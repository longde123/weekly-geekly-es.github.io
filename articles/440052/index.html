<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèª üìû üôçüèæ An√°lisis est√°tico de BIOS / UEFI o c√≥mo obtener un gr√°fico de dependencia üë∂üèΩ üåÜ üëâüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Termin√© de forjar ayer, 
 Enga√±√© dos planes ... " 
 ... Canci√≥n VS Vysotsky ... 
 Hace casi 3 a√±os (a principios de 2016), apareci√≥ el deseo de un us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis est√°tico de BIOS / UEFI o c√≥mo obtener un gr√°fico de dependencia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440052/"><table><tbody><tr><td width="480"><img src="https://habrastorage.org/webt/bh/jy/lo/bhjylo0e06sv0b9flvjqzb4e62u.png" width="480"></td><td align="right">  <i>"Termin√© de forjar ayer,</i> <i><br></i>  <i>Enga√±√© dos planes ... "</i> <i><br></i>  <i>... Canci√≥n VS Vysotsky ...</i> </td></tr></tbody></table><br>  Hace casi 3 a√±os (a principios de 2016), apareci√≥ el deseo de un usuario sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tema</a> del proyecto UEFITool en GitHub: construir un "Gr√°fico de dependencia" para m√≥dulos ejecutables incluidos en BIOS / UEFI. <br><br>  Incluso se produjo una peque√±a discusi√≥n, como resultado de lo cual finalmente qued√≥ claro que esta tarea no es en absoluto trivial, la funcionalidad disponible para su soluci√≥n no es suficiente, las perspectivas en ese momento son nebulosas ... <br><br>  Y esta pregunta permaneci√≥ en el limbo, con la perspectiva de realizarse en un futuro indefinido (pero el deseo probablemente permaneci√≥, y la esperanza, como saben, ¬°muere al final!). <br><br>  Hay una sugerencia: ¬°finalmente, encuentre una soluci√≥n a este problema! <br><a name="habracut"></a><br><h2>  Define los t√©rminos </h2><br>  Se supone adem√°s que estamos lidiando con la arquitectura Intel 64 e IA-32. <br><br>  Para determinar inequ√≠vocamente lo que decidimos construir, tendremos que tratar con m√°s detalle el funcionamiento de las fases individuales de la operaci√≥n BIOS / UEFI. <br><br>  Si observa detenidamente los tipos de archivo presentados en los vol√∫menes de firmware de <abbr title="Sistema de archivos de firmware">FFS</abbr> , resulta que la mayor√≠a de los archivos disponibles incluyen una secci√≥n con m√≥dulos ejecutables. <br><br>  Incluso si consideramos el nuevo firmware de ASUS o ASRock, en el que puede encontrar sin esfuerzo hasta un mill√≥n y medio de archivos del tipo EFI_FV_FILETYPE_FREEFORM que contienen im√°genes de diferentes formatos, sin embargo, incluso en estos firmwares hay m√°s archivos ejecutables que archivos de otros tipos. <br><br><pre><code class="plaintext hljs">+--------------------------------------------------------------------------+ | File Types Information | +--------------------------------------------------------------------------+ | EFI_FV_FILETYPE_RAW = 6 | | EFI_FV_FILETYPE_FREEFORM = 83 | | EFI_FV_FILETYPE_SECURITY_CORE = 1 | | EFI_FV_FILETYPE_PEI_CORE = 1 | | EFI_FV_FILETYPE_DXE_CORE = 1 | | EFI_FV_FILETYPE_PEIM = 57 | | EFI_FV_FILETYPE_DRIVER = 196 | | EFI_FV_FILETYPE_APPLICATION = 1 | | EFI_FV_FILETYPE_SMM = 60 | | EFI_FV_FILETYPE_SMM_CORE = 1 | | EFI_FV_FILETYPE_PAD = 4 | +--------------------------------------------------------------------------+ | Total Files : = 411 | +--------------------------------------------------------------------------+</code> </pre>  <b>Un ejemplo de la composici√≥n de alg√∫n firmware ordinario (ordinario).</b> <br><br>  Aunque los archivos que contienen m√≥dulos ejecutables no est√°n marcados en esta tabla, sin embargo, (por definici√≥n) estar√°n todos en esta lista, excepto los archivos con los sufijos RAW, FREEFORM y PAD. <br><br>  Los archivos con el sufijo "CORE" (SECURITY_CORE, PEI_CORE y DXE_CORE) son los "n√∫cleos" correspondientes (m√≥dulos principales de la fase correspondiente) que reciben el control de otras fases (o despu√©s del inicio), SMM_CORE es una subfase de la fase DXE y se llama durante ella. cumplimiento  La APLICACI√ìN se puede realizar solo a petici√≥n del usuario, no tiene un enlace espec√≠fico a las fases. <br><br>  Los tipos de archivos m√°s comunes no estaban listados: PEIM (m√≥dulos de fase PEI), DRIVER (m√≥dulos de fase DXE) y SMM (m√≥dulos de subfase DXE).  Los m√≥dulos CORE de las fases PEI y DXE incluyen un despachador, que controla la secuencia de los m√≥dulos de carga / arranque de la fase correspondiente. <br><br>  En el ejemplo anterior, no hay opciones combinadas, no las recordaremos: aunque se encuentran en firmware real, es bastante raro.  Aquellos que deseen recibir informaci√≥n m√°s detallada y detallada est√°n invitados a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">consultar los</a> art√≠culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3 de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">CodeRush</a> .  Y tambi√©n cite su consejo: "Para los fan√°ticos de la documentaci√≥n original, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n UEFI PI</a> siempre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°</a> disponible, todo se describe con mucho m√°s detalle". <br><br>  Cada m√≥dulo de firmware ejecutable es un m√≥dulo de formato PE + (Portable Ejecutable) o su derivado (Terse Executable: formato TE).  El m√≥dulo ejecutable en formato PE + es un conjunto de datos estructurados "ligeramente" empaquetados que contienen la informaci√≥n que necesita el cargador para asignar este m√≥dulo a la memoria. <br><br>  El formato (estructura) PE + en s√≠ mismo no tiene ning√∫n mecanismo de interacci√≥n entre los m√≥dulos PE + individuales.  Cada m√≥dulo ejecutable despu√©s de cargar e iniciar la ejecuci√≥n es un proceso aut√≥nomo independiente <b>(bueno, ¬°deber√≠a ser as√≠!)</b> , Es decir  el m√≥dulo no debe "asumir" nada sobre lo que se est√° haciendo fuera de √©l. <br><br>  La organizaci√≥n de la interacci√≥n entre m√≥dulos ejecutables separados de una fase UEFI se organiza mediante el m√≥dulo CORE de la fase correspondiente.  Los m√≥dulos ejecutables separados pueden definir (Instalar) protocolos, solicitar (Localizar) y usar protocolos declarados por otros m√≥dulos, establecer / declarar eventos, declarar (Notificar) manejadores de eventos. <br><br>  Por lo tanto, para cada m√≥dulo de firmware ejecutable, estamos interesados ‚Äã‚Äãen la presencia de los siguientes artefactos: <br><br><ol><li>  Lista de protocolos que define este m√≥dulo.  (Cada protocolo se identifica mediante un n√∫mero √∫nico: guid). </li><li>  Lista de protocolos que usa este m√≥dulo (intenta usar). </li><li>  Lista de eventos que anuncia este m√≥dulo.  (El evento tiene un n√∫mero √∫nico: guid). </li><li>  Una lista de controladores de eventos presentes (implementados y se pueden instalar / inicializar) en este m√≥dulo. </li></ol><blockquote>  <i><u>Un gr√°fico de dependencia est√°tica</u></i> para una fase BIOS / UEFI dada se considera definido si, para cada m√≥dulo de fase ejecutable, conocemos todos los artefactos enumerados anteriormente en las secciones 1-4.  (En otras palabras, si hemos definido toda la informaci√≥n que describe las interdependencias entre los m√≥dulos). </blockquote>  Consideraremos solo la opci√≥n de an√°lisis est√°tico, esto significa que algunos elementos del c√≥digo que implementan los elementos 1-4 pueden ser inalcanzables (son fragmentos del c√≥digo "inactivo") o se podr√°n lograr solo con ciertas opciones para datos / par√°metros de entrada. <br><br>  Todo lo que hemos considerado hasta ahora se basa solo en la especificaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BIOS / UEFI</a> .  Y para comprender las "relaciones" de los m√≥dulos ejecutables existentes del firmware en cuesti√≥n, tendremos que profundizar en su estructura, lo que significa que deber√≠amos revertirlos al menos parcialmente (restaurar los algoritmos originales). <br><br>  Como ya se mencion√≥ anteriormente, el m√≥dulo ejecutable en formato PE + es solo un conjunto de estructuras para el cargador, que construye en la memoria un objeto al que se transferir√° el control, y este objeto por su naturaleza consiste en instrucciones del procesador, as√≠ como datos para estas instrucciones. <br><blockquote>  Diremos que se <i><u>realiz√≥</u></i> un <i><u>desmontaje completo del</u></i> m√≥dulo ejecutable si fuera posible resolver el problema de separar los comandos y los datos presentados en este m√≥dulo. </blockquote>  Al mismo tiempo, no impondremos ning√∫n requisito sobre la estructura y los tipos de datos, es suficiente si por cada byte que pertenece a la imagen del m√≥dulo ejecutable recibido por el cargador, podemos decir claramente a cu√°l de las dos categor√≠as pertenece: byte de comando o byte de datos. <br><br>  La tarea de <i><u>desmontar completamente el</u></i> m√≥dulo ejecutable en s√≠ mismo generalmente no es trivial, adem√°s, en el caso general, no es solucionable algor√≠tmicamente.  No entraremos en detalles sobre este tema, tampoco romperemos las lanzas, consideramos esta afirmaci√≥n como un axioma. <br><br>  Supongamos: <br><br><ol><li>  Ya hemos resuelto el problema del <i><u>desmontaje completo</u></i> para un m√≥dulo de ejecuci√≥n BIOS / UEFI espec√≠fico, es decir.  Logramos separar comandos y datos. </li><li>  Existe el c√≥digo fuente del m√≥dulo en el lenguaje "C" (en el firmware BIOS / UEFI actual, los m√≥dulos se desarrollan principalmente en el lenguaje "C"). </li></ol><br>  Incluso en este caso, simplemente comparar los resultados obtenidos (el texto del ensamblador es solo una representaci√≥n textual de las instrucciones del procesador) con el c√≥digo fuente en el lenguaje "C" requerir√° casi siempre una buena experiencia / calificaci√≥n, con la excepci√≥n de casos absolutamente degenerados. <br><br>  Un estudio completo de ejemplos que muestran dificultades para identificar o comparar los resultados del desensamblaje con el c√≥digo fuente no forma parte de nuestros planes actuales. <br>  Consideremos solo un ejemplo cuando en la lista de ensambladores nos encontramos con el comando <b>"Llamada indirecta"</b> , una llamada a procedimiento impl√≠cito. <br><br>  Este es un ejemplo de una llamada a procedimiento referenciada en una tabla.  Una tabla que contiene enlaces a varios procedimientos es un caso t√≠pico de implementaci√≥n de la presentaci√≥n de interfaces de un protocolo arbitrario. <br><br>  Dicha tabla no tiene que consistir √∫nicamente en referencias a procedimientos; nadie proh√≠be almacenar datos arbitrarios en esta estructura (y este es un ejemplo de una estructura t√≠pica "C"). <br><br>  Aqu√≠ hay una forma de dicha llamada (en lugar del registro ecx, son posibles casi todas las variantes de los registros del procesador de 32 bits): <br><blockquote>  FF 51 18 call dword ptr [ecx + 18h] </blockquote>  Despu√©s de obtener, despu√©s del an√°lisis, un comando similar, es posible averiguar qu√© tipo de procedimiento se llama, una lista de sus par√°metros, el tipo y el valor del resultado devuelto, es posible solo si conocemos el tipo de objeto (protocolo) cuya interfaz se llama mediante este comando. <br><br>  Si sabemos que en el ejemplo anterior el registro "ecx" contiene un puntero (la direcci√≥n del comienzo de la tabla EFI_PEI_SERVICES), podemos recibir (presentar) este comando de la siguiente manera m√°s comprensible y "agradable": <blockquote>  Llamada FF 51 18 [exx + EFI_PEI_SERVICES.InstallPpi] </blockquote>  La obtenci√≥n de informaci√≥n sobre el contenido del registro que participa en el comando <b>"Llamada indirecta" con</b> frecuencia va m√°s all√° de las capacidades de un desensamblador "t√≠pico", cuya tarea es simplemente analizar y convertir el c√≥digo binario (binario) del procesador en una forma legible para los humanos: una representaci√≥n textual del comando del procesador correspondiente. <br><br>  Para resolver este problema, a menudo se requiere el uso de informaci√≥n adicional (Meta) que no est√° disponible en el m√≥dulo ejecutable binario (perdido como resultado de la compilaci√≥n y la vinculaci√≥n; se usa en transformaciones de una representaci√≥n del algoritmo a otra, pero el procesador ya no necesita ejecutar los comandos recibidos). <br><br>  Si estos Metadatos a√∫n est√°n disponibles para nosotros desde fuentes adicionales, us√°ndolos y realizando an√°lisis adicionales, obtenemos una representaci√≥n m√°s comprensible (y m√°s precisa) del comando <b>"Llamada indirecta"</b> . <br><br>  De hecho, este an√°lisis avanzado ya recuerda m√°s el proceso de "descompilaci√≥n", aunque el resultado no se parece al c√≥digo fuente del m√≥dulo en el lenguaje "C", sin embargo, en el futuro nos referiremos a este proceso como la <i>descompilaci√≥n de comandos que son <b>"Llamada indirecta"</b></i> o <i>" descompilaci√≥n parcial</i> <br><br>  Entonces, estamos listos para determinar las condiciones suficientes para construir el gr√°fico de la interdependencia de los m√≥dulos de firmware ejecutables para la fase BIOS / UEFI dada: <br><blockquote>  Para obtener un <u><i>gr√°fico de dependencia est√°tica</i></u> (cualquiera de las fases: PEI o DXE), es <b><i>suficiente</i></b> desmontar completamente todos los m√≥dulos ejecutables de la fase correspondiente (al menos separar todos los comandos) y descompilar los comandos de <b>"Llamada indirecta"</b> presentes en los m√≥dulos desmontados. </blockquote>  Inmediatamente hay muchas preguntas sobre c√≥mo nuestro conocimiento de los equipos de <b>"Llamada indirecta"</b> est√° conectado con las interacciones entre m√≥dulos. <br>  Como se mencion√≥ anteriormente, todo el servicio de gesti√≥n de interacci√≥n es provisto por el m√≥dulo "CORE" de la fase correspondiente, y los servicios en las fases est√°n dise√±ados como tablas de servicios "b√°sicos". <br><br>  Dado que los modelos de interacci√≥n entre los m√≥dulos en las fases PEI y DXE, aunque son ideol√≥gicamente (estructuralmente) similares, son t√©cnicamente diferentes, se propone pasar de algunas consideraciones formales a considerar una construcci√≥n directa espec√≠fica de un <u><i>Gr√°fico de Dependencia Est√°tica</i></u> para la fase PEI. <br><br>  Incluso podremos determinar y formular las condiciones <b><i>necesarias y suficientes</i></b> para la posibilidad de construir un <u><i>Gr√°fico de Dependencia Est√°tica</i></u> para la fase PEI. <br><br><h2>  Creaci√≥n de un <i><u>gr√°fico de dependencia est√°tica</u></i> para la fase PEI </h2><br>  Las descripciones de la soluci√≥n al problema del <u><i>desmontaje completo de</i></u> los m√≥dulos ejecutables de la fase PEI y la descompilaci√≥n de <b>los</b> comandos de <b>Llamada indirecta</b> presentes en estos m√≥dulos est√°n m√°s all√° del alcance de nuestra historia y no se dar√°n en √©l: la presentaci√≥n de este material en volumen puede exceder el tama√±o de esta obra. <br><br>  Es posible que con el tiempo esto suceda como un material separado, pero por ahora, sepa c√≥mo. <br><br>  Solo notamos que el uso de Metadatos, m√°s la presencia de una determinada estructura para construir c√≥digo binario, hace posible en la pr√°ctica <i><u>desmontar completamente</u></i> los m√≥dulos ejecutables BIOS / UEFI.  La prueba formal de este hecho no se supone ahora ni en el futuro.  Al menos en el an√°lisis / procesamiento de m√°s de cien (100) BIOS / UEFI de varios fabricantes, no hubo ejemplos en los que no <i><u>fuera</u></i> posible el <i><u>desmontaje completo</u></i> . <br><br>  Adem√°s, solo resultados espec√≠ficos (con explicaciones: qu√©, c√≥mo y cu√°nto ...). <br><br>  La estructura EFI_PEI_SERVICES es la estructura b√°sica de la fase PEI, que se pasa como par√°metro al punto de entrada de cada m√≥dulo PEI y contiene enlaces a los servicios b√°sicos necesarios para que funcionen los m√≥dulos PEI. <br><br>  Solo nos interesar√°n los campos ubicados al comienzo de la estructura: <br><br><img src="https://habrastorage.org/webt/w_/iz/_m/w_iz_mocpact66z4c382r0o53zc.png"><br><br>  <b>Un fragmento de una estructura real de tipo EFI_PEI_SERVICES en el desensamblador IDA Pro.</b> <br><br>  Y as√≠ es como aparece en el c√≥digo fuente en el lenguaje "C" (recuerde, esto es solo un fragmento de la estructura): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_PEI_SERVICES</span></span></span><span class="hljs-class"> {</span></span> EFI_TABLE_HEADER Hdr; EFI_PEI_INSTALL_PPI InstallPpi; EFI_PEI_REINSTALL_PPI ReInstallPpi; EFI_PEI_LOCATE_PPI LocatePpi; EFI_PEI_NOTIFY_PPI NotifyPpi; <span class="hljs-comment"><span class="hljs-comment">//...      ... };</span></span></code> </pre> <br>  Al comienzo de la estructura EFI_PEI_SERVICES, como en todas las tablas de servicio "b√°sicas" (Tablas de servicios), se encuentra la estructura EFI_TABLE_HEADER.  Los valores presentados en esta estructura de encabezado nos permiten afirmar inequ√≠vocamente que si la estructura EFI_PEI_SERVICES en s√≠ misma est√° realmente presente en el fragmento del desensamblador (consulte el campo "Firma HDR"), ¬°al menos la plantilla de esta estructura! <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EFI_TABLE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT64 Signature; UINT32 Revision; UINT32 HeaderSize; UINT32 CRC32; UINT32 Reserved; };</code> </pre> <br>  En el camino, podemos establecer que el firmware se estaba desarrollando en un momento en que la versi√≥n de la especificaci√≥n UEFI PI era 1.2, cuyo per√≠odo de relevancia era de 2009 a 2013, pero en este momento (principios de 2019), la versi√≥n actual de la especificaci√≥n ya ha crecido (literalmente creci√≥ el otro d√≠a) a la versi√≥n 1.7. <br><br>  Desde el campo "Hdr.HeaderSize", puede determinar que la longitud total de la estructura es 78 h (y esta no es la longitud del encabezado, como su nombre lo indica, sino la longitud de toda la estructura de EFI_PEI_SERVICES). <br><br>  Las interfaces EFI_PEI_SERVICES se dividen en 7 categor√≠as / clases.  Solo los enumeramos: <br><br><ol><li>  Servicios PPI. </li><li>  Servicios de modo de arranque. </li><li>  Servicios HOB. </li><li>  Servicios de volumen de firmware. </li><li>  Servicios de memoria PEI. </li><li>  Servicios de c√≥digo de estado. </li><li>  Restablecer servicios. </li></ol><br>  Toda narraci√≥n adicional estar√° directamente relacionada con los procedimientos que pertenecen a la categor√≠a / clase de Servicios PPI, destinados a la organizaci√≥n de la interacci√≥n entre m√≥dulos de los m√≥dulos ejecutables de la fase PEI. <br><br>  Y solo hay cuatro para la fase PEI. <br><br>  En general, no es necesario adivinar el prop√≥sito de cada una de las interfaces: la funcionalidad est√° completamente determinada por el nombre de la interfaz, todos los detalles est√°n en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> . <br><br>  Los siguientes son prototipos de estos procedimientos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_INSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *PpiList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_REINSTALL_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *OldPpi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_PPI_DESCRIPTOR *NewPpi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_LOCATE_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_GUID *Guid, UINTN Instance, EFI_PEI_PPI_DESCRIPTOR **PpiDescriptor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **Ppi)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EFI_STATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__cdecl *EFI_PEI_NOTIFY_PPI)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_SERVICES **PeiServices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EFI_PEI_NOTIFY_DESCRIPTOR *NotifyList)</span></span></span></span>;</code> </pre> <br>  Solo notamos que adem√°s de los comandos de <b>"Llamada indirecta"</b> que invocan los procedimientos / interfaces de la clase "Servicios PPI", es posible una llamada expl√≠cita (directa - no tabular) a estos procedimientos, lo que a veces ocurre en los m√≥dulos ejecutivos, donde se define / crea la estructura EFI_PEI_SERVICES. <br><br>  Te dir√© un peque√±o secreto: curiosamente, aunque esta es la tabla de servicios "b√°sica" para la fase PEI, sin embargo, como muestra la pr√°ctica, se puede definir no solo en el m√≥dulo PEI_CORE. <br><br>  En la naturaleza real, hay firmwares en los que la estructura EFI_PEI_SERVICES se defini√≥ / form√≥ y se us√≥ en varios m√≥dulos, y de ninguna manera fueron copias del m√≥dulo PEI_CORE. <br><br>  Por lo tanto, las siguientes opciones de c√≥digo son posibles: <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>0D B8 <span class="hljs-number"><span class="hljs-number">8</span></span>C A6 <span class="hljs-number"><span class="hljs-number">78</span></span>+ mov eax, offset ppiList_78A68C seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>12 <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>13 <span class="hljs-number"><span class="hljs-number">57</span></span> push edi ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>14 <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>E+ mov [esi+<span class="hljs-number"><span class="hljs-number">0E40</span></span>h], eax seg000:<span class="hljs-number"><span class="hljs-number">00785F</span></span>1A E8 <span class="hljs-number"><span class="hljs-number">70</span></span> FC FF+ call InstallPpi</code> </pre> <br>  <b>Un ejemplo de una llamada expl√≠cita al procedimiento "InstallPpi".</b> <br><br><pre> <code class="cpp hljs">seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBB <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>D FC mov ecx, [ebp+PeiServices] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBE <span class="hljs-number"><span class="hljs-number">50</span></span> push eax ; PpiList seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CBF C7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>+ mov dword ptr [eax], <span class="hljs-number"><span class="hljs-number">80000010</span></span>h seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CC5 C7 <span class="hljs-number"><span class="hljs-number">43</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>C A8+ mov dword ptr [ebx+<span class="hljs-number"><span class="hljs-number">3</span></span>Ch], offset guid_78A9A8 seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCC <span class="hljs-number"><span class="hljs-number">8B</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> mov edx, [ecx] seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCE <span class="hljs-number"><span class="hljs-number">51</span></span> push ecx ; PeiServices seg000:<span class="hljs-number"><span class="hljs-number">00787</span></span>CCF FF <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [edx+EFI_PEI_SERVICES.InstallPpi]</code> </pre> <br>  <b>Un ejemplo de una llamada impl√≠cita a la interfaz InstallPpi.</b> <br><br><pre> <code class="cpp hljs">FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">18</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> call [ex+EFI_PEI_SERVICES.InstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">1</span></span>Ch] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>C call [ex+EFI_PEI_SERVICES.ReInstallPpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> call [ex+EFI_PEI_SERVICES.LocatePpi] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call dword ptr [ecx+<span class="hljs-number"><span class="hljs-number">24</span></span>h] FF <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> call [ex+EFI_PEI_SERVICES.NotifyPpi]</code> </pre>  <b>Ejemplos de llamadas de interfaz impl√≠citas antes y despu√©s de la autenticaci√≥n.</b> <br><br>  Observamos una caracter√≠stica: en el caso de la fase PEI para la arquitectura IA-32, las interfaces de la clase de servicios PPI tienen compensaciones de 18h, 1Ch, 20h y 24h. <br><br>  Y ahora declaramos la siguiente declaraci√≥n: <br><blockquote>  Para construir un <u><i>Gr√°fico de Dependencia Est√°tica de la</i></u> fase PEI, <b>es necesario y suficiente</b> <u><i>desmontar completamente</i></u> todos los m√≥dulos ejecutables de la fase (al menos separar todos los comandos) y descompilar los comandos de <b>"Llamada indirecta"</b> con compensaciones 18h, 1Ch, 20h, 24h en m√≥dulos desmontados. </blockquote>  De hecho, hemos formulado completamente un algoritmo para resolver el problema, y ‚Äã‚Äãtan pronto como logramos aislar todas las llamadas a las interfaces / procedimientos de la clase de Servicios PPI, solo queda determinar qu√© par√°metros se pasan a estas llamadas.  La tarea puede no ser la m√°s trivial, pero, como lo ha demostrado la pr√°ctica, es completamente solucionable, tenemos todos los datos para esto. <br><br>  Y ahora ejemplos reales de datos reales para m√≥dulos de fase PEI reales.  No indicamos a sabiendas qu√© resultados de BIOS / UEFI de la empresa se obtuvieron, solo damos ejemplos de c√≥mo se ven. <br><br><h2>  Dos ejemplos de descripciones de m√≥dulos PEIM con informaci√≥n completa sobre el uso de las interfaces de servicios PPI en estos m√≥dulos </h2><br><pre> <code class="plaintext hljs"> -- File 04-047/0x02F/: "TcgPlatformSetupPeiPolicy" : [007CCAF0 - 007CD144] DEPENDENCY_START EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI DEPENDENCY_END Install Protocols: [1] TCG_PLATFORM_SETUP_PEI_POLICY Locate Protocols: [2] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI</code> </pre><pre> <code class="plaintext hljs">-- File 04-048/0x030/: "TcgPei" : [007CD160 - 007CF5DE] DEPENDENCY_START EFI_PEI_MASTER_BOOT_MODE_PEIM_PPI EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI AND DEPENDENCY_END Install Protocols: [1] AMI_TCG_PLATFORM_PPI [2] EFI_PEI_TCG_PPI [2] PEI_TPM_PPI Locate Protocols: [1] EFI_PEI_TCG_PPI [1] EFI_PEI_READ_ONLY_VARIABLE_ACCESS_PPI [1] TCG_PLATFORM_SETUP_PEI_POLICY [5] PEI_TPM_PPI Notify Events: [1] AMI_TCM_CALLBACK ReInstall Protocols: [1] PEI_TPM_PPI</code> </pre><br><h2>  Listas de protocolos por tipos de interfaces en las que se utilizaron. </h2><br>  A continuaci√≥n, debajo de los spoilers, hay ejemplos abreviados de listas de protocolos PPIM para cada una de las interfaces de la clase de Servicios PPI. <br><br>  El formato de las listas es el siguiente: <br><pre> El |  n√∫mero de serie |  name_PPI |  guid_PPI |  nombre_ejecutable: nombre de usuario |
</pre><br><div class="spoiler">  <b class="spoiler_title">***** Instale 99 Ppi en "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/kl/o_/-q/klo_-qpqz-m_lokouctilmlnbxw.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Localice 194 Ppi en "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/bl/30/_ibl301bqdkcqk33z-i7ifzqejk.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Vuelva a instalar 5 Ppi en "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/7g/pe/xb/7gpexbxvf_k4sla038anu32el7s.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">***** Notifique 29 Ppi en "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ui/fj/m6/uifjm6sznoctafiav_4cez64ezc.png"><br></div></div><br><h2>  La lista final de todas las gu√≠as de los protocolos a los que se hace referencia en un BIOS / UEFI particular con una leyenda que indica en qu√© "Servicios PPI" se encuentran estos protocolos </h2><br>  A continuaci√≥n se muestra una lista de spoilers de 97 PPi-gu√≠as encontradas y utilizadas expl√≠citamente en un firmware espec√≠fico, cuyos datos se proporcionaron anteriormente. <br><br>  Cada elemento de la lista est√° precedido por una leyenda, que refleja todos los tipos de uso de un protocolo en particular. <br><br><pre> <code class="plaintext hljs">"D" - in DEPENDENCY section used "I" - in "InstallPpi" functions used "L" - in "LocatePpi" functions used "R" - in "ReInstallPpi" functions used "N" - in "NotifyPpi" functions used</code> </pre><br><div class="spoiler">  <b class="spoiler_title">***** Lista Ppi en "Firmware"</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wn/cm/8y/wncm8ymfrh-8oxdssbu0kuazejc.png"><br><img src="https://habrastorage.org/webt/t1/sn/xq/t1snxq4jhzprqvwoq93ithtlfow.png"><br><img src="https://habrastorage.org/webt/y1/tg/mz/y1tgmz0bysbuzmszkope_hegfoa.png"><br></div></div><br>  Los siguientes intervalos de la lista de protocolos son notables en este BIOS / UEFI: <br><br><ol><li>  No. 38-50. <br>  Definici√≥n de protocolos / eventos (InstallPpi) que ning√∫n m√≥dulo utiliza. </li><li>  No. 87-95. <br>  Intente solicitar protocolos que no fueron instalados por ning√∫n m√≥dulo de este firmware. <br></li><li>  No. 96-97. <br>  Dos eventos "Notificar", para los cuales ning√∫n m√≥dulo se molest√≥ en declarar la interfaz correspondiente, respectivamente, aunque estos procedimientos se declaran en m√≥dulos ejecutables, nunca funcionar√°n. </li></ol><br><h2>  Conclusi√≥n </h2><br><ul><li>  Se obtuvieron resultados similares a los anteriores para BIOS / UEFI de varios fabricantes, por lo que todos los ejemplos son an√≥nimos. </li><li>  De hecho, se resolvieron tareas m√°s generales de revertir los algoritmos de los m√≥dulos ejecutables BIOS / UEFI, y el gr√°fico resultante es un resultado secundario, una especie de bonificaci√≥n adicional. </li><li><blockquote>  La soluci√≥n correcta de la tarea <i><u>"Obtenci√≥n del gr√°fico de dependencia est√°tica"</u></i> para los m√≥dulos ejecutables BIOS / UEFI requiere un an√°lisis est√°tico del c√≥digo binario, que incluye un <i><u>desmontaje completo de los</u></i> m√≥dulos ejecutables y <i><u>la descompilaci√≥n parcial de</u></i> <b>los</b> comandos de <b>llamada indirecta</b> de estos m√≥dulos. </blockquote></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440052/">https://habr.com/ru/post/440052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440040/index.html">En desarrollo, cada uno por s√≠ mismo. Pero a veces conduce a un callej√≥n sin salida.</a></li>
<li><a href="../440044/index.html">Historia detallada de Qualcomm</a></li>
<li><a href="../440046/index.html">Lecci√≥n abierta "Crear clientes REST en Spring"</a></li>
<li><a href="../440048/index.html">M√©tricas favoritas: 5 indicadores que todo equipo de ventas debe seguir</a></li>
<li><a href="../440050/index.html">Proxies DNS de bricolaje en Node.JS</a></li>
<li><a href="../440054/index.html">Transfiera el servicio web a Yandex.Cloud con AWS</a></li>
<li><a href="../440058/index.html">Problemas de Internet e Informe de disponibilidad 2018‚Äì2019</a></li>
<li><a href="../440060/index.html">TensorFlow en Apache Ignite</a></li>
<li><a href="../440062/index.html">Planificaci√≥n con mucho gusto. C√≥mo configuramos procesos sin gerentes</a></li>
<li><a href="../440064/index.html">Centros de datos para elegir: Londres, Mosc√∫, Z√∫rich, San Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>