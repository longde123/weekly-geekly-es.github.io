<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 🛎️ 👁‍🗨 Ein moderner Ansatz für den Wettbewerb in Android: Corotins bei Kotlin 🙊 👨🏽‍⚖️ 😬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Wir erinnern Sie daran, dass wir bereits eine Vorbestellung für das lang erwartete Buch über die Kotlin-Sprache aus der berühmten Big N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein moderner Ansatz für den Wettbewerb in Android: Corotins bei Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"> Hallo Habr! <br><br>  Wir erinnern Sie daran, dass wir bereits eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorbestellung für das lang erwartete Buch</a> über die Kotlin-Sprache aus der berühmten Big Nerd Ranch Guides-Reihe haben.  Heute haben wir beschlossen, Sie auf eine Übersetzung eines Artikels aufmerksam zu machen, der über Kotlin-Coroutinen und die korrekte Arbeit mit Streams in Android berichtet.  Das Thema wird sehr aktiv diskutiert. Der Vollständigkeit halber empfehlen wir Ihnen daher, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> von Habr und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen ausführlichen Beitrag</a> aus dem Axmor Software-Blog zu lesen. <br><a name="habracut"></a><br>  Das moderne Wettbewerbs-Framework in Java / Android verursacht Rückrufe und führt zu Blockierungszuständen, da Android keine relativ einfache Möglichkeit bietet, die Thread-Sicherheit zu gewährleisten. <br><br>  Kotlin Coroutinen sind ein sehr effektives und vollständiges Toolkit, das die Verwaltung des Wettbewerbs viel einfacher und produktiver macht. <br><br>  <b>Pause und Block: Was ist der Unterschied?</b> <br><br>  Coroutinen ersetzen keine Threads, sondern bieten einen Rahmen für deren Verwaltung.  Die Philosophie von corutin besteht darin, einen Kontext zu definieren, in dem Sie <b>warten</b> können, bis Hintergrundvorgänge abgeschlossen sind, ohne den Hauptthread zu blockieren. <br><br>  Corutins Ziel ist es in diesem Fall, auf Rückrufe zu verzichten und den Wettbewerb zu vereinfachen. <br><br>  <b>Einfachstes Beispiel</b> <br><br>  Nehmen wir zunächst das einfachste Beispiel: Führen Sie coroutine im Kontext von <code>Main</code> (Hauptthread) aus.  Darin extrahieren wir das Bild aus dem <code>IO</code> Stream und senden dieses Bild zur Verarbeitung zurück an <code>Main</code> . <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  Der Code ist als Single-Thread-Funktion einfach.  Während <code>getImage</code> im zugewiesenen Pool von <code>getImage</code> Threads ausgeführt wird, ist der Hauptthread außerdem frei und kann jede andere Aufgabe übernehmen!  Die Funktion withContext hält die aktuelle Coroutine an, während ihre Aktion ausgeführt wird ( <code>getImage()</code> ).  Sobald <code>getImage()</code> zurückkehrt und der <code>looper</code> aus dem Hauptthread verfügbar wird, nimmt <code>imageView.setImageBitmap(image)</code> die Arbeit im Hauptthread wieder auf und ruft <code>imageView.setImageBitmap(image)</code> . <br><br>  Das zweite Beispiel: Jetzt müssen zwei Hintergrundaufgaben erledigt werden, damit sie verwendet werden können.  Wir werden das Duett async / await verwenden, damit diese beiden Aufgaben parallel ausgeführt werden, und ihr Ergebnis im Hauptthread verwenden, sobald beide Aufgaben fertig sind: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> ähnelt dem <code>launch</code> , gibt jedoch eine <code>deferred</code> Rückgabe zurück (eine Kotlin-Entität, die <code>Future</code> ), sodass das Ergebnis mit <code>await()</code> abgerufen werden kann.  Wenn es ohne Parameter aufgerufen wird, funktioniert es im Standardkontext für den aktuellen Bereich. <br><br>  Auch hier bleibt der Haupt-Thread frei, während wir auf unsere 2 Werte warten. <br>  Wie Sie sehen können, gibt die Startfunktion <code>Job</code> , mit dem gewartet werden kann, bis der Vorgang abgeschlossen ist. Dies erfolgt über die Funktion <code>join()</code> .  Es funktioniert wie in jeder anderen Sprache, mit der Einschränkung, dass es einfach <b>die Coroutine suspendiert und den Fluss nicht blockiert</b> . <br><br>  <b>Versand</b> <br><br>  Dispatching ist ein Schlüsselkonzept bei der Arbeit mit Coroutinen.  Mit dieser Aktion können Sie von einem Thread zum anderen "springen". <br><br>  Überlegen Sie, wie das Äquivalent für den Versand in <code>Main</code> in Java aussieht. <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  Die <code>Handler</code> für Android ist ein <code>Handler</code> basierter Dispatcher.  Das ist also in der Tat eine sehr geeignete Implementierung: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> sendet <code>Runnable</code> an <code>Handler</code> , sodass der Code nicht sofort ausgeführt wird. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> führt seinen Lambda-Ausdruck sofort im aktuellen Thread aus. <br><br>  <code>Dispatchers.Main</code> <b>stellt sicher, dass Coroutine, wenn die Arbeit wieder aufgenommen wird, an den Haupt-Thread weitergeleitet wird</b> .  Darüber hinaus wird Handler hier als native Android-Implementierung zum Senden an die Anwendungsereignisschleife verwendet. <br><br>  Die genaue Implementierung sieht folgendermaßen aus: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Hier ist ein guter Artikel, der Ihnen hilft, die Feinheiten des Versands in Android zu verstehen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu Android Core: Looper, Handler und HandlerThread</a> . <br><br>  <b>Coroutine-Kontext</b> <br><br>  Der Coroutine-Kontext (auch als Coroutine-Manager bezeichnet) bestimmt, in welchem ​​Thread sein Code ausgeführt wird, was zu tun ist, wenn eine Ausnahme ausgelöst wird, und verweist auf den übergeordneten Kontext, um die Stornierung zu verbreiten. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> alle Coroutinen ab, deren übergeordnetes <code>job.cancel()</code> <code>job</code> .  Ein Ausnahmehandler erhält alle Ausnahmen, die in diesen Coroutinen ausgelöst werden. <br><br>  <b>Geltungsbereich</b> <br><br>  Die <code>coroutineScope</code> Schnittstelle vereinfacht die Fehlerbehandlung: <br>  Wenn eine der Tochter-Coroutinen ausfällt, werden auch der gesamte Bereich und alle untergeordneten Coroutinen storniert. <br><br>  Wenn es im <code>async</code> Beispiel nicht möglich war, den Wert zu extrahieren, während eine andere Aufgabe weiter funktionierte, haben wir einen beschädigten Zustand, und damit muss etwas getan werden. <br><br>  Bei der Arbeit mit <code>useValues</code> wird die Funktion <code>useValues</code> nur aufgerufen, wenn beide Werte erfolgreich extrahiert wurden.  Wenn <code>deferred2</code> fehlschlägt, wird <code>deferred1</code> abgebrochen. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  Sie können auch eine ganze Klasse in den Bereich <code>CoroutineContext</code> , um einen Standard- <code>CoroutineContext</code> dafür <code>CoroutineContext</code> und zu verwenden. <br><br>  Eine Beispielklasse, die die <code>CoroutineScope</code> Schnittstelle implementiert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Ausführen von Corutin in <code>CoroutineScope</code> : <br><br>  Der Standardstart- oder <code>async</code> Manager wird jetzt zum aktuellen Bereichsmanager. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { … } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   … } launch(Dispatchers.Default) { // -        … }</span></span></code> </pre> <br>  Autonomer Start von Coroutine (außerhalb eines CoroutineScope): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . … }</span></span></code> </pre> <br>  Sie können den Bereich für eine Anwendung sogar definieren, indem Sie den Standard- <code>Main</code> festlegen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Bemerkungen</b> <br><br><ul><li>  Coroutinen beschränken die Interoperabilität mit Java </li><li>  Begrenzen Sie die Veränderlichkeit, um Sperren zu vermeiden </li><li>  Coroutinen sollen warten, nicht Threads organisieren </li><li>  Vermeiden Sie E / A in <code>Dispatchers.Default</code> (und <code>Main</code> ...) - dafür ist Dispatchers.IO gedacht </li><li>  Streams sind ressourcenintensiv, daher werden Single-Threaded-Kontexte verwendet </li><li>  <code>Dispatchers.Default</code> basiert auf <code>ForkJoinPool</code> , das in Android 5+ eingeführt wurde </li><li>  Coroutinen können über Kanäle verwendet werden </li></ul><br>  <b>Sperren und Rückrufe über Kanäle beseitigen</b> <br><br>  Kanaldefinition aus der JetBrains-Dokumentation: <br><br><blockquote>  Kanal <code>Channel</code> <code>BlockingQueue</code> konzeptionell sehr ähnlich.  Der Hauptunterschied besteht darin, dass der Put-Vorgang nicht blockiert wird, ein Suspend- <code>send</code> (oder ein nicht blockierendes <code>offer</code> ) vorgesehen ist und statt des Take-Vorgangs ein Suspend- <code>receive</code> . </blockquote><br><br>  <b>Schauspieler</b> <br><br>  Stellen Sie sich ein einfaches Werkzeug für die Arbeit mit Kanälen vor: <code>Actor</code> . <br><br>  <code>Actor</code> ist wiederum <code>Handler</code> sehr ähnlich: Wir definieren den Kontext der Coroutine (dh den Thread, in dem wir Aktionen ausführen werden) und arbeiten in einer sequentiellen Reihenfolge damit. <br><br>  Der Unterschied besteht natürlich darin, dass hier Corutine verwendet werden;  <b>Sie können die Leistung und die ausgeführte Codepause angeben</b> . <br><br>  Im Prinzip leitet der <code>actor</code> jeden Befehl an den Coroutine-Kanal weiter.  Es <b>garantiert die Ausführung eines Befehls und schränkt Operationen in seinem Kontext ein</b> .  Dieser Ansatz hilft perfekt dabei, <code>synchronize</code> Anrufe loszuwerden und alle Threads frei zu halten! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  In diesem Beispiel verwenden wir die versiegelten Kotlin-Klassen und wählen aus, welche Aktion ausgeführt werden soll. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  Darüber hinaus werden alle diese Aktionen in die Warteschlange gestellt und niemals parallel ausgeführt.  Dies ist ein bequemer Weg, um <b>Variabilitätsgrenzen</b> zu erreichen. <br><br>  <b>Android Lebenszyklus + Coroutinen</b> <br><br>  Akteure können auch sehr nützlich sein, um die Android-Benutzeroberfläche zu steuern, das Abbrechen von Aufgaben zu vereinfachen und eine Überlastung des Hauptthreads zu verhindern. <br>  Lassen Sie uns dies implementieren und <code>job.cancel()</code> aufrufen, wenn die Aktivität zerstört wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  Die <code>SupervisorJob</code> Klasse ähnelt dem regulären <code>Job</code> mit der einzigen Ausnahme, dass sich die Stornierung nur in der Downstream-Richtung erstreckt. <br><br>  Daher brechen wir nicht alle Coroutinen in einer <code>Activity</code> wenn eine davon fehlschlägt. <br><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer Erweiterungsfunktion</a> , mit der Sie von jeder <code>View</code> in <code>CoroutineScope</code> aus auf diesen <code>CoroutineContext</code> zugreifen können, <code>CoroutineContext</code> es etwas besser aus. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Jetzt können wir all dies <code>setOnClick</code> Funktion <code>setOnClick</code> erstellt einen kombinierten Akteur, um seine <code>onClick</code> Aktionen zu steuern.  Bei mehreren Abgriffen werden Zwischenaktionen ignoriert, wodurch ANR-Fehler beseitigt werden (die Anwendung reagiert nicht), und diese Aktionen werden im Rahmen der <code>Activity</code> .  Wenn die Aktivität zerstört wird, wird dies alles abgebrochen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  In diesem Beispiel setzen wir den <code>Channel</code> auf " <code>Conflated</code> , damit einige Ereignisse ignoriert werden, wenn zu viele vorhanden sind.  Sie können es durch <code>Channel.UNLIMITED</code> ersetzen, wenn Sie Ereignisse lieber in die Warteschlange stellen möchten, ohne eines davon zu verlieren, die Anwendung jedoch vor ANR-Fehlern schützen möchten. <br><br>  Sie können auch die Coroutinen- und Lifecycle-Frameworks kombinieren, um das Abbrechen von Aufgaben im Zusammenhang mit der Benutzeroberfläche zu automatisieren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Vereinfachen Sie die Situation mit Rückrufen (Teil 1)</b> <br><br>  Hier erfahren Sie, wie Sie die Verwendung von Callback-basierten APIs mit <code>Channel</code> transformieren. <br><br>  Die API funktioniert folgendermaßen: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> analysiert den Ordner unter <code>url</code> . </li><li>  Der <code>listener</code> empfängt <code>onMediaAdded(media: Media)</code> für jede in diesem Ordner gefundene Mediendatei. </li><li>  <code>listener.onBrowseEnd()</code> wird beim Parsen des Ordners aufgerufen </li></ol><br>  Hier ist die alte <code>refresh</code> im Inhaltsanbieter für den VLC-Browser: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>Wie kann man es verbessern?</b> <br><br>  Erstellen Sie einen Kanal, der in der <code>refresh</code> .  Jetzt leiten Browser-Rückrufe die Medien nur noch auf diesen Kanal und schließen ihn dann. <br><br>  Jetzt ist die <code>refresh</code> klarer geworden.  Sie erstellt einen Kanal, ruft den VLC-Browser auf, erstellt eine Liste mit Mediendateien und verarbeitet diese. <br><br>  Anstelle der <code>consumeEach</code> oder <code>consumeEach</code> Sie <code>for</code> das Warten auf das Medium verwenden. Diese Schleife wird <code>browserChannel</code> sobald der <code>browserChannel</code> geschlossen wird. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Vereinfachung der Situation durch Rückrufe (Teil 2): ​​Nachrüstung</b> <br><br>  Der zweite Ansatz: Wir verwenden überhaupt keine Kotlinx-Coroutinen, sondern ein Coroutine-Kern-Framework. <br><br>  Sehen Sie, wie Coroutinen tatsächlich funktionieren! <br><br>  Die Funktion <code>retrofitSuspendCall</code> umschließt eine <code>Retrofit Call</code> Anforderung, um sie zu einer <code>suspend</code> Funktion zu machen. <br><br>  Mit <code>suspendCoroutine</code> rufen wir die <code>Call.enqueue</code> Methode auf und halten die Coroutine an.  Der auf diese Weise bereitgestellte Rückruf ruft <code>continuation.resume(response)</code> auf, um die Coroutine mit einer Antwort vom Server fortzusetzen, sobald sie empfangen wird. <br><br>  Als nächstes müssen wir nur unsere Retrofit-Funktionen in <code>retrofitSuspendCall</code> kombinieren, um Abfrageergebnisse mit ihnen zurückzugeben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Somit erfolgt der Anruf, der das Netzwerk blockiert, im dedizierten Retrofit-Thread, die Coroutine ist hier und wartet auf eine Antwort vom Server, und es gibt keinen Ort, an dem sie in der Anwendung verwendet werden kann! <br><br>  Diese Implementierung ist von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gildor / Kotlin-Coroutines-Retrofit-Bibliothek</a> inspiriert. <br><br>  Es gibt auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JakeWharton / retrofit2-kotlin-coroutines-Adapter</a> mit einer anderen Implementierung, die ein ähnliches Ergebnis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liefert</a> . <br><br>  <b>Nachwort</b> <br><br>  <code>Channel</code> kann auf viele andere Arten verwendet werden.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BroadcastChannel</a> finden Sie leistungsfähigere Implementierungen, die Sie möglicherweise nützlich finden. <br><br>  Sie können Kanäle auch mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Produzieren</a> erstellen. <br><br>  Schließlich ist es unter Verwendung von Kanälen bequem, die Kommunikation zwischen den Komponenten der Benutzeroberfläche zu organisieren: Der Adapter kann Klickereignisse über <code>Channel</code> oder beispielsweise über <code>Actor</code> an sein Fragment / seine Aktivität übertragen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457224/">https://habr.com/ru/post/de457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457204/index.html">Windows PowerShell und lange Pfade</a></li>
<li><a href="../de457206/index.html">SQL Index Manager - eine lange Geschichte über SQL Server, Grabgraben und Indexpflege</a></li>
<li><a href="../de457208/index.html">Dynamisches Generieren von robots.txt für ASP.NET Core-Sites basierend auf der Umgebung</a></li>
<li><a href="../de457210/index.html">Speichern Sie statische Ressourcen auf Ihrem Hosting</a></li>
<li><a href="../de457212/index.html">Warum ist es nie zu spät, Java (oder andere Java-Sprachen) zu lernen?</a></li>
<li><a href="../de457232/index.html">Roboterbiene "Bumble" - der erste Testflug innerhalb der ISS</a></li>
<li><a href="../de457234/index.html">Produkt kognitive Verzerrung</a></li>
<li><a href="../de457236/index.html">Wie ein IT-Unternehmen Schwierigkeiten hatte, Musik zu verkaufen</a></li>
<li><a href="../de457240/index.html">Nachrichten der Woche: Neuronales Netz und fotografierte Bilder, Wachstum der Yandex-Aktien, Huawei benötigt 1 Milliarde US-Dollar für Patente</a></li>
<li><a href="../de457246/index.html">Wie man 4 LEDs auf CortexM mit C ++ 17, Tupel und ein bisschen Fantasie blinkt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>