<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéΩ üë®üèª‚Äç‚úàÔ∏è üññüèΩ Situaciones excepcionales: parte 1 de 4 üßòüèæ üïó üçã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Es hora de hablar de excepciones o, m√°s bien, de situaciones excepcionales. Antes de comenzar, veamos la definici√≥n. ¬øQu√© es una situ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Situaciones excepcionales: parte 1 de 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454630/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="introduction">  Introduccion </h2><br><p>  Es hora de hablar de excepciones o, m√°s bien, de situaciones excepcionales.  Antes de comenzar, veamos la definici√≥n.  ¬øQu√© es una situaci√≥n excepcional? </p><br><p>  Esta es una situaci√≥n que hace que la ejecuci√≥n del c√≥digo actual o posterior sea incorrecta.  Me refiero diferente de c√≥mo fue dise√±ado o previsto.  Tal situaci√≥n compromete la integridad de una aplicaci√≥n o su parte, por ejemplo, un objeto.  Lleva la aplicaci√≥n a un estado extraordinario o excepcional. </p><br><p>  Pero, ¬øpor qu√© necesitamos definir esta terminolog√≠a?  Porque nos mantendr√° en algunos l√≠mites.  Si no seguimos la terminolog√≠a, podemos alejarnos demasiado de un concepto dise√±ado que puede dar lugar a muchas situaciones ambiguas.  Veamos algunos ejemplos pr√°cticos: <br><br></p><br><pre><code class="plaintext hljs">struct Number { public static Number Parse(string source) { // ... if(!parsed) { throw new ParsingException(); } // ... } public static bool TryParse(string source, out Number result) { // .. return parsed; } }</code> </pre> <br><p>  Este ejemplo parece un poco extra√±o, y es por una raz√≥n.  Hice este c√≥digo ligeramente artificial para mostrar la importancia de los problemas que aparecen en √©l.  Primero, veamos el m√©todo <code>Parse</code> .  ¬øPor qu√© deber√≠a lanzar una excepci√≥n? </p><a name="habracut"></a><br><ul><li>  Porque el par√°metro que acepta es una cadena, pero su salida es un n√∫mero, que es un tipo de valor.  Este n√∫mero no puede indicar la validez de los c√°lculos: simplemente existe.  En otras palabras, el m√©todo no tiene medios en su interfaz para comunicar un problema potencial. </li><li>  Por otro lado, el m√©todo espera una cadena correcta que contenga alg√∫n n√∫mero y no caracteres redundantes.  Si no contiene, hay un problema en los requisitos previos del m√©todo: el c√≥digo que llama a nuestro m√©todo ha pasado datos incorrectos. </li></ul><br><p>  Por lo tanto, la situaci√≥n cuando este m√©todo obtiene una cadena con datos incorrectos es excepcional porque el m√©todo no puede devolver un valor correcto ni nada.  Por lo tanto, la √∫nica forma es lanzar una excepci√≥n. </p><br><p>  La segunda variante del m√©todo puede se√±alar algunos problemas con los datos de entrada: el valor de retorno aqu√≠ es <code>boolean</code> que indica la ejecuci√≥n exitosa del m√©todo.  Este m√©todo no necesita usar excepciones para se√±alar problemas: todos est√°n cubiertos por el valor de retorno <code>false</code> . </p><br><h2 id="overview">  Resumen </h2><br><p>  El manejo de excepciones puede parecer tan f√°cil como ABC: solo necesitamos colocar bloques <code>try-catch</code> y esperar los eventos correspondientes.  Sin embargo, esta simplicidad se hizo posible debido al tremendo trabajo de los equipos CLR y CoreCLR que unificaron todos los errores que provienen de todas las direcciones y fuentes en el CLR.  Para entender de qu√© vamos a hablar a continuaci√≥n, veamos un diagrama: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e12/163/521/e121635214ad6b5b5675ba4231eb85e7.png"></p><br><p>  Podemos ver que dentro de .NET Framework hay dos mundos: todo lo que pertenece a CLR y todo lo que no, incluidos todos los posibles errores que aparecen en Windows y otras partes del mundo inseguro. </p><br><ul><li>  El manejo estructurado de excepciones (SEH) es una forma est√°ndar en que Windows maneja las excepciones.  Cuando se llaman m√©todos <code>unsafe</code> y se lanzan excepciones, existe la conversi√≥n insegura &lt;-&gt; CLR de excepciones en ambas direcciones: de inseguro a CLR y hacia atr√°s.  Esto se debe a que CLR puede llamar a un m√©todo inseguro que a su vez puede llamar a un m√©todo CLR. </li><li>  El manejo de excepciones vectorizadas (VEH) es una ra√≠z de SEH y le permite colocar sus manejadores en lugares donde puedan producirse excepciones.  En particular, se usaba para colocar <code>FirstChanceException</code> . </li><li>  Las excepciones COM + aparecen cuando la fuente de un problema es un componente COM.  En este caso, una capa entre COM y un m√©todo .NET debe convertir un error COM en una excepci√≥n .NET. </li><li>  Y, por supuesto, envoltorios para HRESULT.  Se introducen para convertir un modelo WinAPI (un c√≥digo de error est√° contenido en un valor de retorno, mientras que los valores de retorno se obtienen utilizando par√°metros de m√©todo) en un modelo de excepciones porque es una excepci√≥n que es est√°ndar para .NET. </li></ul><br><p>  Por otro lado, hay idiomas por encima de CLI, cada uno de los cuales tiene m√°s o menos funciones para manejar excepciones.  Por ejemplo, recientemente VB.NET o F # ten√≠an una funcionalidad de manejo de excepciones m√°s rica expresada en varios filtros que no exist√≠an en C #. </p><br><h2 id="return-codes-vs-exception">  C√≥digos de retorno vs.  excepci√≥n </h2><br><p>  Por separado, debo mencionar un modelo de manejo de errores de aplicaci√≥n utilizando c√≥digos de retorno.  La idea de simplemente devolver un error es clara y clara.  Adem√°s, si tratamos las excepciones como un operador <code>goto</code> , el uso de c√≥digos de retorno se vuelve m√°s razonable: en este caso, el usuario de un m√©todo ve la posibilidad de errores y puede entender qu√© errores pueden ocurrir.  Sin embargo, no adivinemos qu√© es mejor y para qu√©, sino que discutamos el problema de elecci√≥n utilizando una teor√≠a bien razonada. </p><br><p>  Supongamos que todos los m√©todos tienen interfaces para tratar los errores.  Entonces todos los m√©todos se ver√≠an as√≠: </p><br><pre> <code class="plaintext hljs">public bool TryParseInteger(string source, out int result); public DialogBoxResult OpenDialogBox(...); public WebServiceResult IWebService.GetClientsList(...); public class DialogBoxResult : ResultBase { ... } public class WebServiceResult : ResultBase { ... }</code> </pre> <br><p>  Y su uso se ver√≠a as√≠: </p><br><pre> <code class="plaintext hljs">public ShowClientsResult ShowClients(string group) { if(!TryParseInteger(group, out var clientsGroupId)) return new ShowClientsResult { Reason = ShowClientsResult.Reason.ParsingFailed }; var webResult = _service.GetClientsList(clientsGroupId); if(!webResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.ServiceFailed, WebServiceResult = webResult }; } var dialogResult = _dialogsService.OpenDialogBox(webResult.Result); if(!dialogResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.DialogOpeningFailed, DialogServiceResult = dialogResult }; } return ShowClientsResult.Success(); }</code> </pre> <br><p>  Puede pensar que este c√≥digo est√° sobrecargado con el manejo de errores.  Sin embargo, me gustar√≠a que reconsiderara su posici√≥n: todo aqu√≠ es una emulaci√≥n de un mecanismo que arroja y maneja excepciones. </p><br><p>  ¬øC√≥mo puede un m√©todo informar un problema?  Puede hacerlo utilizando una interfaz para informar errores.  Por ejemplo, en el m√©todo <code>TryParseInteger</code> , dicha interfaz est√° representada por un valor de retorno: si todo est√° bien, el m√©todo devolver√° <code>true</code> .  Si no est√° bien, devolver√° <code>false</code> .  Sin embargo, aqu√≠ hay una desventaja: el valor real se devuelve a trav√©s del par√°metro <code>out int result</code> .  La desventaja es que, por un lado, el valor de retorno es l√≥gicamente y, por percepci√≥n, tiene m√°s esencia de "valor de retorno" que la de nuestro par√°metro. Por otro lado, no siempre nos importan los errores. el an√°lisis proviene de un servicio que gener√≥ esta cadena, no necesitamos verificar si hay errores: la cadena siempre ser√° correcta y buena para el an√°lisis. Sin embargo, supongamos que tomamos otra implementaci√≥n del m√©todo: </p><br><pre> <code class="plaintext hljs">public int ParseInt(string source);</code> </pre> <br><p>  Entonces, hay una pregunta: si una cadena tiene errores, ¬øqu√© debe hacer el m√©todo?  ¬øDeber√≠a devolver cero?  Esto no ser√° correcto: no hay cero en la cadena.  En este caso, tenemos un conflicto de intereses: la primera variante tiene demasiado c√≥digo, mientras que la segunda variante no tiene medios para informar errores.  Sin embargo, en realidad es f√°cil decidir cu√°ndo usar c√≥digos de retorno y cu√°ndo usar excepciones. </p><br><blockquote>  Si obtener un error es una norma, elija un c√≥digo de retorno.  Por ejemplo, es normal cuando un algoritmo de an√°lisis de texto encuentra errores en un texto, pero si otro algoritmo que funciona con una cadena analizada obtiene un error de un analizador, puede ser cr√≠tico o, en otras palabras, excepcional. </blockquote><br><h2 id="try-catch-finally-in-brief">  Intenta atrapar finalmente en breve </h2><br><p>  Un bloque <code>try</code> cubre una secci√≥n donde un programador espera obtener una situaci√≥n cr√≠tica que es tratada como una norma por c√≥digo externo.  En otras palabras, si alg√∫n c√≥digo considera que su estado interno es inconsistente en funci√≥n de algunas reglas y genera una excepci√≥n, un sistema externo, que tiene una visi√≥n m√°s amplia de la misma situaci√≥n, puede detectar esta excepci√≥n utilizando un bloque <code>catch</code> y normalizar la ejecuci√≥n del c√≥digo de la aplicaci√≥n .  Por lo tanto, <em>legaliza las excepciones en esta secci√≥n del c√≥digo al capturarlas</em> .  Creo que es una idea importante que justifica la prohibici√≥n de capturar todas <code>try-catch(Exception ex){ ...}</code> <em>si acaso</em> . </p><br><p>  No significa que la captura de excepciones contradiga alguna ideolog√≠a.  Le digo que debe detectar solo los errores que espera de una secci√≥n particular de c√≥digo.  Por ejemplo, no puede esperar todo tipo de excepciones heredadas de <code>ArgumentException</code> o no puede obtener <code>NullReferenceException</code> , porque a menudo significa que un problema est√° m√°s en <em>su</em> c√≥digo que en uno llamado.  Pero es apropiado esperar que no podr√° abrir un archivo deseado.  Incluso si est√° 200% seguro de que podr√° hacerlo, no se olvide de verificar. </p><br><p>  El bloque <code>finally</code> tambi√©n es bien conocido.  Es adecuado para todos los casos cubiertos por bloques <code>try-catch</code> .  Excepto por varias situaciones <em>especiales</em> raras, este bloque <em>siempre</em> funcionar√°.  ¬øPor qu√© se introdujo tal garant√≠a de rendimiento?  Para limpiar aquellos recursos y grupos de objetos que fueron asignados o capturados en el bloque <code>try</code> y de los cuales este bloque es responsable. </p><br><p>  Este bloque a menudo se usa sin el bloque <code>catch</code> cuando no nos importa qu√© error rompi√≥ un algoritmo, pero necesitamos limpiar todos los recursos asignados para este algoritmo.  Veamos un ejemplo simple: un algoritmo de copia de archivos necesita dos archivos abiertos y un rango de memoria para un b√∫fer de efectivo.  Imagine que asignamos memoria y abrimos un archivo, pero no pudimos abrir otro.  Para envolver todo en una "transacci√≥n" at√≥micamente, colocamos las tres operaciones en un solo bloque de <code>try</code> (como una variante de implementaci√≥n) con recursos limpiados <code>finally</code> . Puede parecer un ejemplo simplificado, pero lo m√°s importante es mostrar la esencia. </p><br><p>  Lo que realmente le falta a C # es un bloque de <code>fault</code> que se activa cada vez que ocurre un error.  Es como <code>finally</code> con esteroides.  Si tuvi√©ramos esto, podr√≠amos, por ejemplo, crear un √∫nico punto de entrada para registrar situaciones excepcionales: </p><br><pre> <code class="plaintext hljs">try { //... } fault exception { _logger.Warn(exception); }</code> </pre><br><p>  Otra cosa que deber√≠a tocar en esta introducci√≥n son los filtros de excepci√≥n.  No es una caracter√≠stica nueva en la plataforma .NET, pero los desarrolladores de C # pueden ser nuevos: el filtrado de excepciones apareci√≥ solo en v.  6.0.  Los filtros deber√≠an normalizar una situaci√≥n cuando hay un √∫nico tipo de excepci√≥n que combina varios tipos de errores.  Deber√≠a ayudarnos cuando queremos abordar un escenario particular, pero primero tenemos que detectar todo el grupo de errores y luego filtrarlos.  Por supuesto, me refiero al c√≥digo del siguiente tipo: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) { switch(exception.ErrorCode) { case ErrorCode.MissingModifier: // ... break; case ErrorCode.MissingBracket: // ... break; default: throw; } }</code> </pre> <br><p>  Bueno, ahora podemos reescribir este c√≥digo correctamente: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingModifier) { // ... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingBracket) { // ... }</code> </pre> <br><p>  La mejora aqu√≠ no est√° en la falta de construcci√≥n del <code>switch</code> .  Creo que esta nueva construcci√≥n es mejor en varias cosas: </p><br><ul><li>  usando <code>when</code> para filtrar capturamos exactamente lo que queremos y es correcto en t√©rminos de ideolog√≠a; </li><li>  el c√≥digo se vuelve m√°s legible en esta nueva forma.  Mirando a trav√©s del c√≥digo, nuestro cerebro puede identificar bloques para manejar errores m√°s f√°cilmente, ya que inicialmente busca <code>catch</code> y no <code>switch-case</code> ; </li><li>  el √∫ltimo pero no menos importante: una comparaci√≥n preliminar ANTES de ingresar al bloque de captura.  Significa que si hacemos conjeturas err√≥neas sobre situaciones potenciales, esta construcci√≥n funcionar√° m√°s r√°pido que el <code>switch</code> en el caso de lanzar una excepci√≥n nuevamente. </li></ul><br><p>  Muchas fuentes dicen que la caracter√≠stica peculiar de este c√≥digo es que el filtrado ocurre <em>antes de</em> desenrollar la pila.  Puede ver esto en situaciones en las que no hay otras llamadas excepto las habituales entre el lugar donde se produce una excepci√≥n y el lugar donde se produce la verificaci√≥n del filtrado. </p><br><pre> <code class="plaintext hljs">static void Main() { try { Foo(); } catch (Exception ex) when (Check(ex)) { ; } } static void Foo() { Boo(); } static void Boo() { throw new Exception("1"); } static bool Check(Exception ex) { return ex.Message == "1"; }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/c44/c6b/e41c44c6b41164af3aff1aa9489f417f.png" alt="Apilar sin desenrollar"></p><br><p>  Puede ver en la imagen que el seguimiento de la pila contiene no solo la primera llamada de <code>Main</code> como el punto para capturar una excepci√≥n, sino toda la pila antes del punto de lanzar una excepci√≥n m√°s la segunda entrada en <code>Main</code> trav√©s de un c√≥digo no administrado.  Podemos suponer que este c√≥digo es exactamente el c√≥digo para lanzar excepciones que se encuentra en la etapa de filtrado y elecci√≥n de un controlador final.  Sin embargo, <em>no todas las llamadas se pueden manejar sin desenrollar la pila</em> .  Creo que la uniformidad excesiva de la plataforma genera demasiada confianza en ella.  Por ejemplo, cuando un dominio llama a un m√©todo desde otro dominio, es absolutamente transparente en t√©rminos de c√≥digo.  Sin embargo, la forma en que los m√©todos llaman al trabajo es una historia absolutamente diferente.  Vamos a hablar de ellos en la siguiente parte. </p><br><h3 id="serialization">  Serializaci√≥n </h3><br><p>  Comencemos mirando los resultados de ejecutar el siguiente c√≥digo (agregu√© la transferencia de una llamada a trav√©s del l√≠mite entre dos dominios de aplicaci√≥n). </p><br><pre> <code class="plaintext hljs"> class Program { static void Main() { try { ProxyRunner.Go(); } catch (Exception ex) when (Check(ex)) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { throw new Exception("1"); } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner) dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } } }</code> </pre><br><p>  Podemos ver que el despliegue de la pila ocurre antes de comenzar a filtrar.  Veamos capturas de pantalla.  El primero se toma antes de la generaci√≥n de una excepci√≥n: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bda/8d8/792/bda8d87928516a8213cafdf953d029b6.png" alt="Stackunnroll"></p><br><p>  El segundo es despu√©s: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2b/f45/dee/c2bf45dee3a13091259468415719dbea.png" alt="Stackacknroll2"></p><br><p>  Estudiemos el seguimiento de llamadas antes y despu√©s de filtrar las excepciones.  Que pasa aqui  Podemos ver que los desarrolladores de plataformas hicieron algo que a primera vista parece la protecci√≥n de un subdominio.  El seguimiento se corta despu√©s del √∫ltimo m√©todo en la cadena de llamadas y luego est√° la transferencia a otro dominio.  Pero creo que esto se ve extra√±o.  Para entender por qu√© sucede esto, recordemos la regla principal para los tipos que organizan la interacci√≥n entre dominios.  Estos tipos deber√≠an heredar <code>MarshalByRefObject</code> y ser serializables.  Sin embargo, a pesar de la rigurosidad de los tipos de excepci√≥n de C #, puede ser de cualquier naturaleza.  Que significa  Esto significa que pueden ocurrir situaciones en las que una excepci√≥n dentro de un subdominio puede ser atrapada en un dominio principal.  Adem√°s, si un objeto de datos que puede entrar en una situaci√≥n excepcional tiene algunos m√©todos que son peligrosos en t√©rminos de seguridad, puede llamarse en un dominio principal.  Para evitar esto, la excepci√≥n se serializa primero y luego cruza el l√≠mite entre los dominios de aplicaci√≥n y aparece nuevamente con una nueva pila.  Veamos esta teor√≠a: </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] class Cast { [FieldOffset(0)] public Exception Exception; [FieldOffset(0)] public object obj; } static void Main() { try { ProxyRunner.Go(); Console.ReadKey(); } catch (RuntimeWrappedException ex) when (ex.WrappedException is Program) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { var x = new Cast {obj = new Program()}; throw x.Exception; } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner)dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } }</code> </pre> <br><p>  Para el c√≥digo C # podr√≠a arrojar una excepci√≥n de cualquier tipo (no quiero torturarte con MSIL) Realic√© un truco en este ejemplo lanzando un tipo a uno no comparable, por lo que podr√≠amos lanzar una excepci√≥n de cualquier tipo, pero el traductor pensar√≠a que usamos el tipo de <code>Exception</code> .  Creamos una instancia del tipo de <code>Program</code> , que no es serializable con seguridad, y lanzamos una excepci√≥n usando este tipo como carga de trabajo.  La buena noticia es que obtienes un contenedor para excepciones que no son de excepci√≥n de <code>RuntimeWrappedException</code> que almacenar√° una instancia de nuestro objeto de tipo <code>Program</code> dentro y podremos detectar esta excepci√≥n.  Sin embargo, hay malas noticias que respaldan nuestra idea: llamar a <code>proxy.MethodInsideAppDomain();</code>  generar√° <code>SerializationException</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1ad/ace/7f1/1adace7f1c21e2ad7edc51b36f343dc9.png"></p><br><p>  Por lo tanto, no puede transferir dicha excepci√≥n entre dominios ya que no es posible serializarla.  Esto, a su vez, significa que el uso de filtros de excepci√≥n para envolver llamadas de m√©todos en otros dominios de todos modos conducir√° al desenrollamiento de la pila a pesar de que la serializaci√≥n parece ser innecesaria con la configuraci√≥n <code>FullTrust</code> de un subdominio. </p><br><blockquote>  Deber√≠amos prestar atenci√≥n adicional a la raz√≥n por la cual la serializaci√≥n entre dominios es tan necesaria.  En nuestro ejemplo artificial, creamos un subdominio que no tiene ninguna configuraci√≥n.  Significa que funciona en modo FullTrust.  CLR conf√≠a plenamente en su contenido y no ejecuta ninguna comprobaci√≥n adicional.  Sin embargo, cuando inserte al menos una configuraci√≥n de seguridad, la confianza completa desaparecer√° y CLR comenzar√° a controlar todo lo que sucede dentro de un subdominio.  Entonces, cuando tiene un dominio totalmente confiable, no necesita una serializaci√≥n.  Admita, no necesitamos protegernos.  Pero la serializaci√≥n existe no solo para protecci√≥n.  Cada dominio carga todos los ensamblajes necesarios por segunda vez y crea sus copias.  Por lo tanto, crea copias de todos los tipos y todas las VMT.  Por supuesto, al pasar un objeto de dominio a dominio obtendr√° el mismo objeto.  Pero sus VMT no ser√°n suyos y este objeto no se puede convertir a otro tipo.  En otras palabras, si creamos una instancia de un tipo <code>Boo</code> y la obtenemos en otro dominio, la conversi√≥n de <code>(Boo)boo</code> no funcionar√°.  En este caso, la serializaci√≥n y la deserializaci√≥n resolver√°n el problema ya que el objeto existir√° en dos dominios simult√°neamente.  Existir√° con todos sus datos donde se cre√≥ y existir√° en el dominio de uso como un objeto proxy, asegurando que se invoquen los m√©todos de un objeto original. </blockquote><p>  Al transferir un objeto serializado entre dominios, obtiene una copia completa del objeto de un dominio en otro mientras mantiene cierta delimitaci√≥n en la memoria.  Sin embargo, esta delimitaci√≥n es ficticia.  Se usa solo para aquellos tipos que no est√°n en <code>Shared AppDomain</code> .  Por lo tanto, si arroja algo no serializable como una excepci√≥n, pero desde <code>Shared AppDomain</code> , no obtendr√° un error de serializaci√≥n (podemos intentar lanzar <code>Action</code> lugar de <code>Program</code> ).  Sin embargo, el despliegue de la pila ocurrir√° de todos modos en este caso: ya que ambas variantes deber√≠an funcionar de manera est√°ndar.  Para que nadie se confunda. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454630/">https://habr.com/ru/post/454630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454618/index.html">Foso de productividad: c√≥mo da√±a Slack nuestro flujo de trabajo</a></li>
<li><a href="../454620/index.html">#NoDeployFriday: ¬øayuda o perjudica?</a></li>
<li><a href="../454622/index.html">Kreisel EVEX 910e: modelo hist√≥rico - nueva vida</a></li>
<li><a href="../454626/index.html">DevOops ayer y hoy</a></li>
<li><a href="../454628/index.html">Construyendo un sistema autom√°tico de moderaci√≥n de mensajes</a></li>
<li><a href="../454634/index.html">Semana de la seguridad 23: vulnerabilidad del Bloc de notas, un mill√≥n de sistemas con RDP sin parches</a></li>
<li><a href="../454640/index.html">Depuraci√≥n remota de microservicios a trav√©s de SSH bajo VPN en 4 turnos</a></li>
<li><a href="../454642/index.html">‚Äú‚Äú Hacer una aplicaci√≥n para personas ‚Äù: esto no debe garabatearse en la rodilla‚Äù: sobre el desarrollo m√≥vil en CFT</a></li>
<li><a href="../454644/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 8. Configuraci√≥n del interruptor</a></li>
<li><a href="../454646/index.html">Compilaci√≥n @Pythonetc, mayo de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>