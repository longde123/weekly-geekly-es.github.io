<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê üöâ üëï Imers√£o em Movimento - Linguagem de programa√ß√£o blockchain Libra do Facebook ü§±üèæ üëßüèª üë©‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A seguir, examinaremos detalhadamente as principais caracter√≠sticas do idioma Move e quais s√£o suas principais diferen√ßas com outro idioma j√° popular ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Imers√£o em Movimento - Linguagem de programa√ß√£o blockchain Libra do Facebook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459990/"> A seguir, examinaremos detalhadamente as principais caracter√≠sticas do idioma Move e quais s√£o suas principais diferen√ßas com outro idioma j√° popular para contratos inteligentes - Solidity (na plataforma Ethereum).  O material √© baseado no estudo de um white paper on-line de 26 p√°ginas dispon√≠vel. <br><br><h3>  1. Introdu√ß√£o </h3><br>  Move √© uma linguagem execut√°vel de c√≥digo de bytes usada para executar transa√ß√µes do usu√°rio e contratos inteligentes.  Preste aten√ß√£o a dois pontos: <br><br><ol><li>  Enquanto o Move √© uma linguagem de bytecode que pode ser executada diretamente na m√°quina virtual Move, o Solidity (linguagem de contrato inteligente no Ethereum) √© uma linguagem de n√≠vel superior que √© compilada primeiro no bytecode antes de ser executada no EVM (Ethereum Virtual Machine ) </li><li>  O Move pode ser usado n√£o apenas para a implementa√ß√£o de contratos inteligentes, mas tamb√©m para transa√ß√µes de usu√°rios (mais sobre isso mais adiante), enquanto o Solidity √© uma linguagem apenas para contratos inteligentes. </li></ol><a name="habracut"></a><br>  <i>Tradu√ß√£o feita pela equipe do projeto do protocolo INDEX.</i>  <i>Anteriormente, traduzimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muito material que descreve o projeto Libra</a> , agora √© a vez de analisar o idioma Move um pouco mais profundamente.</i>  <i>A tradu√ß√£o foi feita em conjunto com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">coolsiu</a></i> <br><br>  Um recurso importante do Move √© a capacidade de definir tipos de recursos personalizados com sem√¢ntica l√≥gica linear: um recurso nunca pode ser copiado ou exclu√≠do implicitamente, apenas movido.  Funcionalmente, isso √© semelhante aos recursos da linguagem Rust.  Os valores em Rust podem ser atribu√≠dos apenas a um nome por vez.  A atribui√ß√£o de um valor a outro nome o torna inacess√≠vel sob o nome anterior. <br><br><img src="https://habrastorage.org/webt/np/px/97/nppx97owkfkamua9ccpc1aovkrg.png"><br><br>  Por exemplo, o seguinte fragmento de c√≥digo gerar√° um erro: <i>Uso do valor movido 'x'.</i>  Isso ocorre porque n√£o h√° coleta de lixo no Rust.  Quando as vari√°veis ‚Äã‚Äãficam fora do escopo, a mem√≥ria √† qual elas se referem tamb√©m √© liberada.  Simplificando, pode haver apenas um "propriet√°rio" dos dados.  Neste exemplo, <i>x</i> √© o propriet√°rio original e <i>y</i> se torna o novo propriet√°rio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leia mais sobre esse comportamento aqui</a> . <br><br><h3>  Representa√ß√£o de ativos digitais em sistemas abertos </h3><br>  H√° duas propriedades de ativos f√≠sicos que s√£o dif√≠ceis de representar digitalmente: <br><br><ul><li>  <b>Raridade</b> (escassez, no original - escassez).  A quantidade de ativos (emiss√£o) no sistema deve ser controlada.  A duplica√ß√£o de ativos existentes deve ser proibida e a cria√ß√£o de novos √© uma opera√ß√£o privilegiada. </li><li>  <b>Controle de acesso</b> .  O participante do sistema deve poder proteger ativos com pol√≠ticas de controle de acesso. </li></ul><br>  Essas duas caracter√≠sticas, que s√£o naturais para ativos f√≠sicos, precisam ser implementadas para objetos digitais, se quisermos consider√°-los ativos.  Por exemplo, um metal raro - tem um d√©ficit natural e somente voc√™ tem acesso a ele (segurando em suas m√£os, por exemplo) e pode vend√™-lo ou gast√°-lo. <br><br>  Para ilustrar como chegamos a essas duas propriedades, vamos come√ßar com as seguintes frases: <br><br><h4>  Proposi√ß√£o 1: A regra mais simples, sem escassez e controle de acesso </h4><br><img src="https://habrastorage.org/webt/it/ar/vy/itarvy-z1ns775gm4oxu2isimxe.png"><br><br><ul><li>  <i>G [K]: = n</i> significa atualizar o n√∫mero acess√≠vel pela chave <i>K</i> no estado global da blockchain com o novo valor <i>n</i> . </li><li>  <i>A transa√ß√£o "Alice, 100"</i> significa definir o saldo da conta de Alice como 100. </li></ul><br>  A solu√ß√£o acima tem v√°rios problemas s√©rios: <br><br><ul><li>  Alice pode receber um n√∫mero ilimitado de moedas simplesmente enviando a <i>transa√ß√£o iceAlice, 100‚ü©.</i> </li><li>  As moedas que Alice envia para Bob s√£o in√∫teis, pois Bob poderia enviar um n√∫mero ilimitado de moedas usando a mesma t√©cnica. </li></ul><br><h4>  Proposta n¬∫ 2: leve em considera√ß√£o o d√©ficit </h4><br><img src="https://habrastorage.org/webt/_1/s4/08/_1s408pxxtmawws6dw_vddgzr-m.png"><br><br>  Agora estamos monitorando a situa√ß√£o para que o n√∫mero de moedas <i>Ka</i> seja pelo menos <i>n</i> antes da transa√ß√£o de transfer√™ncia.  No entanto, embora isso resolva o problema da escassez, n√£o h√° informa√ß√µes sobre quem pode enviar as moedas de Alice (at√© agora todos podem fazer isso, o principal √© n√£o violar a regra dos limites de quantidade). <br><br><h4>  Proposi√ß√£o 3: Combinando d√©ficit e controle de acesso </h4><br><img src="https://habrastorage.org/webt/yi/so/hh/yisohh7xhtgmzt8aparwsxdccfc.png"><br><br>  Resolvemos esse problema com o <i>mecanismo de</i> assinatura digital <i>confirm_sig</i> antes de verificar o saldo, o que significa que Alice usa sua chave privada para assinar a transa√ß√£o e confirmar que possui suas moedas. <br><br><h3>  Linguagens de programa√ß√£o Blockchain </h3><br>  As linguagens blockchain existentes enfrentam os seguintes problemas (todos foram resolvidos no Move (nota: <i>infelizmente, o autor do artigo apenas apela ao Ethereum em suas compara√ß√µes, portanto, voc√™ deve lev√°-los apenas nesse contexto. Por exemplo, a maioria dos itens a seguir tamb√©m √© resolvida na EOS</i> )): <br><br>  <b>Representa√ß√£o indireta de ativos</b> .  Um ativo √© codificado usando um n√∫mero inteiro, mas um valor inteiro n√£o √© o mesmo que um ativo.  De fato, n√£o h√° tipo ou valor representando bitcoin / ether / &lt;Any Coin&gt;!  Isso torna os programas de grava√ß√£o que usam ativos dif√≠ceis e propensos a erros.  Padr√µes como a transfer√™ncia de ativos para / de procedimentos ou o armazenamento de ativos em estruturas requerem suporte especial ao idioma. <br><br>  <b>O d√©ficit n√£o √© expans√≠vel</b> .  A linguagem representa apenas um ativo escasso.  Al√©m disso, os rem√©dios contra o d√©ficit s√£o conectados diretamente √† sem√¢ntica da pr√≥pria linguagem.  Um desenvolvedor, se ele deseja criar um ativo do usu√°rio, deve monitorar cuidadosamente todos os aspectos do recurso.  Estes s√£o apenas os problemas dos contratos inteligentes da Ethereum. <br><br>  Os usu√°rios emitem seus ativos, tokens padr√£o do ERC-20, usando n√∫meros inteiros para determinar o custo e o problema total.  Sempre que novos tokens s√£o criados, o c√≥digo do contrato inteligente deve verificar independentemente a conformidade com as regras de emiss√£o.  Al√©m disso, a representa√ß√£o indireta de ativos leva, em alguns casos, a erros graves - duplica√ß√£o, duplica√ß√£o de gastos ou at√© uma completa perda de ativos. <br><br>  <b>Falta de controle de acesso flex√≠vel</b> .  A √∫nica pol√≠tica de controle de acesso atualmente em uso √© um esquema de assinatura usando criptografia assim√©trica.  Assim como a prote√ß√£o contra d√©ficit, as pol√≠ticas de controle de acesso est√£o profundamente embutidas na sem√¢ntica da linguagem.  Mas como expandir a linguagem para permitir que os programadores definam suas pr√≥prias pol√≠ticas de controle de acesso geralmente √© uma tarefa n√£o trivial. <br><br>  Isso tamb√©m se aplica ao Ethereum, onde contratos inteligentes n√£o t√™m suporte de criptografia nativa para controle de acesso.  Os desenvolvedores devem prescrever manualmente o controle de acesso, por exemplo, usando o modificador onlyOwner. <br><br>  Embora eu seja um grande f√£ do Ethereum, acredito que as propriedades dos ativos devem ser suportadas nativamente pelo idioma por raz√µes de seguran√ßa.  Em particular, transferir o Ether para um contrato inteligente envolve despacho din√¢mico, o que levou ao surgimento de uma nova classe de erros conhecidos como vulnerabilidades de reentrada.  O despacho din√¢mico aqui significa que a l√≥gica da execu√ß√£o do c√≥digo ser√° determinada no tempo de execu√ß√£o (din√¢mico) e n√£o no tempo de compila√ß√£o (est√°tico). <br><br>  Assim, no Solidity, quando o contrato A chama a fun√ß√£o do contrato B, o contrato B pode executar um c√≥digo que n√£o foi fornecido pelo desenvolvedor do contrato A, o que pode levar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vulnerabilidades de reentrada</a> (o contrato A executa acidentalmente a fun√ß√£o do contrato B para sacar dinheiro antes da dedu√ß√£o real saldos de conta). <br><br><h3>  Mover conceitos b√°sicos de design de idioma </h3><br><h4>  Recursos de primeira ordem </h4><br>  Falando em um n√≠vel superior, a intera√ß√£o entre m√≥dulos / recursos / procedimentos na linguagem Move √© muito semelhante √†s rela√ß√µes entre classes / objetos e m√©todos nas linguagens OOP. <br>  Os m√≥dulos no Move s√£o semelhantes aos contratos inteligentes em outras blockchains.  O m√≥dulo declara os tipos de recursos e procedimentos que definem as regras para criar, destruir e atualizar os recursos declarados.  Mas tudo isso s√£o apenas conven√ß√µes (" <i>jarg√µes</i> ") no Move.  Um pouco mais tarde ilustraremos esse ponto. <br><br><h4>  Flexibilidade </h4><br>  O Move adiciona flexibilidade ao Libra atrav√©s de scripts.  Cada transa√ß√£o no Libra inclui um script, que √© realmente o principal procedimento de transa√ß√£o.  O script pode executar uma a√ß√£o especificada, por exemplo, pagamentos de acordo com a lista especificada de destinat√°rios ou reutilizar outros recursos - por exemplo, chamando um procedimento no qual a l√≥gica geral √© especificada.  √â por isso que os scripts de transa√ß√£o do Move oferecem mais flexibilidade.  O script pode usar comportamentos √∫nicos e repetitivos, enquanto o Ethereum pode executar apenas scripts repetitivos (chamando um m√©todo de contrato inteligente chamando um m√©todo).  O motivo pelo qual √© chamado de "m√∫ltiplo" √© porque as fun√ß√µes de um contrato inteligente podem ser executadas v√°rias vezes.  (nota: <i>o momento √© muito delicado aqui. Por um lado, os scripts de transa√ß√£o na forma de pseudo-bytecode tamb√©m est√£o no Bitcoin. Por outro lado, como eu o entendo, o Move expande esse idioma, de fato, para o n√≠vel de uma linguagem de contrato inteligente completa</i> ). <br><br><h4>  Seguran√ßa </h4><br>  O formato execut√°vel Move √© bytecode, que, por um lado, √© um idioma de n√≠vel superior ao assembler, mas inferior ao c√≥digo fonte.  O bytecode √© verificado na cadeia quanto √† disponibilidade de recursos, tipos e seguran√ßa de mem√≥ria usando o verificador de bytecode e, em seguida, executado pelo int√©rprete.  Essa abordagem permite que o Move forne√ßa seguran√ßa espec√≠fica ao c√≥digo-fonte, mas sem o processo de compila√ß√£o e a necessidade de adicionar um compilador ao sistema.  Tornar o Move uma linguagem de bytecode √© uma solu√ß√£o realmente boa.  N√£o h√° necessidade de compil√°-lo a partir da fonte, como √© o caso do Solidity, n√£o h√° necessidade de se preocupar com poss√≠veis falhas ou ataques na infraestrutura do compilador. <br><br><h4>  Verificabilidade </h4><br>  Nosso objetivo √© realizar verifica√ß√µes o mais f√°cil poss√≠vel, pois tudo isso entra em cadeia (nota: <i>on-line, no processo de cada transa√ß√£o, portanto, qualquer atraso leva a uma desacelera√ß√£o de toda a rede</i> ); no entanto, o design da linguagem est√° inicialmente pronto para uso e meios fora da cadeia de verifica√ß√£o est√°tica.  Embora isso seja mais prefer√≠vel, at√© agora o desenvolvimento de ferramentas de verifica√ß√£o (como um kit de ferramentas separado) foi adiado para o futuro, e agora apenas a verifica√ß√£o din√¢mica em tempo de execu√ß√£o (on-chain) √© suportada. <br><br><h4>  Modularidade </h4><br>  Os m√≥dulos Move fornecem abstra√ß√£o de dados e localizam opera√ß√µes cr√≠ticas nos recursos.  O encapsulamento fornecido pelo m√≥dulo, combinado com a prote√ß√£o fornecida pelo sistema de tipo Mover, garante que as propriedades definidas para os tipos de m√≥dulo n√£o possam ser violadas pelo c√≥digo fora do m√≥dulo.  Esse √© um projeto de abstra√ß√£o bem pensado, o que significa que os dados dentro do contrato s√≥ podem ser alterados dentro da estrutura do contrato, mas n√£o de fora. <br><br><img src="https://habrastorage.org/webt/rm/co/qe/rmcoqelz3bad4ltayox-u9rpxq0.png"><br><br><h3>  Mover revis√£o </h3><br>  Um script de transa√ß√£o de exemplo demonstra que a√ß√µes maliciosas ou imprudentes de um programador fora de um m√≥dulo n√£o podem violar a seguran√ßa dos recursos do m√≥dulo.  A seguir, veremos exemplos de como os m√≥dulos, recursos e procedimentos s√£o usados ‚Äã‚Äãpara programar o blockchain Libra. <br><br><h4>  Pagamentos ponto a ponto </h4><br><img src="https://habrastorage.org/webt/1a/hr/hh/1ahrhhw3rd4ky7jpfsvzxeohi0e.png"><br><br>  A quantidade de moedas especificada na quantidade ser√° transferida do saldo do remetente para o destinat√°rio. <br>  Existem v√°rios novos pontos (destacados em vermelho): <br><br><ul><li>  <b>0x0</b> : endere√ßo da conta em que o m√≥dulo est√° armazenado </li><li>  <b>Moeda</b> : nome do m√≥dulo </li><li>  <b>Moeda</b> : tipo de recurso </li><li>  O valor da moeda retornado pelo procedimento √© um valor de recurso cujo tipo √© 0x0.Currency.Coin </li><li>  <b>move ()</b> : o valor n√£o pode ser usado novamente </li><li>  <b>copy ()</b> : o valor pode ser usado posteriormente </li></ul><br>  Analisamos o c√≥digo: na primeira etapa, o remetente chama um procedimento chamado <i>retire_from_sender</i> a partir do m√≥dulo armazenado em <i>0x0.Currency</i> .  No segundo est√°gio, o remetente transfere os fundos para o destinat√°rio, movendo o valor do recurso de moeda para o procedimento de dep√≥sito do m√≥dulo <i>0x0.Currency</i> . <br><br>  Aqui est√£o tr√™s exemplos de erros de c√≥digo que ser√£o rejeitados por verifica√ß√µes: <br>  <b>Duplica√ß√£o de fundos alterando a chamada para <i>mover (moeda)</i> para <i>copiar (moeda)</i></b> .  Os recursos podem ser movidos apenas.  Tentar duplicar a quantidade de um recurso (por exemplo, chamando <i>copy (coin)</i> no exemplo acima) resultar√° em um erro ao verificar o bytecode. <br><br>  <b>Reutiliza√ß√£o de fundos especificando o <i>movimento (moeda)</i> duas vezes</b> .  Adicionar a linha <i>0x0.Currency.deposit (copy (some_other_payee), move (coin))</i> para o exemplo acima permitir√° que o remetente "gaste" moedas duas vezes - a primeira vez com o benefici√°rio e a segunda com <i>some_other_payee</i> .  Esse √© um comportamento indesej√°vel, imposs√≠vel com um ativo f√≠sico.  Felizmente, o Move rejeitar√° este programa. <br><br>  <b>Perda de fundos devido a falha no <i>movimento (moeda)</i></b> .  Se voc√™ n√£o mover o recurso (por exemplo, excluindo a linha que cont√©m o <i>movimento (moeda)</i> ), ser√° gerado um erro ao verificar o bytecode.  Isso protege os programadores do Move contra perda acidental ou maliciosa de fundos. <br><br><h3>  M√≥dulo de moeda </h3><br><img src="https://habrastorage.org/webt/p1/gx/rh/p1gxrhzyyl4cmlmlq5rcr4yhzmc.png"><br><br>  Cada conta pode conter 0 ou mais m√≥dulos (representados como ret√¢ngulos) e um ou mais valores de recursos (representados como cilindros).  Por exemplo, uma conta em <i>0x0</i> cont√©m um m√≥dulo <i>0x0.Currency</i> e um valor de recurso do tipo <i>0x0.Currency.Coin</i> .  A conta em <i>0x1</i> possui dois recursos e um m√≥dulo;  A conta em <i>0x2</i> possui dois m√≥dulos e um valor de recurso. <br><br>  Alguns pontos: <br><br><ul><li>  O script de transa√ß√£o √© at√¥mico - completamente executado, ou nem um pouco. </li><li>  Um m√≥dulo √© um c√≥digo de longa dura√ß√£o dispon√≠vel globalmente. </li><li>  O estado global est√° estruturado como uma tabela de hash, onde a chave ser√° o endere√ßo da conta </li><li>  As contas podem conter n√£o mais que um valor de recurso desse tipo e n√£o mais que um m√≥dulo com um determinado nome (uma conta em <i>0x0</i> n√£o pode conter um recurso adicional <i>0x0.Currency.Coin</i> ou outro m√≥dulo chamado <i>Currency</i> ) </li><li>  O endere√ßo do m√≥dulo declarado faz parte do tipo ( <i>0x0.Currency.Coin</i> e <i>0x1.Currency.Coin</i> s√£o tipos separados que n√£o podem ser usados ‚Äã‚Äãde forma intercambi√°vel) </li><li>  Os programadores podem armazenar v√°rias inst√¢ncias desse tipo de recurso na conta, definindo seu recurso personalizado - ( <i>recurso TwoCoins {c1: 0x0.Currency.Coin, c2: 0x0.Currency.Coin}</i> ) </li><li>  Voc√™ pode se referir a um recurso por seu nome sem conflitos, por exemplo, pode se referir a dois recursos usando <i>TwoCoins.c1</i> e <i>TwoCoins.c2</i> . </li></ul><br><h4>  An√∫ncio de recurso de moeda </h4><br><img src="https://habrastorage.org/webt/az/79/8o/az798o2jkg9ft5tkiisy5fitk2o.png"><br>  Um m√≥dulo chamado <i>Currency</i> e um tipo de recurso chamado <i>Coin</i> <br><br>  Alguns pontos: <br><br><ul><li>  <i>Coin</i> √© uma estrutura de campo √∫nico do tipo <i>u64</i> (n√∫mero inteiro n√£o assinado de 64 bits) </li><li>  Somente os procedimentos do m√≥dulo <i>Moeda</i> podem criar ou destruir valores de <i>moeda</i> . </li><li>  Outros m√≥dulos e scripts podem gravar ou referenciar o campo de valor somente por meio de procedimentos abertos fornecidos pelo m√≥dulo. </li></ul><br><h4>  Implementa√ß√£o de Dep√≥sito </h4><br><img src="https://habrastorage.org/webt/52/uj/nw/52ujnwxqzafegglfjqrsckqwy50.png"><br><br>  Este procedimento usa o recurso <i>Coin</i> como entrada e o combina com o recurso <i>Coin</i> armazenado na conta do destinat√°rio: <br><br><ol><li>  Destruindo o recurso de entrada Coin e registrando seu valor. </li><li>  Obter um link para um recurso de moeda exclusivo armazenado na conta do destinat√°rio. </li><li>  Alterando o valor da quantidade de moeda pelo valor passado no par√¢metro quando o procedimento √© chamado. </li></ol><br>  Alguns pontos: <br><br><ul><li>  <i>Desembalar, BorrowGlobal</i> - procedimentos internos </li><li>  <i>Descompactar &lt;T&gt;</i> √© a √∫nica maneira de excluir um recurso do tipo T. O procedimento leva o recurso √† entrada, destr√≥i-o e retorna o valor associado aos campos do recurso. </li><li>  <i>BorrowGlobal &lt;T&gt;</i> aceita o endere√ßo como entrada e retorna um link para uma inst√¢ncia exclusiva de T publicada (de propriedade) por este endere√ßo </li><li>  <i>&amp; mut Coin</i> √© um link para o recurso <i>Coin</i> </li></ul><br><h4>  Implementar retire_from_sender </h4><br><img src="https://habrastorage.org/webt/af/6s/h_/af6sh_tc_6jpvlwzgka0by5cnjo.png"><br><br>  Este procedimento: <br><br><ol><li>  Obt√©m um link para um recurso de <i>moeda</i> exclusivo vinculado √† conta do remetente </li><li>  Diminui o valor do recurso <i>Coin</i> por refer√™ncia √† quantidade especificada </li><li>  Cria e retorna um novo recurso de <i>moeda</i> com um saldo atualizado. </li></ol><br>  Alguns pontos: <br><br><ul><li>  Qualquer <i>dep√≥sito</i> pode ser chamado por qualquer pessoa, mas o <i>retirada_from_sender</i> tem acesso apenas √†s moedas da conta de chamada </li><li>  <i>GetTxnSenderAddress</i> √© semelhante ao <i>msg.sender</i> no Solidity </li><li>  <i>RejectUnless</i> √© semelhante ao <i>requerido</i> no Solidity.  Se essa verifica√ß√£o falhar, a transa√ß√£o ser√° interrompida e todas as altera√ß√µes ser√£o revertidas. </li><li>  <i>O pacote &lt;T&gt;</i> tamb√©m √© um procedimento interno que cria um novo recurso do tipo T. </li><li>  Como <i>descompactar &lt;T&gt;</i> , o <i>pacote &lt;T&gt;</i> s√≥ pode ser chamado dentro do m√≥dulo em que o recurso <i>T √©</i> descrito </li></ul><br><h3>  Conclus√£o </h3><br>  Examinamos as principais caracter√≠sticas da linguagem Move, comparamos com o Ethereum e tamb√©m nos familiarizamos com a sintaxe b√°sica dos scripts.  Em conclus√£o, eu recomendo olhar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">white paper original</a> .  Inclui muitos detalhes sobre os princ√≠pios do design da linguagem de programa√ß√£o, bem como muitos links √∫teis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459990/">https://habr.com/ru/post/pt459990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459978/index.html">Ferramentas de desenvolvedor do Node.js. Chamada de procedimento remoto nos soquetes da Web</a></li>
<li><a href="../pt459980/index.html">Letras nigerianas de alta tecnologia</a></li>
<li><a href="../pt459982/index.html">Analisadores de Roslyn. Como escrever c√≥digo de maneira r√°pida e precisa</a></li>
<li><a href="../pt459984/index.html">Construindo uma infraestrutura como c√≥digo com GitLab e Ansible</a></li>
<li><a href="../pt459988/index.html">O cachorro comeu em redes neurais</a></li>
<li><a href="../pt459992/index.html">GOST R 57100-2016. O que foi aquilo?</a></li>
<li><a href="../pt459994/index.html">Pesquisa: Linux ainda √© o sistema operacional mais popular na nuvem</a></li>
<li><a href="../pt459996/index.html">Alemanha Munique Guia avan√ßado de imigra√ß√£o</a></li>
<li><a href="../pt460002/index.html">Como criamos o Dream Service Desk</a></li>
<li><a href="../pt460004/index.html">Feliz dia do administrador do sistema</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>