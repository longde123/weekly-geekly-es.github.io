<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 👩🏼‍⚕️ 😲 Pinterest Sharding: Bagaimana Kami Meningkatkan Taman MySQL Kami 🐜 💽 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, orang Khabrovit! Selamat untuk semua pada hari programmer dan membagikan terjemahan artikel, yang disiapkan khusus untuk siswa dari kursus "Ars...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pinterest Sharding: Bagaimana Kami Meningkatkan Taman MySQL Kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467389/">  <i>Salut, orang Khabrovit!</i>  <i>Selamat untuk semua pada hari programmer dan membagikan terjemahan artikel, yang disiapkan khusus untuk siswa dari kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Arsitek Beban Tinggi"</a> .</i> <br><br><img src="https://habrastorage.org/webt/3o/s-/k6/3os-k6l2f122mbs6d1lufcif6ke.png"><br><br>  <b><i>"Sharding.</i></b>  <b><i>Atau jangan beling.</i></b>  <b><i>Tanpa berusaha. "</i></b> <b><i><br></i></b>  <b><i>- Yoda</i></b> <br><br>  Hari ini kita akan membahas pemisahan data antara beberapa server MySQL.  Kami selesai sharding pada awal 2012, dan sistem ini masih digunakan untuk menyimpan data dasar kami. <a name="habracut"></a><br><br>  Sebelum kita membahas cara berbagi data, mari kenali mereka dengan lebih baik.  Kami akan menyiapkan cahaya yang bagus, mendapatkan stroberi dalam cokelat, mengingat kutipan dari Star Trek ... <br><br>  Pinterest adalah mesin pencari untuk semua yang menarik minat Anda.  Dalam hal data, Pinterest adalah grafik minat manusia terbesar di dunia.  Ini berisi lebih dari 50 miliar pin yang telah disimpan oleh pengguna di lebih dari satu miliar papan.  Orang-orang menyimpan pin untuk diri mereka sendiri dan seperti pin lainnya, berlangganan pin, papan, dan minat lainnya, melihat feed rumah semua pin, papan, dan minat tempat mereka berlangganan.  Hebat!  Sekarang mari kita buat skalabel! <br><br><h3>  Pertumbuhan yang menyakitkan </h3><br>  Pada 2011, kami mulai mendapatkan momentum.  Menurut beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perkiraan</a> , kami tumbuh lebih cepat dari startup mana pun yang dikenal saat itu.  Sekitar September 2011, setiap komponen infrastruktur kami kelebihan beban.  Kami memiliki beberapa teknologi NoSQL yang kami miliki, dan semuanya gagal total.  Kami juga memiliki banyak budak MySQL, yang biasa kami baca, yang menyebabkan banyak kesalahan luar biasa, terutama saat caching.  Kami membangun kembali seluruh model penyimpanan kami.  Untuk bekerja secara efisien, kami dengan hati-hati mendekati pengembangan persyaratan. <br><br><h3>  Persyaratan </h3><br><ul><li>  Seluruh sistem harus sangat stabil, mudah dioperasikan dan skala dari ukuran kotak kecil ke ukuran bulan saat situs tumbuh. </li><li>  Semua konten yang dihasilkan oleh pinner harus tersedia di situs kapan saja. </li><li>  Sistem harus mendukung permintaan untuk pin N di papan tulis dalam urutan deterministik (misalnya, dalam urutan terbalik waktu pembuatan atau dalam urutan yang ditentukan oleh pengguna).  Hal yang sama berlaku untuk pinners seperti, pin mereka, dll. </li><li> Untuk mempermudah, Anda harus mengusahakan pembaruan dengan segala cara yang memungkinkan.  Untuk mendapatkan konsistensi yang diperlukan, mainan tambahan, seperti jurnal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi yang</a> didistribusikan, akan diperlukan.  Sangat menyenangkan dan (tidak terlalu) mudah! </li></ul><br><h3>  Filsafat Arsitektur dan Catatan </h3><br>  Karena kami ingin data ini menjangkau beberapa basis data, kami tidak bisa menggunakan gabungan, kunci asing, dan indeks untuk mengumpulkan semua data, meskipun mereka dapat digunakan untuk subquery yang tidak menjangkau basis data. <br><br>  Kami juga perlu menjaga keseimbangan muatan pada data.  Kami memutuskan bahwa memindahkan data, elemen demi elemen, akan membuat sistem menjadi tidak perlu dan menyebabkan banyak kesalahan.  Jika kami perlu memindahkan data, lebih baik memindahkan seluruh simpul virtual ke simpul fisik lain. <br><br>  Agar implementasi kami cepat masuk ke sirkulasi, kami membutuhkan solusi paling sederhana dan paling nyaman dan node yang sangat stabil di platform data terdistribusi kami. <br>  Semua data harus direplikasi ke mesin slave untuk membuat cadangan, dengan ketersediaan tinggi dan membuang ke S3 untuk MapReduce.  Kami berinteraksi dengan master hanya pada produksi.  Pada produksi, Anda tidak akan ingin menulis atau membaca di slave.  Slave lag, dan itu menyebabkan bug aneh.  Jika pecahan dilakukan, tidak ada gunanya berinteraksi dengan seorang budak pada produksi. <br><br>  Akhirnya, kita membutuhkan cara yang baik untuk menghasilkan pengidentifikasi unik universal (UUID) untuk semua objek kita. <br><br><h3>  Bagaimana kami melakukan sharding </h3><br>  Apa yang akan kami ciptakan, harus memenuhi persyaratan, bekerja secara stabil, secara umum, bisa dikerjakan dan dipelihara.  Itulah mengapa kami memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknologi</a> MySQL yang sudah cukup matang sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">teknologi</a> yang mendasarinya.  Kami sengaja waspada terhadap teknologi baru untuk penskalaan otomatis MongoDB, Cassandra dan Membase, karena mereka cukup jauh dari kedewasaan (dan dalam kasus kami mereka pecah dengan cara yang mengesankan!). <br><blockquote>  Selain itu: Saya masih merekomendasikan startup untuk menghindari hal-hal aneh baru - coba gunakan MySQL.  Percayalah padaku.  Saya bisa membuktikannya dengan bekas luka. </blockquote>  MySQL - teknologinya terbukti, stabil, dan sederhana - ia berfungsi.  Kami tidak hanya menggunakannya, tetapi juga populer di perusahaan lain dengan skala yang lebih mengesankan.  MySQL sepenuhnya memenuhi kebutuhan kami untuk merampingkan kueri data, memilih rentang data tertentu dan transaksi tingkat-baris.  Bahkan, di gudang senjatanya ada lebih banyak peluang, tetapi kita semua tidak membutuhkannya.  Tetapi MySQL adalah solusi "kemas", jadi data harus dibelokkan.  Inilah solusi kami: <br>  Kami mulai dengan delapan server EC2, satu contoh MySQL pada masing-masing: <br><br><img src="https://habrastorage.org/webt/e0/d0/o0/e0d0o0fijurp6mabuvbwecacnfi.png"><br><br>  Setiap server master-master MySQL direplikasi ke host cadangan jika terjadi kegagalan primer.  Server produksi kami hanya membaca atau menulis untuk dikuasai.  Saya sarankan Anda melakukannya juga.  Ini sangat menyederhanakan dan menghindari kesalahan dengan penundaan replikasi. <br><br>  Setiap entitas MySQL memiliki banyak basis data: <br><br><img src="https://habrastorage.org/webt/zf/vl/sx/zfvlsxbhhh6uict7kf9ly6f2y9m.png"><br><br>  Perhatikan bahwa setiap database secara unik dinamai: db00000, db00001 hingga dbNNNNN.  Setiap basis data adalah pecahan data kami.  Kami membuat keputusan arsitektural, dengan dasar hanya sebagian data yang jatuh ke dalam beling, dan itu tidak pernah melampaui beling ini.  Namun, Anda bisa mendapatkan lebih banyak kapasitas dengan memindahkan serpihan ke mesin lain (kami akan membicarakannya nanti). <br><br>  Kami bekerja dengan tabel konfigurasi yang menunjukkan mesin mana yang memiliki pecahan: <br><br><pre><code class="bash hljs">[{“range”: (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”}, {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”}, ... {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]</code> </pre> <br>  Konfigurasi ini hanya berubah ketika kita perlu memindahkan pecahan atau mengganti host.  Jika <code>master</code> mati, kita bisa menggunakan <code>slave</code> ada, dan kemudian mengambil yang baru.  Konfigurasi ini terletak di <a href="">ZooKeeper</a> dan, ketika diperbarui, dikirim ke layanan yang melayani MySQL shard. <br><br>  Setiap pecahan memiliki set tabel yang sama: <code>pins</code> , <code>boards</code> , <code>users_has_pins</code> , <code>users_likes_pins</code> , <code>pin_liked_by_user</code> , dll.  Saya akan membicarakannya nanti. <br><br>  Bagaimana kita mendistribusikan data untuk pecahan ini? <br><br>  Kami membuat ID 64-bit yang berisi ID beling, tipe data yang terkandung di dalamnya, dan tempat data ini ada di tabel (ID lokal).  ID beling terdiri dari 16 bit, tipe ID adalah 10 bit, dan ID lokal adalah 36 bit.  Ahli matematika tingkat lanjut akan memperhatikan bahwa hanya ada 62 bit.  Pengalaman masa lalu saya sebagai pembuat kompiler dan papan sirkuit telah mengajarkan saya bahwa bit cadangan bernilai emas.  Jadi, kami memiliki dua bit seperti itu (set ke nol). <br><br><pre> <code class="bash hljs">ID = (shard ID &lt;&lt; 46) | (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ID &lt;&lt; 36) | (<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> ID&lt;&lt;0)</code> </pre> <br>  Mari kita ambil pin ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.pinterest.com/pin/241294492511762325/</a> , mari kita analisis ID-nya 241294492511762325: <br><br><pre> <code class="bash hljs">Shard ID = (241294492511762325 &gt;&gt; 46) &amp; 0xFFFF = 3429 Type ID = (241294492511762325 &gt;&gt; 36) &amp; 0x3FF = 1 Local ID = (241294492511762325 &gt;&gt; 0) &amp; 0xFFFFFFFFF = 7075733</code> </pre> <br>  Dengan demikian, objek pin hidup di 3429 beling.  Jenisnya adalah "1" (yaitu, "Pin"), dan ada pada baris 7075733 dalam tabel pin.  Sebagai contoh, mari kita bayangkan pecahan ini ada di MySQL012A.  Kita bisa mendapatkannya sebagai berikut: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”MySQL012A”) conn.execute(“SELECT data FROM db03429.pins <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> local_id=7075733”)</code> </pre> <br><br>  Ada dua jenis data: objek dan pemetaan.  Objek berisi bagian, seperti data pin. <br><br><h4>  Tabel Obyek </h4><br>  Tabel objek seperti Pin, pengguna, papan, dan komentar memiliki ID (ID lokal, dengan kunci primer yang meningkat secara otomatis) dan gumpalan yang berisi JSON dengan semua data objek. <br><br><pre> <code class="bash hljs">CREATE TABLE pins ( local_id INT PRIMARY KEY AUTO_INCREMENT, data TEXT, ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ENGINE=InnoDB;</code> </pre> <br>  Misalnya, objek pin terlihat seperti ini: <br><br><pre> <code class="bash hljs">{“details”: “New Star Wars character”, “link”: “http://webpage.com/asdf”, “user_id”: 241294629943640797, “board_id”: 241294561224164665, …}</code> </pre> <br>  Untuk membuat pin baru, kami mengumpulkan semua data dan membuat gumpalan JSON.  Kemudian kami memilih ID beling (kami lebih memilih untuk memilih ID beling yang sama seperti papan tempat ia ditempatkan, tetapi ini tidak perlu).  Untuk jenis pin 1. Kami terhubung ke database ini dan memasukkan JSON ke tabel pin.  MySQL akan mengembalikan ID lokal yang meningkat secara otomatis.  Sekarang kami memiliki pecahan, tipe dan ID lokal baru, sehingga kami dapat mengkompilasi pengidentifikasi 64-bit penuh! <br><br>  Untuk mengedit pin, kami membaca-memodifikasi-menulis JSON menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi MySQL</a> : <br><br><pre> <code class="bash hljs">&gt; BEGIN &gt; SELECT blob FROM db03429.pins WHERE local_id=7075733 FOR UPDATE [Modify the json blob] &gt; UPDATE db03429.pins SET blob=<span class="hljs-string"><span class="hljs-string">'&lt;modified blob&gt;'</span></span> WHERE local_id=7075733 &gt; COMMIT</code> </pre> <br>  Untuk menghapus pin, Anda dapat menghapus barisnya di MySQL.  Namun, lebih baik menambahkan bidang <i>"aktif"</i> di JSON dan mengaturnya ke <i>"salah"</i> , serta menyaring hasil di sisi klien. <br><br><h4>  Tabel Pemetaan </h4><br>  Tabel pemetaan menautkan satu objek ke objek lain, misalnya papan dengan pin di atasnya.  Tabel MySQL untuk pemetaan berisi tiga kolom: 64-bit untuk ID "from", 64-bit untuk ID "where" dan urutan ID.  Dalam triple ini (dari mana, di mana, urutan) ada kunci indeks, dan mereka berada di beling pengidentifikasi "dari". <br><br><pre> <code class="bash hljs">CREATE TABLE board_has_pins ( board_id INT, pin_id INT, sequence INT, INDEX(board_id, pin_id, sequence) ) ENGINE=InnoDB;</code> </pre> <br>  Tabel pemetaan adalah searah, misalnya, seperti tabel <code>board_has_pins</code> .  Jika Anda membutuhkan arah yang berlawanan, Anda perlu tabel <code>pin_owned_by_board</code> terpisah.  ID urutan menentukan urutan (ID kami tidak dapat dibandingkan antara pecahan, karena ID lokal baru berbeda).  Biasanya kami memasukkan pin baru di papan baru dengan urutan ID sama dengan waktu di unix (cap waktu unix).  Jumlah apa pun dapat berurutan, tetapi waktu unix adalah cara yang baik untuk menyimpan bahan baru secara berurutan, karena indikator ini meningkat secara monoton.  Anda dapat melihat data di tabel pemetaan: <br><br><pre> <code class="bash hljs">SELECT pin_id FROM board_has_pins WHERE board_id=241294561224164665 ORDER BY sequence LIMIT 50 OFFSET 150</code> </pre> <br>  Ini akan memberi Anda lebih dari 50 pin_id, yang kemudian dapat Anda gunakan untuk mencari objek pin. <br>  Apa yang baru saja kita lakukan adalah penggabungan lapisan aplikasi (board_id -&gt; pin_id -&gt; objek pin).  Salah satu properti koneksi yang menakjubkan pada level aplikasi adalah Anda dapat men-cache gambar secara terpisah dari objek.  Kami menyimpan pin_id di cache dari objek pin di cluster memcache, namun kami menyimpan board_id di pin_id di cluster redis.  Ini memungkinkan kita untuk memilih teknologi yang tepat yang paling sesuai dengan objek yang di-cache. <br><br><h3>  Tingkatkan kapasitas </h3><br>  Ada tiga cara utama untuk meningkatkan kapasitas dalam sistem kami.  Cara termudah untuk memperbarui mesin (untuk menambah ruang, meletakkan hard drive lebih cepat, lebih banyak RAM). <br>  Cara selanjutnya untuk meningkatkan kapasitas adalah membuka rentang baru.  Awalnya, kami membuat total 4096 pecahan, meskipun fakta bahwa ID beling terdiri dari 16 bit (total 64rb pecahan).  Objek baru hanya dapat dibuat di pecahan 4k pertama ini.  Pada titik tertentu, kami memutuskan untuk membuat server MySQL baru dengan pecahan dari 4096 hingga 8191 dan mulai mengisinya. <br><br>  Cara terakhir kami meningkatkan kapasitas adalah memindahkan beberapa pecahan ke alat berat baru.  Jika kami ingin meningkatkan kapasitas MySQL001A (dengan pecahan dari 0 hingga 511), kami membuat pasangan master-master baru dengan nama maksimum yang mungkin berikut (katakanlah MySQL009A dan B) dan mulai replikasi dari MySQL001A. <br><br><img src="https://habrastorage.org/webt/d2/uf/gd/d2ufgd1tttsa6tmxvpywfzgqugs.png"><br><br>  Segera setelah replikasi selesai, kami mengubah konfigurasi kami sehingga di MySQL001A hanya ada pecahan dari 0 hingga 255, dan di MySQL009A dari 256 menjadi 511. Sekarang setiap server harus memproses hanya setengah dari pecahan yang diproses sebelumnya. <br><br><img src="https://habrastorage.org/webt/4f/cp/do/4fcpdo2g16molbdkkfbf8xvujbi.png"><br><br><h3>  Beberapa fitur keren </h3><br>  Mereka yang sudah memiliki sistem untuk menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UUID</a> baru akan memahami bahwa dalam sistem ini kita mendapatkannya tanpa biaya!  Saat Anda membuat objek baru dan menyisipkannya ke dalam tabel objek, ia mengembalikan pengidentifikasi lokal baru.  ID lokal ini, dikombinasikan dengan ID shard dan tipe ID, memberi Anda UUID. <br><br>  Anda yang telah melakukan ALTER untuk menambahkan lebih banyak kolom ke tabel MySQL tahu bahwa mereka dapat bekerja sangat lambat dan menjadi masalah besar.  Pendekatan kami tidak memerlukan perubahan level MySQL.  Di Pinterest, kami mungkin hanya membuat satu ALTER dalam tiga tahun terakhir.  Untuk menambahkan bidang baru ke objek, cukup beri tahu layanan Anda bahwa ada beberapa bidang baru di skema JSON.  Anda dapat mengubah nilai default sehingga saat deserializing JSON dari objek tanpa bidang baru, Anda mendapatkan nilai default.  Jika Anda membutuhkan tabel pemetaan, buat tabel pemetaan baru dan mulailah mengisinya kapan pun Anda mau.  Dan setelah selesai, Anda dapat mengirim! <br><br><h3>  Mod beling </h3><br>  Ini hampir seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regu mod</a> , hanya sangat berbeda. <br><br>  Beberapa objek perlu ditemukan tanpa ID.  Misalnya, jika pengguna masuk dengan akun Facebook, kami perlu pemetaan dari ID Facebook ke Pinterest ID.  Bagi kami, ID Facebook hanyalah bit, jadi kami menyimpannya dalam sistem beling terpisah yang disebut mod shard. <br><br>  Contoh lain termasuk alamat IP, nama pengguna dan alamat email. <br>  Mod Shard sangat mirip dengan sistem sharding yang dijelaskan di bagian sebelumnya, dengan satu-satunya perbedaan adalah Anda dapat mencari data menggunakan data input yang berubah-ubah.  Input ini di-hash dan dimodifikasi sesuai dengan jumlah total pecahan dalam sistem.  Akibatnya, sebuah pecahan akan diperoleh di mana data akan atau sudah ditemukan.  Sebagai contoh: <br><br><pre> <code class="bash hljs">shard = md5(“1.2.3.4<span class="hljs-string"><span class="hljs-string">") % 4096</span></span></code> </pre> <br>  Dalam hal ini, shard akan sama dengan 1524. Kami memproses file konfigurasi yang sesuai dengan ID shard: <br><br><pre> <code class="bash hljs">[{“range”: (0, 511), “master”: “msdb001a”, “slave”: “msdb001b”}, {“range”: (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”}, {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”}, …]</code> </pre> <br>  Jadi, untuk menemukan data pada alamat IP 1.2.3.4, kita perlu melakukan hal berikut: <br><br><pre> <code class="bash hljs">conn = MySQLdb.connect(host=”msdb003a”) conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip=<span class="hljs-string"><span class="hljs-string">'1.2.3.4'</span></span>”)</code> </pre> <br>  Anda kehilangan beberapa properti ID shard yang baik, seperti lokalitas spasial.  Anda harus mulai dengan semua pecahan yang dibuat di awal dan membuat sendiri kunci (itu tidak akan dihasilkan secara otomatis).  Itu selalu lebih baik untuk mewakili objek pada sistem Anda dengan ID abadi.  Dengan demikian, Anda tidak perlu memperbarui banyak tautan ketika, misalnya, pengguna mengubah "nama pengguna" -nya. <br><br><h3>  Pikiran terakhir </h3><br>  Sistem ini telah menjalankan produksi di Pinterest selama 3,5 tahun, dan kemungkinan akan bertahan selamanya.  Menerapkannya relatif sederhana, tetapi menjalankannya dan memindahkan semua data dari mesin lama itu sulit.  Jika Anda mengalami masalah ketika Anda baru saja membuat pecahan baru, pertimbangkan untuk membuat sekelompok mesin pengolah data latar belakang (petunjuk: gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan</a> ) untuk memindahkan data Anda dengan skrip dari basis data lama ke pecahan baru Anda.  Saya menjamin bahwa beberapa data akan hilang, tidak peduli seberapa keras Anda mencoba (semuanya gremlin, saya bersumpah), jadi ulangi transfer data berulang-ulang sampai jumlah informasi baru di beling menjadi sangat kecil atau tidak sama sekali. <br><br>  Segala upaya telah dilakukan untuk sistem ini.  Tetapi itu tidak memberikan atomitas, isolasi atau koherensi dengan cara apa pun.  Wow!  Kedengarannya buruk!  Tapi jangan khawatir.  Tentunya, Anda akan merasa luar biasa tanpa mereka.  Anda selalu dapat membangun lapisan ini dengan proses / sistem lain, jika perlu, tetapi secara default dan tanpa biaya Anda sudah mendapatkan cukup banyak: kapasitas kerja.  Keandalan dicapai melalui kesederhanaan, dan bahkan bekerja dengan cepat! <br><br>  Tetapi bagaimana dengan toleransi kesalahan?  Kami menciptakan layanan untuk melayani pecahan MySQL, menyimpan tabel konfigurasi pecahan di ZooKeeper.  Ketika server master crash, kami menaikkan mesin slave dan kemudian menaikkan mesin yang akan menggantinya (selalu up to date).  Kami tidak menggunakan pemrosesan kegagalan otomatis hingga hari ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467389/">https://habr.com/ru/post/id467389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467377/index.html">Tiga berturut-turut: 10 laporan teratas dari Mobius 2019 Piter</a></li>
<li><a href="../id467381/index.html">LED bertingkat, lampu pintar, dan lampu untuk 18 rubel</a></li>
<li><a href="../id467383/index.html">"Manajer harus tetap mengkode": wawancara dengan Stephen Chin</a></li>
<li><a href="../id467385/index.html">Pilihan pertanyaan teknis psikologis dan atipikal dari wawancara pengembang Java</a></li>
<li><a href="../id467387/index.html">Solusi untuk bekerja dengan umpan balik dan pengalaman pelanggan: dari layanan kecil hingga platform berat</a></li>
<li><a href="../id467391/index.html">Yandex memperkenalkan RPKI</a></li>
<li><a href="../id467393/index.html">NX Bootcamp dimulai pada bulan Oktober</a></li>
<li><a href="../id467395/index.html">Habr Weekly # 18 / New Apple Gadgets, smartphone sepenuhnya modular, desa programmer di Belarus, fenomena XY</a></li>
<li><a href="../id467399/index.html">Anda tidak dapat melarang untuk membawa: bagaimana menerapkan konsep BYOD dan tidak membahayakan keamanan informasi</a></li>
<li><a href="../id467401/index.html">Perbandingan Tesla Model S dan Porsche Taycan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>