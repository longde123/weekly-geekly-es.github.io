<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍄 🍤 👨‍🎓 Sidecar para uma divisão de código 🐕 👩🏿‍🏭 🔅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Divisão de código. A divisão de código está em todo lugar. No entanto, por que? Só porque hoje existe muito javascript e nem todos estão em uso no mes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sidecar para uma divisão de código</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Divisão de código.  A divisão de código está em todo lugar.  No entanto, por que?  Só porque hoje existe <strong>muito javascript</strong> e nem todos estão em uso no mesmo momento. </p><br><p>  JS é uma coisa muito <em>pesada</em> .  Não para o seu iPhone Xs ou para o novo laptop i9, mas para milhões (provavelmente bilhões) de proprietários de dispositivos <em>mais lentos</em> .  Ou, pelo menos, para seus relógios. </p><br><p>  Então - o JS é ruim, mas o que aconteceria se o <strong>desativássemos</strong> - o problema desapareceria ... para alguns sites, e desapareceria "com sites" para os baseados no React.  Mas de qualquer maneira - existem sites que podem funcionar sem JS ... e há algo que devemos aprender com eles ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Divisão de código </h1><br><p>  Hoje temos dois caminhos a percorrer, duas maneiras de melhorar ou não piorar: </p><br><h2 id="1-write-less-code">  1. Escreva menos código </h2><br><p> Essa é a melhor coisa que você pode fazer.  Embora o <code>React Hooks</code> permita que você envie um pouco menos de código, e soluções como o <code>Svelte</code> permitem gerar apenas menos código do que o <em>normal</em> , isso não é tão fácil de fazer. </p><br><p>  Não se trata apenas do código, mas também da <em>funcionalidade</em> - para manter o código "compacto", você precisa mantê-lo "compacto".  Não há como manter pequeno o pacote de aplicativos se ele estiver fazendo tantas coisas (e for enviado em 20 idiomas). </p><br><p>  Existem maneiras de escrever códigos <em>curtos e sonoros</em> e de escrever a implementação oposta - <em>a sangrenta empresa</em> .  E, você sabe, ambos são legítimos. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Mas a questão principal - o próprio código.  Um aplicativo de reação simples pode facilmente ignorar 250kb "recomendado".  E você pode passar um mês otimizando e diminuindo.  Otimizações "pequenas" são bem documentadas e bastante úteis - basta obter o <code>bundle-analyzer</code> com <code>size-limit</code> e voltar à forma. <br>  Existem muitas bibliotecas, que lutam por todos os bytes, tentando mantê-lo em seus limites - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pré</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ação</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">armazenamento</a> , para citar algumas. </p><br><p>  Mas nossa aplicação está um pouco além dos 200kb.  É mais perto de <strong>100Mb</strong> .  Remover kilobytes não faz sentido.  Mesmo remover megabytes não faz sentido. </p><br><blockquote>  Depois de um momento, é impossível manter seu aplicativo pequeno.  Crescerá com o tempo. </blockquote><br><h2 id="2-ship-less-code">  2. Envie menos código </h2><br><p>  Como alternativa, o <code>code split</code> .  Em outras palavras - <strong>render</strong> - <strong>se</strong> .  Pegue o seu pacote de 100mb e faça vinte pacotes de 5mb.  Honestamente - essa é a única maneira possível de lidar com seu aplicativo, se ele for grande - crie um pacote de aplicativos menores a partir dele. </p><br><p>  Mas há uma coisa que você deve saber agora: seja qual for a opção escolhida, é um detalhe de implementação, enquanto procuramos algo mais confiável. </p><br><h1 id="the-truth-about-code-splitting">  A verdade sobre a divisão de código </h1><br><p>  A verdade sobre a divisão de código é que sua natureza é separação do tempo.  Você não está apenas <em>dividindo</em> seu código, mas de uma maneira que <strong>utilizará</strong> o mínimo possível em um único momento. </p><br><p>  Apenas não envie o código que você não precisa no momento.  Livre-se disso. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Fácil de dizer, difícil de fazer.  Tenho alguns aplicativos pesados, mas não adequadamente divididos, em que qualquer página carrega 50% de tudo.  Às vezes <code>code splitting</code> torna uma <code>code separation</code> , quero dizer - você pode mover o código para os diferentes blocos, mas ainda assim, usar tudo.  Lembre-se de que <em>"simplesmente não envie o código que você não precisa no momento"</em> , - eu <em>precisava de</em> 50% do código, e esse era o problema real. </p><br><blockquote>  Às vezes, basta adicionar a <code>import</code> aqui e não é suficiente.  Até que não seja a separação do <strong>tempo</strong> , mas apenas a separação do <strong>espaço</strong> - isso não importa. </blockquote><p>  Existem três maneiras comuns de dividir o código: </p><br><ol><li>  Apenas <code>import</code> dinâmica.  Mal usado sozinho hoje em dia.  É mais sobre problemas com o rastreamento de um <em>estado</em> . </li><li>  <code>Lazy</code> Component, quando você pode adiar a renderização e o carregamento de um React Component.  Provavelmente 90% dos "códigos de reação dividem" atualmente. </li><li>  <code>Library</code> <em>Preguiçosa</em> , que na verdade é <code>.1</code> , mas você receberá um código de biblioteca por meio de objetos de renderização do React.  Implementado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">componentes importados de reação e componentes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregáveis</a> .  Bastante útil, mas não bem conhecido. </li></ol><br><h2 id="component-level-code-splitting">  Divisão de código no nível do componente </h2><br><p>  Este é o mais popular.  Como uma divisão de código por rota ou divisão de código por componente.  Não é tão fácil fazê-lo e, como <em>resultado,</em> mantém bons <em>resultados perceptivos</em> .  É a morte do <code>Flash of Loading Content</code> . </p><br><p>  As boas técnicas são: </p><br><ul><li>  carrega <code>js chunk</code> e <code>data</code> para uma rota em paralelo. </li><li>  use um <code>skeleton</code> para exibir algo semelhante à página antes do carregamento da página (como o Facebook). </li><li>  <code>prefetch</code> pedaços, você pode até usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palpites-js</a> para obter uma previsão melhor. </li><li>  use alguns atrasos, indicadores de carregamento, <code>animations</code> e <code>Suspense</code> (no futuro) para suavizar as transições. </li></ul><br><p>  E, você sabe, isso é tudo sobre desempenho <em>perceptivo</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Imagem do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://blog.angularindepth.com/">UX aprimorado com elementos do Ghost</a> </blockquote><br><h1 id="that-doesnt-sound-good">  Isso não parece bom </h1><br><p>  Sabe, eu poderia me chamar de especialista em divisão de código - mas tenho minhas próprias falhas. </p><br><p>  Às vezes, falhava em reduzir o tamanho do pacote.  Às vezes, falhava em melhorar o desempenho resultante, contanto que <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  É chamado de <strong>ondas de carregamento</strong> . </p><br><ul><li>  sem SSR ou pré-renderização.  O SSR adequado é um divisor de águas no momento. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  Na semana passada, tenho duas falhas: </p><br><ul><li>  Eu perdi em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma comparação de biblioteca</a> , desde que minha biblioteca fosse melhor, mas MUITO maior que outra.  Falha ao <strong>"1. Escreva menos código"</strong> . </li><li>  otimizar um site pequeno, feito em React por minha esposa.  Ele estava usando a divisão de componentes baseada em rota, mas o <code>header</code> e o <code>footer</code> foram mantidos no pacote principal para tornar as transições mais "aceitáveis".  Apenas algumas coisas, <strong>firmemente acopladas</strong> entre si, com o lado do pacote disparado até 320kb (antes do gzip).  Não havia nada importante e nada que eu realmente pudesse remover.  <strong>Uma morte por mil cortes</strong> .  Falha ao <strong>enviar menos código</strong> . </li></ul><br><blockquote>  React-Dom foi de 20%, core-js foi de 10%, react-router, jsLingui, react-powerplug ... 20% de código próprio ... Já terminamos. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  A solução </h2><br><p>  Comecei a pensar em como resolver meu problema e por que <em>soluções comuns</em> não estão funcionando corretamente no meu caso de uso. </p><br><blockquote>  O que eu fiz?  Listei todos os locais cruciais, sem os quais o aplicativo não funcionaria, e tentei entender por que tenho o restante. </blockquote><p>  Foi uma surpresa.  Mas meu problema estava no CSS.  Em transição de baunilha CSS. </p><br><p>  Aqui está o código </p><br><ul><li>  uma variável de <em>controle</em> - <code>componentControl</code> , eventualmente seria definida como algo que <code>DisplayData</code> deve exibir. </li><li>  uma vez que o valor é definido - <code>DisplayData</code> se torna visível, alterando <code>className</code> , provocando uma transição sofisticada.  Simultaneamente, o <code>FocusLock</code> se torna ativo, tornando o <code>DisplayData</code> um <strong>modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Gostaria de dividir esta parte do código como um todo, mas isso é algo que não pude fazer devido a dois motivos: </p><br><ol><li>  as informações devem estar visíveis imediatamente, uma vez necessárias, sem demora.  Um requisito comercial. </li><li>  a informação "chrome" deve existir antes, para lidar com a transição da propriedade. </li></ol><br><p>  Esse problema pode ser parcialmente resolvido usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CSSTransitionGroup</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recondição</a> .  Mas, você sabe, corrigir <em>um código</em> adicionando <em>outro código</em> parece estranho, mesmo que seja <em>suficiente</em> .  Quero dizer, adicionar mais código pode ajudar a remover ainda mais código.  Mas ... mas ... </p><br><blockquote>  Deve haver uma maneira melhor! </blockquote><p>  TL; DR - há dois pontos principais aqui: </p><br><ul><li>  <code>DisplayData</code> deve ser <strong>montado</strong> e existe no DOM anterior. </li><li>  <code>FocusLock</code> também deve existir antes, para não causar a <code>DisplayData</code> , mas seus <strong>cérebros não são necessários</strong> no começo. </li></ul><br><hr><br><p>  Então, vamos mudar nosso modelo mental </p><br><h1 id="batman-and-robin">  Batman e robin </h1><br><p>  Vamos supor que nosso código seja Batman e Robin.  Batman pode lidar com a maioria dos bandidos, mas quando ele não pode, seu companheiro Robin vem em socorro .. </p><br><blockquote>  Mais uma vez, Batman entraria na batalha, Robin chegaria mais tarde. </blockquote><p>  Aqui é o Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Este é o seu companheiro, Robin: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman e Robin poderiam formar uma <em>EQUIPE</em> , mas na verdade são duas pessoas diferentes. </p><br><p>  E não se esqueça - ainda estamos falando sobre <strong>divisão de código</strong> .  E, em termos de divisão de código, onde está o ajudante?  Onde está Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  em um carro lateral.  Robin está esperando em um <strong>pedaço lateral</strong> . </blockquote><br><h1 id="sidecar">  Sidecar </h1><br><ul><li>  <code>Batman</code> aqui é tudo visual que seu cliente deve ver o mais rápido possível.  Idealmente instantaneamente. </li><li>  <code>Robin</code> aqui é toda lógica, e recursos interativos sofisticados, que podem estar disponíveis um segundo depois, mas não no começo. </li></ul><br><p>  Seria melhor chamar isso de <strong>divisão de código vertical</strong> onde as ramificações de código existem em paralelo, ao contrário de uma <strong>divisão de código horizontal</strong> comum onde as ramificações de código são <em>cortadas</em> . </p><br><p>  Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns países</a> , esse trio era conhecido como <code>replace reducer</code> ou outras maneiras de carregar preguiçosamente a lógica do redux e os efeitos colaterais. </p><br><p>  Em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns outros países</a> , é conhecido como <code>"3 Phased" code splitting</code> . </p><br><blockquote>  É apenas mais uma separação de preocupações, aplicável apenas a casos, em que é possível adiar o carregamento de parte de um componente, mas não de outra parte. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="fase 3"></p><br><blockquote>  imagem de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Criando o novo facebook.com com React, GraphQL e Relay</a> , em que <code>importForInteractions</code> ou <code>importAfter</code> <strong>são o <code>sidecar</code> - <code>sidecar</code></strong> . </blockquote><p>  E há uma observação <strong>interessante</strong> - enquanto <code>Batman</code> é mais valioso para um cliente, desde que seja algo que o cliente possa <em>ver</em> , ele está sempre em forma ... Enquanto <code>Robin</code> , você sabe, ele pode estar um pouco <em>acima do peso</em> e exigir muito mais bytes para vivendo. </p><br><p>  Como resultado - o Batman sozinho é algo muito suportável para um cliente - ele fornece mais valor a um custo menor.  Você é meu herói Bat! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  O que pode ser movido para um carro lateral: </h2><br><ul><li>  maioria dos <code>useEffect</code> , <code>componentDidMount</code> e amigos. </li><li>  como todos os efeitos <em>modais</em> .  Ou seja, bloqueios de <code>focus</code> e <code>scroll</code> .  Você pode primeiro exibir um modal e <strong>só depois</strong> torná-lo <em>modal</em> , ou seja, "bloquear" a atenção do cliente. </li><li>  Formulários  Mova toda a lógica e validações para um side-car e bloqueie o envio do formulário até que essa lógica seja carregada.  O cliente pode começar a preencher o formulário, sem saber que é apenas o <code>Batman</code> . </li><li>  Algumas animações.  Uma <code>react-spring</code> inteira <code>react-spring</code> no meu caso. </li><li>  Algumas coisas visuais.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">barras de rolagem personalizadas</a> , que podem exibir barras de rolagem sofisticadas um segundo depois. </li></ul><br><p>  Além disso, não se esqueça - todo código, transferido para um side-car, também transfere coisas como core-js poly- e ponyfills, usadas pelo código removido. </p><br><p>  A Divisão de Código pode ser mais inteligente do que em nossos aplicativos hoje.  Devemos perceber que existem 2 tipos de <em>código</em> a serem divididos: 1) aspectos visuais 2) aspectos interativos.  O último pode vir alguns momentos depois.  <code>Sidecar</code> facilita a divisão das duas tarefas, dando a <em>percepção de que tudo foi carregado mais rapidamente</em> .  E vai. </p><br><h2 id="the-oldest-way-to-code-split">  A maneira mais antiga de dividir código </h2><br><p>  Embora ainda não esteja claro quando e o que é um <code>sidecar</code> , darei uma explicação simples: </p><br><blockquote>  <code>Sidecar</code> é <strong>TODOS OS SEUS SCRIPTS</strong> .  Sidecar é a maneira como <em>dividimos o código</em> antes de todas as coisas de front-end que recebemos hoje. </blockquote><p>  Eu estou falando sobre Server Side Rendering ( <strong>SSR</strong> ), ou <strong>HTML</strong> simples, todos nós estávamos acostumados ontem.  <code>Sidecar</code> torna as coisas mais fáceis do que costumavam ser quando as páginas continham HTML e lógica vividas separadamente em scripts externos incorporáveis ​​(separação de preocupações). </p><br><p>  Tínhamos HTML, <strong>além de</strong> CSS, <strong>além de</strong> alguns scripts embutidos, <strong>além</strong> do restante dos scripts extraídos para arquivos <code>.js</code> . </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> eram <code>Batman</code> , enquanto scripts externos eram <code>Robin</code> , e o site funcionava sem Robin e, honestamente, parcialmente sem Batman (ele continuará a luta com as duas pernas (scripts embutidos) quebradas).  Isso foi ontem, e muitos sites "não modernos e legais" são os mesmos hoje. </p><br><hr><br><p>  Se o seu aplicativo suportar SSR - tente <strong>desabilitar o js</strong> e fazê-lo funcionar sem ele.  Então ficaria claro o que poderia ser movido para um carro lateral. <br>  Se o seu aplicativo for um SPA somente do lado do cliente - tente imaginar como ele funcionaria, se o SSR existisse. </p><br><blockquote>  Por exemplo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">theurge.com</a> , escrito em React, é totalmente funcional <strong>sem nenhum js ativado</strong> . </blockquote><p>  Há muitas coisas que você pode descarregar para um carro lateral.  Por exemplo: </p><br><ul><li>  comentários.  Você pode enviar o código para <code>display</code> comentários, mas não <code>answer</code> , desde que exija mais código (incluindo o editor WYSIWYG), o que não é necessário inicialmente.  É melhor atrasar uma <em>caixa de comentários</em> , ou mesmo ocultar o carregamento de código atrás da animação, do que atrasar uma página inteira. </li><li>  player de vídeo.  Envie "vídeo" sem "controles".  Carregue-os um segundo depois, o cliente pode tentar interagir com ele. </li><li>  galeria de imagens, como <code>slick</code> .  Não é grande coisa <strong>desenhar</strong> , mas muito mais difícil de animar e gerenciar.  Está claro o que pode ser movido para um carro lateral. </li></ul><br><blockquote>  Basta pensar no que é essencial para a sua aplicação e no que não é bem ... </blockquote><br><h1 id="implementation-details">  Detalhes da implementação </h1><br><h2 id="di-component-code-splitting">  (DI) Divisão do código do componente </h2><br><p>  A forma mais simples de <code>sidecar</code> é fácil de implementar - basta mover tudo para um subcomponente; você pode codificar a divisão usando maneiras "antigas".  É quase uma separação entre os componentes Smart e Dumb, mas desta vez o Smart não está <em>contanitando</em> um Dumb - é o oposto. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Isso também requer mover o código de <em>inicialização</em> para um Dumb, mas você ainda pode dividir a parte <em>mais pesada</em> de um código. </p><br><blockquote>  Você pode ver um padrão de divisão de código <code>parallel</code> ou <code>vertical</code> agora? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A criação do novo facebook.com com React, GraphQL e Relay</a> , como já mencionei aqui, tinha um conceito de <code>loadAfter</code> ou <code>importForInteractivity</code> , que é bastante parecido com o conceito de sidecar. </p><br><p>  Ao mesmo tempo, eu não recomendaria a criação de algo como <code>useSidecar</code> , desde que você intencionalmente tente usar <code>hooks</code> dentro, mas a divisão de código nesse formulário quebraria a <em>regra dos ganchos</em> . </p><br><p>  Por favor, prefira uma forma de componente mais declarativa.  E você pode usar <code>hooks</code> dentro do componente <code>SideCar</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Pré-busca </h2><br><p>  Não se esqueça - você pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dicas de prioridade de carregamento</a> para pré-carregar ou pré-buscar <code>sidecar</code> e torná-lo mais transparente e invisível. </p><br><p>  Coisas importantes - os scripts de pré-busca o carregariam via <strong>rede</strong> , mas não executam (e gastam CPU), a menos que seja realmente necessário. </p><br><h2 id="ssr">  SSR </h2><br><p>  Diferentemente da divisão <em>normal do</em> código, nenhuma ação especial é necessária para o SSR.  <code>Sidecar</code> pode não fazer parte do processo SSR e não ser necessário antes da etapa de <code>hydration</code> .  Pode ser adiado "por design". </p><br><p>  Portanto, sinta-se à vontade para usar o <code>React.lazy</code> (idealmente algo <strong>sem o</strong> <code>Suspense</code> , você não precisa de nenhum indicador de failback (carregamento) aqui), ou qualquer outra biblioteca, com, mas melhor, sem o suporte do SSR para <em>pular</em> pedaços do sidecar durante o processo do SSR. </p><br><h1 id="the-bad-parts">  As partes ruins </h1><br><p>  Mas existem algumas partes ruins dessa ideia </p><br><h2 id="batman-is-not-a-production-name">  Batman não é um nome de produção </h2><br><p>  Embora <code>Batman</code> / <code>Robin</code> possa ser um bom conceito, o <code>sidecar</code> é uma combinação perfeita para a própria tecnologia - não existe um nome "bom" para o <code>maincar</code> .  Não existe um <code>maincar</code> , e obviamente <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> e <code>Solo</code> não devem ser usados ​​para nomear uma parte que não é um carro lateral. </p><br><p>  O Facebook usou <code>display</code> e <code>interactivity</code> , e essa pode ser a melhor opção para todos nós. </p><br><blockquote>  Se você tem um bom nome para mim - deixe nos comentários </blockquote><br><h2 id="tree-shaking">  Árvore tremendo </h2><br><p>  É mais sobre a separação de preocupações do ponto de vista do <em>bundler</em> .  Vamos imaginar que você tem <code>Batman</code> e <code>Robin</code> .  And <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Então você pode tentar dividir o código do <em>componente</em> para implementar um side-car </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  Em resumo - o código acima funcionaria, mas não fará "o trabalho". </p><br><ul><li>  se você estiver usando apenas <code>batman</code> do <code>stuff.js</code> - o tremor da árvore manteria apenas isso. </li><li>  se você estiver usando apenas <code>robin</code> do <code>stuff.js</code> - o tremor da árvore manteria apenas isso. </li><li>  <strong>mas</strong> se você estiver usando os dois, mesmo em partes diferentes - ambos serão agrupados em uma <strong>primeira</strong> ocorrência do <code>stuff.js</code> , ou seja, o <strong>pacote principal</strong> . </li></ul><br><blockquote>  A trepidação de árvores não é favorável à divisão de códigos.  Você precisa separar as preocupações por arquivos. </blockquote><br><h2 id="un-import">  Desimportar </h2><br><p>  Outra coisa, esquecida por todos, é o custo do javascript.  Era bastante comum na era do jQuery, a era da carga útil do <code>jsonp</code> para carregar o script (com a carga útil do <code>json</code> ), obter a carga útil e <strong>remover</strong> o script. </p><br><blockquote>  Hoje em dia todos nós <code>import</code> scripts, e eles serão importados para sempre, mesmo que não sejam mais necessários. </blockquote><p>  Como eu disse antes - há muito JS e, mais cedo ou mais tarde, com <em>a navegação contínua,</em> você carregará tudo.  Deveríamos encontrar uma maneira de cancelar a importação e não precisar mais de chunk, limpando todos os caches internos e liberando memória para tornar a web mais confiável e não esmagar aplicativos com exceções de falta de memória. </p><br><p>  Provavelmente, a capacidade de desinstalar (o webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode fazer isso</a> ) é um dos motivos pelos quais devemos nos ater à API <em>baseada em componentes</em> , desde que ela nos permita lidar com a <code>unmount</code> . </p><br><p>  Até agora - os padrões dos módulos ESM não têm nada sobre isso - nem sobre controle de cache, nem sobre a reversão da ação de importação. </p><br><h2 id="creating-a-sidecar-enabled-library">  Criando uma biblioteca habilitada para sidecar </h2><br><p>  Até hoje, existe apenas uma maneira de criar uma biblioteca habilitada para <code>sidecar</code> : </p><br><ul><li>  divida seu componente em partes </li><li>  expor uma parte <code>main</code> e uma parte <code>connected</code> (para não quebrar a API) via <code>index</code> </li><li>  expor um <code>sidecar</code> através de um ponto de entrada separado. </li><li>  no código de destino - importe a parte <code>main</code> e a agitação da árvore <code>sidecar</code> deve cortar uma parte <code>connected</code> . </li></ul><br><p>  Essa agitação da árvore do tempo deve funcionar corretamente, e o único problema - é como nomear a parte <code>main</code> . </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  Em suma, a mudança pode ser representada através de uma pequena comparação </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  A <code>dynamic import</code> teoricamente <code>dynamic import</code> poderia ser usada dentro de node_modules, tornando o <em>processo de montagem</em> mais transparente. </p><br><blockquote>  Enfim - nada mais é do que <code>slot</code> padrão de <code>children</code> / <code>slot</code> , tão comum no React. </blockquote><br><h1 id="the-future">  O futuro </h1><br><p>  <code>Facebook</code> provou que a ideia está certa.  Se você ainda não viu esse vídeo, faça-o agora.  Acabei de explicar a mesma idéia de um ângulo um pouco diferente (e comecei a escrever este artigo uma semana antes da conferência F8). </p><br><p>  No momento, é necessário que algumas alterações de código sejam aplicadas à sua base de código.  Ele exige uma separação mais explícita das preocupações para separá-las e permitir que os códigos sejam divididos não horizontalmente, mas verticalmente, enviando <em>menos</em> códigos para uma experiência <em>maior do</em> usuário. </p><br><p>  <code>Sidecar</code> , provavelmente, é a única maneira, exceto o SSR da velha escola, de lidar com grandes bases de códigos.  Última chance de enviar uma quantidade mínima de código, quando você tiver muito. </p><br><blockquote>  Isso poderia tornar um aplicativo BIG menor e um aplicativo PEQUENO ainda mais pequeno. </blockquote><p>  Há 10 anos, o site médio estava "pronto" em 300ms e estava <em>realmente</em> pronto alguns milissegundos depois.  Hoje, segundos e até mais de 10 segundos são os números comuns.  Que pena. </p><br><p>  Vamos fazer uma pausa e pensar - como poderíamos resolver o problema e tornar o UX ótimo novamente ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Geral </h1><br><ul><li>  A divisão de código de componente é a ferramenta mais poderosa, oferecendo a capacidade de dividir algo <em>completamente</em> , mas tem um custo - você pode não exibir nada, exceto uma página em branco ou um <em>esqueleto</em> por um tempo.  Essa é uma separação horizontal. </li><li>  A divisão do código da biblioteca pode ajudar quando a divisão do componente não.  Essa é uma separação horizontal. </li><li>  O código transferido para um side-car completaria a imagem e pode permitir que você forneça uma experiência muito melhor ao usuário.  Mas também exigiria algum esforço de engenharia.  Essa é uma separação vertical. </li></ul><br><p>  <strong>Vamos conversar sobre isso</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  Pare!  E os problemas que você tentou resolver? </h2><br><p>  Bem, essa foi apenas a primeira parte.  <strong>Estamos no final do jogo agora</strong> , levaria mais algumas semanas para escrever a segunda parte desta proposta.  Enquanto isso ... entre no carro lateral! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450942/">https://habr.com/ru/post/pt450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450926/index.html">Jogo 3D em three.js, nw.js</a></li>
<li><a href="../pt450928/index.html">Como os data centers salvam feriados</a></li>
<li><a href="../pt450930/index.html">Como desenvolvemos # bigdataX5 e quem é necessário no Big Data</a></li>
<li><a href="../pt450938/index.html">Linux Install Fest 05.19 em Nizhny Novgorod 18 de maio de 2019</a></li>
<li><a href="../pt450940/index.html">Vivaldi 2.5 - Macrocosmo atraente</a></li>
<li><a href="../pt450946/index.html">Telefone celular em disco LPC810</a></li>
<li><a href="../pt450948/index.html">MU-MIMO: um dos algoritmos de implementação</a></li>
<li><a href="../pt450950/index.html">Fundamentos do Dart Streams</a></li>
<li><a href="../pt450952/index.html">Índice Médio e Antibanco</a></li>
<li><a href="../pt450954/index.html">Como aprendemos a explorar Java no Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>