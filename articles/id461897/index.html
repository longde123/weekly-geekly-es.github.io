<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥙 🛀🏾 🖖🏼 Bagaimana kami menjaga stabilitas aplikasi Lamoda ▪️ 💝 🧖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Nama saya Vitaliy Bendik. Saya adalah pemimpin tim untuk pengembangan aplikasi Android di Lamoda. Pada tahun 2018, saya berbicara di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menjaga stabilitas aplikasi Lamoda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/461897/">  Halo semuanya! <br><br>  Nama saya Vitaliy Bendik.  Saya adalah pemimpin tim untuk pengembangan aplikasi Android di Lamoda.  Pada tahun 2018, saya berbicara di Mosdroid Aluminium dengan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> , transkrip yang ingin saya bagikan. <br><br><img src="https://habrastorage.org/webt/0p/_y/mx/0p_ymxjmgcbtrobs8qiw-f2lzp4.jpeg" alt="gambar"><br><br>  Akan tentang bagaimana kita menjaga stabilitas aplikasi seluler.  Ini sangat penting bagi kami, karena pemirsa seluler kami adalah jutaan pengguna.  Selain itu, dalam hal pangsa dalam pesanan pelanggan kami, aplikasi telah lama melampaui situs, versi desktop dan seluler, dan platform iOS telah menjadi pemimpin mutlak, di depan situs desktop. <br><br>  Dalam laporan itu saya akan memberi tahu: <br><br><ol><li>  apa yang kita maksud dengan stabilitas aplikasi; </li><li>  Tentang arsitektur aplikasi seluler kami; </li><li>  tentang proses, praktik, dan alat yang kami gunakan. </li></ol><br><a name="habracut"></a><br>  Jadi, apa <b>aplikasi yang stabil</b> untuk kita?  Ini adalah aplikasi yang tidak macet, tidak hang, dan berfungsi seperti yang diperkirakan.  Ketika saya mengatakan bahwa itu tidak jatuh, maksud saya itu tidak jatuh di setidaknya 95% -99% pengguna. <br><br><h3>  Arsitektur </h3><br><img src="https://habrastorage.org/webt/v1/bc/wg/v1bcwgf_aypm-fp3k2uagn2gjig.jpeg" alt="gambar"><br><br>  Seperti yang mungkin sudah Anda duga, gambar ini menunjukkan arsitektur murni, yang kami coba patuhi.  Sebagai lapisan Presentasi, kami menggunakan MVP dengan beberapa tambahan, yang akan saya bahas di bawah ini. <br><br>  Aplikasi seluler kami disesuaikan untuk ponsel dan tablet.  Oleh karena itu, tata letak sering berbeda, tetapi terdiri dari blok yang sama atau identik.  Dalam hal ini, kami memiliki entitas seperti Widget.  Ini memungkinkan Anda untuk menguraikan aktivitas atau fragmen menjadi blok yang lebih kecil yang dapat digunakan kembali di layar lain.  Ini masuk akal, karena dari sudut pandang kode yang ada di fragmen atau dalam aktivitas, jarang diperlukan untuk membedakan antara konteks yang sedang dijalankan oleh UI.  Dan fragmen kode ini dapat dibuat menjadi beberapa abstraksi dan digunakan kembali.  Pendekatan ini agak mengingatkan pada perpustakaan SoundCloud - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LightCycle</a> . <br><br><img src="https://habrastorage.org/webt/5l/ly/cu/5llycut458pm-rmnszcrztwhifw.jpeg" alt="gambar"><br><img src="https://habrastorage.org/webt/8n/pg/ck/8npgckuh4s2zimenvubugyenpwo.jpeg" alt="gambar"><br><img src="https://habrastorage.org/webt/oc/5z/g-/oc5zg-kmyn-oyghc_2zkxjo7ymy.jpeg" alt="gambar"><br>  <i>Halaman produk.</i>  <i>Contoh Elemen Widget</i> <br><br>  Adapun interaksi presenter dengan model, semuanya standar di sini: presenter berinteraksi dengan seluruh aplikasi melalui interaktor, apakah itu repositori atau manajer. <br><br><img src="https://habrastorage.org/webt/3e/fx/4l/3efx4ldukwcyhe_3bshc9zskg4e.jpeg" alt="gambar"><br><br>  Kebetulan beberapa presenter perlu berkomunikasi satu sama lain, bertukar data.  Untuk ini, kami memiliki koordinator, yang dapat dianggap sebagai interaksi bersama antara beberapa penyaji. <br><br><img src="https://habrastorage.org/webt/sy/mg/1v/symg1v51jbojq78kcg_bwn3lnhw.jpeg" alt="gambar"><br><br><h3>  Tumpukan </h3><br><blockquote>  - Kami menulis semua kode baru di <b>Kotlin</b> , dan kami menggunakan <b>Moxy</b> sebagai implementasi MVP. <br>  - Sebagai DI kita menggunakan <b>Dagger2</b> . <br>  - Untuk bekerja dengan jaringan - <b>Retrofit</b> . <br>  - Untuk bekerja dengan gambar - <b>Glide</b> . <br>  - Kami menambahkan crash ke <b>Relik Baru</b> . <br>  - Kami juga menggunakan <b>Lottie</b> . <br>  - Saat ini, kami secara aktif menggunakan <b>Kotlin Coroutines</b> . <br></blockquote><h3>  Proses pengembangan </h3><br>  Kami mematuhi aliran Git, yaitu, setiap fitur diimplementasikan dalam cabang fitur terpisah, yang, setelah peninjauan kode, diajukan untuk pengujian. <br><br>  Setelah penguji berhasil menyelesaikan pengujian, dan kami memutuskan pada versi bahwa fitur ini akan pergi, itu menggabungkan ke master. <br><br>  Ketika waktu rilis tiba (kami akan dirilis setiap 2 minggu), cabang-r, di mana pengujian asap dilakukan, dialokasikan, kasus uji dijalankan.  Setelah itu, fitur bergabung ke cabang produksi dan diterbitkan di Google Play Beta. <br><br><img src="https://habrastorage.org/webt/bf/yn/if/bfynifrl8boba6todwjxo2n7_qq.jpeg" alt="gambar"><br><br>  Adapun CI / CD, karena kami menggunakan tumpukan Atlassian, Bamboo bertindak sebagai server pembangun. <br><br>  Saat pengembang membuat permintaan tarik, tugas pembangunan dimulai dari Bamboo.  Dia menarik kode dari repositori, menjalankan skrip pada fastlane, yang mengumpulkan aplikasi, menjalankan tes dan melaporkannya ke Slack. <br><br>  Jika penguji memulai perakitan untuk menguji fitur, maka apk juga dimuat di HockeyApp. <br><br>  Untuk mempublikasikan rilis di Google Play Beta, manajer pengiriman meluncurkan tugas terkait di Bamboo, yang menjalankan aliran yang sama, tetapi juga mengunggah versi ke Google Play Beta. <br><br><img src="https://habrastorage.org/webt/fc/iw/sh/fciwshquhla4fxu-8toit3knt1y.jpeg" alt="gambar"><br><br><h3>  Praktek Terapan </h3><br>  <b>Pra-rilis build</b> <br><br>  Awalnya, kami memiliki dua jenis perakitan, seperti banyak: <br><br>  Debug build di mana ProGuard dan SSL Pinning dinonaktifkan. <br>  Rilis rilis yang menyertakan ProGuard dan Pinning SSL. <br>  Prosesnya terlihat seperti ini: pengembang selesai mengerjakan fitur dan memberikannya untuk pengujian.  Penguji mengumpulkan rakitan Debug, menguji kasus uji di atasnya dan memeriksa kebenaran analitik yang dikirim oleh aplikasi.  Jika semuanya baik-baik saja, maka dia mengirimkan tugas ke Siap untuk rilis, dan dia menunggu saat ketika kita mulai mengumpulkan rilis. <br><br>  Ketika tiba saatnya untuk rilis aplikasi, pengembang menggabungkan semua tugas menjadi master, memilih cabang rc dan memberinya QA untuk pengujian asap.  QA mengumpulkan perakitan rilis, mulai menjalankan tes.  Tetapi ada kalanya ada yang tidak beres.  Masalah biasanya terjadi karena ProGuard.  Tentu saja, mereka cepat diperbaiki, tetapi ini dapat menunda rilis atau menunda untuk beberapa waktu. <br><br>  Untuk alasan ini, kami membuat bangunan pra-rilis di mana ProGuard dihidupkan dan Pinning SSL dimatikan.  Ini memungkinkan para penguji untuk memverifikasi kebenaran dari analitik yang dikirimkan (inilah alasan mengapa para penguji pada awalnya tidak membangun pembuatan rilis). <br>  Sekarang, QA sedang membangun bangunan pra-rilis.  Ini memberi mereka kesempatan untuk menguji analitik dan untuk menghadapi masalah yang disebabkan oleh ProGuard sedini mungkin. <br><br>  <b>Spesifikasi terlebih dahulu</b> <br><br>  Ini adalah pendekatan di mana spesifikasinya utama.  Ketika kami mengembangkan fitur baru dan memerlukan backend, spesifikasi dibuat terlebih dahulu, dan kemudian berdasarkan itu, pengembangan fitur dimulai baik dari backend dan dari klien.  Semua perubahan melewati spesifikasi, dan hanya kemudian perubahan dilakukan pada backend dan klien.  Spesifikasi ini juga menghasilkan dokumentasi Swagger tentang metode API. <br><br><img src="https://habrastorage.org/webt/ti/lm/ju/tilmjul8aguyv8tr6mr-9kjhiyo.jpeg" alt="gambar"><br><br>  Awalnya, kami memiliki API yang kliennya bukan hanya aplikasi seluler.  Metode API tidak konsisten satu sama lain, yang seringkali membuat perubahan sulit. <br><br>  Juga sering menjumpai kasus lucu.  Misalnya, ketika metode mengembalikan daftar merek, dalam kasus ketika ada beberapa, itu mengembalikan array, dan jika hanya ada satu merek, itu mengembalikan objek. <br><br><img src="https://habrastorage.org/webt/7f/nz/9h/7fnz9hfpy8vd5ir5_c7xalavk0g.jpeg" alt="gambar"><br><br>  Atau, ketika tidak ada merek, null dikembalikan, atau secara umum 4 karakter null <br>  (bukan JSON).  Dalam hal ini, aplikasinya sulit. <br><br><img src="https://habrastorage.org/webt/n_/2p/q3/n_2pq3xid5geah4rlu5e3nvjnpk.jpeg" alt="gambar"><br><br>  Oleh karena itu, dari waktu ke waktu, kami sampai pada kesimpulan bahwa aplikasi seluler memerlukan API mereka sendiri, yang akan mempertimbangkan spesifikasinya dan mengaitkan aplikasi seluler dengan sekelompok sistem Lamoda internal yang harus berinteraksi dengan Anda. <br><br><img src="https://habrastorage.org/webt/tu/wt/6y/tuwt6ydqol6aifshqfrqc8ehnlg.jpeg" alt="gambar"><br><br>  Pada saat yang sama, kami memutuskan untuk mencoba pendekatan spesifikasi pertama (spesifikasi Swagger).  Ketika seorang pengembang mulai bekerja pada beberapa fitur yang membutuhkan backend, ia membuat permintaan tarik dengan kontrak fitur.  Kemudian semua pihak yang tertarik dari iOS, Android, dan tim backend ditambahkan ke permintaan penarikan ini.  Ketika semua orang puas dengan kontrak metode API baru, permintaan tarik dituangkan ke cabang backend dan pengembang backend mulai mengembangkan fitur.  Pelanggan juga mulai mengembangkan fitur, karena kontraknya sekarang telah diperbaiki dan Anda dapat mengandalkannya dan, jika perlu, membuat moki. <br><br>  <b>Matikan-fitur</b> <br><br>  Perusahaan memiliki pengembangan A / B Tool sendiri, yang memungkinkan Anda untuk mengimplementasikan eksperimen dan fitur-toggle.  Fitur-matikan kami menutup fungsionalitas tidak kritis untuk pengguna, yang, jika perlu, dapat dinonaktifkan.  Misalnya, jika ada kesalahan di dalamnya, atau jika kita perlu mengurangi beban di backend (sebagai opsi, pada "Black Friday"). <br><br>  Fitur-matikan juga memungkinkan kami untuk menguji perpustakaan untuk dapat melihat apakah perpustakaan lain akan memecahkan masalah kita lebih baik dan berperilaku lebih stabil.  Jika tidak, maka kita selalu dapat kembali ke perpustakaan sebelumnya. <br><br>  <b>Pemantauan pengguna nyata</b> <br><br>  Pemantauan Pengguna Nyata memungkinkan Anda untuk mengukur kinerja aplikasi dari perspektif pengguna.  Sebagai contoh, seorang pelanggan mengklik sebuah item dalam katalog.  Berapa lama dia harus menunggu sebelum dia melihat hasil dari tindakannya, yaitu, dia melihat kartu produk dengan foto? <br><img src="https://habrastorage.org/webt/jp/3t/gb/jp3tgbvrijxwblubhxw96urwzy0.jpeg" alt="gambar"><br>  Ini tidak dapat dilakukan secara otomatis, karena titik awal dan titik akhir pengukuran ini harus ditetapkan secara manual.  Hanya pengembang yang mengerti ketika dapat diasumsikan bahwa pengguna siap untuk berinteraksi dengan layar baru.  Dalam proses interaksi ini, kita mungkin tertarik pada hal-hal seperti: <br><br>  1. konsumsi memori; <br>  2. konsumsi CPU; <br>  3. apa yang terjadi pada arus utama; <br>  4. apa yang dimuat dari jaringan; <br>  5. apa yang terjadi di utas lainnya. <br><br>  Ini memberi kita peluang untuk memperbaiki masalah jika muncul, karena menjadi jelas bahwa itu benar-benar menghabiskan sebagian besar waktu dan kita dapat mengoptimalkannya sehingga aplikasi lebih responsif kepada pengguna. <br><br><h3>  Pengembalian utang teknis </h3><br>  Sebelum meluncurkan versi baru, kami memperbaiki kerusakan yang terjadi di versi sebelumnya.  Ini bukan tentang crash kritis, karena ini pasti akan memerlukan perbaikan terbaru, tetapi tentang crash yang tidak terjadi terlalu sering tidak mempengaruhi kinerja bisnis, tetapi tidak menyenangkan bagi pengguna. <br><br>  Setelah rilis versi, kami meluncurkannya berdasarkan persentase, memantau indikator kritis dan menanggapi insiden jika terjadi.  Untuk pengguliran bertahap, kami menggunakan Google Play Console.  Pengguliran dilakukan sebagai berikut: diluncurkan sebesar 5%, kami memantau indikator;  jika semuanya beres, maka bergulir.  Jika sesuatu terjadi, buat perbaikan terbaru dan roll out sudah.  Selanjutnya, kami melakukan rolling 10%, 20% dan 50%. <br><br>  Tempat kritis apa yang kami <b>pantau</b> ? <br><br><ol><li>  Permintaan jaringan, termasuk dari perpustakaan pihak ketiga: kesalahan, waktu respons, memuat. </li><li>  Musim gugur. </li><li>  Menangani pengecualian, yang disebut "pengecualian yang diproses".  Ini adalah pengecualian yang bisa terjadi jika kita tidak membungkusnya dengan try-catch.  Ini memungkinkan aplikasi untuk tidak jatuh jika pengecualian terjadi pada fungsionalitas yang tidak kritis bagi pengguna.  Misalnya, jatuh miskin karena analitik.  Namun, penting bagi produk untuk memahami bahwa fitur meningkatkan atau memperburuk konversi.  Menggunakan pengecualian yang Ditangani memungkinkan kami untuk tetap merespons dan memperbaiki masalah ini. </li></ol><br><h3>  Alat-alatnya </h3><br><ul><li>  Alat A / B </li><li>  RPM BaruRelik </li><li>  Wawasan Baru. </li></ul><br>  <b>Alat A / B</b> adalah mekanisme untuk melakukan eksperimen dan mekanisme untuk variabel bergulir, fitur-toggle yang sama.  Ini adalah pengembangan internal, sehingga terintegrasi dengan baik ke dalam banyak sistem: dalam aplikasi seluler, di situs, di bagian belakang.  Ini memungkinkan Anda untuk menyampaikan konfigurasi Fitur-beralih tidak dalam permintaan terpisah di belakangnya, tetapi di header tanggapan terhadap permintaan yang dilakukan aplikasi. <br><br>  Ini memberi kita kesempatan: <br><br><ul><li>  Luncurkan eksperimen di kantor ketika kami ingin menguji beberapa fitur di dalam kantor kami. </li><li>  Luncurkan percobaan, serta matikan Fitur untuk pengguna tertentu. </li></ul><br>  Sistem ini tidak tergantung pada faktor eksternal.  Jika kami menggunakan alat pihak ketiga, maka di beberapa titik itu bisa diblokir (halo, Roskomnadzor) atau ada yang salah di dalamnya.  Bagi kami, ini akan menjadi sangat penting, karena dalam hal ini kami tidak akan dapat dengan cepat beralih fitur-toggle.  Dan karena ini adalah pengembangan kami sendiri, kami tidak punya masalah seperti itu. <br><br>  <b>NewRelic</b> adalah alat yang memungkinkan Anda memantau banyak indikator berbeda secara real time.  Dari beragam fitur Relik Baru, kami menggunakan, misalnya, instrumentasi kode otomatis.  Hal inilah yang memungkinkan kami untuk memonitor permintaan jaringan tidak hanya ke backend kami, tetapi juga semua yang lain (termasuk dari perpustakaan pihak ketiga).  NewRelic mendukung sekumpulan klien standar untuk bekerja dengan jaringan.  Anda juga dapat mengumpulkan informasi: <br><br>  1. tentang konsumsi memori; <br>  2. tentang konsumsi CPU; <br>  3. tentang operasi yang terkait dengan JSON; <br>  4. tentang operasi yang terkait dengan SQlite. <br><br>  Selain itu, kami menggunakan NewRelic untuk mengumpulkan laporan kerusakan, untuk mengumpulkan pengecualian yang ditangani dan untuk interaksi pengguna - ini persis dengan <b>Pemantauan Pengguna Nyata yang</b> sama.  Kami sudah menerapkannya melalui mekanisme interaksi pengguna NewRelic. <br><br><h3>  Tetapi bagaimana dengan stabilitas? </h3><br>  Kami memiliki indikator seperti tingkat kerusakan.  Sebelumnya, kami meluncurkan perbaikan terbaru ketika indikatornya berada di kisaran 0,3% hingga 0,5%.  Sangat penting jika nilainya menjadi lebih dari 0,5%. Sekarang kami meluncurkan perbaikan terbaru ketika tingkat kerusakan berada di kisaran 0,1% hingga 0,3%.  Nilai kritis lebih dari 0,3%. Dan, jika sebelumnya tingkat kerusakan rata-rata aplikasi kami adalah 0,1%, sekarang adalah 0,05%. <br><br><img src="https://habrastorage.org/webt/3o/dh/wx/3odhwx8ijfu-8ga6vvm-7uinxaq.jpeg" alt="gambar"><br><br>  Sebagai kesimpulan, saya ingin membuat daftar praktik paling penting yang membantu kami menjaga stabilitas aplikasi.  Kami menguji aplikasi sedekat mungkin dengan versi produksi, menutup fungsionalitas kritis dari toggle-toggle, serta memantau dan menanggapi indikator yang penting bagi kami. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461897/">https://habr.com/ru/post/id461897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461881/index.html">Panduan Pencatatan Node.js</a></li>
<li><a href="../id461885/index.html">EDS adalah jenis penipuan lainnya</a></li>
<li><a href="../id461887/index.html">Memasuki Aeronet Episode 2: Dring Homing</a></li>
<li><a href="../id461891/index.html">Bagaimana kami berteman di infrastruktur bank menggunakan ManageIQ</a></li>
<li><a href="../id461895/index.html">Learn While Travel - bagaimana kami melaju pada Hari Analisis Bisnis Eropa pertama</a></li>
<li><a href="../id461899/index.html">Pembuatan Acara, CQRS dan Laravel</a></li>
<li><a href="../id461901/index.html">Tiga tahun autotests: cara meningkatkan kecepatan dan tidak hanya</a></li>
<li><a href="../id461903/index.html">Musuh misterius: peminjaman kabur</a></li>
<li><a href="../id461905/index.html">Tic Tac Toe, bagian 7: pytest dan Travis CI</a></li>
<li><a href="../id461907/index.html">Analitik produk di studio siklus penuh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>