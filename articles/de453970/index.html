<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÇüèº üöÇ üôä Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 2 üå°Ô∏è üï∫üèæ üôèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte von Forschung und Entwicklung in 3 Teilen. Teil 2 - Entwicklung. 
 Es gibt viele Buchen - noch mehr Vorteile. 

 Im ersten Teil des Art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  Die Geschichte von Forschung und Entwicklung in 3 Teilen.  Teil 2 - Entwicklung. <br>  Es gibt viele Buchen - noch mehr Vorteile. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil des</a> Artikels haben wir einige Tools zum Organisieren von R√ºckw√§rtstunneln kennengelernt, ihre Vor- und Nachteile untersucht, den Mechanismus des Yamux-Multiplexers untersucht und die grundlegenden Anforderungen f√ºr das neu erstellte Powershell-Modul beschrieben.  Es ist Zeit, mit der Entwicklung des Client-Powershell-Moduls f√ºr die vorgefertigte Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSocksTun-</a> Reverse-Tunnels zu beginnen. <br><br>  Zun√§chst m√ºssen wir verstehen, in welchem ‚Äã‚ÄãModus unser Modul funktioniert.  Offensichtlich m√ºssen wir f√ºr die prim√§re Daten√ºbertragung den Windows-Socket-Mechanismus und die .Net-Funktionen zum Streaming von Lese- und Schreibzugriff auf Sockets verwenden.  Aber andererseits, weil  Da unser Modul mehrere Yamux-Streams gleichzeitig bedienen muss, sollten alle E / A-Operationen die Ausf√ºhrung unseres Programms nicht vollst√§ndig blockieren.  Dies legt die Schlussfolgerung nahe, dass unser Modul Software-Multithreading verwenden und Lese- / Schreibvorg√§nge mit einem Yamux-Server sowie Lese- / Schreibvorg√§nge auf Zielservern in verschiedenen Programmstr√∂men ausf√ºhren sollte.  Nat√ºrlich ist es notwendig, einen Mechanismus f√ºr die Interaktion zwischen unseren parallelen Str√∂mungen bereitzustellen.  Gl√ºcklicherweise bietet Powershell zahlreiche M√∂glichkeiten zum Starten und Verwalten von Programmabl√§ufen. <br><a name="habracut"></a><br><h3>  Allgemeiner Arbeitsalgorithmus </h3><br>  Daher sollte der allgemeine Algorithmus unseres Kunden ungef√§hr so ‚Äã‚Äãaussehen: <br><br><ul><li>  eine SSL-Verbindung zum Server herstellen; </li><li>  Melden Sie sich mit einem Passwort an, damit der Server uns von einem Sicherheitsbeauftragten unterscheiden kann. </li><li>  Warten Sie, bis das Yamux-Paket einen neuen Stream installiert hat, und antworten Sie regelm√§√üig auf Server-Keepalive-Anforderungen. </li><li>  Starten Sie einen neuen SocksScript-Programm-Stream (nicht zu verwechseln mit einem Stream), sobald das Yamux-Paket eintrifft, um einen neuen Stream zu installieren.  Implementieren Sie in socksScript die Arbeit des socks5-Servers. </li><li>  Bei Eintreffen eines Pakets mit Daten von yamux - anhand eines 12-Byte-Headers verstehen, f√ºr welchen der Streams die Daten bestimmt sind, sowie deren Gr√∂√üe, die Daten vom yamux-Server lesen und die empfangenen Daten mit der entsprechenden Stream-Nummer an den Stream √ºbertragen; </li><li>  √úberwachen Sie regelm√§√üig die Verf√ºgbarkeit von Daten, die f√ºr den Yamux-Server bestimmt sind, in jedem der laufenden Socken-Skripte.  Wenn solche Daten vorhanden sind, f√ºgen Sie ihnen den entsprechenden 12-Byte-Header hinzu und senden Sie ihn an den yamux-Server. </li><li>  √úbertragen Sie bei Ankunft eines Yamux-Pakets zum Schlie√üen des Streams das Signal an den entsprechenden Stream, um den Stream zu beenden und die Verbindung zu trennen, und vervollst√§ndigen Sie anschlie√üend den Stream selbst. </li></ul><br>  In unserem Client m√ºssen also mindestens 3 Programmabl√§ufe implementiert werden: <br><br><ol><li>  Der Hauptteil, der die Verbindung herstellt, sich beim Yamux-Server anmeldet, Daten von ihm empf√§ngt, Yamux-Header verarbeitet und Rohdaten an andere Programmstr√∂me sendet. </li><li>  Streams mit Socken-Servern.  Es kann mehrere geben - eine f√ºr jeden Stream.  Sie implementieren die Funktionalit√§t von socks5.  Diese Flows interagieren mit Zielpunkten im internen Netzwerk. </li><li>  R√ºckfluss.  Es empf√§ngt Daten von Socken-Streams, f√ºgt ihnen Yamux-Header hinzu und sendet sie an den Yamux-Server. </li></ol><br>  Und nat√ºrlich m√ºssen wir f√ºr die Interaktion zwischen all diesen Fl√ºssen sorgen. <br><br>  Wir m√ºssen nicht nur eine solche Interaktion bereitstellen, sondern auch die Bequemlichkeit des Streamings von Eingabe-Ausgabe (√§hnlich wie bei Sockets) erhalten.  Der am besten geeignete Mechanismus w√§re die Verwendung von Software-Pipes.  In Windows werden Pipes registriert, wenn jede Pipe ihren eigenen Namen hat, und anonym - jede Pipe wird von ihrem Handler identifiziert.  Aus Gr√ºnden der Geheimhaltung werden wir nat√ºrlich anonyme Pipes verwenden.  (Schlie√ülich m√∂chten wir nicht, dass unser Modul mithilfe registrierter Pipes im System berechnet wird - ja?)  Somit erfolgt die Interaktion zwischen den Haupt- / R√ºckflussstr√∂men und den Sockenfl√ºssen √ºber anonyme Pipes, die asynchrone Stream-Input-Output-Operationen unterst√ºtzen.  Zwischen dem Haupt- und dem R√ºckfluss erfolgt die Kommunikation √ºber den Mechanismus f√ºr gemeinsam genutzte Objekte (gemeinsam genutzte synchronisierte Variablen) (mehr dar√ºber, was diese Variablen sind und wie man mit ihnen lebt, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br>  Informationen zum Ausf√ºhren von Sockenstr√∂men sollten in der entsprechenden Datenstruktur gespeichert werden.  Wenn wir einen Socken-Thread in dieser Struktur erstellen, m√ºssen wir schreiben: <br><br><ul><li>  Yamux-Sitzungsnummer: $ ymxstream; </li><li>  4 Variablen f√ºr die Arbeit mit Pipes (Kan√§len): $ cipipe, $ copipe, $ sipipe, $ sopipe.  Da anonyme Kan√§le entweder in IN oder OUT funktionieren, ben√∂tigen wir f√ºr jeden Socken-Stream zwei anonyme Kan√§le, von denen jeder zwei Enden haben muss (Pipestream) (Server und Client). </li><li>  Das Ergebnis des Aufrufs des Streams ist $ AsyncJobResult. </li><li>  Stream-Handler - $ Psobj.  Dadurch werden wir den Stream schlie√üen und Ressourcen freigeben. </li><li>  das Ergebnis des asynchronen Lesens aus der anonymen Pipe durch den Reverse Stream ($ readjob).  Diese Variable wird im umgekehrten YamuxScript-Stream zum asynchronen Lesen aus der entsprechenden Pipe verwendet. </li><li>  Puffer zum Lesen von Daten f√ºr jeden Sockenstrom; </li></ul><br><h3>  Hauptstrom </h3><br>  Aus Sicht der Datenverarbeitung ist die Arbeit unseres Programms also wie folgt aufgebaut: <br><br><ul><li>  Die Serverseite (rsockstun - auf Golang implementiert) l√∂st den SSL-Server aus und wartet auf Verbindungen vom Client. </li><li>  Beim Empfang einer Verbindung vom Client √ºberpr√ºft der Server das Kennwort. Wenn es korrekt ist, stellt er eine Yamux-Verbindung her, erh√∂ht den Socken-Port und wartet auf Verbindungen von Socken-Clients (unsere Proxy-Ketten, Browser usw.), wobei er regelm√§√üig Keepalive-Pakete austauscht mit unserem Kunden.  Wenn das Passwort falsch ist, wird eine Weiterleitung zu der Seite ausgef√ºhrt, die wir bei der Installation des Servers angegeben haben (dies ist eine "legale" Seite f√ºr den aufmerksamen Administrator der Informationssicherheit). </li><li>  Nach Erhalt einer Verbindung von einem Socken-Client sendet der Server ein Yamux-Paket an unseren Client, um einen neuen Stream (YMX SYN) einzurichten. </li></ul><br>  <b>Abrufen und Analysieren eines Yamux-Headers</b> <br><br>  Unser Modul stellt zun√§chst eine SSL-Verbindung zum Server her und meldet sich mit einem Kennwort an: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Dann wartet das Skript auf einen 12-Byte-Yamux-Header und analysiert ihn. <br>  Es gibt eine kleine Nuance ... Wie die Praxis zeigt, lesen Sie einfach 12 Bytes aus dem Socket: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  nicht genug, da der Lesevorgang nach dem Eintreffen nur eines Teils der erforderlichen Bytes abgeschlossen werden kann.  Daher m√ºssen wir auf alle 12 Bytes in der Schleife warten: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Nachdem die Schleife abgeschlossen ist, sollten wir den in der Variablen $ ymxbuffer enthaltenen 12-Byte-Header auf seinen Typ analysieren und Flags gem√§√ü der Spezifikation von Yamux setzen. <br><br>  Es gibt verschiedene Arten von Yamux-Headern: <br><br><ul><li>  ymx syn - Installiere einen neuen Stream; </li><li>  ymx fin - stream vervollst√§ndigung; </li><li>  ymx-Daten - stellen Informationen zu den Daten dar (f√ºr welche Gr√∂√üe und f√ºr welchen Stream sie bestimmt sind); </li><li>  ymx ping - Keepalive-Nachricht; </li><li>  ymx win update - Best√§tigung der √úbertragung eines Teils der Daten; </li></ul><br>  Alles, was nicht zu den aufgef√ºhrten Arten von Yamux-Headern passt, wird als Ausnahmesituation angesehen.  Es gibt 10 solcher Ausnahmen, und wir glauben, dass hier etwas nicht stimmt, und wir schlie√üen die Arbeit unseres Moduls ab.  <s>(sowie alle unsere Dateien l√∂schen, die Festplatte l√∂schen, den Nachnamen √§ndern, einen neuen Pass erstellen, das Land verlassen usw. gem√§√ü der Liste ...)</s> <br><br>  <b>Erstellen eines neuen Sockenfadens</b> <br><br>  Nachdem unser Client ein Yamux-Paket zum Einrichten eines neuen Streams erhalten hat, erstellt er zwei anonyme Server-Pipes ($ sipipe, $ sopipe), f√ºr In / Out erstellt er Client-Pipes ($ cipipe, $ copipe) basierend auf diesen: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  Erstellt einen Runspace f√ºr den Socken-Stream, legt gemeinsam genutzte Variablen f√ºr die Interaktion mit diesem Stream fest (StopFlag) und f√ºhrt den Skriptblock SocksScript aus, der die Funktionalit√§t des Socken-Servers in einem separaten Stream implementiert: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  Die erstellten Variablen werden in eine spezielle ArrayList-Struktur geschrieben - ein Analogon zu Dictionary in Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  Das Hinzuf√ºgen erfolgt √ºber die integrierte Add-Methode: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Yamux Datenverarbeitung</b> <br><br>  Nach dem Empfang von Daten, die f√ºr einen Socken-Stream bestimmt sind, vom Yamux-Server m√ºssen wir die Nummer des Yamux-Streams (die Anzahl der Socken-Streams, f√ºr die diese Daten bestimmt sind) und die Anzahl der Datenbytes aus dem 12-Byte-Yamux-Header bestimmen: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Dann erhalten wir aus dem ArrayList-Stream unter Verwendung des Felds ymxId die Handler der Server-Out-Pipe, die diesem Socken-Stream entsprechen: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Danach lesen wir die Daten aus dem Socket und denken daran, dass wir eine bestimmte Anzahl von Bytes durch die Schleife lesen m√ºssen: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  und schreiben Sie die empfangenen Daten in die entsprechende Pipe: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Yamux FIN-Verarbeitung - Endstrom</b> <br><br>  Wenn wir vom Yamix-Server ein Paket empfangen, das das Schlie√üen eines Streams signalisiert, erhalten wir auch zuerst die Nummer des Yamux-Streams aus dem 12-Byte-Header: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  Dann signalisieren wir √ºber eine gemeinsam genutzte Variable (oder besser gesagt ein Array von Flags, wobei der Index die Yamux-Stream-Nummer ist), dass der Socken-Thread abgeschlossen ist: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  Nachdem Sie das Flag gesetzt haben, m√ºssen Sie vor dem Beenden des Socken-Streams eine gewisse Zeit warten, bis der Socken-Stream dieses Flag verarbeitet.  Daf√ºr reichen 200 ms: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  Schlie√üen Sie dann alle Pipes, die sich auf diesen Stream beziehen, schlie√üen Sie den entsprechenden Runspace und beenden Sie das Powershell-Objekt, um Ressourcen freizugeben: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Nach dem Schlie√üen des Socken-Streams m√ºssen wir das entsprechende Element aus den ArrayList-Streams entfernen: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  Und am Ende m√ºssen wir den .Net-Garbage Collector zwingen, die vom Thread verwendeten Ressourcen freizugeben.  Andernfalls verbraucht unser Skript etwa 100 bis 200 MB Speicher, was die Aufmerksamkeit eines erfahrenen und √§tzenden Benutzers auf sich ziehen kann. Wir ben√∂tigen dies jedoch nicht: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Yamux Script - R√ºckfluss </h3><br>  Wie oben erw√§hnt, werden von Socken-Streams empfangene Daten von einem separaten YamuxScript-Stream verarbeitet, der von Anfang an beginnt (nach einer erfolgreichen Verbindung zum Server).  Seine Aufgabe besteht darin, die Ausgabepipes von Socken-Streams in ArrayList $ -Streams regelm√§√üig abzufragen: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  und wenn sie Daten enthalten, senden Sie sie an den Yamux-Server, nachdem Sie zuvor den entsprechenden 12-Byte-Yamux-Header bereitgestellt haben, der die Nummer der Yamux-Sitzung und die Anzahl der Datenbytes enth√§lt: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  YamuxScript √ºberwacht auch das im freigegebenen $ StopFlag-Array gesetzte Flag f√ºr jeden der ausgef√ºhrten socksScript-Threads.  Dieses Flag kann auf 2 gesetzt werden, wenn der Remote-Server, auf dem socksScript ausgef√ºhrt wird, die Verbindung trennt.  In dieser Situation m√ºssen die Informationen an den Socken-Client gemeldet werden.  Die Kette ist wie folgt: yamuxScript muss den yamux-Server √ºber die Trennung informieren, damit dies wiederum dem Socken-Client signalisiert. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Yamux Fenster Update </h3><br>  Dar√ºber hinaus sollte yamuxScript die Anzahl der vom yamux-Server empfangenen Bytes √ºberwachen und regelm√§√üig eine YMX-WinUpdate-Nachricht senden.  Dieser Mechanismus in Yamux ist f√ºr die √úberwachung und √Ñnderung der sogenannten Fenstergr√∂√üe (√§hnlich dem TCP-Protokoll) verantwortlich - der Anzahl der Datenbytes, die ohne Best√§tigung gesendet werden k√∂nnen.  Standardm√§√üig betr√§gt die Fenstergr√∂√üe 256 KB.  Dies bedeutet, dass wir beim Senden oder Empfangen von Dateien oder Daten, die gr√∂√üer als diese Gr√∂√üe sind, das windpw-Aktualisierungspaket an den yamux-Server senden m√ºssen.  Um die Menge der vom Yamux-Server empfangenen Daten zu steuern, wurde ein spezielles gemeinsam genutztes Array $ RcvBytes eingef√ºhrt, in das der Hauptstrom durch Inkrementieren des aktuellen Werts die Anzahl der vom Server empfangenen Bytes f√ºr jeden Strom aufzeichnet.  Wenn der festgelegte Schwellenwert √ºberschritten wird, sollte yamuxScript ein Paket an den WinUpdate-Server senden und den Z√§hler zur√ºcksetzen: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  SocksScript-Streams </h3><br>  Gehen wir jetzt direkt zu socksScript. <br>  Denken Sie daran, dass socksScript asynchron aufgerufen wird: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  und zum Zeitpunkt des Aufrufs sind die folgenden Daten in der $ state-Variablen vorhanden, die an den Stream √ºbertragen wird: <br><br><ul><li>  $ state.streamId - yamux Sitzungsnummer; </li><li>  $ state.inputStream - Pipe lesen; </li><li>  $ state.oututStream - Pipe schreiben; </li></ul><br>  Die Daten in den Pipes kommen in Rohform ohne Yamux-Header, d. H.  in der Form, in der sie vom Socken-Client kamen. <br><br>  In socksScript m√ºssen wir zun√§chst die Version der Socken bestimmen und sicherstellen, dass es 5 ist: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Nun, dann machen wir genau das, was im Invoke-SocksProxy-Skript implementiert ist.  Der einzige Unterschied wird sein, dass anstelle von Anrufen <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  Es ist notwendig, die TCP-Verbindung und das entsprechende Beendigungsflag im $ StopFlag-Array in einem zyklischen Modus zu √ºberwachen, da wir sonst die Situation des Verbindungsende von der Seite des Socken-Clients und des ymux-Servers nicht erkennen k√∂nnen: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  Falls die Verbindung auf der TCP-Seite des Servers endet, zu dem wir eine Verbindung herstellen, setzen wir dieses Flag auf 2, wodurch yamuxscript dies erkennt und das entsprechende ymx-FIN-Paket an den yamux-Server sendet: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Wir m√ºssen dieses Flag auch setzen, wenn socksScript keine Verbindung zum Zielserver herstellen kann: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Fazit zum zweiten Teil </h3><br>  Im Verlauf unserer Codierungsforschung konnten wir einen Powershell-Client f√ºr unseren RsocksTun-Server mit den folgenden Funktionen erstellen: <br><br><ul><li>  SSL-Verbindungen </li><li>  Autorisierung auf dem Server; </li><li>  Arbeit mit Yamux-Server mit Unterst√ºtzung f√ºr Keepalive-Pings; </li><li>  Multithread-Betriebsart; </li><li>  Unterst√ºtzung f√ºr die √úbertragung gro√üer Dateien; </li></ul><br>  Au√üerhalb des Artikels wurde die Funktionalit√§t implementiert, eine Verbindung √ºber einen Proxyserver herzustellen und zu autorisieren sowie unser Skript in eine Inline-Version umzuwandeln, die √ºber die Befehlszeile ausgef√ºhrt werden kann.  Es wird im dritten Teil sein. <br><br>  Das ist alles f√ºr heute.  Wie sie sagen - abonnieren Sie gerne Kommentare (insbesondere in Bezug auf Ihre Gedanken zur Verbesserung des Codes und zum Hinzuf√ºgen von Funktionen). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453970/">https://habr.com/ru/post/de453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453958/index.html">Monorepositories: bitte</a></li>
<li><a href="../de453960/index.html">Globales DevOps Bootcamp 2019 in Moskau</a></li>
<li><a href="../de453962/index.html">RxSwift und Coroutines bei Kotlin - optionale mobile Entwicklung von AGIMA und GeekBrains</a></li>
<li><a href="../de453964/index.html">OOP in der R-Sprache (Teil 1): S3-Klassen</a></li>
<li><a href="../de453968/index.html">Verlernen Sie die √úberpr√ºfungspraktiken f√ºr toxischen Code</a></li>
<li><a href="../de453972/index.html">Arch√§ologen erstellen mithilfe von 3D-Druck und -Scanning einen zweitausend Jahre alten Stift nach</a></li>
<li><a href="../de453974/index.html">Wettbewerb von ML-Systemen um Sprachmaterial. Wie haben wir gelernt, die L√ºcken zu f√ºllen?</a></li>
<li><a href="../de453976/index.html">Wirtschaftliches Bildungsprogramm f√ºr IT-Spezialisten</a></li>
<li><a href="../de453978/index.html">Der 3D-3D-Drucker druckt ein Geb√§ude in 14 Stunden</a></li>
<li><a href="../de453980/index.html">Drucken von Etiketten und Preisschildern f√ºr den .net Online-Shop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>