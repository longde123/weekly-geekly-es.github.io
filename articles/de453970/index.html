<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💂🏼 🚂 🙊 Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 2 🌡️ 🕺🏾 🙏🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Geschichte von Forschung und Entwicklung in 3 Teilen. Teil 2 - Entwicklung. 
 Es gibt viele Buchen - noch mehr Vorteile. 

 Im ersten Teil des Art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  Die Geschichte von Forschung und Entwicklung in 3 Teilen.  Teil 2 - Entwicklung. <br>  Es gibt viele Buchen - noch mehr Vorteile. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil des</a> Artikels haben wir einige Tools zum Organisieren von Rückwärtstunneln kennengelernt, ihre Vor- und Nachteile untersucht, den Mechanismus des Yamux-Multiplexers untersucht und die grundlegenden Anforderungen für das neu erstellte Powershell-Modul beschrieben.  Es ist Zeit, mit der Entwicklung des Client-Powershell-Moduls für die vorgefertigte Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSocksTun-</a> Reverse-Tunnels zu beginnen. <br><br>  Zunächst müssen wir verstehen, in welchem ​​Modus unser Modul funktioniert.  Offensichtlich müssen wir für die primäre Datenübertragung den Windows-Socket-Mechanismus und die .Net-Funktionen zum Streaming von Lese- und Schreibzugriff auf Sockets verwenden.  Aber andererseits, weil  Da unser Modul mehrere Yamux-Streams gleichzeitig bedienen muss, sollten alle E / A-Operationen die Ausführung unseres Programms nicht vollständig blockieren.  Dies legt die Schlussfolgerung nahe, dass unser Modul Software-Multithreading verwenden und Lese- / Schreibvorgänge mit einem Yamux-Server sowie Lese- / Schreibvorgänge auf Zielservern in verschiedenen Programmströmen ausführen sollte.  Natürlich ist es notwendig, einen Mechanismus für die Interaktion zwischen unseren parallelen Strömungen bereitzustellen.  Glücklicherweise bietet Powershell zahlreiche Möglichkeiten zum Starten und Verwalten von Programmabläufen. <br><a name="habracut"></a><br><h3>  Allgemeiner Arbeitsalgorithmus </h3><br>  Daher sollte der allgemeine Algorithmus unseres Kunden ungefähr so ​​aussehen: <br><br><ul><li>  eine SSL-Verbindung zum Server herstellen; </li><li>  Melden Sie sich mit einem Passwort an, damit der Server uns von einem Sicherheitsbeauftragten unterscheiden kann. </li><li>  Warten Sie, bis das Yamux-Paket einen neuen Stream installiert hat, und antworten Sie regelmäßig auf Server-Keepalive-Anforderungen. </li><li>  Starten Sie einen neuen SocksScript-Programm-Stream (nicht zu verwechseln mit einem Stream), sobald das Yamux-Paket eintrifft, um einen neuen Stream zu installieren.  Implementieren Sie in socksScript die Arbeit des socks5-Servers. </li><li>  Bei Eintreffen eines Pakets mit Daten von yamux - anhand eines 12-Byte-Headers verstehen, für welchen der Streams die Daten bestimmt sind, sowie deren Größe, die Daten vom yamux-Server lesen und die empfangenen Daten mit der entsprechenden Stream-Nummer an den Stream übertragen; </li><li>  Überwachen Sie regelmäßig die Verfügbarkeit von Daten, die für den Yamux-Server bestimmt sind, in jedem der laufenden Socken-Skripte.  Wenn solche Daten vorhanden sind, fügen Sie ihnen den entsprechenden 12-Byte-Header hinzu und senden Sie ihn an den yamux-Server. </li><li>  Übertragen Sie bei Ankunft eines Yamux-Pakets zum Schließen des Streams das Signal an den entsprechenden Stream, um den Stream zu beenden und die Verbindung zu trennen, und vervollständigen Sie anschließend den Stream selbst. </li></ul><br>  In unserem Client müssen also mindestens 3 Programmabläufe implementiert werden: <br><br><ol><li>  Der Hauptteil, der die Verbindung herstellt, sich beim Yamux-Server anmeldet, Daten von ihm empfängt, Yamux-Header verarbeitet und Rohdaten an andere Programmströme sendet. </li><li>  Streams mit Socken-Servern.  Es kann mehrere geben - eine für jeden Stream.  Sie implementieren die Funktionalität von socks5.  Diese Flows interagieren mit Zielpunkten im internen Netzwerk. </li><li>  Rückfluss.  Es empfängt Daten von Socken-Streams, fügt ihnen Yamux-Header hinzu und sendet sie an den Yamux-Server. </li></ol><br>  Und natürlich müssen wir für die Interaktion zwischen all diesen Flüssen sorgen. <br><br>  Wir müssen nicht nur eine solche Interaktion bereitstellen, sondern auch die Bequemlichkeit des Streamings von Eingabe-Ausgabe (ähnlich wie bei Sockets) erhalten.  Der am besten geeignete Mechanismus wäre die Verwendung von Software-Pipes.  In Windows werden Pipes registriert, wenn jede Pipe ihren eigenen Namen hat, und anonym - jede Pipe wird von ihrem Handler identifiziert.  Aus Gründen der Geheimhaltung werden wir natürlich anonyme Pipes verwenden.  (Schließlich möchten wir nicht, dass unser Modul mithilfe registrierter Pipes im System berechnet wird - ja?)  Somit erfolgt die Interaktion zwischen den Haupt- / Rückflussströmen und den Sockenflüssen über anonyme Pipes, die asynchrone Stream-Input-Output-Operationen unterstützen.  Zwischen dem Haupt- und dem Rückfluss erfolgt die Kommunikation über den Mechanismus für gemeinsam genutzte Objekte (gemeinsam genutzte synchronisierte Variablen) (mehr darüber, was diese Variablen sind und wie man mit ihnen lebt, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br>  Informationen zum Ausführen von Sockenströmen sollten in der entsprechenden Datenstruktur gespeichert werden.  Wenn wir einen Socken-Thread in dieser Struktur erstellen, müssen wir schreiben: <br><br><ul><li>  Yamux-Sitzungsnummer: $ ymxstream; </li><li>  4 Variablen für die Arbeit mit Pipes (Kanälen): $ cipipe, $ copipe, $ sipipe, $ sopipe.  Da anonyme Kanäle entweder in IN oder OUT funktionieren, benötigen wir für jeden Socken-Stream zwei anonyme Kanäle, von denen jeder zwei Enden haben muss (Pipestream) (Server und Client). </li><li>  Das Ergebnis des Aufrufs des Streams ist $ AsyncJobResult. </li><li>  Stream-Handler - $ Psobj.  Dadurch werden wir den Stream schließen und Ressourcen freigeben. </li><li>  das Ergebnis des asynchronen Lesens aus der anonymen Pipe durch den Reverse Stream ($ readjob).  Diese Variable wird im umgekehrten YamuxScript-Stream zum asynchronen Lesen aus der entsprechenden Pipe verwendet. </li><li>  Puffer zum Lesen von Daten für jeden Sockenstrom; </li></ul><br><h3>  Hauptstrom </h3><br>  Aus Sicht der Datenverarbeitung ist die Arbeit unseres Programms also wie folgt aufgebaut: <br><br><ul><li>  Die Serverseite (rsockstun - auf Golang implementiert) löst den SSL-Server aus und wartet auf Verbindungen vom Client. </li><li>  Beim Empfang einer Verbindung vom Client überprüft der Server das Kennwort. Wenn es korrekt ist, stellt er eine Yamux-Verbindung her, erhöht den Socken-Port und wartet auf Verbindungen von Socken-Clients (unsere Proxy-Ketten, Browser usw.), wobei er regelmäßig Keepalive-Pakete austauscht mit unserem Kunden.  Wenn das Passwort falsch ist, wird eine Weiterleitung zu der Seite ausgeführt, die wir bei der Installation des Servers angegeben haben (dies ist eine "legale" Seite für den aufmerksamen Administrator der Informationssicherheit). </li><li>  Nach Erhalt einer Verbindung von einem Socken-Client sendet der Server ein Yamux-Paket an unseren Client, um einen neuen Stream (YMX SYN) einzurichten. </li></ul><br>  <b>Abrufen und Analysieren eines Yamux-Headers</b> <br><br>  Unser Modul stellt zunächst eine SSL-Verbindung zum Server her und meldet sich mit einem Kennwort an: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Dann wartet das Skript auf einen 12-Byte-Yamux-Header und analysiert ihn. <br>  Es gibt eine kleine Nuance ... Wie die Praxis zeigt, lesen Sie einfach 12 Bytes aus dem Socket: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  nicht genug, da der Lesevorgang nach dem Eintreffen nur eines Teils der erforderlichen Bytes abgeschlossen werden kann.  Daher müssen wir auf alle 12 Bytes in der Schleife warten: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Nachdem die Schleife abgeschlossen ist, sollten wir den in der Variablen $ ymxbuffer enthaltenen 12-Byte-Header auf seinen Typ analysieren und Flags gemäß der Spezifikation von Yamux setzen. <br><br>  Es gibt verschiedene Arten von Yamux-Headern: <br><br><ul><li>  ymx syn - Installiere einen neuen Stream; </li><li>  ymx fin - stream vervollständigung; </li><li>  ymx-Daten - stellen Informationen zu den Daten dar (für welche Größe und für welchen Stream sie bestimmt sind); </li><li>  ymx ping - Keepalive-Nachricht; </li><li>  ymx win update - Bestätigung der Übertragung eines Teils der Daten; </li></ul><br>  Alles, was nicht zu den aufgeführten Arten von Yamux-Headern passt, wird als Ausnahmesituation angesehen.  Es gibt 10 solcher Ausnahmen, und wir glauben, dass hier etwas nicht stimmt, und wir schließen die Arbeit unseres Moduls ab.  <s>(sowie alle unsere Dateien löschen, die Festplatte löschen, den Nachnamen ändern, einen neuen Pass erstellen, das Land verlassen usw. gemäß der Liste ...)</s> <br><br>  <b>Erstellen eines neuen Sockenfadens</b> <br><br>  Nachdem unser Client ein Yamux-Paket zum Einrichten eines neuen Streams erhalten hat, erstellt er zwei anonyme Server-Pipes ($ sipipe, $ sopipe), für In / Out erstellt er Client-Pipes ($ cipipe, $ copipe) basierend auf diesen: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  Erstellt einen Runspace für den Socken-Stream, legt gemeinsam genutzte Variablen für die Interaktion mit diesem Stream fest (StopFlag) und führt den Skriptblock SocksScript aus, der die Funktionalität des Socken-Servers in einem separaten Stream implementiert: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  Die erstellten Variablen werden in eine spezielle ArrayList-Struktur geschrieben - ein Analogon zu Dictionary in Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  Das Hinzufügen erfolgt über die integrierte Add-Methode: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Yamux Datenverarbeitung</b> <br><br>  Nach dem Empfang von Daten, die für einen Socken-Stream bestimmt sind, vom Yamux-Server müssen wir die Nummer des Yamux-Streams (die Anzahl der Socken-Streams, für die diese Daten bestimmt sind) und die Anzahl der Datenbytes aus dem 12-Byte-Yamux-Header bestimmen: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Dann erhalten wir aus dem ArrayList-Stream unter Verwendung des Felds ymxId die Handler der Server-Out-Pipe, die diesem Socken-Stream entsprechen: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Danach lesen wir die Daten aus dem Socket und denken daran, dass wir eine bestimmte Anzahl von Bytes durch die Schleife lesen müssen: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  und schreiben Sie die empfangenen Daten in die entsprechende Pipe: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Yamux FIN-Verarbeitung - Endstrom</b> <br><br>  Wenn wir vom Yamix-Server ein Paket empfangen, das das Schließen eines Streams signalisiert, erhalten wir auch zuerst die Nummer des Yamux-Streams aus dem 12-Byte-Header: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  Dann signalisieren wir über eine gemeinsam genutzte Variable (oder besser gesagt ein Array von Flags, wobei der Index die Yamux-Stream-Nummer ist), dass der Socken-Thread abgeschlossen ist: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  Nachdem Sie das Flag gesetzt haben, müssen Sie vor dem Beenden des Socken-Streams eine gewisse Zeit warten, bis der Socken-Stream dieses Flag verarbeitet.  Dafür reichen 200 ms: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  Schließen Sie dann alle Pipes, die sich auf diesen Stream beziehen, schließen Sie den entsprechenden Runspace und beenden Sie das Powershell-Objekt, um Ressourcen freizugeben: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Nach dem Schließen des Socken-Streams müssen wir das entsprechende Element aus den ArrayList-Streams entfernen: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  Und am Ende müssen wir den .Net-Garbage Collector zwingen, die vom Thread verwendeten Ressourcen freizugeben.  Andernfalls verbraucht unser Skript etwa 100 bis 200 MB Speicher, was die Aufmerksamkeit eines erfahrenen und ätzenden Benutzers auf sich ziehen kann. Wir benötigen dies jedoch nicht: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Yamux Script - Rückfluss </h3><br>  Wie oben erwähnt, werden von Socken-Streams empfangene Daten von einem separaten YamuxScript-Stream verarbeitet, der von Anfang an beginnt (nach einer erfolgreichen Verbindung zum Server).  Seine Aufgabe besteht darin, die Ausgabepipes von Socken-Streams in ArrayList $ -Streams regelmäßig abzufragen: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  und wenn sie Daten enthalten, senden Sie sie an den Yamux-Server, nachdem Sie zuvor den entsprechenden 12-Byte-Yamux-Header bereitgestellt haben, der die Nummer der Yamux-Sitzung und die Anzahl der Datenbytes enthält: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  YamuxScript überwacht auch das im freigegebenen $ StopFlag-Array gesetzte Flag für jeden der ausgeführten socksScript-Threads.  Dieses Flag kann auf 2 gesetzt werden, wenn der Remote-Server, auf dem socksScript ausgeführt wird, die Verbindung trennt.  In dieser Situation müssen die Informationen an den Socken-Client gemeldet werden.  Die Kette ist wie folgt: yamuxScript muss den yamux-Server über die Trennung informieren, damit dies wiederum dem Socken-Client signalisiert. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Yamux Fenster Update </h3><br>  Darüber hinaus sollte yamuxScript die Anzahl der vom yamux-Server empfangenen Bytes überwachen und regelmäßig eine YMX-WinUpdate-Nachricht senden.  Dieser Mechanismus in Yamux ist für die Überwachung und Änderung der sogenannten Fenstergröße (ähnlich dem TCP-Protokoll) verantwortlich - der Anzahl der Datenbytes, die ohne Bestätigung gesendet werden können.  Standardmäßig beträgt die Fenstergröße 256 KB.  Dies bedeutet, dass wir beim Senden oder Empfangen von Dateien oder Daten, die größer als diese Größe sind, das windpw-Aktualisierungspaket an den yamux-Server senden müssen.  Um die Menge der vom Yamux-Server empfangenen Daten zu steuern, wurde ein spezielles gemeinsam genutztes Array $ RcvBytes eingeführt, in das der Hauptstrom durch Inkrementieren des aktuellen Werts die Anzahl der vom Server empfangenen Bytes für jeden Strom aufzeichnet.  Wenn der festgelegte Schwellenwert überschritten wird, sollte yamuxScript ein Paket an den WinUpdate-Server senden und den Zähler zurücksetzen: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  SocksScript-Streams </h3><br>  Gehen wir jetzt direkt zu socksScript. <br>  Denken Sie daran, dass socksScript asynchron aufgerufen wird: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  und zum Zeitpunkt des Aufrufs sind die folgenden Daten in der $ state-Variablen vorhanden, die an den Stream übertragen wird: <br><br><ul><li>  $ state.streamId - yamux Sitzungsnummer; </li><li>  $ state.inputStream - Pipe lesen; </li><li>  $ state.oututStream - Pipe schreiben; </li></ul><br>  Die Daten in den Pipes kommen in Rohform ohne Yamux-Header, d. H.  in der Form, in der sie vom Socken-Client kamen. <br><br>  In socksScript müssen wir zunächst die Version der Socken bestimmen und sicherstellen, dass es 5 ist: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Nun, dann machen wir genau das, was im Invoke-SocksProxy-Skript implementiert ist.  Der einzige Unterschied wird sein, dass anstelle von Anrufen <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  Es ist notwendig, die TCP-Verbindung und das entsprechende Beendigungsflag im $ StopFlag-Array in einem zyklischen Modus zu überwachen, da wir sonst die Situation des Verbindungsende von der Seite des Socken-Clients und des ymux-Servers nicht erkennen können: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  Falls die Verbindung auf der TCP-Seite des Servers endet, zu dem wir eine Verbindung herstellen, setzen wir dieses Flag auf 2, wodurch yamuxscript dies erkennt und das entsprechende ymx-FIN-Paket an den yamux-Server sendet: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Wir müssen dieses Flag auch setzen, wenn socksScript keine Verbindung zum Zielserver herstellen kann: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Fazit zum zweiten Teil </h3><br>  Im Verlauf unserer Codierungsforschung konnten wir einen Powershell-Client für unseren RsocksTun-Server mit den folgenden Funktionen erstellen: <br><br><ul><li>  SSL-Verbindungen </li><li>  Autorisierung auf dem Server; </li><li>  Arbeit mit Yamux-Server mit Unterstützung für Keepalive-Pings; </li><li>  Multithread-Betriebsart; </li><li>  Unterstützung für die Übertragung großer Dateien; </li></ul><br>  Außerhalb des Artikels wurde die Funktionalität implementiert, eine Verbindung über einen Proxyserver herzustellen und zu autorisieren sowie unser Skript in eine Inline-Version umzuwandeln, die über die Befehlszeile ausgeführt werden kann.  Es wird im dritten Teil sein. <br><br>  Das ist alles für heute.  Wie sie sagen - abonnieren Sie gerne Kommentare (insbesondere in Bezug auf Ihre Gedanken zur Verbesserung des Codes und zum Hinzufügen von Funktionen). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453970/">https://habr.com/ru/post/de453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453958/index.html">Monorepositories: bitte</a></li>
<li><a href="../de453960/index.html">Globales DevOps Bootcamp 2019 in Moskau</a></li>
<li><a href="../de453962/index.html">RxSwift und Coroutines bei Kotlin - optionale mobile Entwicklung von AGIMA und GeekBrains</a></li>
<li><a href="../de453964/index.html">OOP in der R-Sprache (Teil 1): S3-Klassen</a></li>
<li><a href="../de453968/index.html">Verlernen Sie die Überprüfungspraktiken für toxischen Code</a></li>
<li><a href="../de453972/index.html">Archäologen erstellen mithilfe von 3D-Druck und -Scanning einen zweitausend Jahre alten Stift nach</a></li>
<li><a href="../de453974/index.html">Wettbewerb von ML-Systemen um Sprachmaterial. Wie haben wir gelernt, die Lücken zu füllen?</a></li>
<li><a href="../de453976/index.html">Wirtschaftliches Bildungsprogramm für IT-Spezialisten</a></li>
<li><a href="../de453978/index.html">Der 3D-3D-Drucker druckt ein Gebäude in 14 Stunden</a></li>
<li><a href="../de453980/index.html">Drucken von Etiketten und Preisschildern für den .net Online-Shop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>