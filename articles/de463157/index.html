<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèº üë®üèæ‚Äçüåæ ‚ö±Ô∏è ESP32-CAM-Video-Streaming-Server zum Verbinden von I2C- und SPI-Displays üçõ üè® üêî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ESP-32 CAM-Modul mit Kamera von Diymore 

 ESP32-CAM Video Streaming Server 
 Ein Anwendungsbeispiel finden Sie hier . 

 Sie m√ºssen zuerst die Biblio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ESP32-CAM-Video-Streaming-Server zum Verbinden von I2C- und SPI-Displays</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463157/">  ESP-32 CAM-Modul mit Kamera von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diymore</a> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/it/oc/feitoc3nxkss7zc6ocsw7cmuyho.jpeg" width="500"></div><br><h3>  ESP32-CAM Video Streaming Server </h3><br>  Ein Anwendungsbeispiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Sie m√ºssen zuerst die Bibliotheken installieren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Esp32-Karte in Arduino Ide Windows</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Esp32-Karte in Arduino Ide Linux und Mac</a> <br><br>  Detaillierte Einstellungen finden Sie im Artikel. <br><br>  In meinem Fall habe ich das AI-THINKER-Modul so unkommentiert verwendet <br>  #define CAMERA_MODEL_AI_THINKER <br><br>  Die Funktionalit√§t der Gesichtserkennung hat bei mir nicht funktioniert.  Der Kommentar im Artikel war hilfreich. <br><a name="habracut"></a><br>  Es scheint, dass die Gesichtserkennung (zumindest mit dem Beispielprogramm) bei Verwendung des 1.02 ESP-Kerns nicht mehr funktioniert.  Wenn Sie auf den 1.01-Kern zur√ºcksetzen und das zu diesem Kern geh√∂rende Beispielprogramm verwenden, wird dies behoben <br><br>  Nach dem Zur√ºcksetzen auf die vorherige Version von Bibliothek 1.01 hat alles funktioniert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/tg/47/_2tg47ntvkqznzh-nr_jhqzitz8.png"></div><br>  Ich habe ein Paar I2C 128x64- und TFT SPI 128x128-Displays <br><br>  Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OV7670 mit FIFO</a> zum Anschlie√üen der Kamera an das Display, wenn Sie kein CAM-Modul haben.  Unterst√ºtzt OV2640- und OV7670-Kameras <br><br>  Zum Zeitpunkt des Schreibens hat Folgendes f√ºr mich funktioniert <br><br>  ESP32-Kamera + WLAN-Server + I2C-Display (AdaFruit) <br>  ESP32-Kamera + SPI-Display 1,44 "TFT 128x128 v1.1 (AdaFruit) <br>  ESP32-Kamera + SPI-Display 1,8 "TFT 128 * 160 (Espressif-Bibliothek) <br><br>  Der WiFi-Treiber steht in Konflikt mit dem SPI-Bus.  M√∂gliche L√∂sung zur Verwendung einer anderen Bibliothek.  Das Problem trat zum Zeitpunkt der Initialisierung des WiFi-Moduls auf. <br><br>  Das Hauptproblem besteht darin, dass das ESP32-CAM-Modul eine begrenzte Anzahl freier Beine hat.  Ein Teil der Anschl√ºsse wird f√ºr die Kamera verwendet, ein Teil parallel zur SD-Karte.  Der SD-Kartenanschluss ist auf der Platine installiert.  Eine weitere Schlussfolgerung (IO4) ist die LED-Taschenlampe. <br><br>  Das I2C-Display in Schwarzwei√ü ist f√ºr den tats√§chlichen Gebrauch mit dem von der Kamera empfangenen Bild nicht von besonderem Interesse.  TFT-Farbe und hohe Aufl√∂sung.  Darauf sieht man schon das Gesicht.  Auf einem solchen Display oder einer etwas h√∂heren Aufl√∂sung k√∂nnen Sie das T√ºrauge machen <br><br>  Ich werde gleich sagen, dass die AdaFruit-Bibliothek nicht die schnellste ist.  Ich habe es geschafft, ein paar Bilder pro Sekunde anzuzeigen.  Es ist vielversprechender, Bibliotheken zu verwenden, die auf niedrigem Niveau arbeiten.  Aber ich konnte keine ESP32_TFT_Bibliothek mit meinem Display 1.44 "128x128 SPI V1.1 erhalten. Vielleicht wird ILI9163 nicht unterst√ºtzt. Ich habe 1.8" 128 * 160 SPI TFT genommen und es geschafft, ungef√§hr 12 FPS zu quetschen!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> <br><br>  Es gibt einige Bibliotheken, die schneller arbeiten.  Einige sind jedoch nicht f√ºr esp-32 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ) portiert: <br><br>  4,98 Sek. Adafruit_ST7735 <br>  1,71 Sek. ST7735X_kbv <br>  1,30 Sek. PDQ_ST7735 <br><br>  Das Video sieht beeindruckend aus: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HnhsxP0W0m4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Bei Verwendung von <s>zwei Ports kann</s> einer der HSPI- oder VSPI-Hardware-Ports des Mikrocontrollers und der Anzeige mit dem ILI9341-Treiber 30 Bilder pro Sekunde empfangen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7a/39/93/7a3993k5m_j9z5f2juglv5s9h9g.png"></div><br><br>  Wie ich bereits im ESP32-CAM-Modul erw√§hnt habe, ist nur ein SPI kostenlos.  Es wird auf den folgenden PINS angezeigt: <br><br>  IO2 - DC (A0) <br>  IO14 - CLK <br>  IO15 - CS <br>  IO13 - MOSI (SDA) <br>  IO12 - MISO (Eingabe. Nicht verwendet) <br><br>  IO0 - BCKL (Hintergrundbeleuchtung. Nicht verwendet) <br>  IO16 - RST <br><br><img src="https://habrastorage.org/webt/ob/wr/wy/obwrwyztxqm6ct4dtlxe_fggdim.png"><br><br><img src="https://habrastorage.org/webt/nr/7e/dg/nr7edg2broaykspjtyxncso2zxy.png"><br><br>  Die erste Bibliothek, die ich ausprobiert habe, war AdaFruit SSD1306 <br><br><h3>  I2C 128x64 Blaues OLED-Display </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/xl/ji/ecxljimycqq42q16yxswiehsv98.png"></div><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels // Declaration for an SSD1306 display connected to I2C (SDA, SCL pins) #define OLED_RESET -1 // Reset pin # (or -1 if sharing Arduino reset pin) Adafruit_SSD1306 display; void init_display(){ pinMode(14,INPUT_PULLUP); pinMode(15,INPUT_PULLUP); Wire.begin(14,15); display = Adafruit_SSD1306(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET); if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64 Serial.println(F("SSD1306 allocation failed")); for(;;); // Don't proceed, loop forever } ....</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">camera_capture ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BACKCOLOR 0x0000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Black #define PIXELCOLOR 0xFFFF // White #define FRAME_WIDTH 320 #define FRAME_HEIGHT 240 uint16_t pixel_color = 0; esp_err_t camera_capture(){ //acquire a frame camera_fb_t * fb = esp_camera_fb_get(); if (!fb) { ESP_LOGE(TAG, "Camera Capture Failed"); return ESP_FAIL; } int i = 0; for(int y = 0; y &lt; SCREEN_HEIGHT; y++){ for(int x = 0; x &lt; SCREEN_WIDTH; x++){ i = y * FRAME_WIDTH + x; // FRAMESIZE_QVGA // 320x240 char ch = (char)fb-&gt;buf[i]; if (ch &gt; 128) pixel_color = WHITE; else pixel_color = BLACK; // Draw a single pixel in white display.drawPixel(x, y, pixel_color); } } display.display(); //return the frame buffer back to the driver for reuse esp_camera_fb_return(fb); Serial.println("Capture frame ok."); return ESP_OK; }</span></span></span></span></code> </pre><br></div></div><br>  Bei der Arbeit in esp32 wird die Software I2C-Emulation verwendet.  Beteiligte IO14 und IO15.  Es k√∂nnen fast alle freien Ports verwendet werden, nicht der H / W-Bus. <br><br>  So schlie√üen Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">monochromes 0,96 "i2c-OLED-Display an</a> . Sie m√ºssen auf die Anzeigeadresse am I2C-Bus achten. In diesem Fall 0x3C <br><br><h3>  SPI-Anzeige 1,8 "TFT 128 * 160 Espressif Library </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e9/ym/zg/e9ymzg6iukpuzpowfbgvlln89dg.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/jv/j0/eojvj0nkmzg1dqiubx3jcaoepou.jpeg"></div><br>  Schaltplan: <br><br>  IO2 - A0 <br>  IO14 - SCK <br>  IO15 - CS <br>  IO13 - SDA <br>  IO16 - RESET <br><br><img src="https://habrastorage.org/webt/fp/v8/iv/fpv8iv79hdpoefoxwnzsc64ychm.png"><br>  Auf der Platine befindet sich auch ein SD-Kartenleser <br><br>  E / A-Konfiguration: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Configuration for other boards, set the correct values for the display used //---------------------------------------------------------------------------- #define DISP_COLOR_BITS_24 0x66 //#define DISP_COLOR_BITS_16 0x55 // Do not use! // ############################################# // ### Set to 1 for some displays, ### // for example the one on ESP-WROWER-KIT ### // ############################################# #define TFT_INVERT_ROTATION 0 #define TFT_INVERT_ROTATION1 0 // ################################################ // ### SET TO 0X00 FOR DISPLAYS WITH RGB MATRIX ### // ### SET TO 0X08 FOR DISPLAYS WITH BGR MATRIX ### // ### For ESP-WROWER-KIT set to 0x00 ### // ################################################ #define TFT_RGB_BGR 0x08 // ############################################################## // ### Define ESP32 SPI pins to which the display is attached ### // ############################################################## // The pins configured here are the native spi pins for HSPI interface // Any other valid pin combination can be used #define PIN_NUM_MISO 12 // SPI MISO #define PIN_NUM_MOSI 13 // SPI MOSI #define PIN_NUM_CLK 14 // SPI CLOCK pin #define PIN_NUM_CS 15 // Display CS pin #define PIN_NUM_DC 2 // Display command/data pin #define PIN_NUM_TCS 0 // Touch screen CS pin (NOT used if USE_TOUCH=0) // -------------------------------------------------------------- // ** Set Reset and Backlight pins to 0 if not used ! // ** If you want to use them, set them to some valid GPIO number #define PIN_NUM_RST 0 // GPIO used for RESET control #define PIN_NUM_BCKL 0 // GPIO used for backlight control #define PIN_BCKL_ON 0 // GPIO value for backlight ON #define PIN_BCKL_OFF 1 // GPIO value for backlight OFF // -------------------------------------------------------------- // ####################################################### // Set this to 1 if you want to use touch screen functions // ####################################################### #define USE_TOUCH TOUCH_TYPE_NONE // ####################################################### // ####################################################################### // Default display width (smaller dimension) and height (larger dimension) // ####################################################################### #define DEFAULT_TFT_DISPLAY_WIDTH 128 #define DEFAULT_TFT_DISPLAY_HEIGHT 160 // ####################################################################### #define DEFAULT_GAMMA_CURVE 0 #define DEFAULT_SPI_CLOCK 32000000 #define DEFAULT_DISP_TYPE DISP_TYPE_ST7735B //---------------------------------------------------------------------------- #define TFT_INVERT_ROTATION 0 #define TFT_INVERT_ROTATION1 1 #define TFT_INVERT_ROTATION2 0</span></span></code> </pre><br>  Installieren Sie die Umgebung und die Entwicklungsumgebung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Espressif</a> .  Detaillierte Anweisungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dazu</a> . <br><br>  Installieren Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> .  Zum Zusammenstellen der Bibliothek m√ºssen zwei Korrekturen vorgenommen werden. <br><br>  Makefile: <br><br><pre> <code class="bash hljs">+ CFLAGS += -Wno-error=tautological-compare \ + -Wno-implicit-fallthrough \ + -Wno-implicit-function-declaration</code> </pre><br>  Komponenten / tft / tftspi.c: <br><br><pre> <code class="cpp hljs">+ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"driver/gpio.h</span></span></span></span></code> </pre><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> <br><br>  Installieren Sie dann den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ESP32-Kameratreiber</a> . <br><br>  Konfigurieren: <br><br>  #.  $ HOME / esp / esp-idf / export.sh <br>  # idf.py menuconfig <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/yl/ml/ycylmlzznbfewlweiaris71dbzo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_3/gn/5s/_3gn5s4bmrqunmhwjeabdtxe9yu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x8/jc/g6/x8jcg6ia43npfcol7rebn1taz7e.png"></div><br>  Erm√∂glichen Sie den Zugriff auf den USB-Anschluss f√ºr Firmware und √úberwachung: <br><br>  #sudo chmod 777 / dev / ttyUSB0 <br><br>  Wir sammeln und f√ºllen: <br><br>  #make -j4 &amp;&amp; Flash machen <br><br>  12FPS wird durch Paketschreiben mit der Methode send_data erreicht.  Die Aufnahme erfolgt nicht Pixel f√ºr Pixel, sondern als ganze Zeile, die der Breite des Bildschirms entspricht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">esp_err_t</span></span> camera_capture(){ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> tstart, t1, t2; tstart = clock(); <span class="hljs-comment"><span class="hljs-comment">//acquire a frame camera_fb_t * fb = esp_camera_fb_get(); if (!fb) { printf("Camera Capture Failed\n"); return ESP_FAIL; } t1 = clock() - tstart; printf("Capture camera time: %u ms\r\n", t1); int i = 0, bufPos = 0; uint8_t hb, lb; color_t color; color_t *color_line = heap_caps_malloc(_width*3, MALLOC_CAP_DMA); tstart = clock(); for(int y = 0; y &lt; _height; y++) { bufPos = 0; for(int x = 0; x &lt; _width; x++) { i = (y * FRAME_WIDTH + x) &lt;&lt; 1; hb = fb-&gt;buf[i] ; lb = fb-&gt;buf[i + 1]; color.r = (lb &amp; 0x1F) &lt;&lt; 3; color.g = (hb &amp; 0x07) &lt;&lt; 5 | (lb &amp; 0xE0) &gt;&gt; 3; color.b = hb &amp; 0xF8; color_line[bufPos] = color; bufPos++; // TFT_drawPixel(0, 0, color, 1); } disp_select(); send_data(0, y, _width-1, y, _width, color_line); wait_trans_finish(1); disp_deselect(); } free(color_line); t1 = clock() - tstart; printf("Send buffer time: %u ms\r\n", t1); esp_camera_fb_return(fb); printf("Capture frame ok.\n"); return ESP_OK; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Kamerakonfiguration</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// #if defined(CAMERA_MODEL_AI_THINKER) #define PWDN_GPIO_NUM 32 #define RESET_GPIO_NUM -1 #define XCLK_GPIO_NUM 0 #define SIOD_GPIO_NUM 26 #define SIOC_GPIO_NUM 27 #define Y9_GPIO_NUM 35 #define Y8_GPIO_NUM 34 #define Y7_GPIO_NUM 39 #define Y6_GPIO_NUM 36 #define Y5_GPIO_NUM 21 #define Y4_GPIO_NUM 19 #define Y3_GPIO_NUM 18 #define Y2_GPIO_NUM 5 #define VSYNC_GPIO_NUM 25 #define HREF_GPIO_NUM 23 #define PCLK_GPIO_NUM 22 void camera_init_(){ camera_config_t config; config.ledc_channel = LEDC_CHANNEL_0; config.ledc_timer = LEDC_TIMER_0; config.pin_d0 = Y2_GPIO_NUM; config.pin_d1 = Y3_GPIO_NUM; config.pin_d2 = Y4_GPIO_NUM; config.pin_d3 = Y5_GPIO_NUM; config.pin_d4 = Y6_GPIO_NUM; config.pin_d5 = Y7_GPIO_NUM; config.pin_d6 = Y8_GPIO_NUM; config.pin_d7 = Y9_GPIO_NUM; config.pin_xclk = XCLK_GPIO_NUM; config.pin_pclk = PCLK_GPIO_NUM; config.pin_vsync = VSYNC_GPIO_NUM; config.pin_href = HREF_GPIO_NUM; config.pin_sscb_sda = SIOD_GPIO_NUM; config.pin_sscb_scl = SIOC_GPIO_NUM; config.pin_pwdn = PWDN_GPIO_NUM; config.pin_reset = RESET_GPIO_NUM; config.xclk_freq_hz = 20000000; config.fb_count = 2; // for display config.frame_size = FRAMESIZE_QVGA; config.pixel_format = PIXFORMAT_RGB565; // camera init esp_err_t err = esp_camera_init(&amp;config); if (err != ESP_OK) { printf("Camera init failed with error 0x%x", err); return; } printf("Camera init OK\n"); }</span></span></code> </pre><br></div></div><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kern</a> <br><br>  <u>FRAME_WIDTH ist die Bildbreite von 320 Pixel f√ºr QVGA</u> <br><br><pre> <code class="cpp hljs">config.frame_size = FRAMESIZE_QVGA; <span class="hljs-comment"><span class="hljs-comment">// 320x240</span></span></code> </pre><br>  Tats√§chlich sehen wir im Anzeigefenster 128 * 160 das Vollbild <br><br>  <i>Protokollieren Sie die Konfiguration mit einem Videokamerapuffer (config.fb_count = 1).</i> <i><br></i>  <i>Kamerazeit erfassen: 32 ms</i> <i><br></i>  <i>Sendepufferzeit: 47 ms</i> <i><br></i>  <i>Frame erfassen ok.</i> <br><br>  <b>Ergebnis</b> <b><br></b>  <b>1000 / (32 + 47) = 12,65 FPS</b> <br><br><div class="spoiler">  <b class="spoiler_title">Protokollieren Sie die Konfiguration mit zwei Camcorder-Puffern (config.fb_count = 2).</b> <div class="spoiler_text">  Kamerazeit erfassen: 39 ms <br><br>  Sendepufferzeit: 63 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 59 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 34 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 40 ms <br><br>  Sendepufferzeit: 64 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 59 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 34 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 40 ms <br><br>  Sendepufferzeit: 63 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 60 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 34 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 39 ms <br><br>  Sendepufferzeit: 63 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 60 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 1 ms <br><br>  Sendepufferzeit: 34 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 40 ms <br><br>  Sendepufferzeit: 63 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 60 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 34 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 40 ms <br><br>  Sendepufferzeit: 63 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 59 ms <br><br>  Frame erfassen ok. <br>  Kamerazeit erfassen: 0 ms <br><br>  Sendepufferzeit: 35 ms <br><br>  Frame erfassen ok. </div></div><br>  Durch Verwendung des zweiten Puffers des Camcorders wird der Puffer in einigen Zyklen sofort erhalten.  Zuerst wird der vollst√§ndige Zyklus in weniger als der Verwendung eines Puffers erhalten, aber dieses Mal l√§uft es weiter.  Das Intervall zwischen den Zyklen ist schwebend. <br><br>  Mehrmals habe ich in den Protokollen "Brownout-Detektor wurde ausgel√∂st" abgefangen, also habe ich den Detektor ausgeschaltet.  Denn zuerst habe ich die Hintergrundbeleuchtung √ºber den 3,3-V-ESP32-CAM-Pin gespeist <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"soc/rtc_cntl_reg.h"</span></span></span><span class="hljs-meta"> ... WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//disable brownout detector</span></span></span></span></code> </pre><br><h3>  Fazit </h3><br>  Kosteng√ºnstiges ESP32-Funktionsmodul.  Es gibt einen katastrophalen Mangel an Schlussfolgerungen f√ºr die implementierten Ports in der CAM-Version der Karte. W√§hlen Sie daher die CAM-Version, wenn Sie wirklich eine Kamera ben√∂tigen. <br><br><div class="spoiler">  <b class="spoiler_title">N√ºtzliche Links</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">randomnerdtutorials.com/esp32-troubleshooter-guide</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.instructables.com/id/Select-Color-Display-for-ESP32</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/gnulabis/UTFT-ESP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/Bodmer/TFT_eSPI</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463157/">https://habr.com/ru/post/de463157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463143/index.html">Erste Schritte mit Google Analytics: App + Web</a></li>
<li><a href="../de463147/index.html">ROS Trolley Robot. Teil 3. Beschleunigen, Kamera wechseln, Gang fixieren</a></li>
<li><a href="../de463149/index.html">Alan Kay empfiehlt, alte und vergessene, aber wichtige Programmierb√ºcher zu lesen</a></li>
<li><a href="../de463151/index.html">iOS 13 unter der Lupe</a></li>
<li><a href="../de463155/index.html">Wei√ües Rauschen zeichnet ein schwarzes Quadrat. Teil 2. L√∂sung</a></li>
<li><a href="../de463159/index.html">√úber Sicherheit, Zahlen, E-Mails und einiges √ºber Werbung</a></li>
<li><a href="../de463165/index.html">Telegramm schl√§gt DPI zur√ºck und sperrt - Fake TLS</a></li>
<li><a href="../de463167/index.html">Notwendige Materialien, um mit der Entwicklung eines VR-Schulungsprojekts zu beginnen</a></li>
<li><a href="../de463169/index.html">Open Source H√∂rger√§t - wie es funktioniert</a></li>
<li><a href="../de463171/index.html">Neuronale Netze und Deep Learning: Ein Online-Tutorial, Kapitel 6, Teil 1: Deep Learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>