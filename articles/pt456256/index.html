<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📓 👨‍🎤 🗒️ Guia de Arquitetura de Aplicativos Android 🌳 ◾️ 🤥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução gratuita do “Guide to app architecture” do JetPack . Peço que você deixe todos os comentários sobre a tradução n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia de Arquitetura de Aplicativos Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456256/">  Olá Habr!  Apresento a você a tradução gratuita do “Guide to app architecture” do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JetPack</a> .  Peço que você deixe todos os comentários sobre a tradução nos comentários, e eles serão corrigidos.  Além disso, comentários daqueles que usaram a arquitetura apresentada com recomendações para seu uso serão úteis para todos. <br><br>  Este guia aborda as práticas recomendadas e a arquitetura recomendada para a criação de aplicativos robustos.  Esta página pressupõe uma introdução básica ao Android Framework.  Se você é novo no desenvolvimento de aplicativos Android, consulte nossos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">guias</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desenvolvedores</a> para começar e aprender mais sobre os conceitos mencionados neste guia.  Se você estiver interessado em arquitetura de aplicativos e quiser se familiarizar com os materiais deste guia em termos de programação no Kotlin, consulte o curso Udacity, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Desenvolvendo aplicativos para Android com Kotlin"</a> . <br><br><h2>  Experiência do usuário de aplicativos para dispositivos móveis </h2><br>  Na maioria dos casos, os aplicativos de área de trabalho têm um único ponto de entrada na área de trabalho ou no iniciador e, em seguida, são executados como um único processo monolítico.  Os aplicativos Android têm uma estrutura muito mais complexa.  Um aplicativo Android típico contém vários <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">componentes de aplicativos</a> , incluindo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atividades</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fragmentos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Serviços</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ContentProviders</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BroadcastReceivers</a> . <br><br>  Você declara todos ou alguns desses componentes do aplicativo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manifesto</a> do aplicativo.  O Android usa esse arquivo para decidir como integrar seu aplicativo à interface de usuário comum do dispositivo.  Como um aplicativo Android bem escrito contém vários componentes, e os usuários geralmente interagem com vários aplicativos em um curto período de tempo, os aplicativos devem se adaptar a diferentes tipos de fluxos de trabalho e tarefas orientadas ao usuário. <br><a name="habracut"></a><br>  Por exemplo, considere o que acontece quando você compartilha uma foto em seu aplicativo de mídia social favorito: <br><br><ol><li>  O aplicativo aciona a intenção da câmera.  O Android inicia um aplicativo de câmera para processar a solicitação.  No momento, o usuário deixou o aplicativo para redes sociais e sua experiência como usuário é impecável. </li><li>  Um aplicativo de câmera pode acionar outras intenções, como iniciar um seletor de arquivos, que pode iniciar outro aplicativo. </li><li>  No final, o usuário retorna ao aplicativo de rede social e compartilha a foto. </li></ol><br>  A qualquer momento do processo, o usuário pode ser interrompido por uma ligação ou notificação.  Após a ação associada a essa interrupção, o usuário espera poder retornar e retomar esse processo de compartilhamento de fotos.  Esse comportamento de troca de aplicativos é comum em dispositivos móveis, portanto, seu aplicativo deve lidar corretamente com esses pontos (tarefas). <br><br>  Lembre-se de que os dispositivos móveis também têm recursos limitados; portanto, a qualquer momento, o sistema operacional pode destruir alguns processos de aplicativos, a fim de liberar espaço para novos. <br><br>  Dadas as condições desse ambiente, os componentes do seu aplicativo podem ser iniciados individualmente e não em ordem, e o sistema operacional ou o usuário pode destruí-los a qualquer momento.  Como esses eventos não estão sob seu controle, <b>você não deve armazenar dados ou estados nos componentes do aplicativo</b> e os componentes do aplicativo não devem depender um do outro. <br><br><h2>  Princípios gerais de arquitetura </h2><br>  Se você não deve usar componentes do aplicativo para armazenar dados e estado do aplicativo, como deve desenvolver seu aplicativo? <br><br><h3>  Divisão de responsabilidade </h3><br>  O princípio mais importante a seguir é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o compartilhamento de responsabilidades</a> .  Um erro comum é quando você escreve todo o seu código em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atividade</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fragmento</a> .  Essas são classes de interface do usuário que devem conter apenas lógica processando a interação da interface com o usuário e do sistema operacional.  Ao compartilhar a responsabilidade o máximo possível nessas classes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(SRPs)</a> , você pode evitar muitos dos problemas associados ao ciclo de vida do aplicativo. <br><br><h3>  Controle de interface do usuário do modelo </h3><br>  Outro princípio importante é que você deve <b>controlar sua interface com o usuário a partir de um modelo</b> , de preferência de um modelo permanente.  Modelos são os componentes responsáveis ​​pelo processamento dos dados para o aplicativo.  Eles são independentes dos objetos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">View</a> e dos componentes do aplicativo, portanto, não são afetados pelo ciclo de vida do aplicativo e pelos problemas relacionados. <br><br>  Um modelo permanente é ideal pelos seguintes motivos: <br><br><ul><li>  Seus usuários não perderão dados se o sistema operacional Android destruir seu aplicativo para liberar recursos. </li><li>  Seu aplicativo continua funcionando quando a conexão de rede está instável ou indisponível. </li></ul><br>  Ao organizar a base do seu aplicativo em classes de modelo com uma responsabilidade claramente definida pelo gerenciamento de dados, seu aplicativo se torna mais testável e suportado. <br><br><h2>  Arquitetura de aplicativo recomendada </h2><br>  Esta seção demonstra como estruturar um aplicativo usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">componentes de arquitetura</a> , trabalhando em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cenário de uso de ponta a ponta</a> . <br><br>  <i><b>Nota</b></i>  <i>Não é possível ter uma maneira de escrever aplicativos que funcionem melhor para cada cenário.</i>  <i>No entanto, a arquitetura recomendada é um bom ponto de partida para a maioria das situações e fluxos de trabalho.</i>  <i>Se você já possui uma boa maneira de escrever aplicativos Android que atendam aos princípios gerais de arquitetura, não deve alterá-lo.</i> <br><br>  Imagine que estamos criando uma interface de usuário que exibe um perfil de usuário.  Usamos uma API privada e uma API REST para recuperar dados do perfil. <br><br><h3>  Revisão </h3><br>  Para começar, considere o esquema de interação dos módulos da arquitetura do aplicativo finalizado: <br><br><img src="https://habrastorage.org/webt/lb/xq/cx/lbxqcxyjtoauqkif9hte7srpnm8.png"><br><br>  Observe que cada componente depende apenas do componente um nível abaixo dele.  Por exemplo, Atividade e Fragmentos dependem apenas do modelo de exibição.  Repositório é a única classe que depende de muitas outras classes;  neste exemplo, o armazenamento depende de um modelo de dados persistente e de uma fonte de dados interna remota. <br><br>  Esse padrão de design cria uma experiência do usuário consistente e agradável.  Independentemente de o usuário retornar ao aplicativo alguns minutos depois de fechá-lo ou alguns dias depois, ele verá instantaneamente as informações do usuário de que o aplicativo foi salvo localmente.  Se esses dados estiverem desatualizados, o módulo de armazenamento do aplicativo começará a atualizar os dados em segundo plano. <br><br><h3>  Crie uma interface de usuário </h3><br>  A interface do usuário consiste no fragmento <code>UserProfileFragment</code> e no <code>user_profile_layout.xml</code> layout <code>user_profile_layout.xml</code> correspondente. <br><br>  Para gerenciar a interface do usuário, nosso modelo de dados deve conter os seguintes elementos de dados: <br><br><ul><li>  <b>ID do</b> usuário <b>:</b> ID do usuário.  A melhor solução é passar essas informações para o fragmento usando os argumentos do fragmento.  Se o sistema operacional Android destruir nosso processo, essas informações serão salvas, para que o identificador fique disponível na próxima vez que iniciarmos nosso aplicativo. </li><li>  <b>Objeto de usuário:</b> uma classe de dados que contém informações do usuário. </li></ul><br>  Usamos um <code>UserProfileViewModel</code> baseado em um componente da arquitetura ViewModel para armazenar essas informações. <br><br>  <i><u>O objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ViewModel</a> fornece dados para um componente específico da interface com o usuário, como fragmento ou Atividade, e contém lógica de processamento de dados corporativos para interagir com o modelo.</u></i>  <i><u>Por exemplo, o <b>ViewModel</b> pode chamar outros componentes para carregar dados e encaminhar solicitações de usuário para alterações de dados.</u></i>  <i><u><b>O ViewModel</b> não conhece os componentes da interface do usuário e, portanto, não é afetado por alterações na configuração, como recriar Activity quando o dispositivo é girado.</u></i> <br><br>  Agora, identificamos os seguintes arquivos: <br><br><ul><li>  <code>user_profile.xml</code> : layout da interface do usuário definido. </li><li>  <code>UserProfileFragment</code> : descreveu um controlador de interface do usuário responsável por exibir informações ao usuário. </li><li>  <code>UserProfileViewModel</code> : uma classe responsável por preparar os dados para exibi-los em <code>UserProfileFragment</code> e responder à interação do usuário. </li></ul><br>  Os seguintes trechos de código mostram o conteúdo inicial desses arquivos.  (O arquivo de layout é omitido por simplicidade.) <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = TODO() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : User = TODO() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel: UserProfileViewModel <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> viewModels() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span>: View { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inflater.inflate(R.layout.main_fragment, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }</code> </pre> <br>  Agora que temos esses módulos de código, como os conectamos?  Depois que o campo do usuário é definido na classe UserProfileViewModel, precisamos de uma maneira de informar a interface do usuário. <br><br>  <i><b>Nota</b></i>  <i>SavedStateHandle permite que o ViewModel acesse o estado salvo e os argumentos do fragmento ou ação associado.</i> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle["uid"] ?: throw IllegalArgumentException("missing user id") val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateVMFactory(this) } ... )</span></span></code> </pre> <br>  Agora precisamos informar nosso fragmento quando o objeto de usuário for recebido.  É aqui que o componente da arquitetura LiveData aparece. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LiveData</a> é um detentor de dados observável.  Outros componentes em seu aplicativo podem rastrear alterações nos objetos usando esse suporte, sem criar caminhos explícitos e difíceis de dependência entre eles.  O componente LiveData também leva em consideração o estado do ciclo de vida dos componentes do seu aplicativo, como Atividades, Fragmentos e Serviços, e inclui lógica de limpeza para evitar vazamento de objetos e consumo excessivo de memória. <br><br>  <i>Nota</i>  <i>Se você já usa bibliotecas como RxJava ou Agera, pode continuar a usá-las em vez do LiveData.</i>  <i>No entanto, ao usar bibliotecas e abordagens semelhantes, lembre-se de lidar adequadamente com o ciclo de vida do seu aplicativo.</i>  <i>Em particular, verifique se você suspendeu seus fluxos de dados quando o LifecycleOwner associado for parado e destrua esses fluxos quando o LifecycleOwner associado tiver sido destruído.</i>  <i>Você também pode adicionar o artefato android.arch.lifecycle: jet streams para usar o LiveData com outra biblioteca de jet stream, como RxJava2.</i> <br><br>  Para incluir o componente LiveData em nosso aplicativo, alteramos o tipo de campo em <code>UserProfileViewModel</code> para LiveData.  <code>UserProfileFragment</code> agora <code>UserProfileFragment</code> informado sobre atualizações de dados.  Além disso, como esse campo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LiveData</a> suporta o ciclo de vida, ele limpa automaticamente os links quando não são mais necessários. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span></span>( savedStateHandle: SavedStateHandle ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = TODO() }</code> </pre> <br>  Agora, modificamos o <code>UserProfileFragment</code> para observar os dados no <code>ViewModel</code> e atualizar a interface do usuário de acordo com as alterações: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewModel.user.observe(viewLifecycleOwner) { <span class="hljs-comment"><span class="hljs-comment">//  UI } }</span></span></code> </pre> <br>  Sempre que os dados do perfil do usuário são atualizados, o retorno de chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">onChanged ()</a> é chamado e a interface do usuário é atualizada. <br><br>  Se você estiver familiarizado com outras bibliotecas que usam retornos de chamada observáveis, talvez tenha percebido que não redefinimos o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">onStop ()</a> do fragmento para interromper a observação dos dados.  Esta etapa é opcional para o LiveData, pois suporta o ciclo de vida, o que significa que ele não chamará o retorno de chamada <code>onChanged()</code> se o fragmento estiver em um estado inativo;  isto é, ele recebeu uma ligação para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">onStart ()</a> , mas ainda não recebeu <code>onStop()</code> ).  O LiveData também remove automaticamente o observador ao chamar o método <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">onDestroy ()</a> no fragmento. <br><br>  Não adicionamos nenhuma lógica para lidar com as alterações na configuração, como girar a tela do dispositivo pelo usuário.  <code>UserProfileViewModel</code> restaurado automaticamente quando a configuração é alterada. Assim que um novo fragmento é criado, ele recebe a mesma instância do <code>ViewModel</code> e o retorno de chamada é chamado imediatamente usando os dados atuais.  Como os objetos <code>ViewModel</code> são projetados para sobreviver aos objetos <code>View</code> correspondentes que eles atualizam, você não deve incluir referências diretas aos objetos <code>View</code> na sua implementação do ViewModel.  Para obter mais informações sobre a vida útil do <code>ViewModel</code> corresponde ao ciclo de vida dos componentes da interface do usuário, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ciclo de vida do ViewModel.</a> <br><br><h3>  Recuperação de dados </h3><br>  Agora que usamos o LiveData para conectar o <code>UserProfileViewModel</code> ao <code>UserProfileFragment</code> , como podemos obter dados do perfil do usuário? <br><br>  Neste exemplo, assumimos que nosso back-end fornece uma API REST.  Usamos a biblioteca Retrofit para acessar nosso back-end, embora você possa usar uma biblioteca diferente que atenda ao mesmo objetivo. <br><br>  Aqui está a nossa definição de um serviço da <code>Webservice</code> vinculado ao nosso back-end: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Webservice</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> declares an HTTP GET request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Path</span></span></span><span class="hljs-comment">("user") annotation on the userId parameter marks it as a * replacement for the {user} placeholder in the </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@GET</span></span></span><span class="hljs-comment"> path */</span></span> <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/users/{user}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Path(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"user"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Call&lt;User&gt; }</code> </pre> <br>  Uma primeira idéia para implementar um <code>ViewModel</code> pode envolver chamar o serviço da <code>Webservice</code> para recuperar os dados e atribuí- <code>LiveData</code> ao nosso objeto <code>LiveData</code> .  Esse design funciona, mas usá-lo torna nosso aplicativo mais difícil de manter à medida que cresce.  Isso atribui muita responsabilidade à classe <code>UserProfileViewModel</code> , que viola o princípio da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">separação de interesses</a> .  Além disso, o escopo do ViewModel está associado ao ciclo de vida da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Atividade</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fragmento</a> , o que significa que os dados do serviço da <code>Webservice</code> perdidos quando o ciclo de vida do objeto da interface do usuário associado termina.  Esse comportamento cria uma experiência indesejável para o usuário. <br><br>  Em vez disso, nosso <code>ViewModel</code> delega o processo de recuperação de dados para um novo módulo de armazenamento. <br><br>  <u><i><b>Os</b> módulos de <b>repositório</b> lidam com operações de dados.</i></u>  <u><i>Eles fornecem uma API limpa para que o restante do aplicativo possa obter esses dados com facilidade.</i></u>  <u><i>Eles sabem de onde obter os dados e o que a API chama para fazer ao atualizar os dados.</i></u>  <u><i>Você pode pensar nos repositórios como intermediários entre diferentes fontes de dados, como modelos persistentes, serviços da web e caches.</i></u> <br><br>  Nossa classe <code>UserRepository</code> , mostrada no seguinte trecho de código, usa uma instância do <code>WebService</code> para recuperar dados do usuário: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> webservice: Webservice = TODO() <span class="hljs-comment"><span class="hljs-comment">// ... fun getUser(userId: String): LiveData&lt;User&gt; { //    .    . val data = MutableLiveData&lt;User&gt;() webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br>  Embora o módulo de armazenamento pareça desnecessário, ele serve a um propósito importante: abstrai as fontes de dados do restante do aplicativo.  Agora, nosso <code>UserProfileViewModel</code> não sabe recuperar dados, para que possamos fornecer aos modelos de apresentação dados obtidos de várias implementações diferentes de extração de dados. <br><br>  <b>Nota</b>  Perdemos o caso de erros de rede por simplicidade.  Para uma implementação alternativa que expõe erros e status de download, consulte o Apêndice: Divulgação do status da rede. <br><br>  <b>Gerenciando dependências entre componentes</b> <br><br>  A classe <code>UserRepository</code> acima precisa de uma instância do <code>Webservice</code> para recuperar dados do usuário.  Ele poderia apenas criar uma instância, mas para isso ele também precisa conhecer as dependências da classe de serviço da <code>Webservice</code> .  Além disso, <code>UserRepository</code> provavelmente não é a única classe que precisa de um serviço da web.  Essa situação exige a duplicação do código, pois toda classe que precisa de um link para o serviço da <code>Webservice</code> precisa saber como criá-lo e suas dependências.  Se cada classe criar um novo <code>WebService</code> , nosso aplicativo poderá se tornar muito intensivo em recursos. <br><br>  Para resolver esse problema, você pode usar os seguintes padrões de design: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Injeção de Dependência (DI)</a> .  A injeção de dependência permite que as classes definam suas dependências sem criá-las.  Em tempo de execução, outra classe é responsável por fornecer essas dependências.  Recomendamos a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dagger 2</a> para implementar a injeção de dependência em aplicativos Android.  O Dagger 2 cria automaticamente objetos, ignorando a árvore de dependências e fornece garantias em tempo de compilação para dependências. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Local do serviço) Localizador de serviço</a> : O modelo do localizador de serviço fornece um registro no qual as classes podem obter suas dependências em vez de construí-las. </li></ul><br>  A implementação de um registro de serviço é mais fácil do que usar o DI; portanto, se você é novo no DI, use o modelo: localização do serviço. <br><br>  Esses modelos permitem escalar seu código porque fornecem modelos claros para gerenciar dependências sem duplicar ou complicar o código.  Além disso, esses modelos permitem alternar rapidamente entre implementações de teste e produção de amostragem de dados. <br><br>  Nosso aplicativo de amostra usa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dagger 2</a> para gerenciar as dependências do objeto <code>Webservice</code> . <br><br><h3>  Conecte o ViewModel e armazenamento </h3><br>  Agora modificamos nosso <code>UserProfileViewModel</code> para usar o objeto <code>UserRepository</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( savedStateHandle: SavedStateHandle, userRepository: UserRepository ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userId : String = savedStateHandle[<span class="hljs-string"><span class="hljs-string">"uid"</span></span>] ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"missing user id"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user : LiveData&lt;User&gt; = userRepository.getUser(userId) }</code> </pre> <br><h3>  Armazenamento em cache </h3><br>  A implementação <code>UserRepository</code> abstrai a chamada do objeto <code>Webservice</code> , mas como conta apenas com uma fonte de dados, não é muito flexível. <br><br>  O principal problema com a implementação do <code>UserRepository</code> é que, depois de receber dados do nosso back-end, esses dados não são armazenados em nenhum lugar.  Portanto, se o usuário sair do <code>UserProfileFragment</code> e retornar a ele, nosso aplicativo deverá recuperar os dados, mesmo que eles não tenham sido alterados. <br><br>  Esse design não é ideal pelos seguintes motivos: <br><br><ul><li>  Gasta recursos valiosos de tráfego. </li><li>  Isso faz com que o usuário aguarde a conclusão de uma nova solicitação. </li></ul><br>  Para resolver essas deficiências, adicionamos uma nova fonte de dados ao nosso <code>UserRepository</code> , que armazena em cache objetos de <code>User</code> na memória: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// Dagger,        . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val userCache: UserCache ) { fun getUser(userId: String): LiveData&lt;User&gt; { val cached = userCache.get(userId) if (cached != null) { return cached } val data = MutableLiveData&lt;User&gt;() userCache.put(userId, data) //     ,  ,  . //      . webservice.getUser(userId).enqueue(object : Callback&lt;User&gt; { override fun onResponse(call: Call&lt;User&gt;, response: Response&lt;User&gt;) { data.value = response.body() } //     . override fun onFailure(call: Call&lt;User&gt;, t: Throwable) { TODO() } }) return data } }</span></span></code> </pre> <br><h3>  Dados persistentes </h3><br>  Usando nossa implementação atual, se o usuário girar o dispositivo ou sair e retornar imediatamente ao aplicativo, a interface do usuário existente ficará imediatamente visível, porque a loja recupera dados do nosso cache na memória. <br><br>  No entanto, o que acontece se um usuário sair do aplicativo e retornar algumas horas depois que o sistema operacional Android concluir o processo?  Contando com nossa implementação atual nessa situação, precisamos obter dados da rede novamente.  Esse processo de atualização não é apenas uma experiência ruim para o usuário;  também é um desperdício porque consome dados móveis valiosos. <br><br>  Você pode resolver esse problema armazenando em cache solicitações da Web, mas isso cria um novo problema importante: o que acontece se os mesmos dados do usuário são exibidos em um tipo diferente de solicitação, por exemplo, ao receber uma lista de amigos?  O aplicativo exibirá dados conflitantes, o que é confuso na melhor das hipóteses.  Por exemplo, nosso aplicativo pode exibir duas versões diferentes dos dados do mesmo usuário se o usuário enviou uma solicitação de lista de amigos e uma solicitação de usuário único em momentos diferentes.  Nosso aplicativo precisaria descobrir como combinar esses dados conflitantes. <br><br>  A maneira correta de lidar com essa situação é usar um modelo constante.  A Biblioteca de Dados Permanentes da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sala</a> (DB) vem em nosso auxílio. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Room</a> é uma biblioteca de mapeamento de objetos que fornece armazenamento de dados local com um código padrão mínimo.  No momento da compilação, ele verifica cada consulta quanto à conformidade com seu esquema de dados; portanto, consultas SQL quebradas resultam em erros durante a compilação e não travam no tempo de execução.  Resumos de sala de alguns detalhes básicos da implementação de tabelas e consultas SQL brutas.  Também permite observar alterações nos dados do banco de dados, incluindo solicitações de coleta e conexão, expondo essas alterações usando objetos LiveData.  Ele mesmo define explicitamente restrições de execução que resolvem problemas comuns de encadeamento, como acesso ao armazenamento no encadeamento principal. <br><br>  <i><b>Nota</b></i>  <i>Se seu aplicativo já usa outra solução, como o ORM (SQLite Object Relational Mapping), você não precisa substituir a solução existente por Room.</i>  <i>No entanto, se você estiver escrevendo um novo aplicativo ou reorganizando um aplicativo existente, recomendamos o uso do Room para salvar os dados do aplicativo.</i>  <i>Assim, você pode tirar proveito da abstração da biblioteca e validação de consulta.</i> <br><br>  Para usar o Room, precisamos definir nosso layout local.  Primeiro, adicionamos a anotação <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@Entity</a></code> à nossa classe de modelo de dados do <code>User</code> e a anotação <code>@PrimaryKey</code> no campo de <code>id</code> da classe.  Essas anotações marcam <code>User</code> como uma tabela em nosso banco de dados e <code>id</code> como a chave primária da tabela: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String )</code> </pre> <br>  Em seguida, criamos a classe de banco de dados implementando o <code>RoomDatabase</code> para nosso aplicativo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>()</code> </pre> <br>  Observe que o <code>UserDatabase</code> é abstrato.  A biblioteca da sala fornece isso automaticamente.  Consulte a documentação do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quarto</a> para obter detalhes. <br><br>  Agora precisamos de uma maneira de inserir dados do usuário no banco de dados.  Para esta tarefa, criamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um objeto de acesso a dados (DAO)</a> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = REPLACE)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM user WHERE id = :userId"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: LiveData&lt;User&gt; }</code> </pre> <br>  Observe que o método <code>load</code> retorna um objeto do tipo LiveData.  A sala sabe quando o banco de dados é alterado e notifica automaticamente todos os observadores ativos de alterações de dados.  Como o Room usa o <i>LiveData</i> , essa operação é eficiente;  ele atualiza os dados apenas se houver pelo menos um observador ativo. <br><br>  <i><b>Nota: A</b> sala verifica a invalidação com base nas modificações da tabela, o que significa que ele pode enviar notificações de falsos positivos.</i> <br><br>  Após definir nossa classe <code>UserDao</code> , fazemos referência ao DAO da nossa classe de banco de dados: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Database(entities = [User::class], version = 1)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDatabase</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoomDatabase</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: UserDao }</code> </pre> <br>  Agora podemos alterar nosso <code>UserRepository</code> para incluir a fonte de dados da sala: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, //    .    . private val executor: Executor, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { refreshUser(userId) //   LiveData    . return userDao.load(userId) } private fun refreshUser(userId: String) { //    . executor.execute { // ,      . val userExists = userDao.hasUser(FRESH_TIMEOUT) if (!userExists) { //  . val response = webservice.getUser(userId).execute() //    . //   .  LiveData  , //        . userDao.save(response.body()!!) } } } companion object { val FRESH_TIMEOUT = TimeUnit.DAYS.toMillis(1) } }</span></span></code> </pre> <br>  Observe que, mesmo se alteramos a fonte de dados no <code>UserRepository</code> , não precisamos alterar nosso <code>UserProfileViewModel</code> ou <code>UserProfileFragment</code> .  Esta pequena atualização demonstra a flexibilidade que nossa arquitetura de aplicativos oferece.  Também é ótimo para teste, porque podemos fornecer um <code>UserRepository</code> falso e testar nosso <code>UserProfileViewModel</code> produção ao mesmo tempo. <br><br>  Se os usuários retornarem em alguns dias, é provável que um aplicativo que use essa arquitetura exiba informações desatualizadas até que o repositório receba informações atualizadas.  Dependendo do seu caso de uso, você pode não exibir informações desatualizadas.  Em vez disso, você pode exibir dados de <i>espaço reservado</i> , o que mostra valores ilegais e indica que seu aplicativo está baixando e carregando informações atualizadas. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A única fonte de verdade:</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalmente, diferentes pontos de extremidade da API REST retornam os mesmos dados. Por exemplo, se nosso back-end tiver outro ponto de extremidade que retorne uma lista de amigos, o mesmo objeto de usuário poderá vir de dois pontos de extremidade da API diferentes, possivelmente até usando diferentes níveis de detalhe. Se </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornarmos a resposta da solicitação </font></font><code>Webservice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como está, sem verificar a consistência, nossas interfaces com o usuário poderão mostrar informações confusas, porque a versão e o formato dos dados do armazenamento dependerão do último ponto final chamado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por esse motivo, nossa implementação </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">armazena respostas de serviço da web em um banco de dados. Alterações no banco de dados acionam retornos de chamada para objetos ativos do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LiveData</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Usando esse modelo, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o banco de dados serve como a única fonte de verdade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e outras partes do aplicativo acessam-no através do nosso </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Independentemente de você usar um cache de disco, recomendamos que seu repositório identifique a fonte de dados como a única fonte de verdade para o restante do seu aplicativo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar progresso da operação </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em alguns casos de uso, como puxar para atualizar, é importante que a interface do usuário mostre ao usuário que uma operação de rede está em andamento no momento. </font><font style="vertical-align: inherit;">É recomendável que a ação da interface do usuário seja separada dos dados reais, pois os dados podem ser atualizados por vários motivos. </font><font style="vertical-align: inherit;">Por exemplo, se recebermos uma lista de amigos, o mesmo usuário poderá ser selecionado novamente programaticamente, o que levará a uma atualização para o LiveData. </font><font style="vertical-align: inherit;">Do ponto de vista da interface do usuário, o fato de ter uma solicitação em andamento é apenas outro ponto de dados, semelhante a qualquer outra parte de dados no próprio objeto </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos usar uma das seguintes estratégias para exibir o status de atualização de dados acordado na interface do usuário, independentemente de onde a solicitação de atualização de dados veio: </font></font><br><br><ul><li>  <code>getUser ()</code> ,      <code>LiveData</code> .         .  ,   NetworkBoundResource   GitHub <a href="">android-Architecture-components</a> . </li><li>       <code>UserRepository</code> ,      .    ,              ,         ,   pull-to-refresh. </li></ul><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na seção sobre separação de interesses, mencionamos que uma das principais vantagens de seguir esse princípio é a testabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lista a seguir mostra como testar cada módulo de código do nosso exemplo estendido:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface do usuário e interação</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : use o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android UI Test Toolkit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A melhor maneira de criar esse teste é usar a biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espresso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Você pode criar um fragmento e fornecer um layout </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como o fragmento está associado apenas a </font></font><code>UserProfileViewModel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imitação (imitação)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dessa classe é suficiente para testar completamente a interface do usuário do seu aplicativo.</font></font></li><li> <b>ViewModel:</b>     <code>UserProfileViewModel</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JUnit</a> .      , <code>UserRepository</code> . </li><li> <b>UserRepository:</b>     <code>UserRepository</code>    JUnit.    <code>Webservice</code>  <code>UserDao</code> .      : <br><br><ul><li>     -. </li><li>      . </li><li>     ,     . </li></ul><br></li><li>   <code>Webservice</code> ,  <code>UserDao</code>  ,             . </li><li> <b>UserDao:</b>   DAO    .       -   ,   .        ,  ,      ,        … <br><br> <i><b>:</b> Room     ,    DAO,   JSQL  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SupportSQLiteOpenHelper</a></b> .     ,      SQLite     SQLite   .</i> </li><li> <b>-:</b>         .   ,  -,      .  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://github.com/square/ok">MockWebServer</a> ,          . </li><li> <b> :</b>     maven    .    <code>androidx.arch.core</code> :    JUnit: <br><br><ul><li> <code>InstantTaskExecutorRule:</code>            . </li><li> <code>CountingTaskExecutorRule:</code>         .        Espresso     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </li></ul><br></li></ul><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A programação é um campo criativo e a criação de aplicativos Android não é exceção. Existem várias maneiras de resolver o problema, seja transferir dados entre várias ações ou fragmentos, recuperar dados excluídos e armazená-los localmente offline, ou qualquer número de outros cenários comuns encontrados por aplicativos não triviais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora as recomendações a seguir não sejam necessárias, nossa experiência mostra que sua implementação torna sua base de código mais confiável, testável e suportada a longo prazo: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite designar os pontos de entrada do seu aplicativo - como ações, serviços e receptores de transmissão - como fontes de dados.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez disso, eles só precisam se coordenar com outros componentes para obter um subconjunto dos dados relacionados a esse ponto de entrada. Cada componente do aplicativo é de curta duração, dependendo da interação do usuário com seu dispositivo e do estado atual geral do sistema. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie linhas de responsabilidade claras entre os vários módulos do seu aplicativo.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por exemplo, não distribua código que baixa dados da rede para várias classes ou pacotes em sua base de códigos. Da mesma forma, não defina várias responsabilidades não relacionadas - como cache de dados e ligação de dados - na mesma classe. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exponha o mínimo possível de cada módulo.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resista à tentação de criar um rótulo “apenas um” que revele os detalhes de uma implementação interna de um módulo. Você pode ganhar algum tempo no curto prazo, mas terá uma dívida técnica muitas vezes à medida que sua base de código se desenvolver. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pense em como tornar cada módulo testável isoladamente.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por exemplo, ter uma API bem definida para recuperar dados da rede facilita o teste de um módulo que armazena esses dados em um banco de dados local. Se, em vez disso, você misturar a lógica desses dois módulos em um único local ou distribuir seu código de rede por toda a base de códigos, o teste se tornará muito mais difícil - em alguns casos, nem mesmo impossível. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concentre-se no núcleo exclusivo do seu aplicativo para se destacar de outros aplicativos.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não reinvente a roda escrevendo o mesmo padrão repetidamente. Em vez disso, concentre seu tempo e energia no que torna seu aplicativo único e deixe que os componentes da arquitetura Android e outras bibliotecas recomendadas lidem com um padrão repetitivo. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mantenha o máximo possível de dados relevantes e atualizados.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assim, os usuários podem aproveitar a funcionalidade do seu aplicativo, mesmo que o dispositivo esteja offline. Lembre-se de que nem todos os usuários usam uma conexão constante de alta velocidade. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designe uma única fonte de dados como a única fonte verdadeira.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sempre que seu aplicativo precisar acessar esses dados, sempre deve vir dessa fonte única de verdade.</font></font><br><br><h3> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adendo: divulgação do status da rede</font></font></u> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na seção acima da arquitetura de aplicativo recomendada, ignoramos erros de rede e estados de inicialização para simplificar trechos de código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta seção mostra como exibir o status da rede usando a classe Resource, que encapsula os dados e seu estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O seguinte snippet de código fornece um exemplo de implementação</font></font><code>Resource:</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         . sealed class Resource&lt;T&gt;( val data: T? = null, val message: String? = null ) { class Success&lt;T&gt;(data: T) : Resource&lt;T&gt;(data) class Loading&lt;T&gt;(data: T? = null) : Resource&lt;T&gt;(data) class Error&lt;T&gt;(message: String, data: T? = null) : Resource&lt;T&gt;(data, message) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o download de dados da rede ao exibir uma cópia desses dados é uma prática comum, é útil criar uma classe auxiliar que possa ser reutilizada em vários locais. Para este exemplo, nós criamos uma classe chamada </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O diagrama a seguir mostra a árvore de decisão para </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/e1/wv/c9/e1wvc9un_w2t8jyi0kiky8wagw0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Começa observando o banco de dados do recurso. Quando um registro é baixado do banco de dados pela primeira vez, ele </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verifica se o resultado é bom o suficiente para ser enviado ou se precisa ser recuperado da rede. Observe que essas duas situações podem ocorrer simultaneamente, já que você provavelmente deseja mostrar dados em cache ao atualizá-los da rede.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se a chamada de rede for bem-sucedida, ela armazena a resposta no banco de dados e reinicializa o fluxo. No caso de uma </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falha na </font><font style="vertical-align: inherit;">solicitação de rede </font><font style="vertical-align: inherit;">, ela envia a falha diretamente. </font></font><br><br> <code><b>.</b>             .       ,       .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que confiar em um banco de dados para enviar alterações envolve o uso de efeitos colaterais relacionados, o que não é muito bom, pois o comportamento indefinido desses efeitos colaterais pode ocorrer se o banco de dados não enviar as alterações porque os dados não foram alterados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, não envie resultados recebidos da rede, pois isso viola o princípio de uma única fonte de verdade. </font><font style="vertical-align: inherit;">No final, é possível que o banco de dados contenha gatilhos que alterem os valores dos dados durante a operação de salvamento. </font><font style="vertical-align: inherit;">Da mesma forma, não envie `SUCESSO` sem novos dados, pois o cliente receberá a versão incorreta dos dados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O seguinte snippet de código mostra a API aberta fornecida pela classe </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para suas subclasses:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ResultType:   . // RequestType:   API. abstract class NetworkBoundResource&lt;ResultType, RequestType&gt; { //      API   . @WorkerThread protected abstract fun saveCallResult(item: RequestType) //      ,  ,    //     . @MainThread protected abstract fun shouldFetch(data: ResultType?): Boolean //        . @MainThread protected abstract fun loadFromDb(): LiveData&lt;ResultType&gt; //     API. @MainThread protected abstract fun createCall(): LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; // ,    .   //    ,    . protected open fun onFetchFailed() {} //   LiveData,  , //    . fun asLiveData(): LiveData&lt;ResultType&gt; = TODO() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preste atenção aos seguintes detalhes importantes da definição de classe: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele define dois parâmetros de tipo </font></font><code>ResultType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">, </font></font><code>RequestType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como o tipo de dados retornado da API pode não corresponder ao tipo de dados usado localmente.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele usa uma classe </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para solicitações de rede. </font></font><code>ApiResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É um invólucro simples para uma classe </font></font><code>Retrofit2.Call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que converte respostas em instâncias </font></font><code>LiveData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A implementação completa da classe </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aparece como parte do projeto </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub android-Architecture-components</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma vez criado, </font></font><code>NetworkBoundResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos usá-lo para escrever nossas implementações de disco e conectadas à rede </font></font><code>User</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na classe </font></font><code>UserRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  Dagger2,         . @Singleton class UserRepository @Inject constructor( private val webservice: Webservice, private val userDao: UserDao ) { fun getUser(userId: String): LiveData&lt;User&gt; { return object : NetworkBoundResource&lt;User, User&gt;() { override fun saveCallResult(item: User) { userDao.save(item) } override fun shouldFetch(data: User?): Boolean { return rateLimiter.canFetch(userId) &amp;&amp; (data == null || !isFresh(data)) } override fun loadFromDb(): LiveData&lt;User&gt; { return userDao.load(userId) } override fun createCall(): LiveData&lt;ApiResponse&lt;User&gt;&gt; { return webservice.getUser(userId) } }.asLiveData() } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456256/">https://habr.com/ru/post/pt456256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456240/index.html">Desenvolvimento de chatbot (laravel + botman)</a></li>
<li><a href="../pt456242/index.html">Um pouco mais sobre multitarefa em microcontroladores</a></li>
<li><a href="../pt456246/index.html">Elemento zero</a></li>
<li><a href="../pt456248/index.html">Como eu peguei: antes de estilos para um elemento de foco</a></li>
<li><a href="../pt456250/index.html">Localização de aplicativos e suporte a RTL. Relatório Yandex.Taxi</a></li>
<li><a href="../pt456258/index.html">Livre como um vento e livre como uma tradução de cerveja de "Livre como na liberdade" para o russo sob a licença GNU FDL 1.3</a></li>
<li><a href="../pt456260/index.html">Conversa sobre economia justa</a></li>
<li><a href="../pt456262/index.html">Rádio definido por software - como funciona? Parte 9</a></li>
<li><a href="../pt456264/index.html">Crie arquivos binários do Android usando o NDK do Android e de origem. Desenvolvemos o utilitário screencap</a></li>
<li><a href="../pt456266/index.html">O resumo de materiais interessantes para o desenvolvedor móvel 302 (de 10 a 16 de junho)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>