<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèº üë®‚Äçüíª üôèüèΩ Tipos dependientes de Haskell: ¬øpor qu√© es el futuro del desarrollo de software? üò¨ ‚úîÔ∏è üóìÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En Serokell, no solo nos dedicamos a proyectos comerciales, sino que tambi√©n nos esforzamos por mejorar el mundo. Por ejemplo, estamos trabajando para...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos dependientes de Haskell: ¬øpor qu√© es el futuro del desarrollo de software?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p> En Serokell, no solo nos dedicamos a proyectos comerciales, sino que tambi√©n nos esforzamos por mejorar el mundo.  Por ejemplo, estamos trabajando para mejorar la herramienta principal de todos los Haskelists: el Glasgow Haskell Compiler (GHC).  Nos centramos en ampliar el sistema de tipos bajo la influencia del trabajo de Richard Eisenberg, <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"Tipos dependientes en Haskell: teor√≠a y pr√°ctica"</a> . </p><br><p>  En <a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">nuestro blog,</a> Vladislav ya habl√≥ sobre por qu√© Haskell carece de tipos dependientes y c√≥mo planeamos agregarlos.  Decidimos traducir esta publicaci√≥n al ruso para que tantos desarrolladores como sea posible pudieran usar tipos dependientes y hacer una contribuci√≥n adicional al desarrollo de Haskell como idioma. </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del">  Estado actual de las cosas </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="Algoritmo de selecci√≥n del lenguaje de programaci√≥n"></p><br><p>  Los tipos dependientes son lo que m√°s extra√±o en Haskell.  Discutamos por qu√©.  Del c√≥digo que queremos: </p><br><ul><li>  rendimiento, es decir, velocidad de ejecuci√≥n y bajo consumo de memoria; </li><li>  mantenibilidad y facilidad de comprensi√≥n; </li><li>  correcci√≥n garantizada por el m√©todo de compilaci√≥n. </li></ul><br><p>  Con las tecnolog√≠as existentes, rara vez es posible lograr las tres caracter√≠sticas, pero con el soporte para los tipos dependientes de Haskell, la tarea se simplifica. </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Haskell Standard: Ergonom√≠a + Rendimiento </h2><br><p>  Haskell se basa en un sistema simple: un c√°lculo lambda polim√≥rfico con c√°lculos perezosos, tipos de datos algebraicos y clases de tipos.  Es esta combinaci√≥n de caracter√≠sticas del lenguaje la que nos permite escribir c√≥digo elegante, compatible y al mismo tiempo productivo.  Para fundamentar esta afirmaci√≥n, comparamos brevemente Haskell con idiomas m√°s populares. </p><br><p>  Los lenguajes con acceso inseguro a la memoria, como C, conducen a los errores y vulnerabilidades m√°s graves (por ejemplo, desbordamientos de b√∫fer, p√©rdidas de memoria).  A veces se necesitan tales lenguajes, pero la mayor√≠a de las veces su uso es una idea m√°s o menos. </p><br><p>  Los lenguajes de acceso a la memoria segura forman dos grupos: aquellos que dependen del recolector de basura y Rust.  Rust parece ser √∫nico en ofrecer <a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">acceso seguro a la memoria sin recolecci√≥n de basura</a> .  Tampoco se admiten Cyclone y otros lenguajes de investigaci√≥n en este grupo.  Pero a diferencia de ellos, Rust est√° en camino a la popularidad.  La desventaja es que, a pesar de la seguridad, la administraci√≥n de memoria de Rust no es trivial y manual.  En aplicaciones que pueden permitirse el uso del recolector de basura, es mejor pasar el tiempo de los desarrolladores en otras tareas. </p><br><p>  Quedan idiomas con los recolectores de basura, que dividiremos en dos categor√≠as seg√∫n su sistema de tipos. </p><br><p>  Los lenguajes de tipo din√°mico (o m√°s bien <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">monotipados</a> ), como JavaScript o Clojure, no proporcionan un an√°lisis est√°tico y, por lo tanto, no pueden proporcionar el mismo nivel de confianza en la correcci√≥n del c√≥digo (y no, las pruebas no pueden reemplazar los tipos; necesita ambos) !). </p><br><p>  Los lenguajes de tipo est√°tico como Java o Go a menudo tienen un sistema de tipos muy limitado.  Esto obliga a los programadores a escribir c√≥digo redundante y poner caracter√≠sticas de lenguaje inseguras.  Por ejemplo, la falta de tipos gen√©ricos en Go obliga al uso de la <a href="https://tour.golang.org/methods/14" rel="nofollow">interfaz {}</a> y la <a href="https://golang.org/ref/spec" rel="nofollow">conversi√≥n de tipos de tiempo de ejecuci√≥n</a> .  Tampoco hay separaci√≥n entre los c√°lculos con efectos secundarios (entrada, salida) y los c√°lculos puros. </p><br><p>  Finalmente, entre los idiomas con acceso seguro a la memoria, un recolector de basura y un potente sistema de tipos, Haskell destaca por la pereza.  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">La computaci√≥n diferida es</a> extremadamente √∫til para escribir c√≥digo composable y modular.  Permiten descomponer en definiciones auxiliares cualquier parte de las expresiones, incluidas las construcciones que definen un flujo de control. </p><br><p>  Haskell parece un lenguaje casi perfecto hasta que te das cuenta de cu√°n lejos est√° de liberar todo su potencial en t√©rminos de verificaci√≥n est√°tica en comparaci√≥n con las herramientas de prueba de teoremas como <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda</a> . </p><br><p> Como un ejemplo simple de d√≥nde el sistema de tipo Haskell no es lo suficientemente potente, considere el operador de <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">indexaci√≥n de lista</a> de <code>Prelude</code> (o <a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">indexar una matriz</a> de un paquete <code>primitive</code> ): </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p>  Nada en estas firmas tipo refleja el requisito de que el √≠ndice debe ser no negativo y menor que la longitud de la colecci√≥n.  Para software con requisitos de alta confiabilidad esto es inaceptable. </p><br><h2 id="agda-ergonomika--korrektnost">  Agda: ergonom√≠a + correcci√≥n </h2><br><p>  Los medios de prueba de teoremas (por ejemplo, <a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ) son herramientas de software que permiten usar una computadora para desarrollar pruebas formales de teoremas matem√°ticos.  Para un matem√°tico, usar tales herramientas es como escribir evidencia en papel.  La diferencia en el rigor sin precedentes requerido por una computadora para establecer la validez de dicha evidencia. </p><br><p>  Para el programador, sin embargo, los medios para probar los teoremas no son tan diferentes del compilador para el lenguaje de programaci√≥n esot√©rico con un sistema de tipo incre√≠ble (y posiblemente un entorno de desarrollo integrado) y mediocre (o incluso ausente) todo lo dem√°s.  Una forma de probar los teoremas es, de hecho, los lenguajes de programaci√≥n, cuyos autores dedicaron todo su tiempo a desarrollar un sistema de mecanograf√≠a y olvidaron que los programas a√∫n deben ejecutarse. </p><br><p>  El preciado sue√±o de los desarrolladores de software verificados es un medio de probar teoremas, que ser√≠a un buen lenguaje de programaci√≥n con generador de c√≥digo y tiempo de ejecuci√≥n de alta calidad.  En esta direcci√≥n, incluidos los creadores de <a href="https://www.idris-lang.org/" rel="nofollow">Idris</a> experimentaron.  Pero este es un lenguaje con c√°lculos estrictos (en√©rgicos), y su implementaci√≥n en este momento no es estable. </p><br><p>  Entre todos los medios para probar los teoremas, los Haskelistas de Agda son de su agrado.  En muchos sentidos, es similar a Haskell, pero con un sistema de tipos m√°s potente.  En Serokell lo usamos para probar las diversas propiedades de nuestros programas.  Mi colega Dania Rogozin escribi√≥ una <a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">serie de art√≠culos</a> sobre esto. </p><br><p>  Aqu√≠ hay un tipo de funci√≥n de <a href="" rel="nofollow">b√∫squeda</a> similar al operador de Haskell <code>(!!)</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ‚àÄ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p>  El primer par√°metro aqu√≠ es de tipo <code>List A</code> , que corresponde a <code>[a]</code> en Haskell.  Sin embargo, le damos el nombre <code>xs</code> para referirnos al resto de la firma de tipo.  En Haskell, podemos acceder a los argumentos de la funci√≥n solo en el cuerpo de la funci√≥n en el nivel de t√©rmino: </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p>  Pero en Agda, podemos referirnos a este valor <code>xs</code> en el nivel de tipo, lo que hacemos en el segundo par√°metro de <code>lookup</code> , <code>Fin (length xs)</code> .  Una funci√≥n que se refiere a su par√°metro en el nivel de tipo se denomina <em>funci√≥n dependiente</em> y es un ejemplo de tipos dependientes. </p><br><p>  El segundo par√°metro en la <code>lookup</code> es del tipo <code>Fin n</code> para <code>n ~ length xs</code> .  Un valor de tipo <code>Fin n</code> corresponde a un n√∫mero en el rango <code>[0, n)</code> , por lo que <code>Fin (length xs)</code> es un n√∫mero no negativo menor que la longitud de la lista de entrada.  Esto es exactamente lo que necesitamos para presentar un √≠ndice v√°lido de un elemento de la lista.  En t√©rminos generales, la <code>lookup ["x","y","z"] 2</code> pasar√° la verificaci√≥n de tipo, pero la <code>lookup ["x","y","z"] 42</code> fallar√°. </p><br><p>  Cuando se trata de ejecutar programas Agda, podemos compilarlos en Haskell utilizando el <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">backend</a> MAlonzo.  Pero el rendimiento del c√≥digo generado ser√° insatisfactorio.  Esto no es culpa de MAlonzo: tiene que insertar numerosos <code>unsafeCoerce</code> para que el GHC <code>unsafeCoerce</code> c√≥digo ya verificado por Agda.  Pero el mismo <code>unsafeCoerce</code> <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">reduce el rendimiento</a> <em>(despu√©s de la discusi√≥n de este art√≠culo, result√≥ que los problemas de rendimiento pueden haber sido causados ‚Äã‚Äãpor otras razones: nota del autor)</em> . </p><br><p>  Esto nos coloca en una posici√≥n dif√≠cil: tenemos que usar Agda para el modelado y la verificaci√≥n formal, y luego volver a implementar la misma funcionalidad en Haskell.  Con esta organizaci√≥n de flujos de trabajo, nuestro c√≥digo Agda act√∫a como una especificaci√≥n verificada por computadora.  Esto es mejor que la especificaci√≥n en lenguaje natural, pero lejos de ser ideal.  El objetivo es que si se compila el c√≥digo, funcionar√° de acuerdo con la especificaci√≥n. </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost">  Haskell con extensiones: correcci√≥n + rendimiento </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p>  Con el objetivo de obtener garant√≠as est√°ticas de idiomas con tipos dependientes, GHC ha recorrido un largo camino.  Se le agregaron extensiones para aumentar la expresividad del sistema de tipos.  Empec√© a usar Haskell cuando GHC 7.4 era la √∫ltima versi√≥n del compilador.  Incluso entonces, ten√≠a las extensiones principales para la programaci√≥n avanzada a nivel de tipo: <code>RankNTypes</code> , <code>GADTs</code> , <code>TypeFamilies</code> , <code>DataKinds</code> y <code>PolyKinds</code> . </p><br><p>  Sin embargo, todav√≠a no hay tipos dependientes completos en Haskell: ni funciones dependientes (tipos Œ†) ni pares dependientes (tipos Œ£).  Por otro lado, ¬°al menos tenemos una codificaci√≥n para ellos! </p><br><p>  Las pr√°cticas actuales son las siguientes: </p><br><ul><li>  codificar funciones de nivel de tipo como familias de tipos privadas, </li><li>  utilizar funcionalizaci√≥n para habilitar funciones no saturadas, </li><li>  cerrar la brecha entre t√©rminos y tipos utilizando tipos √∫nicos. </li></ul><br><p>  Esto conduce a una cantidad significativa de c√≥digo redundante, pero la biblioteca de <code>singletons</code> automatiza su generaci√≥n a trav√©s de Template Haskell. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p>  Entonces, el m√°s atrevido y decisivo puede codificar tipos dependientes en Haskell en este momento.  Como demostraci√≥n, aqu√≠ hay una implementaci√≥n de la funci√≥n de <code>lookup</code> similar a la variante en Agda: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p>  Y aqu√≠ hay una sesi√≥n de GHCi que muestra que las b√∫squedas de hecho rechazan los √≠ndices que son demasiado grandes: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: ‚Ä¢ Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) ‚Ä¢ In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p>  Este ejemplo muestra que la viabilidad no significa pr√°ctica.  Me alegra que Haskell tenga capacidades de lenguaje para implementar <code>lookupS</code> , pero al mismo tiempo me preocupa la complejidad innecesaria que surge.  Fuera de los proyectos de investigaci√≥n, no recomendar√≠a ese estilo de c√≥digo. </p><br><p>  En este caso particular, podr√≠amos lograr el mismo resultado con menos complejidad usando vectores indexados en longitud.  Sin embargo, la traducci√≥n directa de c√≥digo de Agda revela mejor los problemas que debe tener en otras circunstancias. </p><br><p>  Aqu√≠ hay algunos de ellos: </p><br><ul><li>  La relaci√≥n de escritura <code>a :: t</code> y la relaci√≥n de destino de la forma <code>t :: k</code> diferentes.  <code>5 :: Integer</code> es verdadero en t√©rminos, pero no en tipos.  <code>"hi" :: Symbol</code> es verdadero en tipos, pero no en t√©rminos.  Esto requiere que la <code>Demote</code> tipos <code>Demote</code> vistas y tipos. </li><li>  La biblioteca est√°ndar usa <code>Int</code> como una representaci√≥n de √≠ndices de lista (y los <code>singletons</code> usan <code>Nat</code> en definiciones elevadas).  <code>Int</code> y <code>Nat</code> son tipos no inductivos.  A pesar de ser m√°s eficientes que la codificaci√≥n unaria de n√∫meros naturales, no funcionan muy bien con definiciones inductivas como <code>Fin</code> o <code>lookupS</code> .  Debido a esto, redefinimos la <code>length</code> como <code>len</code> . </li><li>  Haskell no tiene mecanismos incorporados para elevar las funciones al nivel de tipos.  <code>singletons</code> codifica como familias de tipos privados y aplica la funcionalizaci√≥n para evitar la falta de uso parcial de las familias de tipos.  Esta codificaci√≥n es complicada.  Adem√°s, tuvimos que poner la definici√≥n de <code>len</code> en una cita de Template Haskell para que los <code>singletons</code> generen su contraparte de nivel de tipo, <code>Len</code> . </li><li>  No hay funciones dependientes incorporadas.  Uno tiene que usar <a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">tipos de unidades</a> para cerrar la brecha entre t√©rminos y tipos.  En lugar de la lista habitual, pasamos <code>SList</code> a <code>lookupS</code> .  Por lo tanto, debemos tener en cuenta varias definiciones de listas a la vez.  Tambi√©n conduce a gastos generales durante la ejecuci√≥n del programa.  Surgen debido a la conversi√≥n entre valores ordinarios y valores de tipos de unidades ( <code>toSing</code> , <code>fromSing</code> ) y debido a la transferencia del procedimiento de conversi√≥n (restricci√≥n <code>SingKind</code> ). </li></ul><br><p>  La inconveniencia es el problema menor.  Peor a√∫n, estas caracter√≠sticas del lenguaje no son confiables.  Por ejemplo, inform√© el problema <a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow"># 12564</a> en 2016, y tambi√©n hay <a href="https://gitlab.haskell.org/ghc/ghc/issues/12088" rel="nofollow"># 12088 del</a> mismo a√±o.  Ambos problemas dificultan la implementaci√≥n de programas m√°s avanzados que los ejemplos de los libros de texto (como las listas de indexaci√≥n).  Estos errores de GHC todav√≠a no est√°n corregidos, y la raz√≥n, me parece, es que los desarrolladores simplemente no tienen suficiente tiempo.  El n√∫mero de personas que trabajan activamente en el GHC es sorprendentemente peque√±o, por lo que algunas cosas no se mueven. </p><br><h2 id="rezyume">  Resumen </h2><br><p>  Mencion√© anteriormente que queremos las tres propiedades del c√≥digo, as√≠ que aqu√≠ hay una tabla que ilustra el estado actual de las cosas: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Haskell est√°ndar </th><th>  Agda </th><th>  Haskell con extensiones </th></tr></thead><tbody><tr><td>  Ergonom√≠a y mantenibilidad </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>  Rendimiento </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Correcci√≥n garantizada por el m√©todo de dibujo. </td><td>  - </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee">  Futuro brillante </h1><br><p>  De las tres opciones disponibles, cada una tiene sus inconvenientes.  Sin embargo, podemos solucionarlos: </p><br><ul><li>  Tome el est√°ndar Haskell y agregue tipos dependientes directamente en lugar de una codificaci√≥n inc√≥moda mediante <code>singletons</code> .  (Es m√°s f√°cil decirlo que hacerlo). </li><li>  Tome Agda e implemente un generador de c√≥digo eficiente y RTS para ello.  (Es m√°s f√°cil decirlo que hacerlo). </li><li>  Tome Haskell con extensiones, corrija errores y contin√∫e agregando nuevas extensiones para simplificar la codificaci√≥n de los tipos dependientes.  (Es m√°s f√°cil decirlo que hacerlo). </li></ul><br><p>  La buena noticia es que las tres opciones convergen en un punto (en cierto sentido).  Imagine la extensi√≥n m√°s peque√±a del est√°ndar Haskell que agrega tipos dependientes y, por lo tanto, le permite garantizar la exactitud del c√≥digo por la forma en que est√° escrito.  El c√≥digo de Agda se puede compilar (transponer) a este idioma sin <code>unsafeCoerce</code> .  Y Haskell con extensiones es, en cierto sentido, un prototipo inacabado de este lenguaje.  Algo necesita ser mejorado, y algo necesita ser eliminado, pero al final, lograremos el resultado deseado. </p><br><h2 id="izbavlenie-ot-singletons">  Deshacerse de los <code>singletons</code> </h2><br><p>  Un buen indicador de progreso es la simplificaci√≥n de la biblioteca de <code>singletons</code> .  Como los tipos dependientes se implementan en Haskell, ya no se necesitan soluciones y manejo especial de casos especiales implementados en <code>singletons</code> .  Finalmente, la necesidad de este paquete desaparecer√° por completo.  Por ejemplo, en 2016, usando la extensi√≥n <code>-XTypeInType</code> <code>SingKind</code> <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">KProxy</a> de <code>SingKind</code> y <code>SomeSing</code> .  Este cambio fue posible gracias a la uni√≥n de tipos y tipos.  Compare definiciones antiguas y nuevas: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  En las definiciones anteriores, <code>k</code> aparece exclusivamente en las posiciones de vista, a la derecha de las anotaciones de la forma <code>t :: k</code> .  Usamos <code>kparam :: KProxy k</code> para transferir <code>k</code> a los tipos. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  En las nuevas definiciones, <code>k</code> mueve libremente entre las vistas y las posiciones de tipo, por lo que ya no necesitamos <code>KProxy</code> .  La raz√≥n es que, comenzando con GHC 8.0, los tipos y tipos entran en la misma categor√≠a sint√°ctica. </p><br><p>  Hay tres mundos completamente separados en Haskell est√°ndar: t√©rminos, tipos y vistas.  Si mira el c√≥digo fuente de GHC 7.10, puede ver un <a href="" rel="nofollow">analizador</a> separado para las vistas y una <a href="" rel="nofollow">verificaci√≥n por</a> separado.  GHC 8.0 ya no los tiene: el <a href="" rel="nofollow">analizador</a> y la <a href="" rel="nofollow">validaci√≥n</a> de tipos y vistas son comunes. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p>  En Haskell con extensiones, la vista es solo el rol en el que se encuentra el tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p>  En GHC 8.0‚Äì8.4, todav√≠a hab√≠a algunas diferencias entre la resoluci√≥n de nombres en tipos y tipos.  Pero los minimic√© a GHC 8.6: cre√© la extensi√≥n <code>StarIsType</code> e introduje la funcionalidad <code>PolyKinds</code> en <code>PolyKinds</code> .  Hice <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">las</a> diferencias restantes como una <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">advertencia</a> para GHC 8.8, y las elimin√© por <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">completo</a> en GHC 8.10 (la <em>traducci√≥n de este p√°rrafo se ha actualizado, en el original el trabajo realizado se describe como tareas futuras - nota del autor</em> ). </p><br><p>  ¬øCu√°l es el siguiente paso?  Echemos un vistazo a <code>SingKind</code> en la √∫ltima versi√≥n de <code>singletons</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  La <code>Demote</code> tipo <code>Demote</code> necesaria para tener en cuenta las discrepancias entre la relaci√≥n de escritura <code>a :: t</code> la relaci√≥n de destino de la forma <code>t :: k</code> .  Con mayor frecuencia (para tipos de datos algebraicos), <code>Demote</code> es un mapeo de identidad: </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p>  Por lo tanto, <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> .  Esta observaci√≥n nos lleva a hacer la siguiente simplificaci√≥n: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p>  <code>Demote</code> necesario <code>Demote</code> !  Y, de hecho, esto funcionar√≠a tanto con <code>Either [Bool] Bool</code> como con otros tipos de datos algebraicos.  En la pr√°ctica, sin embargo, estamos tratando con tipos de datos no algebraicos: <code>Integer,</code> <code>Natural</code> , <code>Char</code> , <code>Text</code> , etc.  Si se usan como especies, no est√°n pobladas: <code>1 :: Natural</code> es cierto a nivel de t√©rminos, pero no a nivel de tipos.  Debido a esto, estamos tratando con tales definiciones: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p>  La soluci√≥n a este problema es criar tipos primitivos.  Por ejemplo, el <code>Text</code> define as√≠: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p>  Si elevamos adecuadamente <code>ByteArray#</code> e <code>Int#</code> al nivel de tipos, podemos usar <code>Text</code> lugar de <code>Symbol</code> .  Al hacer lo mismo con <code>Natural</code> y posiblemente un par de otros tipos, puede deshacerse de <code>Demote</code> , ¬øverdad? </p><br><p>  Por desgracia, no es as√≠.  En lo anterior, hice la vista gorda al tipo de datos m√°s importante: funciones.  Tambi√©n tienen una instancia especial de <code>Demote</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code> este es un tipo con el que las funciones de nivel de tipo se codifican en singletons basadas en <a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">funcionalidades</a> y familias de tipos privados. </p><br><p>  Al principio, puede parecer una buena idea combinar <code>~&gt;</code> y <code>-&gt;</code> , ya que ambos significan el tipo (tipo) de la funci√≥n.  El problema es que <code>-&gt;</code> en la posici√≥n de tipo y <code>-&gt;</code> en la posici√≥n de vista significan cosas diferentes.  En el nivel de t√©rmino, todas las funciones de <code>a</code> a <code>b</code> son de tipo <code>a -&gt; b</code> .  En el nivel de tipo, solo los <em>constructores</em> de <code>a</code> a <code>b</code> son de tipo <code>a -&gt; b</code> , pero no son sin√≥nimos de tipos ni familias de tipos.  Para deducir los tipos, GHC supone que <code>f ~ g</code> <code>a ~ b</code> derivan de <code>fa ~ gb</code> , lo cual es cierto para los constructores, pero no para las funciones; es por eso que hay una restricci√≥n. </p><br><p>  Por lo tanto, para elevar las funciones al nivel de tipos, pero para preservar la inferencia de tipos, tendremos que mover los constructores a un tipo separado.  Lo llamamos <code>a :-&gt; b</code> , porque realmente ser√° cierto que <code>f ~ g</code> <code>a ~ b</code> siguen de <code>fa ~ gb</code> .  Otras funciones seguir√°n siendo de tipo <code>a -&gt; b</code> .  Por ejemplo, <code>Just :: a :-&gt; Maybe a</code> , pero al mismo tiempo <code>isJust :: Maybe a -&gt; Bool</code> . </p><br><p>  Cuando <code>Demote</code> , el √∫ltimo paso es deshacerse de <code>Sing</code> .  Para hacer esto, necesitamos un nuevo cuantificador, un h√≠brido entre <code>forall</code> y <code>-&gt;</code> .  Echemos un vistazo m√°s de cerca a la funci√≥n isJust: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p>  La funci√≥n <code>isJust</code> parametriza con el tipo <code>a</code> y luego con el valor <code>x :: Maybe a</code> .  Estos dos par√°metros tienen propiedades diferentes: </p><br><ul><li>  Explicidad  En la <code>isJust (Just "hello")</code> , pasamos <code>x = Just "hello"</code> expl√≠citamente, y <code>a = String</code> es generado impl√≠citamente por el compilador.  En Haskell moderno, tambi√©n podemos forzar el paso expl√≠cito de ambos par√°metros: <code>isJust @String (Just "hello")</code> . </li><li>  Relevancia  El valor pasado a la entrada a <code>isJust</code> en el c√≥digo se transmitir√° durante la ejecuci√≥n del programa: realizamos una comparaci√≥n con la muestra usando <code>case</code> para verificar si es <code>Nothing</code> o <code>Just</code> .  Por lo tanto, el valor se considera relevante.  Pero su tipo se borra y no se puede comparar con el patr√≥n: la funci√≥n maneja <code>Maybe Int</code> , <code>Maybe String</code> , <code>Maybe Bool</code> , etc.  Por lo tanto, se considera irrelevante.  Esta propiedad tambi√©n se llama parametricidad. </li><li>  Adicci√≥n  En <code>forall a. t</code>  <code>forall a. t</code> , el tipo <code>t</code> puede referirse a <code>a</code> , y por lo tanto, depender del particular pasado <code>a</code> .  Por ejemplo, <code>isJust @String</code> es de tipo <code>Maybe String -&gt; Bool</code> , y <code>isJust @Int</code> es de tipo <code>Maybe Int -&gt; Bool</code> .  Esto significa que <code>forall</code> es un cuantificador dependiente.  Observe la diferencia con el par√°metro de valor: no importa si llamamos <code>isJust Nothing</code> o <code>isJust (Just ‚Ä¶)</code> , el tipo de resultado siempre es <code>Bool</code> .  Por lo tanto, <code>-&gt;</code> es un cuantificador independiente. </li></ul><br><p>  Para eliminar <code>Sing</code> , necesitamos un cuantificador expl√≠cito y relevante, como <code>a -&gt; b</code> , y al mismo tiempo dependiente, como <code>forall (a :: k). t</code>  <code>forall (a :: k). t</code> .  Denotelo como <code>foreach (a :: k) -&gt; t</code> .  Para eliminar <code>SingI</code> , tambi√©n presentamos un cuantificador dependiente relevante impl√≠cito, <code>foreach (a :: k). t</code>  <code>foreach (a :: k). t</code> .  Como resultado, los <code>singletons</code> no ser√°n necesarios ya que acabamos de agregar funciones dependientes al lenguaje. </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami">  Una breve mirada a Haskell con tipos dependientes </h2><br><p>  Con el aumento de las funciones al nivel de tipos y el cuantificador <code>foreach</code> , podemos reescribir las <code>lookupS</code> siguiente manera: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p>  En resumen, el c√≥digo no lo hizo, sin embargo, es bastante bueno para ocultar c√≥digo redundante.  Sin embargo, el nuevo c√≥digo es mucho m√°s simple: ya no hay <code>Demote</code> , <code>SingKind</code> , <code>SList</code> , <code>SNil</code> , <code>SCons</code> , <code>fromSing</code> .  No hay uso de <code>TemplateHaskell</code> , ya que ahora podemos llamar a la funci√≥n <code>len</code> directamente en lugar de crear la familia de tipos <code>Len</code> .  El rendimiento tambi√©n ser√° mejor, ya que ya no necesita convertir de <code>fromSing</code> . </p><br><p>  Todav√≠a tenemos que redefinir la <code>length</code> como <code>len</code> para devolver una <code>N</code> definida inductivamente en lugar de <code>Int</code> .  Quiz√°s este problema no deber√≠a considerarse en el marco de agregar tipos dependientes a Haskell, porque Agda tambi√©n usa un <code>N</code> definido inductivamente en la funci√≥n de <code>lookup</code> . </p><br><p>  En algunos aspectos, Haskell con tipos dependientes es incluso m√°s simple que Haskell est√°ndar.  A√∫n as√≠, en t√©rminos, los tipos y los tipos se combinan en un solo lenguaje uniforme.  Me puedo imaginar f√°cilmente escribir c√≥digo en este estilo en un proyecto comercial para probar formalmente la correcci√≥n de los componentes clave de las aplicaciones.  Muchas bibliotecas de Haskell pueden proporcionar interfaces m√°s seguras sin la complejidad de los <code>singletons</code> . </p><br><p>  Esto no ser√° f√°cil de lograr.  Nos enfrentamos a muchos problemas de ingenier√≠a que afectan a todos los componentes del GHC: un analizador, resoluci√≥n de nombres, verificaci√≥n de tipos e incluso el lenguaje Core.  Todo tendr√° que ser modificado, o incluso completamente redise√±ado. </p><br><hr><br><h1 id="tezaurus">  Report generator </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Plazo</strong> <br></td><td>  <strong>Traducci√≥n</strong> <br></td><td>  <strong>Explicaci√≥n</strong> <br></td></tr><tr><td> correct by construction <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     ¬´¬ª  ¬´¬ª,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a href="https://habr.com/ru/post/485174/">https://habr.com/ru/post/485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485158/index.html">Nikolay Vavilov. El hombre que quer√≠a alimentar al mundo entero y muri√≥ de hambre en una celda de la prisi√≥n.</a></li>
<li><a href="../485160/index.html">¬øQu√© es I en ACID o una perspectiva diferente?</a></li>
<li><a href="../485162/index.html">C√≥mo evolucionaron los comentarios de c√≥digo desde la d√©cada de 1940 hasta 2020</a></li>
<li><a href="../485164/index.html">Transformadores y odio en Vancouver: c√≥mo el antiplagio recorre el NeurIPS-2019</a></li>
<li><a href="../485172/index.html">Problemas de arquitectura en grandes proyectos</a></li>
<li><a href="../485176/index.html">Seis esquemas para ayudar a explicar los conceptos de gesti√≥n de productos.</a></li>
<li><a href="../485178/index.html">Metodolog√≠a para la reconstrucci√≥n de edificios perdidos a partir de fotograf√≠as.</a></li>
<li><a href="../485180/index.html">¬øNecesitamos un lago de datos? ¬øQu√© hacer con el almac√©n de datos?</a></li>
<li><a href="../485182/index.html">Sennheiser en 2020: auriculares inal√°mbricos actualizados para el aniversario</a></li>
<li><a href="../485184/index.html">Resultados de la encuesta con pesta√±as</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>