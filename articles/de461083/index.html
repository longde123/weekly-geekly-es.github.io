<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è ü¶á üë©üèø‚Äçüöí Schreiben von Software mit der Funktionalit√§t von Client-Server-Dienstprogrammen Windows, Teil 02 üåæ üë®üèæ‚Äçüè´ üêê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TFTP (Trivial File Transfer Protocol) ist ein einfaches Datei√ºbertragungsprotokoll, das die Artikelserie √ºber benutzerdefinierte Implementierungen von...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben von Software mit der Funktionalit√§t von Client-Server-Dienstprogrammen Windows, Teil 02</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461083/">  TFTP (Trivial File Transfer Protocol) ist ein einfaches Datei√ºbertragungsprotokoll, das die Artikelserie √ºber benutzerdefinierte Implementierungen von Konsolendienstprogrammen in Windows fortsetzt. <br><br>  Wie beim letzten Mal gehen wir kurz auf die Theorie ein, sehen uns einen Code an, der eine √§hnliche Funktion wie die erforderliche implementiert, und analysieren ihn.  Lesen Sie mehr - unter dem Schnitt <a name="habracut"></a><br><br>  Ich werde die Referenzinformationen, deren Links traditionell am Ende des Artikels zu finden sind, nicht kopieren und einf√ºgen. Ich m√∂chte nur sagen, dass TFTP im Wesentlichen eine vereinfachte Variante des FTP-Protokolls ist, bei dem die Zugriffssteuerungseinstellung entfernt wird. Tats√§chlich gibt es hier nichts au√üer den Befehlen zum Empfangen und √úbertragen der Datei .  Um unsere Implementierung jedoch etwas eleganter und an die aktuellen Prinzipien des Codeschreibens angepasst zu gestalten, wird die Syntax geringf√ºgig ge√§ndert - sie √§ndert nicht die Arbeitsprinzipien, aber die Schnittstelle IMHO wird etwas logischer und kombiniert die positiven Aspekte von FTP und TFTP. <br><br>  Insbesondere fragt der Client beim Start nach der IP-Adresse des Servers und dem Port, an dem benutzerdefiniertes TFTP ge√∂ffnet ist (aufgrund der Inkompatibilit√§t mit dem Standardprotokoll hielt ich es f√ºr angebracht, die Option zur Auswahl des Ports dem Benutzer zu √ºberlassen). Danach erfolgt eine Verbindung, √ºber die der Client einen der Befehle senden kann. abrufen oder ablegen, um eine Datei zu empfangen oder an den Server zu senden.  Alle Dateien werden im Bin√§rmodus gesendet - um die Logik zu vereinfachen. <br><br>  F√ºr die Implementierung des Protokolls habe ich traditionell 4 Klassen verwendet: <br><br><ul><li>  TFTPClient </li><li>  TFTPServer </li><li>  TFTPClientTester </li><li>  TFTPServerTester </li></ul><br>  Aufgrund der Tatsache, dass Testklassen nur zum Debuggen der Hauptklassen existieren, werde ich sie nicht analysieren, aber der Code befindet sich im Repository. Einen Link dazu finden Sie am Ende des Artikels.  Und jetzt werde ich die Hauptklassen verstehen. <br><br><h4>  TFTPClient </h4><br>  Die Aufgabe dieser Klasse besteht darin, √ºber ihre IP- und Portnummer eine Verbindung zum Remote-Server herzustellen, einen Befehl aus dem Eingabestream (in diesem Fall der Tastatur) zu lesen, ihn zu analysieren, auf den Server zu √ºbertragen und je nachdem, ob Sie die Datei √ºbertragen oder empfangen m√∂chten, sie zu √ºbertragen oder zu empfangen. <br><br>  Der Client-Startcode zum Herstellen einer Verbindung zum Server und zum Warten auf einen Befehl aus dem Eingabestream sieht folgenderma√üen aus.  Eine Reihe von globalen Variablen, die hier verwendet werden, werden au√üerhalb des Artikels im Volltext des Programms beschrieben.  Aufgrund ihrer Trivialit√§t zitiere ich nicht, um den Artikel nicht zu √ºberladen. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ip = ip; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { inicialization(); Scanner keyboard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scanner(System.in); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { getAndParseInput(keyboard); sendCommand(); selector(); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Lassen Sie uns die in diesem Codeblock aufgerufenen Methoden durchgehen: <br><br>  Hier wird die Datei gesendet. Mit dem Scanner pr√§sentieren wir den Inhalt der Datei als Array von Bytes, die wir nacheinander in den Socket schreiben, dann schlie√üen und erneut √∂ffnen (nicht die naheliegendste L√∂sung, aber die Freigabe von Ressourcen garantiert). Anschlie√üend wird eine Meldung √ºber den Erfolg angezeigt √úbertragung. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span><span class="hljs-function"> </span></span>{ File src = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(sourcePath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InputStream scanner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = scanner.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) sout.write(b); sout.close(); inicialization(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e.getMessage()); } }</code> </pre> <br>  Dieses Codefragment beschreibt den Empfang von Daten vom Server.  Alles ist wieder trivial, nur der erste Codeblock ist von Interesse.  Um genau zu verstehen, wie viele Bytes Sie aus dem Socket lesen m√ºssen, m√ºssen Sie wissen, wie viel die √ºbertragene Datei wiegt.  Die Dateigr√∂√üe auf dem Server scheint eine lange Ganzzahl zu sein, daher werden hier 4 Bytes akzeptiert, die anschlie√üend in eine einzelne Zahl konvertiert werden.  Dies ist kein sehr Java-Ansatz, er ist f√ºr SI ziemlich √§hnlich, aber er l√∂st sein Problem. <br><br>  Dann ist alles trivial - wir holen die bekannte Anzahl von Bytes aus dem Socket und schreiben sie in eine Datei, wonach wir eine Erfolgsmeldung anzeigen. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sourcePath, String destPath)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sizeOfFile = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sizeBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[Long.SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; Long.SIZE/Byte.SIZE; i++) { sizeBytes[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)sin.read(); sizeOfFile*=<span class="hljs-number"><span class="hljs-number">256</span></span>; sizeOfFile+=sizeBytes[i]; } FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i =<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sizeOfFile; i++) { writer.write(sin.read()); } writer.close(); System.out.println(<span class="hljs-string"><span class="hljs-string">"\nDONE\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  Wenn ein anderer Befehl als get oder put in das Client-Fenster eingegeben wurde, wird die Funktion showErrorMessage aufgerufen, die die Unrichtigkeit der Eingabe anzeigt.  Aus Trivialit√§t zitiere ich nicht.  Etwas interessanter ist die Funktion zum Abrufen und Teilen der Eingabezeichenfolge.  Wir √ºbergeben ihm einen Scanner, von dem wir eine durch zwei Leerzeichen getrennte Zeile erwarten, die einen Befehl, eine Quelladresse und eine Zieladresse enth√§lt. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndParseInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { input = scanner.nextLine().split(<span class="hljs-string"><span class="hljs-string">" "</span></span>); typeOfCommand = input[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sourcePath = input[<span class="hljs-number"><span class="hljs-number">1</span></span>]; destPath = input[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bad input"</span></span>); } }</code> </pre> <br>  Befehl senden - Senden des vom Scanner eingegebenen Befehls an den Socket und Erzwingen des Sendens <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : input) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch : str.toCharArray()) { sout.write(ch); } sout.write(<span class="hljs-string"><span class="hljs-string">' '</span></span>); } sout.write(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  Ein Selektor ist eine Funktion, die die Aktionen eines Programms abh√§ngig von der Eingabezeichenfolge bestimmt.  Hier ist nicht alles sehr sch√∂n und der nicht so gute Trick wird verwendet, um ihn zu zwingen, √ºber den Codeblock hinauszugehen, aber der Hauptgrund daf√ºr ist das Fehlen einiger Dinge in Java, wie Delegierte in C #, Zeiger auf eine Funktion aus C ++ oder zumindest be√§ngstigend und schrecklich lass es dich sch√∂n realisieren.  Wenn Sie wissen, wie Sie den Code etwas eleganter gestalten k√∂nnen, warte ich in den Kommentaren auf Kritik.  Es scheint mir, dass hier ein String-Delegate-W√∂rterbuch ben√∂tigt wird, aber es gibt keinen Delegaten ... <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">selector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"get"</span></span>)){ get(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeOfCommand.equals(<span class="hljs-string"><span class="hljs-string">"put"</span></span>)){ put(sourcePath, destPath); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } showErrorMessage(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre> <br><h4>  TFTPServer </h4><br>  Die Funktionalit√§t des Servers unterscheidet sich von der Funktionalit√§t des Clients im Gro√üen und Ganzen nur dadurch, dass die Befehle dazu nicht von der Tastatur, sondern vom Socket stammen.  Einige der Methoden stimmen √ºberein, daher werde ich sie nicht angeben. Ich werde nur die Unterschiede erw√§hnen. <br><br>  Zu Beginn wird hier die run-Methode verwendet, die einen Port f√ºr die Eingabe empf√§ngt und Eingabedaten vom Socket in einem ewigen Zyklus verarbeitet. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; incialization(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { getAndParseInput(); selector(); } }</code> </pre> <br>  Die put-Methode, ein Wrapper der writeToFileFromSocket-Methode, die den Schreibstrom in eine Datei √∂ffnet und nach Abschluss der Aufzeichnung alle Eingangsbytes aus dem Socket schreibt, zeigt eine Meldung √ºber den erfolgreichen Abschluss der √úbertragung an. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ writeToFileFromSocket(); System.out.print(<span class="hljs-string"><span class="hljs-string">"\nDone\n"</span></span>); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeToFileFromSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileOutputStream writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(destPath)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = sin.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : bytes) { writer.write(b); } writer.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } }</code> </pre> <br>  Die get-Methode stellt eine Serverdatei bereit.  Wie bereits im Abschnitt auf der Clientseite des Programms erw√§hnt, m√ºssen Sie zum erfolgreichen √úbertragen einer Datei ihre Gr√∂√üe kennen, die in einer langen Ganzzahl gespeichert ist. Daher habe ich sie in ein Array von 4 Bytes aufgeteilt, sie auf das Socket-Byte √ºbertragen und sie dann nach dem Empfang und Sammeln auf dem Client √ºbertragen Zur√ºck zur Nummer, ich √ºbertrage alle Bytes, aus denen die Datei besteht, aus dem Eingabestream aus der Datei. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String source, String dest)</span></span></span></span>{ File sending = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(source); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileInputStream readFromFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(sending); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arr = readFromFile.readAllBytes(); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(sending.length()).array(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Long.SIZE / Byte.SIZE; i++) sout.write(bytes[i]); sout.flush(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b : arr) sout.write(b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ System.out.println(e.getMessage()); } };</code> </pre> <br>  Die Methode getAndParseInput ist dieselbe wie im Client. Der einzige Unterschied besteht darin, dass Daten vom Socket und nicht von der Tastatur gelesen werden.  Der Code im Repository, wie Selektor. <br>  In diesem Fall erfolgt die Initialisierung in einem separaten Codeblock, weil  Im Rahmen dieser Implementierung werden nach Abschluss der √úbertragung die Ressourcen freigegeben und wieder belegt, um erneut vor Speicherlecks zu sch√ºtzen. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { serverSocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerSocket(port); socket = serverSocket.accept(); sin = socket.getInputStream(); sout = socket.getOutputStream(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.print(e.getMessage()); } }</code> </pre> <br>  Zusammenfassend: <br><br>  Wir haben gerade unsere Variante eines einfachen Daten√ºbertragungsprotokolls geschrieben und herausgefunden, wie es funktionieren soll.  Im Prinzip habe ich Amerika nicht entdeckt und nicht viel Neues geschrieben, aber - es gab keine √§hnlichen Artikel √ºber Habr√©, und als Teil des Schreibens einer Reihe von Artikeln √ºber cmd-Dienstprogramme war es unm√∂glich, ihn nicht zu ber√ºhren. <br><br>  Referenzen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode-Repository</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurz √ºber TFTP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Gleiche, aber auf Russisch</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461083/">https://habr.com/ru/post/de461083/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461073/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 3 - OverpassTurbo</a></li>
<li><a href="../de461075/index.html">Business Intelligence. IT-Objekte, Komponenten, Tools</a></li>
<li><a href="../de461077/index.html">Wie werden Pentester gekocht? Eingangstests f√ºr Praktikanten im Bereich digitale Sicherheit</a></li>
<li><a href="../de461079/index.html">Stadt ohne Stau</a></li>
<li><a href="../de461081/index.html">Der Tag, an dem Dodo aufgeh√∂rt hat. Asynchrones Skript</a></li>
<li><a href="../de461085/index.html">Wechseln Sie die Sprache in der Android App</a></li>
<li><a href="../de461087/index.html">Dungeons und H√∂hlen f√ºr mein Spiel generieren</a></li>
<li><a href="../de461091/index.html">LED Camelion Lampen</a></li>
<li><a href="../de461093/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 469 (07/09/2019 - 07/07/2019)</a></li>
<li><a href="../de461095/index.html">Apollo Guidance Computer - Architektur und Systemsoftware. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>