<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🖖🏿 👨🏾‍💻 WAL في PostgreSQL: 4. سجل الإعداد 🧑🏾‍🤝‍🧑🏽 🤠 🕴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لذلك ، تعرفنا على جهاز ذاكرة التخزين المؤقت المخزن المؤقت ، وباستخدام مثاله ، أدركنا أنه عندما يتم فقد محتويات ذاكرة الوصول العشوائي أثناء الفشل ، يلز...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL في PostgreSQL: 4. سجل الإعداد</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/" style=";text-align:right;direction:rtl">  لذلك ، تعرفنا على جهاز <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ذاكرة التخزين المؤقت المخزن المؤقت</a> ، وباستخدام مثاله ، أدركنا أنه عندما يتم فقد محتويات ذاكرة الوصول العشوائي أثناء الفشل ، يلزم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تسجيل سجل ما قبل الكتابة</a> لاستعادته.  يقتصر حجم ملفات السجل المطلوبة ووقت الاسترداد بسبب وجود <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">نقطة تفتيش يتم</a> تنفيذها بشكل دوري. <br><br>  في المقالات السابقة ، بحثنا بالفعل عددًا كبيرًا من الإعدادات المهمة المتعلقة بالمجلة بطريقة أو بأخرى.  في هذه المقالة (الأخيرة في هذه السلسلة) ، سننظر في مشكلات التوليف التي لم تتم مناقشتها بعد: مستويات السجل والغرض منها ، وكذلك موثوقية وأداء التسجيل. <br><br><h1 style=";text-align:right;direction:rtl">  مستويات السجل </h1><br>  الغرض الأساسي من سجل prerecord هو توفير القدرة على التعافي من الفشل.  ولكن ، إذا كنت لا تزال بحاجة إلى الاحتفاظ بجريدة ، فيمكن تكييفها مع مهام أخرى ، وإضافة قدر معين من المعلومات الإضافية إليها.  هناك عدة مستويات من قطع الأشجار.  يتم تعيينها بواسطة المعلمة <em>wal_level</em> ويتم تنظيمها بحيث يتضمن سجل كل مستوى تالي كل شيء يدخل في سجل المستوى السابق ، بالإضافة إلى شيء آخر جديد. <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  أدنى </h2><br>  يتم تعيين الحد الأدنى لمستوى ممكن من خلال القيمة <em>wal_level</em> = الحد الأدنى ويضمن فقط الانتعاش بعد الفشل.  لتوفير مساحة ، لا يتم تسجيل العمليات المتعلقة بمعالجة البيانات الجماعية (مثل CREATE TABLE AS SELECT أو CREATE INDEX).  بدلاً من ذلك ، تتم كتابة البيانات اللازمة على الفور على القرص ، ويتم إضافة كائن جديد إلى دليل النظام ويصبح مرئيًا عند الالتزام بالمعاملة.  في حالة حدوث عطل أثناء العملية ، تظل البيانات المسجلة بالفعل غير مرئية ولا تنتهك التناسق.  في حالة حدوث الفشل بعد اكتمال العملية ، فإن كل ما يلزم قد انتقل بالفعل إلى القرص ولا يحتاج إلى تسجيل. <br><br>  لنرى.  أولاً ، قم بتعيين المستوى المطلوب (لهذا ستحتاج أيضًا إلى تغيير معلمة أخرى - <em>max_wal_senders</em> ). <br><br><pre style=";text-align:right;direction:rtl"><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  لاحظ أن تغيير المستوى يتطلب إعادة تشغيل الخادم. <br><br>  تذكر الموضع الحالي في السجل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  الآن لنقم بإنشاء الجدول (CREATE TABLE AS SELECT) وكتابة الموضع في السجل مرة أخرى.  لا يهم مقدار البيانات المحددة بواسطة بيان SELECT في هذه الحالة ، لذلك سنقتصر على سطر واحد. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  باستخدام الأداة المساعدة المألوفة pg_waldump ، دعونا نلقي نظرة على إدخالات السجل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  بعض التفاصيل ، بالطبع ، قد تختلف من إطلاق إلى آخر ، ولكن في هذه الحالة ، هذا ما حدث.  يشير إدخال مدير Heap2 إلى التنظيف ، وهو عبارة عن تنظيف في الصفحة لأحد الجداول في كتالوج النظام (يمكن تمييز كائنات النظام بسهولة بالعين المجردة بواسطة الرقم "القصير" فيما يتعلق): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  ثم هناك سجل حول الحصول على OID التالي للجدول الذي سنقوم بإنشائه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  الآن إنشاء الفعلي للجدول: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  ومع ذلك ، لم يتم تسجيل إدخال البيانات في جدول.  ثم هناك العديد من الإدخالات حول إدراج صفوف في جداول وفهارس مختلفة - يسجل هذا PostgreSQL الجدول الذي تم إنشاؤه في دليل النظام (أعطيها في شكل مختصر): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  وأخيراً ، تثبيت المعاملة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2 style=";text-align:right;direction:rtl">  طبق الاصل </h2><br>  عندما نستعيد النظام من النسخة الاحتياطية ، نبدأ من حالة نظام الملفات وننقل البيانات تدريجياً إلى نقطة الاسترداد ، ونعيد تشغيل إدخالات دفتر اليومية المؤرشفة.  يمكن أن يكون عدد هذه السجلات كبيرًا للغاية (على سبيل المثال ، عدة أيام) ، أي أن فترة الاسترداد لن تغطي نقطة تحكم واحدة ، بل تغطي الكثير.  لذلك ، من الواضح أن الحد الأدنى لمستوى السجل لا يكفي - إذا لم يتم تسجيل بعض العمليات ، فلن نعرف ببساطة أنه يلزم تكرارها.  لاستعادة نسخة احتياطية ، يجب تسجيل <em>جميع</em> العمليات. <br><br>  وينطبق الشيء نفسه على النسخ المتماثل - لن يتم نقل أي شيء لم يتم تسجيله إلى النسخة المتماثلة ولن يتم إعادة إنتاجه.  ولكن إذا أردنا تنفيذ الطلبات على نسخة طبق الأصل ، فلا يزال الأمر معقدًا. <br><br>  أولاً ، نحتاج إلى معلومات حول الأقفال الحصرية التي تحدث على الخادم الأساسي ، حيث قد تتعارض مع الطلبات على النسخة المتماثلة.  يتم تسجيل هذه الأقفال وتطبيقها على النسخة المتماثلة (نيابة عن عملية بدء التشغيل). <br><br>  ثانياً ، يجب أن تكون قادرًا على إنشاء <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لقطات بيانات</a> ، ولهذا ، كما نذكر ، هناك حاجة إلى معلومات حول المعاملات الجارية.  في حالة النسخة المتماثلة ، نحن لا نتحدث فقط عن المعاملات المحلية ، ولكن أيضًا عن المعاملات على الخادم الرئيسي.  الطريقة الوحيدة لنقل هذه المعلومات هي كتابتها بشكل دوري إلى السجل (يحدث هذا كل 15 ثانية). <br><br>  يتم تعيين مستوى السجل ، الذي يضمن القدرة على الاسترداد من نسخة احتياطية وإمكانية النسخ المتماثل المادي ، بواسطة القيمة wal_level = <em>النسخة المتماثلة</em> .  (قبل الإصدار 9.6 ، كان هناك مستويان منفصلان للأرشيف و hot_byby ، ولكن بعد ذلك تم دمجهما في واحد مشترك واحد.) <br><br>  بدءًا من PostgreSQL 10 ، يتم تعيين هذا المستوى افتراضيًا (وقبل ذلك كان الحد الأدنى).  لذلك ، فقط إعادة تعيين المعلمات إلى القيم الافتراضية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  نقوم بحذف الجدول ونكرر نفس تسلسل الإجراءات تمامًا كما حدث في المرة الأخيرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  تحقق الآن من إدخالات دفتر اليومية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  تنظيف ، الحصول على OID ، إنشاء جدول والتسجيل في دليل النظام - في الوقت الحالي ، كل شيء كما كان: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, … rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  لكن شيئا جديدا.  سجل القفل الحصري المتعلق بمدير الاستعداد - في هذه الحالة ، يقوم بحظر رقم المعاملة (لماذا هو مطلوب ، سنتحدث بالتفصيل في سلسلة المقالات التالية): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  وهذا سجل حول إدراج صفوف في جدولنا (قارن رقم الملف بالنسب الموضحة أعلاه في سجل CREATE): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  سجل الالتزام: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  ويشير سجل آخر ، والذي يحدث بشكل دوري وغير مرتبط بالمعاملة المكتملة ، إلى مدير الاستعداد ويقدم تقارير عن المعاملات الجارية حاليًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2 style=";text-align:right;direction:rtl">  منطقي </h2><br>  أخيرًا ، يتم تعيين المستوى الأخير حسب قيمة المعلمة <em>wal_level</em> = المنطقية ويوفر إمكانية فك التشفير المنطقي والتكرار المنطقي.  يجب تمكينه على خادم النشر. <br><br>  من وجهة نظر إدخالات دفتر اليومية ، لا يختلف هذا المستوى عملياً عن النسخة المتماثلة - يتم إضافة الإدخالات المتعلقة بأصول النسخ المتماثل والإدخالات المنطقية التعسفية التي يمكن إضافتها إلى سجل التطبيق.  يعتمد فك الترميز المنطقي بشكل أساسي على معلومات حول المعاملات الجارية ، نظرًا لأنك تحتاج إلى إنشاء لقطة من البيانات لتتبع التغييرات في كتالوج النظام. <br><br>  الآن لن ندخل في تفاصيل عملية النسخ الاحتياطي والتكرار - هذا موضوع كبير لسلسلة منفصلة من المقالات. <br><br><h1 style=";text-align:right;direction:rtl">  موثوقية السجل </h1><br>  من الواضح أن آلية عمل دفتر اليومية يجب أن تكون موثوقة وتوفر ضمانات لإمكانية الاسترداد في أي حالات (لا تتعلق ، بالطبع ، بالأضرار التي لحقت بشركة البيانات).  تتأثر الموثوقية بالعديد من العوامل ، والتي سننظر في تخزينها في ذاكرة التخزين المؤقت وفساد البيانات و atomicity التسجيلات. <br><br><h2 style=";text-align:right;direction:rtl">  التخزين المؤقت </h2><br>  هناك العديد من ذاكرات التخزين المؤقت على مسار البيانات إلى تخزين غير متغير (مثل محرك الأقراص الثابتة). <br><br>  عندما يطلب برنامج (أي ، ولكن في حالتنا PostgreSQL) من نظام التشغيل كتابة شيء ما على القرص ، فإن نظام التشغيل ينقل البيانات إلى ذاكرة التخزين المؤقت الخاصة به في ذاكرة الوصول العشوائي.  يحدث التسجيل الفعلي بشكل غير متزامن ، اعتمادًا على إعدادات برنامج جدولة I / O لنظام التشغيل. <br><br>  عندما يقرر نظام التشغيل كتابة البيانات ، فإنها تقع في ذاكرة التخزين المؤقت لمحرك الأقراص (القرص الصلب).  يمكن أن تؤدي إلكترونيات Drive أيضًا إلى تأخير التسجيل ، على سبيل المثال ، جمع البيانات في مجموعات تكون أكثر ربحية للتسجيل في نفس الوقت.  وإذا تم استخدام وحدة تحكم RAID ، يظهر مستوى آخر من التخزين المؤقت بين نظام التشغيل ومحرك الأقراص. <br><br>  وبالتالي ، إذا لم تتخذ تدابير خاصة ، فمن غير الواضح تمامًا متى سيتم تخزين البيانات بأمان.  هذا ليس مهمًا في العادة ، ولكن هناك أماكن حرجة حيث يحتاج PostgreSQL إلى التأكد من أن البيانات مكتوبة بشكل آمن.  أولاً وقبل كل شيء ، هذا يوميات (إذا لم يصل إدخال دفتر اليومية إلى القرص ، فسيختفي مع باقي محتويات ذاكرة الوصول العشوائي) ونقطة تفتيش (يجب أن تكون متأكدًا من أن الصفحات المتسخة مكتوبة بالفعل على القرص).  ولكن هناك حالات أخرى ، على سبيل المثال ، تنفيذ عمليات غير يومية على المستوى الأدنى ، إلخ. <br><br>  يوفر نظام التشغيل الأدوات التي يجب أن تضمن الكتابة الفورية للبيانات إلى ذاكرة غير متقلبة.  هناك العديد من الخيارات ، ولكنها تنقسم إلى خيارين رئيسيين: إما أن يتم إعطاء أمر التزامن بعد التسجيل (fsync ، fdatasync) ، أو عند فتح ملف (أو الكتابة إليه) ، يتم الإشارة إلى علامة خاصة للمزامنة أو حتى التسجيل المباشر ، وتجاوز ذاكرة التخزين المؤقت لنظام التشغيل. <br><br>  بالنسبة للسجل ، تسمح لك الأداة المساعدة pg_test_fsync باختيار الطريقة الأنسب لنظام تشغيل معين ونظام ملفات محدد ، ويتم تثبيته في معلمة تكوين <em>wal_sync_method</em> .  تتم مزامنة الملفات العادية دائمًا باستخدام fsync. <br><br>  النقطة الدقيقة هي أنه عند اختيار طريقة ، يجب مراعاة خصائص الجهاز.  على سبيل المثال ، إذا كنت تستخدم وحدة تحكم مدعومة بواسطة بطارية احتياطية ، فلا يوجد سبب لعدم استخدام ذاكرة التخزين المؤقت الخاصة بها ، لأن البطارية ستحفظ البيانات في حالة انقطاع التيار الكهربائي. <br><br><blockquote style=";text-align:right;direction:rtl">  تحتوي الوثائق على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">العديد من التفاصيل</a> حول هذا الموضوع. <br></blockquote><br>  في أي حال ، تكون المزامنة مكلفة ولا تحدث أكثر من اللازم (سنعود إلى هذه المشكلة أقل قليلاً عندما نتحدث عن الأداء). <br><br>  بشكل عام ، يمكن إيقاف تشغيل المزامنة (المعلمة <em>fsync</em> مسؤولة عن هذا) ، ولكن في هذه الحالة يجب أن تنسى موثوقية التخزين.  من خلال تعطيل <em>fsync</em> ، فإنك توافق على أنه قد يتم فقد البيانات في أي وقت بشكل لا رجعة فيه.  ربما يكون الخيار الوحيد المعقول لاستخدام هذا الخيار هو زيادة الإنتاجية مؤقتًا ، عندما يمكن استعادة البيانات بسهولة من مصدر آخر (على سبيل المثال ، أثناء الترحيل الأولي). <br><br><h2 style=";text-align:right;direction:rtl">  تلف البيانات </h2><br>  الجهاز غير كامل وقد تتلف البيانات على الوسائط ، عند إرسال البيانات عبر كبلات الواجهة ، وما إلى ذلك. تتم معالجة بعض هذه الأخطاء على مستوى الأجهزة ، لكن بعضها لا يتم معالجتها. <br><br>  من أجل اكتشاف المشكلة في الوقت المناسب ، يتم توفير إدخالات دفتر اليومية دائما مع الاختباري. <br><br>  يمكن أيضًا حماية صفحات البيانات من خلال الاختبارات.  في الوقت الحالي ، لا يمكن القيام بذلك إلا عند تهيئة الكتلة ، ولكن في PostgreSQL 12 سيكون من الممكن تشغيلها وإيقافها باستخدام الأداة المساعدة pg_checksums (على الرغم من عدم انتقالها بعد ، ولكن فقط عند إيقاف الخادم). <br><br>  في بيئة الإنتاج ، يجب تضمين الاختبارات ، على الرغم من النفقات العامة لحسابها ومراقبتها.  هذا يقلل من احتمال عدم اكتشاف الفشل في الوقت المناسب. <br><br><blockquote style=";text-align:right;direction:rtl">  يقلل ، ولكن لا يلغي. <br>  أولاً ، يتم التحقق من المجموع الاختباري فقط عند الوصول إلى الصفحة - وبالتالي ، قد لا يتم ملاحظة الضرر حتى يتم الوصول إلى كافة النسخ الاحتياطية.  هذا هو السبب في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">pg_probackup</a> بالتحقق من المجموع الاختباري لجميع صفحات الكتلة أثناء النسخ الاحتياطي. <br>  ثانياً ، تعتبر الصفحة المملوءة بالأصفار صحيحة - إذا كان نظام الملفات عن طريق الخطأ "يلغي" الملف ، فقد يمر هذا دون أن يلاحظه أحد. <br>  ثالثًا ، تحمي الاختبارية الطبقة الرئيسية فقط من ملفات البيانات.  الطبقات المتبقية والملفات الأخرى (على سبيل المثال ، حالات المعاملات XACT) ليست محمية من قبل أي شيء. <br>  للأسف. <br></blockquote><br>  دعونا نرى كيف يعمل.  أولاً ، تأكد من تمكين عمليات المجموع الاختباري (ضع في اعتبارك أن هذا ليس هو الحال عند تثبيت حزمة على أنظمة تشبه دبيان): <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  المعلمة <em>data_checksums</em> للقراءة فقط. <br><br>  هنا هو الملف الذي يوجد به جدولنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  أوقف الخادم وقم بتغيير بضعة بايت في صفحة الصفر ، على سبيل المثال ، احذف إدخال السجل الأخير من رأس LSN. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  من حيث المبدأ ، لا يمكن إيقاف الخادم.  يكفي أن تكون الصفحة مكتوبة على القرص وتم إجبارها على الخروج من ذاكرة التخزين المؤقت (وإلا فإن الخادم سيعمل مع الصفحة من ذاكرة التخزين المؤقت).  لكن مثل هذا السيناريو أكثر صعوبة في التكاثر. <br><br>  نبدأ الآن الخادم ونحاول قراءة الجدول. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  ولكن ماذا لو لم يمكن استعادة البيانات من النسخة الاحتياطية؟  تسمح <em>لك</em> المعلمة <em>ignore_checksum_failure</em> بمحاولة قراءة الجدول ، بشكل طبيعي مع خطر الحصول على بيانات مشوهة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  بالطبع ، في هذه الحالة ، كل شيء يسير على ما يرام ، لأننا أفسدنا عنوان الصفحة فقط ، وليس البيانات نفسها. <br><br>  وأكثر شيء واحد.  عند تشغيل المجموع الاختباري ، تتم كتابة أجزاء من المطالبات إلى السجل ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">درسناها</a> سابقًا) ، نظرًا لأن التغيير في أي شيء ، حتى غير أساسي ، يؤدي أيضًا إلى تغيير في المجموع الاختباري.  عند إيقاف تشغيل المجموع الاختباري ، تكون المعلمة <em>wal_log_hints</em> مسؤولة عن كتابة بت تلميح في <em>السجل</em> . <br><br>  يتم دائمًا تسجيل التغييرات في تلميحات البتات كصورة <em>صفحة كاملة</em> (FPI ، صورة صفحة كاملة) ، مما يزيد من حجم السجل بالترتيب.  في هذه الحالة ، من المنطقي تمكين ضغط الصور الكاملة باستخدام المعلمة <em>wal_compression</em> (ظهرت هذه المعلمة في الإصدار 9.5).  أدناه نحن ننظر إلى أرقام محددة. <br><br><h2 style=";text-align:right;direction:rtl">  سجل الذرية </h2><br>  وأخيرا ، هناك مشكلة ذرية السجل.  تستغرق صفحة قاعدة البيانات 8 كيلو بايت على الأقل (يمكن أن تكون 16 أو 32 كيلو بايت) ، وعلى مستوى منخفض ، يحدث التسجيل في كتل تكون عادة أصغر (عادة 512 بايت أو 4 كيلوبايت).  لذلك ، في حالة انقطاع التيار الكهربائي ، قد يتم تسجيل صفحة البيانات جزئيًا.  من الواضح أنه أثناء الاسترداد ، لا معنى لتطبيق إدخالات دفتر اليومية العادية على هذه الصفحة. <br><br>  للحماية ، يسمح لك PostgreSQL بالكتابة إلى <em>الصورة كاملة للصفحة</em> عند تغييرها لأول مرة بعد بداية نقطة التفتيش (يتم تسجيل نفس الصورة عند تغيير بت تلميح الأدوات).  <em>تتحكم</em> المعلمة <em>full_page_writes في ذلك</em> ، ويتم تمكينها افتراضيًا. <br><br>  في حالة مواجهة صورة صفحة أثناء الاستعادة في سجل ما ، تتم كتابتها بشكل غير مشروط (بدون التحقق من LSN) إلى القرص: هناك ثقة أكبر بها ، لأنه ، مثل أي سجل سجل ، محمي بواسطة المجموع الاختباري.  ويتم بالفعل تطبيق إدخالات دفتر اليومية العادية على هذه الصورة الصحيحة المضمونة. <br><br>  على الرغم من أن PostgreSQL يستثني المساحة غير المخصصة من صورة الصفحة الكاملة (نظرنا سابقًا إلى بنية الكتلة) ، إلا أن حجم إدخالات دفتر اليومية الذي تم إنشاؤه يزيد بشكل كبير.  كما ذكرنا سابقًا ، يمكن تحسين الموقف عن طريق ضغط الصور الكاملة (معلمة <em>الضغط</em> ). <br><br>  من أجل الشعور بالتغيير في حجم السجل بطريقة ما ، سنقوم بإجراء تجربة بسيطة باستخدام الأداة المساعدة pgbench.  لنستعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  <em>يتم</em> تمكين <em>الخيار full_page_writes</em> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  قم بتشغيل نقطة الإيقاف وتشغيل الاختبار لمدة 30 ثانية على الفور. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  حجم السجل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  قم الآن بإيقاف تشغيل المعلمة full_page_writes: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  وكرر التجربة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  حجم السجل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  نعم ، لقد انخفض الحجم ، ولكن ليس على الإطلاق بنفس الأهمية التي قد يتوقعها المرء. <br><br>  والسبب في ذلك هو تهيئة الكتلة باستخدام مجموعات اختبارية في صفحات البيانات ، وبالتالي لا يزال يتعين عليك كتابة صور الصفحة كاملة في السجل عند تغيير بت تلميح الأدوات.  تشكل هذه البيانات (في حالتنا) حوالي نصف إجمالي الحجم ، والذي يمكن رؤيته من خلال النظر إلى الإحصائيات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  من أجل الاكتناز ، أزلت الصفوف الصفرية من الجدول.  انتبه إلى الخط الكلي (الإجمالي) وقارن حجم الصور الكاملة (حجم FPI) مع حجم السجلات العادية (حجم السجل). <br><br>  لا يمكن تعطيل المعلمة <em>full_page_writes</em> إلا إذا كان نظام الملفات والأجهزة المستخدمة <em>لوحدهما</em> يضمنان التسجيل الذري.  ولكن ، كما نرى ، لا يوجد سبب كبير لهذا (على افتراض أن المجموع الاختباري مدرج). <br><br>  الآن دعونا نرى كيف يساعد الضغط. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  كرر نفس التجربة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  حجم السجل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  الخلاصة: في ظل وجود عدد كبير من صور الصفحة كاملة (نظرًا <em>للاختبارات</em> أو <em>full_page_writes</em> ، أي دائمًا تقريبًا) ، من المرجح استخدام الضغط على الرغم من حقيقة أن هذا يحمّل المعالج. <br><br><h1 style=";text-align:right;direction:rtl">  إنتاجية </h1><br>  أثناء تشغيل الخادم العادي ، يحدث تسجيل متسلسل مستمر لملفات السجل.  نظرًا لعدم وجود وصول عشوائي ، تتعامل محركات الأقراص الثابتة العادية مع هذه المهمة.  لكن طبيعة التحميل هذه تختلف بشكل كبير عن كيفية الوصول إلى ملفات البيانات. <br><br>  لذلك ، يكون من المفيد عادةً وضع السجل على قرص فعلي منفصل (أو صفيف قرص) مثبت على نظام ملفات الخادم.  بدلاً من دليل $ PGDATA / pg_wal ، تحتاج إلى إنشاء رابط رمزي إلى الدليل المطابق. <br><br><blockquote style=";text-align:right;direction:rtl">  هناك بعض المواقف التي لا تحتاج فيها ملفات السجل فقط إلى الكتابة ولكن أيضًا للقراءة.  الأول هو حالة استرداد مفهومة بعد الفشل.  والثاني هو أقل تافهة.  يحدث ذلك في حالة استخدام النسخ المتماثل المتدفق ولم تتمكن النسخة المتماثلة من تلقي إدخالات دفتر اليومية أثناء وجودها في المخازن المؤقتة لذاكرة الوصول العشوائي على الخادم الرئيسي.  ثم يجب على عملية walsender قراءة البيانات الضرورية من القرص.  سنتحدث عن هذا بمزيد من التفصيل عندما نصل إلى النسخ المتماثل. <br></blockquote><br>  يتم التسجيل في أحد وضعين: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  متزامن - عند ارتكاب معاملة ما ، يكون استمرار العمل مستحيلًا إلى أن يتم وضع جميع إدخالات دفتر اليومية حول هذه المعاملة على القرص </li><li style=";text-align:right;direction:rtl">  غير متزامن - يتم إكمال المعاملة على الفور ، ويتم كتابة السجل في الخلفية. </li></ul><br>  يتم تحديد الوضع المتزامن بواسطة المعلمة <em>synchronous_commit</em> ويتم تمكينه افتراضيًا. <br><br>  نظرًا لأن التزامن يرتبط بإدخال / إخراج حقيقي (أي بطيء) ، فمن المفيد القيام به بأقل قدر ممكن.  للقيام بذلك ، تستغرق عملية الصيانة التي تكمل المعاملة وتكتب السجل وقفة قصيرة ، تحددها المعلمة <em>الالتزام_التأخير</em> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ولكن هذا يحدث فقط إذا كان لدى النظام على الأقل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ارتباطات</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالمعاملات النشطة. الرهان هنا على حقيقة أنه خلال فترة الانتظار سيتم الانتهاء من بعض المعاملات وسيكون من الممكن مزامنة سجلاتهم دفعة واحدة. يشبه هذا كيف تمسك باب المصعد حتى يتسنى لشخص ما أن يسقط في الكابينة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المعلمة الافتراضية هي </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conf_siblings</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 5 ، و </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conf_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0 ، لذلك لا يوجد انتظار فعلي. تغيير </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هو مفيد فقط في الأنظمة التي تنفيذ عدد كبير من OLTP-المعاملات قصيرة.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثم تقوم العملية بمسح السجل إلى القرص إلى LSN المطلوبة (أو أكثر قليلاً إذا تمت إضافة إدخالات جديدة أثناء وقت الانتظار). بعد ذلك ، تعتبر الصفقة مكتملة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مع التسجيل المتزامن ، يتم ضمان المتانة (الحرف D في اختصار ACID) - إذا تم تنفيذ المعاملة ، فكل إدخالات دفتر اليومية الخاصة بها موجودة بالفعل على القرص ولن يتم فقدها. الجانب الآخر هو أن التسجيل المتزامن يزيد من زمن الاستجابة (الأمر COMMIT لا يُرجع التحكم حتى ينتهي التزامن) ويقلل من أداء النظام. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن الحصول على كتابة غير متزامنة عن طريق تعيين </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التزامن</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = إيقاف (أو محلي). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أثناء التسجيل غير المتزامن ، تقوم عملية كاتب السجل بإعادة تعيين إدخالات دفتر اليومية ، مع تبديل دورات الانتظار (التي يتم تعيينها بواسطة المعلمة</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font><em><font style="vertical-align: inherit;">200 مللي ثانية</font></em><font style="vertical-align: inherit;"> بشكل افتراضي). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند الاستيقاظ بعد الانتظار التالي ، تتحقق العملية من ظهور صفحات WAL الكاملة من آخر مرة. في حالة وجودها ، تتجاهل العملية الصفحة الحالية غير المعبئة وتسجيل السجلات المملوءة بالكامل فقط. (صحيح ، أنها ليست دائمًا في كل مرة: يتوقف التسجيل ، ويصل إلى نهاية ذاكرة التخزين المؤقت ، ويستمر من بداية ذاكرة التخزين المؤقت في المرة التالية.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لم تكن صفحة واحدة ممتلئة ، فستقوم العملية بكتابة الصفحة الحالية (غير كاملة) للمجلة - لسبب وجيه استيقظت؟ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تهدف هذه الخوارزمية إلى عدم مزامنة الصفحة نفسها عدة مرات إذا كان ذلك ممكنًا ، وهو أمر مهم لدفق كبير من التغييرات.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يكون التسجيل غير المتزامن أكثر فعالية من التسجيل المتزامن - لا تنتظر تغييرات الالتزام التسجيل. ومع ذلك ، تتناقص الموثوقية: قد تختفي البيانات الملتقطة في حالة حدوث عطل في حالة انقضاء أقل من 3 × </font><font style="vertical-align: inherit;">وقت </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wal_writer_delay</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بين الالتزام والفشل </font><font style="vertical-align: inherit;">(والذي ، بشكل افتراضي ، يزيد قليلاً عن نصف ثانية). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يبقى الاختيار الصعب - الكفاءة أو الموثوقية - مع مسؤول النظام. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يرجى ملاحظة: على عكس إيقاف المزامنة ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fsync</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = off) ، لا يؤدي الوضع غير المتزامن إلى استحالة الاسترداد. في حالة حدوث عطل ، سيستمر النظام في استعادة حالة متناسقة ، ولكن ربما تكون بعض أحدث المعاملات غائبة فيه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المعلمة </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Synchronous_commit</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن تعيين كجزء من المعاملات الفردية. يتيح لك ذلك زيادة الإنتاجية من خلال التضحية بموثوقية جزء فقط من المعاملة. لنقل أن المعاملات المالية تحتاج دائمًا إلى إصلاحها بشكل متزامن ، ويمكن في بعض الأحيان إهمال رسائل الدردشة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الواقع ، كلا هذين الوضعين يعملان معًا. حتى مع الالتزام المتزامن ، سيتم كتابة سجلات المعاملات الطويلة بشكل غير متزامن لتحرير مخازن WAL المؤقتة. وإذا ، عند إعادة تعيين صفحة من ذاكرة التخزين المؤقت المخزن المؤقت ، اتضح أن إدخال دفتر اليومية المقابل ليس على القرص بعد ، فسيتم إعادة تعيينه على الفور في الوضع المتزامن. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للحصول على فكرة عما يعطيه الالتزام غير المتزامن ، نحاول تكرار اختبار pgbench في هذا الوضع.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام التزامن المتزامن ، تلقينا حوالي 900 معاملة في الثانية (tps) ، مع التزام غير متزامن - 1500. بالطبع ، في نظام حقيقي تحت الحمل الحقيقي ، ستكون النسبة مختلفة ، لكن من الواضح أن التأثير يمكن أن يكون مهمًا للغاية في المعاملات القصيرة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه المرحلة ، انتهت سلسلة المقالات حول اليومية. </font><font style="vertical-align: inherit;">إذا ظل هناك شيء مهم وراء الكواليس ، فلا تجد صعوبة في الكتابة في التعليقات. </font><font style="vertical-align: inherit;">شكرا لكم جميعا! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وبعد ذلك ، سيكون لدينا مغامرات مثيرة في عالم الأقفال ، لكن هذه قصة أخرى.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar461523/">https://habr.com/ru/post/ar461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar461507/index.html">لماذا قررنا إطلاق StartupDrive من شركة Gazprom Neft للشركات ، والذي نجح بالفعل في ذلك</a></li>
<li><a href="../ar461509/index.html">مساعدو السفر: مجموعة مختارة من الأدوات والاكسسوارات</a></li>
<li><a href="../ar461511/index.html">بيثون إدارة الاعتماد: مقارنة بين النهج</a></li>
<li><a href="../ar461517/index.html">أفضل خوارزميات نسخ ولصق لـ C و C ++. هايكو OS كتاب الطبخ</a></li>
<li><a href="../ar461519/index.html">أفضل خوارزميات نسخ ولصق لـ C و C ++. Haiku OS وصفة مجموعة</a></li>
<li><a href="../ar461525/index.html">كيف فعلت شريط التمرير حقا التكيف (دائري)</a></li>
<li><a href="../ar461527/index.html">الإرتفاع الصوتي DIY</a></li>
<li><a href="../ar461531/index.html">تيك تاك تو ، الجزء 6: قارورة والكرفس / RabbitMQ</a></li>
<li><a href="../ar461533/index.html">تصور للنوم من السنة الأولى للطفل على أنماط بطانية</a></li>
<li><a href="../ar461535/index.html">C ++ و FIX و Oracle و PL / SQL: ما يحتاج متخصص تكنولوجيا المعلومات إلى معرفته للحصول على وظيفة في مجال التمويل + فرص عمل حقيقية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>