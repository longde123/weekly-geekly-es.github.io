<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿 🤲🏼 👩🏾‍🚒 Masuk dalam aplikasi php yang didistribusikan ♈️ 🐫 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan membahas manfaat penebangan. Saya akan menceritakan tentang log di PSR. Saya akan menambahkan beberapa rekomendasi pribadi untuk beke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masuk dalam aplikasi php yang didistribusikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456676/"><p><img src="https://habrastorage.org/webt/xm/rd/rj/xmrdrjy7rtwa8f2__bcbjrdry4y.png"></p><br><p>  Artikel ini akan membahas manfaat penebangan.  Saya akan menceritakan tentang log di PSR.  Saya akan menambahkan beberapa rekomendasi pribadi untuk bekerja dengan level, pesan, dan konteks acara yang dicatat.  Contoh akan diberikan tentang bagaimana mengatur logging dan pemantauan menggunakan ELK dalam aplikasi yang ditulis dalam Laravel dan diluncurkan melalui Docker pada beberapa contoh.  Saya akan menandatangani aturan penting dari sistem peringatan.  Saya akan memberikan contoh skrip yang meningkatkan seluruh tumpukan pemantauan dengan satu perintah. </p><a name="habracut"></a><br><h2 id="polza-logirovaniya">  Manfaat penebangan </h2><br><p>  Penebangan yang terorganisasi dengan baik memungkinkan setidaknya hal berikut: </p><br><ul><li>  Untuk mengetahui bahwa sesuatu tidak berjalan sebagaimana mestinya (ada kesalahan) </li><li>  Ketahui detail kesalahan, yang akan membantu untuk mengatakan dengan siapa dan di mana kesalahan terjadi, dan mencegah pengulangan </li><li>  Untuk mengetahui bahwa semuanya berjalan sesuai rencana (access.log, debug-, info-level) </li></ul><br><p>  Pencatatan dengan sendirinya tidak akan memberi tahu Anda semua ini, tetapi dengan bantuan log, Anda dapat mengetahui detail acara sendiri, atau mengonfigurasi sistem pemantauan log yang dapat memberi tahu masalah.  Jika pesan dalam log disertai dengan konteks yang cukup, ini sangat menyederhanakan debugging, karena Anda akan memiliki akses ke lebih banyak data tentang situasi di mana peristiwa itu terjadi. </p><br><h2 id="chem-pisat-i-chto-pisat">  Apa yang harus ditulis dan apa yang harus ditulis </h2><br><p> Bagian dari komunitas php telah mengembangkan rekomendasi untuk beberapa tugas penulisan kode.  Salah satu rekomendasi tersebut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antarmuka Logger PSR-3</a> .  Itu hanya menggambarkan apa yang Anda perlu login.  Untuk ini, <code>Psr\Log\LoggerInterface</code> dari paket "psr / log" dikembangkan.  Saat menggunakannya, Anda perlu tahu tentang tiga komponen acara: </p><br><ol><li>  <strong>Level</strong> - Pentingnya Acara </li><li>  <strong>Pesan</strong> - teks yang menjelaskan acara tersebut </li><li>  <strong>Konteks</strong> - serangkaian informasi tambahan tentang acara tersebut </li></ol><br><h3 id="urovni-sobytiya-po-psr-3">  Level Acara PSR-3 </h3><br><p>  Level-level tersebut dipinjam dari RFC 5424 - Protokol Syslog, perkiraan deskripsi mereka adalah sebagai berikut: </p><br><ul><li>  debug - Detail untuk debugging </li><li>  info - Acara menarik </li><li>  notice - Peristiwa material, tapi bukan kesalahan </li><li>  peringatan - Kasus luar biasa, tetapi tidak kesalahan </li><li>  error - Kesalahan eksekusi yang tidak memerlukan intervensi sesaat </li><li>  critical - Kondisi kritis (komponen sistem tidak tersedia, pengecualian tak terduga) </li><li>  waspada - Tindakan memerlukan intervensi segera </li><li>  darurat - Sistem tidak berfungsi </li></ul><br><p>  Ada deskripsi, tetapi tidak selalu mudah diikuti, karena kesulitan dalam menentukan pentingnya peristiwa tertentu.  Misalnya, dalam konteks satu permintaan, tidak mungkin untuk mengakses sumber daya yang terhubung.  Saat merekam acara ini, kami tidak tahu apakah satu permintaan seperti itu gagal, atau mungkin hanya satu pengguna yang gagal.  Itu tergantung pada apakah intervensi segera diperlukan atau jika ini adalah kasus yang jarang, itu bisa menunggu atau bahkan diabaikan.  Masalah-masalah seperti itu diselesaikan dalam kerangka pemantauan log.  Tetapi Anda masih perlu menentukan levelnya.  Oleh karena itu, level logging dalam tim dapat disepakati.  Contoh: </p><br><ul><li>  <strong>darurat</strong> adalah level untuk sistem eksternal yang dapat melihat sistem Anda dan menentukan dengan pasti bahwa itu benar-benar tidak berfungsi, atau diagnosa sendiri tidak berfungsi. </li><li>  <strong>waspada</strong> - sistem itu sendiri dapat mendiagnosis keadaannya, misalnya, dengan tugas yang dijadwalkan, dan sebagai hasilnya merekam acara dengan level ini.  Ini bisa berupa pengecekan sumber daya yang terhubung atau sesuatu yang spesifik, misalnya, keseimbangan pada akun sumber daya eksternal yang digunakan. </li><li>  <strong>critical</strong> - suatu peristiwa ketika kegagalan memberikan komponen sistem yang sangat penting dan harus selalu berfungsi.  Itu sudah sangat tergantung pada apa yang sistem lakukan.  Cocok untuk acara yang penting untuk mencari tahu dengan cepat, bahkan jika itu terjadi hanya sekali. </li><li>  <strong>kesalahan</strong> - suatu peristiwa telah terjadi yang, ketika segera diulang, Anda perlu melaporkan.  Gagal menyelesaikan tindakan, yang harus dilakukan, tetapi tindakan ini tidak termasuk dalam deskripsi kritis.  Misalnya, tidak mungkin menyimpan gambar profil pengguna atas permintaannya, tetapi sistem itu bukan layanan gambar profil, tetapi sistem obrolan. </li><li>  <strong>peringatan</strong> - acara, untuk pemberitahuan segera yang perlu Anda hubungi sejumlah besar dari mereka selama periode waktu.  Gagal melakukan suatu tindakan, kegagalan yang tidak merusak sesuatu yang serius.  Ini masih kesalahan, tetapi koreksi yang mungkin menunggu jadwal kerja.  Misalnya, tidak mungkin menyimpan avatar pengguna, dan sistemnya adalah toko online.  Diperlukan pemberitahuan tentang mereka (pada frekuensi tinggi) untuk mempelajari tentang anomali yang tiba-tiba, karena mereka dapat menjadi gejala masalah yang lebih serius. </li><li>  <strong>perhatikan</strong> - ini adalah peristiwa yang melaporkan penyimpangan yang disediakan oleh sistem yang merupakan bagian dari fungsi normal sistem.  Misalnya, pengguna menentukan kata sandi yang salah di pintu masuk, pengguna tidak mengisi nama tengah, tetapi tidak perlu, pengguna membeli pesanan untuk 0 rubel, tetapi ini disediakan untuk Anda dalam kasus yang jarang terjadi.  Pemberitahuan pada mereka pada frekuensi tinggi juga diperlukan, karena peningkatan tajam dalam jumlah penyimpangan dapat merupakan hasil dari kesalahan yang sangat perlu diperbaiki. </li><li>  <strong>info</strong> - events, kejadian yang melaporkan fungsi normal sistem.  Misalnya, pengguna telah mendaftar, pengguna telah membeli produk, pengguna telah meninggalkan umpan balik.  Pemberitahuan untuk peristiwa semacam itu perlu dikonfigurasikan dengan cara yang berlawanan: jika jumlah peristiwa semacam itu tidak cukup terjadi selama periode waktu tertentu, maka Anda harus memberi tahu, karena penurunannya dapat disebabkan oleh kesalahan. </li><li>  <strong>debug</strong> - peristiwa untuk <strong>men</strong> -debug proses pada sistem.  Ketika Anda menambahkan data yang cukup ke konteks acara, Anda dapat mendiagnosis masalahnya, atau menyimpulkan bahwa prosesnya berfungsi dengan baik dalam sistem.  Misalnya, pengguna membuka halaman produk dan menerima daftar rekomendasi.  Secara signifikan meningkatkan jumlah acara yang dikirim, sehingga diperbolehkan untuk menghapus pencatatan acara tersebut setelah beberapa saat.  Akibatnya, jumlah kejadian seperti itu dalam operasi normal akan berubah-ubah, maka pemantauan untuk pemberitahuannya dapat dihilangkan. </li></ul><br><h3 id="soobschenie-sobytiya">  Pesan acara </h3><br><p>  Dengan PSR-3, sebuah pesan harus berupa string atau objek dengan metode <code>__toString()</code> .  Selain itu, menurut PSR-3, baris pesan dapat berisi placeholder dari formulir <code>”User {username} created”</code> , yang dapat diganti dengan nilai-nilai dari array konteks.  Saat menggunakan Elasticsearch dan Kibana untuk pemantauan, saya sarankan tidak menggunakan placeholder, tetapi menulis garis tetap, karena ini akan menyederhanakan penyaringan peristiwa, dan konteksnya akan selalu ada.  Selain itu, saya mengusulkan untuk memperhatikan persyaratan tambahan untuk pesan: </p><br><ol><li>  Teksnya harus pendek tetapi bermakna.  Ini adalah apa yang akan muncul dalam peringatan, dan apa yang akan ada dalam daftar peristiwa yang telah terjadi. </li><li>  Teks lebih baik menjadi unik untuk berbagai bagian program.  Ini akan memungkinkan dari peringatan, tanpa melihat konteksnya, untuk memahami di bagian mana peristiwa itu terjadi. </li></ol><br><h3 id="kontekst-sobytiya">  Konteks acara </h3><br><p>  Konteks acara untuk PSR-3 adalah larik (kemungkinan bersarang) dari nilai variabel, misalnya, ID entitas.  Konteksnya dapat dibiarkan kosong jika pesannya jelas tentang acara tersebut.  Dalam hal mencatat pengecualian, Anda harus melewati seluruh pengecualian, bukan hanya <code>getMessage()</code> .  Saat menggunakan Monolog melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NormalizerFormatter,</a> data yang berguna akan secara otomatis diekstraksi dari pengecualian dan ditambahkan ke konteks peristiwa, termasuk jejak stack.  Artinya, Anda malah perlu </p><br><pre> <code class="php hljs">[ <span class="hljs-string"><span class="hljs-string">'exception'</span></span> =&gt; $exception-&gt;getMessage(), ]</code> </pre> <br><p>  untuk digunakan </p><br><pre> <code class="php hljs">[ <span class="hljs-string"><span class="hljs-string">'exception'</span></span> =&gt; $exception, ]</code> </pre> <br><p>  Di Laravel, Anda dapat secara otomatis memasukkan data untuk acara dalam acara.  Ini dapat dilakukan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konteks Log Global</a> (hanya untuk pengecualian yang tidak berhasil atau melalui <code>report()</code> ), atau melalui LogFormatter (untuk semua acara).  Biasanya, informasi ditambahkan dengan id pengguna saat ini, permintaan URI, IP, permintaan UUID dan sejenisnya. </p><br><p>  Saat menggunakan Elasticsearch sebagai repositori log, ingatlah bahwa ia menggunakan tipe data tetap.  Yaitu, jika Anda meneruskan <code>customer_id</code> dalam konteks angka, maka ketika Anda mencoba menyimpan acara dengan tipe yang berbeda, misalnya string (uuid), pesan seperti itu tidak akan ditulis.  Jenis dalam indeks ditetapkan ketika nilai pertama kali diterima.  Jika indeks dibuat setiap hari, maka tipe baru akan direkam hanya pada hari berikutnya.  Tetapi bahkan ini tidak akan menyelesaikan semua masalah, karena untuk Kibana jenis akan dicampur dan beberapa operasi yang terkait dengan jenis tidak akan tersedia sampai ada indeks campuran. </p><br><p>  Untuk mencegah masalah ini, saya sarankan Anda mengikuti aturan: </p><br><ul><li>  Jangan gunakan nama kunci yang terlalu umum, yang bisa dari tipe yang berbeda </li><li>  Lakukan casting eksplisit ke tipe nilai jika Anda tidak yakin dengan tipenya </li></ul><br><p>  Contoh: sebagai gantinya </p><br><pre> <code class="php hljs">[ <span class="hljs-string"><span class="hljs-string">'response'</span></span> =&gt; $response-&gt;all(), <span class="hljs-string"><span class="hljs-string">'customer_id'</span></span> =&gt; $id, <span class="hljs-string"><span class="hljs-string">'value'</span></span> =&gt; $someValue, ]</code> </pre> <br><p>  untuk digunakan </p><br><pre> <code class="php hljs">[ <span class="hljs-string"><span class="hljs-string">'smsc_response_data'</span></span> =&gt; json_encode($response-&gt;all()), <span class="hljs-string"><span class="hljs-string">'customer_id'</span></span> =&gt; (string) $customer_id, <span class="hljs-string"><span class="hljs-string">'smsc_request_some_value'</span></span> =&gt; (string) $someValue, ]</code> </pre> <br><h3 id="vyzov-loggera-iz-koda">  Memanggil logger dari kode </h3><br><p>  Untuk merekam acara dengan cepat di log, Anda dapat membuat beberapa opsi.  Mari kita pertimbangkan beberapa di antaranya. </p><br><ol><li>  Deklarasikan <code>log()</code> fungsi global <code>log()</code> dan panggil dari berbagai bagian program.  Pendekatan ini memiliki banyak kelemahan.  Misalnya, di kelas di mana kita mengakses fungsi ini, ketergantungan implisit terbentuk.  Ini harus dihindari.  Selain itu, logger seperti ini sulit untuk dikonfigurasi ketika sistem perlu memiliki beberapa yang berbeda.  Kelemahan lain, jika kita berbicara tentang bekerja dengan Laravel, adalah bahwa kita tidak menggunakan fitur yang disediakan oleh kerangka kerja untuk menyelesaikan masalah ini. </li><li>  Gunakan fasad Laravel \ Log.  Dengan pendekatan ini, bagian-bagian sistem yang mengakses fasad ini mulai bergantung pada kerangka kerja.  Pada bagian-bagian sistem yang tidak akan kita hapus dari kerangka kerja, solusi semacam itu sangat cocok.  Misalnya, tulis dari beberapa contoh perintah konsol, tugas latar belakang, pengontrol.  Atau ketika sudah ada struktur layanan yang rumit, dan melempar instance dari logger ke dalamnya tidak begitu sederhana. </li><li>  Mengatasi ketergantungan logger melalui bantuan kerangka <code>app()</code> dan kerangka <code>resolve()</code> .  Pendekatan ini memiliki kelemahan yang sama dengan menggunakan fasad, tetapi Anda perlu menulis sedikit lebih banyak kode. </li><li>  Tentukan ketergantungan pada logger di konstruktor kelas yang akan digunakan logger ini.  Pada saat yang sama, <code>LoggerInterface</code> sama harus ditentukan sebagai jenis untuk memenuhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DIP</a> .  Berkat kerangka kerja autowiring, dependensi akan secara otomatis diselesaikan dalam implementasi abstraksi yang mereka nyatakan.  Di Laravel, beberapa kelas dependensi dapat ditentukan dalam metode terpisah, alih-alih ditentukan dalam konstruktor seluruh kelas. </li></ol><br><h3 id="gde-v-kode-vyzyvat-logger">  Di mana dalam kode untuk memanggil logger </h3><br><p>  Saat mengatur kode dalam proyek, pertanyaan mungkin muncul di kelas mana saya harus menulis ke log.  Haruskah itu menjadi layanan?  Atau haruskah itu dilakukan di mana layanan dipanggil dari: controller, tugas latar belakang, perintah konsol?  Atau haruskah setiap pengecualian memutuskan apa yang akan ditulis ke log menggunakan metode <code>report</code> (Laravel)?  Tidak ada jawaban sederhana untuk semua pertanyaan sekaligus. </p><br><p>  Pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peluang yang</a> diberikan oleh Laravel untuk mendelegasikan tugas pengecualian ke kelas pengecualian itu sendiri.  Pengecualian tidak dapat mengetahui betapa pentingnya sistem untuk menentukan tingkat suatu peristiwa.  Selain itu, pengecualian tidak memiliki akses ke konteks kecuali jika secara khusus ditambahkan ketika pengecualian ini dipanggil.  Untuk memanggil metode <code>render</code> pada pengecualian, Anda harus tidak menangkap pengecualian (global ErrorHandler akan digunakan), atau menangkap dan menggunakan <code>report()</code> global helper.  Metode ini memungkinkan kita untuk tidak memanggil logger PSR-3 setiap kali kita dapat menangkap pengecualian ini.  Tapi saya pikir tidak layak untuk memberikan pengecualian tanggung jawab tersebut. </p><br><p>  Tampaknya kita selalu dapat login hanya di layanan.  Memang, di beberapa layanan Anda bisa melakukan logging.  Tetapi pertimbangkan layanan yang tidak tergantung pada proyek dan, secara umum, kami berencana untuk memasukkannya ke dalam paket terpisah.  Maka layanan ini tidak tahu tentang pentingnya dalam proyek, dan, oleh karena itu, tidak akan dapat menentukan tingkat pembalakan.  Misalnya, layanan integrasi dengan gateway SMS tertentu.  Jika kita mendapatkan kesalahan jaringan, maka ini tidak berarti itu cukup serius.  Mungkin sistem memiliki layanan integrasi dengan gateway SMS lain di mana akan ada upaya kedua untuk mengirim, maka kesalahan dari yang pertama dapat dilaporkan sebagai peringatan, dan kesalahan yang kedua sebagai kesalahan.  Hanya sekarang semua integrasi ini harus dipanggil dari layanan lain, yang akan masuk dengan tepat.  Ternyata kesalahan ada di satu layanan, dan kami masuk di layanan lain.  Namun terkadang kami tidak memiliki pembungkus layanan di atas layanan lain - kami menyebutnya langsung dari pengontrol.  Dalam hal ini, saya menganggap diperbolehkan untuk menulis ke log di controller daripada menulis dekorator layanan untuk logging. </p><br><p>  Contoh yang menunjukkan penggunaan dependensi dan konteks lewat: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Commands</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">App</span></span>\<span class="hljs-title"><span class="hljs-title">Services</span></span>\<span class="hljs-title"><span class="hljs-title">ExampleService</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Console</span></span>\<span class="hljs-title"><span class="hljs-title">Command</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Log</span></span>\<span class="hljs-title"><span class="hljs-title">LoggerInterface</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $signature = <span class="hljs-string"><span class="hljs-string">'example'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExampleService $service, LoggerInterface $logger)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $service-&gt;example(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (\<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $exception) { $logger-&gt;critical(<span class="hljs-string"><span class="hljs-string">'Example error'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'exception'</span></span> =&gt; $exception, ]); } } }</code> </pre><br><h2 id="kuda-pisat">  Tempat menulis </h2><br><p>  Pertimbangkan opsi berikut. </p><br><ol><li>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi 12 faktor</a> dan beberapa rekomendasi lain, Anda perlu menulis di stdout, stderr dari runtime aplikasi.  Untuk melakukan ini, Anda dapat menentukan di <code>php://stdout</code> config logger <code>php://stdout</code> *. </li><li>  Abaikan 12 faktor, cara buruh pelabuhan dan tulis ke file.  Laravel (Monolog) bahkan memungkinkan Anda untuk mengkonfigurasi rotasi log.  Pesan lebih lanjut dari file dapat dikumpulkan menggunakan Filebeat dan dikirim ke Logstash untuk dianalisis. </li><li>  Kirim log dari aplikasi secara langsung lebih lanjut, misalnya, melalui UDP untuk meningkatkan kinerja. </li><li>  Kombinasikan solusi.  Menulis ke file yang menggunakan Filebeat akan dikumpulkan dan dikirim ke Logstash.  Tuliskan dalam wadah stderr agar dapat menggunakan perintah <code>docker logs</code> dan siap untuk mengumpulkan kayu dari lingkungan orkestrasi wadah.  Dalam hal ini, Anda dapat menulis beberapa saluran hanya secara lokal, beberapa mengirim melalui jaringan. </li></ol><br><p>  * <em>Dalam php-fpm 7.2, ketika menulis log ke stdout, kita mendapatkan "PERINGATAN: [kelompok www] child X berkata ke stdout ...", dan pesan yang panjang terpotong.</em>  <em>Salah satu solusi untuk masalah ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</em>  <em>Tidak ada masalah seperti itu di php-fpm 7.3.</em> </p><br><p>  Opsi format perekaman: </p><br><ul><li>  Dapat dibaca oleh manusia (penghentian baris, indentasi, dll.) </li><li>  Dapat dibaca mesin (biasanya json) </li><li>  Kedua format sekaligus: dapat dibaca mesin di stdout untuk perutean lebih lanjut, dapat dibaca manusia jika terjadi masalah perutean mendadak dan debugging cepat </li></ul><br><p>  Salah satu opsi mengasumsikan bahwa log dirutekan - setidaknya, mereka dikirim ke sistem pemrosesan tunggal (penyimpanan) log karena alasan berikut: </p><br><ol><li>  Penyimpanan dan pengarsipan jangka panjang </li><li>  Tren skala besar </li><li>  Sistem pemberitahuan acara yang fleksibel </li></ol><br><p>  Docker memiliki kemampuan untuk menentukan manajer log.  Standarnya adalah <code>json-file</code> , yaitu buruh pelabuhan menambahkan output dari wadah ke file json di host.  Jika kami memilih manajer log yang akan mengirim catatan di suatu tempat melalui jaringan, maka kami tidak dapat lagi menggunakan perintah <code>docker logs</code> .  Jika stdout / stderr dari wadah dipilih sebagai satu-satunya tempat untuk merekam log aplikasi, maka dalam kasus masalah jaringan atau masalah dengan repositori tunggal, tidak mungkin untuk dengan cepat mengekstraksi catatan untuk debug. </p><br><p>  Kita bisa menggunakan dock file json dan Filebeat.  Kami akan menerima log lokal dan perutean lebih lanjut.  Perlu dicatat di sini adalah fitur lain dari buruh pelabuhan.  Saat merekam acara yang lebih panjang dari 16KB, buruh pelabuhan memecah catatan dengan simbol <code>\n</code> , yang membingungkan banyak pengumpul log.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> tentang ini.  Masalah pada bagian buruh pelabuhan tidak bisa diselesaikan, jadi itu diselesaikan oleh para kolektor.  Dengan beberapa versi, Filebeat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendukung</a> perilaku buruh pelabuhan ini dan menggabungkan acara dengan benar. </p><br><p>  Apa kombinasi dari semua kemungkinan tujuan dan format rekaman yang dapat Anda pilih untuk proyek Anda sendiri. </p><br><h2 id="ispolzovanie-filebeat--elk--elastalert">  Menggunakan Filebeat + ELK + Elastalert </h2><br><p>  Secara singkat, peran masing-masing layanan dapat digambarkan sebagai berikut: </p><br><ul><li>  Filebeat - mengumpulkan acara dari file dan mengirim </li><li>  Logstash - mem-parsing acara dan mengirim </li><li>  Elasticsearch - menyimpan acara terstruktur </li><li>  Kibana - menampilkan acara (grafik, agregasi, dll.) </li><li>  Elastalert - Mengirim pemberitahuan berdasarkan permintaan </li></ul><br><p>  Selain itu, Anda dapat: zabbix, metricbeat, grafana, dan lainnya. </p><br><p>  Sekarang, lebih banyak tentang masing-masing. </p><br><h3 id="filebeat">  Filebeat </h3><br><p>  Anda dapat menjalankan sebagai layanan terpisah pada host, Anda dapat menggunakan wadah buruh pelabuhan yang terpisah.  Untuk bekerja dengan aliran peristiwa dari buruh pelabuhan, ia menggunakan jalur host <code>/var/lib/docker/containers/*/*.log</code> .  Filebeat memiliki beragam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> untuk mengatur perilaku dalam berbagai situasi (file diubah namanya, file dihapus, dan sejenisnya).  Filebeat itu sendiri dapat mem-parsing json di dalam acara, tetapi tidak json juga bisa masuk ke acara, yang akan menyebabkan kesalahan.  Semua pemrosesan acara paling baik dilakukan di satu tempat. </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi fragmen untuk Filebeat 6</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">filebeat.inputs: - type: docker containers: ids: - "*" processors: - add_docker_metadata: ~</code> </pre></div></div><br><h3 id="logstash">  Logstash </h3><br><p>  Dapat menerima acara dari banyak sumber, tetapi di sini kami mempertimbangkan Filebeat. <br>  Di setiap acara, selain acara itu sendiri dari stdout / stderr, ada metadata (tuan rumah, wadah, dll.).  Ada banyak filter pemrosesan bawaan: parse dengan interval reguler, parse json, modifikasi, tambah, hapus bidang, dll. Cocok untuk mengurai log aplikasi dan nginx access.log dalam format apa pun.  Dapat mentransfer data ke berbagai repositori, tetapi di sini kami mempertimbangkan Elasticsearch. </p><br><div class="spoiler">  <b class="spoiler_title">Fragmen konfigurasi filter Logstash</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">if [status] { date { match =&gt; ["timestamp_nginx_access", "dd/MMM/yyyy:HH:mm:ss Z"] target =&gt; "timestamp_nginx" remove_field =&gt; ["timestamp_nginx_access"] } mutate { convert =&gt; { "bytes_sent" =&gt; "integer" "body_bytes_sent" =&gt; "integer" "request_length" =&gt; "integer" "request_time" =&gt; "float" "upstream_response_time" =&gt; "float" "upstream_connect_time" =&gt; "float" "upstream_header_time" =&gt; "float" "status" =&gt; "integer" "upstream_status" =&gt; "integer" } remove_field =&gt; [ "message" ] rename =&gt; { "@timestamp" =&gt; "event_timestamp" "timestamp_nginx" =&gt; "@timestamp" } } }</code> </pre> </div></div><br><h3 id="elasticsearch">  Pencarian Elastics </h3><br><p>  Elasticsearch adalah alat yang sangat kuat untuk berbagai tugas, tetapi untuk tujuan pemantauan, log dapat digunakan hanya dengan mengetahui minimum tertentu. <br>  Peristiwa tersimpan adalah dokumen, dokumen disimpan dalam indeks. <br>  Setiap indeks adalah skema di mana suatu tipe didefinisikan untuk setiap bidang dokumen.  Anda tidak dapat menyimpan acara di indeks jika setidaknya satu bidang memiliki tipe yang salah. <br>  Jenis yang berbeda memungkinkan Anda untuk melakukan operasi yang berbeda pada sekelompok dokumen (untuk angka - jumlah, min, maks, rata, dll, untuk string - pencarian fuzzy, dan sebagainya). <br>  Untuk log, manajemen biasanya merekomendasikan penggunaan indeks harian - indeks baru setiap hari. </p><br><p>  Memastikan operasi Elasticsearch yang stabil dengan pertumbuhan volume data adalah tugas yang membutuhkan pengetahuan lebih dalam tentang alat ini.  Tapi solusi cepat untuk masalah stabilitas, Anda dapat memilih untuk secara otomatis menghapus data yang sudah usang.  Untuk melakukan ini, saya sarankan membagi level peristiwa dalam logstash di indeks yang berbeda.  Ini akan memungkinkan lebih lama untuk menyimpan acara yang jarang, tetapi lebih penting. </p><br><div class="spoiler">  <b class="spoiler_title">Cuplikan konfigurasi output logstash</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">output { if [fields][log_type] == "app_log" { if [level] in ["DEBUG", "INFO", "NOTICE"] { elasticsearch { hosts =&gt; "${ES_HOST}" index =&gt; "logstash-app-log-debug-%{+YYYY.MM.dd}" } } else { elasticsearch { hosts =&gt; "${ES_HOST}" index =&gt; "logstash-app-log-error-%{+YYYY.MM.dd}" } } } }</code> </pre> </div></div><br><p>  Untuk secara otomatis menghapus indeks usang, saya sarankan menggunakan program dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kurator</a> Elastis.  Peluncuran program ditambahkan ke jadwal Cron, konfigurasinya sendiri dapat disimpan dalam file terpisah. </p><br><div class="spoiler">  <b class="spoiler_title">Sebuah fragmen konfigurasi untuk menghapus indeks usang</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">action: delete_indices description: logstash-app-log-error options: ignore_empty_list: True filters: - filtertype: pattern kind: prefix value: logstash-app-log-error- - filtertype: age source: name direction: older timestring: '%Y.%m.%d' unit: months unit_count: 6</code> </pre> </div></div><br><p>         ,         Filebeat  Logstash,   .    Elasticsearch    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-- </a> , ,    . </p><br><h3 id="kibana"> Kibana </h3><br><p> Kibana        .  -,     Elasticsearch.       . </p><br><p>   Kibana —         Discovery   . ,   Discovery       app   warning  ,    time, message, exception class, host, client_id. </p><br><p>  ,  Discovery       nginx,       404    time, message, request, status. <br>   Kibana   ,        :  ,  ,     . ,       (        ). </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/c1d/feb/5a3/c1dfeb5a364508015c4787f5e457528a.jpg" alt="gambar"></p></div></div><br><h3 id="elastalert"> Elastalert </h3><br><p> Elastalert      Elasticsearch      .  , .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,          . <br>       ,         (),       . </p><br><p>   : </p><br><ul><li>       ALERT, EMERGENCY.  — 10  </li><li>       CRITICAL.  — 30  </li><li>    ,  N   X  M  </li><li>    10 INFO  3  </li><li>   nginx   200, 201, 304     75%  ,     50  </li></ul><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">name: Blacklist ALERT, EMERGENCY type: blacklist index: logstash-app-* compare_key: "level" blacklist: - "ALERT" - "EMERGENCY" realert: minutes: 5 alert: - "slack"</code> </pre></div></div><br><p>             — <strong>  </strong> .       ,      ,   .        Kibana. </p><br><p>    , ,   http-     75%  ,     ,   ,     ,    .  -   ,     ,      ,     . </p><br><p>         , ,  ,     ,       Kibana,        . </p><br><p>    5     .    , ,     ,  ,  ,     . </p><br><p>      ,          .       . </p><br><p>            Kibana    .            . </p><br><h2 id="vsyo-vmeste">   </h2><br><p>      docker-.     ,         ,    staging-  production-,      . </p><br><p>   ,   Elastalert,      .  Elastalert  ,    <br> <code>envsubst &lt; /opt/elastalert/config.dist.yaml &gt; /opt/elastalert/config.yaml</code>  entrypoint-   ,   . </p><br><p>        ,       ,       ,     . </p><br><div class="spoiler"> <b class="spoiler_title">    Makefile       </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">build: docker build -t some-registry/elasticsearch elasticsearch docker build -t some-registry/logstash logstash docker build -t some-registry/kibana kibana docker build -t some-registry/nginx nginx docker build -t some-registry/curator curator docker build -t some-registry/elastalert elastalert push: docker push some-registry/elasticsearch docker push some-registry/logstash docker push some-registry/kibana docker push some-registry/nginx docker push some-registry/curator docker push some-registry/elastalert pull: docker pull some-registry/elasticsearch docker pull some-registry/logstash docker pull some-registry/kibana docker pull some-registry/nginx docker pull some-registry/curator docker pull some-registry/elastalert prepare: docker network create -d bridge elk-network || echo "ok" stop: docker rm -f kibana || true docker rm -f logstash || true docker rm -f elasticsearch || true docker rm -f nginx || true docker rm -f elastalert || true run-logstash: docker rm -f logstash || echo "ok" docker run -d --restart=always --network=elk-network --name=logstash -p 127.0.0.1:5001:5001 -e "LS_JAVA_OPTS=-Xms256m -Xmx256m" -e "ES_HOST=elasticsearch:9200" some-registry/logstash run-kibana: docker rm -f kibana || echo "ok" docker run -d --restart=always --network=elk-network --name=kibana -p 127.0.0.1:5601:5601 --mount source=elk-kibana,target=/usr/share/kibana/optimize some-registry/kibana run-elasticsearch: docker rm -f elasticsearch || echo "ok" docker run -d --restart=always --network=elk-network --name=elasticsearch -e "ES_JAVA_OPTS=-Xms1g -Xmx1g" --mount source=elk-esdata,target=/usr/share/elasticsearch/data some-registry/elasticsearch run-nginx: docker rm -f nginx || echo "ok" docker run -d --restart=always --network=elk-network --name=nginx -p 80:80 -v /root/elk/.htpasswd:/etc/nginx/.htpasswd some-registry/nginx run-elastalert: docker rm -f elastalert || echo "ok" docker run -d --restart=always --network=elk-network --name=elastalert --env-file=./elastalert/.env some-registry/elastalert run: prepare run-elasticsearch run-kibana run-logstash run-elastalert delete-old-indices: docker run --rm --network=elk-network -e "ES_HOST=elasticsearch:9200" some-registry/curator curator --config /curator/curator.yml /curator/actions.yml</code> </pre> </div></div><br><p>      : </p><br><ul><li>    80  nginx,     basic auth  Kibana </li><li>  Logstash  .       ssh- </li><li>       nginx </li><li>    ,  docker- </li><li>           </li><li>          </li><li>       ,  .env-    nginx- </li><li>  *_JAVA_OPTS   ,          4GB RAM (        ES). </li></ul><br><p>  ,          xpack-. </p><br><p>    docker-compose. ,   ,   Dockerfile-,  Filebeat,  Logstash,  ,   ,     ,    ,        VCS. </p><br><p>       .      .     ,    ( Laravel    scheduler), ,     5   .          ALERT.     ,    .    ,     ,      . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  ,      ,    ,           .       . ,   -      .              .   ,   ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456676/">https://habr.com/ru/post/id456676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456662/index.html">Bagaimana cara menghemat uang pada seorang terapis menggunakan pengembangan berbasis tes</a></li>
<li><a href="../id456666/index.html">WebTotem atau bagaimana kita ingin membuat Internet lebih aman</a></li>
<li><a href="../id456668/index.html">Microsoft ML Spark: ekstensi Spark yang menjadikan SparkML lebih manusiawi dan LightGBM sebagai bonus</a></li>
<li><a href="../id456670/index.html">Tentang metode otentikasi yang sangat mata-mata</a></li>
<li><a href="../id456672/index.html">Resep Nginx: pemberitahuan asinkron dari PostgreSQL ke websocket</a></li>
<li><a href="../id456678/index.html">Keadaan elektronik masa depan. Bagian 4</a></li>
<li><a href="../id456680/index.html">Delapan Hukum Penamaan dalam Desain UX (Bagian 2)</a></li>
<li><a href="../id456682/index.html">Perilaku tidak terdefinisi dengan deklarasi fungsi yang tidak digunakan lagi di ANSI C</a></li>
<li><a href="../id456684/index.html">Memperbaiki bug kecil di calc.exe</a></li>
<li><a href="../id456686/index.html">Seluk-beluk wawancara ketika mempekerjakan udalenka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>