<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úâÔ∏è üé¨ üë∏üèø Programa√ß√£o heterog√™nea e oneAPI Toolkit. Palestra improvisada de especialistas da Intel responde √†s suas perguntas üñ≤Ô∏è üí° ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como parte da coluna "Fa√ßa uma pergunta a um especialista da Intel", solicitamos ao especialista em Intel Konstantin Vladimirov que respondesse pergun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o heterog√™nea e oneAPI Toolkit. Palestra improvisada de especialistas da Intel responde √†s suas perguntas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/479486/"><img src="https://habrastorage.org/webt/tz/b5/gv/tzb5gvt-1m1z3yvd4tjzot84ao4.jpeg"><br><br>  Como parte da coluna "Fa√ßa uma pergunta a um especialista da Intel", solicitamos ao especialista em Intel Konstantin Vladimirov que respondesse perguntas relacionadas √† programa√ß√£o heterog√™nea, ao <a href="https//software.intel.com/en-us/oneapi">kit de ferramentas oneAPI</a> e a coisas interessantes relacionadas.  O resultado superou todas as nossas expectativas.  Konstantin n√£o economizou tempo e deu respostas detalhadas e substanciadas, sem medo de ser pol√™mico.  De fato, recebemos uma pequena palestra sobre programa√ß√£o entre arquiteturas em todas as suas formas: descarregar nuances, otimiza√ß√µes, padr√µes e assim por diante. <br>  Transferimos o microfone para o especialista.  Bem, os coment√°rios s√£o dados ao p√∫blico. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta <a href="https://habr.com/ru/users/soarex16/" class="user_link">Soarex16</a> <br><blockquote>  Qu√£o trabalhosa ser√° a transi√ß√£o do OpenCL para o oneAPI e quais benef√≠cios podem ser obtidos com isso? </blockquote><br>  <b>A resposta</b>  Mudar para o DPC ++ pode ser complicado, mas, na minha opini√£o, vale a pena.  Existem dois est√°gios principais. <br><br>  Primeiramente, essa √© uma transi√ß√£o da sua linguagem de programa√ß√£o heterog√™nea (OpenCL, computa√ß√£o Vulkan), que, provavelmente, √© baseada na API.  Aqui voc√™ tem uma vantagem no fato de que voc√™ j√° conhece a √°rea de assunto e a dificuldade est√° em mudar o pensamento do controle direto via API para constru√ß√µes de linguagem um pouco mais impl√≠citas. <br>  Em segundo lugar, essa √© uma transi√ß√£o do seu idioma host.  Se voc√™ descarregou toda a sua vida do C puro, o limite de entrada √© igual ao limite para alternar de C para C ++, que √© bastante alto. <br><br>  Por que tentar? <br><br>  Em primeiro lugar, o DPC ++ faz um √≥timo trabalho para um programador.  Voc√™ esquecer√° muito rapidamente, como um pesadelo, todas essas chamadas expl√≠citas para clXXXYYY, e o que o sexto argumento significa, e se voc√™ esqueceu o c√≥digo de retorno.  Muitos wrappers orientados a objetos n√£o escondem a rotina, mas geralmente com o custo de alternar da API OpenCL padr√£o para a API wrapper n√£o t√£o padr√£o (eu tamb√©m vi essas bicicletas).  No caso do DPC ++, voc√™ simplesmente escreve o SYCL padr√£o com extens√µes Intel (que em breve tamb√©m se tornar√° o SYCL padr√£o). <br><br>  Em segundo lugar, o DPC ++ fornece compila√ß√£o conjunta, ou seja, voc√™ pode ter certeza dos tipos e n√£o ter√° problemas nas bordas da API com dimens√µes, preenchimento, alinhamento.  Voc√™ escreve o c√≥digo do kernel e do host em um arquivo e esse √© o mesmo c√≥digo.  Usando o USM, voc√™ tamb√©m pode trabalhar com estruturas de dados complexas com muito mais facilidade. <br><br>  Em terceiro lugar, o DPC ++ √© C ++ real, ou seja, permite programa√ß√£o generalizada.  Por exemplo, o kernel mais simples para adicionar dois vetores: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> kern = [A, B, C](cl::sycl::id&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; wiID) { C[wiID] = A[wiID] + B[wiID]; <span class="hljs-comment"><span class="hljs-comment">//   A, B  C?  ! };</span></span></code> </pre> <br>  A mesma coisa no OpenCL: <br><br><pre> <code class="cpp hljs">_<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *A, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *B, __global </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *C)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>); C[i] = A[i] + B[i]; }</code> </pre> <br>  Voc√™ v√™, fui for√ßado a apontar para um tipo OpenCL int.  Se eu precisar de um float, precisarei escrever outro kernel ou usar um pr√©-processador ou gera√ß√£o de c√≥digo externo.  Obter quase todos os recursos do C ++ √† sua disposi√ß√£o pode ser um pouco assustador se voc√™ n√£o tiver experi√™ncia com o C ++.  Mas isso √© comum quando se trata de uma grande mudan√ßa tecnol√≥gica. <br><br>  E todos os benef√≠cios n√£o se limitam a isso.  Mencionarei outra coisa nas respostas a seguir. <br><br>  Ent√£o, eu teria baixado o compilador em seu lugar e tentado, pois n√£o √© dif√≠cil fazer isso com o pacote <a href="https://software.intel.com/en-us/oneapi">OneAPI</a> . <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Question <a href="https://habr.com/ru/users/juster/" class="user_link">Juster</a> <br><blockquote>  O OpenVINO e o oneAPI estar√£o de alguma forma relacionados? </blockquote><br>  <b>A resposta</b>  A distribui√ß√£o OpenVINO agora faz parte da distribui√ß√£o OneAPI.  Aprender e usar redes neurais s√£o tarefas computacionalmente dif√≠ceis que se beneficiam muito da programa√ß√£o heterog√™nea.  Acredito que, mais cedo ou mais tarde, todos os componentes OneAPI tornar√£o poss√≠vel o uso de todos os recursos de computa√ß√£o dispon√≠veis: aceleradores gr√°ficos e aceleradores especiais como Nervana e FPGA.  E tudo isso sem sair do paradigma da linguagem e do sistema de tipos do seu programa C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Perguntas do correio <br><blockquote>  Estou tentando entender como o acelerador de hardware de IA ficar√° em tr√™s anos. Por favor, ajude com isso.  Existe uma empresa interessante Graphcore e sua IPU - este dispositivo n√£o √© menos eficiente que o FPGA, mas √© muito mais f√°cil programar - Python com suporte para TensorFlow e outras estruturas.  Acontece que, se as promessas da Graphcore forem cumpridas, n√£o haver√° necessidade de FPGAs no mercado de aprendizado de m√°quina.  O Python √© muito mais conveniente para os cientistas de dados do que o C ++. <br>  Voc√™ concorda que o FPGA n√£o √© adequado para o mercado de aprendizado de m√°quina comparado √†s solu√ß√µes program√°veis ‚Äã‚Äãem Python?  Se o mercado de ML √© perdido, que outros aplicativos FPGA comuns voc√™ v√™? <br>  Em quais aplicativos voc√™ v√™ a necessidade inevit√°vel de programa√ß√£o heterog√™nea, onde voc√™ n√£o pode conviver com ferramentas mais convenientes, como Python? </blockquote><br>  <b>A resposta</b>  Olhei brevemente para que tipo de IPU.  Mais um peda√ßo de ferro no qual todos descarregar√£o.  Esses caras competem com a GPU e com aceleradores especiais, e n√£o com o FPGA. <br><br>  Nas tarefas para as quais uma pe√ßa de hardware especializada √© afiada, ela sempre vence o FPGA, por exemplo, a renderiza√ß√£o de v√≠deo √© melhor em uma placa de v√≠deo etc.  Mas no mundo (inclusive no mundo da ML) existem muitas tarefas para as quais nada de especial foi inventado ou lan√ßado, e aqui o FPGA sempre ser√° indispens√°vel.  Por exemplo, porque existe uma quest√£o de pre√ßo e, para ser barato, uma pe√ßa de hardware especializada deve ser enorme. <br><br>  Suponha agora que a IPU especificada √© realmente legal.  Isso n√£o cancelar√° a programa√ß√£o heterog√™nea; pelo contr√°rio, a presen√ßa de um acelerador t√£o excelente o estimular√°.  E tamb√©m dar√° um avan√ßo gigantesco no OneAPI e no DPC ++, porque mais cedo ou mais tarde algu√©m dir√° "Eu quero usar tanto a sua IPU quanto a minha GPU em um programa".  Bem cedo, porque a programa√ß√£o heterog√™nea √© sobre isso.  Seu significado √© a transfer√™ncia de uma tarefa adequada para um dispositivo adequado.  Uma tarefa pode vir de qualquer lugar.  E esse dispositivo pode ser qualquer coisa, pode at√© ser o mesmo dispositivo em que o programa est√° sendo executado.  Por exemplo, se voc√™ descarregar o kernel escrito no ISPC e utilizar os recursos vetoriais do Xeon ao m√°ximo, poder√° descarreg√°-lo voc√™ mesmo e ainda obter um ganho significativo.  O principal crit√©rio aqui √© desempenho.  Bem, nunca haver√° muita produtividade neste mundo.  Mesmo com os melhores aceleradores do mundo. <br><br>  Quanto ao Python e sua conveni√™ncia ... Devo admitir imediatamente que n√£o gosto de linguagens dinamicamente digitadas: elas s√£o lentas e, em vez de um erro de compila√ß√£o normal, voc√™ deve esperar duas horas antes de cair no tempo de execu√ß√£o devido ao tipo errado.  Mas n√£o vejo como √© ruim fazer as mesmas descargas no Python.  A prop√≥sito, o OneAPI j√° inclui o Intel Distribution for Python, o que √© extremamente conveniente para v√°rias revis√µes. <br><br>  Ou seja, no mundo dos sonhos dos amantes de Python, voc√™ escreve um programa e o transfere para todos os aceleradores que pode encontrar usando o OneAPI, e n√£o para um monte de bibliotecas espec√≠ficas de fornecedores.  Outra coisa √© que, com essa abordagem, voc√™ perde a digita√ß√£o de ponta a ponta e retorna ao mundo extremamente prec√°rio da programa√ß√£o baseada em API.  Talvez o desenvolvimento do DPC ++ incentive a comunidade a usar mais ativamente ferramentas mais apropriadas, como C ++. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  Desempenho versus OpenCL.  Deve haver impostos sobre o luxo - ou seja,  custos indiretos.  Existem medidas? </blockquote><br>  <b>A resposta</b>  Na Internet, voc√™ pode encontrar muitas medi√ß√µes com diversos resultados, dependendo do compilador, da tarefa e da qualidade da implementa√ß√£o.  Como uma pesquisa pessoal, avaliei tarefas simples (SGEMM, DGEMM) no meu laptop (gr√°ficos integrados do Skylake) e vi que, at√© agora, h√° algum problema (em porcentagem).  Mas parece-me que isso √© uma conseq√º√™ncia do fato de que tudo isso √© beta at√© agora. <br><br>  Em teoria, o resultado deve ser acelera√ß√£o, n√£o desacelera√ß√£o, ou seja, em princ√≠pio, todo esse luxo deve ter um valor negativo.  √â tudo sobre o compilador.  Quando seu programa consiste em uma √∫nica fonte e √© processado como um √∫nico programa, o compilador obt√©m oportunidades fant√°sticas e incr√≠veis de otimiza√ß√£o: definindo c√≥digo comum, invertendo loops, reorganizando se√ß√µes de c√≥digo e tudo o mais que o compilador simplesmente n√£o pode fazer na abordagem baseada em API, mas mais cedo ou mais tarde, ela definitivamente aprender√° com um √∫nico modelo de fonte. <br><br>  Al√©m disso, o DPC ++ ter√° um custo negativo em termos de tempo de desenvolvimento.  Um exemplo simples s√£o os acessadores SYCL, que o compilador j√° est√° usando para organizar eventos e gerenciar filas ass√≠ncronas. <br><br><pre> <code class="cpp hljs">deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> C = bufferC.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh); .... deviceQueue.submit([&amp;](cl::sycl::handler &amp;cgh) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> A = bufferA.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> B = bufferB.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_read&gt;(cgh); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> D = bufferD.<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> get_access&lt;sycl_write&gt;(cgh);</code> </pre><br>  Aqui, o compilador v√™ que os dois pacotes apenas l√™em A e B e escrevem buffers independentes C e D; como resultado, ele v√™ a capacidade de envi√°-los em paralelo, se houver tamanhos globais suficientes. <br><br>  Obviamente, um programa OpenCL gravado de forma pedestre tamb√©m pode faz√™-lo, mas o tempo de desenvolvimento gasto com um kernel n√£o trivial n√£o ser√° compar√°vel. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  Todas as maneiras de otimizar aplicativos OpenCL para DPC ++ s√£o relevantes?  O que h√° de novo a ser adicionado a eles? </blockquote><br>  <b>A resposta</b>  Eu diria que a maior parte da sutil otimiza√ß√£o manual que est√° sendo feita pelos gravadores do kernel pode e deve ser feita pelo compilador.  Da mesma forma, por exemplo, considero uma pr√°tica prejudicial instalar manualmente um assembler em linha em programas C ++, porque mesmo que ofere√ßa benef√≠cios t√°ticos, ele interfere nas otimiza√ß√µes e atua como um fator negativo no desenvolvimento e na transfer√™ncia de um produto.  Bem, o OpenCL agora tamb√©m √© montador. <br><br>  Quanto √† resposta mais detalhada, tenho medo do abismo aqui.  Por exemplo, existe um documento Intel bem conhecido "Guia do desenvolvedor OpenCL para gr√°ficos de processador Intel".  E h√° uma <a href="https://software.intel.com/en-us/iocl-opg-avoiding-needless-synchronization">se√ß√£o</a> sobre como tentar, para n√£o colocar onde o excesso de sincroniza√ß√£o. <br><br>  Portanto, do meu ponto de vista, essa √© uma tarefa n√£o humana em princ√≠pio.  As pessoas s√£o extremamente pobres em raciocinar sobre a sincroniza√ß√£o multithread e tendem a esculpir a sincroniza√ß√£o de maneira conservadora ou incorreta, ou ambas ao mesmo tempo - coloquei v√≠rgulas como essa ( <i>mas foi corrigida - nota editorial</i> ). <br><br>  Por outro lado, no DPC ++, em vez de escrever c√≥digo com barreiras expl√≠citas, assim: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (t = <span class="hljs-number"><span class="hljs-number">0</span></span>; t &lt; numTiles; t++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledRow = TS * t + row; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tiledCol = TS * t + col; Asub[col][row] = A[globalRow * AY + tiledCol]; Bsub[col][row] = B[tiledRow * BY + globalCol]; <span class="hljs-comment"><span class="hljs-comment">// Synchronise to make sure the tile is loaded barrier(CLK_LOCAL_MEM_FENCE); // .... etc ....</span></span></code> </pre> <br>  Voc√™ provavelmente escrever√° uma itera√ß√£o expl√≠cita de <i>parallel_for_work_group</i> , dentro da qual <i>group.parallel_for_work_item</i> <br><br><pre> <code class="cpp hljs">cgh.parallel_for_work_group&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mxm_kernel</span></span></span><span class="hljs-class">&gt;( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cl</span></span></span><span class="hljs-class">:</span></span>:sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{BIG_AX / TS, BIG_BY / TS}, cl::sycl::range&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;{TS, TS}, [=](cl::sycl::group&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; group) { <span class="hljs-comment"><span class="hljs-comment">// .... etc .... for (int t = 0; t &lt; numTiles; t++) { group.parallel_for_work_item([&amp;](cl::sycl::h_item&lt;2&gt; it) { // .... etc .... Asub[col][row] = A[globalRow][tiledCol]; Bsub[col][row] = B[tiledRow][globalCol]; }); //      ,   </span></span></code> </pre> <br>  Como resultado, voc√™ n√£o precisa definir a sincroniza√ß√£o manualmente, e toda a se√ß√£o pode ser descartada. <br><br>  E assim voc√™ pode andar em todas as se√ß√µes.  Algo vai sobreviver, algo vai sair.  Prevejo o surgimento de um novo documento "Otimiza√ß√£o para DPC ++", mas o tempo deve passar, pois todas as t√©cnicas realmente √∫teis s√£o desenvolvidas apenas mais tarde e com sangue <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  H√° uma limita√ß√£o no OpenCL - voc√™ n√£o pode usar "dados distantes" no kernel, ou seja, por exemplo, implementar um "filtro amplo" que usa dados de entrada de um grande grupo de pixels maior que o grupo de trabalho OpenCL em um c√°lculo.  O que o DPC ++ oferece a esse respeito? </blockquote><br>  <b>A resposta</b>  Bem, isso √© imposs√≠vel.  Obviamente, n√£o escrevo kernels em particular ... Mas √© absolutamente certo que voc√™ pode usar toda a mem√≥ria global como ela √©, basta garantir que trabalhe com opera√ß√µes at√¥micas (ou sincronize externamente os kernels hier√°rquicos).  E voc√™ tamb√©m pode conectar o System SVM (bem, ou o USM no DPC ++). <br><br>  Infelizmente, tudo isso √© extremamente ineficiente, e eu n√£o gosto de todos esses truques.  Al√©m disso, eles s√£o dif√≠ceis de otimizar pelo compilador. <br><br>  E assim, se falamos de solu√ß√µes diretas e eficazes, √© claro que n√£o h√° m√°gica no DPC ++.  No final, seu programa ainda est√° dividido em partes: o c√≥digo do host e o c√≥digo do dispositivo, e todas as restri√ß√µes do dispositivo afetam o c√≥digo do dispositivo.  O tamanho m√°ximo do grupo de trabalho √© o paralelismo real de que seu hardware √© capaz.  Tudo o que est√° em cima disso s√£o apenas maneiras de sair, afetando drasticamente o desempenho.  √â por isso que o DPC ++ oferece uma oportunidade para fazer isso: <i>device.get_info &lt;sycl :: info :: device :: max_work_group_size&gt; ()</i> e depois decide como viver com o n√∫mero resultante. <br><br>  Seria tentador, √© claro, criar um modelo no DPC ++, quando o programador trabalha como voc√™ gosta com loops de qualquer tamanho, e o compilador examina o que fazer a seguir, mas seria mortalmente errado, porque ocultaria constantes e at√© assint√≥ticos de complexidade adicional computa√ß√£o aparecendo do nada.  Por outro motivo, Alexandrescu escreveu que "encapsular a complexidade deve ser considerado um crime", e isso tamb√©m se aplica. <br><br>  √Äs vezes, revisar o pr√≥prio algoritmo ajuda.  Aqui, o DPC ++ facilita as coisas porque √© mais f√°cil refatorar um c√≥digo mais estruturado.  Mas isso √© t√£o consolador. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  O DPC ++ √© baseado em SYCL.  Mas e se voc√™ for mais fundo, quais s√£o as diferen√ßas do OpenCL na implementa√ß√£o do backend, se houver.  Por exemplo, o mecanismo de distribui√ß√£o entre dispositivos heterog√™neos √© o mesmo que o OpenCL? </blockquote><br>  <b>A resposta</b>  Se voc√™ se esconder, esse √© o OpenCL.  Todas as vantagens e vantagens do SYCL s√£o as vantagens e os pontos fortes do idioma, ou seja, o frontend.  Do front-end, vem o bom e velho SPIRV, que vai para o back-end e l√° √© otimizado (geralmente j√° em tempo de execu√ß√£o, ou seja, √© JIT) j√° para uma placa de v√≠deo espec√≠fica da mesma maneira que o OpenCL seria otimizado para ela. <br><br>  Outra coisa √© que o mecanismo de distribui√ß√£o de trabalho entre dispositivos heterog√™neos √© apenas mais front-end que back-end, porque √© o c√≥digo do host que decide o que enviar e para onde.  E o c√≥digo do host √© obtido no DPC ++.  Eu j√° mostrei um exemplo um pouco mais alto de como o compilador pode, com base nos acessadores, tomar uma decis√£o sobre pacotes paralelos.  E esta √© apenas a ponta do iceberg. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  Bibliotecas  Sim, n√£o estamos falando de CUDA.  Mas sabemos que, para desenvolvedores de CUDA, existem bibliotecas muito √∫teis que funcionam com alto desempenho na GPU.  O OneAPI tamb√©m cont√©m algumas bibliotecas, mas, por exemplo, <a href="https://software.intel.com/en-us/ipp">IPP</a> - n√£o h√° nada √∫til de arquivamento para trabalhar com imagens no oneAPI / OpenCL.  Haver√° algo e como, neste caso, mudar de CUDA para oneAPI? </blockquote><br>  <b>A resposta</b>  A transi√ß√£o da CUDA para um √∫nico padr√£o aberto ser√° dif√≠cil, mas inevit√°vel.  Obviamente, a CUDA agora tem uma infraestrutura mais madura.  Mas as caracter√≠sticas de seu licenciamento s√£o uma desvantagem de bloqueio, porque cada vez mais players aparecem no mercado de sistemas heterog√™neos, cart√µes e aceleradores cada vez mais interessantes de diferentes fabricantes. <br><br>  A diversidade de APIs existentes dificulta o uso desse mundo de possibilidades para programadores com experi√™ncia na CPU cl√°ssica.  O que leva ao OneAPI ou algo parecido.  Aqui a m√°gica n√£o est√° na inova√ß√£o da Intel nos gr√°ficos, mas no fato de que a Intel abre a porta do DPC ++ para todos.  N√≥s nem possu√≠mos o padr√£o SYCL, ele pertence ao grupo Khronos e todas as extens√µes Intel s√£o extens√µes no Khronos onde qualquer pessoa pode se comprometer (e h√° representantes de todos os principais players do pa√≠s).  E isso significa que (as bibliotecas) e a comunidade aparecer√£o (j√° est√£o aparecendo) e v√°rias vagas nessa dire√ß√£o. <br><br>  E, √© claro, o IPP ser√° reescrito para novas realidades.  N√£o tenho nada a ver com IPP, mas o uso do DPC ++ √© senso comum, e pessoas s√£s est√£o sentadas l√°. <br><br>  Mas o mais importante √© que agora √© o momento da hist√≥ria em que voc√™ pode escrever sua pr√≥pria biblioteca, que ultrapassar√° o IPP e que o mundo inteiro usar√°.  Porque os padr√µes abertos sempre vencem. <br><br><img src="https://habrastorage.org/webt/pb/_f/jj/pb_fjj71wjkak3kyklvojjcao5w.png" alt="imagem">  Pergunta do correio <br><blockquote>  Se compararmos o lan√ßamento de algoritmos de redes neurais de treinamento e infer√™ncia no Nervana e FPGA - quais s√£o as diferen√ßas na programa√ß√£o e a efici√™ncia resultante? </blockquote><br>  <b>A resposta</b>  N√£o sei nada sobre detalhes de programa√ß√£o de FPGA, escrevo compiladores.  Mas eu tenho uma contra-pergunta.  E como vamos comparar?  Em benchmarks padr√£o, √© antidesportivo, Nervana lambeu embaixo deles.  Mas caso voc√™ tenha algo interessante, o FPGA desamarra as suas m√£os, e colocar isso em Nervana pode ser longo, caro, s√≥ isso. <br><br>  Acontece que a pergunta em si √©, por assim dizer, da s√©rie "quem √© mais forte que um elefante ou uma baleia".  Mas essa n√£o √© uma pergunta real.  A verdadeira quest√£o √©: como aproveitar um elefante e uma baleia em um carrinho?  Bem, ou pelo menos distribua, digamos, um elefante para pux√°-lo por terra e uma baleia por mar. <br><br>  No caso do OneAPI, voc√™ ter√° o mesmo programa, em geral, em C ++ padr√£o.  E voc√™ pode escrev√™-lo e execut√°-lo com descarregamento para frente e para tr√°s.  Essa ser√° a mesma tarefa que lhe interessa, na qual voc√™ mesmo pode medir e otimizar o desempenho.  Um padr√£o √∫nico e uma interface √∫nica para dispositivos heterog√™neos ser√£o um passo para comparar ma√ß√£s com ma√ß√£s em tais assuntos. <br><br>  Por exemplo: ‚Äúo que √© melhor para% da minha tarefa% do ponto de vista da facilidade de programa√ß√£o e efici√™ncia - coloque essa parte no FPGA, deixe essa no Nervana ou divida essa parte em duas e reescreva essa parte para a GPU?‚Äù <br><br>  E a hist√≥ria toda com a OneAPI - √© apenas para voc√™ dizer: "por que pensar nisso por um longo tempo, vou tentar agora rapidamente, √© SIMPLES". <br><br>  Ainda n√£o, n√£o √© f√°cil.  Mas haver√°. <br><br><hr><br>  <b>Posf√°cio do especialista</b> <br><br>  Obrigado a todos por suas perguntas.  √â poss√≠vel e at√© prov√°vel que eu estivesse errado, impreciso e cometi erros.  Acontece que, na Internet, constantemente algu√©m est√° errado. <br><br>  Espero poder interessar algu√©m em programa√ß√£o heterog√™nea e DPC ++.  Quero recomendar a todos o site <a href="https://sycl.tech/">sycl.tech</a> , onde <a href="https://sycl.tech/">existem muitos</a> relat√≥rios, inclusive de especialistas de renome mundial (√© necess√°rio ingl√™s) <br><br>  Bom para todos! <br><br>  <i>PS do editor.</i>  <i>Desta vez, por decis√£o un√¢nime do conselho editorial, foi decidido atribuir o pr√™mio pela melhor pergunta ... ao autor das respostas.</i>  <i>Eu acho que voc√™ concorda que isso √© justo.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479486/">https://habr.com/ru/post/pt479486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479468/index.html">Edge of Honesty e John Doe</a></li>
<li><a href="../pt479474/index.html">Por que a auto-organiza√ß√£o de equipes √© t√£o importante no Scrum e por que n√£o pode haver gerentes nele</a></li>
<li><a href="../pt479478/index.html">Plug-in Java sem problemas</a></li>
<li><a href="../pt479480/index.html">SARIF SDK e seus erros</a></li>
<li><a href="../pt479482/index.html">SARIF SDK e seus erros</a></li>
<li><a href="../pt479488/index.html">De um laptop - um servidor dom√©stico com energia redundante ao roteador Mikrotik</a></li>
<li><a href="../pt479492/index.html">Computa√ß√£o sem servidor baseada no OpenWhisk, parte 3</a></li>
<li><a href="../pt479496/index.html">Analisando tarefas WTF em JavaScript</a></li>
<li><a href="../pt479498/index.html">Como o tempo linear se transforma no Windows em O (n¬≤)</a></li>
<li><a href="../pt479502/index.html">Como sobreviver √† era glacial mais severa da hist√≥ria da Terra?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>