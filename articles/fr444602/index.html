<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎫 🈲 🐳 Encapsulation en C ++ et C 🤬 👨‍🏫 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Définition 


 L'encapsulation est un ensemble d'outils pour contrôler l'accès aux données ou aux méthodes qui gèrent ces données. Une définition déta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encapsulation en C ++ et C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444602/"><p><img src="https://habrastorage.org/webt/uq/da/c9/uqdac9e3znu_dgoypeekipj7so8.png"></p><br><h1 id="opredelenie">  Définition </h1><br><p>  L'encapsulation est un ensemble d'outils pour contrôler l'accès aux données ou aux méthodes qui gèrent ces données.  Une définition détaillée du terme «encapsulation» peut être trouvée dans ma précédente publication sur le Habré à ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> .  Cet article se concentre sur les exemples d'encapsulation en C ++ et C. </p><br><h1 id="inkapsulyaciya-v-si">  Encapsulation en C ++ </h1><br><p> Par défaut, dans une classe ( <code>class</code> ), les données et les méthodes sont privées ( <code>private</code> );  ils ne peuvent être lus et modifiés que par la classe à laquelle ils appartiennent.  Le niveau d'accès peut être modifié à l'aide des mots clés appropriés fournis par C ++. </p><br><p>  Plusieurs qualificatifs sont disponibles en C ++ et modifient l'accès aux données comme suit: </p><a name="habracut"></a><br><ul><li>  les données publiques sont accessibles à tous; </li><li>  protégé ( <code>protected</code> ) - disponible uniquement pour la classe et les classes enfants; </li><li>  privé - <code>private</code> - disponible uniquement pour la classe à laquelle ils appartiennent. </li></ul><br><p>  Par souci de concision, seuls deux niveaux (privé et public) seront mis en évidence dans les exemples. </p><br><h2 id="primer-inkapsulyacii">  Exemple d'encapsulation </h2><br><p>  Dans la classe <code>Contact</code> , les variables et méthodes publiques sont accessibles depuis le programme principal.  Les variables et méthodes privées ne peuvent être lues, appelées ou modifiées que par la classe elle-même. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; int main() { Contact Tony; Tony.print_numbers(); // cout &lt;&lt; Tony.mobile_number &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Tenter d'imprimer ou de modifier la variable privée <code>mobile_number</code> partir du programme principal ( <code>main</code> ) provoquera une erreur de compilation car l'accès aux données privées de la classe est limité. </p><br><h2 id="narushenie-inkapsulyacii-s-druzyami-horoshaya-praktika">  Violation d'encapsulation avec des amis (bonne pratique) </h2><br><p>  En C ++, il y a le mot-clé «ami» qui vous permet d'ajouter des exceptions aux règles générales d'accès aux données.  Si une fonction ou une classe s'appelle un ami de la classe <code>Contact</code> , ils bénéficient d'un accès gratuit à des données protégées ou privées. </p><br><p>  Il y a deux règles de base de l'amitié - l'amitié n'est pas héritée et non mutuelle.  De plus, la présence d '«amis» ne modifie pas le niveau de sécurité des données - les données privées restent privées à l'exception des «amis». </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } // Declaring a global 'friend' function friend void print_numbers( Contact some_contact ); }; void print_numbers( Contact some_contact ) { cout &lt;&lt; "Mobile number: " &lt;&lt; some_contact.mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; some_contact.home_number &lt;&lt; endl; } int main() { Contact Tony; print_numbers(Tony); return 0; }</span></span></span></span></code> </pre> <br><p>  Dans cet exemple, la fonction <code>print_numbers()</code> est une fonction normale, pas une méthode de la classe <code>Contact</code> .  Déclarer la fonction <code>print_numbers()</code> «ami» de la classe <code>Contact</code> est la seule raison pour laquelle la fonction <code>print_numbers()</code> a accès à des données privées.  Si vous supprimez la ligne avec la définition d'un ami, le code ne sera pas compilé. </p><br><p>  <em>Remarque</em> : il est préférable de ne pas abuser d'amis.  L'ajout d'un ami doit être considéré comme une exception et non comme une pratique générale. </p><br><h2 id="narushenie-inkapsulyacii-s-preobrazovaniem-tipov-i-ukazatelyami-plohaya-praktika">  Violation d'encapsulation avec conversion de type et pointeurs (mauvaise pratique) </h2><br><p>  Tout d'abord, il convient de noter que l'utilisation de pointeurs et de conversion de type de cette manière est une mauvaise idée.  Cette méthode ne garantit pas la réception des données nécessaires.  Il est mal lu et mal entretenu.  Malgré cela, il existe. </p><br><p>  C ++ a hérité de nombreux outils de C, dont l'un est le <code>typecasting</code> .  Par défaut, toutes les variables et méthodes de la classe sont privées.  Dans le même temps, le niveau standard d'accès aux données dans la structure ( <code>struct</code> ) est public.  Il est possible de créer une structure ou une classe entièrement publique dans laquelle les données seront localisées de manière identique aux données de la classe <code>Contact</code> et en utilisant la conversion de type pour accéder aux données privées. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Contact { private: int mobile_number; // private variable int home_number; // private variable public: Contact() // constructor { mobile_number = 12345678; home_number = 87654321; } void print_numbers() { cout &lt;&lt; "Mobile number: " &lt;&lt; mobile_number; cout &lt;&lt; ", home number: " &lt;&lt; home_number &lt;&lt; endl; } }; struct Contact_struct { int mobile_number; int home_number; }; int main() { Contact Tony; Contact_struct * structured_Tony; Tony.print_numbers(); structured_Tony = (Contact_struct *) &amp; Tony; structured_Tony-&gt;mobile_number = 20; structured_Tony-&gt;home_number = 30; Tony.print_numbers(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Les données privées ont été lues et modifiées en raison de la conversion de type</em> </p><br><h1 id="inkapsulyaciya-v-si-1">  Encapsulation C </h1><br><p>  L'encapsulation est traditionnellement considérée comme l'un des principes clés de la POO.  Cependant, cela ne limite pas l'utilisation de ce principe dans les langues orientées vers la procédure.  En C, l'encapsulation est utilisée depuis longtemps, malgré l'absence des mots-clés «privé» et «public». </p><br><h2 id="privatnye-peremennye">  Variables privées </h2><br><p>  Dans le cadre de l'encapsulation, toutes les données en C peuvent être considérées comme publiques par défaut.  Le niveau d'accès aux variables dans les structures ( <code>struct</code> ) peut être changé en privé si leur définition est isolée du programme principal.  L'effet souhaité peut être obtenu en utilisant des fichiers d'en-tête (en-tête, .h) et de source (source, .c) distincts. </p><br><p>  Dans cet exemple, la structure a été définie dans un fichier source séparé "private_var.c".  Étant donné que l'initialisation de la structure en C nécessite l'allocation et la libération de mémoire, plusieurs fonctions d'assistance ont été ajoutées. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } void delete_contact( struct Contact * some_contact ) { free(some_contact); }</span></span></span></span></code> </pre> <br><p>  Dans le fichier d'en-tête correspondant "private_var.h", la structure <code>Contact</code> été déclarée, mais son contenu est resté caché au programme principal. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_VAR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_VAR struct Contact; struct Contact * create_contact(); void delete_contact( struct Contact * some_contact ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_VAR */</span></span></span></span></code> </pre> <br><p>  Ainsi, pour «main.c», le contenu de la structure est inconnu et les tentatives de lecture ou de modification des données privées entraîneront une erreur de compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // printf( "Mobile number: %d\n", Tony-&gt;mobile_number); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-peremennym-s-ukazatelyami">  Accéder aux variables privées avec des pointeurs </h2><br><p>  La conversion de type peut être utilisée pour surmonter l'encapsulation en C comme en C ++, mais cette approche a déjà été décrite.  Sachant que, dans la structure, les données sont organisées dans l'ordre de leur déclaration, les pointeurs et l'arithmétique des pointeurs conviennent pour atteindre l'objectif. </p><br><p>  L'accès aux variables de la structure est limité.  Cependant, seules les variables sont masquées, pas la mémoire dans laquelle les données sont stockées.  Les pointeurs peuvent être considérés comme une référence à l'adresse mémoire, et si cette mémoire est disponible pour le programme, les données stockées dans cette mémoire peuvent être lues et modifiées.  Si le pointeur est affecté à la mémoire dans laquelle la structure stocke ses données - elles peuvent être lues.  En utilisant la même définition de structure (les mêmes fichiers «.c» et «.h») et le fichier «main.c» modifié, la restriction d'accès a été surmontée. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_var.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); int * mobile_number_is_here = (int *)Tony; printf("Mobile number: %d\n", *mobile_number_is_here); int * home_number_is_here = mobile_number_is_here + 1; *home_number_is_here = 1; printf("Modified home number: %d\n", *home_number_is_here); delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Les données de la structure ont été lues et modifiées</em> </p><br><h2 id="privatnye-funkcii">  Fonctions privées </h2><br><p>  Les fonctions, étant externes (externes) par défaut, sont visibles dans toute l' <code>translation unit</code> dite de <code>translation unit</code> .  En d'autres termes, si plusieurs fichiers sont compilés ensemble en un seul fichier objet, n'importe lequel de ces fichiers pourra accéder à n'importe quelle fonction à partir de n'importe quel autre fichier.  L'utilisation du <code>static</code> - <code>static</code> "statique" lors de la création d'une fonction limitera sa visibilité au fichier dans lequel elle a été définie. Par conséquent, pour garantir la confidentialité de la fonction, vous devez effectuer plusieurs étapes: </p><br><ul><li>  la fonction doit être déclarée statique ( <code>static</code> ) soit dans le fichier source (.c) soit dans le fichier d'en-tête correspondant (.h); </li><li>  la définition de la fonction doit être dans un fichier source séparé. </li></ul><br><p>  Dans cet exemple, la fonction statique <code>print_numbers()</code> été définie dans le fichier «private_funct.c».  Par ailleurs, la fonction <code>delete_contact()</code> appelle avec succès <code>print_numbers()</code> car ils sont dans le même fichier. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Contact { int mobile_number; int home_number; }; struct Contact * create_contact() { struct Contact * some_contact; some_contact = malloc(sizeof(struct Contact)); some_contact-&gt;mobile_number = 12345678; some_contact-&gt;home_number = 87654321; return( some_contact ); } static void print_numbers( struct Contact * some_contact ) { printf("Mobile number: %d, ", some_contact-&gt;mobile_number); printf("home number = %d\n", some_contact-&gt;home_number); } void delete_contact( struct Contact * some_contact ) { print_numbers(some_contact); free(some_contact); }</span></span></span></span></code> </pre> <br><p>  Dans le fichier d'en-tête correspondant "private_funct.h", <code>print_numbers()</code> été déclaré comme une fonction statique. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PRIVATE_FUNCT_H struct Contact; struct Contact * create_contact(); static void print_numbers( struct Contact * some_contact ); void delete_contact( struct Contact * my_points ); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PRIVATE_FUNCT_H */</span></span></span></span></code> </pre> <br><p>  Le programme principal, «main.c», appelle avec succès <code>print_numbers()</code> indirectement via <code>delete_contact()</code> , car les deux fonctions sont dans le même document.  Cependant, une tentative d'appeler <code>print_numbers()</code> partir du programme principal <code>print_numbers()</code> erreur. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"private_funct.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main() { struct Contact * Tony; Tony = create_contact(); // print_numbers( Tony ); // will cause compile time error delete_contact( Tony ); return 0; }</span></span></span></span></code> </pre> <br><h2 id="poluchenie-dostupa-k-privatnym-funkciyam">  Accès aux fonctionnalités privées </h2><br><p>  Il est <code>print_numbers()</code> appeler <code>print_numbers()</code> depuis le programme principal.  Pour ce faire, vous pouvez utiliser le mot-clé <code>goto</code> ou passer un pointeur vers une fonction privée dans <code>main</code> .  Les deux méthodes nécessitent des modifications soit dans le fichier source «private_funct.c», soit directement dans le corps de la fonction elle-même.  Étant donné que ces méthodes ne contournent pas l'encapsulation et l'annulent, elles dépassent le cadre de cet article. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  L'encapsulation existe en dehors des langages POO.  Les langages POO modernes rendent l'utilisation de l'encapsulation pratique et naturelle.  Il existe de nombreuses façons de contourner l'encapsulation et éviter les pratiques douteuses aidera à la préserver en C et C ++. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444602/">https://habr.com/ru/post/fr444602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444592/index.html">L'armée américaine prévoit d'utiliser un nouveau type d'exosquelette</a></li>
<li><a href="../fr444594/index.html">Gros o</a></li>
<li><a href="../fr444596/index.html">Iodide: Mozilla Interactive Science Editor</a></li>
<li><a href="../fr444598/index.html">Le CD a 40 ans et il est mort (n'est-ce pas?)</a></li>
<li><a href="../fr444600/index.html">Évaluation de 14 cm sans tête 2019</a></li>
<li><a href="../fr444610/index.html">Statistiques et suivi des scripts PHP en temps réel. ClickHouse et Grafana vont aider Pinba</a></li>
<li><a href="../fr444612/index.html">Dommages macro pour le code C ++</a></li>
<li><a href="../fr444614/index.html">Toute l'histoire de Linux. Partie II: hauts et bas des entreprises</a></li>
<li><a href="../fr444616/index.html">Création de votre propre enregistreur vocal Android à l'aide de Kotlin</a></li>
<li><a href="../fr444620/index.html">Utilisation de fichiers de séquence de noyau Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>