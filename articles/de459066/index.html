<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì© ‚õëÔ∏è üßòüèº Datenbank-Schreib- und Leseausgleich üë©üèø‚Äçüöí üêò üëí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem fr√ºheren Artikel habe ich das Konzept und die Implementierung einer Datenbank beschrieben, die auf Funktionen basiert und nicht auf Tabellen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenbank-Schreib- und Leseausgleich</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lsfusion/blog/459066/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0w/wi/gl/0wwiglioocbaxcpjodrzg5x1ocs.jpeg" alt="Bild"></div><br>  In einem fr√ºheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel habe</a> ich das Konzept und die Implementierung einer Datenbank beschrieben, die auf Funktionen basiert und nicht auf Tabellen und Feldern wie in relationalen Datenbanken.  Es gab viele Beispiele, die die Vorteile dieses Ansatzes gegen√ºber dem Klassiker zeigten.  Viele fanden sie nicht √ºberzeugend genug. <br><br>  In diesem Artikel werde ich zeigen, wie Sie mit diesem Konzept das Schreiben und Lesen in der Datenbank schnell und bequem ausgleichen k√∂nnen, ohne die Arbeitslogik zu √§ndern.  Sie versuchten, √§hnliche Funktionen in modernen kommerziellen DBMS (insbesondere Oracle und Microsoft SQL Server) zu implementieren.  Am Ende des Artikels werde ich zeigen, was mit ihnen passiert ist, um es milde auszudr√ºcken, nicht sehr. <br><a name="habracut"></a><br><h3>  Beschreibung </h3><br>  Zum besseren Verst√§ndnis beginne ich die Beschreibung nach wie vor mit Beispielen.  Angenommen, wir m√ºssen eine Logik implementieren, die eine Liste der Abteilungen mit der Anzahl der Mitarbeiter und ihrem Gesamtgehalt zur√ºckgibt. <br><br>  In einer funktionalen Datenbank sieht es folgenderma√üen aus: <br><div class="scrollable-table"><table><tbody><tr><td><code><font color="#a626a4">CLASS</font> Department ''; <br> name '' = <font color="#a626a4">DATA</font> <font color="#a626a4">STRING</font> [ <font color="#986801">100</font> ] (Department); <br> <br> <font color="#a626a4">CLASS</font> Employee ''; <br> department '' = <font color="#a626a4">DATA</font> Department (Employee); <br> salary '' = <font color="#a626a4">DATA</font> <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] (Employee); <br> <br> countEmployees '- ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> department(Employee e) = d; <br> salarySum ' ' (Department d) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d; <br> <br> SELECT name(Department d), countEmployees(d), salarySum(d); <br></code> </td></tr></tbody></table></div>  Die Komplexit√§t der Ausf√ºhrung dieser Abfrage in einem DBMS entspricht <i>O (Anzahl der Mitarbeiter)</i> , da Sie f√ºr diese Berechnung die gesamte Tabelle der Mitarbeiter scannen und sie dann nach Abteilungen gruppieren m√ºssen.  Abh√§ngig vom gew√§hlten Plan <i>O (Protokollanzahl der Mitarbeiter)</i> oder <i>O (Anzahl der Abteilungen)</i> f√ºr die Gruppierung usw. wird es auch einige kleine (wir glauben, dass es viel mehr Mitarbeiter als Abteilungen gibt) Erg√§nzungen geben. <br><br>  Es ist klar, dass der Aufwand f√ºr die Ausf√ºhrung in verschiedenen DBMS unterschiedlich sein kann, aber die Komplexit√§t wird sich in keiner Weise √§ndern. <br><br>  In der vorgeschlagenen Implementierung bildet das funktionale DBMS eine Unterabfrage, die die erforderlichen Werte f√ºr die Abteilung berechnet und dann eine Verkn√ºpfung mit der Abteilungstabelle erstellt, um den Namen zu erhalten.  Bei der Deklaration kann jedoch f√ºr jede Funktion ein spezieller MATERIALISIERTER Marker angegeben werden.  Das System erstellt automatisch ein geeignetes Feld f√ºr jede dieser Funktionen.  Wenn sich ein Funktionswert √§ndert, √§ndert sich der Feldwert in derselben Transaktion.  Beim Zugriff auf diese Funktion wird bereits ein Rechtsbehelf gegen das berechnete Feld eingelegt. <br><br>  Insbesondere wenn Sie MATERIALISIERT f√ºr die Funktionen <i>countEmployees</i> und <i>SalarySum eingeben</i> , werden in der Tabelle mit der Liste der Abteilungen zwei Felder hinzugef√ºgt, in denen die Anzahl der Mitarbeiter und ihr Gesamtgehalt gespeichert werden.  Bei jeder √Ñnderung der Mitarbeiter, ihrer Geh√§lter oder der Zugeh√∂rigkeit zu Abteilungen √§ndert das System automatisch die Werte dieser Felder.  Die obige Abfrage beginnt direkt mit dem Zugriff auf diese Felder und wird f√ºr <i>O (Anzahl der Abteilungen) ausgef√ºhrt</i> . <br><br>  Was sind die Einschr√§nkungen?  Nur eines: Eine solche Funktion muss eine endliche Anzahl von Eingabewerten haben, f√ºr die ihr Wert definiert ist.  Andernfalls ist es unm√∂glich, eine Tabelle zu erstellen, in der alle Werte gespeichert sind, da es keine Tabelle mit einer unendlichen Anzahl von Zeilen geben kann. <br><br>  Ein Beispiel: <br><div class="scrollable-table"><table><tbody><tr><td> <code>employeesCount '    &gt; N' (Department d, <font color="#a626a4">NUMERIC</font> [ <font color="#986801">10</font> , <font color="#986801">2</font> ] N) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> salary(Employee e) <font color="#a626a4">IF</font> department(e) = d <font color="#a626a4">AND</font> salary(e) &gt; N; <br></code> </td></tr></tbody></table></div>  Diese Funktion ist f√ºr eine unendliche Anzahl von Werten der Zahl N definiert (zum Beispiel ist jeder negative Wert geeignet).  Daher kann es nicht MATERIALISIERT werden.  Dies ist also eine logische und keine technische Einschr√§nkung (dh nicht, weil wir dies nicht implementieren konnten).  Ansonsten keine Einschr√§nkungen.  Sie k√∂nnen Gruppierung, Sortierung, UND und ODER, PARTITION, Rekursion usw. verwenden. <br><br>  In Aufgabe 2.2 des vorherigen Artikels k√∂nnen Sie beispielsweise MATERIALISIERT f√ºr beide Funktionen festlegen: <br><div class="scrollable-table"><table><tbody><tr><td> <code>bought <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> sum(Detail d) <font color="#a626a4">IF</font> <br> customer(order(d)) = c <font color="#a626a4">AND</font> <br> product(d) = p <font color="#a626a4">AND</font> <br> extractYear(date(order(d))) = y <font color="#a626a4">MATERIALIZED</font> ; <br> rating <font color="#50a14f">''</font> (Customer c, Product p, <font color="#a626a4">INTEGER</font> y) = <br> <font color="#a626a4">PARTITION</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">ORDER</font> <font color="#a626a4">DESC</font> bought(c, p, y), p <font color="#a626a4">BY</font> c, y <font color="#a626a4">MATERIALIZED</font> ; <br> SELECT contactName(Customer c), name(Product p) <font color="#a626a4">WHERE</font> rating(c, p, <font color="#986801">1997</font> ) &lt; <font color="#986801">3</font> ; <br></code> </td></tr></tbody></table></div>  Das System selbst erstellt eine Tabelle mit Schl√ºsseln der Typen <i>Customer</i> , <i>Product</i> und <i>INTEGER</i> , f√ºgt zwei Felder hinzu und aktualisiert die darin enthaltenen Feldwerte bei √Ñnderungen.  Bei weiteren Aufrufen dieser Funktionen werden diese nicht berechnet, sondern Werte aus den entsprechenden Feldern gelesen. <br><br>  Mit diesem Mechanismus k√∂nnen Sie beispielsweise die Rekursion (CTE) in Abfragen entfernen.  Ber√ºcksichtigen Sie insbesondere die Gruppen, aus denen der Baum besteht, unter Verwendung der Kind / Eltern-Beziehung (jede Gruppe hat einen Link zu ihrem Elternteil): <br><div class="scrollable-table"><table><tbody><tr><td> <code>parent = <font color="#a626a4">DATA</font> Group (Group); <br></code> </td></tr></tbody></table></div>  In einer funktionalen Datenbank kann die Rekursionslogik wie folgt definiert werden: <br><div class="scrollable-table"><table><tbody><tr><td> <code>level (Group child, Group parent) = <font color="#a626a4">RECURSION</font> <font color="#986801">1l</font> <font color="#a626a4">IF</font> child <font color="#a626a4">IS</font> Group <font color="#a626a4">AND</font> parent == child <br> <font color="#a626a4">STEP</font> <font color="#986801">2l</font> <font color="#a626a4">IF</font> parent == parent($parent); <br> isParent (Group child, Group parent) = <font color="#a626a4">TRUE</font> <font color="#a626a4">IF</font> level(child, parent) <font color="#a626a4">MATERIALIZED</font> ; <br></code> </td></tr></tbody></table></div>  Da MATERIALIZED f√ºr die Funktion <i>isParent</i> angeh√§ngt ist, wird f√ºr sie eine Tabelle mit zwei Schl√ºsseln (Gruppen) erstellt, in der das Feld <i>isParent</i> nur dann wahr ist, wenn der erste Schl√ºssel ein Nachkomme des zweiten Schl√ºssels ist.  Die Anzahl der Eintr√§ge in dieser Tabelle entspricht der Anzahl der Gruppen multipliziert mit der durchschnittlichen Tiefe des Baums.  Wenn beispielsweise die Anzahl der Nachkommen einer bestimmten Gruppe berechnet werden muss, k√∂nnen Sie auf diese Funktion zugreifen: <br><div class="scrollable-table"><table><tbody><tr><td> <code>childrenCount (Group g) = <font color="#a626a4">GROUP</font> <font color="#a626a4">SUM</font> <font color="#986801">1</font> <font color="#a626a4">IF</font> isParent(Group child, g); <br></code> </td></tr></tbody></table></div>  Die SQL-Abfrage enth√§lt keinen CTE.  Stattdessen wird es eine einfache GROUP BY geben. <br><br>  Mit diesem Mechanismus k√∂nnen Sie die Datenbank bei Bedarf auch problemlos denormalisieren: <br><div class="scrollable-table"><table><tbody><tr><td> <code><font color="#a626a4">CLASS</font> Order <font color="#50a14f">''</font> ; <br> date <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> <font color="#a626a4">DATE</font> (Order); <br> <br> <font color="#a626a4">CLASS</font> OrderDetail <font color="#50a14f">' '</font> ; <br> order <font color="#50a14f">''</font> = <font color="#a626a4">DATA</font> Order (OrderDetail); <br> date <font color="#50a14f">''</font> (OrderDetail d) = date(order(d)) <font color="#a626a4">MATERIALIZED</font> <font color="#a626a4">INDEXED</font> ; <br></code> </td></tr></tbody></table></div>  Wenn Sie die <i>Datumsfunktion</i> f√ºr die Bestellposition aufrufen, erfolgt das Lesen aus der Tabelle mit den Bestellpositionen des Felds, f√ºr das es einen Index gibt.  Beim √Ñndern des Bestelldatums berechnet das System selbst das denormalisierte Datum in der Zeile automatisch neu. <br><br><h3>  Die Vorteile </h3><br>  Warum wird dieser ganze Mechanismus ben√∂tigt?  In klassischen DBMS kann ein Entwickler oder DBA ohne Umschreiben von Abfragen nur Indizes √§ndern, Statistiken ermitteln und dem Abfrageplaner mitteilen, wie sie ausgef√ºhrt werden sollen (au√üerdem sind HINTs nur in kommerziellen DBMS verf√ºgbar).  Unabh√§ngig davon, wie sehr sie sich bem√ºhen, k√∂nnen sie die erste Anforderung im Artikel f√ºr <i>O (Anzahl der Abteilungen)</i> nicht erf√ºllen, ohne die Anforderungen zu √§ndern und Ausl√∂ser hinzuzuf√ºgen.  In dem vorgeschlagenen Schema m√ºssen Sie in der Entwicklungsphase nicht √ºber die Struktur der Datenspeicherung und die zu verwendenden Aggregationen nachdenken.  All dies kann einfach im laufenden Betrieb direkt im Betrieb ge√§ndert werden. <br><br>  In der Praxis ist dies wie folgt.  Einige Leute entwickeln Logik direkt basierend auf der Aufgabe.  Sie kennen sich weder mit Algorithmen und ihrer Komplexit√§t noch mit Ausf√ºhrungspl√§nen, mit Join'ov-Typen oder mit anderen technischen Komponenten aus.  Diese Leute sind mehr Gesch√§ftsanalysten als Entwickler.  Dann geht alles in den Test oder Betrieb.  Die Protokollierung langer Abfragen ist aktiviert.  Wenn eine lange Anforderung erkannt wird, entscheiden sich andere Personen (eher technisch - tats√§chlich DBA) daf√ºr, MATERIALISIERT in eine Zwischenfunktion aufzunehmen.  Dadurch wird die Aufzeichnung etwas verlangsamt (da ein zus√§tzliches Feld in einer Transaktion aktualisiert werden muss).  Dies wird jedoch nicht nur erheblich beschleunigt, sondern auch alle anderen, die diese Funktion verwenden.  Gleichzeitig ist es relativ einfach, eine Entscheidung dar√ºber zu treffen, welche bestimmte Funktion verwirklicht werden soll.  Zwei Hauptparameter: Die Anzahl der m√∂glichen Eingabewerte (genau wie viele Datens√§tze in der entsprechenden Tabelle enthalten sind) und wie oft sie in anderen Funktionen verwendet werden. <br><br><h3>  Analoga </h3><br>  Moderne kommerzielle DBMS verf√ºgen √ºber √§hnliche Mechanismen: MATERIALISIERTE ANSICHT mit FAST REFRESH (Oracle) und INDEXED VIEW (Microsoft SQL Server).  In PostgreSQL kann MATERIALIZED VIEW nicht in einer Transaktion aktualisiert werden, sondern nur auf Anfrage (und sogar mit sehr strengen Einschr√§nkungen), daher ber√ºcksichtigen wir dies nicht.  Sie haben jedoch mehrere Probleme, die ihre Verwendung stark einschr√§nken. <br><br>  Erstens k√∂nnen Sie die Materialisierung nur aktivieren, wenn Sie bereits eine regul√§re ANSICHT erstellt haben.  Andernfalls m√ºssen Sie die verbleibenden Anforderungen f√ºr den Zugriff auf die neu erstellte Ansicht neu schreiben, um diese Materialisierung verwenden zu k√∂nnen.  Oder lassen Sie alles so, wie es ist, aber es ist zumindest unwirksam, wenn bestimmte Daten bereits berechnet wurden, aber viele Abfragen verwenden sie nicht immer, sondern berechnen sie erneut. <br><br>  Zweitens haben sie eine Vielzahl von Einschr√§nkungen: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle</b> <div class="spoiler_text"><blockquote><h5>  5.3.8.4 Allgemeine Einschr√§nkungen f√ºr die schnelle Aktualisierung </h5><br>  Die definierende Abfrage der materialisierten Ansicht ist wie folgt eingeschr√§nkt: <br><ul><li>  Die materialisierte Ansicht darf keine Verweise auf sich nicht wiederholende Ausdr√ºcke wie <code>SYSDATE</code> und <code>ROWNUM</code> . </li><li>  Die materialisierte Ansicht darf keine Verweise auf <code>RAW</code> oder <code>LONG</code> <code>RAW</code> -Datentypen enthalten. </li><li>  Es darf keine <code>SELECT</code> Listenunterabfrage enthalten. </li><li>  Die <code>SELECT</code> Klausel darf keine Analysefunktionen (z. B. <code>RANK</code> ) enthalten. </li><li>  Es kann nicht auf eine Tabelle verweisen, f√ºr die ein <code>XMLIndex</code> Index definiert ist. </li><li>  Es darf keine <code>MODEL</code> Klausel enthalten. </li><li>  Es darf keine <code>HAVING</code> Klausel mit einer Unterabfrage enthalten. </li><li>  Es darf keine verschachtelten Abfragen enthalten, die <code>ANY</code> , <code>ALL</code> oder <code>NOT</code> <code>EXISTS</code> . </li><li>  Es darf keine <code>[START WITH ‚Ä¶] CONNECT BY</code> Klausel <code>[START WITH ‚Ä¶] CONNECT BY</code> enthalten. </li><li>  Es kann nicht mehrere Detailtabellen an verschiedenen Standorten enthalten. </li><li>  <code>ON</code> <code>COMMIT</code> materialisierte Ansichten k√∂nnen keine Remote-Detailtabellen enthalten. </li><li>  Verschachtelte materialisierte Ansichten m√ºssen einen Join oder ein Aggregat haben. </li><li>  Materialisierte Join-Ansichten und materialisierte Aggregatansichten mit einer <code>GROUP</code> <code>BY</code> Klausel k√∂nnen nicht aus einer indexorganisierten Tabelle ausgew√§hlt werden. </li></ul><br><h5>  5.3.8.5 Einschr√§nkungen bei der schnellen Aktualisierung von materialisierten Ansichten nur mit Verkn√ºpfungen </h5><br>  Das Definieren von Abfragen f√ºr materialisierte Ansichten nur mit Verkn√ºpfungen und ohne Aggregate unterliegt den folgenden Einschr√§nkungen f√ºr die schnelle Aktualisierung: <br><ul><li>  Alle Einschr√§nkungen aus " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Einschr√§nkungen f√ºr die schnelle Aktualisierung</a> ". </li><li>  Sie d√ºrfen keine <code>GROUP</code> <code>BY</code> Klauseln oder -Aggregate haben. </li><li>  Rowids aller Tabellen in der <code>FROM</code> Liste m√ºssen in der <code>SELECT</code> Liste der Abfrage angezeigt werden. </li><li>  Materialisierte Ansichtsprotokolle m√ºssen mit Zeilen-IDs f√ºr alle Basistabellen in der <code>FROM</code> Liste der Abfrage vorhanden sein. </li><li>  Sie k√∂nnen keine schnell aktualisierbare materialisierte Ansicht aus mehreren Tabellen mit einfachen Verkn√ºpfungen erstellen, die eine Objekttypspalte in der <code>SELECT</code> Anweisung enthalten. </li></ul><br>  Au√üerdem ist die von Ihnen gew√§hlte Aktualisierungsmethode nicht optimal, wenn: <br><ul><li>  Die definierende Abfrage verwendet einen √§u√üeren Join, der sich wie ein innerer Join verh√§lt.  Wenn die definierende Abfrage einen solchen Join enth√§lt, sollten Sie die definierende Abfrage so umschreiben, dass sie einen inneren Join enth√§lt. </li><li>  Die <code>SELECT</code> Liste der materialisierten Ansicht enth√§lt Ausdr√ºcke f√ºr Spalten aus mehreren Tabellen. </li></ul><br><h5>  5.3.8.6 Einschr√§nkungen bei der schnellen Aktualisierung materialisierter Ansichten mit Aggregaten </h5><br>  Das Definieren von Abfragen f√ºr materialisierte Ansichten mit Aggregaten oder Verkn√ºpfungen unterliegt den folgenden Einschr√§nkungen f√ºr die schnelle Aktualisierung: <br><ul><li>  Alle Einschr√§nkungen aus " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Einschr√§nkungen f√ºr die schnelle Aktualisierung</a> ". </li></ul><br>  Die schnelle Aktualisierung wird sowohl f√ºr materialisierte <code>ON</code> <code>COMMIT</code> als auch f√ºr <code>ON</code> <code>DEMAND</code> Ansichten unterst√ºtzt. Es gelten jedoch die folgenden Einschr√§nkungen: <br><ul><li>  Alle Tabellen in der materialisierten Ansicht m√ºssen materialisierte Ansichtsprotokolle haben, und die materialisierten Ansichtsprotokolle m√ºssen: <br><ul><li>  Enthalten alle Spalten aus der Tabelle, auf die in der materialisierten Ansicht verwiesen wird. </li><li>  <code>ROWID</code> <code>INCLUDING</code> mit <code>ROWID</code> und <code>INCLUDING</code> <code>VALUES</code> . </li><li>  Geben Sie die <code>SEQUENCE</code> Klausel an, wenn f√ºr die Tabelle eine Mischung aus Einf√ºgungen / direkten Ladevorg√§ngen, L√∂schvorg√§ngen und Aktualisierungen erwartet wird. </li></ul><br></li><li>  F√ºr eine schnelle Aktualisierung werden nur <code>SUM</code> , <code>COUNT</code> , <code>AVG</code> , <code>VARIANCE</code> , <code>VARIANCE</code> , <code>MIN</code> und <code>MAX</code> unterst√ºtzt. </li><li>  <code>COUNT(*)</code> muss angegeben werden. </li><li>  Aggregatfunktionen d√ºrfen nur als √§u√üerster Teil des Ausdrucks auftreten.  Das hei√üt, Aggregate wie <code>AVG(AVG(x))</code> oder <code>AVG(x)</code> + <code>AVG(x)</code> sind nicht zul√§ssig. </li><li>  F√ºr jedes Aggregat wie <code>AVG(expr)</code> muss der entsprechende <code>COUNT(expr)</code> vorhanden sein.  Oracle empfiehlt die <code>SUM(expr)</code> . </li><li>  Wenn <code>VARIANCE(expr)</code> oder <code>STDDEV(expr</code> ) angegeben ist, m√ºssen <code>COUNT(expr)</code> und <code>SUM(expr)</code> angegeben werden.  Oracle empfiehlt die <code>SUM(expr *expr)</code> . </li><li>  Die <code>SELECT</code> Spalte in der definierenden Abfrage kann kein komplexer Ausdruck mit Spalten aus mehreren Basistabellen sein.  Eine m√∂gliche Problemumgehung besteht darin, eine verschachtelte materialisierte Ansicht zu verwenden. </li><li>  Die <code>SELECT</code> Liste muss alle <code>GROUP</code> <code>BY</code> Spalten enthalten. </li><li>  Die materialisierte Ansicht basiert nicht auf einer oder mehreren entfernten Tabellen. </li><li>  Wenn Sie in den Filterspalten eines materialisierten Ansichtsprotokolls einen <code>CHAR</code> Datentyp verwenden, m√ºssen die Zeichens√§tze der Master-Site und der materialisierten Ansicht identisch sein. </li><li>  Wenn die materialisierte Ansicht eine der folgenden Optionen aufweist, wird die schnelle Aktualisierung nur bei herk√∂mmlichen DML-Einf√ºgungen und direkten Lasten unterst√ºtzt. <br><ul><li>  Materialisierte Ansichten mit <code>MIN</code> oder <code>MAX</code> Aggregaten </li><li>  Materialisierte Ansichten, die <code>SUM(expr)</code> aber keinen <code>COUNT(expr)</code> </li><li>  Materialisierte Ansichten ohne <code>COUNT(*)</code> </li></ul><br>  Eine solche materialisierte Ansicht wird als materialisierte Ansicht nur zum Einf√ºgen bezeichnet. </li><li>  Eine materialisierte Ansicht mit <code>MAX</code> oder <code>MIN</code> kann nach L√∂sch- oder gemischten DML-Anweisungen schnell aktualisiert werden, wenn sie keine <code>WHERE</code> Klausel enth√§lt. <br>  Die maximale Aktualisierung von max / min nach dem L√∂schen oder der gemischten DML hat nicht das gleiche Verhalten wie der Nur-Einf√ºgen-Fall.  Es l√∂scht und berechnet die Max / Min-Werte f√ºr die betroffenen Gruppen neu.  Sie m√ºssen sich der Auswirkungen auf die Leistung bewusst sein. </li><li>  Materialisierte Ansichten mit benannten Ansichten oder Unterabfragen in der <code>FROM</code> Klausel k√∂nnen schnell aktualisiert werden, sofern die Ansichten vollst√§ndig zusammengef√ºhrt werden k√∂nnen.  Informationen dazu, welche Ansichten zusammengef√ºhrt werden, finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle Database SQL-Sprachreferenz</a> . </li><li>  Wenn keine √§u√üeren Verkn√ºpfungen vorhanden sind, haben Sie m√∂glicherweise eine beliebige Auswahl und Verkn√ºpfungen in der <code>WHERE</code> Klausel. </li><li>  Materialisierte Aggregatansichten mit √§u√üeren Verkn√ºpfungen k√∂nnen nach herk√∂mmlicher DML und direktem Laden schnell aktualisiert werden, sofern nur die √§u√üere Tabelle ge√§ndert wurde.  Au√üerdem m√ºssen eindeutige Einschr√§nkungen f√ºr die Verkn√ºpfungsspalten der inneren Verkn√ºpfungstabelle vorhanden sein.  Wenn es √§u√üere <code>AND</code> gibt, m√ºssen alle <code>AND</code> durch <code>AND</code> und den Gleichheitsoperator ( <code>=</code> ) verwenden. </li><li>  F√ºr materialisierte Ansichten mit <code>CUBE</code> , <code>ROLLUP</code> , Gruppierungss√§tzen oder deren Verkettung gelten die folgenden Einschr√§nkungen: <br><ul><li>  Die <code>SELECT</code> Liste sollte einen Gruppierungsunterscheidungsmerkmal enthalten, der entweder eine <code>GROUPING_ID</code> Funktion f√ºr alle <code>GROUP</code> <code>BY</code> Ausdr√ºcke oder eine <code>GROUPING</code> Funktion f√ºr jeden <code>GROUP</code> <code>BY</code> Ausdruck sein kann.  Wenn die <code>GROUP</code> <code>BY</code> Klausel der materialisierten Ansicht beispielsweise " <code>GROUP</code> <code>BY</code> <code>CUBE(a, b)</code> " <code>GROUPING_ID(a, b)</code> sollte die <code>SELECT</code> Liste entweder " <code>GROUPING_ID(a, b)</code> " oder " <code>GROUPING(a)</code> <code>AND</code> <code>GROUPING(b)</code> "damit die materialisierte Ansicht schnell aktualisiert werden kann. </li><li>  <code>GROUP</code> <code>BY</code> sollte nicht zu doppelten Gruppierungen f√ºhren.  Beispielsweise kann " <code>GROUP BY a, ROLLUP(a, b)</code> " nicht schnell aktualisiert werden, da dies zu doppelten Gruppierungen " <code>(a), (a, b), AND (a)</code> " f√ºhrt. </li></ul></li></ul><br><h5>  5.3.8.7 Einschr√§nkungen bei der schnellen Aktualisierung materialisierter Ansichten mit UNION ALL </h5><br>  Materialisierte Ansichten mit dem Set-Operator <code>UNION</code> <code>ALL</code> unterst√ºtzen die Option <code>REFRESH</code> <code>FAST</code> wenn die folgenden Bedingungen erf√ºllt sind: <br><ul><li>  Die definierende Abfrage muss den Operator <code>UNION</code> <code>ALL</code> auf der obersten Ebene haben. <br><br>  Der <code>UNION</code> <code>ALL</code> Operator kann nicht in eine Unterabfrage eingebettet werden, mit einer Ausnahme: Der <code>UNION</code> <code>ALL</code> kann sich in einer Unterabfrage in der <code>FROM</code> Klausel befinden, vorausgesetzt, die definierende Abfrage hat die Form <code>SELECT * FROM</code> (Ansicht oder Unterabfrage mit <code>UNION</code> <code>ALL</code> ) wie im Folgenden Beispiel: <br><pre>  CREATE VIEW view_with_unionall AS
 (SELECT c.rowid crid, c.cust_id, 2 umarker
  VON Kunden c WHERE c.cust_last_name = 'Smith'
  UNION ALL
  SELECT c.rowid crid, c.cust_id, 3 umarker
  VON Kunden c WHERE c.cust_last_name = 'Jones');

 MATERIALISIERTE ANSICHT ERSTELLEN unionall_inside_view_mv
 SCHNELL AUF NACHFRAGE WIEDERAUFNEHMEN
 SELECT * FROM view_with_unionall;
</pre>  Beachten Sie, dass die Ansicht <code>view_with_unionall</code> die Anforderungen f√ºr eine schnelle Aktualisierung erf√ºllt. </li><li>  Jeder Abfrageblock in der <code>UNION</code> <code>ALL</code> Abfrage muss die Anforderungen einer schnell aktualisierbaren materialisierten Ansicht mit Aggregaten oder einer schnell aktualisierbaren materialisierten Ansicht mit Verkn√ºpfungen erf√ºllen. <br><br>  Die entsprechenden Protokolle f√ºr materialisierte Ansichten m√ºssen in den Tabellen erstellt werden, wie dies f√ºr den entsprechenden Typ der schnell aktualisierbaren materialisierten Ansicht erforderlich ist. <br>  Beachten Sie, dass die Oracle-Datenbank auch den Sonderfall einer materialisierten Ansicht einer einzelnen Tabelle mit <code>ROWID</code> sofern die Spalte <code>ROWID</code> in der Liste <code>SELECT</code> und im Protokoll der materialisierten Ansicht enthalten ist.  Dies wird in der definierenden Abfrage der Ansicht <code>view_with_unionall</code> . </li><li>  Die <code>SELECT</code> Liste jeder Abfrage muss einen <code>UNION</code> <code>ALL</code> Marker enthalten, und die <code>UNION</code> <code>ALL</code> Spalte muss in jedem <code>UNION</code> <code>ALL</code> Zweig einen eindeutigen konstanten numerischen Wert oder Zeichenfolgenwert haben.  Au√üerdem muss die Markierungsspalte in der <code>SELECT</code> Liste jedes Abfrageblocks an derselben Ordnungsposition erscheinen.  Weitere Informationen zu <code>UNION</code> <code>ALL</code> Markern finden Sie unter " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UNION ALL-Marker und Umschreiben von Abfragen</a> ". </li><li>  Einige Funktionen wie √§u√üere Verkn√ºpfungen, Abfragen von materialisierten Ansichten mit nur Einf√ºgung und Remote-Tabellen werden f√ºr materialisierte Ansichten mit <code>UNION</code> <code>ALL</code> nicht unterst√ºtzt.  Beachten Sie jedoch, dass bei der Replikation verwendete materialisierte Ansichten, die keine Verkn√ºpfungen oder Aggregate enthalten, schnell aktualisiert werden k√∂nnen, wenn <code>UNION</code> <code>ALL</code> oder Remote-Tabellen verwendet werden. </li><li>  Der Kompatibilit√§tsinitialisierungsparameter muss auf 9.2.0 oder h√∂her eingestellt sein, um mit <code>UNION</code> <code>ALL</code> eine schnell aktualisierbare materialisierte Ansicht zu erstellen. </li></ul></blockquote></div></div><br>  Ich m√∂chte Oracle-Fans nicht beleidigen, aber nach ihrer Liste von Einschr√§nkungen zu urteilen, scheint es, dass dieser Mechanismus im allgemeinen Fall nicht mit einem Modell geschrieben wurde, sondern mit Tausenden von Indern, bei denen jeder seinen eigenen Thread schreiben durfte und jeder von ihnen konnte und tat.  Die Verwendung dieses Mechanismus f√ºr echte Logik ist wie das Gehen in einem Minenfeld.  Sie k√∂nnen jederzeit eine Mine erwerben, die auf eine der nicht offensichtlichen Einschr√§nkungen st√∂√üt.  Wie dies funktioniert, ist ebenfalls ein separates Thema, das jedoch nicht in den Geltungsbereich dieses Artikels f√§llt. <br><br><div class="spoiler">  <b class="spoiler_title">Microsoft SQL Server</b> <div class="spoiler_text"><blockquote><h3>  Zus√§tzliche Anforderungen </h3><br>  Zus√§tzlich zu den SET-Optionen und den deterministischen Funktionsanforderungen m√ºssen die folgenden Anforderungen erf√ºllt sein: <br><ul><li>  Der Benutzer, der <code>CREATE INDEX</code> ausf√ºhrt, muss der Eigent√ºmer der Ansicht sein. </li><li>  Wenn Sie den Index erstellen, muss die Option <code>IGNORE_DUP_KEY</code> auf OFF (Standardeinstellung) gesetzt sein. </li><li>  Tabellen m√ºssen durch zweiteilige Namen, <em>Schema</em> , referenziert werden <strong>.</strong>  <em>Tabellenname</em> in der Ansichtsdefinition. </li><li>  Benutzerdefinierte Funktionen, auf die in der Ansicht verwiesen wird, m√ºssen mit der Option <code>WITH SCHEMABINDING</code> . </li><li>  Auf benutzerdefinierte Funktionen, auf die in der Ansicht verwiesen wird, muss durch den zweiteiligen Namen <em>&lt;Schema&gt;</em> verwiesen werden <strong>.</strong>  <em>&lt;Funktion&gt;</em> . </li><li>  Die Datenzugriffseigenschaft einer benutzerdefinierten Funktion muss <code>NO SQL</code> , und die externe Zugriffseigenschaft muss <code>NO</code> . </li><li>  Common Language Runtime (CLR) -Funktionen k√∂nnen in der Auswahlliste der Ansicht angezeigt werden, k√∂nnen jedoch nicht Teil der Definition des Clustered-Indexschl√ºssels sein.  CLR-Funktionen k√∂nnen nicht in der WHERE-Klausel der Ansicht oder der ON-Klausel einer JOIN-Operation in der Ansicht angezeigt werden. </li><li>  F√ºr CLR-Funktionen und -Methoden von benutzerdefinierten CLR-Typen, die in der Ansichtsdefinition verwendet werden, m√ºssen die Eigenschaften wie in der folgenden Tabelle angegeben festgelegt sein. <br><div class="scrollable-table"><table><thead><tr><th>  Eigentum </th><th>  Hinweis </th></tr></thead><tbody><tr><td>  DETERMINISTIC = TRUE </td><td>  Muss explizit als Attribut der Microsoft .NET Framework-Methode deklariert werden. </td></tr><tr><td>  PR√ÑZISE = WAHR </td><td>  Muss explizit als Attribut der .NET Framework-Methode deklariert werden. </td></tr><tr><td>  DATENZUGRIFF = KEIN SQL </td><td>  Wird ermittelt, indem das DataAccess-Attribut auf DataAccessKind.None und das SystemDataAccess-Attribut auf SystemDataAccessKind.None festgelegt werden. </td></tr><tr><td>  EXTERNER ZUGRIFF = NR </td><td>  Diese Eigenschaft ist f√ºr CLR-Routinen standardm√§√üig NO. </td></tr><tr><td></td><td></td></tr></tbody></table></div></li><li>  Die Ansicht muss mit der Option <code>WITH SCHEMABINDING</code> . </li><li>  Die Ansicht darf nur auf Basistabellen verweisen, die sich in derselben Datenbank wie die Ansicht befinden.  Die Ansicht kann nicht auf andere Ansichten verweisen. </li><li>  Die SELECT-Anweisung in der Ansichtsdefinition darf die folgenden Transact-SQL-Elemente nicht enthalten: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET-Funktionen ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> und <code>OPENXML</code> ) </td><td>  <code>OUTER</code> ( <code>OUTER</code> , <code>RIGHT</code> oder <code>FULL</code> ) </td></tr><tr><td>  Abgeleitete Tabelle (definiert durch Angabe einer <code>SELECT</code> Anweisung in der <code>FROM</code> Klausel) </td><td>  Selbstverbindungen </td><td>  Angeben von Spalten mithilfe von <code>SELECT *</code> oder <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> oder <code>AVG</code> </td><td>  Common Table Expression (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>text</strong> , <strong>ntext</strong> , <strong>image</strong> , <strong>XML</strong> oder <strong>filestream</strong> spalten </td><td>  Unterabfrage </td><td>  <code>OVER</code> Klausel, die Ranking- oder Aggregatfensterfunktionen enth√§lt </td></tr><tr><td>  Volltext-Pr√§dikate ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  <code>SUM</code> Funktion, die auf einen nullbaren Ausdruck verweist </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  Benutzerdefinierte CLR-Aggregatfunktion </td><td> <code>TOP</code> </td> <td>  Operatoren <code>CUBE</code> , <code>GROUPING SETS</code> oder <code>GROUPING SETS</code> </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>EXCEPT</code> , <code>INTERSECT</code> oder <code>INTERSECT</code> Operatoren </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Tabellenvariablen </td><td>  <code>OUTER APPLY</code> oder <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Sparse Spaltens√§tze </td><td>  Inline- (TVF) oder Tabellenfunktionen mit mehreren Anweisungen (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><br>  <sup>1</sup> Die indizierte Ansicht kann <strong>Float-</strong> Spalten enthalten.  Solche Spalten k√∂nnen jedoch nicht in den Clustered-Indexschl√ºssel aufgenommen werden. </li><li>  Wenn <code>GROUP BY</code> vorhanden ist, muss die VIEW-Definition <code>COUNT_BIG(*)</code> und darf <code>HAVING</code> nicht enthalten.  Diese <code>GROUP BY</code> Einschr√§nkungen gelten nur f√ºr die Definition der indizierten Ansicht.  Eine Abfrage kann eine indizierte Ansicht in ihrem Ausf√ºhrungsplan verwenden, auch wenn diese <code>GROUP BY</code> Einschr√§nkungen nicht erf√ºllt sind. </li><li>  Wenn die Ansichtsdefinition eine <code>GROUP BY</code> Klausel enth√§lt, kann der Schl√ºssel des eindeutigen Clustered-Index nur auf die in der <code>GROUP BY</code> Klausel angegebenen Spalten verweisen. </li></ul></blockquote></div></div><br>  Hier k√∂nnen Sie sehen, dass die Indianer nicht angezogen wurden, da sie beschlossen, nach dem Schema ‚ÄûWir werden wenig, aber gut tun‚Äú zu tun.  Das hei√üt, sie haben mehr Minen auf dem Feld, aber ihr Standort ist transparenter.  Das Beunruhigendste ist diese Einschr√§nkung: <br><blockquote>  Die Ansicht darf nur auf Basistabellen verweisen, die sich in derselben Datenbank wie die Ansicht befinden.  Die Ansicht kann nicht auf andere Ansichten verweisen. </blockquote><br>  In unserer Terminologie bedeutet dies, dass eine Funktion nicht auf eine andere materialisierte Funktion zugreifen kann.  Es schneidet die ganze Ideologie im Keim. <br>  Diese Einschr√§nkung (und weiter im Text) reduziert auch die Anwendungsf√§lle erheblich: <br><blockquote>  Die SELECT-Anweisung in der Ansichtsdefinition darf die folgenden Transact-SQL-Elemente nicht enthalten: <br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td> <code>COUNT</code> </td> <td>  ROWSET-Funktionen ( <code>OPENDATASOURCE</code> , <code>OPENQUERY</code> , <code>OPENROWSET</code> und <code>OPENXML</code> ) </td><td>  <code>OUTER</code> ( <code>OUTER</code> , <code>RIGHT</code> oder <code>FULL</code> ) </td></tr><tr><td>  Abgeleitete Tabelle (definiert durch Angabe einer <code>SELECT</code> Anweisung in der <code>FROM</code> Klausel) </td><td>  Selbstverbindungen </td><td>  Angeben von Spalten mithilfe von <code>SELECT *</code> oder <code>SELECT &lt;table_name&gt;.*</code> </td></tr><tr><td> <code>DISTINCT</code> </td> <td>  <code>STDEV</code> , <code>STDEVP</code> , <code>VAR</code> , <code>VARP</code> oder <code>AVG</code> </td><td>  Common Table Expression (CTE) </td></tr><tr><td>  <strong>float</strong> <sup>1</sup> , <strong>text</strong> , <strong>ntext</strong> , <strong>image</strong> , <strong>XML</strong> oder <strong>filestream</strong> spalten </td><td>  Unterabfrage </td><td>  <code>OVER</code> Klausel, die Ranking- oder Aggregatfensterfunktionen enth√§lt </td></tr><tr><td>  Volltext-Pr√§dikate ( <code>CONTAINS</code> , <code>FREETEXT</code> ) </td><td>  <code>SUM</code> Funktion, die auf einen nullbaren Ausdruck verweist </td><td> <code>ORDER BY</code> </td> </tr><tr><td>  Benutzerdefinierte CLR-Aggregatfunktion </td><td> <code>TOP</code> </td> <td>  Operatoren <code>CUBE</code> , <code>GROUPING SETS</code> oder <code>GROUPING SETS</code> </td></tr><tr><td>  <code>MIN</code> , <code>MAX</code> </td><td>  <code>EXCEPT</code> , <code>INTERSECT</code> oder <code>INTERSECT</code> Operatoren </td><td> <code>TABLESAMPLE</code> </td> </tr><tr><td>  Tabellenvariablen </td><td>  <code>OUTER APPLY</code> oder <code>CROSS APPLY</code> </td><td>  <code>PIVOT</code> , <code>UNPIVOT</code> </td></tr><tr><td>  Sparse Spaltens√§tze </td><td>  Inline- (TVF) oder Tabellenfunktionen mit mehreren Anweisungen (MSTVF) </td><td> <code>OFFSET</code> </td> </tr><tr><td> <code>CHECKSUM_AGG</code> </td> <td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div></blockquote><br>  OUTER JOINS, UNION, ORDER BY und andere sind verboten.  Vielleicht war es einfacher anzugeben, was verwendet werden kann als was nicht.  Die Liste w√§re wahrscheinlich viel kleiner. <br><br>  Zusammenfassend l√§sst sich sagen, dass in jedem (ich stelle fest, kommerziellen) DBMS eine Vielzahl von Einschr√§nkungen gegen√ºber keinem (mit Ausnahme eines logischen und nicht eines technischen) in der LGPL-Technologie bestehen.  Es ist jedoch zu beachten, dass die Implementierung dieses Mechanismus in der relationalen Logik etwas komplizierter ist als in der beschriebenen Funktion. <br><br><h3>  Implementierung </h3><br>  Wie funktioniert es  PostgreSQL wird als "virtuelle Maschine" verwendet.  Im Inneren befindet sich ein komplexer Algorithmus, der Abfragen erstellt.  Hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> .  Und es gibt nicht nur eine gro√üe Anzahl von Heuristiken mit einer Reihe von Wenns.  Wenn Sie also ein paar Monate Zeit haben, um zu studieren, k√∂nnen Sie versuchen, die Architektur zu verstehen. <br><br>  Funktioniert es effizient?  Effektiv genug.  Leider ist es schwierig, dies zu beweisen.  Ich kann nur sagen, dass wenn Sie die Tausenden von Anfragen in gro√üen Anwendungen ber√ºcksichtigen, diese im Durchschnitt effektiver sind als ein guter Entwickler.  Ein ausgezeichneter SQL-Programmierer kann jede Abfrage effizienter schreiben, aber mit tausend Abfragen hat er einfach weder Motivation noch Zeit, dies zu tun.  Das einzige, was ich jetzt als Beweis f√ºr die Wirksamkeit geben kann, ist, dass auf der Grundlage der auf diesem DBMS basierenden Plattform mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ERP-Systemprojekte</a> funktionieren, in denen Tausende verschiedener MATERIALISIERTER Funktionen mit Tausenden von Benutzern und Terrabyte-Datenbanken mit Hunderten von Millionen von Datens√§tzen arbeiten auf einem normalen Dual-Prozessor-Server.  Jeder kann jedoch die Effektivit√§t testen / widerlegen, indem er die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattform</a> und PostgreSQL herunterl√§dt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> SQL-Abfrageprotokollierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiviert</a> und versucht, die Logik und die Daten dort zu √§ndern. <br><br>  In den folgenden Artikeln werde ich auch dar√ºber sprechen, wie Sie Einschr√§nkungen f√ºr Funktionen aufh√§ngen, mit √Ñnderungssitzungen arbeiten und vieles mehr k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459066/">https://habr.com/ru/post/de459066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459046/index.html">Unabh√§ngige Implementierung (Existenznachweis) in 2 Schritten</a></li>
<li><a href="../de459050/index.html">Leistungsstarkes Vuex-Schreibmodul</a></li>
<li><a href="../de459052/index.html">Wie man vergleicht: "tolles Auto" und "h√§ssliche H√ºtte", in einer Marketingumfrage und in Big Data</a></li>
<li><a href="../de459054/index.html">Heatmap von Klicks - wie sich Benutzer auf der Website verhalten</a></li>
<li><a href="../de459062/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 305 (vom 1. bis 7. Juli)</a></li>
<li><a href="../de459068/index.html">Windows Server 2008 R2 - Der K√∂nig ist tot, es lebe der K√∂nig</a></li>
<li><a href="../de459070/index.html">Turmverteidigung in Einheit schaffen: T√ºrme und schie√üende Feinde</a></li>
<li><a href="../de459074/index.html">Kleine Freude # 7: Drei zum Preis von One-Console-Animation, Algorithmen und Debugging</a></li>
<li><a href="../de459078/index.html">CERN wechselt zu Open Source Software - warum?</a></li>
<li><a href="../de459080/index.html">Features HttpUrlConnection von java.net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>