<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìñ ü•£ üé± Performances de Kotlin sur Android üî∏ üõ∞Ô∏è üè•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parlons aujourd'hui des performances de Kotlin sur Android en production. Regardons sous le capot, impl√©mentons des optimisations d√©licates, comparons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Performances de Kotlin sur Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Parlons aujourd'hui des performances de Kotlin sur Android en production.  Regardons sous le capot, impl√©mentons des optimisations d√©licates, comparons le code d'octet.  Enfin, nous aborderons s√©rieusement la comparaison et mesurerons les rep√®res. <br><br>  Cet article est bas√© sur un rapport d' <strong>Alexander Smirnov</strong> lors de AppsConf 2017 et aidera √† d√©terminer s'il est possible d'√©crire du code dans Kotlin, qui ne sera pas inf√©rieur √† Java en termes de vitesse. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier:</strong> Alexander Smirnov CTO chez PapaJobs, dirige le blog vid√©o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Android in Faces</a> et est √©galement l'un des organisateurs de la communaut√© Mosdroid. <br><a name="habracut"></a><br>  Commen√ßons par vos attentes. <br><br><blockquote>  Pensez-vous que Kotlin √† l'ex√©cution est plus lent que Java?  Ou plus vite?  Ou peut-√™tre qu'il n'y a pas beaucoup de diff√©rence?  Apr√®s tout, les deux fonctionnent sur le bytecode que la machine virtuelle nous fournit. </blockquote><br>  Faisons les choses correctement.  Traditionnellement, lorsque la question de la comparaison des performances se pose, tout le monde veut voir des rep√®res et des chiffres sp√©cifiques.  Malheureusement, pour Android, il n'y a pas de JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Microbenchmark Harness</a> ), donc nous ne pouvons pas mesurer √† quel point cela peut √™tre cool en Java.  Alors, que pouvons-nous faire pour faire la mesure, comme d√©crit ci-dessous? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Si jamais vous essayez de mesurer votre code de cette fa√ßon, alors l'un des d√©veloppeurs JMH sera triste, pleurera et viendra √† vous dans un r√™ve - ne faites jamais √ßa. <br><br>  Sur Android, vous pouvez faire des r√©f√©rences, en particulier, Google l'a d√©montr√© lors des E / S de l'ann√©e derni√®re.  Ils ont dit qu'ils avaient consid√©rablement am√©lior√© la machine virtuelle, dans ce cas ART, et si sur Android 4.1 une allocation d'un objet prenait environ 600 √† 700 nanosecondes, alors dans la huiti√®me version, cela prendrait environ 60 nanosecondes.  C'est-√†-dire  ils ont pu le mesurer avec une telle pr√©cision dans une machine virtuelle.  Pourquoi nous ne pouvons pas faire non plus - nous n'avons pas de tels outils. <br><br>  Si nous regardons toute la documentation, la seule chose que nous pouvons trouver est la recommandation ci-dessus, comment mesurer l'interface utilisateur: <br><br>  <strong>shell adb dumpsys gfxinfo% nom_package%</strong> <br><br>  En fait, faisons-le de cette fa√ßon et voyons √† la fin ce que cela donnera.  Mais d'abord, nous d√©terminerons ce que nous mesurerons et ce que nous pouvons faire d'autre. <br><br><blockquote>  La prochaine question.  O√π pensez-vous que les performances sont importantes lorsque vous cr√©ez une application de premi√®re classe? <br><br><ol><li>  Certainement partout. </li><li>  Fil d'interface utilisateur. </li><li>  Vue personnalis√©e + animations. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  J'aime surtout la premi√®re option, mais il est fort probable qu'il soit impossible de faire fonctionner tout le code tr√®s, tr√®s rapidement et il est important qu'au moins il n'y ait pas d'UiThread ou de vue personnalis√©e.  Je suis √©galement d'accord avec cela - c'est tr√®s, tr√®s important.  Personne ne remarquera le fait que dans votre flux JSON s√©par√© sera d√©s√©rialis√© pendant 10 millisecondes de plus. <br><br>  La psychologie de la Gestalt dit que lorsque nous clignons des yeux, pendant environ 150 √† 300 millisecondes, l'≈ìil humain est flou et ne voit pas ce qui s'y passe r√©ellement.  Et puis ces 10 millisecondes de temps ne le font pas.  Mais si nous revenons √† la psychologie gestalt, il est important non pas ce que je vois vraiment et ce qui se passe r√©ellement, mais ce que je comprends en tant qu'utilisateur est important. <br><br>  C'est-√†-dire  si nous faisons croire √† l'utilisateur qu'il a tout tr√®s, tr√®s vite, mais en fait, il sera simplement magnifiquement battu, par exemple, √† l'aide d'une belle animation, alors il sera satisfait, m√™me si ce n'est pas le cas. <br><br>  Les motifs de psychologie de la Gestalt dans iOS √©voluent depuis un certain temps.  Par cons√©quent, si vous prenez deux applications avec le m√™me temps de traitement, mais sur des plates-formes diff√©rentes, et que vous les mettez c√¥te √† c√¥te, il semblera que sur iOS tout est plus rapide.  L'animation dans les processus iOS est un peu plus rapide, une animation ant√©rieure d√©marre au d√©marrage et de nombreuses autres animations, pour que ce soit beau. <br><br>  La <strong>premi√®re r√®gle est donc de penser √† l'utilisateur.</strong> <br><br>  Et pour la deuxi√®me r√®gle, vous devez vous immerger dans le hardcore. <br><br><h2>  KOTLIN STYLE <br></h2><br>  Pour √©valuer honn√™tement les performances de Kotlin, nous allons le comparer avec Java.  Par cons√©quent, il s'av√®re qu'il est impossible de mesurer certaines choses qui ne sont que dans Kotlin, par exemple: <br><br><ul><li>  Collection Api. </li><li>  Param√®tres par d√©faut de la m√©thode. </li><li>  Classes de donn√©es. </li><li>  Types r√©ifi√©s. </li><li>  Coroutines. </li></ul><br>  <strong>L'API de collecte</strong> que Kotlin nous fournit est tr√®s cool, tr√®s rapide.  En Java, cela n'existe tout simplement pas, il n'y a que diff√©rentes impl√©mentations.  Par exemple, la biblioth√®que d'API Liteweight Stream sera plus lente car elle fait tout de la m√™me mani√®re que Kotlin, mais avec une ou deux allocations suppl√©mentaires √† l'op√©ration, car tout se transforme en objet suppl√©mentaire. <br><br>  Si nous prenons l'API Stream de Java 8, cela fonctionnera plus lentement que l'API Kotlin Collection, mais √† une condition - il n'y a pas une telle paralysie dans l'API Collection, si nous incluons en parall√®le, sur de gros volumes de donn√©es Stream API, Java contournera l'API Kotlin Collection.  Par cons√©quent, nous ne pouvons pas comparer de telles choses, car nous effectuons la comparaison pr√©cis√©ment du point de vue d'Android. <br><br>  La deuxi√®me chose, qui, √† mon avis, ne peut √™tre compar√©e, est les <strong>param√®tres par d√©faut de la m√©thode</strong> - une fonctionnalit√© tr√®s int√©ressante, qui, soit dit en passant, se trouve dans Dart.  Lorsque vous appelez une m√©thode, elle peut avoir certains param√®tres qui peuvent prendre une certaine valeur, mais peut √™tre NULL.  Et par cons√©quent, vous ne faites pas 10 m√©thodes diff√©rentes, mais faites une m√©thode et dites que l'un des param√®tres peut √™tre NULL, et √† l'avenir l'utiliser sans aucun param√®tre.  C'est-√†-dire  il va regarder, le param√®tre est venu, ou il n'est pas venu.  C'est tr√®s pratique car vous pouvez √©crire beaucoup moins de code, mais l'inconv√©nient est que vous devez payer pour cela.  C'est du sucre syntaxique: vous, en tant que d√©veloppeur, pensez que c'est une m√©thode API, mais en r√©alit√©, sous le capot, chaque variation de la m√©thode avec des param√®tres manquants est g√©n√©r√©e dans le bytecode.  Et chacune de ces m√©thodes v√©rifie √©galement, petit √† petit, si ce param√®tre est arriv√©.  Si c'est le cas, alors ok, si ce n'est pas le cas, nous cr√©ons un masque de bits, et en fonction de ce masque de bits, la m√©thode d'origine que vous avez √©crite est en fait appel√©e.  Les op√©rations au niveau du bit, tout <em>si / sinon</em> co√ªtent un peu d'argent, mais tr√®s peu, et il est normal que vous deviez payer pour plus de commodit√©.  Il me semble que c'est absolument normal. <br><br>  L'√©l√©ment suivant qui ne peut pas √™tre compar√© est <strong>les classes de donn√©es</strong> . <br><br>  Tout le monde pleure qu'en Java, il existe des param√®tres pour lesquels il existe des classes de mod√®le.  C'est-√†-dire  vous prenez des param√®tres et faites plus de m√©thodes, de getters et de setters pour tous ces param√®tres.  Il s'av√®re que pour une classe avec dix param√®tres, vous avez toujours besoin de toute une nappe de getters, de setters et de tout un tas de plus.  De plus, si vous n'utilisez pas de g√©n√©rateurs, vous devez √©crire avec vos mains, ce qui est g√©n√©ralement terrible. <br><br>  Kotlin vous permet de vous √©loigner de tout.  Tout d'abord, comme il existe des propri√©t√©s dans Kotlin, vous n'avez pas besoin d'√©crire des getters et des setters.  Il n'a <strong>pas de param√®tres de classe, toutes les propri√©t√©s</strong> .  En tout cas, nous le pensons.  Deuxi√®mement, si vous √©crivez qu'il s'agit de classes de donn√©es, un tas de tout le reste sera g√©n√©r√©.  Par exemple, equals (), toStrung () / hasCode (), etc. <br><br>  Bien s√ªr, cela pr√©sente √©galement des inconv√©nients.  Par exemple, je n'avais pas besoin que les 20 param√®tres de mes classes de donn√©es soient compar√©s √† la fois dans mes √©gaux (), je n'avais qu'√† comparer 3. Quelqu'un n'aime pas tout cela parce que les performances sont perdues sur ce point, et en plus, beaucoup est g√©n√©r√© fonctions de service, et le code compil√© est assez volumineux.  Autrement dit, si vous √©crivez tout √† la main, il y aura moins de code que si vous utilisez des classes de donn√©es. <br><br>  Je n'utilise pas de classes de donn√©es pour une autre raison.  Auparavant, il y avait des restrictions sur l'expansion de ces classes et autre chose.  Maintenant, tout le monde va mieux avec √ßa, mais l'habitude demeure. <br><br>  Qu'est-ce qui est tr√®s, tr√®s cool dans Kotlin, et qu'est-ce qui sera toujours plus rapide que Java?  Il s'agit de <strong>types r√©ifi√©s</strong> , qui, soit dit en passant, se <strong>trouvent</strong> √©galement dans Dart. <br><br>  Vous savez que lorsque vous utilisez des g√©n√©riques, l'effacement de type est effac√© au stade de la compilation et au moment de l'ex√©cution, vous ne savez plus quel objet de ce g√©n√©rique est r√©ellement utilis√©. <br><br>  Avec les types Reified, vous n'avez pas besoin d'utiliser la r√©flexion √† de nombreux endroits lorsque vous en auriez besoin en Java, car avec les m√©thodes en ligne, c'est avec Reified que vous connaissez le type, et il s'av√®re donc que vous n'utilisez pas la r√©flexion et votre code fonctionne plus rapidement.  La magie. <br><br>  Et il y a des <strong>Coroutines</strong> .  Ils sont tr√®s cool, je les aime beaucoup, mais au moment de la performance, ils n'√©taient inclus que dans la version alpha, il n'√©tait donc pas possible de faire des comparaisons correctes avec eux. <br><br><h2>  CHAMPS <br></h2><br>  Alors allons-y, passons √† ce que nous pouvons comparer avec Java et ce que nous pouvons influencer en g√©n√©ral. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Comme je l'ai dit, nous n'avons pas de param√®tres pour la classe, nous avons des propri√©t√©s. <br><br>  Nous avons var, nous avons val, nous avons une classe externe, dont l'une des propri√©t√©s est @JvmField, et nous verrons ce qui se passe r√©ellement avec la fonction work (): nous additionnons la valeur des champs a et b de notre propre classe et les valeurs des champs a et b de la classe externe, qui sont √©crites dans le champ immuable c. <br><br>  La question est de savoir comment, en fait, sera appel√© dans d = a + b.  Nous savons tous que cette propri√©t√© une fois, le getter de cette classe sera appel√©e pour ce param√®tre. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Mais si nous regardons le bytecode, nous verrons que getfield est r√©ellement accessible.  Autrement dit, cela dans le bytecode n'est pas un appel √† la fonction InvokeVirtual, mais un acc√®s direct au champ.  Il n'y a rien qui nous a √©t√© promis au d√©part, que nous ayons toutes les propri√©t√©s, pas les champs.  Il s'av√®re que Kotlin nous trompe, il y a un appel direct. <br><br>  Que se passe-t-il si nous voyons quel bytecode est g√©n√©r√© pour une autre ligne: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Auparavant, si vous acc√©diez √† une propri√©t√© priv√©e, vous aviez toujours un appel InvokeVirtual.  S'il s'agissait d'une propri√©t√© priv√©e, l'acc√®s √† celle-ci se faisait via GetField.  GetField est beaucoup plus rapide qu'InvokeVirtual, la sp√©cification d'Android pr√©tend que l'acc√®s direct √† un champ est 3 √† 7 fois plus rapide.  Par cons√©quent, il est recommand√© de toujours faire r√©f√©rence √† Field, et non par le biais de getters ou setters.  Maintenant, en particulier dans la huiti√®me machine virtuelle ART, il y aura d√©j√† des num√©ros diff√©rents, mais si vous prenez toujours en charge la version 4.1, ce sera vrai. <br><br>  Par cons√©quent, il s'av√®re qu'il est toujours avantageux pour nous d'avoir GetField, et non InvokeVirtual. <br><br>  Maintenant, vous pouvez obtenir GetField si vous acc√©dez √† une propri√©t√© de votre propre classe, ou s'il s'agit d'une propri√©t√© publique, vous devez d√©finir @JvmField.  Ensuite, exactement la m√™me chose dans le bytecode sera un appel GetField, qui est 3-7 fois plus rapide. <br><br>  Il est clair que nous parlons ici en nanosecondes et, avec un tr√¥ne, c'est tr√®s, tr√®s petit.  Mais, d'autre part, si vous le faites dans le thread d'interface utilisateur, par exemple, dans la m√©thode ondraw, vous acc√©dez √† une sorte de vue, cela affectera le rendu de chaque image, et vous pouvez le faire un peu plus rapidement. <br><br>  <strong>Si nous additionnons toutes les optimisations, alors en somme, cela peut donner quelque chose.</strong> <br><br><h2>  STATIQUE!? <br></h2><br>  Et la statique?  Nous savons tous que dans Kotlin statique est un objet compagnon.  Auparavant, vous avez probablement ajout√© une sorte de balise, par exemple, statique publique, statique finale, etc., si vous la convertissez en code Kotlin, vous obtiendrez un objet compagnon, qui √©crira quelque chose comme ceci: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  Pensez-vous que cette entr√©e est identique √† la d√©claration finale statique standard en Java?  Est-ce statique ou pas du tout? </blockquote><br>  Oui, en effet, Kotlin d√©clare qu'ici c'est dans Kotlin - statique, cet objet dit qu'il est statique.  En r√©alit√©, ce n'est pas statique. <br><br>  Si nous regardons le bytecode g√©n√©r√©, nous verrons ce qui suit: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Un Test.Companion est g√©n√©r√©; un objet singleton pour lequel l'instance est cr√©√©e, cette instance est √©crite dans son propre champ.  Apr√®s cela, l'acc√®s √† l'un des objets compagnons s'effectue via cet objet.  Il prend getstatic, c'est-√†-dire une instance statique de cette classe, et invoque la fonction getK invokevirtual dessus, et exactement la m√™me chose pour la fonction work2.  Nous comprenons donc que ce n'est pas statique. <br><br>  Cela est important, car sur les anciennes machines virtuelles Java, invokestatic √©tait environ 30% plus rapide qu'invokevirtual.  Maintenant, bien s√ªr, chez HotSpot, la virtualisation optimis√©e devient vraiment cool, et elle est presque invisible.  N√©anmoins, vous devez garder cela √† l'esprit, d'autant plus qu'il y a une allocation suppl√©mentaire et qu'un emplacement suppl√©mentaire sur 4ST1 repr√©sente 700 nanosecondes de trop. <br><br>  Examinons le code Java qui sort si vous inversez le d√©ploiement du bytecode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Un champ statique est cr√©√©, une impl√©mentation finale statique de l'objet Companion, des getters et setters sont cr√©√©s et, comme vous pouvez le voir, se r√©f√©rant au champ statique √† l'int√©rieur, une m√©thode statique suppl√©mentaire appara√Æt.  Tout est assez triste. <br><br>  Que pouvons-nous faire en veillant √† ce qu'il ne soit pas statique?  Nous pouvons essayer d'ajouter @JvmField et @JvmStatic et voir ce qui se passe. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Je dirai tout de suite que vous ne vous √©loignerez pas de @JvmStatic, ce sera le m√™me objet, car il s'agit d'un objet compagnon, il y aura une allocation suppl√©mentaire de cet objet et il y aura un appel suppl√©mentaire. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Mais l'appel ne changera que pour k, car ce sera @JvmField, il sera pris directement comme getstatic, les getters et setters ne seront plus g√©n√©r√©s.  Mais pour la fonction work2, rien ne changera. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  La deuxi√®me option sur la fa√ßon de cr√©er de la statique est propos√©e dans la documentation de Kotlin, il est donc dit que nous pouvons simplement cr√©er un objet, et ce sera du code statique. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  En r√©alit√©, ce n'est pas non plus le cas. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Il s'av√®re que nous faisons un appel d'instance getstatic √† partir de singletone, qui est cr√©√©, et appelons exactement les m√™mes m√©thodes virtuelles. <br><br>  La seule fa√ßon dont nous pouvons r√©aliser invokestatic est les fonctions d'ordre sup√©rieur.  Lorsque nous √©crivons simplement une fonction en dehors de la classe, par exemple, fun test2 sera vraiment appel√© statique. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  De plus, la chose la plus int√©ressante est qu'une classe sera cr√©√©e, un objet, dans ce cas testKt, il g√©n√©rera un objet pour lui-m√™me, il g√©n√©rera une fonction qu'il mettra dans cet objet, et maintenant il sera appel√© invokestatique. <br><br>  Pourquoi cela a √©t√© fait est incompr√©hensible.  Beaucoup sont m√©contents de cela, mais il y a ceux qui consid√®rent qu'une telle impl√©mentation est tout √† fait normale.  Depuis la machine virtuelle, incl.  L'art s'am√©liore, maintenant il n'est plus aussi critique.  Dans la huiti√®me version d'Android, tout comme sur HotSpot, tout est optimis√©, mais ces petites choses affectent encore l√©g√®rement les performances globales. <br><br><h2>  NULLABILIT√â <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Ceci est le prochain exemple int√©ressant.  Il semblerait que nous ayons not√© que le second peut √™tre annulable, et il doit √™tre v√©rifi√© avant de faire quoi que ce soit avec.  Dans ce cas, je m'attends √† ce que nous en ayons un si.  Lorsque ce code est d√©ploy√© dans si second n'est pas √©gal √† z√©ro, alors je pense que l'ex√©cution ira plus loin et ne sortira qu'en premier. <br><br>  Comment tout cela se d√©roule-t-il vraiment dans le code java?  En fait, il y aura un ch√®que. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Nous obtiendrons Intrinsics dans un premier temps.  Disons que je dis que celui-ci <br><br>  Si se d√©veloppera en un op√©rateur ternaire.  Mais en plus de cela, bien que nous ayons m√™me corrig√© que le premier param√®tre ne peut pas √™tre annul√©, il sera toujours v√©rifi√© via Intrinsics. <br><br>  Intrinsics est une classe interne de Kotlin qui a un certain ensemble de param√®tres et de v√©rifications.  Et chaque fois que vous rendez le param√®tre de m√©thode non nul, il le v√©rifie quand m√™me.  Pourquoi?  Ensuite, que nous travaillons dans Interop Java, et il peut arriver que vous vous attendiez √† ce qu'il ne soit pas annulable ici, mais avec Java cela viendra de quelque part. <br><br>  Si vous cochez ceci, il ira plus loin dans le code, puis apr√®s 10-20 appels de m√©thode, vous ferez quelque chose avec un param√®tre qui, bien qu'il ne puisse pas √™tre annulable, mais pour une raison quelconque, il s'est av√©r√© qu'il l'est.  Tout tombera pour vous, et vous ne pourrez pas comprendre ce qui s'est r√©ellement pass√©.  Pour √©viter cette situation, chaque fois que vous passerez le param√®tre null, vous devrez toujours le v√©rifier.  Et s'il est nullable, il y aura une exception. <br><br>  Ce ch√®que vaut √©galement quelque chose, et s'il y en a beaucoup, ce ne sera pas tr√®s bon. <br><br>  Mais en fait, si nous parlons de HotSpot, alors 10 appels de ces Intrinsics prendront environ quatre nanosecondes.  C'est tr√®s, tr√®s petit, et vous ne devriez pas vous en soucier, mais c'est un facteur int√©ressant. <br><br><h2>  PRIMITIVES <br></h2><br>  En Java, il existe des primitives.  √Ä Kotlin, comme nous le savons tous, il n'y a pas de primitives, nous fonctionnons toujours avec des objets.  En Java, ils sont utilis√©s pour fournir des performances plus √©lev√©es pour les objets sur certains calculs mineurs.  Ajouter deux objets co√ªte beaucoup plus cher que d'ajouter deux primitives.  Prenons un exemple. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Il y a trois nombres, car les deux premiers types non nuls seront d√©duits, et vers le troisi√®me nous dirons qu'il peut √™tre annulable. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Si vous regardez le bytecode et voyez quel code Java est g√©n√©r√©, les deux premiers nombres ne sont pas nuls et peuvent donc √™tre des primitives.  Mais la primitive ne peut pas contenir Null, seul un objet peut le faire, donc un objet sera g√©n√©r√© pour le troisi√®me nombre. <br><br><h2>  AUTOBOXE <br></h2><br>  Lorsque vous travaillez avec des primitives et effectuez une op√©ration avec une primitive et une non-primitive, vous devrez soit traduire l'une d'elles en primitive, soit en objet. <br><br>  Et, il semblerait, il n'est pas surprenant que si vous effectuez des op√©rations avec nullable et non nullable dans Kotlin, alors vous perdez un peu en performances.  De plus, s'il existe de nombreuses op√©rations de ce type, vous perdez beaucoup. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Voyez o√π la boxe / unboxing sera ici?  Je n'ai pas vu non plus avant d'avoir regard√© le bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  En fait, je m'attendais √† ce qu'il y ait quelque chose comme cette comparaison: si la cha√Æne n'est pas nulle et si elle est vide, d√©finissez-la sur true, sinon d√©finissez-la sur false.  Tout semble simple, mais en r√©alit√© le code suivant est g√©n√©r√©: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Regardons √† l'int√©rieur.  La variable <em>a est</em> prise, elle est cast√©e en CharSequence, apr√®s avoir √©t√© cast√©e, qui a √©galement √©t√© d√©pens√©e pendant un certain temps, une autre v√©rification est appel√©e - StringsKt.isBlank - c'est ainsi que la fonction d'extension de CharSequence est √©crite, donc elle est cast√©e et envoy√©e.  Puisque la premi√®re expression peut √™tre nullable, elle la prend et fait de la boxe, et enveloppe tout cela dans Boolean.valueOf.  Par cons√©quent, la vraie primitive devient √©galement un objet, et ce n'est qu'apr√®s que la v√©rification a d√©j√† eu lieu et que Intrinsics.areEqual est appel√©. <br><br>  Cela semblerait une op√©ration si simple, mais un r√©sultat si inattendu.  En fait, il y a tr√®s peu de telles choses.  Mais quand vous pouvez avoir nullable / non nullable, vous pouvez g√©n√©rer un grand nombre de ces choses, et que vous n'auriez jamais imagin√©.  Par cons√©quent, je vous recommande de vous √©loigner de l'obscurit√© d√®s que possible.  C'est-√†-dire  <strong>venez √† l'immunit√© des valeurs le plus t√¥t possible et √©loignez-vous de nullable</strong> pour que vous n'op√©riez pas aussi rapidement que possible. <br><br><h2>  Boucles <br></h2><br>  La prochaine chose int√©ressante. <br><br>  Vous pouvez utiliser l'habituel pour, qui est en Java, mais vous pouvez √©galement utiliser la nouvelle API pratique - √©crire imm√©diatement l'√©num√©ration des √©l√©ments dans la liste.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Par exemple, vous pouvez appeler la fonction de travail dans une boucle, o√π ce sera un √©l√©ment de cette liste. </font></font><br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un it√©rateur sera g√©n√©r√© et il y aura une recherche it√©rative banale. </font><font style="vertical-align: inherit;">C'est normal, c'est beaucoup recommand√©. </font><font style="vertical-align: inherit;">Mais si nous examinons le type de conseils que Google nous donne, nous d√©couvrirons, du point de vue des performances sp√©cifiques √† ArrayList, une √©num√©ration des travaux 3 fois plus rapide que celle d'un it√©rateur. </font><font style="vertical-align: inherit;">Dans tous les autres cas, l'it√©rateur fonctionnera de mani√®re identique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, si vous √™tes s√ªr d'avoir une ArrayList, il est logique de faire autre chose - √©crivez votre foreach.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   ¬´¬ª,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        ‚àí1,  until ,   ,    .   ,    ,    ranges.  C'est-√†-dire   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    ‚Äî   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   ‚Äî Xno-param-assertions ‚Äî    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  ‚Äî ,     .     ,    ,    0,04 . ,  ,        ‚Äî   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  ‚Äî   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   ‚Äî . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420143/">https://habr.com/ru/post/fr420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420131/index.html">M√©thode d'exploration de Bitcoin probabiliste</a></li>
<li><a href="../fr420133/index.html">Mod√©lisation des syst√®mes dynamiques: comment se d√©place la lune?</a></li>
<li><a href="../fr420135/index.html">C'est aussi Toshiba: des produits inattendus de la soci√©t√© japonaise</a></li>
<li><a href="../fr420139/index.html">Livre ¬´Site Reliability Engineering. Fiabilit√© et fiabilit√© comme dans Google ¬ª</a></li>
<li><a href="../fr420141/index.html">Depuis le SGBD MPP charg√© - Data Lake dynamique avec des outils d'analyse: partagez les d√©tails de la cr√©ation</a></li>
<li><a href="../fr420145/index.html">Comment se passe la journ√©e de travail des membres du PC AppsConf</a></li>
<li><a href="../fr420147/index.html">OpenSource sur Clojure</a></li>
<li><a href="../fr420151/index.html">Plus simple qu'il n'y para√Æt. Chapitre 12</a></li>
<li><a href="../fr420153/index.html">Impression 3D de pi√®ces complexes en ABS et PLA avec beaucoup de support</a></li>
<li><a href="../fr420155/index.html">SSD Intel Datacenter. Grands volumes et nouveaux noms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>