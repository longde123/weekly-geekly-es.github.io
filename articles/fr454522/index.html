<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 🚡 🐭 Node.js: gestion de la mémoire disponible pour les applications s'exécutant dans des conteneurs 👩🏿‍💼 💪🏼 👵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de l'exécution d'applications Node.js dans des conteneurs Docker, les paramètres de mémoire traditionnels ne fonctionnent pas toujours comme prév...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: gestion de la mémoire disponible pour les applications s'exécutant dans des conteneurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Lors de l'exécution d'applications Node.js dans des conteneurs Docker, les paramètres de mémoire traditionnels ne fonctionnent pas toujours comme prévu.  Le matériel, dont nous publions la traduction aujourd'hui, est consacré à trouver la réponse à la question de savoir pourquoi.  Il fournira également des recommandations pratiques pour gérer la mémoire disponible pour les applications Node.js s'exécutant dans des conteneurs. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Examen des recommandations</font> </h2><br>  Supposons qu'une application Node.js s'exécute dans un conteneur avec une limite de mémoire définie.  Si nous parlons de Docker, l'option <code>--memory</code> pourrait être utilisée pour définir cette limite.  Quelque chose de similaire est possible lorsque vous travaillez avec des systèmes d'orchestration de conteneurs.  Dans ce cas, il est recommandé d'utiliser l' <code>--max-old-space-size</code> lors du démarrage de l'application Node.js.  Cela vous permet d'informer la plate-forme de la quantité de mémoire dont elle dispose et de prendre également en compte le fait que cette quantité doit être inférieure à la limite définie au niveau du conteneur. <br><br>  Lorsque l'application Node.js s'exécute à l'intérieur du conteneur, définissez la capacité de la mémoire disponible en fonction de la valeur maximale d'utilisation de la mémoire active par l'application.  Cela se fait si les limites de mémoire du conteneur peuvent être configurées. <br><br>  Parlons maintenant plus en détail du problème de l'utilisation de la mémoire dans les conteneurs. <br><br><h2>  <font color="#3AC1EF">Docker Memory Limit</font> </h2><br>  Par défaut, les conteneurs n'ont pas de limites de ressources et peuvent utiliser autant de mémoire que le permet le système d'exploitation.  La commande <code>docker run</code> dispose d'options de ligne de commande qui vous permettent de définir des limites concernant l'utilisation de la mémoire ou les ressources du processeur. <br><br>  La commande de lancement de conteneur peut ressembler à ceci: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Veuillez noter ce qui suit: <br><br><ul><li>  <code>x</code> est la limite de la quantité de mémoire disponible pour le conteneur, exprimée en unités de <code>y</code> . </li><li>  <code>y</code> peut prendre la valeur <code>b</code> (octets), <code>k</code> (kilo-octets), <code>m</code> (mégaoctets), <code>g</code> (gigaoctets). </li></ul><br>  Voici un exemple de commande de lancement de conteneur: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Ici, la limite de mémoire est fixée à <code>1000000</code> octets. <br><br>  Pour vérifier la limite de mémoire définie au niveau du conteneur, vous pouvez, dans le conteneur, exécuter la commande suivante: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Parlons du comportement du système lors de la spécification de la limite de mémoire de l'application Node.js à l'aide de la <code>--max-old-space-size</code> .  Dans ce cas, cette limite de mémoire correspondra à la limite définie au niveau du conteneur. <br><br>  Ce qui est appelé "ancien espace" dans le nom de la clé est l'un des fragments du tas contrôlé par V8 (l'endroit où les "anciens" objets JavaScript sont placés).  Cette clé, si vous n'entrez pas dans les détails que nous touchons ci-dessous, contrôle la taille maximale du tas.  Les détails sur les commutateurs de ligne de commande Node.js peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En général, lorsqu'une application essaie d'utiliser plus de mémoire que celle disponible dans le conteneur, son opération se termine. <br><br>  Dans l'exemple suivant (le fichier d'application est appelé <code>test-fatal-error.js</code> ), les objets <code>MyRecord</code> sont placés dans le tableau de <code>list</code> , avec un intervalle de 10 millisecondes.  Cela conduit à une croissance incontrôlée du tas, simulant une fuite de mémoire. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Veuillez noter que tous les exemples de programmes dont nous allons discuter ici sont placés dans l'image Docker, qui peut être téléchargée à partir du Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Vous pouvez utiliser cette image pour des expériences indépendantes. <br><br>  De plus, vous pouvez emballer l'application dans un conteneur Docker, collecter l'image et l'exécuter avec la limite de mémoire: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Ici <code>ravali1906/dockermemory</code> est le nom de l'image. <br><br>  Vous pouvez maintenant démarrer l'application en spécifiant une limite de mémoire qui dépasse la limite de conteneur: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Ici, le <code>--max_old_space_size</code> représente la limite de mémoire indiquée en mégaoctets.  La méthode <code>process.memoryUsage()</code> donne des informations sur l'utilisation de la mémoire.  Les valeurs sont exprimées en octets. <br><br>  À un certain moment, l'application est abandonnée de force.  Cela se produit lorsque la quantité de mémoire utilisée par lui franchit une certaine frontière.  Quelle est cette frontière?  De quelles limitations sur la quantité de mémoire peut-on parler? <br><br><h2>  <font color="#3AC1EF">Le comportement attendu d'une application exécutée avec la clé est - max-old-space-size</font> </h2><br>  Par défaut, la taille de segment de mémoire maximale dans Node.js (jusqu'à la version 11.x) est de 700 Mo sur les plates-formes 32 bits et de 1400 Mo sur les plates-formes 64 bits.  Vous pouvez en savoir plus sur la définition de ces valeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En théorie, si vous utilisez la <code>--max-old-space-size</code> pour <code>--max-old-space-size</code> limite de mémoire qui dépasse la limite de mémoire du conteneur, vous pouvez vous attendre à ce que l'application soit arrêtée par le mécanisme de sécurité du noyau du noyau Linux OOM Killer. <br><br>  En réalité, cela peut ne pas arriver. <br><br><h2>  <font color="#3AC1EF">Le comportement réel de l'application exécutée avec la clé est max-old-space-size</font> </h2><br>  L'application, immédiatement après le lancement, n'alloue pas toute la mémoire dont la limite est spécifiée à l'aide de <code>--max-old-space-size</code> .  La taille du tas JavaScript dépend des besoins de l'application.  Vous pouvez déterminer la quantité de mémoire utilisée par l'application en fonction de la valeur du champ <code>heapUsed</code> de l'objet renvoyé par la méthode <code>process.memoryUsage()</code> .  En fait, nous parlons de la mémoire allouée dans le tas pour les objets. <br><br>  Par conséquent, nous concluons que l'application sera <code>--memory</code> force si la taille du <code>--memory</code> est supérieure à la limite définie par la clé <code>--memory</code> démarrage du conteneur. <br><br>  Mais en réalité, cela peut ne pas se produire non plus. <br><br>  Lors du profilage des applications Node.js gourmandes en ressources qui s'exécutent dans des conteneurs avec une limite de mémoire donnée, les modèles suivants peuvent être observés: <br><br><ol><li>  OOM Killer est déclenché bien plus tard que le moment où les <code>heapUsed</code> <code>heapTotal</code> et <code>heapUsed</code> sont nettement supérieures aux limites de la mémoire. </li><li>  OOM Killer ne répond pas au dépassement des limites. </li></ol><br><h2>  <font color="#3AC1EF">Une explication du comportement des applications Node.js dans les conteneurs</font> </h2><br>  Un conteneur supervise un indicateur important des applications qui s'exécutent dessus.  Il s'agit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RSS</a> (taille de l'ensemble résident).  Cet indicateur représente une certaine partie de la mémoire virtuelle de l'application. <br><br>  De plus, c'est un morceau de mémoire qui est alloué à l'application. <br><br>  Mais ce n'est pas tout.  RSS fait partie de la mémoire active allouée à l'application. <br><br>  Toute la mémoire allouée à une application peut ne pas être active.  Le fait est que la «mémoire allouée» n'est pas nécessairement allouée physiquement jusqu'à ce que le processus commence à vraiment l'utiliser.  De plus, en réponse aux demandes d'allocation de mémoire provenant d'autres processus, le système d'exploitation peut vider des parties inactives de la mémoire d'application dans le fichier d'échange et transférer l'espace libéré vers d'autres processus.  Et lorsque l'application aura à nouveau besoin de ces morceaux de mémoire, ils seront extraits du fichier d'échange et retournés à la mémoire physique. <br><br>  La métrique RSS indique la quantité de mémoire active et disponible pour l'application dans son espace d'adressage.  C'est lui qui influence la décision sur l'arrêt forcé de l'application. <br><br><h2>  <font color="#3AC1EF">Preuve</font> </h2><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 1.</font>  <font color="#3AC1EF">Une application qui alloue de la mémoire pour un tampon</font> </h3><br>  L'exemple suivant, <code>buffer_example.js</code> , montre un programme qui alloue de la mémoire pour un tampon: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Pour que la quantité de mémoire allouée par le programme dépasse la limite définie lors du lancement du conteneur, exécutez d'abord le conteneur avec la commande suivante: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Après cela, exécutez le programme: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Comme vous pouvez le voir, le système n'a pas terminé le programme, bien que la mémoire allouée par le programme dépasse la limite de conteneur.  Cela est dû au fait que le programme ne fonctionne pas avec toute la mémoire allouée.  RSS est très petit, il ne dépasse pas la limite de mémoire du conteneur. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 2.</font>  <font color="#3AC1EF">Application remplissant le tampon avec des données</font> </h3><br>  Dans l'exemple suivant, <code>buffer_example_fill.js</code> , la mémoire n'est pas seulement allouée, mais également remplie de données: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Exécutez le conteneur: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Après cela, exécutez l'application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Apparemment, même maintenant, l'application ne se termine pas!  Pourquoi?  Le fait est que lorsque la quantité de mémoire active atteint la limite définie au démarrage du conteneur et qu'il y a de la place dans le fichier d'échange, certaines des anciennes pages de la mémoire de processus sont déplacées vers le fichier d'échange.  La mémoire libérée est mise à la disposition du même processus.  Par défaut, Docker alloue un espace pour le fichier d'échange égal à la limite de mémoire définie à l'aide de l'indicateur <code>--memory</code> .  Compte tenu de cela, nous pouvons dire que le processus a 2 Go de mémoire - 1 Go dans la mémoire active et 1 Go dans le fichier d'échange.  En effet, du fait que l'application peut utiliser sa propre mémoire, dont le contenu est temporairement déplacé vers le fichier d'échange, la taille de l'index RSS est dans la limite du conteneur.  Par conséquent, l'application continue de fonctionner. <br><br><h3>  <font color="#3AC1EF">▍ Exemple n ° 3.</font>  <font color="#3AC1EF">Une application qui remplit un tampon avec des données s'exécutant dans un conteneur qui n'utilise pas de fichier d'échange</font> </h3><br>  Voici le code que nous allons expérimenter ici (c'est le même fichier <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Cette fois, exécutez le conteneur, en configurant explicitement les fonctionnalités de travail avec le fichier d'échange: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Lancez l'application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Voir le message <code>Killed</code> ?  Lorsque la valeur de la clé <code>--memory-swap</code> est égale à la <code>--memory</code> clé <code>--memory</code> , cela indique au conteneur qu'il ne doit pas utiliser le fichier d' <code>--memory-swap</code> .  De plus, par défaut, le noyau du système d'exploitation dans lequel s'exécute le conteneur lui-même peut vider une certaine quantité de pages mémoire anonymes utilisées par le conteneur dans le fichier d'échange.  <code>--memory-swappiness</code> sur <code>0</code> , nous désactivons cette fonctionnalité.  Par conséquent, il s'avère que le fichier d'échange n'est pas utilisé à l'intérieur du conteneur.  Le processus se termine lorsque la métrique RSS dépasse la limite de mémoire du conteneur. <br><br><h2>  <font color="#3AC1EF">Recommandations générales</font> </h2><br>  Lorsque les applications Node.js sont lancées avec la <code>--max-old-space-size</code> , dont la valeur dépasse la limite de mémoire définie au démarrage du conteneur, il peut sembler que Node.js «ne fait pas attention» à la limite du conteneur.  Mais, comme le montrent les exemples précédents, la raison évidente de ce comportement est le fait que l'application n'utilise tout simplement pas le volume de <code>--max-old-space-size</code> entier spécifié avec l' <code>--max-old-space-size</code> . <br><br>  N'oubliez pas que l'application ne se comportera pas toujours de la même façon si elle utilise plus de mémoire que celle disponible dans le conteneur.  Pourquoi?  Le fait est que la mémoire active (RSS) du processus est influencée par de nombreux facteurs externes que l’application elle-même ne peut pas influencer.  Ils dépendent de la charge du système et des caractéristiques de l'environnement.  Par exemple, il s'agit des fonctionnalités de l'application elle-même, du niveau de parallélisme dans le système, des fonctionnalités du planificateur du système d'exploitation, des fonctionnalités du garbage collector, etc.  De plus, ces facteurs, d'un lancement à l'autre, peuvent changer. <br><br><h2>  <font color="#3AC1EF">Recommandations sur la définition de la taille du segment Node.js pour les cas où vous pouvez contrôler cette option, mais pas avec des restrictions de mémoire au niveau du conteneur</font> </h2><br><ul><li>  Exécutez l'application Node.js minimale dans le conteneur et mesurez la taille RSS statique (dans mon cas, pour Node.js 10.x, cela représente environ 20 Mo). </li><li>  Le tas Node.js contient non seulement l'ancien_espace, mais également d'autres (tels que nouvel_espace, espace_code, etc.).  Par conséquent, si vous prenez en compte la configuration standard de la plate-forme, vous devez vous fier au fait que le programme aura besoin d'environ 20 Mo de mémoire supplémentaire.  Si les paramètres standard ont changé, ces changements doivent également être pris en compte. </li><li>  Maintenant, nous devons soustraire la valeur obtenue (supposons qu'elle sera de 40 Mo) de la quantité de mémoire disponible dans le conteneur.  Ce qui reste est une valeur qui, sans crainte que l' <code>--max-old-space-size</code> du programme ne manque de mémoire, peut être spécifiée comme valeur clé - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Recommandations pour la définition de limites de mémoire de conteneur pour les cas où ce paramètre peut être contrôlé, mais les paramètres d'application Node.js ne sont pas</font> </h2><br><ul><li>  Exécutez l'application dans des modes qui vous permettent de connaître les valeurs maximales de la mémoire consommée par celle-ci. </li><li>  Analysez le score RSS.  En particulier, ici, avec la méthode <code>process.memoryUsage()</code> , la commande Linux <code>top</code> peut être utile. </li><li>  Pourvu que dans le conteneur dans lequel il est prévu d'exécuter l'application, rien ne soit exécuté, la valeur obtenue peut être utilisée comme limite de mémoire du conteneur.  Pour être sûr, il est recommandé de l'augmenter d'au moins 10%. </li></ul><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Dans Node.js 12.x, certains des problèmes abordés ici sont résolus en ajustant de manière adaptative la taille du tas, qui est effectuée en fonction de la quantité de RAM disponible.  Ce mécanisme fonctionne également lors de l'exécution d'applications Node.js dans des conteneurs.  Mais les paramètres peuvent différer des paramètres par défaut.  Cela se produit, par exemple, lorsque la clé <code>--max_old_space_size</code> été utilisée lors du démarrage de l'application.  Pour de tels cas, tout ce qui précède reste pertinent.  Cela suggère que toute personne qui exécute des applications Node.js dans des conteneurs doit être prudente et responsable concernant les paramètres de mémoire.  De plus, la connaissance des limites standard d'utilisation de la mémoire, qui est plutôt conservatrice, peut améliorer les performances des applications en modifiant délibérément ces limites. <br><br>  <b>Chers lecteurs!</b>  Avez-vous manqué de problèmes de mémoire lors de l'exécution des applications Node.js dans des conteneurs Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454522/">https://habr.com/ru/post/fr454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454512/index.html">Petit déjeuner avec Charles Weatherly, auteur du livre culte Etudes for Programmers</a></li>
<li><a href="../fr454514/index.html">Développement d'un synthétiseur musical simple sur ATMEGA8</a></li>
<li><a href="../fr454516/index.html">Comment obtenir un bon texte pour 200 roubles</a></li>
<li><a href="../fr454518/index.html">Wasmer: la bibliothèque Go la plus rapide pour exécuter le code WebAssembly</a></li>
<li><a href="../fr454520/index.html">Consignes pour écrire du code JavaScript propre</a></li>
<li><a href="../fr454524/index.html">Réparation de bandeau Samsung Level On Pro</a></li>
<li><a href="../fr454530/index.html">DJI a créé un octocoptère qui peut faire des films</a></li>
<li><a href="../fr454532/index.html">Je vais dire un mot sur l'approche d'ingénierie</a></li>
<li><a href="../fr454534/index.html">Peu scientifique sur les monades</a></li>
<li><a href="../fr454536/index.html">Amplificateur au capteur de fréquence cardiaque classique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>