<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèª üö° üê≠ Node.js: gestion de la m√©moire disponible pour les applications s'ex√©cutant dans des conteneurs üë©üèø‚Äçüíº üí™üèº üëµüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de l'ex√©cution d'applications Node.js dans des conteneurs Docker, les param√®tres de m√©moire traditionnels ne fonctionnent pas toujours comme pr√©v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: gestion de la m√©moire disponible pour les applications s'ex√©cutant dans des conteneurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Lors de l'ex√©cution d'applications Node.js dans des conteneurs Docker, les param√®tres de m√©moire traditionnels ne fonctionnent pas toujours comme pr√©vu.  Le mat√©riel, dont nous publions la traduction aujourd'hui, est consacr√© √† trouver la r√©ponse √† la question de savoir pourquoi.  Il fournira √©galement des recommandations pratiques pour g√©rer la m√©moire disponible pour les applications Node.js s'ex√©cutant dans des conteneurs. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Examen des recommandations</font> </h2><br>  Supposons qu'une application Node.js s'ex√©cute dans un conteneur avec une limite de m√©moire d√©finie.  Si nous parlons de Docker, l'option <code>--memory</code> pourrait √™tre utilis√©e pour d√©finir cette limite.  Quelque chose de similaire est possible lorsque vous travaillez avec des syst√®mes d'orchestration de conteneurs.  Dans ce cas, il est recommand√© d'utiliser l' <code>--max-old-space-size</code> lors du d√©marrage de l'application Node.js.  Cela vous permet d'informer la plate-forme de la quantit√© de m√©moire dont elle dispose et de prendre √©galement en compte le fait que cette quantit√© doit √™tre inf√©rieure √† la limite d√©finie au niveau du conteneur. <br><br>  Lorsque l'application Node.js s'ex√©cute √† l'int√©rieur du conteneur, d√©finissez la capacit√© de la m√©moire disponible en fonction de la valeur maximale d'utilisation de la m√©moire active par l'application.  Cela se fait si les limites de m√©moire du conteneur peuvent √™tre configur√©es. <br><br>  Parlons maintenant plus en d√©tail du probl√®me de l'utilisation de la m√©moire dans les conteneurs. <br><br><h2>  <font color="#3AC1EF">Docker Memory Limit</font> </h2><br>  Par d√©faut, les conteneurs n'ont pas de limites de ressources et peuvent utiliser autant de m√©moire que le permet le syst√®me d'exploitation.  La commande <code>docker run</code> dispose d'options de ligne de commande qui vous permettent de d√©finir des limites concernant l'utilisation de la m√©moire ou les ressources du processeur. <br><br>  La commande de lancement de conteneur peut ressembler √† ceci: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Veuillez noter ce qui suit: <br><br><ul><li>  <code>x</code> est la limite de la quantit√© de m√©moire disponible pour le conteneur, exprim√©e en unit√©s de <code>y</code> . </li><li>  <code>y</code> peut prendre la valeur <code>b</code> (octets), <code>k</code> (kilo-octets), <code>m</code> (m√©gaoctets), <code>g</code> (gigaoctets). </li></ul><br>  Voici un exemple de commande de lancement de conteneur: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Ici, la limite de m√©moire est fix√©e √† <code>1000000</code> octets. <br><br>  Pour v√©rifier la limite de m√©moire d√©finie au niveau du conteneur, vous pouvez, dans le conteneur, ex√©cuter la commande suivante: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Parlons du comportement du syst√®me lors de la sp√©cification de la limite de m√©moire de l'application Node.js √† l'aide de la <code>--max-old-space-size</code> .  Dans ce cas, cette limite de m√©moire correspondra √† la limite d√©finie au niveau du conteneur. <br><br>  Ce qui est appel√© "ancien espace" dans le nom de la cl√© est l'un des fragments du tas contr√¥l√© par V8 (l'endroit o√π les "anciens" objets JavaScript sont plac√©s).  Cette cl√©, si vous n'entrez pas dans les d√©tails que nous touchons ci-dessous, contr√¥le la taille maximale du tas.  Les d√©tails sur les commutateurs de ligne de commande Node.js peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En g√©n√©ral, lorsqu'une application essaie d'utiliser plus de m√©moire que celle disponible dans le conteneur, son op√©ration se termine. <br><br>  Dans l'exemple suivant (le fichier d'application est appel√© <code>test-fatal-error.js</code> ), les objets <code>MyRecord</code> sont plac√©s dans le tableau de <code>list</code> , avec un intervalle de 10 millisecondes.  Cela conduit √† une croissance incontr√¥l√©e du tas, simulant une fuite de m√©moire. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Veuillez noter que tous les exemples de programmes dont nous allons discuter ici sont plac√©s dans l'image Docker, qui peut √™tre t√©l√©charg√©e √† partir du Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Vous pouvez utiliser cette image pour des exp√©riences ind√©pendantes. <br><br>  De plus, vous pouvez emballer l'application dans un conteneur Docker, collecter l'image et l'ex√©cuter avec la limite de m√©moire: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Ici <code>ravali1906/dockermemory</code> est le nom de l'image. <br><br>  Vous pouvez maintenant d√©marrer l'application en sp√©cifiant une limite de m√©moire qui d√©passe la limite de conteneur: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Ici, le <code>--max_old_space_size</code> repr√©sente la limite de m√©moire indiqu√©e en m√©gaoctets.  La m√©thode <code>process.memoryUsage()</code> donne des informations sur l'utilisation de la m√©moire.  Les valeurs sont exprim√©es en octets. <br><br>  √Ä un certain moment, l'application est abandonn√©e de force.  Cela se produit lorsque la quantit√© de m√©moire utilis√©e par lui franchit une certaine fronti√®re.  Quelle est cette fronti√®re?  De quelles limitations sur la quantit√© de m√©moire peut-on parler? <br><br><h2>  <font color="#3AC1EF">Le comportement attendu d'une application ex√©cut√©e avec la cl√© est - max-old-space-size</font> </h2><br>  Par d√©faut, la taille de segment de m√©moire maximale dans Node.js (jusqu'√† la version 11.x) est de 700 Mo sur les plates-formes 32 bits et de 1400 Mo sur les plates-formes 64 bits.  Vous pouvez en savoir plus sur la d√©finition de ces valeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En th√©orie, si vous utilisez la <code>--max-old-space-size</code> pour <code>--max-old-space-size</code> limite de m√©moire qui d√©passe la limite de m√©moire du conteneur, vous pouvez vous attendre √† ce que l'application soit arr√™t√©e par le m√©canisme de s√©curit√© du noyau du noyau Linux OOM Killer. <br><br>  En r√©alit√©, cela peut ne pas arriver. <br><br><h2>  <font color="#3AC1EF">Le comportement r√©el de l'application ex√©cut√©e avec la cl√© est max-old-space-size</font> </h2><br>  L'application, imm√©diatement apr√®s le lancement, n'alloue pas toute la m√©moire dont la limite est sp√©cifi√©e √† l'aide de <code>--max-old-space-size</code> .  La taille du tas JavaScript d√©pend des besoins de l'application.  Vous pouvez d√©terminer la quantit√© de m√©moire utilis√©e par l'application en fonction de la valeur du champ <code>heapUsed</code> de l'objet renvoy√© par la m√©thode <code>process.memoryUsage()</code> .  En fait, nous parlons de la m√©moire allou√©e dans le tas pour les objets. <br><br>  Par cons√©quent, nous concluons que l'application sera <code>--memory</code> force si la taille du <code>--memory</code> est sup√©rieure √† la limite d√©finie par la cl√© <code>--memory</code> d√©marrage du conteneur. <br><br>  Mais en r√©alit√©, cela peut ne pas se produire non plus. <br><br>  Lors du profilage des applications Node.js gourmandes en ressources qui s'ex√©cutent dans des conteneurs avec une limite de m√©moire donn√©e, les mod√®les suivants peuvent √™tre observ√©s: <br><br><ol><li>  OOM Killer est d√©clench√© bien plus tard que le moment o√π les <code>heapUsed</code> <code>heapTotal</code> et <code>heapUsed</code> sont nettement sup√©rieures aux limites de la m√©moire. </li><li>  OOM Killer ne r√©pond pas au d√©passement des limites. </li></ol><br><h2>  <font color="#3AC1EF">Une explication du comportement des applications Node.js dans les conteneurs</font> </h2><br>  Un conteneur supervise un indicateur important des applications qui s'ex√©cutent dessus.  Il s'agit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RSS</a> (taille de l'ensemble r√©sident).  Cet indicateur repr√©sente une certaine partie de la m√©moire virtuelle de l'application. <br><br>  De plus, c'est un morceau de m√©moire qui est allou√© √† l'application. <br><br>  Mais ce n'est pas tout.  RSS fait partie de la m√©moire active allou√©e √† l'application. <br><br>  Toute la m√©moire allou√©e √† une application peut ne pas √™tre active.  Le fait est que la ¬´m√©moire allou√©e¬ª n'est pas n√©cessairement allou√©e physiquement jusqu'√† ce que le processus commence √† vraiment l'utiliser.  De plus, en r√©ponse aux demandes d'allocation de m√©moire provenant d'autres processus, le syst√®me d'exploitation peut vider des parties inactives de la m√©moire d'application dans le fichier d'√©change et transf√©rer l'espace lib√©r√© vers d'autres processus.  Et lorsque l'application aura √† nouveau besoin de ces morceaux de m√©moire, ils seront extraits du fichier d'√©change et retourn√©s √† la m√©moire physique. <br><br>  La m√©trique RSS indique la quantit√© de m√©moire active et disponible pour l'application dans son espace d'adressage.  C'est lui qui influence la d√©cision sur l'arr√™t forc√© de l'application. <br><br><h2>  <font color="#3AC1EF">Preuve</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Exemple n ¬∞ 1.</font>  <font color="#3AC1EF">Une application qui alloue de la m√©moire pour un tampon</font> </h3><br>  L'exemple suivant, <code>buffer_example.js</code> , montre un programme qui alloue de la m√©moire pour un tampon: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Pour que la quantit√© de m√©moire allou√©e par le programme d√©passe la limite d√©finie lors du lancement du conteneur, ex√©cutez d'abord le conteneur avec la commande suivante: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Apr√®s cela, ex√©cutez le programme: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Comme vous pouvez le voir, le syst√®me n'a pas termin√© le programme, bien que la m√©moire allou√©e par le programme d√©passe la limite de conteneur.  Cela est d√ª au fait que le programme ne fonctionne pas avec toute la m√©moire allou√©e.  RSS est tr√®s petit, il ne d√©passe pas la limite de m√©moire du conteneur. <br><br><h3>  <font color="#3AC1EF">‚ñç Exemple n ¬∞ 2.</font>  <font color="#3AC1EF">Application remplissant le tampon avec des donn√©es</font> </h3><br>  Dans l'exemple suivant, <code>buffer_example_fill.js</code> , la m√©moire n'est pas seulement allou√©e, mais √©galement remplie de donn√©es: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Ex√©cutez le conteneur: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Apr√®s cela, ex√©cutez l'application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Apparemment, m√™me maintenant, l'application ne se termine pas!  Pourquoi?  Le fait est que lorsque la quantit√© de m√©moire active atteint la limite d√©finie au d√©marrage du conteneur et qu'il y a de la place dans le fichier d'√©change, certaines des anciennes pages de la m√©moire de processus sont d√©plac√©es vers le fichier d'√©change.  La m√©moire lib√©r√©e est mise √† la disposition du m√™me processus.  Par d√©faut, Docker alloue un espace pour le fichier d'√©change √©gal √† la limite de m√©moire d√©finie √† l'aide de l'indicateur <code>--memory</code> .  Compte tenu de cela, nous pouvons dire que le processus a 2 Go de m√©moire - 1 Go dans la m√©moire active et 1 Go dans le fichier d'√©change.  En effet, du fait que l'application peut utiliser sa propre m√©moire, dont le contenu est temporairement d√©plac√© vers le fichier d'√©change, la taille de l'index RSS est dans la limite du conteneur.  Par cons√©quent, l'application continue de fonctionner. <br><br><h3>  <font color="#3AC1EF">‚ñç Exemple n ¬∞ 3.</font>  <font color="#3AC1EF">Une application qui remplit un tampon avec des donn√©es s'ex√©cutant dans un conteneur qui n'utilise pas de fichier d'√©change</font> </h3><br>  Voici le code que nous allons exp√©rimenter ici (c'est le m√™me fichier <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Cette fois, ex√©cutez le conteneur, en configurant explicitement les fonctionnalit√©s de travail avec le fichier d'√©change: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Lancez l'application: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Voir le message <code>Killed</code> ?  Lorsque la valeur de la cl√© <code>--memory-swap</code> est √©gale √† la <code>--memory</code> cl√© <code>--memory</code> , cela indique au conteneur qu'il ne doit pas utiliser le fichier d' <code>--memory-swap</code> .  De plus, par d√©faut, le noyau du syst√®me d'exploitation dans lequel s'ex√©cute le conteneur lui-m√™me peut vider une certaine quantit√© de pages m√©moire anonymes utilis√©es par le conteneur dans le fichier d'√©change.  <code>--memory-swappiness</code> sur <code>0</code> , nous d√©sactivons cette fonctionnalit√©.  Par cons√©quent, il s'av√®re que le fichier d'√©change n'est pas utilis√© √† l'int√©rieur du conteneur.  Le processus se termine lorsque la m√©trique RSS d√©passe la limite de m√©moire du conteneur. <br><br><h2>  <font color="#3AC1EF">Recommandations g√©n√©rales</font> </h2><br>  Lorsque les applications Node.js sont lanc√©es avec la <code>--max-old-space-size</code> , dont la valeur d√©passe la limite de m√©moire d√©finie au d√©marrage du conteneur, il peut sembler que Node.js ¬´ne fait pas attention¬ª √† la limite du conteneur.  Mais, comme le montrent les exemples pr√©c√©dents, la raison √©vidente de ce comportement est le fait que l'application n'utilise tout simplement pas le volume de <code>--max-old-space-size</code> entier sp√©cifi√© avec l' <code>--max-old-space-size</code> . <br><br>  N'oubliez pas que l'application ne se comportera pas toujours de la m√™me fa√ßon si elle utilise plus de m√©moire que celle disponible dans le conteneur.  Pourquoi?  Le fait est que la m√©moire active (RSS) du processus est influenc√©e par de nombreux facteurs externes que l‚Äôapplication elle-m√™me ne peut pas influencer.  Ils d√©pendent de la charge du syst√®me et des caract√©ristiques de l'environnement.  Par exemple, il s'agit des fonctionnalit√©s de l'application elle-m√™me, du niveau de parall√©lisme dans le syst√®me, des fonctionnalit√©s du planificateur du syst√®me d'exploitation, des fonctionnalit√©s du garbage collector, etc.  De plus, ces facteurs, d'un lancement √† l'autre, peuvent changer. <br><br><h2>  <font color="#3AC1EF">Recommandations sur la d√©finition de la taille du segment Node.js pour les cas o√π vous pouvez contr√¥ler cette option, mais pas avec des restrictions de m√©moire au niveau du conteneur</font> </h2><br><ul><li>  Ex√©cutez l'application Node.js minimale dans le conteneur et mesurez la taille RSS statique (dans mon cas, pour Node.js 10.x, cela repr√©sente environ 20 Mo). </li><li>  Le tas Node.js contient non seulement l'ancien_espace, mais √©galement d'autres (tels que nouvel_espace, espace_code, etc.).  Par cons√©quent, si vous prenez en compte la configuration standard de la plate-forme, vous devez vous fier au fait que le programme aura besoin d'environ 20 Mo de m√©moire suppl√©mentaire.  Si les param√®tres standard ont chang√©, ces changements doivent √©galement √™tre pris en compte. </li><li>  Maintenant, nous devons soustraire la valeur obtenue (supposons qu'elle sera de 40 Mo) de la quantit√© de m√©moire disponible dans le conteneur.  Ce qui reste est une valeur qui, sans crainte que l' <code>--max-old-space-size</code> du programme ne manque de m√©moire, peut √™tre sp√©cifi√©e comme valeur cl√© - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Recommandations pour la d√©finition de limites de m√©moire de conteneur pour les cas o√π ce param√®tre peut √™tre contr√¥l√©, mais les param√®tres d'application Node.js ne sont pas</font> </h2><br><ul><li>  Ex√©cutez l'application dans des modes qui vous permettent de conna√Ætre les valeurs maximales de la m√©moire consomm√©e par celle-ci. </li><li>  Analysez le score RSS.  En particulier, ici, avec la m√©thode <code>process.memoryUsage()</code> , la commande Linux <code>top</code> peut √™tre utile. </li><li>  Pourvu que dans le conteneur dans lequel il est pr√©vu d'ex√©cuter l'application, rien ne soit ex√©cut√©, la valeur obtenue peut √™tre utilis√©e comme limite de m√©moire du conteneur.  Pour √™tre s√ªr, il est recommand√© de l'augmenter d'au moins 10%. </li></ul><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Dans Node.js 12.x, certains des probl√®mes abord√©s ici sont r√©solus en ajustant de mani√®re adaptative la taille du tas, qui est effectu√©e en fonction de la quantit√© de RAM disponible.  Ce m√©canisme fonctionne √©galement lors de l'ex√©cution d'applications Node.js dans des conteneurs.  Mais les param√®tres peuvent diff√©rer des param√®tres par d√©faut.  Cela se produit, par exemple, lorsque la cl√© <code>--max_old_space_size</code> √©t√© utilis√©e lors du d√©marrage de l'application.  Pour de tels cas, tout ce qui pr√©c√®de reste pertinent.  Cela sugg√®re que toute personne qui ex√©cute des applications Node.js dans des conteneurs doit √™tre prudente et responsable concernant les param√®tres de m√©moire.  De plus, la connaissance des limites standard d'utilisation de la m√©moire, qui est plut√¥t conservatrice, peut am√©liorer les performances des applications en modifiant d√©lib√©r√©ment ces limites. <br><br>  <b>Chers lecteurs!</b>  Avez-vous manqu√© de probl√®mes de m√©moire lors de l'ex√©cution des applications Node.js dans des conteneurs Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454522/">https://habr.com/ru/post/fr454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454512/index.html">Petit d√©jeuner avec Charles Weatherly, auteur du livre culte Etudes for Programmers</a></li>
<li><a href="../fr454514/index.html">D√©veloppement d'un synth√©tiseur musical simple sur ATMEGA8</a></li>
<li><a href="../fr454516/index.html">Comment obtenir un bon texte pour 200 roubles</a></li>
<li><a href="../fr454518/index.html">Wasmer: la biblioth√®que Go la plus rapide pour ex√©cuter le code WebAssembly</a></li>
<li><a href="../fr454520/index.html">Consignes pour √©crire du code JavaScript propre</a></li>
<li><a href="../fr454524/index.html">R√©paration de bandeau Samsung Level On Pro</a></li>
<li><a href="../fr454530/index.html">DJI a cr√©√© un octocopt√®re qui peut faire des films</a></li>
<li><a href="../fr454532/index.html">Je vais dire un mot sur l'approche d'ing√©nierie</a></li>
<li><a href="../fr454534/index.html">Peu scientifique sur les monades</a></li>
<li><a href="../fr454536/index.html">Amplificateur au capteur de fr√©quence cardiaque classique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>