<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍👨 🙂 🧚🏾 使用IPEYE云监控服务进行内部延时拍摄 🗻 📳 🎽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，每天都会出现一项任务，与一对连接到IPEYE的监控摄像机形成延时。 如果您对Python知识最少的人如何处理感兴趣，或者您想向我指出我的错误，请欢迎... 

 前言 
 我父亲决定搬家并在另一个地区盖房子。 他请我帮助进行视频监控。 输入数据： 



- 没有技术室。 
- 设备可能被盗。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用IPEYE云监控服务进行内部延时拍摄</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475154/"> 最近，每天都会出现一项任务，与一对连接到IPEYE的监控摄像机形成延时。 如果您对Python知识最少的人如何处理感兴趣，或者您想向我指出我的错误，请欢迎... <br><a name="habracut"></a><br><h2> 前言 </h2><br> 我父亲决定搬家并在另一个地区盖房子。 他请我帮助进行视频监控。 输入数据： <br><br><ul><li> 没有技术室。 </li><li> 设备可能被盗。 </li><li> 需要高质量的图片。 </li><li> 摄像机必须在室外。 </li><li> 您只需要2台摄像机。 </li><li> 我真的想要带变焦的PTZ摄像机。 </li><li> 我想要一个移动应用程序。 </li></ul><br> 在查看了品牌设备商店的价格后，决定购买带阿里所有面包的noname PoE摄像机。 这些相机足够便宜-大约每个5千个。 <br><br> 我不想将DVR放置在施工现场，因此决定使用云解决方案。 摄像机到达后，我试图结交具有不同服务的朋友，以便一切正常，包括PTZ。 在我尝试过的所有服务中，结果发现只有IPEYE才使中国相机成为朋友。 <br> 这将结束介绍。 我认为现在每个人都很清楚为什么要进行有关此服务的对话。 <br><br><h2>  IPEYE的经验 </h2><br> 服务即服务。 承诺的一切都实现了。 技术支持会回答问题。 关键是您可以指定一个指向rstp流的链接，扭转PTZ设置，一切都会正常进行。  Android移动应用程序有效。 可以为其相机创建访客用户，并向每个亲戚授予访问权限。  Vivaldi中的Web界面有时会出现故障；在Chrome中，此类故障不太常见。 浏览档案有点沉闷。 <br> 可以下载相机中的档案，但是最多可以进行3个小时的下载。 该过程非常耗时。 <br><br> 一切似乎都很好，但您内心深处感到有些不对劲。 并且没有足够的存档深度。 您可以增加深度，但最昂贵的选择-12个月，一台摄像机的费用为每年25,000卢布（通过检测记录时）。 <br><br><h2> 让我们想出些什么吗？ </h2><br> 那是我父亲问我的问题。 我父亲想抓住建筑的所有阶段。 <br> 解决此问题有哪些选择？ 您可以每天访问Web界面，并从每个摄像机导出几段视频。 谁来执行这样沉闷的任务？ 没有人！ 一天几次打开广播摄像机并拍摄屏幕截图？ 好吧，还有精神错乱。 将档案深度增加到1年？ 好吧，一个非常便宜的解决方案。  Google告诉我，此服务已经内置了TimeLapse函数，但是分辨率很低，您无法下载它以备将来使用：:( <br>  <b>UPD：</b>原始游戏中时光倒流可以下载。 为此，请在Web界面中打开延时。 使用开发人员工具，检查网页并找到指向我们文件的链接。 连结格式： <br>  sr &lt;server_number&gt; .ipeye.ru / api / v1 / stream / &lt;uuid&gt; / nvr / timelapse / 0 / &lt;unixtimestamp&gt; /100/video.mjpeg <br><br> 决定写一些东西以某种方式保存相机的屏幕截图并形成最终的视频。 <br><br><h3> 免责声明 </h3><br> 该作品的作者不是程序员，也不打算成为一个程序员。  OOP初步了解基础知识。 敏捷等 没有研究。 一个月前，他观看了有关python的简短视频课程，并决定使用它来解决当前问题。 <br><br><h2>  API </h2><br> 很高兴发现IPEYE服务是公开可用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">API</a> 。 该API仅提供用于PHP的示例，但事实证明它很有用。 <br><br> 基于我的计算机从未关闭的事实，开发出以下概念： <br><br><ol><li>  Windows Scheduler每30分钟运行一次脚本。 </li><li> 通过API的脚本确定了我的相机的uuid。 </li><li> 通过API的脚本从相机接收照片并将其保存到目录中。 </li><li> 该脚本每天一次为每个摄像机生成一个视频文件。 </li><li> 包含源照片和最终视频的目录已绑定到云并共享。 </li><li> 亲戚想要观看游戏中时光倒流并按需要操作文件时。 </li></ol><br> 为了使用API​​，我编写了两个函数：记录和执行对API服务器的请求。 <br><br><div class="spoiler">  <b class="spoiler_title">writeLog（）</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(logdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LogEnable == <span class="hljs-number"><span class="hljs-number">1</span></span>: log_time = datetime.now() log_time = log_time.isoformat(timespec=<span class="hljs-string"><span class="hljs-string">'seconds'</span></span>) log_file = open(log_file_path, <span class="hljs-string"><span class="hljs-string">"a+"</span></span>) log_file.write(log_time + <span class="hljs-string"><span class="hljs-string">": "</span></span> + str(logdata) + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) log_file.close <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">getApiResponse（）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getApiResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method, api_uri)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> method == <span class="hljs-string"><span class="hljs-string">"GET"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r = requests.get(api_url + api_uri, timeout = api_timeout) r.raise_for_status() <span class="hljs-comment"><span class="hljs-comment">#   HTTP    except requests.exceptions.Timeout: writeLog("Error. Timeout. Request Uri:" + api_uri) except requests.exceptions.TooManyRedirects: writeLog("Error. TooManyRedirects or bad URL. Request Uri:" + api_uri) except requests.exceptions.RequestException as e: writeLog("Error. Fatal error: " + str(e) + " Request Uri:" + api_uri) sys.exit(1) except requests.exceptions.HTTPError as e: writeLog("Error. HTTP error: " + str(e) + " Request Uri:" + api_uri) if method == "POST": try: r = requests.post(api_url + api_uri, timeout = api_timeout) r.raise_for_status() #   HTTP    except requests.exceptions.Timeout: writeLog("Error. Timeout. Request Uri:" + api_uri) except requests.exceptions.TooManyRedirects: writeLog("Error. TooManyRedirects or bad URL. Request Uri:" + api_uri) except requests.exceptions.RequestException as e: writeLog("Error. Fatal error: " + str(e) + " Request Uri:" + api_uri) sys.exit(1) except requests.exceptions.HTTPError as e: writeLog("Error. HTTP error: " + str(e) + " Request Uri:" + api_uri) return r</span></span></code> </pre><br></div></div><br> 根据API，我们可以访问/ devices / all并获取所有线程上的信息。 如果您相信API文档，我立即感到困惑，不需要授权...当我询问/ devices / all时，出现错误： <blockquote> 致命错误：401客户端错误：未经授权的网址： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">api.ipeye.ru</a> ：8111 /设备/全部 </blockquote> 我修改了getApiResponse函数以传递我的凭据，但同时收到401错误。我没有列出该函数，因为 将来没有用。 <br><br> 我不得不联系技术支持。 支持团队解释说，为了通过授权使用API​​，您必须首先与IPEYE达成协议并配置Web服务器。 什么样的网络服务器以及为什么不向我解释，但是同时，他们也暗示了在何处可以获取uuid相机并未经授权访问API。 <br><br><div class="spoiler">  <b class="spoiler_title">对应支持</b> <div class="spoiler_text"><blockquote> 我：下午好。 是否可以使用API​​？ 我在网络界面中找不到uuid相机。 当我询问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">api.ipeye.ru</a>时，我想获取我的相机列表：8111 /设备/除我的用户名/密码链接之外的所有链接均无效。 <br><br>  IPEYE：作为登录名/密码，使用了API用户的授权数据，我们以合同方式提供访问权限。 <br><br> 因此，您将看到的摄像机列表不是您的登录名，而是用户API的所有摄像机。 <br><br> 我：访问两台摄像机的API需要花费多少钱？ <br><br>  IPEYE：那里的一切都更加复杂，您将需要启动您的网站并使用我们的API向其中添加相机，然后继续使用它们。 <br> 配备2台摄像机值得吗？ <br><br> 我：通常，为了理解，我仅需要访问API才能自动从相机下载屏幕截图。 为了进一步形成时间流逝。 <br><br>  IPEYE：在这种情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">api.ipeye.ru / doc＃AppDeviceJPEGOnline</a>不适合什么？ <br><br> 我：在哪里可以找到相机的UUID？ <br><br>  IPEYE：例如，从浏览器的地址栏中。 相同的UUID作为devcode参数出现在“站点代码”中。 <br><br></blockquote><br></div></div><br> 干残渣中有什么？ 实际上，如果您查看GET参数，则可以在您的帐户中找到uuid相机。 有一个方法/设备/ jpeg /在线/：uuid /：拍摄屏幕快照的名称，有uuid，我们已经知道了相机的名称。 <br><br> 我创建了一个功能来保存流中的图像。 <br><br><div class="spoiler">  <b class="spoiler_title">saveJpegFromStream（）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveJpegFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uuid, name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># api_uri = "/device/thumb/online/" + uuid + "/1920/" + name api_uri = "/device/jpeg/online/" + uuid + "/" + name writeLog("Trying save Stream screenshot for camera: " + name) response = getApiResponse("GET", api_uri) content_type = response.headers.get('content-type') if content_type is None: writeLog("Nothing to save") return False if 'text' in content_type.lower() or 'html' in content_type.lower(): writeLog("Received text data: " + response.content.decode("utf-8")) return False else: filename = dirToSave + "\\" + name + "-" + today.strftime("%Y-%m-%d-%H-%M-%S") + ".jpg" screenshot = open(filename, "wb") screenshot.write(response.content) screenshot.close() writeLog("File saved as: " + filename) return True</span></span></code> </pre><br></div></div><br> 我提出了要求，并了解有些不对劲……我们收到了文件。 图片来自我的相机，但大小可疑-66Kb。 我看一下属性并了解608 * 342绝不是1920 * 1080。 当我请求/ device / thumb / online / uuid / 1920 / name时，我得到的文件为1920 * 1080，但这只是前一个文件608 * 342扩展到所需的比例。 当然，这种情况并不适合我。 <br><br> 同样在实验期间，发现没有检查或以任何方式使用name参数。 您可以发送任何您想要的。 <br><br> 之后，我得出结论，最有用的命令/ device / url / rtsp /是获得指向RTSP流的链接。 我不得不求助于Google，因为 尚不了解如何使用RTSP。 <br><br><div class="spoiler">  <b class="spoiler_title">getStreamRTSP（）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreamRTSP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uuid, name)</span></span></span><span class="hljs-function">:</span></span> api_uri = <span class="hljs-string"><span class="hljs-string">"/device/url/rtsp/"</span></span> + uuid writeLog(<span class="hljs-string"><span class="hljs-string">"Trying get stream RTSP link for "</span></span> + name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + uuid) response = json.loads(getApiResponse(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, api_uri).text) writeLog(<span class="hljs-string"><span class="hljs-string">"Stream RTSP link for "</span></span> + name + <span class="hljs-string"><span class="hljs-string">": "</span></span> + str(response[<span class="hljs-string"><span class="hljs-string">"message"</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(response[<span class="hljs-string"><span class="hljs-string">"message"</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">saveJpegFromRTSP</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveJpegFromRTSP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, rtspLink)</span></span></span><span class="hljs-function">:</span></span> writeLog(<span class="hljs-string"><span class="hljs-string">"Trying save RTSP screenshot for camera: "</span></span> + name) rtspClient = cv2.VideoCapture(rtspLink) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rtspClient.isOpened(): _,frame = rtspClient.read() rtspClient.release() <span class="hljs-comment"><span class="hljs-comment">#       if _ and frame is not None: filename = dirToSave + "\\" + name + "-" + today.strftime("%Y-%m-%d-%H-%M-%S") + ".jpg" cv2.imwrite(filename, frame) writeLog("File saved as: " + filename) return True else: writeLog("Can't read RTSP stream") return False</span></span></code> </pre><br></div></div><br> 在上面编写了几个函数后，我意识到对于初始任务根本不需要使用API​​ :)我直接链接到摄像机的rtsp流，使用最后一个函数，我可以从摄像机捕获图像。 但是我并没有在这一步开始改变这个概念。 <br><br> 使用API​​时，有两个优点：IPEYE服务器初始化流的速度比摄像机快得多，并且rtsp摄像机流可以被防火墙关闭。 <br><br><h2>  jpg2mp4 </h2><br> 最后一步是将一台摄像机的所有图像添加到视频中。 我选择mp4v编解码器，因为  MEGA允许您在Web界面中播放这些视频文件。 <br><br><div class="spoiler">  <b class="spoiler_title">makeVideoFile（）</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeVideoFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> height = <span class="hljs-number"><span class="hljs-number">1080</span></span> width = <span class="hljs-number"><span class="hljs-number">1920</span></span> <span class="hljs-comment"><span class="hljs-comment"># video = cv2.VideoWriter(dirToSave + "\\Video" + name + ".avi", cv2.VideoWriter_fourcc(*'DIVX'), 1,(width,height)) video = cv2.VideoWriter(dirToSave + "\\Video" + name + ".mp4", cv2.VideoWriter_fourcc(*'mp4v'), 1,(width,height)) files = os.listdir(dirToSave) screenshots = list(filter(lambda x: x.startswith(name + "-"), files)) for screenshot in screenshots: origImage = cv2.imread(dirToSave + "\\" + screenshot) #  ,    ,      -   ...   #  ,        FullHD ?           API heightOrig, widthOrig, channelsOrig = origImage.shape if height != heightOrig or width != widthOrig: img = cv2.resize(origImage, (width, height)) video.write(img) else: video.write(origImage) cv2.destroyAllWindows() video.release()</span></span></code> </pre><br></div></div><br> 供参考：45个jpg文件，视频格式的总容量为37.3 MB，占用16.9 MB。 <br><br> 感谢您阅读我的第一篇公开文章。 我试图以故事的形式描述一切，而不是简单地做，因为我不想在出路时拿到枯燥的文章。 <br><br> 我会很高兴发表评论，因为我不到一个月前遇到了python。 <br><br> 带有扩展注释的完整脚本可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上找到。 此外，该脚本考虑了时区的差异，并且编写了所有其余功能以快速缩放到不同数量的摄像机。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475154/">https://habr.com/ru/post/zh-CN475154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475134/index.html">高科技欺诈的另一种方式</a></li>
<li><a href="../zh-CN475138/index.html">有益地使用Raspberry Pi的5种方法 第二部分</a></li>
<li><a href="../zh-CN475142/index.html">睡眠，放松和音乐：专业运动员如何克服疲劳，我们该如何做</a></li>
<li><a href="../zh-CN475144/index.html">将Laravel分为组件</a></li>
<li><a href="../zh-CN475146/index.html">一次数据恢复尝试的痛苦或悠久的历史</a></li>
<li><a href="../zh-CN475158/index.html">Playme P570 Mono评论：简而言之</a></li>
<li><a href="../zh-CN475162/index.html">在现代C ++代码中使用X-Macro</a></li>
<li><a href="../zh-CN475164/index.html">讨论：互联网依赖开源-评论家有哪些论点</a></li>
<li><a href="../zh-CN475170/index.html">在React.JS上创建数据驱动的应用程序的基本模式问题</a></li>
<li><a href="../zh-CN475172/index.html">有益地使用Raspberry Pi的5种方法 第三部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>