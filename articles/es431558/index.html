<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 😊 📪 Si inventar un lenguaje de programación del siglo XXI 👴🏻 🐆 ⛅️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del artículo analiza los problemas de los lenguajes de programación modernos y las formas en que se pueden corregir las deficiencias. 


 Sol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Si inventar un lenguaje de programación del siglo XXI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wirex/blog/431558/">  <i>El autor del artículo analiza los problemas de los lenguajes de programación modernos y las formas en que se pueden corregir las deficiencias.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/nl/u6/tknlu6j7laqqcrsjz_arrflsebm.jpeg"></div><br>  Solo en los últimos 18 años, las personas han ideado muchos idiomas, entre los cuales probablemente los más populares son Swift, Kotlin y Go.  Además, la característica distintiva del lenguaje de programación del siglo XXI es la ausencia de características distintivas.  Lo más agradable de trabajar con estos idiomas es que puedes pasar un fin de semana aprendiendo uno de ellos y finalmente decir que lograste aprender una novedad popular, pero que de hecho no has aprendido nada nuevo.  Realmente no son nada nuevo.  Todos los lenguajes modernos se crean sobre la base de alguna fórmula correcta y probada, cuyo nombre es probablemente Objective-C, Java o C. <br><br>  La "falta de novedad" puede considerarse una característica valiosa, pero esta situación plantea una pregunta.  ¿Estamos realmente frente a los idiomas del nuevo siglo XXI, o todo esto es solo un reflejo de los malos hábitos de programación del siglo XX? <br><br>  Si inventara el lenguaje, no trataría de corregir el pasado, sino que trataría de crear algo que funcionara bien en las condiciones modernas, pero que también pudiera desarrollar y resistir la prueba del tiempo.  Si esto requiere soluciones constructivas radicales, que así sea. <br><br><h3>  ¡Abajo la sintaxis! </h3><br>  La sintaxis de los idiomas modernos refleja un intento de exprimir la libertad de la tiza y el pizarrón en los grilletes de ASCII.  Algunos elementos de un registro, como signos aritméticos o corchetes, se perciben de manera más o menos natural.  Pero una serie de otras designaciones se justifican solo ahorrando esfuerzo al presionar los botones de teletipo. <a name="habracut"></a><br><br>  Introducir texto desde el teclado ya no es difícil.  No estamos obligados a ponernos en una posición en la que sea necesario adivinar el significado de la sintaxis.  Piezas como <i>(($: @ (&lt;# [), (= # [), $: @ (&gt; # [)) ({~? @ #)) ^: (1 &lt;#)</i> - un formato de grabación muy corto y espacioso (esto, por cierto, es un código <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">real</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenguaje real</a> ), pero no mejora la legibilidad de ninguna manera.  Y, lo que es más importante, es difícil "googlearlo" o encontrarlo en stackoverflow. <br><br>  Lo mismo puede decirse sobre los misteriosos nombres de funciones, convenciones de códigos de retorno y atributos con un significado oscuro.  Sirvieron bien en el pasado, ahorrando mucho espacio en tarjetas perforadas, pero hoy es el momento para un merecido descanso. <br><br>  Algo como <br><br> <code>FILE * test_file = fopen("/tmp/test.txt", "w+");</code> <br> <br>  debe transformarse en <br><br> <code>create file /tmp/test.txt for input and output as test_file</code> <br> <br>  No necesitamos todos estos corchetes, comillas, asteriscos y punto y coma (a menos que, por supuesto, realmente no transmitan la idea más claramente).  El resaltado de sintaxis es bastante capaz de reemplazar completamente la notación de sintaxis. <br><br>  Algunas cosas abundantes están disponibles en el siglo XXI: por ejemplo, velocidad de análisis, memoria de computadora, búsqueda en línea.  Otros recursos aún están en precio: tiempo de desarrollo, memoria del programador, esfuerzo dedicado al aprendizaje de las características del lenguaje.  Los cambios en las reglas para escribir código deberían cambiar el enfoque hacia recursos más baratos y ahorrar recursos más caros. <br><br><h3>  ¡Abajo los tipos incorporados! </h3><br>  Probablemente esté familiarizado con las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paradojas de JavaScript</a> .  Por ejemplo, tales: <br><br> <code>&gt; 10.8 / 100 <br> 0.10800000000000001</code> <br> <br>  Este resultado no es exclusivo de JavaScript.  Y esto no es una paradoja en absoluto, sino un ejemplo de adhesión absolutamente correcta al respetado estándar IEEE 754. Una implementación similar de números de punto flotante se encuentra en casi todas las arquitecturas.  Y no es tan malo, teniendo en cuenta que estamos tratando de meter un número infinito de números reales en 32, 64 o 256 bits. <br><br>  Lo que los matemáticos consideran imposible, los ingenieros encarnan el rechazo del sentido común en aras de la implementación práctica.  Los números de coma flotante en la interpretación IEEE no son números en absoluto.  Las matemáticas requieren asociatividad de la operación de su adición.  Los tipos flotante y doble no siempre guardan esta propiedad.  Las matemáticas requieren que el conjunto de números reales incluya enteros, pero este requisito no se cumple ni siquiera para float y uint32_t del mismo tamaño.  Las matemáticas requieren que los números reales tengan un elemento cero.  Bueno, a este respecto, el estándar IEEE supera todas las expectativas, porque los números de coma flotante tienen dos elementos cero en lugar de uno. <br><br>  No solo los números de coma flotante tienen características similares.  Los enteros integrados no están mejor implementados.  ¿Sabes qué sucede si intentas agregar dos números de 16 bits? <br><br> <code>0xFFFF + 0x0001</code> <br> <br>  Nadie dará una respuesta exacta.  Un instinto nos dice que el desbordamiento dará 0x0000.  Sin embargo, dicho resultado no está documentado en ninguna norma internacional.  Al manejar esta operación, todos se guían por el enfoque C y la familia de procesadores x86.  Alternativamente, puede resultar 0xFFFF, o se activará una interrupción, o se almacenará un bit especial que indica desbordamiento en un lugar especial. <br><br>  Tales momentos generalmente no se consideran en ningún lado, y las reglas para procesar tales operaciones difieren de un idioma a otro.  Si las rarezas de coma flotante están al menos fijadas por el estándar, entonces la última pregunta planteada es, en principio, impredecible. <br><br>  En cambio, para los cálculos numéricos, sugeriría introducir tipos de datos de un valor definible con un punto fijo y con un comportamiento estandarizado en caso de pérdida de precisión o ir más allá del límite superior o inferior.  Algo como esto: <br><br> <code>1.000 / 3.000 = 0.333 <br> 0001 + 9999 = overflowed 9999 <br> 0.001 / 2 = underflowed 0</code> <br> <br>  No es necesario agregar todos los ceros finales: su presencia debe estar implícita en la definición del tipo de datos.  Pero es importante poder elegir los límites máximos y mínimos usted mismo, y no depender de la arquitectura del procesador. <br><br>  ¿No funcionarán tales cálculos más lentamente?  Sí lo harán  Pero pregúntese: ¿con qué frecuencia tiene que programar la informática de alto rendimiento?  Creo que si no eres un experto en este campo, entonces es muy raro.  Y si está involucrado en tales tareas, entonces utiliza equipos y compiladores especializados para estos fines.  Por lo que puedo decir, un programador típico del siglo XXI rara vez resuelve ecuaciones diferenciales. <br><br>  Sea como fuere, nada impide el uso de tipos integrados rápidos, complejos e impredecibles del pasado como alternativa, en lugar de como la opción predeterminada. <br><br><h3>  ¡Abajo la práctica de los metalenguajes! </h3><br>  Hay lenguajes maravillosos que se inventaron no para realizar tareas, sino para crear idiomas que sean capaces de realizarlas.  Racket, Rebol y Forth son solo algunos ejemplos.  Me gustan todos, jugar con ellos es puro placer.  Pero, como probablemente haya adivinado, el placer recibido de trabajar con el idioma no es el criterio principal que hace que el idioma sea universal y popular. <br><br>  La capacidad de crear nuevos idiomas dentro de un idioma para realizar una tarea en particular es una herramienta muy poderosa que vale la pena durante el trabajo de investigación independiente.  Desafortunadamente, si el código debe ser claro no solo para el autor, además del principal, tendrá que enseñar a otras personas y el nuevo idioma interno.  Y aquí comienzan los problemas. <br><br>  La gente quiere completar la tarea, y no aprender un idioma que ayudará a hacer el trabajo exactamente una vez, y después de eso no serán útiles.  Para los extraños, la idea de dominar su idioma es una inversión que es poco probable que valga la pena.  Pero aprender algo estandarizado es una inversión para toda la vida.  Por lo tanto, más bien, volverán a escribir su código nuevamente y solo entonces lo aprenderán.  Por lo tanto, innumerables dialectos aparecen para una esfera aplicada.  La gente discute sobre estética, ideología, arquitectura y otras cosas sin importancia.  Y millones de líneas de código están escritas para hundirse en el olvido en unos pocos meses. <br><br>  Los chicos de Lisp pasaron por esto en los años 80.  Se dieron cuenta de que mientras más elementos del lenguaje aplicado estén estandarizados, mejor.  Así surgió Common Lisp. <br><br>  Y él era enorme.  El estándar INCITS 226–1994 tiene 1.153 páginas.  Este registro, 17 años después, se rompió solo por C ++ con el estándar ISO / IEC 14882: 2011 (1338 páginas).  C ++ tiene que arrastrar un legado insoportable, a pesar de que no siempre ha sido tan grande.  Common Lisp fue creado en su mayor parte desde cero. <br><br>  El lenguaje de programación no debería ser tan grande.  Esto no es necesario  Solo necesita una buena biblioteca estándar, llena de todo tipo de cosas útiles, para que las personas no tengan que reinventar la rueda. <br><br>  Por supuesto, mantener un equilibrio entre el tamaño y la idoneidad de la aplicación no es fácil.  La experiencia de C ++ en la práctica ha demostrado lo difícil que es.  Creo que para lograr el equilibrio necesario, el lenguaje del siglo XXI debe agudizarse condicionalmente bajo cierto campo aplicado.  Dado que la mayoría de los problemas ahora surgen precisamente en el campo de las aplicaciones empresariales, el lenguaje probablemente debería centrarse en los problemas empresariales, y no en el desarrollo de juegos o el diseño web. <br><br><h3>  Entonces ... </h3><br>  El lenguaje del siglo XXI debe estar orientado a los negocios, usar expresiones de lenguaje claro y no depender de tipos incorporados.  ¡Es genial que tal lenguaje ya exista!  ¿Qué piensas, de qué estamos hablando? <br><br>  Sí, esto es COBOL. <br><br>  Este es uno de los primeros idiomas de alto nivel, hoy mayormente olvidado.  Tengo que admitir que describí intencionalmente las características antiguas de COBOL como ultramodernas e increíblemente prometedoras.  Y lo hice para mostrar una cosa.  El código no está escrito por características del lenguaje.  Tu lo haces <br><br>  Es ingenuo pensar que el idioma es responsable de la calidad del código, y que agregar algunos dispositivos (o eliminarlos) puede mejorar automáticamente todo.  Hubo un tiempo en que a los programadores no les gustaban Fortran y COBOL, por lo tanto, inventaron C ++ y Java, para finalmente llegar a una situación en la que, 20 o 30 años después, tampoco les gustaban a todos. <br><br>  Según mis sentimientos, la raíz del problema se encuentra en algún lugar del campo de la sociología y la psicología, pero no en la programación.  ¿Realmente nos disgustan tanto los idiomas?  ¿Y estamos satisfechos con el entorno en el que trabajamos?  Windows es vulnerable, Visual Studio es demasiado lento, es imposible salir de Vim.  De hecho, son estas cosas las que causan descontento, y no el proceso creativo en sí. <br><br>  Pero siempre tienes que encontrar al culpable.  Como ingenieros de software, en parte responsables de lo pésimos que son los programas, no nos culparemos, ¿verdad?  Por lo tanto, estamos buscando fallas en las herramientas.  Inventemos nuevos COBOL hasta que un día el sol comience a brillar más, las aves no canten más fuerte y Windows comience a cargarse en 2 segundos. <br><br>  Pero lo más probable es que este día nunca llegue. <br><br>  Por lo tanto, si quisiera inventar el lenguaje de programación del siglo XXI, trataría de encontrar un nuevo enfoque de responsabilidad.  O una nueva forma de dominar mejor las herramientas existentes.  Intentaría estar más atento a los detalles esenciales y deshacerme sin piedad de cualquier complejidad innecesaria.  En lugar de idiomas que entran y pasan de moda, siempre hay algunas cosas fundamentales que merecen un replanteamiento constante. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/4bd/bf6/597/4bdbf659775744b1bdbb4d8a00a0a980.png" alt="imagen"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431558/">https://habr.com/ru/post/es431558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431546/index.html">¿Por qué estamos diciendo bien?</a></li>
<li><a href="../es431548/index.html">Solar Dozor - ¿Qué hay detrás de las estrellas?</a></li>
<li><a href="../es431550/index.html">Moldeo por inyección de película (IMD): cómo funciona</a></li>
<li><a href="../es431554/index.html">Facebook como contador de un viejo medidor eléctrico</a></li>
<li><a href="../es431556/index.html">Sidenis sobre trabajar con corporaciones de seguros, entrenamiento ágil y tecnologías prohibidas</a></li>
<li><a href="../es431560/index.html">Acceso a redes de señalización SS7 a través del subsistema de radio: ahora es posible</a></li>
<li><a href="../es431562/index.html">Cómo rodar con código heredado cuando se necesitaba un proyecto ayer</a></li>
<li><a href="../es431564/index.html">El mayor error en la historia de la física.</a></li>
<li><a href="../es431566/index.html">Acelerómetros y giroscopios MEMS: comprensión de las especificaciones</a></li>
<li><a href="../es431568/index.html">Fintech digest: pago por teléfono, cajeros automáticos atacan de nuevo, institucionalización de la criptosfera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>