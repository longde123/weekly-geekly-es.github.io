<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ ğŸ¤œğŸ¼ ğŸ‘¨ğŸ¿â€ğŸ”¬ Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 3. Observasi Tingkat Tinggi ğŸ‘¨ğŸ¿â€âœˆï¸ ğŸŒµ ğŸšŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini kita akan melihat bagaimana mungkin untuk memproses yang lain dalam satu utas, mengapa diperlukan, dan bagaimana Observable Order Ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar pemrograman reaktif menggunakan RxJS. Bagian 3. Observasi Tingkat Tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450050/"><img src="https://habrastorage.org/webt/kk/rj/yw/kkrjywqpfptl1uta2ou9bltd-je.png"><br><br>  Dalam artikel ini kita akan melihat bagaimana mungkin untuk memproses yang lain dalam satu utas, mengapa diperlukan, dan bagaimana Observable Order Tinggi (selanjutnya disebut HOO) operator akan membantu kami dalam hal ini. <br><br>  Seri artikel "Dasar-dasar pemrograman reaktif menggunakan RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Reaktivitas dan aliran</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Operator dan pipa</a> </li></ul><br><br>  Ketika bekerja dengan utas, suatu situasi sering muncul ketika perlu untuk mentransfer hasil yang lain ke utas sebagai nilai.  Sebagai contoh, kami ingin menjalankan permintaan ajax dan memproses responsnya di utas saat ini, atau menjalankan beberapa permintaan paralel, menerapkan pengumpulan.  Saya pikir banyak orang terbiasa memecahkan masalah seperti itu menggunakan mekanisme seperti janji.  Tetapi apakah mungkin untuk menyelesaikannya menggunakan RxJS?  Tentu saja, dan semuanya jauh lebih mudah daripada yang Anda pikirkan! <br><a name="habracut"></a><br>  <b>Catatan</b> : untuk memahami bagian teoritis artikel, Anda tidak harus membaca artikel sebelumnya, Anda hanya perlu tahu apa yang dapat diamati, operator dan pipa.  Pada bagian praktis, kami akan memperbaiki contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kedua</a> , yang dapat Anda temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> . <br><br><h4>  Masalah </h4><br>  Mari kita bayangkan tugas berikut: kita perlu mencari tahu setiap detik apakah server dapat diakses.  Bagaimana kita bisa menyelesaikannya? <br><br>  Pertama, buat aliran menggunakan metode pengatur waktu: <br><br><pre><code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre> <br>  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">timer</a> sangat mirip secara prinsip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">interval</a> .  Tapi tidak seperti itu, ini memungkinkan Anda untuk mengatur waktu mulai utas, yang dikirim oleh parameter pertama.  Parameter kedua menunjukkan interval di mana nilai baru akan dihasilkan.  Jika parameter kedua tidak ditentukan, timer hanya akan menghasilkan satu nilai dan menghentikan aliran. <br><br>  Karena Anda dan saya tidak memiliki server, saya sarankan hanya menulis fungsi yang mengemulasi permintaan ke server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> makeRequest = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mapTo(<span class="hljs-string"><span class="hljs-string">'success'</span></span>) ) }</code> </pre><br>  Apa yang dilakukan metode ini?  Ini mengembalikan aliran yang dibuat menggunakan metode timer, yang memancarkan nilai setelah satu detik berlalu dan berakhir.  Karena metode penghitung waktu hanya menghasilkan angka, kami menggunakan operator mapTo untuk menggantinya dengan string "sukses". <br><br>  Seperti inilah aliran yang dibuat oleh metode makeRequest: <br><br><img src="https://habrastorage.org/webt/5t/0a/pf/5t0apfljjo-5lc9buhsd9455mrk.png"><br><br>  Sekarang kita punya pilihan: untuk memanggil metode makeRequest di dalam aliran atau untuk menyerahkan tanggung jawab ini kepada pengamat? <br><br>  Pendekatan pertama lebih disukai, karena dalam hal ini kita akan dapat menggunakan potensi penuh RxJS dengan operatornya dan membebaskan pengamat kita dari tugas yang tidak perlu.  Kami menggunakan metode timer untuk mengeksekusi permintaan dengan interval: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Ketika kita menjalankan kode seperti itu, kita akan melihat bahwa di console.log kita tidak mendapatkan pesan dengan teks "success", tetapi objek bertipe Observable: <br><br><img src="https://habrastorage.org/webt/ld/bd/ue/ldbduelhulehfiqmbm80sm3zgu8.png"><br><br>  Jawabannya cukup diharapkan, karena di peta kami mengembalikan aliran.  Agar streaming berfungsi, Anda harus berlangganan.  Baiklah, mari kita lihat bagaimana <b>tidak melakukannya</b> : <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable</span></span></span><span class="hljs-function"> =&gt;</span></span> observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); });</code> </pre><br>  Masalah dengan contoh di atas adalah kita mendapatkan langganan dalam langganan.  Tetapi bagaimana jika kita ingin membuat lebih dari satu permintaan dalam satu rantai?  Atau bagaimana jika pada suatu saat kita perlu berhenti berlangganan dari aliran di dalam?  Dalam hal ini, kode kita akan semakin menyerupai "mie".  Untuk mengatasi masalah ini, RxJS memiliki operator khusus yang disebut HOO. <br><br><h4>  Hoo </h4><br>  HOO adalah jenis pernyataan khusus yang menerima aliran sebagai nilai.  Salah satu operator tersebut adalah metode mergeAll. <br><br>  Ketika aliran tiba di mergeAll, itu berlangganan.  Aliran dimana operator berlangganan disebut internal.  Aliran dari mana operator menerima aliran lain sebagai nilai disebut eksternal. <br><br>  Ketika utas internal menghasilkan nilai, menggabungkan Semua mendorong nilai itu ke utas eksternal.  Dengan demikian, kami menyingkirkan kebutuhan untuk berlangganan secara manual.  Jika kami berhenti berlangganan dari aliran eksternal, maka menggabungkan semua akan berhenti secara otomatis dari yang internal. <br><br>  Mari kita lihat bagaimana kita dapat menulis ulang contoh kita dengan mergeAll: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Dalam contoh di atas, aliran eksternal dibuat oleh pernyataan timer.  Dan aliran yang dibuat di operator peta bersifat internal.  Setiap utas yang dibuat jatuh ke dalam pernyataan mergeAll. <br><br><img src="https://habrastorage.org/webt/la/va/m1/lavam1n0lygvuyfolgwfd6yfyd0.png"><br><br>  Peta kombinasi + mergeAll digunakan sangat sering, oleh karena itu di RxJS ada metode mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> makeRequest()) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br>  Ketika utas eksternal menghasilkan nilai, operator mergeMap memanggil fungsi panggil balik yang dilaluinya, yang menghasilkan utas baru.  Kemudian, gabung berlangganan berlangganan aliran yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/n1/rh/ks/n1rhksa9atkguhglj7by5p45bew.png"><br><br>  Kekhasan operator mergeAll / mergeMap adalah jika aliran lain turun ke sana, maka ia juga berlangganan.  Jadi, dalam aliran eksternal, kita bisa mendapatkan nilai dari beberapa yang internal sekaligus.  Mari kita lihat contoh berikut: <br><br><pre> <code class="javascript hljs"> timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  Beginilah tampilan stream eksternal tanpa operator mergeMap: <br><br><img src="https://habrastorage.org/webt/ie/ww/8j/ieww8j7-t1lnixucckiwzzqrmxc.png"><br><br>  Demikian juga dengan mergeMap: <br><br><pre> <code class="javascript hljs">timer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) )</code> </pre><br><img src="https://habrastorage.org/webt/lw/0p/_o/lw0p_ownbroitrzyxksva1lhexe.png"><br><br>  Setiap detik, kami membuat utas internal baru dan menggabungkan subscribe.  Dengan demikian, kami memiliki banyak utas internal yang bekerja secara bersamaan, nilai-nilai dari mana jatuh ke eksternal: <br><br><img src="https://habrastorage.org/webt/ar/il/_v/aril_vrkhr-jrn1jkllqj6io-ec.png"><br><br><img src="https://habrastorage.org/webt/jv/wh/um/jvwhumoobhmtyejohzsxkc26oae.png"><br><br>  <b>Catatan</b> : hati-hati menggunakan mergeMap, setiap utas internal baru akan berfungsi sampai Anda berhenti berlangganan dari eksternal.  Pada contoh di atas, jumlah utas internal bertambah setiap detik, pada akhirnya bisa ada begitu banyak utas sehingga komputer tidak dapat mengatasi beban. <br><br><h4>  concatAll / concatMap </h4><br>  Metode mergeMap sangat bagus ketika Anda tidak peduli dengan urutan eksekusi utas internal, tetapi bagaimana jika Anda membutuhkannya?  Misalkan kita ingin permintaan server berikutnya hanya dieksekusi setelah menerima respons dari yang sebelumnya? <br><br>  Untuk tujuan tersebut, operator HOO concatAll / concatMap cocok.  Operator ini, setelah berlangganan ke utas internal, menunggu sampai selesai, dan hanya kemudian berlangganan yang berikutnya. <br><br>  Jika selama eksekusi dari satu utas yang baru turun ke sana, maka ia ditempatkan di antrian sampai yang sebelumnya selesai. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  1     const firstInnerObservable = timer(1000).pipe( mapTo(1) ); // ,  2     const secondInnerObservable = timer(500).pipe( mapTo(2) ); of( firstInnerObservable, secondInnerObservable ).pipe( concatAll() ).subscribe({ next: console.log });</span></span></code> </pre><br>  Pada contoh di atas, kami membuat dua utas menggunakan metode pengatur waktu.  Untuk kejelasan, saya menggunakan operator mapTo untuk menampilkan nilai yang berbeda.  Utas pertama akan menghasilkan 1, yang kedua - 2. Utas eksternal dibuat menggunakan metode, yang mengambil dua di atas yang dapat diamati sebagai input. <br><br>  Pernyataan concatAll pertama kali menerima firstInnerObservable, berlangganan, dan menunggu sampai selesai, dan hanya setelah selesai berlangganan pertama ke secondInnerObservable.  Inilah yang akan terlihat seperti aliran eksternal: <br><br><img src="https://habrastorage.org/webt/dz/cd/mi/dzcdmibwf773qa025bqlqfd9oe4.png"><br><br>  Jika kami mengganti concatAll dengan mergeAll, maka aliran akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( mergeAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ax/o3/tw/axo3tw1onffl5zq956-ewdjdf8q.png"><br><br><h4>  switchAll / switchMap </h4><br>  Operator ini berbeda dari yang sebelumnya ketika menerima aliran baru, ia segera berhenti berlangganan dari yang sebelumnya dan berlangganan yang baru. <br><br>  Ambil contoh di atas dan ganti concatAll dengan switchAll, dan lihat bagaimana aliran eksternal berperilaku: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( switchAll() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/ec/ra/sm/ecrasmknkfvubsngt7c_dcrtu1w.png"><br><br>  Hanya nilai dari aliran internal kedua yang masuk ke aliran eksternal.  Itu karena switchMap berhenti berlangganan dari yang pertama saat menerima utas kedua. <br><br>  Kapan ini dibutuhkan?  Misalnya, saat menerapkan pencarian data.  Jika respons dari server belum datang, dan kami telah mengirim permintaan baru, maka kami tidak masuk akal untuk menunggu yang sebelumnya. <br><br><h4>  knalpot / exhaustMap </h4><br>  knalpot adalah kebalikan dari pernyataan switchAll, dan perilakunya mirip dengan concatAll.  Metode ini, berlangganan aliran, menunggu sampai selesai.  Jika aliran baru turun ke sana, maka itu hanya dibuang. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">of</span></span>( firstInnerObservable, secondInnerObservable ).pipe( exhaust() ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log });</code> </pre><br><img src="https://habrastorage.org/webt/2m/x7/ur/2mx7urryxakugfc8srx3lffn92c.png"><br><br>  Dalam contoh di atas, kami tidak mendapatkan deuce, karena pada saat itu operator sedang menunggu penyelesaian utas pertama, dan hanya menjatuhkan yang kedua. <br><br>  Saya pikir banyak yang punya pertanyaan, kapan perilaku seperti itu dibutuhkan?  Contoh yang baik adalah formulir login.  Tidak masuk akal untuk mengirim beberapa permintaan ke server sampai yang saat ini selesai. <br><br><h4>  Kami sedang menyelesaikan aplikasi </h4><br>  Kami ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">contoh</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel kedua</a> .  Di dalamnya, kami menerapkan pencarian di GitHub dan menggunakan operator mergeMap untuk mengirim permintaan ke server.  Sekarang kita tahu fitur-fitur operator ini, apakah ini benar-benar cocok untuk kasus kita? <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Mari kita asumsikan bahwa server GitHub akan kelebihan beban, maka memproses respons kita akan memakan banyak waktu.  Apa yang mungkin salah dalam kasus ini? <br><br>  Misalkan pengguna memasukkan beberapa data, tidak menunggu jawaban, dan memasukkan yang baru.  Dalam hal ini, kami akan mengirimkan permintaan kedua ke server.  Namun, tidak ada yang menjamin bahwa jawaban untuk permintaan pertama akan datang lebih awal. <br><br>  Karena operator mergeMap tidak peduli dalam urutan apa untuk memproses utas internal, dalam kasus ketika permintaan pertama dieksekusi lebih lambat dari yang kedua, kami akan menghapus data aktual.  Oleh karena itu, saya mengusulkan untuk mengganti metode mergeMap dengan switchMap: <br><br><pre> <code class="javascript hljs">fromEvent(input, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>).pipe( debounceTime(<span class="hljs-number"><span class="hljs-number">700</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> event.target.value), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function"> =&gt;</span></span> val.length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), distinctUntilChanged(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(getUsersRepsFromAPI(value)).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([])) ) }) ).subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reps</span></span></span><span class="hljs-function"> =&gt;</span></span> recordRepsToList(reps) })</code> </pre><br>  Sekarang, jika pengguna memasukkan data baru, switchMap akan berhenti berlangganan dari aliran sebelumnya dan berlangganan yang baru. <br><br>  Perlu dicatat bahwa permintaan http kami akan terus hang sampai server memberikan jawaban.  Namun, karena kami telah berhenti berlangganan dari aliran internal, jawabannya tidak akan jatuh ke aliran eksternal. <br><br>  <b>Catatan</b> : jika Anda bekerja dengan Angular dan menggunakan HttpClient untuk bekerja dengan http, maka Anda tidak dapat khawatir tentang membatalkan permintaan itu sendiri.  HttpClient dapat melakukan ini untuk Anda ketika berhenti berlangganan. <br><br><h4>  Batalkan http </h4><br>  Fetch api memiliki kemampuan untuk membatalkan permintaan http menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">AbortController</a> .  Ketika dikombinasikan dengan operator switchMap, fungsi ini akan menghemat lalu lintas pengguna. <br><br>  Mari kita tulis ulang contoh kita sedikit.  Dan buat metode yang akan membungkus panggilan pengambilan di diamati: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createCancellableRequest = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      const controller = new AbortController(); const signal = controller.signal; return new Observable(observer =&gt; { fetch(url, { signal }) .then(response =&gt; { if (response.ok) { return response.json(); } throw new Error(''); }) //     .then(result =&gt; observer.next(result)) //   .then(() =&gt; observer.complete()) //   ,     .catch(error =&gt; observer.error(error)); // ,    return () =&gt; { //   controller.abort(); }; }); };</span></span></code> </pre><br>  Juga ubah metode getUsersRepsFromApi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getUsersRepsFromAPI = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/users/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ username }</span></span></span><span class="hljs-string">/repos`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createCancellableRequest(url); }</code> </pre><br>  Sekarang metode tersebut tidak mengembalikan janji, tetapi dapat diamati.  Oleh karena itu, kami menghapus bungkus dari di switchMap: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getUsersRepsFromAPI(value).pipe( catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>([]) ) )</code> </pre><br>  <b>Catatan</b> : dalam RxJS versi 6.5, mereka menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pernyataan fromFetch</a> , yang dengan sendirinya menyebut metode abort di bawah kap, sehingga Anda tidak perlu lagi menulis "sepeda" sendiri. <br><br>  Itu saja!  Semua kode sampel dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> . <br><br><h4>  Kesimpulan </h4><br>  Hari ini kami melihat apa itu HOO dan beberapa operator yang sangat berguna dari kategori ini.  Tentu saja, ini jauh dari semuanya.  Untuk informasi yang lebih terperinci dan terperinci, saya sarankan mengunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dokumentasi</a> RxJS. <br><br>  Dalam artikel selanjutnya saya berencana untuk mempertimbangkan apa perbedaan antara Panas dan Dingin yang dapat diamati. <br><br>  Akhirnya: jangan menggunakan langganan dalam langganan, karena ada HOO! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450050/">https://habr.com/ru/post/id450050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450036/index.html">Summ3r 0f h4ck: magang Keamanan Digital 2019</a></li>
<li><a href="../id450040/index.html">Perusahaan baru akan mendukung OpenJDK 8 dan 11 - kami memahami situasinya</a></li>
<li><a href="../id450042/index.html">Tata letak keyboard diperpanjang Rusia</a></li>
<li><a href="../id450044/index.html">Mencari masalah di tempat yang salah</a></li>
<li><a href="../id450048/index.html">Komentar tentang perubahan Undang-Undang Federal No. 149-Ğ¤Ğ— â€œTentang Informasi, Teknologi Informasi, dan Perlindungan Informasiâ€</a></li>
<li><a href="../id450054/index.html">Meretas token jwt</a></li>
<li><a href="../id450056/index.html">Bayar Perhatian # 2: Intisari Artikel tentang Pemikiran Produk, Psikologi Perilaku, dan Produktivitas Pribadi</a></li>
<li><a href="../id450058/index.html">Resume orang itu</a></li>
<li><a href="../id450060/index.html">Bagaimana saya mengetahui bahwa visa saya belum siap, sebuah pesan di Slack</a></li>
<li><a href="../id450062/index.html">Memulihkan sirkulasi di otak beberapa jam setelah kematian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>