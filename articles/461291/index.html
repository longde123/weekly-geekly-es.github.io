<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèΩ üç¥ üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ Golang: problemas de rendimiento espec√≠ficos üåÇ ü§ûüèº üîü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El lenguaje Go est√° ganando popularidad. Tan seguro de que hay m√°s y m√°s conferencias, por ejemplo, GolangConf , y el lenguaje se encuentra entre las ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: problemas de rendimiento espec√≠ficos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  El lenguaje Go est√° ganando popularidad.  Tan seguro de que hay m√°s y m√°s conferencias, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GolangConf</a> , y el lenguaje se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encuentra entre las diez</a> tecnolog√≠as mejor pagadas.  Por lo tanto, ya tiene sentido hablar sobre sus problemas espec√≠ficos, por ejemplo, el rendimiento.  Adem√°s de los problemas comunes para todos los idiomas compilados, Go tiene el suyo.  Est√°n asociados con el optimizador, la pila, el sistema de tipos y el modelo multitarea.  Las formas de resolverlos y las soluciones alternativas a veces son muy espec√≠ficas. <br><br>  <strong>Daniel Podolsky</strong> , aunque el evangelista de Go, tambi√©n encuentra muchas cosas extra√±as en √©l.  Todo lo extra√±o y, lo m√°s importante, interesante, recopila y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba</a> , y luego habla de ello en HighLoad ++.  La transcripci√≥n del informe incluir√° n√∫meros, gr√°ficos, ejemplos de c√≥digo, resultados del generador de perfiles, una comparaci√≥n del rendimiento de los mismos algoritmos en diferentes idiomas, y todo lo dem√°s, por lo que odiamos la palabra "optimizaci√≥n".  No habr√° revelaciones en la transcripci√≥n, de d√≥nde provienen en un lenguaje tan simple, y todo lo que se pueda leer en los peri√≥dicos. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>Sobre los oradores.</strong>  <b>Daniil Podolsky</b> : 26 a√±os de experiencia, 20 en operaci√≥n, incluido el l√≠der del grupo, 5 a√±os de programaci√≥n en Go.  <b>Kirill Danshin</b> : creador de Gramework, Maintainer, Fast HTTP, Black Go-mage. <br><br>  <em>El informe fue preparado conjuntamente por Daniil Podolsky y Kirill Danshin, pero Daniel hizo un informe y Cyril ayud√≥ mentalmente.</em> <br><br><h2>  Construcciones de lenguaje </h2><br>  Tenemos un est√°ndar de rendimiento: <code>direct</code> .  Esta es una funci√≥n que incrementa una variable y ya no hace nada. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  El resultado de la funci√≥n es <b>1.46 ns por operaci√≥n</b> .  Esta es la opci√≥n m√≠nima.  M√°s r√°pido que 1.5 ns por operaci√≥n, probablemente no funcionar√°. <br><br><h3>  Diferir c√≥mo lo amamos </h3><br>  Muchos saben y aman usar la construcci√≥n de lenguaje diferido.  Muy a menudo lo usamos as√≠. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  ¬°Pero no puedes usarlo as√≠!  Cada aplazador come 40 ns por operaci√≥n. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Pens√© que tal vez esto es por inline?  Tal vez en l√≠nea es tan r√°pido? <br><br>  Direct est√° en l√≠nea y la funci√≥n diferir no puede estar en l√≠nea.  Por lo tanto, compil√≥ una funci√≥n de prueba separada sin en l√≠nea. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Nada ha cambiado, diferir tom√≥ los mismos 40 ns.  Diferir querido, pero no catastr√≥fico. <br><br><blockquote>  Cuando una funci√≥n toma menos de 100 ns, puede hacerlo sin diferir. </blockquote><br>  Pero cuando la funci√≥n tarda m√°s de un microsegundo, es lo mismo: puede usar aplazar. <br><br><h3>  Pasando un par√°metro por referencia </h3><br>  Considera un mito popular. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Nada ha cambiado, nada vale la pena. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Excepto por 3 ns por aplazamiento, pero esto se cancela por fluctuaciones. <br><br><h3>  Funciones an√≥nimas </h3><br>  A veces los novatos preguntan: "¬øEs costosa una funci√≥n an√≥nima?" <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Una funci√≥n an√≥nima no es costosa, toma 40.4 ns. </blockquote><br><h3>  Interfaces </h3><br>  Hay una interfaz y estructura que lo implementa. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Hay tres opciones para usar el m√©todo de incremento.  Directamente desde Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  Desde la interfaz concreta correspondiente: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Con conversi√≥n de interfaz en tiempo de ejecuci√≥n: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  A continuaci√≥n se muestra la conversi√≥n y el uso de la interfaz en tiempo de ejecuci√≥n directamente. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  La interfaz, como tal, no cuesta nada. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  La conversi√≥n de la interfaz de tiempo de ejecuci√≥n vale la pena, pero no es costosa, no es necesario que se niegue espec√≠ficamente.  Pero trate de prescindir de √©l cuando sea posible. <br><br>  <b>Mitos:</b> <br><br><ul><li>  Desreferencia - punteros de desreferenciaci√≥n - gratis. </li><li>  Las funciones an√≥nimas son gratuitas. </li><li>  Las interfaces son gratis. </li><li>  Conversi√≥n de interfaz de tiempo de ejecuci√≥n: NO GRATUITA. </li></ul><br><h3>  Cambiar, mapear y cortar </h3><br>  Cada reci√©n llegado a Go pregunta qu√© sucede si reemplaza el interruptor con el mapa.  ¬øSer√° m√°s r√°pido? <br><br>  El interruptor viene en diferentes tama√±os.  Prob√© en tres tama√±os: peque√±o para 10 casos, mediano para 100 y grande para 1000 casos.  El interruptor para 1000 casos se encuentra en el c√≥digo de producci√≥n real.  Por supuesto, nadie los escribe con sus manos.  Este es un c√≥digo generado autom√°ticamente, generalmente un interruptor de tipo.  Probado en dos tipos: int y string.  Parec√≠a que resultar√≠a m√°s claro. <br><br>  <strong>Peque√±o interruptor.</strong>  La opci√≥n m√°s r√°pida es el cambio real.  A continuaci√≥n, se corta inmediatamente, donde el √≠ndice entero correspondiente contiene una referencia a la funci√≥n.  Map no es un l√≠der en int o string. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3.26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100,000,000 </td><td>  11.70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3.85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100,000,000 </td><td>  12.70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100,000,000 </td><td>  15.60 ns / op </td></tr></tbody></table></div><br>  El encendido de cadenas es significativamente m√°s lento que en int.  Si puede hacer un cambio no a una cadena, sino a int, entonces h√°galo. <br><br>  <strong>Interruptor central</strong>  Switch en s√≠ mismo todav√≠a gobierna int, pero slice lo ha superado un poco.  El mapa sigue siendo malo.  Pero en una clave de cadena, el mapa es m√°s r√°pido que el cambio, como se esperaba. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4.55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100,000,000 </td><td>  17.10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3.76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50,000,000 </td><td>  28.50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100,000,000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Gran cambio</strong>  Mil casos muestran la victoria incondicional del mapa en la nominaci√≥n "cambiar por cadena".  Te√≥ricamente, rebanada gan√≥, pero en la pr√°ctica le aconsejo que use el mismo interruptor aqu√≠.  El mapa sigue siendo lento, incluso teniendo en cuenta que el mapa tiene teclas enteras con una funci√≥n hash especial.  En general, esta funci√≥n no hace nada.  El int en s√≠ tiene un hash para int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100,000,000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50,000,000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100,000,000 </td><td>  12.8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20,000,000 </td><td>  100.0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37.4 ns / op </td></tr></tbody></table></div><br>  <strong>Conclusiones</strong>  El mapa solo es mejor en grandes cantidades y no en una condici√≥n de entero.  Estoy seguro de que en cualquiera de las condiciones, excepto int, se comportar√° igual que en la cadena.  Slice siempre se dirige cuando las condiciones son enteras.  √öselo si desea "acelerar" su programa en 2 ns. <br><br><h2>  Interacci√≥n entre rutinas </h2><br>  El tema es complejo, he realizado muchas pruebas y presentar√© las m√°s reveladoras.  Conocemos los siguientes <strong>medios de interacci√≥n entre agencias</strong> . <br><br><ul><li>  At√≥mico  Estos son medios de aplicabilidad limitada: puede reemplazar el puntero o usar int. </li><li>  Mutex se ha utilizado ampliamente desde Java. </li><li>  El canal es exclusivo de GO. </li><li>  Canal con b√∫fer: canales con b√∫fer. </li></ul><br>  Por supuesto, prob√© en un n√∫mero significativamente mayor de gorutinas que compiten por un recurso.  Pero eligi√≥ tres para s√≠ mismo como indicativo: un poco - 100, un medio - 1000 y mucho - 10000. <br><br>  <strong>El perfil de carga es diferente</strong> .  A veces, todas las gorutinas quieren escribir en una variable, pero esto es raro.  Por lo general, despu√©s de todo, algunos escriben, otros leen.  De la mayor√≠a de los lectores, el 90% lee, de los que escriben, el 90% escribe. <br><br>  Este es el c√≥digo que se usa para que la rutina que sirve al canal pueda proporcionar tanto lectura como escritura a una variable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Si nos llega un mensaje a trav√©s del canal a trav√©s del cual escribimos, lo ejecutamos.  Si el canal est√° cerrado, terminamos goroutin.  En cualquier momento, estamos listos para escribir en el canal que utilizan otras gorutinas para leer. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100,000,000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6.72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5,000,000 </td><td>  239.00 ns / op </td></tr></tbody></table></div><br>  Estos son datos para una gorutina.  La prueba del canal se realiza en dos goroutines: uno procesa el canal, el otro escribe en este canal.  Y estas opciones han sido probadas en una. <br><br><ul><li>  Escrituras directas a una variable. </li><li>  Mutex toma un registro, escribe en una variable y libera un registro. </li><li>  Atomic escribe en una variable a trav√©s de Atomic.  No es gratis, pero sigue siendo significativamente m√°s barato que Mutex en una garutina. </li></ul><br>  Con una peque√±a cantidad de gorutina, el Atomic es una forma efectiva y r√°pida de sincronizar, lo cual no es sorprendente.  Direct no est√° aqu√≠, porque necesitamos sincronizaci√≥n, que no proporciona.  Pero Atomic tiene fallas, por supuesto. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100,000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1,000,000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449,666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442,708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100,000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449,556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  El siguiente es Mutex.  Esperaba que Channel fuera tan r√°pido como Mutex, pero no. <br><br><blockquote>  Channel es un orden de magnitud m√°s caro que Mutex. </blockquote><br>  Adem√°s, el canal y el canal protegido tienen un precio similar.  Y hay Channel, en el que el b√∫fer nunca se desborda.  Es un orden de magnitud m√°s barato que aquel cuyo b√∫fer se desborda.  Solo si el b√∫fer en Channel no est√° lleno, entonces cuesta aproximadamente lo mismo en orden de magnitud que Mutex.  Esto es lo que esperaba de la prueba. <br><br>  Esta imagen con la distribuci√≥n de cu√°nto cuesta se repite en cualquier perfil de carga, tanto en MostRead como en EverythingWrite.  Adem√°s, el canal completo mayor√≠a de lectura cuesta lo mismo que el incompleto.  Y el canal protegido en su mayor√≠a de WriteWrite, en el que el almacenamiento intermedio no est√° lleno, cuesta lo mismo que el resto.  No puedo decir por qu√© esto es as√≠: todav√≠a no he estudiado este problema. <br><br><h2>  Pasando par√°metros </h2><br>  <strong>¬øC√≥mo pasar par√°metros m√°s r√°pido, por referencia o por valor?</strong>  Vamos a verlo <br><br>  Verifiqu√© lo siguiente: hice tipos anidados del 1 al 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  El d√©cimo tipo anidado tendr√° 10 campos int64, y los tipos anidados de la anidaci√≥n anterior tambi√©n ser√°n 10. <br><br>  Luego escribi√≥ funciones que crean un tipo de anidamiento. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Para las pruebas, utilic√© tres opciones del tipo: peque√±o con anidaci√≥n 2, mediano con anidaci√≥n 3, grande con anidaci√≥n 5. Tuve que hacer una prueba muy grande con anidaci√≥n 10 por la noche, pero all√≠ la imagen es exactamente la misma que para 5. <br><br>  <b>En las funciones, pasar por valor es al menos dos veces m√°s r√°pido que pasar por referencia</b> .  Esto se debe al hecho de que pasar por valor no carga el an√°lisis de escape.  En consecuencia, las variables que asignamos est√°n en la pila.  Es sustancialmente m√°s barato para el tiempo de ejecuci√≥n, para el recolector de basura.  Aunque puede que no tenga tiempo para conectarse.  Estas pruebas continuaron durante unos segundos: el recolector de basura probablemente todav√≠a estaba dormido. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200,000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100,000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Magia negra </h2><br>  ¬øSabes qu√© generar√° este programa? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  El resultado del programa depende de la arquitectura en la que se ejecuta.  En little endian, por ejemplo, AMD64, el programa muestra <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9seIoMvLxPVEGYHWZ52oOr73o8A#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9seIoMvLxPVEGYHWZ52oOr73o8A#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhh9seIoMvLxPVEGYHWZ52oOr73o8A#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  En Big Endian, uno.  El resultado es diferente, porque en little endian esta unidad aparece en el medio del n√∫mero, y en big endian - al final. <br><br>  Todav√≠a hay procesadores en el mundo donde los conmutadores endian, por ejemplo, Power PC.  Ser√° necesario averiguar qu√© endian est√° configurado en su computadora al inicio, antes de hacer inferencias sobre lo que hacen los trucos inseguros de este tipo.  Por ejemplo, si escribe un c√≥digo Go que se ejecutar√° en alg√∫n servidor multiprocesador de IBM. <br><br>  Cit√© este c√≥digo para explicar por qu√© considero toda la magia negra insegura.  No necesitas usarlo.  Pero Cyril cree que es necesario.  Y aqu√≠ est√° el por qu√©. <br><br>  Hay una funci√≥n que hace lo mismo que GOB: Go Binary Marshaller.  Este es el codificador, pero no es seguro. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  De hecho, toma un pedazo de memoria y extrae una matriz de bytes. <br><br>  Esto ni siquiera es una orden, son dos √≥rdenes.  Por lo tanto, Cyril Danshin, cuando escribe un c√≥digo de alto rendimiento, no duda en entrar en las entra√±as de su programa y hacerlo inseguro. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Benchmark gob-4 </td><td>  200,000 </td><td>  8466 ns / op </td><td>  120,94 MB / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50,000,000 </td><td>  37 ns / op </td><td>  27691.06 MB / s </td></tr></tbody></table></div><blockquote>  Discutiremos caracter√≠sticas m√°s espec√≠ficas de Go el 7 de octubre en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GolangConf</a> , una conferencia para aquellos que usan Go en el desarrollo profesional y para aquellos que consideran este lenguaje como una alternativa.  Daniil Podolsky es solo un miembro del Comit√© del Programa, si desea discutir este art√≠culo o revelar problemas relacionados, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presente una solicitud</a> para un informe. <br><br>  Para todo lo dem√°s, con respecto al alto rendimiento, por supuesto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> .  Tambi√©n aceptamos solicitudes all√≠.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Suscr√≠base</a> al bolet√≠n y mant√©ngase actualizado con las noticias de todas nuestras conferencias para desarrolladores web. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461291/">https://habr.com/ru/post/461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461281/index.html">Tutorial para configurar un servidor DNS BIND en un entorno chroot para Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../461283/index.html">Arquitectura de software y dise√±o de sistemas: el panorama general y la gu√≠a de recursos</a></li>
<li><a href="../461285/index.html">5 algoritmos de muestreo principales</a></li>
<li><a href="../461287/index.html">Desarrollar una IA astuta en un juego t√°ctico basado en heur√≠stica y mutaciones.</a></li>
<li><a href="../461289/index.html">Lanzamiento de CLion 2019.2: soporte para desarrollo integrado, depurador para MSVC, b√∫squeda de archivos de encabezado no utilizados</a></li>
<li><a href="../461297/index.html">C√≥mo se ven los ataques dirigidos modernos</a></li>
<li><a href="../461299/index.html">C√≥mo la PC conquist√≥ la industria de los medios con un software exitoso: discutiendo Pro Tools y Media Composer</a></li>
<li><a href="../461303/index.html">Usar la tarjeta Troika como p√≥liza de seguro m√©dico obligatorio</a></li>
<li><a href="../461305/index.html">Red de la empresa y MitM. Parte 2</a></li>
<li><a href="../461307/index.html">Te invitamos a VK Hackathon 2019. El pozo de premios de este a√±o es de dos millones de rublos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>