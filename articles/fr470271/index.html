<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏼 👴🏾 👉🏽 F # 6: Tuples 🎞️ 🍢 🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Notre voyage vers F # continue donc. L'article suivant se concentrera sur les types F # qui peuvent ou non avoir des équivalents .NET standard. Ce mes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F # 6: Tuples</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470271/">  Notre voyage vers F # continue donc.  L'article suivant se concentrera sur les types F # qui peuvent ou non avoir des équivalents .NET standard.  Ce message concerne les tuples. <br><a name="habracut"></a><br><h4>  Que sont les tuples <br></h4><br>  Un tuple est un groupe de valeurs non nommées mais ordonnées, éventuellement de types différents. <br><br><h4>  Création de tuples <br></h4><br>  Les tuples sont très faciles à créer, nous faisons juste quelque chose comme celui ci-dessous.  Remarquez comment j'ai créé un package mixte de tuples, dont certains sont des nombres et d'autres des chaînes, et nous pouvons également mélanger et faire correspondre les deux types et le nombre de valeurs. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> a = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>, 'c')</code> </pre> <br><h4>  Tuples universels </h4><br>  Les fonctions qui acceptent les tuples peuvent également accepter sans problème des tuples universels.  Un système d'inférence tel que F # se fera un plaisir de gérer l'inférence des types corrects pour un tuple.  Voici un exemple. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> someFunction tup = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (x,y) = tup printfn <span class="hljs-string"><span class="hljs-string">"x is %A and y is %A"</span></span> xy <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-string"><span class="hljs-string">"cat"</span></span>,<span class="hljs-string"><span class="hljs-string">"dog"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre> <br>  Et voici les résultats de l'exécution ci-dessus, où vous pouvez voir que la fonction someFunction a accepté et a fonctionné sans problème avec divers tuples typés. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df0/3ed/aee/df03edaee1d6384983a224e440d2c0f8.png" alt="image"><br><br><h4>  Signatures de tuple <br></h4><br>  Jusqu'à présent, nous n'avons pas du tout abordé la compréhension des signatures F #, en fait, c'est un sujet auquel j'ai également décidé de consacrer un blog entier, car je pense que c'est assez compliqué.  Cependant, nous sommes situés là où nous sommes, c'est-à-dire ici et maintenant, et nous étudions les tuples, alors maintenant je voulais juste montrer à quoi ressemblerait la signature du tuple. <br><br>  Supposons que j'ai déclaré les tuples suivants dans la fenêtre FSI: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> a = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"codfather"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-number"><span class="hljs-number">12.5</span></span>)</code> </pre> <br>  Et puis je les ai examinés dans la fenêtre FSI;  nous verrons quelque chose comme ceci: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">val</span></span> a : int * int = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) val b : int * string = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"codfather"</span></span>) val c : int * string * float = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>, <span class="hljs-number"><span class="hljs-number">12.5</span></span>)</code> </pre> <br>  C'est intéressant, nous pouvons voir quelques choses ici, à savoir: <br><ul><li>  Les parenthèses ne font pas partie d'une signature de type </li><li>  Le système de type F # peut correctement déduire un type basé sur les valeurs contenues dans le tuple lui-même. </li><li>  La virgule est remplacée par "*" </li></ul><br>  Ainsi, le tuple cristallin ressemble à ceci: <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Aura la signature suivante: <br><pre> <code class="erlang hljs">int * int</code> </pre> <br><br><h4>  Répartition du tuple </h4><br>  Nous avons donc vu comment créer des tuples, mais qu'en est-il de les casser ou de les déconstruire en valeurs distinctes.  Est-ce possible?  Oui bien sûr.  Comme précédemment, commençons par quelques exemples: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (a,b) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"(a,b) = (1,2), so value of 'a' should be 1, and it is =%i,\r\n 'b' should be 2, and it is =%i"</span></span> ab //   ,  ,     ,   //     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (_,z) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"grabbing last value from (1,2) which is = %i"</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (a,b :string) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"grabbing (1,\"cat\") which has values = %i %s"</span></span> ab <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (a :int,b :string) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"grabbing (1,\"cat\") which has values = %i %s"</span></span> ab <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (a ,b, c) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>, 'c') printfn <span class="hljs-string"><span class="hljs-string">"grabbing (1,\"cat\",'c') which has values = %i %s %c"</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> first = fst (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"grabbing fst from (1,2) which has values = %i"</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> second = snd (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"grabbing 2nd from (1,2) which has values = %i"</span></span> second</code> </pre> <br>  Les résultats sont imprimés dans une fenêtre de console standard, comme suit: <br><img src="https://habrastorage.org/getpro/habr/post_images/697/b30/e19/697b30e19b05d005f67f6bb1ff0e068a.png" alt="image"><br><br><h4>  Utilisation de Let </h4><br>  Mais comment avons-nous obtenu les pièces individuelles?  Eh bien, tout ce dont vous avez besoin est le code ci-dessus, mais regardons un exemple.  Supposons que nous ayons un tuple comme celui-ci: <br><pre> <code class="haskell hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Et je voulais que les valeurs des deux "valeurs" du tuple soient liées à de nouvelles valeurs individuelles, nous pourrions simplement faire ceci: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (a,b) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Nous pouvons également sélectionner uniquement les valeurs dont nous avons vraiment besoin, ce qui se fait à l'aide d'un caractère générique pour les parties indésirables.  Ce qui garantit l'absence de reliure de valeur inutile.  Voici un exemple: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (_,z) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><br><h4>  Utilisation des fonctions de tuple intégrées </h4><br>  Il existe également une prise en charge intégrée pour obtenir les première et deuxième valeurs d'un tuple.  Que peut-on faire en utilisant les fonctions " <b>fst</b> " et " <b>snd</b> ".  Il n'y a pas de support pour autre chose que le 2ème élément (ce sont probablement les cas les plus courants).  « <b>Fst</b> » et « <b>snd</b> » peuvent être utilisés comme suit: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> first = fst (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> second = snd (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Maintenant, je veux attirer votre attention sur un cas particulier où nous pouvons avoir un décalage avec le nombre de valeurs que nous essayons d'exploser en valeurs individuelles.  Donc, ce sera quelque chose comme un exemple ici: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> (a ,b) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"cat"</span></span>, 'c')</code> </pre> <br>  Vous pouvez voir que le tuple lui-même contient en fait 3 valeurs, mais la liaison Let n'a que 2 valeurs, donc le compilateur nous en avertit, comme vous pouvez le voir dans la capture d'écran ci-dessous: <br><img src="https://habrastorage.org/getpro/habr/post_images/c44/7d6/7e7/c447d67e7a8e9e543aa71d6e039d1be9.png" alt="image"><br><h4>  Création de nouveaux tuples </h4><br>  Vous voudrez peut-être créer de nouveaux tuples à partir de tuples existants, c'est assez simple, voici un exemple: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> oldOne = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (x,y) = oldOne <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newOne = (x+<span class="hljs-number"><span class="hljs-number">1</span></span>,y+<span class="hljs-number"><span class="hljs-number">1</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"original = %A, and we did this (x+1,y+1)\r\n to obtain newOne = %A"</span></span> oldOne newOne</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/116/cf0/20a/116cf020a8c1a7e580e6aeab42b25800.png" alt="image"><br><br><h4>  Comparaison de tuples </h4><br>  <b>Les tuples ne sont considérés comme égaux que si</b> <b><br></b> <br><ul><li>  Ils ont le même nombre de valeurs. </li><li>  TOUTES les valeurs sont considérées comme égales (évidemment, il peut s'agir de méthodes Equals personnalisées ou d'implémentations IEquatable personnalisées, etc.) </li></ul><br>  Regardons un exemple simple. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">printfn</span></span> <span class="hljs-string"><span class="hljs-string">"(1,2) = (3,4) =% b"</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) = (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)) printfn <span class="hljs-string"><span class="hljs-string">"(1,2) = (1,2) =% b"</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) printfn <span class="hljs-string"><span class="hljs-string">"('a', 'b') = ('a', 'b') =% b"</span></span> (('a', 'b') = ('a', 'b')) printfn <span class="hljs-string"><span class="hljs-string">"('a', 'b') = ('a', 'c') =% b"</span></span> (('a', 'b') = ('a', 'c'))</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/25b/274/d3f/25b274d3f9c60f5cddc39eabe4052f33.png" alt="image"><br><br>  En fait, si vos tuples ont des longueurs différentes (le nombre d'éléments) et que vous essayez de les comparer en utilisant l'opérateur d'égalité "=", vous obtiendrez un avertissement: <br><img src="https://habrastorage.org/getpro/habr/post_images/156/843/fcb/156843fcb2366f49661d18a6036a84e9.png" alt="image"><br><br><h4>  Tuple matching patterns </h4><br>  Nous n'avons pas encore traité de modèles de correspondance, mais plus tard, nous verrons un article entier sur ce sujet.  En attendant, sachez simplement que c'est une façon de faire correspondre à nouveau les paramètres d'entrée.  Vous pouvez le faire pour les tuples, ce qui se fait comme suit: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> someFunction tup = match tup with | <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"you passed (1,2)"</span></span> | _,_ -&gt; printfn <span class="hljs-string"><span class="hljs-string">"you passed some other tuple"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> someFunction (<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/674/96c/e1b/67496ce1b37b2fc6a4ba2a4ddda7067d.png" alt="image"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470271/">https://habr.com/ru/post/fr470271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470255/index.html">Optimisation du portefeuille obligataire avec ALGLIB</a></li>
<li><a href="../fr470259/index.html">Aimybox dans la recherche: le cadre pour créer des assistants vocaux a besoin d'un assistant iOS</a></li>
<li><a href="../fr470265/index.html">Aide-mémoire de l'abréviation C ++ et plus encore. Partie 1: C ++</a></li>
<li><a href="../fr470267/index.html">Surveillance de température certifiée</a></li>
<li><a href="../fr470269/index.html">ReactOS 0.4.12: 华为 ， 你 认为 这个 怎么 样？</a></li>
<li><a href="../fr470273/index.html">F # 7: Records</a></li>
<li><a href="../fr470275/index.html">F # 8: Syndicats discriminés</a></li>
<li><a href="../fr470277/index.html">Comment le réseau mondial de la Fédération de Russie est-il organisé et organisé?</a></li>
<li><a href="../fr470279/index.html">AI, apprentissage automatique, Big Data, reconnaissance vocale et autres mots qui ne vous aideront PAS à apprendre l'anglais</a></li>
<li><a href="../fr470281/index.html">Le visage du logiciel russe. Ou quelques statistiques du registre unifié des programmes informatiques et des bases de données russes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>