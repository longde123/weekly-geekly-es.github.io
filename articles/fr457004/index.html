<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏻 🧑🏿‍🤝‍🧑🏿 ⏯️ Méthodes simples pour optimiser les programmes Go 👈 👩🏾‍🎨 👋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je me soucie toujours de la performance. Je ne sais pas exactement pourquoi. Mais je suis simplement énervé par la lenteur des services et des program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Méthodes simples pour optimiser les programmes Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457004/">  Je me soucie toujours de la performance.  Je ne sais pas exactement pourquoi.  Mais je suis simplement énervé par la lenteur des services et des programmes.  On dirait que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">je ne suis pas seul</a> . <br><br><blockquote>  <i>Dans les tests A / B, nous avons essayé de ralentir la sortie des pages par incréments de 100 millisecondes et avons constaté que même de très petits retards entraînaient une baisse significative des revenus.</i>  - Greg Linden, Amazon.com </blockquote><br>  Par expérience, une faible productivité se manifeste de deux manières: <br><br><ul><li>  Les opérations qui fonctionnent bien à petite échelle deviennent non viables avec un nombre croissant d'utilisateurs.  Il s'agit généralement d'opérations O (N) ou O (N²).  Lorsque la base d'utilisateurs est petite, tout fonctionne bien.  Le produit est pressé de mettre sur le marché.  À mesure que la base grandit, des situations pathologiques de plus en plus inattendues se produisent - et le service s'arrête. <br></li><li> De nombreuses sources individuelles de travail sous-optimal, «la mort de mille coupures». </li></ul><a name="habracut"></a><br>  Pendant la majeure partie de ma carrière, j'ai étudié la science des données avec Python ou créé des services sur Go.  Dans le second cas, j'ai beaucoup plus d'expérience en optimisation.  Go n'est généralement pas un goulot d'étranglement dans les services que j'écris - les programmes de base de données sont souvent limités par les E / S.  Cependant, dans les pipelines de batch d'apprentissage automatique que j'ai développés, le programme est souvent limité par le CPU.  Si Go utilise trop le processeur, il existe différentes stratégies. <br><br>  Cet article explique certaines méthodes qui peuvent être utilisées pour augmenter considérablement la productivité sans trop d'effort.  J'ignore délibérément les méthodes qui nécessitent des efforts importants ou des changements importants dans la structure du programme. <br><br><h1>  Avant de commencer </h1><br>  Avant d'apporter des modifications au programme, prenez le temps de créer une base de référence appropriée pour la comparaison.  Si vous ne le faites pas, vous vous promènerez dans le noir, en vous demandant s'il y a un quelconque avantage à apporter les modifications apportées.  Tout d'abord, écrivez des repères et prenez des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">profils</a> à utiliser dans pprof.  Il est préférable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d’écrire la référence également sur Go</a> : cela facilite l’utilisation de pprof et du profilage de la mémoire.  Utilisez également benchcmp: un outil utile pour comparer les différences de performances entre les tests. <br><br>  Si le code n'est pas très compatible avec les benchmarks, commencez simplement par quelque chose qui peut être mesuré.  Vous pouvez profiler le code manuellement avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">runtime / pprof</a> . <br><br>  Commençons donc! <br><br><h3>  Utilisez sync.Pool pour réutiliser les objets précédemment sélectionnés </h3><br>  sync.Pool implémente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une liste de versions</a> .  Cela vous permet de réutiliser les structures précédemment allouées et amortit la distribution de l'objet sur de nombreuses utilisations, réduisant le travail du garbage collector.  L'API est très simple.  Implémentez une fonction qui alloue une nouvelle instance d'un objet.  L'API renvoie le type de pointeur. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  Après cela, vous pouvez faire des objets <code>Get()</code> partir du pool et les remettre <code>Put()</code> lorsque vous avez terminé. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  Il y a des nuances.  Avant Go 1.13, le pool était effacé à chaque récupération de place.  Cela peut nuire aux performances des programmes qui allouent beaucoup de mémoire.  Au 1.13, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il semble que plus d'objets survivent après le GC</a> . <br><br>  <b>!!!</b>  <b>Avant de renvoyer un objet dans le pool, assurez-vous de réinitialiser les champs de structure.</b> <br><br>  Si vous ne le faites pas, vous pouvez obtenir un objet sale du pool qui contient des données d'une utilisation précédente.  Il s'agit d'un grave risque pour la sécurité! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret" } return rsp</span></span></code> </pre> <br>  Un moyen sûr de toujours garantir zéro mémoire est de le faire explicitement: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  Le seul cas où ce n'est pas un problème est lorsque vous utilisez la mémoire exacte à laquelle vous avez écrit.  Par exemple: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Évitez d'utiliser des structures contenant des pointeurs comme clés pour une grande carte </h3><br>  Fuh, j'étais trop bavard.  Je suis désolé.  Ils parlaient souvent (y compris mon ancien collègue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phil Pearl</a> ) des performances de Go avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grande taille de tas</a> .  Pendant le garbage collection, le runtime analyse les objets avec des pointeurs et les suit.  Si vous avez une très grande carte <code>map[string]int</code> , GC doit vérifier chaque ligne.  Cela se produit avec chaque garbage collection, car les lignes contiennent des pointeurs. <br><br>  Dans cet exemple, nous écrivons 10 millions d'éléments pour <code>map[string]int</code> et mesurer la durée de la récupération de place.  Nous allouons notre carte dans la zone du package pour garantir l'allocation de mémoire à partir du tas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  En exécutant le programme, nous verrons ce qui suit: <br><br><pre>  inthash → aller installer &amp;&amp; inthash
 gc a pris: 98.726321ms
 gc a pris: 105.524633ms
 gc a pris: 102.829451ms
 gc a pris: 102.71908ms
 gc a pris: 103.084104ms
 gc a pris: 104.821989ms </pre><br>  C'est assez long dans un pays informatique! <br><br>  Que peut-on faire pour optimiser?  Supprimer des pointeurs partout est une bonne idée, afin de ne pas charger le ramasse-miettes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il y a des pointeurs dans les lignes</a> ;  implémentons donc ceci comme <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  En exécutant à nouveau le programme, nous voyons: <br><br><pre>  inthash → aller installer &amp;&amp; inthash
 gc a pris: 3.608993ms
 gc a pris: 3.926913ms
 gc a pris: 3.955706ms
 gc a pris: 4.063795ms
 gc a pris: 3.91519ms
 gc a pris: 3.75226ms </pre><br>  Bien mieux.  Nous avons accéléré la collecte des ordures de 35 fois.  Lorsqu'il est utilisé en production, il sera nécessaire de hacher les chaînes en nombres entiers avant de les insérer dans la carte. <br><br>  Soit dit en passant, il existe de nombreuses autres façons d'éviter le GC.  Si vous allouez des tableaux gigantesques de structures sans signification, en octets ou en octets, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GC ne le scannera pas</a> : c'est-à-dire que vous économisez du temps GC.  De telles méthodes nécessitent généralement une révision substantielle du programme, donc aujourd'hui nous ne nous pencherons pas sur ce sujet. <br><br>  Comme pour toute optimisation, l'effet peut varier.  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fil des tweets de Damian Gryski</a> pour un exemple intéressant de la façon dont la suppression de lignes d'une grande carte au profit d'une structure de données plus intelligente a effectivement <i>augmenté</i> la consommation de mémoire.  En général, lisez tout ce qu'il publie. <br><br><h3>  Marshaling de génération de code pour éviter la réflexion d'exécution </h3><br>  Le marshaling et le démarshaling de votre structure dans différents formats de sérialisation, tels que JSON, est une opération typique, en particulier lors de la création de microservices.  Pour de nombreux microservices, c'est généralement le seul travail.  Des fonctions comme <code>json.Marshal</code> et <code>json.Unmarshal</code> s'appuient sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réflexion lors de l'exécution</a> pour sérialiser les champs de structure en octets et vice versa.  Cela peut fonctionner lentement: la réflexion n'est pas aussi efficace que le code explicite. <br><br>  Cependant, il existe des options d'optimisation.  La mécanique de marshaling JSON ressemble à ceci: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  Si nous connaissons le processus de marshalisation en JSON, nous avons un indice pour éviter la réflexion lors de l'exécution.  Mais nous ne voulons pas écrire manuellement tout le code de marshalisation, alors que devons-nous faire?  Laissez l'ordinateur générer ce code!  Les générateurs de code comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">easyjson</a> examinent la structure et génèrent du code hautement optimisé qui est entièrement compatible avec les interfaces de marshaling existantes comme <code>json.Marshaller</code> . <br><br>  Téléchargez le package et écrivez la commande suivante dans <code>$file.go</code> , qui contient les structures pour lesquelles vous souhaitez générer du code. <br><br><pre>  easyjson -all $ file.go </pre><br>  Le fichier <code>$file_easyjson.go</code> doit être généré.  Puisque <code>easyjson</code> implémenté pour vous l'interface <code>json.Marshaller</code> , ces fonctions seront appelées par défaut au lieu de réflexion.  Félicitations: vous venez d'accélérer votre code JSON trois fois.  Il existe de nombreuses astuces pour augmenter encore la productivité. <br><br>  Je recommande ce package car je l'ai déjà utilisé et avec succès.  Mais attention.  Veuillez ne pas prendre cela comme une invitation à entamer avec moi des débats agressifs sur les packages JSON les plus rapides. <br><br>  Assurez-vous de recréer le code de marshaling lorsque la structure change.  Si vous oubliez de le faire, les nouveaux champs ajoutés ne seront pas sérialisés, ce qui créera de la confusion!  Vous pouvez utiliser <code>go generate</code> pour ces tâches.  Pour maintenir la synchronisation avec les structures, je préfère placer <code>generate.go</code> à la racine du package, ce qui provoque la <code>go generate</code> pour tous les fichiers du package: cela peut aider lorsque vous avez de nombreux fichiers qui doivent générer un tel code.  L'astuce principale: pour vous assurer que les structures sont mises à jour, appelez <code>go generate</code> dans le CI et vérifiez qu'il n'y a pas de différence avec le code enregistré. <br><br><h3>  Utilisez strings.Builder pour créer des chaînes </h3><br>  Dans Go, les chaînes sont immuables: considérez-les comme des octets en lecture seule.  Cela signifie que chaque fois que vous créez une chaîne, vous allouez de la mémoire et créez potentiellement plus de travail pour le garbage collector. <br><br>  Go 1.10 a implémenté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strings.Builder</a> comme un moyen efficace de créer des chaînes.  En interne, il écrit dans un tampon d'octets.  Ce n'est que lorsque vous appelez <code>String()</code> dans le générateur crée réellement une chaîne.  Il s'appuie sur quelques astuces non sécurisées pour renvoyer les octets sous-jacents sous forme de chaîne avec une allocation nulle: consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce blog</a> pour une étude plus approfondie sur la façon dont cela fonctionne. <br><br>  Comparez les performances des deux approches: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Voici les résultats sur mon Macbook Pro: <br><br><pre>  strbuild -&gt; allez tester -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5,000,000 255 ns / op 216 B / op 8 allocs / op
 BenchmarkStringBuildBuilder-8 20 000 000 54,9 ns / op 64 B / op 1 allocs / op </pre><br>  Comme vous pouvez le voir, <code>strings.Builder</code> est 4,7 fois plus rapide, provoque huit fois moins d'allocations et occupe quatre fois moins de mémoire. <br><br>  Lorsque les performances sont importantes, utilisez <code>strings.Builder</code> .  En général, je recommande de l'utiliser partout, sauf dans les cas les plus triviaux de construction de chaînes. <br><br><h3>  Utilisez strconv au lieu de fmt </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fmt</a> est l'un des packages les plus connus de Go.  Vous l'avez probablement utilisé dans votre premier programme pour afficher «bonjour, monde».  Mais quand il s'agit de convertir des entiers et des flottants en chaînes, ce n'est pas aussi efficace que son frère cadet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strconv</a> .  Ce package affiche des performances décentes avec très peu de modifications de l'API. <br><br>  <code>fmt</code> prend fondamentalement l' <code>interface{}</code> comme arguments de fonction.  Il y a deux inconvénients: <br><br><ul><li>  Vous perdez la sécurité du type.  Pour moi, c'est très important. <br></li><li>  Cela peut augmenter la quantité de sécrétions nécessaires.  Passer un type sans pointeur comme <code>interface{}</code> entraîne généralement une allocation de segment de mémoire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ce billet de blog</a> explique pourquoi il en est ainsi. </li><li>  Le programme suivant montre la différence de performances: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Benchmarks sur Macbook Pro: <br><br><pre>  strfmt → go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30 000 000 39,5 ns / op 32 B / op 1 allocs / op
 Indice de référence Fmt-8 10000000143 ns / op 72 B / op 3 allocs / op </pre><br>  Comme vous pouvez le voir, l'option strconv est 3,5 fois plus rapide, provoque trois fois moins d'allocations et occupe deux fois moins de mémoire. <br><br><h3>  Allouer le réservoir de tranches avec make pour éviter la redistribution </h3><br>  Avant de passer à l'amélioration des performances, mettons à jour rapidement les informations découpées en mémoire.  Une tranche est une construction très utile dans Go.  Il fournit un tableau évolutif avec la possibilité d'accepter différentes vues dans la même mémoire de base sans réallocation.  Si vous regardez sous le capot, la tranche se compose de trois éléments: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  Quels sont ces domaines? <br><br><ul><li>  <code>data</code> : pointeur vers les données sous-jacentes dans la tranche <br></li><li>  <code>len</code> : nombre actuel d'éléments dans la tranche <br></li><li>  <code>cap</code> : nombre d'éléments qu'une tranche peut atteindre avant de redistribuer </li></ul><br>  Les sections sous le capot sont des réseaux de longueur fixe.  Lorsque la valeur maximale ( <code>cap</code> ) est atteinte, un nouveau tableau avec une valeur double est alloué, la mémoire est copiée de l'ancienne tranche vers la nouvelle et l'ancien tableau est supprimé. <br><br>  Je vois souvent quelque chose comme ce code où une tranche avec une capacité limite zéro est allouée si la capacité de la tranche est connue à l'avance: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Dans ce cas, la tranche commence par la taille zéro <code>len</code> et le <code>cap</code> capacité limite zéro.  Après avoir reçu la réponse, nous ajoutons des éléments à la tranche, en même temps que nous atteignons la capacité limite: un nouveau tableau de base est sélectionné, où le <code>cap</code> doublé et les données y sont copiées.  Si nous obtenons 8 éléments dans la réponse, cela conduit à 5 redistributions. <br><br>  La méthode suivante est beaucoup plus efficace: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Ici, nous avons explicitement alloué la capacité de la tranche à l'aide de make.  Nous pouvons désormais y ajouter des données en toute sécurité, sans redistribution ni copie supplémentaires. <br><br>  Si vous ne savez pas combien de mémoire allouer, car la capacité est dynamique ou calculée ultérieurement dans le programme, mesurez la distribution finale de la taille de tranche après l'exécution du programme.  Je prends habituellement le 90e ou 99e centile et je code dur la valeur dans le programme.  Dans les cas où le CPU est plus cher que la RAM pour vous, définissez cette valeur plus haut que vous pensez nécessaire. <br><br>  L'astuce s'applique également aux cartes: <code>make(map[string]string, len(foo))</code> allouera suffisamment de mémoire pour éviter la redistribution. <br><br>  Consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> sur le fonctionnement réel des tranches. <br><br><h3>  Utiliser des méthodes pour transférer des tranches d'octets </h3><br>  Lorsque vous utilisez des paquets, utilisez des méthodes qui permettent la transmission d'une tranche d'octets: ces méthodes donnent généralement plus de contrôle sur la distribution. <br><br>  Un bon exemple consiste à comparer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">time.Format</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">time.AppendFormat</a> .  Le premier renvoie une chaîne.  Sous le capot, cela sélectionne une nouvelle tranche d'octets et appelle <code>time.AppendFormat</code> dessus.  Le second prend un tampon d'octets, écrit une représentation temporelle formatée et retourne une tranche d'octets étendue.  Cela se trouve souvent dans d'autres packages de la bibliothèque standard: voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strconv.AppendFloat</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bytes.NewBuffer</a> . <br><br>  Pourquoi cela augmente-t-il la productivité?  Eh bien, maintenant vous pouvez passer les tranches d'octets que vous avez reçues de <code>sync.Pool</code> , au lieu d'allouer un nouveau tampon à chaque fois.  Ou vous pouvez augmenter la taille de tampon initiale à une valeur qui convient mieux à votre programme afin de réduire le nombre de copies répétées de la tranche. <br><br><h1>  Résumé </h1><br>  Vous pouvez appliquer toutes ces méthodes à votre base de code.  Au fil du temps, vous construirez un modèle mental pour raisonner sur les performances des programmes Go.  Cela aidera grandement dans leur conception. <br><br>  Mais utilisez-les en fonction de la situation.  Ce sont des conseils, pas l'évangile.  Mesurez et vérifiez tout avec des repères. <br><br>  Et sachez quand vous arrêter.  Augmenter la productivité est un bon exercice: la tâche est intéressante et les résultats sont immédiatement visibles.  Cependant, l'utilité d'augmenter la productivité dépend fortement de la situation.  Si votre service donne une réponse en 10 ms et que le retard du réseau est de 90 ms, vous ne devriez probablement pas essayer de réduire ces 10 ms à 5 ms: vous avez encore 95 ms.  Même si vous optimisez le service au maximum jusqu'à 1 ms, le retard total sera toujours de 91 ms.  Mangez probablement de plus gros poissons. <br><br>  Optimisez judicieusement! <br><br><h3>  Les références </h3><br>  Si vous souhaitez plus d'informations, voici de grandes sources d'inspiration: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D'autres dangers des gros tas en jeu</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Efficacité de la distribution dans les services Go haute performance</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment j'ai cessé de m'inquiéter et suis tombé amoureux d'un groupe</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octets Buffer, je pensais que tu étais mon ami</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gc est mauvais mais vous ne devriez pas vous sentir mal</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Profilage et optimisation dans Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de la mémoire dans CockroachDB</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Élimination des retards GC dans les grands tas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sept étapes pour accélérer au centuple</a> </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457004/">https://habr.com/ru/post/fr457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456986/index.html">Durov n'a rien à voir avec TON</a></li>
<li><a href="../fr456988/index.html">Histoires d'un avocat en informatique. Entreprise d'externalisation de la vie. 3e partie</a></li>
<li><a href="../fr456992/index.html">Quelques conseils utiles pour ceux qui décident d'apprendre l'anglais par eux-mêmes</a></li>
<li><a href="../fr456996/index.html">Trois chevaux blancs</a></li>
<li><a href="../fr456998/index.html">L'histoire complète d'Harold et de l'arbre de Bob Herbert dans Fallout</a></li>
<li><a href="../fr457008/index.html">Antiquités: trois histoires de palmiers</a></li>
<li><a href="../fr457010/index.html">Pourquoi je n'utilise pas de composants Web</a></li>
<li><a href="../fr457016/index.html">La méthodologie BEM comme exemple d'autocollants dans l'opencart</a></li>
<li><a href="../fr457018/index.html">Plus de complexité</a></li>
<li><a href="../fr457020/index.html">Une sélection de sources académiques et scientifiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>