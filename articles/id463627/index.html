<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▶️ 🏇 ⚾️ Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 4 🚔 🤳 👎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="← Bagian 3. Pengalamatan tidak langsung dan kontrol aliran 
 Bagian 5. Merancang aplikasi multi-utas. → 
 Perpustakaan Generator Kode Assembler untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463627/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">← Bagian 3. Pengalamatan tidak langsung dan kontrol aliran</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5. Merancang aplikasi multi-utas.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">→</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Perpustakaan Generator Kode Assembler untuk Mikrokontroler AVR </h2><br><h3 id="chast-4-programmirovanie-periferiynyh-ustroystv-i-obrabotka-preryvaniy">  Bagian 4. Memprogram perangkat dan menangani gangguan </h3><br><p>  Di bagian posting ini, kami, seperti yang dijanjikan, akan menangani salah satu aspek paling populer dari pemrograman mikrokontroler - yaitu, bekerja dengan perangkat periferal.  Ada dua pendekatan yang paling umum untuk pemrograman periferal.  Pertama, sistem pemrograman tidak tahu apa-apa tentang perangkat periferal dan hanya menyediakan sarana akses ke port kontrol perangkat.  Pendekatan ini praktis tidak berbeda dengan bekerja dengan perangkat pada tingkat assembler dan memerlukan studi menyeluruh tentang tujuan semua port yang terkait dengan pengoperasian perangkat periferal tertentu.  Untuk memudahkan pekerjaan pemrogram, ada program khusus, tetapi bantuan mereka, sebagai suatu peraturan, berakhir dengan pembuatan urutan inisialisasi perangkat awal.  Keuntungan dari pendekatan ini adalah akses penuh ke semua kemampuan periferal, dan kerugiannya adalah kompleksitas pemrograman dan banyaknya kode program. </p><br><p>  Pekerjaan kedua dengan perangkat periferal dilakukan pada tingkat perangkat virtual.  Keuntungan utama dari pendekatan ini adalah kesederhanaan manajemen perangkat dan kemampuan untuk bekerja dengan mereka tanpa mempelajari implementasi perangkat keras tertentu.  Kelemahan dari pendekatan ini adalah keterbatasan kemampuan perangkat periferal dengan tujuan dan fungsi dari perangkat virtual yang ditiru. </p><br><p>  Perpustakaan NanoRTOS mengimplementasikan pendekatan ketiga.  Setiap perangkat periferal dijelaskan oleh kelas khusus, yang tujuannya adalah untuk menyederhanakan pengaturan dan pengoperasian perangkat sambil mempertahankan fungsionalitas penuhnya.  Lebih baik menunjukkan fitur pendekatan ini menggunakan contoh, jadi mari kita mulai. </p><a name="habracut"></a><br><p>  Mari kita mulai dengan perangkat periferal paling sederhana dan paling umum - port input / output digital.  Port ini menggabungkan hingga 8 saluran, yang masing-masing dapat dikonfigurasi secara independen untuk input atau output.  Klarifikasi ke 8 berarti bahwa arsitektur pengontrol menyiratkan kemungkinan menetapkan fungsi alternatif untuk bit port individual, yang mengecualikan penggunaannya sebagai port air / output, sehingga mengurangi jumlah bit yang tersedia.  Pengaturan dan pekerjaan lebih lanjut dapat dilakukan pada level bit yang terpisah, dan pada level port secara keseluruhan (menulis dan membaca semua 8 bit dengan satu perintah).  Pengontrol Mega328 yang digunakan dalam contoh memiliki 3 port: B, C, dan D. Pada kondisi awal, dari sudut pandang perpustakaan, debit semua port netral.  Ini berarti bahwa untuk aktivasi mereka perlu menunjukkan mode penggunaannya.  Jika ada upaya untuk mengakses port yang tidak diaktifkan, program akan menghasilkan kesalahan kompilasi.  Ini dilakukan untuk menghilangkan kemungkinan konflik saat menetapkan fungsi alternatif.  Untuk mengalihkan port ke mode input / output, gunakan perintah <em>Mode</em> untuk mengatur mode single-bit, dan <em>Direction</em> untuk mengatur mode semua bit port dengan satu perintah.  Dari sudut pandang pemrograman, semua port adalah sama dan perilakunya dijelaskan oleh satu kelas. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT;<span class="hljs-comment"><span class="hljs-comment">// 0   B    m.PortC.Direction(0xFF);//       m.PortB.Activate(); //   m.PortC.Activate(); //  C //   m.PortB[0].Set(); //  0   B  1 m.PortB[0].Clear();//  0   B  0 m.PortB[0].Toggle();//  0   B   m.PortC.Write(0b11000000);// 6  7        var rr = m.REG(); //     rr.Load(0xC0); m.PortC.Write(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Contoh di atas menunjukkan bagaimana output data melalui port dapat diatur.  Bekerja dengan port B di sini dilakukan pada level satu kategori, dan dengan port C di level port, secara keseluruhan.  Perhatikan perintah <em>Aktivasi ()</em> .  Tujuannya adalah untuk menghasilkan dalam kode output urutan perintah inisialisasi perangkat sesuai dengan properti yang ditetapkan sebelumnya.  Dengan demikian, perintah <em>Activate ()</em> selalu menggunakan set parameter yang ditetapkan saat ini pada saat eksekusi.  Pertimbangkan contoh membaca data dari port. </p><br><pre> <code class="cs hljs"> m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  B m.PortC.Activate(); //  C Bit dd = m.BIT(); //     Register rr = m.REG(); //     m.PortB[0].Read(dd); //  0   B m.PortC.Read(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Dalam contoh ini, tipe data <em>Bit</em> baru telah muncul.  Analog terdekat dari tipe ini dalam bahasa tingkat tinggi adalah tipe <em>bool</em> .  Tipe data <em>Bit</em> digunakan untuk menyimpan hanya satu bit informasi dan memungkinkan nilainya untuk digunakan sebagai kondisi dalam operasi percabangan.  Untuk menghemat memori, variabel bit selama penyimpanan digabungkan ke dalam blok sedemikian rupa sehingga satu register RON digunakan untuk menyimpan 8 variabel tipe <em>Bit</em> .  Selain tipe yang dijelaskan, pustaka berisi dua tipe data bit: <em>Pin</em> , yang memiliki fungsi yang sama dengan Bit, tetapi menggunakan register IO dan <em>Mbit</em> untuk menyimpan variabel bit dalam memori RAM.  Mari kita lihat bagaimana Anda bisa menggunakan variabel bit untuk mengatur cabang </p><br><pre> <code class="cs hljs">m.IF(m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>], () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   = 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = m.BIT(); b.Set(); m.IF(b, () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   b "</span></span>));</code> </pre> <br><p>  Baris pertama memeriksa status port input, dan jika pada input 1, kode blok bersyarat dijalankan.  Baris terakhir berisi contoh di mana variabel tipe <em>Bit</em> digunakan sebagai kondisi percabangan. </p><br><p>  Perangkat periferal umum dan yang sering digunakan berikutnya dapat dianggap sebagai penghitung / penghitung perangkat keras.  Dalam mikrokontroler AVR, perangkat ini memiliki serangkaian fungsi besar dan, tergantung pada pengaturannya, dapat digunakan untuk menghasilkan penundaan, menghasilkan berliku-liku dengan frekuensi yang dapat diprogram, mengukur frekuensi sinyal eksternal, dan juga sebagai modulator PWM multimode.  Tidak seperti port I / O, masing-masing timer Mega328 memiliki serangkaian fitur unik.  Oleh karena itu, setiap timer dijelaskan oleh kelas yang terpisah. </p><br><p>  Mari kita pertimbangkan secara lebih detail.  Sebagai sumber sinyal setiap timer, sinyal eksternal dan jam internal prosesor dapat digunakan.  Pengaturan perangkat keras mikrokontroler memungkinkan Anda untuk mengonfigurasikan penggunaan frekuensi penuh untuk perangkat periferal, atau mengaktifkan splitter tunggal untuk semua perangkat periferal hingga 8. Karena mikrokontroler memungkinkan operasi dalam rentang frekuensi yang luas, perhitungan nilai pembagi pengatur waktu yang tepat untuk penundaan yang diperlukan selama pencatatan waktu internal memerlukan menentukan frekuensi prosesor. dan mode prescaler.  Dengan demikian, bagian pengaturan waktu mengambil bentuk berikut </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     //    Timer1 m.Timer1.Clock = eTimerClockSource.CLK256; //   m.Timer1.OCRA = (ushort)((0.5 * m.FCLK) / 256); //    A m.Timer1.Mode = eWaveFormMode.CTC_OCRA; //    m.Timer1.Activate(); //    Timer1</span></span></code> </pre> <br><p>  Jelas, pengaturan timer memerlukan mempelajari dokumentasi pabrikan untuk memilih mode yang benar dan memahami tujuan dari berbagai pengaturan, tetapi menggunakan perpustakaan membuat bekerja dengan perangkat lebih mudah dan lebih dimengerti, sambil tetap mempertahankan kemampuan untuk menggunakan semua mode perangkat. </p><br><p>  Sekarang saya sarankan sedikit gangguan dari deskripsi penggunaan perangkat tertentu dan sebelum melanjutkan, diskusikan masalah operasi asinkron.  Keuntungan utama dari perangkat periferal adalah mereka dapat melakukan fungsi-fungsi tertentu tanpa menggunakan sumber daya CPU.  Kompleksitas dapat muncul dalam organisasi interaksi antara program dan perangkat, karena peristiwa yang terjadi selama pengoperasian perangkat periferal tidak sinkron sehubungan dengan aliran eksekusi kode dalam CPU.  Metode interaksi sinkron, di mana program mengandung siklus untuk menunggu status perangkat yang diinginkan, meniadakan hampir semua keuntungan pinggiran sebagai perangkat independen.  Lebih efisien dan disukai adalah mode interrupt.  Dalam mode ini, prosesor terus mengeksekusi kode utas utama, dan ketika peristiwa terjadi, mengalihkan utas eksekusi ke penangannya.  Pada akhir pemrosesan, kontrol kembali ke utas utama.  Kelebihan dari pendekatan ini jelas, tetapi penggunaannya mungkin rumit oleh kompleksitas pengaturan.  Di assembler, untuk menggunakan interupsi, Anda harus: </p><br><ul><li>  atur alamat yang benar di tabel interupsi, </li><li>  konfigurasikan perangkat itu sendiri untuk bekerja dengan gangguan, </li><li>  Jelaskan fungsi penanganan interupsi </li><li>  menyediakan untuk pelestarian semua register dan bendera yang digunakan di dalamnya sehingga interupsi tidak mempengaruhi kemajuan utas utama </li><li>  aktifkan interupsi global. </li></ul><br><p>  Untuk menyederhanakan pemrograman kerja melalui interupsi, kelas-kelas deskripsi perangkat periferal perpustakaan berisi properti-event dari pengendali event.  Pada saat yang sama, untuk mengatur pekerjaan dengan perangkat periferal melalui interupsi, Anda hanya perlu menjelaskan kode untuk memproses acara yang diperlukan, dan perpustakaan akan melakukan semua pengaturan lain secara independen.  Mari kita kembali ke pengaturan timer dan menambahkannya dengan definisi kode yang harus dieksekusi ketika ambang batas untuk membandingkan saluran perbandingan timer tercapai.  Misalkan kita ingin bahwa ketika ambang batas saluran perbandingan dipicu, bit tertentu dari port I / O diatur ulang ketika meluap.  Dengan kata lain, kami ingin mengimplementasikan, menggunakan timer, fungsi menghasilkan sinyal PWM pada port yang dipilih sembarang dengan siklus tugas yang ditentukan oleh nilai-nilai <em>OCRA</em> untuk yang pertama dan <em>OCRB</em> untuk saluran kedua.  Mari kita lihat bagaimana kode akan terlihat dalam kasus ini. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; bit1.Mode = ePinMode.OUT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; bit2.Mode = ePinMode.OUT; m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  0  1   B   //     m.Timer0.Clock = eTimerClockSource.CLK; m.Timer0.OCRA = 50; m.Timer0.OCRB = 170; m.Timer0.Mode = eWaveFormMode.PWMPC_TOP8; //   m.Timer0.OnCompareA = () =&gt; bit1.Set(); m.Timer0.OnCompareB = () =&gt;bit2.Set(); m.Timer0.OnOverflow = () =&gt; m.PortB.Write(0); m.Timer0.Activate(); m.EnableInterrupt(); //  //   m.LOOP(m.TempH, (r, l) =&gt; m.GO(l), (r) =&gt; { });</span></span></code> </pre> <br><p>  Bagian tentang pengaturan mode timer telah dipertimbangkan sebelumnya, jadi mari kita beralih ke penangan interupsi segera.  Dalam contoh tersebut, tiga penangan digunakan untuk mengimplementasikan dua saluran PWM menggunakan satu pengatur waktu.  Kode penangan cukup jelas, tetapi pertanyaan mungkin timbul bagaimana penghematan negara yang disebutkan sebelumnya diimplementasikan sehingga panggilan interupsi tidak mempengaruhi logika utas utama.  Solusinya, di mana semua register dan bendera disimpan, terlihat jelas berlebihan, oleh karena itu perpustakaan menganalisis penggunaan sumber daya dalam interupsi dan menyimpan hanya minimum yang diperlukan.  Loop utama kosong mengonfirmasi gagasan bahwa tugas untuk terus menghasilkan beberapa sinyal PWM bekerja tanpa partisipasi dari program utama. </p><br><p>  Perlu dicatat bahwa perpustakaan mengimplementasikan pendekatan terpadu untuk bekerja dengan interupsi untuk semua kelas deskripsi perangkat periferal.  Ini menyederhanakan pemrograman dan mengurangi kesalahan. </p><br><p>  Kami akan terus mempelajari pekerjaan dengan interupsi dan mempertimbangkan situasi di mana mengklik tombol yang terpasang pada port input akan menyebabkan tindakan tertentu pada bagian program.  Dalam prosesor yang kami pertimbangkan, ada dua cara untuk menghasilkan interupsi ketika kondisi port input berubah.  Yang paling canggih adalah penggunaan mode interupsi eksternal.  Dalam hal ini, kami dapat menghasilkan interupsi terpisah untuk masing-masing kesimpulan dan mengkonfigurasi reaksi hanya untuk peristiwa tertentu (depan, resesi, level).  Sayangnya, hanya ada dua di kristal kami.  Metode lain memungkinkan Anda untuk mengontrol dengan cara menginterupsi salah satu bit dari port input, tetapi pemrosesan lebih rumit karena fakta bahwa peristiwa terjadi pada level port ketika sinyal input dari salah satu bit yang dikonfigurasi berubah, dan klarifikasi lebih lanjut dari penyebab interupsi harus dilakukan pada level algoritma oleh perangkat lunak . </p><br><p>  Sebagai ilustrasi, kami akan mencoba memecahkan masalah mengendalikan keadaan output port menggunakan dua tombol.  Salah satunya harus mengatur nilai port yang ditunjukkan oleh kami ke 1, dan yang lainnya reset.  Karena hanya ada dua tombol, kami akan menggunakan kesempatan untuk menggunakan interupsi eksternal. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortD[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0x0C</span></span>); <span class="hljs-comment"><span class="hljs-comment">// pull-up   m.INT0.Mode = eExtIntMode.Falling; //  INT0  . m.INT0.OnChange = () =&gt; m.PortD[0].Set(); //      1 m.INT1.Mode = eExtIntMode.Falling; //  INT1  . m.INT1.OnChange = () =&gt; m.PortD[0].Clear(); //     //  m.INT0.Activate(); m.INT1.Activate(); m.PortD.Activate(); m.EnableInterrupt(); //   //  m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { });</span></span></code> </pre> <br><p>  Menggunakan interupsi eksternal memungkinkan kami untuk memecahkan masalah kami sesederhana dan sejelas mungkin. </p><br><p>  Mengelola port eksternal secara terprogram bukan satu-satunya cara yang mungkin.  Terutama, timer memiliki pengaturan yang memungkinkan mereka untuk mengontrol output mikrokontroler secara langsung.  Untuk melakukan ini, dalam pengaturan timer, Anda harus menentukan mode kontrol output </p><br><pre> <code class="cs hljs">m.Timer0.CompareModeA = eCompareMatchMode.Set;</code> </pre> <br><p>  Setelah mengaktifkan timer, bit 6 port D akan menerima fungsi alternatif dan akan dikontrol oleh timer.  Dengan demikian, kami dapat menghasilkan sinyal PWM pada output prosesor murni pada tingkat perangkat keras, menggunakan perangkat lunak hanya untuk mengatur parameter sinyal.  Pada saat yang sama, jika kita mencoba menggunakan alat pustaka untuk beralih ke port sibuk sebagai port input / output, kita akan mendapatkan kesalahan di tingkat kompilasi. </p><br><p>  Perangkat terakhir yang akan kita lihat di bagian artikel ini adalah port serial USART.  Fungsionalitas perangkat ini sangat luas, tetapi sejauh ini kami hanya akan menyentuh salah satu kasus penggunaan yang paling umum untuk perangkat ini. </p><br><p>  Kasing penggunaan paling populer untuk port ini adalah menghubungkan terminal serial ke input / output informasi teks.  Bagian dari kode mengenai pengaturan port dalam kasus ini mungkin terlihat sebagai berikut </p><br><pre> <code class="cs hljs">m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     m.Usart.Mode = eUartMode.UART; //    UART m.Usart.Baudrate = 9600; //   9600  m.Usart.FrameFormat = eUartFrame.U8N1; //   8N1</span></span></code> </pre> <br><p>  Pengaturan yang ditentukan bertepatan dengan pengaturan default USART di perpustakaan, oleh karena itu, mereka dapat dilewati sebagian atau seluruhnya dalam teks program. </p><br><p>  Pertimbangkan contoh kecil di mana kita menampilkan teks statis ke terminal.  Agar tidak mengembang kode, kami membatasi diri pada output ke terminal klasik "Halo dunia!"  di awal program. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.ROMPTR(); <span class="hljs-comment"><span class="hljs-comment">//      m.CKDIV8 = false; m.FCLK = 16000000; //      m.Usart.Mode = eUartMode.UART; m.Usart.Baudrate = 9600; m.Usart.FrameFormat = eUartFrame.U8N1; //         m.Usart.OnTransmitComplete = () =&gt; { ptr.MLoadInc(m.TempL); m.IF(m.TempL!=0,()=&gt;m.Usart.Transmit(m.TempL)); }; m.Usart.Activate(); m.EnableInterrupt(); //   var str = Const.String("Hello world!"); //   ptr.Load(str); //     ptr.MloadInc(m.TempL); //    m.Usart.Transmit(m.TempL); //   . m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r,l) =&gt; { });</span></span></code> </pre> <br><p>  Dalam program ini, dari yang baru, deklarasi <em>str</em> string konstan.  Perpustakaan menempatkan semua variabel konstan dalam memori program, oleh karena itu, untuk bekerja dengannya, Anda harus menggunakan penunjuk <em>ROMPtr</em> .  Output data ke terminal dimulai dengan output dari karakter pertama dari urutan string, setelah itu kontrol langsung menuju loop utama, tanpa menunggu akhir output.  Penyelesaian proses transfer byte menyebabkan interupsi, di mana pawang yang membaca karakter berikutnya dari baris.  Jika karakter tidak sama dengan 0 (perpustakaan menggunakan format nol-dihentikan untuk menyimpan string), karakter ini dikirim ke port antarmuka serial.  Jika kita mencapai akhir baris, karakter tidak dikirim ke port dan siklus pengiriman berakhir. </p><br><p>  Kerugian dari pendekatan ini adalah algoritma pemrosesan interupsi tetap.  Ini tidak akan membiarkan port serial digunakan dengan cara lain selain menghasilkan string statis.  Kelemahan lain dari implementasi ini adalah kurangnya mekanisme untuk memantau hunian pelabuhan.  Jika Anda mencoba mengirim beberapa saluran secara berurutan, mungkin ada situasi di mana transmisi saluran sebelumnya akan terputus atau saluran akan tercampur. </p><br><p>  Metode yang lebih efektif untuk memecahkan masalah ini dan masalah lainnya, serta bekerja dengan perangkat periferal lainnya, kita akan lihat di bagian posting selanjutnya.  Di dalamnya, kita akan melihat lebih dekat pada pemrograman menggunakan kelas manajemen tugas <em>paralel</em> khusus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463627/">https://habr.com/ru/post/id463627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463613/index.html">Gambar Docker juga dapat dibangun di werf menggunakan Dockerfile biasa</a></li>
<li><a href="../id463617/index.html">Fitur pengujian MMO seluler</a></li>
<li><a href="../id463619/index.html">Bekerja dari jarak jauh: pengalaman kami</a></li>
<li><a href="../id463623/index.html">Kami dipilih dari hutan tes: kami sedang membangun jalan singkat dari perlengkapan ke pengujian</a></li>
<li><a href="../id463625/index.html">Pemantauan jaringan dan deteksi aktivitas jaringan abnormal menggunakan solusi Flowmon Networks</a></li>
<li><a href="../id463629/index.html">Mengkonfigurasi NextCloud + ONLYOFFICE di server yang sama menggunakan Docker</a></li>
<li><a href="../id463631/index.html">Dialog tentang surat</a></li>
<li><a href="../id463637/index.html">Menguji infrastruktur Anda sebagai kode dengan Pulumi. Bagian 2</a></li>
<li><a href="../id463639/index.html">Yah Apple BLEee</a></li>
<li><a href="../id463647/index.html">Video dan laporan dengan SmartMail Meetup: Frontend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>