<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔬 🎤 💚 So debuggen Sie WebRTC 👩🏾‍🎓 👨🏼‍⚕️ 🐒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Voximplant verwenden wir WebRTC seit seiner Einführung: zuerst als Alternative zu Flash für Sprach- und Videoanrufe und dann als vollständiger Ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So debuggen Sie WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Bei Voximplant verwenden wir WebRTC seit seiner Einführung: zuerst als Alternative zu Flash für Sprach- und Videoanrufe und dann als vollständiger Ersatz.  Die Technologie hat einen langen und schmerzhaften Entwicklungsweg zurückgelegt. Erst vor kurzem haben alle gängigen Browser damit begonnen, sie zu unterstützen. Es gibt Schwierigkeiten bei der Bildschirmübertragung, mehrere Videostreams, und manchmal stürzt der Browser einfach ab, wenn Sie den Videostream aus- und wieder einschalten.  Die gesammelten Erfahrungen ermöglichen es uns, interessante Artikel für Habr zu übersetzen, und heute geben wir das Wort an Lee Sylvester von Xirsys weiter, der über das Debuggen von (Video-) Aufrufen in Chrome, Firefox, Safari und Edge sprechen wird.  Das Debuggen von WebRTC ist nicht einfach. Wir haben sogar spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen</a> zum Entfernen von Protokollen in gängigen Browsern.  Und was Lee hat - Sie werden es unter dem Schnitt herausfinden (Spoiler: viel von allem, einschließlich WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  Die dunkle Seite von WebRTC </h2><br>  Während meiner Arbeit bei Xirsys habe ich einige wirklich coole Apps gesehen, die WebRTC verwendeten.  Während eine kleine Gruppe von Entwicklern High-Tech-Produkte erstellt, können die meisten Programmierer WebRTC nicht einmal verwenden.  Warum?  Und alles ist einfach.  Es ist kompliziert. <br><br>  Viele von uns kennen eine typische Webanwendung.  Eine solche Anwendung hat einen Client, der Anforderungen sendet, und einen Server, der auf diese Anforderungen reagiert.  Ein einfacher, linearer und leicht vorhersehbarer Prozess.  Wenn etwas schief geht, wissen wir normalerweise, wo wir uns die Protokolle ansehen müssen und was passieren kann.  Aber mit WebRTC ist nicht alles so einfach. <br><br><h2>  Asynchronität </h2><br>  Wenn Sie jemals eine Multithread-Anwendung geschrieben haben, wissen Sie wahrscheinlich, welche Kopfschmerzen diese Entwicklung verursacht.  Flüge, schlechtes Gedächtnis - aber meistens nur Fehler, die schwer zu finden sind. <br><br>  WebRTC ist asynchroner Natur.  Und das ist überhaupt nicht die einfache AJAX-Asynchronität.  Um eine Analogie zu ziehen, sind dies mehrere gleichzeitig gestartete AJAX-Anforderungen, die versuchen, Daten auf zwei Computern abzustimmen.  Das ist immer noch Unterhaltung. <br><br><h2>  NAT-Bypass-Minenfeld </h2><br>  Beim Erstellen von Webanwendungen muss etwas entwickelt werden, das auf dem Server ausgeführt wird und auf Anforderungen reagiert.  Das Schlimmste, was passieren kann, ist der Port, der in IPTables nicht geöffnet ist.  Es wird in 2 Minuten behandelt.  Sie können nicht über WebRTC sagen. <br><br>  Webserver, nicht einmal ihre Software, sondern Hardware, sind Geräte mit öffentlichen IP-Adressen.  Sie sind von überall zugänglich.  Und WebRTC dient zum Senden und Empfangen von Daten von den Computern der Benutzer.  Die haben normalerweise eine IP-Adresse von 192.168. Etwas und brennen nicht mit dem Wunsch, auf Netzwerkanfragen zu antworten. <br><br>  Die Autoren von WebRTC wissen davon, daher sortiert die Engine verschiedene Verbindungsmethoden, um eine Verbindung zwischen zwei Computern herzustellen, die nicht sehr dafür ausgelegt sind. <br><br><h2>  Wo soll ich mit dem Debuggen beginnen? </h2><br>  In diesem Artikel spreche ich über die grundlegenden Werkzeuge zur Lösung der beliebtesten Probleme.  Aber vorher wollen wir sehen, wie WebRTC normalerweise eine Verbindung herstellt. <br><br><h2>  Wie WebRTC eine Verbindung herstellt </h2><br>  Alle WebRTC-Verbindungen erfordern ein wenig Hilfe vom Signalisierungsprotokoll.  "Wenig Hilfe" ist Ihr eigener Server und Ihr eigenes Protokoll, mit denen der Anrufer mit der Person, die er anruft, kommunizieren kann, bevor er eine Peer-to-Peer-Verbindung herstellt. <br><br>  WebRTC verwendet das Signalisierungsprotokoll, um Informationen über IP-Adressen, die Fähigkeit zur Erfassung und Wiedergabe von Sprache und Video, die Netzwerktopologie und die übertragenen Daten zu übertragen. <br><br>  Das häufig verwendete Protokoll ist COMET (oder SIP - Anmerkung des Übersetzers) und Web-Sockets.  WebRTC beschränkt Entwickler nicht auf irgendetwas, so dass Sie alles verwenden können, was Sie möchten, zumindest Daten über den Editor übertragen und kopieren und einfügen (in einem der Workshops funktioniert es - wieder ein Übersetzer).  Durch die Signalisierung beider Computer können Sie bereits über WebRTC eine Verbindung herstellen. <br><br><h4>  Angebot und Antwort </h4><br>  WebRTC-Verbindungen verwenden "Angebot" und "Antwort": <br><br><ol><li>  Der Initiator der Verbindung erstellt ein "Angebot" und leitet es an die andere Seite weiter. </li><li>  Die Gegenpartei erhält ein „Angebot“, erstellt eine „Antwort“ und gibt diese zurück. </li><li>  Der Initiator der Verbindung erhält eine "Antwort". </li></ol><br>  Das ist theoretisch.  In der Praxis sieht der Austausch von Höflichkeiten nicht so einfach aus. <br><br><ol><li>  Vor dem Senden von "Angebot" erstellt der Verbindungsinitiator eine Instanz von <b>RTCPeerConnection</b> und empfängt daraus das <b>Textpaket</b> "SDP" (Session Description Protocol) mit <b>rtcPeerConnection.createOffer ()</b> .  Dieses Paket beschreibt die Fähigkeit, Sprache und Video für den Browser zu empfangen / zu senden. </li><li>  Der Inhalt des SDP-Pakets wird mithilfe von <b>rtcPeerConnection.setLocalDescription ()</b> als "Beschreibung der lokalen Seite der Verbindung" <b>festgelegt</b> . </li><li>  Das Paket wird an die andere Seite gesendet, wo sein Inhalt mit <b>rtcPeerConnection.setRemoteDescription ()</b> als "Beschreibung der anderen Seite der Verbindung" <b>festgelegt wird</b> . </li><li>  Auf der anderen Seite der Verbindung wird mit <b>rtcPeerConnection.createAnswer ()</b> ein eigenes SDP-Paket erstellt. Der Inhalt wird als „Beschreibung der lokalen Seite der Verbindung“ festgelegt. </li><li>  Das Paket wird an den Verbindungsinitiator weitergeleitet, der seinen Inhalt als "Beschreibung der anderen Seite der Verbindung" festlegt. </li></ol><br>  Und erst nach all den Aktionen kennen beide Verbindungsparteien die Fähigkeiten des anderen zum Empfangen und Senden von Sprache / Video. <br><br><h4>  ICE-Kandidaten </h4><br>  Die Fähigkeit, mit Medien zu arbeiten, reicht jedoch nicht aus.  Immerhin haben die Vertragsparteien noch nichts über den Zustand des Netzes gesagt. <br><br>  Sie können sofort herausfinden, welche Video-Codecs der Browser unterstützt und ob sich auf dem Laptop eine Kamera befindet.  Es braucht Zeit, um Ihre externe IP-Adresse und die Logik des NAT-Betriebs herauszufinden, und Informationen über den Netzwerkstatus werden ausgetauscht, wenn diese Informationen empfangen werden. <br><br>  Dank der Trickle ICE-Technologie (nicht von allen Browsern unterstützt - Anmerkung des Übersetzers) kann die Verbindung zwischen zwei WebRTC-Geräten jederzeit hergestellt werden - sobald ein geeigneter „Kandidat“ gefunden wurde. <br><br>  Der Entwickler muss das Ereignis <b>onicecandidate</b> abonnieren (alles in Kleinbuchstaben!) Und die empfangenen SDP-Pakete an die andere Seite weiterleiten, wo sie von WebRTC mithilfe der <b>addIceCandidate-</b> Methode (und hier Überraschung, Großbuchstabe) übertragen werden müssen.  Es funktioniert in beide Richtungen. <br><br><h2>  Verbindung </h2><br>  WebRTC verwendet Dinge wie STUN (Session Traversal Utilities für NAT) und TURN (Traversal Using Relay um NAT), um eine Verbindung herzustellen.  Es klingt beängstigend, aber in Wirklichkeit gibt es nur zwei Netzwerkprotokolle. <br><br><h4>  STUN Server </h4><br>  Das erste der beiden Protokolle ist etwas komplizierter als der Echoserver.  Wenn Verbindungsteilnehmer beschreiben möchten, wie sie eine Verbindung zu ihnen herstellen sollen, benötigen sie ihre öffentliche IP-Adresse.  Und höchstwahrscheinlich ist dies nicht die IP-Adresse des Computers. Öffentliche Geräte werden Benutzergeräten selten zugewiesen.  Die gesamte NAT-Technologie wurde erfunden, um nicht zu isolieren.  Um Ihre öffentliche Adresse weiterhin herauszufinden, sendet der Browser eine Anfrage an den STUN-Server.  Beim Durchlaufen von NAT ändert das Netzwerkpaket seine Rücksprungadresse in public.  Nachdem der STUN-Server das Paket mit der Anforderung empfangen hat, kopiert er die Rücksprungadresse des Pakets in seine Nutzdaten und sendet das Paket zurück.  Beim Durchlaufen von NAT in die entgegengesetzte Richtung verliert das Paket seine öffentliche IP-Adresse, aber eine Kopie dieser Adresse verbleibt in der Nutzlast, wo WebRTC sie lesen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  TURN-Server </h2><br>  Der TURN-Server verwendet die STUN-Protokollerweiterung.  Dieselben Pakete, Header und eine neue Sache: <b>Befehl</b> .  Der Server ist ein Proxy: Beide Clients stellen über den UDP- <b>Zuweisungsport</b> eine Verbindung zu ihm her und übertragen ihre Daten über den Server. <br><br>  TURN-Server sind so konzipiert, dass der Initiator der Verbindung über mehr Funktionen verfügt als die andere Seite.  Dies führt zu einem interessanten Effekt, wenn ein Anruf über einen TURN-Server erfolgreich oder nicht erfolgreich ist, je nachdem, wer wen anruft (denken Sie an alle Skype - Notizübersetzer). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Debuggen </h2><br>  Sie lesen also bis zu diesem Absatz.  Wir sind mit dem Übersetzer zufrieden und denken daran, dass es in dem Artikel um das Debuggen von WebRTC geht.  Aber all das ist ein notwendiges Minimum, ohne das man nicht einmal anfangen kann.  Aber wenn Sie anfangen und kein unmenschliches Glück haben, wird es brechen. <br><br>  Es wird auf viele verschiedene Arten brechen.  Der erste ist der Mangel an Konnektivität.  Sie haben sowohl die STUN- als auch die TURN-Servereinstellungen an beide WebRTCs übergeben und ihnen dabei geholfen, Angebote, Antworten und ICE-Kandidaten auszutauschen, aber es gibt weder Video noch Sprache.  Wo soll ich anfangen?  Bei lokalen Wiedergabeproblemen. <br><br><h2>  Lokales WebRTC-Debugging </h2><br>  Wie ich oben geschrieben habe, erfolgt die Hauptarbeit von WebRTC auf der Browserseite.  STUN- und TURN-Server sind unglaublich einfach, sodass die meisten Probleme in Ihrem JavaScript-Code auftreten, der in zwei Browsern ausgeführt wird.  Traurig aber wahr.  Auf der anderen Seite, wenn das Interessanteste lokal in Browsern passiert, haben Sie reichlich Gelegenheit zum Debuggen! <br><br>  Das erste, was Sie überprüfen müssen, ist Ihre Signalisierung.  Es ist Ihr Code, der die Konfiguration von Audio mit Video (Angebot, Antwort) und Informationen zu Netzwerkeinstellungen (Eiskandidaten) zwischen Browsern überträgt.  Sie müssen überprüfen, welche Pakete gesendet, welche WebRTC empfangen und gesendet wurden: <br><br><ul><li>  hat die andere Seite der Verbindung ein Angebot erhalten?  Hat der Verbindungsinitiator eine Antwort erhalten?  Ohne diesen minimalen Austausch von Annehmlichkeiten wird keine Verbindung hergestellt. </li><li>  Hat WebRTC an beiden Enden der Verbindung Pakete mit ICE-Kandidaten weitergeleitet?  Haben Sie diese Pakete ausgetauscht und mit <b>addIceCandidate</b> an die andere Seite <b>zurückgegeben</b> ? </li><li>  Wenn beim Paketaustausch alles gut lief, wurde der <b>onaddstream-</b> Ereignishandler <b>aufgerufen</b> und haben Sie das resultierende Objekt in einem HTML-Element installiert, um Video (oder Audio) abzuspielen? </li></ul><br>  Wenn der Paketaustausch nicht verdächtig ist, können Sie sich mit den Eingeweiden der Sitzung befassen. <br><br><h2>  Sitzungsbeschreibungsprotokoll </h2><br>  Angebots-, Antwort- und ICE-Kandidatenpakete werden von WebRTC im SDP-Textformat erstellt.  Auf den ersten Blick sieht der Inhalt der Pakete beängstigend aus, aber mit ein wenig Vorbereitung können Sie beim Debuggen viel davon profitieren.  Wikipedia beschreibt SDP ziemlich gut, aber ich habe eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bessere Beschreibung</a> für Sie gefunden. <br><br>  Das wichtigste Feld in Kandidaten-ICE-SDP-Paketen ist <b>typ</b> .  Für WebRTC kann ein Feld einen von drei Werten haben: <br><br><ul><li>  typ host; </li><li>  typ srflx; </li><li>  Typ Relais. </li></ul><br><h4>  Typ Host </h4><br>  Der <b>Hosttyp</b> gibt den ICE-Kandidaten für eine lokale Verbindung an (WebRTC zählt mehrere Kandidaten auf, in der Hoffnung, eine Verbindung herzustellen, es ist nicht im Voraus bekannt, welche sich herausstellen wird - vom Übersetzer notiert).  Für eine solche Verbindung ist weder ein STUN- noch ein TURN-Server erforderlich, da Geräte im lokalen Netzwerk häufig Netzwerkverbindungen direkt herstellen können.  Beim Debuggen aus dem lokalen Netzwerk müssen Sie nur die Übertragung von <b>Host-</b> Paketen überprüfen und debuggen und sicherstellen, dass die Geräte UDP-Pakete untereinander senden können.  Obwohl es Ausnahmen gibt, habe ich in der Praxis Netzwerkkonfigurationen gesehen, bei denen der Browser einen TURN-Server benötigte, um eine Verbindung zu sich selbst herzustellen. <br><br><h4>  typ srflx </h4><br>  Die Buchstabenkombination „srflx“ steht für „Server Reflexive“ und markiert die Verbindungskandidaten mit einer externen IP-Adresse, wobei ein STUN-Server für die Verbindung ausreicht (mithilfe der NAT-Penetrationstechnologie, die in etwa 80% der Fälle erfolgreich ist, beachten Sie den Übersetzer). <br><br><h4>  Typ Relais </h4><br>  "Relay" markiert die Verbindung über einen TURN-Server, was fast immer erfolgreich ist.  Es ist wichtig zu beachten, dass WebRTC nicht genau drei verschiedene Pakete mit dem Feld "typ" erstellen muss.  Wie Kandidaten ausgewählt werden, hängt von der Implementierung von WebRTC in einer bestimmten Browserversion ab. <br><br><h2>  Testen der Gerätekonnektivität </h2><br>  Google bietet eine spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webanwendung</a> zum Testen von WebRTC-Verbindungen auf Ihrem Gerät.  Öffnen Sie die Seite, klicken Sie auf die Schaltfläche "Start". Der JavaScript-Code versucht, mithilfe der Signalisierung, der STUN- und TURN-Server von Google eine Verbindung zum Google-Server herzustellen. <br><br><h2>  WebRTC-Interna </h2><br>  Sie haben alle Pakete untersucht, den Code überprüft, alles sieht richtig aus, aber es funktioniert nicht?  Für solche Fälle hat Google seinem Chrome-Browser einen speziellen Abschnitt zur Verfügung gestellt, in dem die Interna von WebRTC während des Verbindungsaufbaus und einige schöne Grafiken für den Fall einer erfolgreichen Verbindung angezeigt werden.  Öffnen Sie zur Verwendung einen speziellen technischen Link im Browser: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Wenn Sie bereits eine Anwendung mit WebRTC geöffnet haben, werden sofort eine Reihe technischer Daten angezeigt.  Andernfalls öffnen Sie einfach eine andere Registerkarte und es gibt etwas, das WebRTC verwendet.  Auf der Registerkarte werden alle Aufrufe des <b>RTCPeerConnection-</b> Objekts <b>angezeigt</b> , und Sie können in Echtzeit sehen, wie die Verbindung hergestellt wird. <br><br><h2>  ICE-Setup </h2><br>  Am oberen Rand der Seite befindet sich die ICE-Zeichenfolge, mit der die Verbindung initialisiert wurde.  Wenn während seiner Entstehung ein Fehler gemacht wurde, ist dieser sofort sichtbar (durch die "ICE-Linie" verweist der Autor auf die Konfiguration des RTCPeerConnection-Objekts mit einer Liste von STUN- und TURN-Servern (das 'iceServers'-Objekt) - Hinweis des Übersetzers).  Vielleicht gibt es keine Liste von Servern?  Sie müssen das RTCPeerConnection-Objekt konfigurieren, bevor Sie den ersten Aufruf von <b>createOffer</b> oder <b>createAnswer ausführen</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  RTCPeerConnection-Ereignisse </h2><br>  Der nächste interne Abschnitt zeigt die Aufrufe der <b>RTCPeerConnection-</b> Methoden und die vom Objekt empfangenen Ereignisse in chronologischer Reihenfolge.  Fehler werden sorgfältig rot hervorgehoben.  Bitte beachten Sie, dass das rote <b>addIceCandidateFailed</b> häufig kein Anzeichen für einen Fehler ist und die Verbindung möglicherweise normal hergestellt wird.  Wenn die Verbindung erfolgreich ist, ist das letzte Ereignis in der Liste ein <b>iceconnectionstatechange-</b> Ereignis mit dem Wert <b>complete</b> . <br><br><h2>  Abschnitt 'Statistiken' </h2><br>  Der nächste Abschnitt ist relevant, wenn die Verbindung erfolgreich hergestellt wurde.  Es enthält Statistiken über übertragene Daten und Netzwerkverzögerungen.  Die zwei interessantesten Optionen sind: <b>ssrc</b> und <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", markiert jede Ihrer Audio- und Videospuren.  Zeigt Statistiken der übertragenen Daten und Parameter an, z. B. die <b>Umlaufzeit</b> . </li><li>  <b>bweforvideo</b> , BandWidth Estimation, zeigt die Breite des verwendeten Netzwerkkanals an. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  GetStats-Funktion </h2><br>  Oft können Sie nicht auf die Interna-Seite zugreifen.  Zum Beispiel, wenn ein Problem mit Ihrem Benutzer auftritt.  In diesem Fall können Sie dieselben Daten <b>abrufen</b> , die auf der internen Seite <b>angezeigt</b> werden, indem Sie die Methode <b>getStats</b> für das <b>RTCPeerConnection-</b> Objekt <b>aufrufen</b> .  Diese Methode richtet eine Rückruffunktion ein, die WebRTC jedes Mal aufruft, wenn etwas Interessantes passiert.  Die aufgerufene Funktion erhält ein Objekt mit den Feldern, die auf der Interna-Seite angezeigt werden: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Ein weiteres nützliches Tool ist das Ereignis <b>oniceconnectionstatechange</b> eines <b>RTCPeerConnection-</b> Objekts.  Der Ereignishandler erhält Informationen zum Verbindungsfortschritt.  Mögliche Optionen: <br><br><ul><li>  <b>neu</b> : WebRTC erwartet Kandidaten von der zweiten Seite der Verbindung, die mit der <b>addIceCandidate-</b> Methode hinzugefügt werden <b>müssen</b> . </li><li>  <b>Überprüfung</b> : WebRTC hat Kandidaten von der zweiten Seite der Verbindung empfangen, vergleicht sie mit lokalen und iteriert über Optionen. </li><li>  <b>verbunden</b> : Ein geeignetes Kandidatenpaar wird ausgewählt und die Verbindung hergestellt.  Es ist bemerkenswert, dass die Kandidaten danach gemäß dem Trickle ICE-Protokoll weiter kommen können. </li><li>  <b>abgeschlossen</b> : Alle Kandidaten werden empfangen und die Verbindung hergestellt. </li><li>  <b>getrennt</b> : Die Verbindung wird <b>getrennt</b> .  Auf instabilen Kanälen kann sich WebRTC wieder verbinden. Wir überwachen das <b>verbundene</b> Flag. </li><li>  <b>geschlossen</b> : Die Verbindung wird getrennt und WebRTC funktioniert nicht mehr damit. </li></ul><br>  Wenn die Verbindung im <b>fehlgeschlagenen</b> Zustand beendet wurde, können wir die auf beiden Seiten empfangenen Kandidaten untersuchen und verstehen, warum die Verbindung fehlgeschlagen ist.  Wenn beispielsweise eine Seite <b>Host-</b> und <b>srflx-Kandidaten bereitstellte</b> , die andere Seite <b>Host</b> und <b>Relay</b> , die Geräte sich jedoch in unterschiedlichen Netzwerken befanden. <br><br><h2>  Schwarzes Rechteck statt Video </h2><br>  Oft gibt es eine Situation, in der die Verbindung hergestellt wird, der Ton übertragen wird, aber anstelle des Videos hat einer oder beide Teilnehmer ein schwarzes Rechteck.  Meistens geschieht dies, wenn Sie das empfangene Videoobjekt einem HTML-Element zuweisen, bevor die Verbindung in den <b>abgeschlossenen</b> Zustand übergeht. <br><br><h2>  Wie man einen Zauberstab nach draußen steckt </h2><br>  Zusätzlich zum <b>RTCPeerConnection-</b> Objekt <b>selbst</b> und den vom Browser angezeigten Interna können Sie Tools zur Analyse von Netzwerkpaketen wie Wireshark verwenden.  Diese Tools können Pakete verwendeter WebRTC-Protokolle anzeigen.  Wireshark zeigt Ihnen beispielsweise den Inhalt von STUN-Paketen im Hauptfenster an, und Sie können sie filtern, indem Sie das Schlüsselwort "stun" in das Filterfeld eingeben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  Was ist in Serverantworten zu beachten?  Wenn Sie nur Antworten mit dem <b>Bindungstyp sehen</b> , bedeutet dies, dass nur STUN (externes IP-Gespräch) unterstützt wird und WebRTC nur <b>srflx-</b> Kandidaten anbieten <b>kann</b> .  Wenn die Antworten TURN-spezifische Pakete <b>Allocation</b> und <b>CreatePermission enthalten</b> , hat WebRTC die Möglichkeit, eine Verbindung über einen Proxyserver herzustellen.  Der Paketanalysator markiert die erfolgreiche und nicht erfolgreiche <b>Zuordnung</b> .  Wenn es keinen gibt, der erfolgreich ist, werden höchstwahrscheinlich die falschen Zugriffsparameter auf die TURN-Server (die fast immer mit einem Benutzernamen und einem Kennwort schützen - die Anmerkung des Übersetzers) übergeben. <br><br>  Wenn das Protokoll ein <b>CreatePermission Success Response-</b> Paket enthält, können wir davon ausgehen, dass mit den Konfigurationen STUN und TURN alles in Ordnung ist.  Und wenn es auch ein <b>ChannelBind-</b> Paket gibt, konnte mit hoher Geschwindigkeit eine Verbindung zum TURN-Server hergestellt werden. <br><br><h2>  Zelluläre Probleme </h2><br>  In meiner Praxis können viele WebRTC-Lösungen, die eine WiFi-Verbindung herstellen, keine Verbindung über 3G / 4G herstellen.  Eine auf einem mobilen Gerät gestartete Anwendung ist schwieriger zu debuggen: Wir haben keinen so einfachen Paketanalysator wie Wireshark, und Safari kann keine WebRTC-Interna anzeigen.  Die Logik legt nahe, dass das Problem nicht in der Anwendung selbst liegt, sondern in der Mobilfunkkommunikation, wenn die Anwendung über WLAN einwandfrei funktioniert.  Wie debuggen?  Nehmen Sie einen Laptop und schließen Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3G-Dongle</a> an.  Sie haben also einen Paketanalysator und praktische Protokolle, mit denen Sie die Wurzel aller Probleme in angemessener Zeit finden können. <br><br><h2>  Schlussfolgerungen </h2><br>  Das Debuggen von WebRTC ist nicht einfach, aber wenn Sie im Internet gut suchen, finden Sie viele Artikel und Beispiele.  Wenn Sie im Bereich der Echtzeitkommunikation arbeiten, empfehle ich Ihnen, die RFC-Spezifikationen für die Protokolle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TURN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebRTC zu</a> lesen.  Die Dokumente sind groß, aber die darin enthaltenen Informationen helfen, verlässliche Entscheidungen zu treffen und die Frage zu beantworten, warum es nicht klingelt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417869/">https://habr.com/ru/post/de417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417859/index.html">3CX-Integration mit Microsoft Dynamics 365</a></li>
<li><a href="../de417861/index.html">Endloses Primmuster</a></li>
<li><a href="../de417863/index.html">Kinder bald bestellen? Der UK Ethics Council genehmigt die Gentechnik menschlicher Embryonen</a></li>
<li><a href="../de417865/index.html">Android-Barrierefreiheit - ein Wolf im Schafspelz? Yandex Vortrag</a></li>
<li><a href="../de417867/index.html">Wie man die Dauer eines IT-Projekts bewertet und wann es sich überhaupt nicht lohnt</a></li>
<li><a href="../de417871/index.html">An der Ziellinie des suborbitalen Tourismus</a></li>
<li><a href="../de417873/index.html">Möglichkeiten zum Erstellen von PopUp-Fenstern</a></li>
<li><a href="../de417875/index.html">Raus aus dem Kaninchenbau SPA mit modernen Schienen</a></li>
<li><a href="../de417877/index.html">Wie Tinder (leicht) Ihren Standort verbirgt</a></li>
<li><a href="../de417879/index.html">Kostenlose Prüfung von Microsoft [zum Beispiel ein kürzlich durchgeführter Wettbewerb]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>