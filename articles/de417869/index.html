<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüî¨ üé§ üíö So debuggen Sie WebRTC üë©üèæ‚Äçüéì üë®üèº‚Äç‚öïÔ∏è üêí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Voximplant verwenden wir WebRTC seit seiner Einf√ºhrung: zuerst als Alternative zu Flash f√ºr Sprach- und Videoanrufe und dann als vollst√§ndiger Ers...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So debuggen Sie WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  Bei Voximplant verwenden wir WebRTC seit seiner Einf√ºhrung: zuerst als Alternative zu Flash f√ºr Sprach- und Videoanrufe und dann als vollst√§ndiger Ersatz.  Die Technologie hat einen langen und schmerzhaften Entwicklungsweg zur√ºckgelegt. Erst vor kurzem haben alle g√§ngigen Browser damit begonnen, sie zu unterst√ºtzen. Es gibt Schwierigkeiten bei der Bildschirm√ºbertragung, mehrere Videostreams, und manchmal st√ºrzt der Browser einfach ab, wenn Sie den Videostream aus- und wieder einschalten.  Die gesammelten Erfahrungen erm√∂glichen es uns, interessante Artikel f√ºr Habr zu √ºbersetzen, und heute geben wir das Wort an Lee Sylvester von Xirsys weiter, der √ºber das Debuggen von (Video-) Aufrufen in Chrome, Firefox, Safari und Edge sprechen wird.  Das Debuggen von WebRTC ist nicht einfach. Wir haben sogar spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anweisungen</a> zum Entfernen von Protokollen in g√§ngigen Browsern.  Und was Lee hat - Sie werden es unter dem Schnitt herausfinden (Spoiler: viel von allem, einschlie√ülich WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  Die dunkle Seite von WebRTC </h2><br>  W√§hrend meiner Arbeit bei Xirsys habe ich einige wirklich coole Apps gesehen, die WebRTC verwendeten.  W√§hrend eine kleine Gruppe von Entwicklern High-Tech-Produkte erstellt, k√∂nnen die meisten Programmierer WebRTC nicht einmal verwenden.  Warum?  Und alles ist einfach.  Es ist kompliziert. <br><br>  Viele von uns kennen eine typische Webanwendung.  Eine solche Anwendung hat einen Client, der Anforderungen sendet, und einen Server, der auf diese Anforderungen reagiert.  Ein einfacher, linearer und leicht vorhersehbarer Prozess.  Wenn etwas schief geht, wissen wir normalerweise, wo wir uns die Protokolle ansehen m√ºssen und was passieren kann.  Aber mit WebRTC ist nicht alles so einfach. <br><br><h2>  Asynchronit√§t </h2><br>  Wenn Sie jemals eine Multithread-Anwendung geschrieben haben, wissen Sie wahrscheinlich, welche Kopfschmerzen diese Entwicklung verursacht.  Fl√ºge, schlechtes Ged√§chtnis - aber meistens nur Fehler, die schwer zu finden sind. <br><br>  WebRTC ist asynchroner Natur.  Und das ist √ºberhaupt nicht die einfache AJAX-Asynchronit√§t.  Um eine Analogie zu ziehen, sind dies mehrere gleichzeitig gestartete AJAX-Anforderungen, die versuchen, Daten auf zwei Computern abzustimmen.  Das ist immer noch Unterhaltung. <br><br><h2>  NAT-Bypass-Minenfeld </h2><br>  Beim Erstellen von Webanwendungen muss etwas entwickelt werden, das auf dem Server ausgef√ºhrt wird und auf Anforderungen reagiert.  Das Schlimmste, was passieren kann, ist der Port, der in IPTables nicht ge√∂ffnet ist.  Es wird in 2 Minuten behandelt.  Sie k√∂nnen nicht √ºber WebRTC sagen. <br><br>  Webserver, nicht einmal ihre Software, sondern Hardware, sind Ger√§te mit √∂ffentlichen IP-Adressen.  Sie sind von √ºberall zug√§nglich.  Und WebRTC dient zum Senden und Empfangen von Daten von den Computern der Benutzer.  Die haben normalerweise eine IP-Adresse von 192.168. Etwas und brennen nicht mit dem Wunsch, auf Netzwerkanfragen zu antworten. <br><br>  Die Autoren von WebRTC wissen davon, daher sortiert die Engine verschiedene Verbindungsmethoden, um eine Verbindung zwischen zwei Computern herzustellen, die nicht sehr daf√ºr ausgelegt sind. <br><br><h2>  Wo soll ich mit dem Debuggen beginnen? </h2><br>  In diesem Artikel spreche ich √ºber die grundlegenden Werkzeuge zur L√∂sung der beliebtesten Probleme.  Aber vorher wollen wir sehen, wie WebRTC normalerweise eine Verbindung herstellt. <br><br><h2>  Wie WebRTC eine Verbindung herstellt </h2><br>  Alle WebRTC-Verbindungen erfordern ein wenig Hilfe vom Signalisierungsprotokoll.  "Wenig Hilfe" ist Ihr eigener Server und Ihr eigenes Protokoll, mit denen der Anrufer mit der Person, die er anruft, kommunizieren kann, bevor er eine Peer-to-Peer-Verbindung herstellt. <br><br>  WebRTC verwendet das Signalisierungsprotokoll, um Informationen √ºber IP-Adressen, die F√§higkeit zur Erfassung und Wiedergabe von Sprache und Video, die Netzwerktopologie und die √ºbertragenen Daten zu √ºbertragen. <br><br>  Das h√§ufig verwendete Protokoll ist COMET (oder SIP - Anmerkung des √úbersetzers) und Web-Sockets.  WebRTC beschr√§nkt Entwickler nicht auf irgendetwas, so dass Sie alles verwenden k√∂nnen, was Sie m√∂chten, zumindest Daten √ºber den Editor √ºbertragen und kopieren und einf√ºgen (in einem der Workshops funktioniert es - wieder ein √úbersetzer).  Durch die Signalisierung beider Computer k√∂nnen Sie bereits √ºber WebRTC eine Verbindung herstellen. <br><br><h4>  Angebot und Antwort </h4><br>  WebRTC-Verbindungen verwenden "Angebot" und "Antwort": <br><br><ol><li>  Der Initiator der Verbindung erstellt ein "Angebot" und leitet es an die andere Seite weiter. </li><li>  Die Gegenpartei erh√§lt ein ‚ÄûAngebot‚Äú, erstellt eine ‚ÄûAntwort‚Äú und gibt diese zur√ºck. </li><li>  Der Initiator der Verbindung erh√§lt eine "Antwort". </li></ol><br>  Das ist theoretisch.  In der Praxis sieht der Austausch von H√∂flichkeiten nicht so einfach aus. <br><br><ol><li>  Vor dem Senden von "Angebot" erstellt der Verbindungsinitiator eine Instanz von <b>RTCPeerConnection</b> und empf√§ngt daraus das <b>Textpaket</b> "SDP" (Session Description Protocol) mit <b>rtcPeerConnection.createOffer ()</b> .  Dieses Paket beschreibt die F√§higkeit, Sprache und Video f√ºr den Browser zu empfangen / zu senden. </li><li>  Der Inhalt des SDP-Pakets wird mithilfe von <b>rtcPeerConnection.setLocalDescription ()</b> als "Beschreibung der lokalen Seite der Verbindung" <b>festgelegt</b> . </li><li>  Das Paket wird an die andere Seite gesendet, wo sein Inhalt mit <b>rtcPeerConnection.setRemoteDescription ()</b> als "Beschreibung der anderen Seite der Verbindung" <b>festgelegt wird</b> . </li><li>  Auf der anderen Seite der Verbindung wird mit <b>rtcPeerConnection.createAnswer ()</b> ein eigenes SDP-Paket erstellt. Der Inhalt wird als ‚ÄûBeschreibung der lokalen Seite der Verbindung‚Äú festgelegt. </li><li>  Das Paket wird an den Verbindungsinitiator weitergeleitet, der seinen Inhalt als "Beschreibung der anderen Seite der Verbindung" festlegt. </li></ol><br>  Und erst nach all den Aktionen kennen beide Verbindungsparteien die F√§higkeiten des anderen zum Empfangen und Senden von Sprache / Video. <br><br><h4>  ICE-Kandidaten </h4><br>  Die F√§higkeit, mit Medien zu arbeiten, reicht jedoch nicht aus.  Immerhin haben die Vertragsparteien noch nichts √ºber den Zustand des Netzes gesagt. <br><br>  Sie k√∂nnen sofort herausfinden, welche Video-Codecs der Browser unterst√ºtzt und ob sich auf dem Laptop eine Kamera befindet.  Es braucht Zeit, um Ihre externe IP-Adresse und die Logik des NAT-Betriebs herauszufinden, und Informationen √ºber den Netzwerkstatus werden ausgetauscht, wenn diese Informationen empfangen werden. <br><br>  Dank der Trickle ICE-Technologie (nicht von allen Browsern unterst√ºtzt - Anmerkung des √úbersetzers) kann die Verbindung zwischen zwei WebRTC-Ger√§ten jederzeit hergestellt werden - sobald ein geeigneter ‚ÄûKandidat‚Äú gefunden wurde. <br><br>  Der Entwickler muss das Ereignis <b>onicecandidate</b> abonnieren (alles in Kleinbuchstaben!) Und die empfangenen SDP-Pakete an die andere Seite weiterleiten, wo sie von WebRTC mithilfe der <b>addIceCandidate-</b> Methode (und hier √úberraschung, Gro√übuchstabe) √ºbertragen werden m√ºssen.  Es funktioniert in beide Richtungen. <br><br><h2>  Verbindung </h2><br>  WebRTC verwendet Dinge wie STUN (Session Traversal Utilities f√ºr NAT) und TURN (Traversal Using Relay um NAT), um eine Verbindung herzustellen.  Es klingt be√§ngstigend, aber in Wirklichkeit gibt es nur zwei Netzwerkprotokolle. <br><br><h4>  STUN Server </h4><br>  Das erste der beiden Protokolle ist etwas komplizierter als der Echoserver.  Wenn Verbindungsteilnehmer beschreiben m√∂chten, wie sie eine Verbindung zu ihnen herstellen sollen, ben√∂tigen sie ihre √∂ffentliche IP-Adresse.  Und h√∂chstwahrscheinlich ist dies nicht die IP-Adresse des Computers. √ñffentliche Ger√§te werden Benutzerger√§ten selten zugewiesen.  Die gesamte NAT-Technologie wurde erfunden, um nicht zu isolieren.  Um Ihre √∂ffentliche Adresse weiterhin herauszufinden, sendet der Browser eine Anfrage an den STUN-Server.  Beim Durchlaufen von NAT √§ndert das Netzwerkpaket seine R√ºcksprungadresse in public.  Nachdem der STUN-Server das Paket mit der Anforderung empfangen hat, kopiert er die R√ºcksprungadresse des Pakets in seine Nutzdaten und sendet das Paket zur√ºck.  Beim Durchlaufen von NAT in die entgegengesetzte Richtung verliert das Paket seine √∂ffentliche IP-Adresse, aber eine Kopie dieser Adresse verbleibt in der Nutzlast, wo WebRTC sie lesen kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  TURN-Server </h2><br>  Der TURN-Server verwendet die STUN-Protokollerweiterung.  Dieselben Pakete, Header und eine neue Sache: <b>Befehl</b> .  Der Server ist ein Proxy: Beide Clients stellen √ºber den UDP- <b>Zuweisungsport</b> eine Verbindung zu ihm her und √ºbertragen ihre Daten √ºber den Server. <br><br>  TURN-Server sind so konzipiert, dass der Initiator der Verbindung √ºber mehr Funktionen verf√ºgt als die andere Seite.  Dies f√ºhrt zu einem interessanten Effekt, wenn ein Anruf √ºber einen TURN-Server erfolgreich oder nicht erfolgreich ist, je nachdem, wer wen anruft (denken Sie an alle Skype - Notiz√ºbersetzer). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Debuggen </h2><br>  Sie lesen also bis zu diesem Absatz.  Wir sind mit dem √úbersetzer zufrieden und denken daran, dass es in dem Artikel um das Debuggen von WebRTC geht.  Aber all das ist ein notwendiges Minimum, ohne das man nicht einmal anfangen kann.  Aber wenn Sie anfangen und kein unmenschliches Gl√ºck haben, wird es brechen. <br><br>  Es wird auf viele verschiedene Arten brechen.  Der erste ist der Mangel an Konnektivit√§t.  Sie haben sowohl die STUN- als auch die TURN-Servereinstellungen an beide WebRTCs √ºbergeben und ihnen dabei geholfen, Angebote, Antworten und ICE-Kandidaten auszutauschen, aber es gibt weder Video noch Sprache.  Wo soll ich anfangen?  Bei lokalen Wiedergabeproblemen. <br><br><h2>  Lokales WebRTC-Debugging </h2><br>  Wie ich oben geschrieben habe, erfolgt die Hauptarbeit von WebRTC auf der Browserseite.  STUN- und TURN-Server sind unglaublich einfach, sodass die meisten Probleme in Ihrem JavaScript-Code auftreten, der in zwei Browsern ausgef√ºhrt wird.  Traurig aber wahr.  Auf der anderen Seite, wenn das Interessanteste lokal in Browsern passiert, haben Sie reichlich Gelegenheit zum Debuggen! <br><br>  Das erste, was Sie √ºberpr√ºfen m√ºssen, ist Ihre Signalisierung.  Es ist Ihr Code, der die Konfiguration von Audio mit Video (Angebot, Antwort) und Informationen zu Netzwerkeinstellungen (Eiskandidaten) zwischen Browsern √ºbertr√§gt.  Sie m√ºssen √ºberpr√ºfen, welche Pakete gesendet, welche WebRTC empfangen und gesendet wurden: <br><br><ul><li>  hat die andere Seite der Verbindung ein Angebot erhalten?  Hat der Verbindungsinitiator eine Antwort erhalten?  Ohne diesen minimalen Austausch von Annehmlichkeiten wird keine Verbindung hergestellt. </li><li>  Hat WebRTC an beiden Enden der Verbindung Pakete mit ICE-Kandidaten weitergeleitet?  Haben Sie diese Pakete ausgetauscht und mit <b>addIceCandidate</b> an die andere Seite <b>zur√ºckgegeben</b> ? </li><li>  Wenn beim Paketaustausch alles gut lief, wurde der <b>onaddstream-</b> Ereignishandler <b>aufgerufen</b> und haben Sie das resultierende Objekt in einem HTML-Element installiert, um Video (oder Audio) abzuspielen? </li></ul><br>  Wenn der Paketaustausch nicht verd√§chtig ist, k√∂nnen Sie sich mit den Eingeweiden der Sitzung befassen. <br><br><h2>  Sitzungsbeschreibungsprotokoll </h2><br>  Angebots-, Antwort- und ICE-Kandidatenpakete werden von WebRTC im SDP-Textformat erstellt.  Auf den ersten Blick sieht der Inhalt der Pakete be√§ngstigend aus, aber mit ein wenig Vorbereitung k√∂nnen Sie beim Debuggen viel davon profitieren.  Wikipedia beschreibt SDP ziemlich gut, aber ich habe eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bessere Beschreibung</a> f√ºr Sie gefunden. <br><br>  Das wichtigste Feld in Kandidaten-ICE-SDP-Paketen ist <b>typ</b> .  F√ºr WebRTC kann ein Feld einen von drei Werten haben: <br><br><ul><li>  typ host; </li><li>  typ srflx; </li><li>  Typ Relais. </li></ul><br><h4>  Typ Host </h4><br>  Der <b>Hosttyp</b> gibt den ICE-Kandidaten f√ºr eine lokale Verbindung an (WebRTC z√§hlt mehrere Kandidaten auf, in der Hoffnung, eine Verbindung herzustellen, es ist nicht im Voraus bekannt, welche sich herausstellen wird - vom √úbersetzer notiert).  F√ºr eine solche Verbindung ist weder ein STUN- noch ein TURN-Server erforderlich, da Ger√§te im lokalen Netzwerk h√§ufig Netzwerkverbindungen direkt herstellen k√∂nnen.  Beim Debuggen aus dem lokalen Netzwerk m√ºssen Sie nur die √úbertragung von <b>Host-</b> Paketen √ºberpr√ºfen und debuggen und sicherstellen, dass die Ger√§te UDP-Pakete untereinander senden k√∂nnen.  Obwohl es Ausnahmen gibt, habe ich in der Praxis Netzwerkkonfigurationen gesehen, bei denen der Browser einen TURN-Server ben√∂tigte, um eine Verbindung zu sich selbst herzustellen. <br><br><h4>  typ srflx </h4><br>  Die Buchstabenkombination ‚Äûsrflx‚Äú steht f√ºr ‚ÄûServer Reflexive‚Äú und markiert die Verbindungskandidaten mit einer externen IP-Adresse, wobei ein STUN-Server f√ºr die Verbindung ausreicht (mithilfe der NAT-Penetrationstechnologie, die in etwa 80% der F√§lle erfolgreich ist, beachten Sie den √úbersetzer). <br><br><h4>  Typ Relais </h4><br>  "Relay" markiert die Verbindung √ºber einen TURN-Server, was fast immer erfolgreich ist.  Es ist wichtig zu beachten, dass WebRTC nicht genau drei verschiedene Pakete mit dem Feld "typ" erstellen muss.  Wie Kandidaten ausgew√§hlt werden, h√§ngt von der Implementierung von WebRTC in einer bestimmten Browserversion ab. <br><br><h2>  Testen der Ger√§tekonnektivit√§t </h2><br>  Google bietet eine spezielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webanwendung</a> zum Testen von WebRTC-Verbindungen auf Ihrem Ger√§t.  √ñffnen Sie die Seite, klicken Sie auf die Schaltfl√§che "Start". Der JavaScript-Code versucht, mithilfe der Signalisierung, der STUN- und TURN-Server von Google eine Verbindung zum Google-Server herzustellen. <br><br><h2>  WebRTC-Interna </h2><br>  Sie haben alle Pakete untersucht, den Code √ºberpr√ºft, alles sieht richtig aus, aber es funktioniert nicht?  F√ºr solche F√§lle hat Google seinem Chrome-Browser einen speziellen Abschnitt zur Verf√ºgung gestellt, in dem die Interna von WebRTC w√§hrend des Verbindungsaufbaus und einige sch√∂ne Grafiken f√ºr den Fall einer erfolgreichen Verbindung angezeigt werden.  √ñffnen Sie zur Verwendung einen speziellen technischen Link im Browser: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Wenn Sie bereits eine Anwendung mit WebRTC ge√∂ffnet haben, werden sofort eine Reihe technischer Daten angezeigt.  Andernfalls √∂ffnen Sie einfach eine andere Registerkarte und es gibt etwas, das WebRTC verwendet.  Auf der Registerkarte werden alle Aufrufe des <b>RTCPeerConnection-</b> Objekts <b>angezeigt</b> , und Sie k√∂nnen in Echtzeit sehen, wie die Verbindung hergestellt wird. <br><br><h2>  ICE-Setup </h2><br>  Am oberen Rand der Seite befindet sich die ICE-Zeichenfolge, mit der die Verbindung initialisiert wurde.  Wenn w√§hrend seiner Entstehung ein Fehler gemacht wurde, ist dieser sofort sichtbar (durch die "ICE-Linie" verweist der Autor auf die Konfiguration des RTCPeerConnection-Objekts mit einer Liste von STUN- und TURN-Servern (das 'iceServers'-Objekt) - Hinweis des √úbersetzers).  Vielleicht gibt es keine Liste von Servern?  Sie m√ºssen das RTCPeerConnection-Objekt konfigurieren, bevor Sie den ersten Aufruf von <b>createOffer</b> oder <b>createAnswer ausf√ºhren</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  RTCPeerConnection-Ereignisse </h2><br>  Der n√§chste interne Abschnitt zeigt die Aufrufe der <b>RTCPeerConnection-</b> Methoden und die vom Objekt empfangenen Ereignisse in chronologischer Reihenfolge.  Fehler werden sorgf√§ltig rot hervorgehoben.  Bitte beachten Sie, dass das rote <b>addIceCandidateFailed</b> h√§ufig kein Anzeichen f√ºr einen Fehler ist und die Verbindung m√∂glicherweise normal hergestellt wird.  Wenn die Verbindung erfolgreich ist, ist das letzte Ereignis in der Liste ein <b>iceconnectionstatechange-</b> Ereignis mit dem Wert <b>complete</b> . <br><br><h2>  Abschnitt 'Statistiken' </h2><br>  Der n√§chste Abschnitt ist relevant, wenn die Verbindung erfolgreich hergestellt wurde.  Es enth√§lt Statistiken √ºber √ºbertragene Daten und Netzwerkverz√∂gerungen.  Die zwei interessantesten Optionen sind: <b>ssrc</b> und <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", markiert jede Ihrer Audio- und Videospuren.  Zeigt Statistiken der √ºbertragenen Daten und Parameter an, z. B. die <b>Umlaufzeit</b> . </li><li>  <b>bweforvideo</b> , BandWidth Estimation, zeigt die Breite des verwendeten Netzwerkkanals an. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  GetStats-Funktion </h2><br>  Oft k√∂nnen Sie nicht auf die Interna-Seite zugreifen.  Zum Beispiel, wenn ein Problem mit Ihrem Benutzer auftritt.  In diesem Fall k√∂nnen Sie dieselben Daten <b>abrufen</b> , die auf der internen Seite <b>angezeigt</b> werden, indem Sie die Methode <b>getStats</b> f√ºr das <b>RTCPeerConnection-</b> Objekt <b>aufrufen</b> .  Diese Methode richtet eine R√ºckruffunktion ein, die WebRTC jedes Mal aufruft, wenn etwas Interessantes passiert.  Die aufgerufene Funktion erh√§lt ein Objekt mit den Feldern, die auf der Interna-Seite angezeigt werden: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Ein weiteres n√ºtzliches Tool ist das Ereignis <b>oniceconnectionstatechange</b> eines <b>RTCPeerConnection-</b> Objekts.  Der Ereignishandler erh√§lt Informationen zum Verbindungsfortschritt.  M√∂gliche Optionen: <br><br><ul><li>  <b>neu</b> : WebRTC erwartet Kandidaten von der zweiten Seite der Verbindung, die mit der <b>addIceCandidate-</b> Methode hinzugef√ºgt werden <b>m√ºssen</b> . </li><li>  <b>√úberpr√ºfung</b> : WebRTC hat Kandidaten von der zweiten Seite der Verbindung empfangen, vergleicht sie mit lokalen und iteriert √ºber Optionen. </li><li>  <b>verbunden</b> : Ein geeignetes Kandidatenpaar wird ausgew√§hlt und die Verbindung hergestellt.  Es ist bemerkenswert, dass die Kandidaten danach gem√§√ü dem Trickle ICE-Protokoll weiter kommen k√∂nnen. </li><li>  <b>abgeschlossen</b> : Alle Kandidaten werden empfangen und die Verbindung hergestellt. </li><li>  <b>getrennt</b> : Die Verbindung wird <b>getrennt</b> .  Auf instabilen Kan√§len kann sich WebRTC wieder verbinden. Wir √ºberwachen das <b>verbundene</b> Flag. </li><li>  <b>geschlossen</b> : Die Verbindung wird getrennt und WebRTC funktioniert nicht mehr damit. </li></ul><br>  Wenn die Verbindung im <b>fehlgeschlagenen</b> Zustand beendet wurde, k√∂nnen wir die auf beiden Seiten empfangenen Kandidaten untersuchen und verstehen, warum die Verbindung fehlgeschlagen ist.  Wenn beispielsweise eine Seite <b>Host-</b> und <b>srflx-Kandidaten bereitstellte</b> , die andere Seite <b>Host</b> und <b>Relay</b> , die Ger√§te sich jedoch in unterschiedlichen Netzwerken befanden. <br><br><h2>  Schwarzes Rechteck statt Video </h2><br>  Oft gibt es eine Situation, in der die Verbindung hergestellt wird, der Ton √ºbertragen wird, aber anstelle des Videos hat einer oder beide Teilnehmer ein schwarzes Rechteck.  Meistens geschieht dies, wenn Sie das empfangene Videoobjekt einem HTML-Element zuweisen, bevor die Verbindung in den <b>abgeschlossenen</b> Zustand √ºbergeht. <br><br><h2>  Wie man einen Zauberstab nach drau√üen steckt </h2><br>  Zus√§tzlich zum <b>RTCPeerConnection-</b> Objekt <b>selbst</b> und den vom Browser angezeigten Interna k√∂nnen Sie Tools zur Analyse von Netzwerkpaketen wie Wireshark verwenden.  Diese Tools k√∂nnen Pakete verwendeter WebRTC-Protokolle anzeigen.  Wireshark zeigt Ihnen beispielsweise den Inhalt von STUN-Paketen im Hauptfenster an, und Sie k√∂nnen sie filtern, indem Sie das Schl√ºsselwort "stun" in das Filterfeld eingeben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  Was ist in Serverantworten zu beachten?  Wenn Sie nur Antworten mit dem <b>Bindungstyp sehen</b> , bedeutet dies, dass nur STUN (externes IP-Gespr√§ch) unterst√ºtzt wird und WebRTC nur <b>srflx-</b> Kandidaten anbieten <b>kann</b> .  Wenn die Antworten TURN-spezifische Pakete <b>Allocation</b> und <b>CreatePermission enthalten</b> , hat WebRTC die M√∂glichkeit, eine Verbindung √ºber einen Proxyserver herzustellen.  Der Paketanalysator markiert die erfolgreiche und nicht erfolgreiche <b>Zuordnung</b> .  Wenn es keinen gibt, der erfolgreich ist, werden h√∂chstwahrscheinlich die falschen Zugriffsparameter auf die TURN-Server (die fast immer mit einem Benutzernamen und einem Kennwort sch√ºtzen - die Anmerkung des √úbersetzers) √ºbergeben. <br><br>  Wenn das Protokoll ein <b>CreatePermission Success Response-</b> Paket enth√§lt, k√∂nnen wir davon ausgehen, dass mit den Konfigurationen STUN und TURN alles in Ordnung ist.  Und wenn es auch ein <b>ChannelBind-</b> Paket gibt, konnte mit hoher Geschwindigkeit eine Verbindung zum TURN-Server hergestellt werden. <br><br><h2>  Zellul√§re Probleme </h2><br>  In meiner Praxis k√∂nnen viele WebRTC-L√∂sungen, die eine WiFi-Verbindung herstellen, keine Verbindung √ºber 3G / 4G herstellen.  Eine auf einem mobilen Ger√§t gestartete Anwendung ist schwieriger zu debuggen: Wir haben keinen so einfachen Paketanalysator wie Wireshark, und Safari kann keine WebRTC-Interna anzeigen.  Die Logik legt nahe, dass das Problem nicht in der Anwendung selbst liegt, sondern in der Mobilfunkkommunikation, wenn die Anwendung √ºber WLAN einwandfrei funktioniert.  Wie debuggen?  Nehmen Sie einen Laptop und schlie√üen Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3G-Dongle</a> an.  Sie haben also einen Paketanalysator und praktische Protokolle, mit denen Sie die Wurzel aller Probleme in angemessener Zeit finden k√∂nnen. <br><br><h2>  Schlussfolgerungen </h2><br>  Das Debuggen von WebRTC ist nicht einfach, aber wenn Sie im Internet gut suchen, finden Sie viele Artikel und Beispiele.  Wenn Sie im Bereich der Echtzeitkommunikation arbeiten, empfehle ich Ihnen, die RFC-Spezifikationen f√ºr die Protokolle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TURN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebRTC zu</a> lesen.  Die Dokumente sind gro√ü, aber die darin enthaltenen Informationen helfen, verl√§ssliche Entscheidungen zu treffen und die Frage zu beantworten, warum es nicht klingelt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417869/">https://habr.com/ru/post/de417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417859/index.html">3CX-Integration mit Microsoft Dynamics 365</a></li>
<li><a href="../de417861/index.html">Endloses Primmuster</a></li>
<li><a href="../de417863/index.html">Kinder bald bestellen? Der UK Ethics Council genehmigt die Gentechnik menschlicher Embryonen</a></li>
<li><a href="../de417865/index.html">Android-Barrierefreiheit - ein Wolf im Schafspelz? Yandex Vortrag</a></li>
<li><a href="../de417867/index.html">Wie man die Dauer eines IT-Projekts bewertet und wann es sich √ºberhaupt nicht lohnt</a></li>
<li><a href="../de417871/index.html">An der Ziellinie des suborbitalen Tourismus</a></li>
<li><a href="../de417873/index.html">M√∂glichkeiten zum Erstellen von PopUp-Fenstern</a></li>
<li><a href="../de417875/index.html">Raus aus dem Kaninchenbau SPA mit modernen Schienen</a></li>
<li><a href="../de417877/index.html">Wie Tinder (leicht) Ihren Standort verbirgt</a></li>
<li><a href="../de417879/index.html">Kostenlose Pr√ºfung von Microsoft [zum Beispiel ein k√ºrzlich durchgef√ºhrter Wettbewerb]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>