<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏾 🌧️ 🍿 Rust上的操作系统。 页面内存：高级 👵 🕵️ 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文介绍了操作系统的内核如何访问物理内存帧。 我们将研究将虚拟地址转换为物理地址的功能。 我们还将弄清楚如何在页表中创建新的映射。 

 该博客发布在GitHub上 。 如果您有任何疑问或问题，请在此处打开相应的票证。 本文的所有资料都在这里 。 

 引言 
 从上一篇文章中，我们了解了分页内存的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust上的操作系统。 页面内存：高级</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/"> 本文介绍了操作系统的内核如何访问物理内存帧。 我们将研究将虚拟地址转换为物理地址的功能。 我们还将弄清楚如何在页表中创建新的映射。 <br><br> 该博客发布在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a> 。 如果您有任何疑问或问题，请在此处打开相应的票证。 本文的所有资料都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br><br><h1> 引言 </h1><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中，</a>我们了解了分页内存的原理以及x86_64上的四级页表如何工作。 我们还发现加载器已经为内核设置了页表层次结构，因此内核在虚拟地址上运行。 这样可以提高安全性，但是会出现问题：如何访问存储在页表项或<code>CR3</code>实际物理地址？ <br><a name="habracut"></a><br> 在本文的第一部分中，我们将讨论该问题以及解决该问题的不同方法。 然后，我们实现了一个功能，它可以潜入页表的层次结构，将虚拟地址转换为物理地址。 最后，学习如何在页表中创建新的映射并查找未使用的内存框架以创建新表。 <br><br><h2> 依赖关系更新 </h2><br> 要工作，您需要<code>x86_64</code> 0.4.0或更高版本。 更新我们的<code>Cargo.toml</code>的依赖<code>Cargo.toml</code> ： <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1> 访问页表 </h1><br> 从内核访问页表并不像看起来那样容易。 要了解此问题，请再看看上一篇文章中的四级表层次结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br> 重要的是每个页面条目都存储下一张表的<i>物理</i>地址。 这避免了这些地址的转换，从而降低了性能并容易导致无限循环。 <br><br> 问题是我们不能直接从内核访问物理地址，因为它也可以在虚拟地址上工作。 例如，当我们访问地址<code>4 KiB</code> ，我们可以访问<i>虚拟</i>地址<code>4 KiB</code> ，而不能访问存储第四级页面表的<i>物理</i>地址。 如果我们要访问<code>4 KiB</code>的物理地址，则需要使用一些虚拟地址，将其转换为虚拟地址。 <br><br> 因此，要访问页表的框架，您需要将一些虚拟页面映射到这些框架。 有多种创建此类映射的方法。 <br><br> 一种简单的解决方案是<b>所有页表的显示相同</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br> 在此示例中，我们看到相同的帧显示。 页表的物理地址同时是有效的虚拟地址，因此我们可以轻松地从寄存器CR3开始访问所有级别的页表。 <br><br> 但是，这种方法会使虚拟地址空间变得混乱，并使得很难找到较大的连续区域的空闲内存。 假设我们要在上图中创建一个1000 KiB虚拟内存区域，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在memory中显示一个文件</a> 。 我们不能从<code>28  KiB</code>区域开始，因为它位于已经占用的页面<code>1004  KiB</code> 。 因此，您将不得不进一步寻找，直到找到合适的大片段，例如<code>1008  KiB</code> 。 存在与分段存储器相同的碎片问题。 <br><br> 另外，新页表的创建要复杂得多，因为我们需要找到尚未使用相应页的物理框架。 例如，对于我们的文件，我们保留了1000 KiB的<i>虚拟</i>内存区域，从地址<code>1008  KiB</code> 。 现在，我们不能再使用物理地址在<code>1000  KiB</code>和<code>2008  KiB</code>之间的任何帧，因为它不能显示相同。 <br><br>  2.另一个选择是<b>仅</b>在需要访问<b>页表时临时广播</b>它们。 对于临时比较，只需要第一级表的相同显示即可： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br> 在此图中，级别1表管理虚拟地址空间的前2个MiB。 这是可能的，因为来自CR3寄存器的访问是通过级别4、3和2的表中的零条目进行的。具有索引<b>8</b>的记录将<code>32 KiB</code>处的虚拟页转换为<code>32 KiB</code>的物理帧，从而标识了1级表本身。在图中用水平箭头表示。 <br><br> 通过写入相同映射的1级表，我们的内核最多可以创建511次时间比较（512减去身份映射所需的记录）。 在上面的示例中，内核将1级表的空记录与<code>24 KiB</code>处的帧进行了匹配。 这将虚拟页面从<code>0 KiB</code>临时映射到页面2级别表的物理帧，由虚线箭头指示。 现在，内核可以通过写入从<code>0 KiB</code>开始的页面来访问2级表。 <br><br> 因此，使用临时映射访问页表的任意框架包括以下操作： <br><br><ul><li> 在相同显示的1级表中找到一个免费条目。 <br></li><li> 将此条目映射到我们要访问的页表的物理框架。 <br></li><li> 通过与条目关联的虚拟页面访问此框架。 <br></li><li> 将记录重新设置为未使用，从而删除临时映射。 </li></ul><br> 使用这种方法，虚拟地址空间保持干净，因为经常使用相同的512个虚拟页面。 缺点是麻烦，特别是因为新的比较可能需要更改表的多个级别，也就是说，我们需要重复上述过程几次。 <br><br>  3.尽管以上两种方法都有效，但是还有第三种方法： <b>递归页表</b> 。 它结合了这两种方法的优点：它不断地比较页表的所有帧，而无需临时比较，并且并排保持相邻页，避免虚拟地址空间的碎片化。 这就是我们将要使用的方法。 <br><br><h2> 递归页表 </h2><br> 这个想法是将一些记录从第四级表转换成它本身。 因此，我们实际上保留了虚拟地址空间的一部分，并将所有当前和将来的表框架映射到该空间。 <br><br> 让我们看一个例子，以了解这一切如何工作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br> 与本文开头的示例唯一的不同是，在第4级表中具有索引<code>511</code>的附加记录被映射到位于该表本身中的物理帧<code>4 KiB</code> 。 <br><br> 当CPU继续执行该记录时，它不会引用3级表，而是再次引用4级表，这类似于调用自身的递归函数。 重要的是，处理器必须假定4级表中的​​每个条目都指向3级表，所以现在将4级表视为3级表，因为x86_64中所有级别的表都具有相同的结构，所以这种方法有效。 <br><br> 通过在开始实际转换之前跟踪一次或多次递归记录，我们可以有效地减少处理器经历的级别数。 例如，如果我们跟踪一次递归记录，然后转到3级表，则处理器认为3级表是2级表，接着，他将2级表视为1级表，并将1级表视为已映射物理内存中的帧。 这意味着我们现在可以读写页面1级表，因为处理器认为这是一个映射的帧。 下图显示了这种转换的五个步骤： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br> 同样，在开始转换之前，我们可以跟踪两次递归项以减少传递给两个级别的数量： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br> 让我们逐步完成此过程。 首先，CPU跟踪4级表中的​​递归条目，并认为它已到达3级表，然后再次跟踪递归记录，并认为它已达到2级。但实际上，它仍处于4级，然后CPU转到了新地址。并进入第3级表，但认为它已经在第1级表中。最后，在第2级表的下一个入口点，处理器认为它已经访问了物理内存帧。 这使我们可以读写2级表。 <br><br> 还访问了3级和4级表。要访问3级表，我们遵循三遍递归记录：处理器认为它已经在1级表中，并且在下一步中我们达到3级，CPU将其视为映射帧。 要访问4级表本身，我们只需遵循递归记录四次，直到处理器将4级表本身作为映射帧处理（下图中的蓝色）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br> 起初很难理解这个概念，但实际上它运作良好。 <br><br><h4> 地址计算 </h4><br> 因此，我们可以通过遵循一次或多次递归记录来访问所有级别的表。 由于四级表中的索引是直接从虚拟地址派生的，因此必须为此方法创建特殊的虚拟地址。 我们记得，页表索引是从地址中提取的，如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br> 假设我们要访问显示特定页面的1级表。 如上所述，您需要遍历一次递归记录，然后遍历第四，第三和第二级的索引。 为此，我们将所有地址块向右移动一个块，并将递归记录的索引设置为4级初始索引的位置： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br> 要访问此页面的2级表，我们将所有索引块向右移动两个块，并将递归索引设置为两个源块的位置：4级和3级： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br> 要访问3级表，我们进行了相同的操作，我们只需要向右移动三个地址块即可。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br> 最后，要访问4级表，请将所有内容向右移动四个块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br> 现在，您可以计算所有四个级别的页表的虚拟地址。 我们甚至可以通过将其索引乘以8（即页表项的大小）来计算精确指向特定页表项的地址。 <br><br> 下表显示了用于访问各种类型帧的地址的结构： <br><br><table><thead><tr><th> 的虚拟地址 </th><th> 地址结构（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八进制</a> ） </th></tr></thead><tbody><tr><td> 页数 </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td> 进入1级表 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td> 在2级表中输入 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td> 在3级表中输入 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td> 进入第4级表格 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br> 在这里， <code></code>是4级索引， <code></code>是3级， <code></code>是2级， <code>DDD</code>是所显示帧的1级索引， <code>EEEE</code>是其偏移量。  <code>RRR</code>是递归记录的索引。 索引（三位数）通过乘以8（页表项的大小）而转换为偏移量（四位数）。 使用此偏移量，结果地址直接指向相应的页表条目。 <br><br>  <code>SSSS</code>是带符号数字的扩展位，也就是说，它们都是第47位的副本。这是对x86_64体系结构中有效地址的特殊要求，我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章中</a>已对此进行了讨论。 <br><br> 地址是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">八进制的</a> ，因为每个八进制字符代表三位，这使您可以清楚地区分不同级别的表的9位索引。 在每个字符代表四个位的十六进制系统中，这是不可能的。 <br><br><h2> 实作 </h2><br> 经过所有这些理论，我们终于可以继续执行了。 方便的是，加载器不仅生成页面表，还生成了4级表的最后一条记录中的递归显示，之所以这样做，是因为否则会出现鸡或蛋的问题：我们需要访问4级表以创建递归映射但是我们无法在没有任何显示的情况下访问它。 <br><br> 在上一篇文章的结尾，我们已经使用了此递归映射来通过硬编码地址<code>0xffff_ffff_ffff_f000</code>访问4级表。 如果将这个地址转换为八进制并与上表进行比较，我们将看到它与4级表中的​​记录结构完全对应，其中<code>RRR</code> = <code>0o777</code> ， <code>AAAA</code> = <code>0</code>和符号<code>1</code>的扩展位： <br><br><pre> 结构：0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
地址：0o_177777_777_777_777_777_0000 </pre><br> 多亏了递归表的知识，我们现在可以创建虚拟地址来访问所有活动表。 并具有播放功能。 <br><br><h3> 地址翻译 </h3><br> 第一步，创建一个函数，该函数将虚拟地址转换为物理地址，并通过页表的层次结构进行传递： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br> 首先，我们为递归索引（511 = <code>0o777</code> ）和符号扩展位（每个为1）引入变量。 然后，我们通过按位运算来计算页表的索引和偏移量，如图所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br> 下一步是计算四个页表的虚拟地址，如上一节所述。 接下来，在函数中，我们将每个地址转换为<code>PageTable</code>链接。 这些是不安全的操作，因为编译器无法知道这些地址是否有效。 <br><br> 计算完地址后，我们使用索引运算符查看4级表中的​​记录，如果该记录为零，则该4级记录没有3级表，这意味着<code>addr</code>没有映射到任何物理内存。 因此，我们返回<code>None</code> 。 否则，我们知道存在3级表。 然后，像上一级一样，重复该过程。 <br><br> 在检查了更高级别的三页之后，我们最终可以读取级别1表的记录，该记录告诉我们地址所映射的物理帧。 最后一步，添加页面偏移量-并返回地址。 <br><br> 如果我们确定知道地址已映射，则可以直接访问1级表，而无需查看更高级别的页面。 但是由于我们不知道这一点，因此我们首先需要检查是否存在1级表，否则我们的函数将为不匹配的地址返回缺少页面的错误。 <br><br><h4> 试一下 </h4><br> 让我们尝试在<code>_start</code>函数中为虚拟地址使用转换函数： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br> 启动后，我们看到以下结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br> 如预期的那样，与标识符关联的地址0xb8000转换为相同的物理地址。 代码页和堆栈页被转换为任意的物理地址，这取决于加载程序如何为内核创建初始映射。 <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>RecursivePageTable</code></a>类型，该类型为各种页面表操作实现安全抽象。 使用这种类型，您可以更简洁地实现<code>translate_addr</code>函数： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  <code>RecursivePageTable</code>类型完全封装了不安全的页表爬网，因此不再需要<code>translate_addr</code>函数中的<code>unsafe</code>代码。 由于需要保证传递的<code>level_4_table_addr</code>的正确性，因此<code>init</code>函数仍然不安全。 <br><br> 必须更新我们的<code>_start</code>函数以重新签名该函数，如下所示： <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br> 现在，我们将引用传递给<code>RecursivePageTable</code>类型，而不是将<code>LEVEL_4_TABLE_ADDR</code>传递给<code>translate_addr</code>并通过不安全的原始指针访问页表。 因此，我们现在有了一个安全的抽象和明确的所有权语义。 这确保了我们不会在共享访问中意外更改页表，因为要更改它，我们需要排他地拥有<code>RecursivePageTable</code> 。 <br><br> 此功能提供的结果与手动编写的原始翻译功能相同。 <br><br><h4> 使不安全的功能更安全 </h4><br> <code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个不安全的函数：它需要一个块来调用它</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为调用者必须保证满足某些要求。在我们的情况下，要求将发送的地址精确地映射到第4级页表的物理帧</font><font style="vertical-align: inherit;">，将不安全功能</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个主体放置</font><font style="vertical-align: inherit;">在该块中，</font><font style="vertical-align: inherit;">以便执行各种操作而无需创建其他块</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。因此，我们不需要不安全的块来取消引用</font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题在于我们无法立即看到哪些零件不安全。</font><font style="vertical-align: inherit;">例如，如果不查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">定义，</font></a></font><code>RecursivePageTable::new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就无法说出它是否安全。</font><font style="vertical-align: inherit;">因此，很容易意外跳过一些不安全的代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为避免此问题，可以添加安全的内置函数：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，</font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次需要使用</font><font style="vertical-align: inherit;">该块</font><font style="vertical-align: inherit;">进行取消引用</font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且我们立即看到这些是唯一不安全的操作。</font><font style="vertical-align: inherit;">Rust目前开放</font><font style="vertical-align: inherit;">了</font><font style="vertical-align: inherit;">一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以更改这种不安全功能的不成功属性。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个新的映射 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们读取页表并创建转换函数时，下一步是在页表层次结构中创建新的映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此操作的复杂性取决于我们要显示的虚拟页面。在最简单的情况下，此页面已经存在一个1级页面的表格，我们只需要输入一个即可。在最困难的情况下，该页面位于尚不存在3级的内存区域中，因此首先您需要创建3级，2级和1级的新表。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从一个不需要创建新表的简单案例开始。加载程序被加载到虚拟地址空间的第一个兆字节中，因此我们知道该区域有一个有效的1级表，例如，我们可以选择该存储区中任何未使用的页面，例如address处的页面</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将VGA文本缓冲区</font><font style="vertical-align: inherit;">的帧用作所需的帧</font><font style="vertical-align: inherit;">。检查我们的地址翻译的工作原理非常简单。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在模块</font><font style="vertical-align: inherit;">的新功能</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">实现它</font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数接受对</font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（和将对其进行更改）和</font><font style="vertical-align: inherit;">的可变引用，</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面对此进行了说明。然后，它应用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">托盘中</font><font style="vertical-align: inherit;">的功能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将页面映射到该地址</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并将物理框架</font><font style="vertical-align: inherit;">映射到</font><font style="vertical-align: inherit;">该地址</font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该函数不安全，因为使用无效参数可能会破坏内存安全性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了参数</font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两个更多的参数。第三个参数是页表的标志集。我们</font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为所有有效条目</font><font style="vertical-align: inherit;">设置了</font><font style="vertical-align: inherit;">必要的标志</font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">并</font><font style="vertical-align: inherit;">为可写性</font><font style="vertical-align: inherit;">设置了标志</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第四个参数应该是实现该特征的某种结构</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该方法需要此参数。</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因为创建新的页表可能需要未使用的框架。实现需要的参数特征</font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如类型</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PhysFrame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普遍</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的特点</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PageSize</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，标准的4个KiB页面和具有巨大页2 MIB / 1吉布工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能会失败，因此返回</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。由于这只是一个不可靠的代码示例，因此</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在发生错误时</font><font style="vertical-align: inherit;">，我们只需使用</font><font style="vertical-align: inherit;">panic </font><font style="vertical-align: inherit;">即可</font><font style="vertical-align: inherit;">。如果成功，函数将返回一种类型</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该类型</font><font style="vertical-align: inherit;">提供了一种从关联翻译缓冲区（TLB）方法中清除最近匹配的页面的简便方法</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。喜欢</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该类型会使用该属性</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>#[must_use]</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果我们意外忘记应用</font><font style="vertical-align: inherit;">该属性</font><font style="vertical-align: inherit;">，则会发出警告。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们知道该地址</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要新的页表，因此它</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以始终返回</font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要测试功能，请创建以下代码</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（如果出现错误“方法</font></font><code>allocate_frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是特征的成员</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”，则需要升级</font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到版本0.4.0。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以测试新的翻译功能：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们在地址处为页面创建一个映射</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用指向实例的可变链接来</font><font style="vertical-align: inherit;">调用该函数</font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会将</font><font style="vertical-align: inherit;">页面</font><font style="vertical-align: inherit;">转换为VGA文本缓冲区，因此我们将在屏幕上看到一些结果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们在此页面中写入一个值，该值</font></font><code>0xf021f077f065f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对应于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ New！”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><i><font style="vertical-align: inherit;">。</font></i><font style="vertical-align: inherit;">在白色背景上。</font><font style="vertical-align: inherit;">只是不需要将此值立即写到页面顶部</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为顶行将从屏幕上移出</font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并以</font></font><code>0x900</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大约位于屏幕中间</font><font style="vertical-align: inherit;">的偏移量写入它</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ VGA文本模式”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一文中我们知道</font><font style="vertical-align: inherit;">，写入VGA缓冲区应该是易失的，因此我们使用该方法</font></font><code>write_volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当我们在QEMU中运行它时，我们看到以下内容： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕上的题字。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该代码有效，因为已经有一个1级表来显示该页面</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们尝试转换尚不存在此类表的页面，该函数</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回错误，因为它将尝试从中选择框架以创建新的页面表</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们尝试翻译页面</font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(…) { […] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启动时，会从以下错误消息开始恐慌： </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 惊慌于'map_to失败：FrameAllocationFailed'，/.../result.rs:999haps </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要显示尚无页面级别1表的页面，您需要创建正确的表</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，您如何知道哪些帧是空闲的以及多少物理内存可用？</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开机资讯 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的计算机具有不同的物理内存量，并且VGA等设备保留的不同区域也不同。只有BIOS或UEFI固件才能确切知道可以使用哪些存储区以及保留哪些存储区。两种固件标准都提供了获取内存分配卡的功能，但只能在下载开始时调用它们。因此，我们的引导加载程序已经从BIOS请求了此（和其他）信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了将信息传递给OS的内核，加载器在调用函数时作为参数</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了指向启动信息结构的链接。将此参数添加到我们的函数中：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该结构</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>BootInfo</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍在最终确定中，因此当升级到</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与semver不兼容的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来版本的bootloader时崩溃时，不要感到惊讶</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他目前拥有三个领域</font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含第4级页面的表的递归虚拟地址，因此，不必硬注册该地址</font></font><code>0o_177777_777_777_777_777_0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最受关注，因为它包含所有内存区域及其类型（未使用，保留或其他）的列表。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用于将其他数据与加载程序相关联的当前函数。</font><font style="vertical-align: inherit;">实现尚未完成，因此我们暂时可以忽略它。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在使用该字段</font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建正确</font><font style="vertical-align: inherit;">的字段之前</font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们要保证参数的类型正确</font></font><code>boot_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 巨集 </font></font><code>entry_point</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是从外部调用的，因此不检查功能的签名。</font><font style="vertical-align: inherit;">这意味着任意参数都不会导致编译错误，但可能导致崩溃或未定义的运行时行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了验证签名，</font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于将Rust函数定义为入口点</font><font style="vertical-align: inherit;">的板条箱</font><font style="vertical-align: inherit;">使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>entry_point</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有经过验证的类型</font><font style="vertical-align: inherit;">的宏</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们为此宏重写函数：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; […] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于入口点，您不再需要使用</font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为宏会设置真正的低层入口点</font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该函数</font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在已成为完全正常的Rust函数，因此我们可以为其选择任意名称。</font><font style="vertical-align: inherit;">重要的是它已经被键入，因此，如果您更改函数的签名（例如，通过添加参数或更改其类型），则会发生编译错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，现在我们正在发送到一个</font></font><code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">硬编码的地址，但是</font></font><code>boot_info.p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，即使将来的引导加载程序版本在页面级别4的表表中选择另一个条目进行递归显示，代码也将起作用。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 选框 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，由于有了BIOS中的信息，我们才可以访问内存分配卡，以便您可以制作普通的帧分配器。</font><font style="vertical-align: inherit;">让我们从通用骨架开始：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字段</font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由任意</font><font style="vertical-align: inherit;">帧</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这使您可以简单地将调用委派</font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生在一个新函数中</font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此函数使用组合器将原始内存分配图转换为使用的物理帧的迭代器： </font></font><br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> range</a> Rust          . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三步是最困难的：使用方法将每个范围转换为一个迭代器</font></font><code>into_iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后使用选择每个第4096个地址</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>step_by</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于页面大小为4096字节（4 KiB），因此我们获得了每个帧开始的地址。</font><font style="vertical-align: inherit;">加载程序页面会对齐所有已用的内存区域，因此我们不需要对齐或舍入代码。</font><font style="vertical-align: inherit;">更换</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>flat_map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们得到</font></font><code>Iterator&lt;Item = u64&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替</font></font><code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在最后阶段，我们将起始地址转换为类型</font></font><code>PhysFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以构建所需的</font><font style="vertical-align: inherit;">地址</font></font><code>Iterator&lt;Item = PhysFrame&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后使用此迭代器创建并返回一个新的迭代器</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以改变我们的功能</font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">广播它的实例</font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不是</font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在地址翻译成功了，我们再次在屏幕上看到黑白消息</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ New！”。</font></font></i>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在幕后，该方法</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建丢失的页表，如下所示：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从中提取未使用的帧</font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将顶级表条目与此框架匹配。</font><font style="vertical-align: inherit;">现在可以通过递归页表访问该框架。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将框架归零以创建一个新的空页表。 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转到下一级表。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们的功能</font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是一个示例，但是我们现在可以为任意页面创建新的映射。</font><font style="vertical-align: inherit;">在以后的文章中分配内存和实现多线程时，这非常有用。</font></font><br><br><h1> 总结 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，您学习了如何使用4级递归表将所有帧转换为可计算的虚拟地址。</font><font style="vertical-align: inherit;">我们使用此方法来实现地址转换功能并在页表中创建新的映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们看到，创建新映射需要新表的未使用框架。</font><font style="vertical-align: inherit;">可以根据引导加载程序传递给我们内核的BIOS中的信息来实现这种帧分配器。</font></font><br><br><h1> 接下来是什么 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一篇文章中，我们将为内核创建一个堆内存区域，这将使我们能够</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配内存</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用不同</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的集合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439066/">https://habr.com/ru/post/zh-CN439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439050/index.html">培训Cisco 200-125 CCNA v3.0。 思科认证网络专家（CCNA）。 第2天。OSI和TCP-IP模型</a></li>
<li><a href="../zh-CN439056/index.html">水泥品牌整合</a></li>
<li><a href="../zh-CN439060/index.html">7类客户</a></li>
<li><a href="../zh-CN439062/index.html">Anisoprint作曲家：高强度3D打印</a></li>
<li><a href="../zh-CN439064/index.html">典型的网格错误（Bootstrap网格），或者为什么设计者和布局设计者不互相理解</a></li>
<li><a href="../zh-CN439068/index.html">“爱你”垃圾邮件活动重定向到日本</a></li>
<li><a href="../zh-CN439070/index.html">中国将因其高效率而放弃反腐败人工智能系统零信任</a></li>
<li><a href="../zh-CN439072/index.html">智能家居开发商清单：15条原则</a></li>
<li><a href="../zh-CN439076/index.html">在哪些应用程序中等待未知的恶意代码？</a></li>
<li><a href="../zh-CN439078/index.html">彼尔姆程序员因创建恋童癖者通过其移动应用程序而被捕</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>