<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèæ üë®üèΩ‚Äçüåæ üçÄ C√≥mo usar archivos HDF5 en Python üë©üèø‚Äçüé§ üîç üåï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Se acerca el lanzamiento del curso "Desarrollador web en Python" , respectivamente, todav√≠a compartimos art√≠culos interesantes y nos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo usar archivos HDF5 en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/416309/"> Hola a todos! <br><br>  Se acerca el lanzamiento del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Desarrollador web en Python"</a> , respectivamente, todav√≠a compartimos art√≠culos interesantes y nos invitan a nuestras lecciones abiertas, donde puedes ver material interesante, conocer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">maestros</a> y hacerles preguntas. <br><br>  Vamos! <br><br>  <i>HDF5 permite el almacenamiento eficiente de grandes cantidades de datos</i> <br><br>  Cuando se trabaja con grandes vol√∫menes de datos, ya sean experimentales o simulados, almacenarlos en varios archivos de texto no es muy eficiente.  Algunas veces necesita acceder a un subconjunto espec√≠fico de datos y desea hacerlo r√°pidamente.  En estas situaciones, el formato HDF5 resuelve ambos problemas gracias a una biblioteca incorporada altamente optimizada.  HDF5 se usa ampliamente en entornos cient√≠ficos y tiene una excelente implementaci√≥n en Python dise√±ada para trabajar con NumPy desde el primer momento. <br><br>  El formato HDF5 admite archivos de cualquier tama√±o, y cada archivo tiene una estructura interna que le permite buscar un conjunto de datos espec√≠fico.  Esto puede considerarse como un archivo separado con su propia estructura jer√°rquica, as√≠ como un conjunto de carpetas y subcarpetas.  De manera predeterminada, los datos se almacenan en formato binario y la biblioteca es compatible con diferentes tipos de datos.  Una de las opciones m√°s importantes para el formato HDF5 es que le permite adjuntar metadatos a cada elemento de la estructura, por lo que es ideal para crear archivos sin conexi√≥n. <br><br><img src="https://habrastorage.org/webt/t9/ae/qu/t9aequcpmfwvbjckfxmnwcyevzo.png"><a name="habracut"></a><br>  En Python, se puede construir una interfaz con el formato HDF5 utilizando el paquete h5py.  Una de las caracter√≠sticas m√°s interesantes de este paquete es que los datos se leen de un archivo solo cuando es necesario.  Imagine que tiene una matriz muy grande que no cabe en su RAM disponible.  Por ejemplo, podr√≠a generar una matriz en una computadora con diferentes especificaciones, a diferencia de la que usa para el an√°lisis de datos.  El formato HDF5 le permite elegir qu√© elementos de la matriz leer con una sintaxis equivalente a NumPy.  Entonces puede trabajar con datos almacenados en el disco duro, y no en la RAM, sin cambios significativos en el c√≥digo existente. <br><br>  En este art√≠culo, veremos c√≥mo puede usar h5py para almacenar y recuperar datos de su disco duro.  Discutiremos diferentes formas de almacenar datos y c√≥mo optimizar el proceso de lectura.  Todos los ejemplos que aparecen en este art√≠culo tambi√©n est√°n disponibles en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de Github</a> . <br><br>  <b>Instalaci√≥n</b> <br><br>  El formato HDF5 es compatible con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupo HDF</a> y se basa en est√°ndares de c√≥digo abierto, lo que significa que sus datos siempre estar√°n disponibles, incluso si el grupo desaparece.  El soporte de Python se proporciona a trav√©s del paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">h5py</a> , que se puede instalar a trav√©s de pip.  Recuerde que debe usar el entorno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">virtual</a> para las pruebas: <br><br><pre><code class="bash hljs">pip install h5py</code> </pre> <br>  Este comando tambi√©n instalar√° NumPy si no est√° en su entorno. <br><br>  Si est√° buscando una herramienta gr√°fica para examinar el contenido de sus archivos HDF5, puede instalar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visor HDF5</a> .  Est√° escrito en Java, por lo que deber√≠a funcionar en casi cualquier computadora. <br><br>  <b>Almacenamiento b√°sico de datos y lectura</b> <br><br>  Pasemos a usar la biblioteca HDF5.  Crearemos un nuevo archivo y guardaremos una matriz aleatoria de NumPy en √©l. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">"default"</span></span>, data=arr)</code> </pre><br>  Las primeras l√≠neas son bastante simples: importamos los paquetes h5py y NumPy y creamos una matriz con valores aleatorios.  Abrimos el archivo random.hdf5 con permiso de escritura w, lo que significa que si ya existe un archivo con el mismo nombre, se sobrescribir√°.  Si desea guardar el archivo y a√∫n as√≠ poder escribir en √©l, puede abrirlo con el atributo a en lugar de w.  Creamos un conjunto de datos llamado predeterminado y establecemos los datos como una matriz aleatoria creada anteriormente.  Los conjuntos de datos son los custodios de nuestros datos, principalmente componentes b√°sicos del formato HDF5. <br><br>  <b>Una nota</b> <b><br></b> <br>  Si no est√° familiarizado con la declaraci√≥n with, debo tener en cuenta que esta es una forma conveniente de abrir y cerrar archivos.  Incluso si ocurre un error dentro <code>with</code> , el archivo se cerrar√°.  Si por alguna raz√≥n no est√° utilizando, nunca olvide agregar el <code>f.close()</code> al final.  La declaraci√≥n <code>with</code> funciona con cualquier archivo, no solo con archivos HDF. <br><br>  Podemos leer los datos casi de la misma manera que leemos el archivo NumPy: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: data = f[<span class="hljs-string"><span class="hljs-string">'default'</span></span>] print(min(data)) print(max(data)) print(data[:<span class="hljs-number"><span class="hljs-number">15</span></span>])</code> </pre> <br>  Abrimos el archivo con el atributo de lectura r y restauramos los datos accediendo directamente al conjunto de datos llamado predeterminado.  Si abre el archivo y no sabe qu√© conjuntos de datos est√°n disponibles, puede obtenerlos: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f.keys(): print(key)</code> </pre> <br>  Despu√©s de leer el conjunto de datos que desea, puede usarlo como si estuviera usando cualquier matriz NumPy.  Por ejemplo, puede encontrar los valores m√°ximos y m√≠nimos o seleccionar los primeros 15 valores de la matriz.  Sin embargo, estos ejemplos simples ocultan muchas cosas que suceden debajo del cap√≥, y deben discutirse para comprender todo el potencial de HDF5. <br><br>  En el ejemplo anterior, puede usar los datos como una matriz.  Por ejemplo, puede referirse al tercer elemento ingresando datos [2], o puede obtener un rango de valores de datos [1: 3].  Tenga en cuenta: los datos no son una matriz, es un conjunto de datos.  Puede verlo escribiendo <code>print(type(data))</code> .  Los conjuntos de datos funcionan de una manera completamente diferente a las matrices, porque su informaci√≥n se almacena en el disco duro y no la cargan en la RAM si no los usamos.  El siguiente c√≥digo, por ejemplo, no funcionar√°: <br><br><pre> <code class="python hljs">f = h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) data = f[<span class="hljs-string"><span class="hljs-string">'default'</span></span>] f.close() print(data[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br>  El error que aparece es un poco engorroso, pero la √∫ltima l√≠nea es muy √∫til: <br><br><pre> <code class="bash hljs">ValueError: Not a dataset (not a dataset)</code> </pre> <br>  El error significa que estamos intentando acceder a un conjunto de datos al que ya no tenemos acceso.  Esto es un poco confuso, pero sucede porque cerramos el archivo y, por lo tanto, ya no se nos permite acceder al segundo valor en los datos.  Cuando asignamos f ['predeterminado'] a datos variables, en realidad no leemos los datos del archivo, en su lugar, generamos un puntero a donde est√°n los datos en el disco duro.  Por otro lado, este c√≥digo funcionar√°: <br><br><pre> <code class="python hljs">f = h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) data = f[<span class="hljs-string"><span class="hljs-string">'default'</span></span>][:] f.close() print(data[<span class="hljs-number"><span class="hljs-number">10</span></span>])</code> </pre><br>  Tenga en cuenta que la √∫nica diferencia es que agregamos [:] despu√©s de leer el conjunto de datos.  Muchos otros manuales se detienen en tales ejemplos, sin siquiera demostrar todo el potencial del formato HDF5 con el paquete h5py.  Debido a los ejemplos que hemos examinado hasta ahora, puede que se pregunte: ¬øpor qu√© usar HDF5 si guardar archivos NumPy le brinda la misma funcionalidad?  Veamos las caracter√≠sticas del formato HDF5. <br><br>  <b>Lectura selectiva de archivos HDF5</b> <br><br>  Hasta ahora, hemos visto que cuando leemos un conjunto de datos, todav√≠a no estamos leyendo datos del disco, sino que creamos un enlace a un lugar espec√≠fico en el disco duro.  Podemos ver qu√© sucede si, por ejemplo, leemos expl√≠citamente los primeros 10 elementos de un conjunto de datos: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: data_set = f[<span class="hljs-string"><span class="hljs-string">'default'</span></span>] data = data_set[:<span class="hljs-number"><span class="hljs-number">10</span></span>] print(data[<span class="hljs-number"><span class="hljs-number">1</span></span>]) print(data_set[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br>  Dividimos el c√≥digo en diferentes l√≠neas para hacerlo m√°s expl√≠cito, pero puede ser m√°s sint√©tico en sus proyectos.  En las l√≠neas anteriores, primero leemos el archivo y luego leemos el conjunto de datos predeterminado.  Asignamos los primeros 10 elementos del conjunto de datos a la variable de datos.  Despu√©s de cerrar el archivo (cuando finaliza), podemos acceder a los valores almacenados en los datos, pero data_set arrojar√° un error.  Tenga en cuenta que solo leemos desde el disco cuando accedemos expl√≠citamente a los primeros 10 elementos de un conjunto de datos.  Si observa los tipos de datos y data_set, ver√° que son realmente diferentes.  El primero es una matriz NumPy, y el segundo es un conjunto de datos h5py. <br><br>  El mismo comportamiento es relevante en escenarios m√°s complejos.  Creemos un nuevo archivo, esta vez con dos conjuntos de datos, y seleccionemos los elementos de uno de ellos en funci√≥n de los elementos del otro.  Comencemos creando un nuevo archivo y almacenando datos;  esta parte es la m√°s simple: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np arr1 = np.random.randn(<span class="hljs-number"><span class="hljs-number">10000</span></span>) arr2 = np.random.randn(<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'complex_read.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.create_dataset(<span class="hljs-string"><span class="hljs-string">'array_1'</span></span>, data=arr1) f.create_dataset(<span class="hljs-string"><span class="hljs-string">'array_2'</span></span>, data=arr2)</code> </pre> <br>  Tenemos dos conjuntos de datos llamados array_1 y array_2, cada uno de los cuales contiene una matriz aleatoria NumPy.  Queremos leer los valores de array_2 que corresponden a elementos donde los valores de array_1 son positivos.  Podemos intentar hacer algo como esto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'complex_read.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d1 = f[<span class="hljs-string"><span class="hljs-string">'array_1'</span></span>] d2 = f[<span class="hljs-string"><span class="hljs-string">'array_2'</span></span>] data = d2[d1&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  Pero eso no funcionar√°.  d1 es un conjunto de datos y no se puede comparar con un n√∫mero entero.  La √∫nica forma es leer los datos del disco y luego compararlos.  Por lo tanto, obtenemos algo como esto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'complex_read.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d1 = f[<span class="hljs-string"><span class="hljs-string">'array_1'</span></span>] d2 = f[<span class="hljs-string"><span class="hljs-string">'array_2'</span></span>] data = d2[d1[:]&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  El primer conjunto de datos d1 se carga completamente en la memoria cuando hacemos d1 [:], pero del segundo conjunto de datos d2 tomamos solo algunos elementos.  Si el conjunto de datos d1 era demasiado grande para cargarlo en la memoria por completo, podr√≠amos trabajar dentro de un bucle. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'complex_read.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d1 = f[<span class="hljs-string"><span class="hljs-string">'array_1'</span></span>] d2 = f[<span class="hljs-string"><span class="hljs-string">'array_2'</span></span>] data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(d1)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d1[i] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: data.append(d2[i]) print(<span class="hljs-string"><span class="hljs-string">'The length of data with a for loop: {}'</span></span>.format(len(data)))</code> </pre> <br>  Por supuesto, hay problemas con la eficacia de la lectura por elementos y la adici√≥n de elementos a la lista, pero este es un muy buen ejemplo de una de las mayores ventajas de usar HDF5 sobre archivos de texto o NumPy.  Dentro del bucle, cargamos solo un elemento en la memoria.  En nuestro ejemplo, cada elemento es simplemente un n√∫mero, pero podr√≠a ser cualquier cosa: desde texto a imagen o video. <br><br>  Como siempre, dependiendo de su aplicaci√≥n, debe decidir si desea leer toda la matriz en la memoria o no.  A veces ejecuta simulaciones en una computadora espec√≠fica con una gran cantidad de memoria, pero no tiene las mismas caracter√≠sticas en su computadora port√°til y se ve obligado a leer fragmentos de sus datos.  Recuerde que la lectura desde el disco duro es relativamente lenta, especialmente si usa el HDD en lugar de los discos SDD o incluso m√°s si lee desde un disco de red. <br><br>  <b>Escribir selectivamente en archivos HDF5</b> <br><br>  En los ejemplos anteriores, agregamos datos al conjunto de datos tan pronto como se cre√≥.  Sin embargo, para muchas aplicaciones necesita guardar datos durante la generaci√≥n.  HDF5 le permite guardar datos de la misma manera que los lee.  Veamos c√≥mo crear un conjunto de datos vac√≠o y agregarle algunos datos. <br><br><pre> <code class="python hljs">arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">"default"</span></span>, (<span class="hljs-number"><span class="hljs-number">1000</span></span>,)) dset[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>] = arr[<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">60</span></span>]</code> </pre> <br>  Las dos primeras l√≠neas son las mismas que antes, excepto para <code>create_dataset</code> .  No agregamos datos cuando los creamos, solo creamos un conjunto de datos vac√≠o que puede contener hasta 1000 elementos.  Con la misma l√≥gica que antes, cuando leemos ciertos elementos de un conjunto de datos, en realidad escribimos en el disco solo cuando asignamos valores a ciertos elementos de la variable dset.  En el ejemplo anterior, solo asignamos valores a un subconjunto de la matriz, con √≠ndices del 10 al 19. <br><br>  <b><i>Advertencia</i></b> <br><br>  No es del todo cierto lo que escribe en el disco cuando asigna valores a un conjunto de datos.  El momento exacto depende de varios factores, incluido el estado del sistema operativo.  Si el programa se cierra demasiado pronto, puede suceder que no todo se grabe.  Es muy importante usar siempre el m√©todo <code>close()</code> , y en caso de que escriba en etapas, tambi√©n puede usar <code>flush()</code> para forzar la entrada.  Usar con evita muchos problemas de escritura. <br><br>  Si lee el archivo e imprime los primeros 20 valores del conjunto de datos, ver√° que todos son ceros, excepto los √≠ndices del 10 al 19. Hay un error com√∫n que puede provocar un dolor de cabeza notable.  El siguiente c√≥digo no guardar√° nada en el disco: <br><br><pre> <code class="python hljs">arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'random.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">"default"</span></span>, (<span class="hljs-number"><span class="hljs-number">1000</span></span>,)) dset = arr</code> </pre> <br>  Este error siempre causa muchos problemas, porque no comprender√° que no escribi√≥ nada hasta que intente leer el resultado.  El problema aqu√≠ es que no especifica d√≥nde desea almacenar los datos, simplemente sobrescribe la variable dset con una matriz NumPy.  Dado que el conjunto de datos y la matriz tienen la misma longitud, debe usar dset [:] = arr.  Este error ocurre con m√°s frecuencia de lo que piensa, y dado que t√©cnicamente no es incorrecto, no ver√° ning√∫n error en el terminal y sus datos ser√°n ceros. <br><br>  Hasta ahora, siempre hemos trabajado con matrices unidimensionales, pero no estamos limitados a ellas.  Por ejemplo, supongamos que queremos usar una matriz 2D, simplemente podemos hacer: <br><br><pre> <code class="python hljs">dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, (<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>))</code> </pre> <br>  lo que nos permite almacenar datos en una matriz de 500x1024.  Para usar un conjunto de datos, podemos usar la misma sintaxis que antes, pero teniendo en cuenta la segunda dimensi√≥n: <br><br><pre> <code class="python hljs">dset[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> dset[<span class="hljs-number"><span class="hljs-number">200</span></span>:<span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>:<span class="hljs-number"><span class="hljs-number">1024</span></span>] = <span class="hljs-number"><span class="hljs-number">123</span></span></code> </pre> <br>  <b>Especificar tipos de datos para optimizar el espacio.</b> <br><br>  Hasta ahora, hemos examinado solo la punta del iceberg de lo que HDF5 tiene para ofrecer.  Adem√°s de la longitud de los datos que desea conservar, puede especificar el tipo de datos para optimizar el espacio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La documentaci√≥n de h5py</a> contiene una lista de todos los tipos compatibles, aqu√≠ solo mostramos algunos.  Al mismo tiempo, trabajaremos con varios conjuntos de datos en un archivo. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'several_datasets.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset_int_1 = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'integers'</span></span>, (<span class="hljs-number"><span class="hljs-number">10</span></span>, ), dtype=<span class="hljs-string"><span class="hljs-string">'i1'</span></span>) dset_int_8 = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'integers8'</span></span>, (<span class="hljs-number"><span class="hljs-number">10</span></span>, ), dtype=<span class="hljs-string"><span class="hljs-string">'i8'</span></span>) dset_complex = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'complex'</span></span>, (<span class="hljs-number"><span class="hljs-number">10</span></span>, ), dtype=<span class="hljs-string"><span class="hljs-string">'c16'</span></span>) dset_int_1[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1200</span></span> dset_int_8[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1200.1</span></span> dset_complex[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4j</span></span></code> </pre><br>  En el ejemplo anterior, creamos tres conjuntos de datos diferentes, cada uno de los cuales tiene un tipo diferente.  Enteros de 1 byte, enteros de 8 bytes y n√∫meros complejos de 16 bytes.  Solo almacenamos un n√∫mero, incluso si nuestros conjuntos de datos pueden contener hasta 10 elementos.  Puede leer los valores y ver qu√© se guard√≥ realmente.  Debe notarse aqu√≠ que un entero de 1 byte debe redondearse a 127 (en lugar de 1200), y un entero de 8 bytes debe redondearse a 1200 (en lugar de 1200.1). <br><br>  Si alguna vez ha programado en lenguajes como C o Fortran, probablemente sepa qu√© significan los diferentes tipos de datos.  Sin embargo, si siempre ha trabajado con Python, es posible que no haya encontrado ning√∫n problema sin declarar expl√≠citamente el tipo de datos con los que est√° trabajando.  Es importante recordar que el n√∫mero de bytes le indica cu√°ntos n√∫meros diferentes puede guardar.  Si usa 1 byte, tiene 8 bits y, por lo tanto, puede almacenar 2 ^ 8 n√∫meros diferentes.  En el ejemplo anterior, los enteros son positivos, negativos y 0. Cuando usa enteros de 1 byte, puede almacenar valores de -128 a 127, en total son 2 ^ 8 n√∫meros posibles.  Esto es equivalente a usar 8 bytes, pero con una amplia gama de n√∫meros. <br><br>  El tipo de datos seleccionados afectar√° su tama√±o.  Primero, veamos c√≥mo funciona esto con un ejemplo simple.  Creemos tres archivos, cada uno con un conjunto de datos para 100,000 elementos, pero con diferentes tipos de datos.  Guardaremos los mismos datos en ellos y luego compararemos sus tama√±os.  Creamos una matriz aleatoria para asignar a cada conjunto de datos para llenar la memoria.  Recuerde que los datos se convertir√°n al formato especificado en el conjunto de datos. <br><br><pre> <code class="python hljs">arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">100000</span></span>) f = h5py.File(<span class="hljs-string"><span class="hljs-string">'integer_1.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'i1'</span></span>) d[:] = arr f.close() f = h5py.File(<span class="hljs-string"><span class="hljs-string">'integer_8.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'i8'</span></span>) d[:] = arr f.close() f = h5py.File(<span class="hljs-string"><span class="hljs-string">'float.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'f16'</span></span>) d[:] = arr f.close()</code> </pre> <br>  Cuando verifique el tama√±o de cada archivo, obtendr√° algo como: <br><br><table><tbody><tr><th>  Archivo </th><th>  Tama√±o (b) </th></tr><tr><td>  entero_1 </td><td>  102144 </td></tr><tr><td>  entero_9 </td><td>  802144 </td></tr><tr><td>  flotar </td><td>  1602144 </td></tr></tbody></table><br>  La relaci√≥n entre tama√±o y tipo de datos es clara.  Cuando pasa de enteros de 1 byte a 8 bytes, el tama√±o del archivo aumenta 8 veces, de manera similar, cuando va a 16 bytes, ocupa aproximadamente 16 veces m√°s espacio.  Pero el espacio no es el √∫nico factor importante a tener en cuenta; tambi√©n debe tener en cuenta el tiempo que lleva escribir datos en el disco.  Cuanto m√°s tenga que escribir, m√°s tardar√°.  Dependiendo de su aplicaci√≥n, puede ser crucial optimizar la lectura y escritura de datos. <br><br>  Tenga en cuenta: si utiliza el tipo de datos incorrecto, tambi√©n puede perder informaci√≥n.  Por ejemplo, si tiene enteros de 8 bytes y los almacena como enteros de 1 byte, sus valores se truncar√°n.  Cuando se trabaja en el laboratorio, los dispositivos que crean diferentes tipos de datos a menudo est√°n disponibles.  Algunas tarjetas DAQ tienen 16 bits, algunas c√°maras funcionan con 8 bits, pero algunas pueden funcionar con 24. Es importante prestar atenci√≥n a los tipos de datos, pero esto tambi√©n es algo que los desarrolladores de Python pueden no tener en cuenta, porque no es necesario que expl√≠citamente declarar tipo. <br><br>  Tambi√©n es interesante recordar que la matriz predeterminada de NumPy ser√° flotante con 8 bytes (64 bits) por elemento.  Esto puede ser un problema si, por ejemplo, inicializa una matriz con ceros para almacenar datos, que deber√≠an tener solo 2 bytes.  El tipo de matriz en s√≠ no cambiar√°, y si guarda los datos al crear el conjunto de datos (agregando data = my_array), el formato predeterminado ser√° "f8", que es una matriz, pero no datos reales, <br><br>  Pensar en los tipos de datos no es algo que sucede regularmente si trabajas con Python en aplicaciones simples.  Sin embargo, debe tener en cuenta que existen tipos de datos y qu√© impacto pueden tener en sus resultados.  Es posible que tenga discos duros grandes y que realmente no le importe el almacenamiento de archivos, pero cuando le importa la velocidad con la que ahorra, no hay otra forma que optimizar todos los aspectos de su c√≥digo, incluidos los tipos de datos. <br><br>  <b>Compresi√≥n de datos</b> <br><br>  Al guardar datos, puede elegir la compresi√≥n utilizando diferentes algoritmos.  El paquete h5py admite varios filtros de compresi√≥n, como GZIP, LZF y SZIP.  Cuando se usa uno de los filtros de compresi√≥n, los datos se procesar√°n en su camino hacia el disco y, al leerlos, se desempaquetar√°n.  Por lo tanto, no hay cambios especiales en el c√≥digo.  Podemos repetir el mismo experimento, guardando diferentes tipos de datos, pero usando un filtro de compresi√≥n.  Nuestro c√≥digo se ve as√≠: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'integer_1_compr.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'i1'</span></span>, compression=<span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, compression_opts=<span class="hljs-number"><span class="hljs-number">9</span></span>) d[:] = arr <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'integer_8_compr.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'i8'</span></span>, compression=<span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, compression_opts=<span class="hljs-number"><span class="hljs-number">9</span></span>) d[:] = arr <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'float_compr.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100000</span></span>,), dtype=<span class="hljs-string"><span class="hljs-string">'f16'</span></span>, compression=<span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, compression_opts=<span class="hljs-number"><span class="hljs-number">9</span></span>) d[:] = arr</code> </pre> <br>  Elegimos gzip porque es compatible con todas las plataformas.  Las opciones de compresi√≥n_opts especifican el nivel de compresi√≥n.  Cuanto mayor sea el nivel, menos espacio ocupar√°n los datos, pero m√°s tiempo deber√≠a funcionar el procesador.  El nivel de compresi√≥n predeterminado es 4. Podemos ver las diferencias en nuestros archivos seg√∫n el nivel de compresi√≥n: <br><br><table><tbody><tr><th>  Tipo </th><th>  Sin compresi√≥n </th><th>  Compresi√≥n 9 </th><th>  Compresi√≥n 4 </th></tr><tr><td>  entero_1 </td><td>  102144 </td><td>  28016 </td><td>  30463 </td></tr><tr><td>  entero_8 </td><td>  802144 </td><td>  43329 </td><td>  57971 </td></tr><tr><td>  flotar </td><td>  1602144 </td><td>  1469580 </td><td>  1469868 </td></tr></tbody></table><br>  El efecto de la compresi√≥n en conjuntos de datos completos es mucho m√°s notable que en los conjuntos de datos de punto flotante.  Te dejo que descubras por qu√© la compresi√≥n funcion√≥ tan bien en los primeros dos casos, pero no en el √∫ltimo.  Como sugerencia: debe verificar qu√© datos est√° almacenando realmente. <br><br>  La lectura de datos comprimidos no cambia ninguno de los c√≥digos descritos anteriormente.  La biblioteca principal HDF5 se encargar√° de extraer datos de conjuntos de datos comprimidos utilizando el algoritmo apropiado.  Por lo tanto, si implementa compresi√≥n para guardar, no necesita cambiar el c√≥digo que usa para leer. <br><br>  La compresi√≥n de datos es una herramienta adicional que debe considerar junto con todos los dem√°s aspectos del procesamiento de datos.  Debe considerar el tiempo adicional del procesador y la relaci√≥n de compresi√≥n efectiva para evaluar los beneficios de la compresi√≥n de datos dentro de su propia aplicaci√≥n.  El hecho de que sea transparente para el c√≥digo posterior hace que sea incre√≠blemente f√°cil probar y encontrar la mejor soluci√≥n. <br><br>  <b>Redimensionar conjuntos de datos</b> <br><br>  Cuando est√° trabajando en un experimento, a veces es imposible saber qu√© tan grandes ser√°n sus datos.  Imagine que est√° grabando una pel√≠cula, tal vez la detendr√° despu√©s de un segundo, tal vez despu√©s de una hora.  Afortunadamente, HDF5 le permite cambiar el tama√±o de los conjuntos de datos sobre la marcha con un bajo costo computacional.  La longitud del conjunto de datos se puede exceder hasta el tama√±o m√°ximo.  Este tama√±o m√°ximo se especifica al crear el conjunto de datos con la palabra clave maxshape: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'resize_dataset.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">100</span></span>, ), maxshape=(<span class="hljs-number"><span class="hljs-number">500</span></span>, )) d[:<span class="hljs-number"><span class="hljs-number">100</span></span>] = np.random.randn(<span class="hljs-number"><span class="hljs-number">100</span></span>) d.resize((<span class="hljs-number"><span class="hljs-number">200</span></span>,)) d[<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">200</span></span>] = np.random.randn(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'resize_dataset.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f[<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>] print(dset[<span class="hljs-number"><span class="hljs-number">99</span></span>]) print(dset[<span class="hljs-number"><span class="hljs-number">199</span></span>])</code> </pre><br>  Primero, crea un conjunto de datos para almacenar 100 valores y establece el tama√±o m√°ximo en 500 valores.  Despu√©s de guardar el primer lote de valores, puede expandir el conjunto de datos para guardar los siguientes 100. Puede repetir el procedimiento hasta obtener un conjunto de datos con 500 valores.        ,   N-    .   ,     ,         . <br><br>           ,        ,    . ,    -  (   ,      ,     ): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'resize_dataset.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f[<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>] dset.resize((<span class="hljs-number"><span class="hljs-number">300</span></span>,)) dset[:<span class="hljs-number"><span class="hljs-number">200</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> dset[<span class="hljs-number"><span class="hljs-number">200</span></span>:<span class="hljs-number"><span class="hljs-number">300</span></span>] = np.random.randn(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'resize_dataset.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dset = f[<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>] print(dset[<span class="hljs-number"><span class="hljs-number">99</span></span>]) print(dset[<span class="hljs-number"><span class="hljs-number">199</span></span>]) print(dset[<span class="hljs-number"><span class="hljs-number">299</span></span>])</code> </pre> <br>       ,     ,    200           200  299.       ,   ,  . <br><br> ,    ,    ,     .    2D-,     ,   ‚Äî   ,    2D-.       3-    HDF-,        .            ,    : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'movie_dataset.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f.create_dataset(<span class="hljs-string"><span class="hljs-string">'dataset'</span></span>, (<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), maxshape=(<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> )) d[:,:,<span class="hljs-number"><span class="hljs-number">0</span></span>] = first_frame d.resize((<span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) d[:,:,<span class="hljs-number"><span class="hljs-number">1</span></span>] = second_frame</code> </pre> <br>       1024x1024 ,        .  ,      ,          .     maxshape    None. <br><br> <b>   (Chunks)</b> <br><br>    ,     .   (chunk)          , ..     .    ,    ,     .     ,  : <br><br><pre> <code class="python hljs">dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">"chunked"</span></span>, (<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>), chunks=(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>))</code> </pre><br>   ,     dset [0: 100,0: 100]   .     dset [200: 300, 200: 300], dset [100: 200, 400: 500]  . .  h5py,        : <br><br>     (Chunking)    .        10 KiB  1 MiB,      .    ,        ,     . <br><br>       (auto-chunking),      .     ,      maxshape.     : <br><br><pre> <code class="python hljs">dset = f.create_dataset(<span class="hljs-string"><span class="hljs-string">"autochunk"</span></span>, (<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>), chunks=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br> <b>   (Groups)</b> <br><br>         .          HDF5,    ,     .        (groups),     ,   .     ,       : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g = f.create_group(<span class="hljs-string"><span class="hljs-string">'Base_Group'</span></span>) gg = g.create_group(<span class="hljs-string"><span class="hljs-string">'Sub_Group'</span></span>) d = g.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, data=arr) dd = gg.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, data=arr)</code> </pre> <br>    Base_Group     ,  Sub_Group.         default      .    ,  ,   : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: d = f[<span class="hljs-string"><span class="hljs-string">'Base_Group/default'</span></span>] dd = f[<span class="hljs-string"><span class="hljs-string">'Base_Group/Sub_Group/default'</span></span>] print(d[<span class="hljs-number"><span class="hljs-number">1</span></span>]) print(dd[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br>    ,            : Base_Group/default  Base_Group/Sub_Group/default.    , ,   ,    ,     .    ‚Äî  keys(): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f.keys(): print(k)</code> </pre> <br> ,      ,       for-.      ,     .     visit(), : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> print(name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.visit(get_all)</code> </pre> <br>  ,     <code>get_all</code> ,    , name.     visit,        <code>get_all.</code> visit     ,      ,   None,    . , ,       Sub_Group,    <code>get_all</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'Sub_Group'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g = f.visit(get_all) print(g)</code> </pre><br>  visit    ,     ,    None,     ,   get_all.    Sub_Group,   get_all   ,    Sub_Group    .   ,  g  ,      ,   : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g_name = f.visit(get_all) group = f[g_name]</code> </pre> <br>         .   ‚Äî  ,  visititems,      : name  object.   : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_objects</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, obj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'Sub_Group'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: group = f.visititems(get_objects) data = group[<span class="hljs-string"><span class="hljs-string">'default'</span></span>] print(<span class="hljs-string"><span class="hljs-string">'First data element: {}'</span></span>.format(data[<span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre><br>     visititems   ,         ,  ,     .   ,    ,   .       . ,    ,         . <br><br> <b>   HDF5</b> <br><br>   ,     HDF5,    ,       .    ,  , ,   ,  ,     ,  ..    . ,     ,     200x300x250. ,  ,   ,    ,   ‚Äî ,      . <br><br>     HDF5    -.          . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> h5py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os arr = np.random.randn(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g = f.create_group(<span class="hljs-string"><span class="hljs-string">'Base_Group'</span></span>) d = g.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, data=arr) g.attrs[<span class="hljs-string"><span class="hljs-string">'Date'</span></span>] = time.time() g.attrs[<span class="hljs-string"><span class="hljs-string">'User'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Me'</span></span> d.attrs[<span class="hljs-string"><span class="hljs-string">'OS'</span></span>] = os.name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> g.attrs.keys(): print(<span class="hljs-string"><span class="hljs-string">'{} =&gt; {}'</span></span>.format(k, g.attrs[k])) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> d.attrs.keys(): print(<span class="hljs-string"><span class="hljs-string">'{} =&gt; {}'</span></span>.format(j, d.attrs[j]))</code> </pre> <br>       ,  attrs   .  ,        ,     .      ,     .     ,   ,        ,    update: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g = f.create_group(<span class="hljs-string"><span class="hljs-string">'Base_Group'</span></span>) d = g.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, data=arr) metadata = {<span class="hljs-string"><span class="hljs-string">'Date'</span></span>: time.time(), <span class="hljs-string"><span class="hljs-string">'User'</span></span>: <span class="hljs-string"><span class="hljs-string">'Me'</span></span>, <span class="hljs-string"><span class="hljs-string">'OS'</span></span>: os.name,} f.attrs.update(metadata) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f.attrs.keys(): print(<span class="hljs-string"><span class="hljs-string">'{} =&gt; {}'</span></span>.format(m, f.attrs[m]))</code> </pre><br> ,   ,  hdf5, . ,   .        hdf5,    .  Python     -.          JSON,        ,     ,  ,  pickle. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups_dict.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: g = f.create_group(<span class="hljs-string"><span class="hljs-string">'Base_Group'</span></span>) d = g.create_dataset(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, data=arr) metadata = {<span class="hljs-string"><span class="hljs-string">'Date'</span></span>: time.time(), <span class="hljs-string"><span class="hljs-string">'User'</span></span>: <span class="hljs-string"><span class="hljs-string">'Me'</span></span>, <span class="hljs-string"><span class="hljs-string">'OS'</span></span>: os.name,} m = g.create_dataset(<span class="hljs-string"><span class="hljs-string">'metadata'</span></span>, data=json.dumps(metadata))</code> </pre><br>   ,      .        ,   .    ,   json.dumps,      .    ,     HDF5.    ,              json.loads: <br><br>  Pit√≥n <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> h5py.File(<span class="hljs-string"><span class="hljs-string">'groups_dict.hdf5'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: metadata = json.loads(f[<span class="hljs-string"><span class="hljs-string">'Base_Group/metadata'</span></span>][()]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> metadata: print(<span class="hljs-string"><span class="hljs-string">'{} =&gt; {}'</span></span>.format(k, metadata[k]))</code> </pre> <br>    json    ,    .     YAML, XML  ..    ,   ,   ,     attr  , ,     . <br><br> <b>   HDF5</b> <br><br>        ,            . ,     ,    ,      .      HDF  ,   ,  ,          ,   ,    .  ,  HDF        . <br><br>  HDF5        .        ,      ,    .         ,      . .      SQL,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDFql</a> ,    SQL      HDF5. <br><br>            .      , , -   ,  ,    .        ,     .  ,    ,            . <br><br> HDF5 ‚Äî  ,       .    ,  ,      ,    ,        . HDF5 ‚Äî  ,         ,     . <br><br>  El fin <br><br>    ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416309/">https://habr.com/ru/post/es416309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416299/index.html">La gente ha estado rastreando los glaciares en Islandia durante d√©cadas; Ahora la t√©cnica lo har√°</a></li>
<li><a href="../es416301/index.html">Navegaci√≥n en la aplicaci√≥n de Android usando coordinadores</a></li>
<li><a href="../es416303/index.html">Recreando el primer disparador</a></li>
<li><a href="../es416305/index.html">La estandarizaci√≥n es la aventura m√°s larga de Internet de las cosas</a></li>
<li><a href="../es416307/index.html">iOS 12: nuevo en notificaciones</a></li>
<li><a href="../es416313/index.html">Lista de verificaci√≥n de an√°lisis de registro de eventos de seguridad</a></li>
<li><a href="../es416315/index.html">ASP.NET Razor: Resolviendo algunos problemas de arquitectura para el modelo de vista</a></li>
<li><a href="../es416319/index.html">Antecedentes: listas blancas de IMEI y Rossvyaz</a></li>
<li><a href="../es416321/index.html">C√≥mo convertirse en orador de conferencias internacionales de TI</a></li>
<li><a href="../es416323/index.html">La opci√≥n de acceso aleatorio a las configuraciones y grabaciones del registrador de autom√≥viles desde cualquier lugar en Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>