<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍌 🚙 👨🏼‍🍳 Beeinflussen Sie die Statistik der Inline-Kommentare ◼️ 🙍 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie sammle ich Seitenkommentarstatistiken in Confluence? 

 Ja, und warum könnte das nötig sein? 



 Warum und warum 
 In dem Projekt, in dem ich ger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beeinflussen Sie die Statistik der Inline-Kommentare</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485652/">  Wie sammle ich Seitenkommentarstatistiken in Confluence? <br><br>  Ja, und warum könnte das nötig sein? <br><br><img src="https://habrastorage.org/webt/c6/7x/uo/c67xuo6sop9dd7mpzxty_i7wj7s.png"><br><a name="habracut"></a><br><h2>  Warum und warum </h2><br>  In dem Projekt, in dem ich gerade gearbeitet habe, ist der folgende Prozess der Vorbereitung und Genehmigung von Anforderungen entstanden: <br><br><ul><li>  Confluence wurde für die Dokumentation verwendet. </li><li>  Das Lieferantenteam erstellte Beschreibungen der Geschäftsprozesse und ihrer Schritte in Form von separaten Seiten entsprechend der Vorlage. </li><li>  Einmal pro Woche wurde dem Kunden eine Reihe vorbereiteter Beschreibungen zum Korrekturlesen übergeben. </li><li>  Das Kundenteam hinterließ alle Fragen und Ergänzungen in Form von eingebauten Kommentaren auf der entsprechenden Seite. </li><li>  Das Lieferantenteam ergänzte den Inhalt, beantwortete Kommentare und stellte Fragen für zusätzliche Studien. </li><li>  Wenn die Frage beantwortet und der Inhalt aktualisiert oder die Aufgabe für das Studium festgelegt wurde, sollte das Kundenteam den Kommentar schließen. </li><li>  Fragen zu einem Stapel von Dokumenten aus der aktuellen Woche sollten geschlossen sein, bis der nächste Stapel nächste Woche übertragen wird. </li></ul><br>  Projektmanager haben jede Woche die Aufgabe zu verstehen, wie viel der gelieferte Stapel von Dokumenten funktioniert hat und was davon als bedingt bereit angesehen werden kann.  Und die Teilnehmer des Lieferantenteams müssen regelmäßig den Status der Kommentare zu ihren Dokumenten überprüfen und mit den anderen zielgerichtet zusammenarbeiten.  Aber wie findet man sie?  Sie können jede Seite öffnen, den ersten Kommentar mit Ihren Augen suchen (oder mit Hilfe eines <a href="https://community.atlassian.com/t5/Confluence-questions/Search-for-unresolved-inline-comments/qaq-p/971424">kleinen Tricks</a> ) und dann auf alle Kommentare klicken, weil  Das Kundenteam hat es nicht eilig, sie zu schließen, über sie nachzudenken und nach einer Antwort zu suchen. <br><br>  Der wöchentliche Stapel enthält 50-100 separate Seiten, und dies mit Ihren Händen zu tun, ist ein erheblicher Arbeitsaufwand.  Und wenn Sie immer noch versuchen, Argumente zu sammeln, um die andere Seite zu überzeugen, wird es sehr traurig.  Und es gibt auch baumelnde Kommentare, die sich aus einer fehlerhaften Bearbeitung der Seite ergeben, wenn der Quelltext versehentlich gelöscht wird.  Ein solcher Kommentar ist in den aufgelösten sichtbar, kann jedoch nicht wieder geöffnet werden (dies ist möglich, wenn Sie eine unsichtbare Markierung im Text der Seite neu erstellen). <br><br>  Die Suche nach Tools war nicht erfolgreich.  Darüber hinaus wird Confluence auf Kundenseite bereitgestellt. Sie können keine Plugins installieren, ganz zu schweigen vom Kauf.  Keine Makroentwicklungsexpertise. <br><br>  Irgendwann erinnerte ich mich an die Confluence- <a href="https://docs.atlassian.com/ConfluenceServer/rest/7.1.0/">REST-API</a> und an frühere Erfahrungen mit der Verwendung der ähnlichen <a href="https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/">Jira-API</a> .  Suche und Experimente mit Aufruffunktionen aus dem Browser haben gezeigt, dass Sie zu den Kommentaren und deren Eigenschaften gelangen können.  Als Nächstes mussten Sie ein Tool für die Automatisierung auswählen und können mit der Lösung beginnen.  Ich habe einige Erfahrungen mit der Erstellung von Skripten für Tools, die eher mit Administratoren wie Bash, Perl oder JScript zu tun haben.  Ich bin kein Entwickler, ich hatte keine vertrauten oder vertrauten Werkzeuge.  Ich wollte etwas üblicheres oder passenderes ausprobieren.  Dann entdeckte ich einen <a href="https://atlassian-python-api.readthedocs.io/en/latest/">Wrapper für die Python-API</a> und beschloss, es damit zu versuchen. <br><br><h2>  Allgemeines Prinzip </h2><br>  Das Problem wurde wie folgt formuliert.  Sie müssen alle Seiten finden, die sich auf eine bestimmte wöchentliche Lieferung beziehen.  Sammeln Sie Kommentare dazu in einer Liste: Seite, Link zum Kommentar, Autor und Datum des Kommentars, Quelltext auf der Seite, Kommentar und Antworten, Autor und Datum der letzten Antwort, Status des Kommentars.  Sammeln Sie außerdem Statistiken für jede Seite, wie viele Kommentare insgesamt, wie viele Gefahren, wie viele geöffnet sind.  Speichern Sie alles auf einer speziellen Statistikseite. <br><br>  Ich setze Python ein, schaue mir die Grundlagen der Arbeit damit an und lass uns gehen.  Erstellen Sie zunächst eine Verbindung: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> atlassian <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Confluence UserLogin = <span class="hljs-string"><span class="hljs-string">'xxxxxx'</span></span> <span class="hljs-comment"><span class="hljs-comment"># input("Login: ") UserPwd = 'xxxxxx' # input("Password: ") confluenceURL = 'http://wiki.xxxxxx' confluence = Confluence( url=confluenceURL, username=UserLogin, password=UserPwd)</span></span></code> </pre> <br>  Um nach Seiten aus einem wöchentlichen Stapel zu suchen, habe ich mich für die Verwendung von Tags entschieden.  Wie man sie in großen Mengen liefert, ist eine separate Aufgabe. <br><br><pre> <code class="python hljs">page_label = <span class="hljs-string"><span class="hljs-string">'week123'</span></span> cql = <span class="hljs-string"><span class="hljs-string">'space.key={} and label = "{}" and type = page '</span></span> <span class="hljs-string"><span class="hljs-string">'ORDER BY title '</span></span>.format(<span class="hljs-string"><span class="hljs-string">'YYY'</span></span>, page_label) pages = confluence.cql(cql, expand=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, start=<span class="hljs-number"><span class="hljs-number">0</span></span>, limit=<span class="hljs-number"><span class="hljs-number">200</span></span>)</code> </pre><br>  Also haben wir eine Liste von Seiten, die wir überprüfen müssen.  Als nächstes bearbeiten wir jede einzelne Seite.  Wir erheben aus ihren Daten Kommentare mit ihren Parametern.  Basierend auf diesen Daten erstellen wir Statistiken darüber, wie viele Kommentare auf der Seite vorhanden sind und unter welchen Bedingungen.  Als nächstes knocken wir das Ergebnis für alle Seiten aus und beginnen, das Ergebnis zu formatieren.  Wir erstellen den Hauptteil der Seite mit dem Ergebnis in Form einer Statistiktabelle und einer detaillierten Liste offener Kommentare. <br><br><div class="spoiler">  <b class="spoiler_title">Seitenlistenverarbeitung</b> <div class="spoiler_text"><pre> <code class="python hljs">statistics = [] open_comments = [] <span class="hljs-comment"><span class="hljs-comment">#  - ? if pages is not None: #    ? if pages['size'] &gt; 0: for page in pages['results']: print(page['title']) #       , #  page_comments = page_comments_data(page['content']['id']) #     statistics.append(page_statistics(page_comments)) #        #    . for comment in page_comments: if comment['Result'] not in ['resolved', 'nocomment']: if not (comment['Result'] == 'dangling' and comment['Author'] in excludeNames): open_comments.append(comment) #       . statistics.append(total_statistics(statistics)) #     page_id = confluence.get_page_id(space='YYY', title=page_title) #     ,    . page_body = ('&lt;p&gt;&lt;ac:structured-macro ac:name="toc" ac:schema-version="1"' '/&gt;&lt;/p&gt;' '&lt;h1&gt;Comments Statistics&lt;/h1&gt;{}' '&lt;h1&gt;Open Comments List&lt;/h1&gt;{}' ).format(create_table(statistics), create_table(open_comments)) #  if page_id is not None: status = confluence.update_page( page_id=page_id, title=page_title, body=page_body, representation='storage' )</span></span></code> </pre></div></div><br><h2>  API-Funktionen </h2><br>  Lassen Sie uns nun herausfinden, wie die Seite verarbeitet wird.  Standardmäßig gibt die API nur grundlegende Informationen zurück, z. B. einen Bezeichner oder einen Seitennamen.  Alle zusätzlichen Eigenschaften müssen explizit angegeben werden.  Sie können angezeigt werden, indem Sie das Ergebnis des Anrufs analysieren.  Zusätzliche Daten finden Sie in Abschnitten oder Unterabschnitten von _expandable.  Wir fügen den gewünschten Artikel zum Erweitern hinzu und schauen weiter, bis wir die erforderlichen Daten finden. <br><br><div class="spoiler">  <b class="spoiler_title">Issue-Beispiel</b> <div class="spoiler_text"><pre> <code class="json hljs">http://wiki.xxxxxx/rest/api/content/<span class="hljs-number"><span class="hljs-number">101743895</span></span>?expand=body,children.comment { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"97517865"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"current"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"w2019-47 comments status"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"children"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"results"</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"limit"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/page"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"styled_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"storage"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"anonymous_export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"extensions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operations"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"restrictions"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/restriction/byOperation"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"history"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/history"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ancestors"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"descendants"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/descendant"</span></span>, } }</code> </pre></div></div><br>  Und es gibt auch eine Beschränkung der Anzahl der ausgegebenen Ergebnisse, die Paginierung.  Es ist serverseitig konfiguriert (API?) Und in unserem Fall ist es 25. Bei einigen Anforderungen kann es durch explizite Angabe geändert werden, funktioniert jedoch nur für die oberste Ebene.  Und wenn wir Kommentare zu der Seite veröffentlichen, bekommen wir trotzdem nur 25, während die Größe auch falsch ist.  Im Beispiel waren es 29 in der Realität.  Wir haben es geschafft, die Paginierung von Kommentaren mithilfe einer separaten Funktion im Confluence-Modul zu umgehen - get_page_comments mit der Möglichkeit, die Seitengröße anzugeben. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    import re #      XML def replace_chars2(in_text): text = re.sub(r'&amp;', '&amp;', in_text) text = re.sub(r'\'', ''', text) text = re.sub(r'&lt;', '&lt;', text) text = re.sub(r'&gt;', '&gt;', text) text = re.sub(r'"', '"', text) return text</span></span></code> </pre><br>  Die nächste Gefahr lag in der Erhaltung und Herausgabe von Sonderzeichen.  Der Hauptteil einer Seite oder eines Kommentars kann in mehreren Ansichten abgerufen werden: Interner XML-Speicher, Zwischen-HTML ohne Makroausgabe-Ansicht und HTML mit Makroausgabe-export_view.  Der Titel des Seitentitels und der ursprünglich kommentierte Text originalSelection werden jedoch immer in einer zum Lesen geeigneten Form ausgegeben.  Weil  Zukünftig werden diese Daten mit Statistiken in den Hauptteil der Seite geschrieben, und einige Zeichen führen zu Konvertierungsfehlern.  Ich musste ein Ersatzverfahren oben schreiben. <br><br><h2>  Seitenkommentare </h2><br>  Nun zum Parsen der Seite.  Dies ist eine Prozedur, die eine Seite lädt, ihre Daten sammelt, dann eine Liste von Kommentaren mit Antworten herausholt und sie in Korrespondenz sammelt.  Das Ergebnis ist eine Liste von Wörterbüchern, wobei jedes Element der Liste einem Kommentar mit Antworten entspricht.  Und alle Attribute dieses Kommentars liegen in den entsprechenden Feldern des Wörterbuchs. <br><br><div class="spoiler">  <b class="spoiler_title">Einzelseitenverarbeitung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_comments_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page_identifier)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#,      ,  , #   , #  ,    ,    #   (). expand_text = ('body.storage,extensions.inlineProperties' ',extensions.resolution,version,children.comment' ',children.comment.version,children.comment.body.storage' ) #    .     . conf_page = confluence.get_page_by_id(page_identifier, expand='body.storage') page_title = replace_chars2(conf_page['title']) #   . link_base = conf_page['_links']['base'] page_link = link_base + conf_page['_links']['webui'] page_code = '&lt;a href="{}"&gt;{}&lt;/a&gt;'.format(page_link, page_title) #   page_comments = confluence.get_page_comments(content_id=page_identifier, start=0, limit=1000, comments = [] #    for comment in page_comments['results']: #      - . if comment['extensions']['location'] == 'footer': continue #  comment_text = comment['body']['storage']['value'] comment_result = comment['extensions']['resolution']['status'] comment_link = '&lt;a href="{}"&gt;{}&lt;/a&gt;'\ .format(link_base + comment['_links']['webui'], 'link') #  comment_link = re.sub(r'&amp;focusedCommentId=', '&amp;focusedCommentId=', comment_link) #  created_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', comment['version']['when'])) created_by = comment['version']['by']['displayName'] orig_text = replace_chars2(comment['extensions'] ['inlineProperties']['originalSelection']) #    /. thread = '&lt;b&gt;To text: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(orig_text, created_when, created_by, comment_text) last_by = '' last_when = '' #  answers = comment['children']['comment']['size'] if answers &gt; 0: for message in comment['children']['comment']['results']: #  last_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', message['version']['when'])) last_by = message['version']['by']['displayName'] #  thread += ('&lt;br/&gt;===next===&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(last_when, last_by, message['body']['storage']['value']) ) #  . row_comm = {"Page": page_code, "Comment": comment_link, "Thread": thread, "Result": comment_result, "Answers count": answers, "Creation Date": created_when, "Author": created_by, "Last Date": last_when, "Last Author": last_by} comments.append(row_comm) #   ,   , #     . if len(comments) == 0: row_comm = {"Page": page_code, "Comment": 'nolink', "Thread": 'nocomment', "Result": 'nocomment', "Answers count": 0, "Creation Date": 'never', "Author": 'nobody', "Last Date": 'never', "Last Author": 'nobody'} comments.append(row_comm) return comments</span></span></code> </pre></div></div><br><h2>  Statistiken und Tabellen </h2><br>  Zur Klarheit der Datenpräsentation sammeln wir Statistiken über diese und ordnen sie in Form von Tabellen an. <br><br><div class="spoiler">  <b class="spoiler_title">Wir verarbeiten Statistiken</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_statistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comments_data)</span></span></span><span class="hljs-function">:</span></span> open_count = <span class="hljs-number"><span class="hljs-number">0</span></span> dang_count = <span class="hljs-number"><span class="hljs-number">0</span></span> comment_count = len(comments_data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> comment_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> comment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comments_data: <span class="hljs-comment"><span class="hljs-comment">#     if comment['Result'] not in ['resolved', 'nocomment']: if comment['Result'] in ['open', 'reopened']: open_count += 1 if comment['Result'] == 'dangling' and comment['Author'] not in excludeNames: dang_count += 1 res_dict = {'Page': comments_data[0]['Page'], 'Total': comment_count, 'Resolved': comment_count - open_count - dang_count, 'Dangling': dang_count, 'Open': open_count} return res_dict #   def total_statistics(stat_data): total_comment = 0 total_resolved = 0 total_open = 0 total_dangling = 0 for statRow in stat_data: total_comment += statRow['Total'] total_resolved += statRow['Resolved'] total_open += statRow['Open'] total_dangling += statRow['Dangling'] res_dict = {'Page': 'All Pages Total', 'Type': '', 'Jira': '', 'Status': '', 'Total': total_comment, 'Resolved': total_resolved, 'Dangling': total_dangling, 'Open': total_open} return res_dict</span></span></code> </pre></div></div><br>  Um die Daten in Form von Tabellen zu erstellen, führen wir eine weitere Prozedur aus.  Es bildet den HTML-Code der Tabelle aus der Liste der Wörterbücher, fügt als Überschriften eine Zeile aus den Namen der Wörterbuchtasten und eine Spalte mit Zeilennummern hinzu. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tab_data)</span></span></span><span class="hljs-function">:</span></span> tab_start = <span class="hljs-string"><span class="hljs-string">'&lt;table style="width: 100.00%;"&gt;&lt;colgroup&gt;&lt;col /&gt;'</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;col /&gt;&lt;/colgroup&gt;&lt;tbody&gt;'</span></span> tab_end = <span class="hljs-string"><span class="hljs-string">'&lt;/tbody&gt;&lt;/table&gt;'</span></span> tab_code = tab_start + <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;'</span></span> row_num = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tab_data) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;Num&lt;/th&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data[<span class="hljs-number"><span class="hljs-number">0</span></span>].keys(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;{}&lt;/th&gt;'</span></span>.format(key) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(row_num) row_num += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row.values(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(field) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> tab_code += tab_end + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tab_code</code> </pre><br>  Jetzt ist alles fertig.  Nach dem Beschriften und Ausführen des Skripts erhalten wir eine Seite, die ungefähr so ​​aussieht: <br><br><img src="https://habrastorage.org/webt/-1/if/af/-1ifafmgt3mqvbayphkq7opy4mq.png"><br><br><h2>  PS </h2>  Das ist natürlich nicht alles, was sich am Ende herausgestellt hat.  Es wurde ein Seiten-Parsing durchgeführt und nach einem Makro mit der Aufgabennummer in Jira gesucht.  In Jira gab es eine automatische Kennzeichnung nach Aufgabennummern und Verknüpfungen von diesen zu Confluence.  Es wurde ein Vergleich und eine Überprüfung der wöchentlichen Lieferlisten durchgeführt.  In Excel wurden Kommentare gespeichert und gemeinsame Daten aus mehreren wöchentlichen Excel-Dateien gesammelt.  Und kürzlich wurde das Parsen von Kommentaren aus Word hinzugefügt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485652/">https://habr.com/ru/post/de485652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485636/index.html">CRISPR-resistente Viren bauen Schutzräume, um das Genom vor DNA-durchdringenden Enzymen zu schützen</a></li>
<li><a href="../de485640/index.html">Methoden zum Ausblenden von Webseiten</a></li>
<li><a href="../de485646/index.html">Nützliche Python-Tipps, die Sie noch nie zuvor getroffen haben. Teil 2</a></li>
<li><a href="../de485648/index.html">Der pythonische Ansatz für for: range () - und enumerate () - Schleifen</a></li>
<li><a href="../de485650/index.html">Docker-Bildverkleinerungstechniken</a></li>
<li><a href="../de485654/index.html">Eine Idee aus der Physik hilft der KI, in höheren Dimensionen zu arbeiten.</a></li>
<li><a href="../de485660/index.html">Das DDoS-Schutzunternehmen selbst habe DDoS-Angriffe gestartet, gab sein Gründer zu</a></li>
<li><a href="../de485664/index.html">Erstellen dynamischer Parameter in einem Jenkins-Job oder wie Sie Ihre Aufgabe benutzerfreundlich gestalten können</a></li>
<li><a href="../de485672/index.html">Redis Best Practices, Teil 1</a></li>
<li><a href="../de485682/index.html">Zeitmanagement wird nicht helfen: Aufschub ist das Problem der Regulierung von Emotionen, nicht Zeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>