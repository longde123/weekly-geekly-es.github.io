<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçå üöô üë®üèº‚Äçüç≥ Beeinflussen Sie die Statistik der Inline-Kommentare ‚óºÔ∏è üôç üö£üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie sammle ich Seitenkommentarstatistiken in Confluence? 

 Ja, und warum k√∂nnte das n√∂tig sein? 



 Warum und warum 
 In dem Projekt, in dem ich ger...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beeinflussen Sie die Statistik der Inline-Kommentare</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485652/">  Wie sammle ich Seitenkommentarstatistiken in Confluence? <br><br>  Ja, und warum k√∂nnte das n√∂tig sein? <br><br><img src="https://habrastorage.org/webt/c6/7x/uo/c67xuo6sop9dd7mpzxty_i7wj7s.png"><br><a name="habracut"></a><br><h2>  Warum und warum </h2><br>  In dem Projekt, in dem ich gerade gearbeitet habe, ist der folgende Prozess der Vorbereitung und Genehmigung von Anforderungen entstanden: <br><br><ul><li>  Confluence wurde f√ºr die Dokumentation verwendet. </li><li>  Das Lieferantenteam erstellte Beschreibungen der Gesch√§ftsprozesse und ihrer Schritte in Form von separaten Seiten entsprechend der Vorlage. </li><li>  Einmal pro Woche wurde dem Kunden eine Reihe vorbereiteter Beschreibungen zum Korrekturlesen √ºbergeben. </li><li>  Das Kundenteam hinterlie√ü alle Fragen und Erg√§nzungen in Form von eingebauten Kommentaren auf der entsprechenden Seite. </li><li>  Das Lieferantenteam erg√§nzte den Inhalt, beantwortete Kommentare und stellte Fragen f√ºr zus√§tzliche Studien. </li><li>  Wenn die Frage beantwortet und der Inhalt aktualisiert oder die Aufgabe f√ºr das Studium festgelegt wurde, sollte das Kundenteam den Kommentar schlie√üen. </li><li>  Fragen zu einem Stapel von Dokumenten aus der aktuellen Woche sollten geschlossen sein, bis der n√§chste Stapel n√§chste Woche √ºbertragen wird. </li></ul><br>  Projektmanager haben jede Woche die Aufgabe zu verstehen, wie viel der gelieferte Stapel von Dokumenten funktioniert hat und was davon als bedingt bereit angesehen werden kann.  Und die Teilnehmer des Lieferantenteams m√ºssen regelm√§√üig den Status der Kommentare zu ihren Dokumenten √ºberpr√ºfen und mit den anderen zielgerichtet zusammenarbeiten.  Aber wie findet man sie?  Sie k√∂nnen jede Seite √∂ffnen, den ersten Kommentar mit Ihren Augen suchen (oder mit Hilfe eines <a href="https://community.atlassian.com/t5/Confluence-questions/Search-for-unresolved-inline-comments/qaq-p/971424">kleinen Tricks</a> ) und dann auf alle Kommentare klicken, weil  Das Kundenteam hat es nicht eilig, sie zu schlie√üen, √ºber sie nachzudenken und nach einer Antwort zu suchen. <br><br>  Der w√∂chentliche Stapel enth√§lt 50-100 separate Seiten, und dies mit Ihren H√§nden zu tun, ist ein erheblicher Arbeitsaufwand.  Und wenn Sie immer noch versuchen, Argumente zu sammeln, um die andere Seite zu √ºberzeugen, wird es sehr traurig.  Und es gibt auch baumelnde Kommentare, die sich aus einer fehlerhaften Bearbeitung der Seite ergeben, wenn der Quelltext versehentlich gel√∂scht wird.  Ein solcher Kommentar ist in den aufgel√∂sten sichtbar, kann jedoch nicht wieder ge√∂ffnet werden (dies ist m√∂glich, wenn Sie eine unsichtbare Markierung im Text der Seite neu erstellen). <br><br>  Die Suche nach Tools war nicht erfolgreich.  Dar√ºber hinaus wird Confluence auf Kundenseite bereitgestellt. Sie k√∂nnen keine Plugins installieren, ganz zu schweigen vom Kauf.  Keine Makroentwicklungsexpertise. <br><br>  Irgendwann erinnerte ich mich an die Confluence- <a href="https://docs.atlassian.com/ConfluenceServer/rest/7.1.0/">REST-API</a> und an fr√ºhere Erfahrungen mit der Verwendung der √§hnlichen <a href="https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/">Jira-API</a> .  Suche und Experimente mit Aufruffunktionen aus dem Browser haben gezeigt, dass Sie zu den Kommentaren und deren Eigenschaften gelangen k√∂nnen.  Als N√§chstes mussten Sie ein Tool f√ºr die Automatisierung ausw√§hlen und k√∂nnen mit der L√∂sung beginnen.  Ich habe einige Erfahrungen mit der Erstellung von Skripten f√ºr Tools, die eher mit Administratoren wie Bash, Perl oder JScript zu tun haben.  Ich bin kein Entwickler, ich hatte keine vertrauten oder vertrauten Werkzeuge.  Ich wollte etwas √ºblicheres oder passenderes ausprobieren.  Dann entdeckte ich einen <a href="https://atlassian-python-api.readthedocs.io/en/latest/">Wrapper f√ºr die Python-API</a> und beschloss, es damit zu versuchen. <br><br><h2>  Allgemeines Prinzip </h2><br>  Das Problem wurde wie folgt formuliert.  Sie m√ºssen alle Seiten finden, die sich auf eine bestimmte w√∂chentliche Lieferung beziehen.  Sammeln Sie Kommentare dazu in einer Liste: Seite, Link zum Kommentar, Autor und Datum des Kommentars, Quelltext auf der Seite, Kommentar und Antworten, Autor und Datum der letzten Antwort, Status des Kommentars.  Sammeln Sie au√üerdem Statistiken f√ºr jede Seite, wie viele Kommentare insgesamt, wie viele Gefahren, wie viele ge√∂ffnet sind.  Speichern Sie alles auf einer speziellen Statistikseite. <br><br>  Ich setze Python ein, schaue mir die Grundlagen der Arbeit damit an und lass uns gehen.  Erstellen Sie zun√§chst eine Verbindung: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> atlassian <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Confluence UserLogin = <span class="hljs-string"><span class="hljs-string">'xxxxxx'</span></span> <span class="hljs-comment"><span class="hljs-comment"># input("Login: ") UserPwd = 'xxxxxx' # input("Password: ") confluenceURL = 'http://wiki.xxxxxx' confluence = Confluence( url=confluenceURL, username=UserLogin, password=UserPwd)</span></span></code> </pre> <br>  Um nach Seiten aus einem w√∂chentlichen Stapel zu suchen, habe ich mich f√ºr die Verwendung von Tags entschieden.  Wie man sie in gro√üen Mengen liefert, ist eine separate Aufgabe. <br><br><pre> <code class="python hljs">page_label = <span class="hljs-string"><span class="hljs-string">'week123'</span></span> cql = <span class="hljs-string"><span class="hljs-string">'space.key={} and label = "{}" and type = page '</span></span> <span class="hljs-string"><span class="hljs-string">'ORDER BY title '</span></span>.format(<span class="hljs-string"><span class="hljs-string">'YYY'</span></span>, page_label) pages = confluence.cql(cql, expand=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, start=<span class="hljs-number"><span class="hljs-number">0</span></span>, limit=<span class="hljs-number"><span class="hljs-number">200</span></span>)</code> </pre><br>  Also haben wir eine Liste von Seiten, die wir √ºberpr√ºfen m√ºssen.  Als n√§chstes bearbeiten wir jede einzelne Seite.  Wir erheben aus ihren Daten Kommentare mit ihren Parametern.  Basierend auf diesen Daten erstellen wir Statistiken dar√ºber, wie viele Kommentare auf der Seite vorhanden sind und unter welchen Bedingungen.  Als n√§chstes knocken wir das Ergebnis f√ºr alle Seiten aus und beginnen, das Ergebnis zu formatieren.  Wir erstellen den Hauptteil der Seite mit dem Ergebnis in Form einer Statistiktabelle und einer detaillierten Liste offener Kommentare. <br><br><div class="spoiler">  <b class="spoiler_title">Seitenlistenverarbeitung</b> <div class="spoiler_text"><pre> <code class="python hljs">statistics = [] open_comments = [] <span class="hljs-comment"><span class="hljs-comment">#  - ? if pages is not None: #    ? if pages['size'] &gt; 0: for page in pages['results']: print(page['title']) #       , #  page_comments = page_comments_data(page['content']['id']) #     statistics.append(page_statistics(page_comments)) #        #    . for comment in page_comments: if comment['Result'] not in ['resolved', 'nocomment']: if not (comment['Result'] == 'dangling' and comment['Author'] in excludeNames): open_comments.append(comment) #       . statistics.append(total_statistics(statistics)) #     page_id = confluence.get_page_id(space='YYY', title=page_title) #     ,    . page_body = ('&lt;p&gt;&lt;ac:structured-macro ac:name="toc" ac:schema-version="1"' '/&gt;&lt;/p&gt;' '&lt;h1&gt;Comments Statistics&lt;/h1&gt;{}' '&lt;h1&gt;Open Comments List&lt;/h1&gt;{}' ).format(create_table(statistics), create_table(open_comments)) #  if page_id is not None: status = confluence.update_page( page_id=page_id, title=page_title, body=page_body, representation='storage' )</span></span></code> </pre></div></div><br><h2>  API-Funktionen </h2><br>  Lassen Sie uns nun herausfinden, wie die Seite verarbeitet wird.  Standardm√§√üig gibt die API nur grundlegende Informationen zur√ºck, z. B. einen Bezeichner oder einen Seitennamen.  Alle zus√§tzlichen Eigenschaften m√ºssen explizit angegeben werden.  Sie k√∂nnen angezeigt werden, indem Sie das Ergebnis des Anrufs analysieren.  Zus√§tzliche Daten finden Sie in Abschnitten oder Unterabschnitten von _expandable.  Wir f√ºgen den gew√ºnschten Artikel zum Erweitern hinzu und schauen weiter, bis wir die erforderlichen Daten finden. <br><br><div class="spoiler">  <b class="spoiler_title">Issue-Beispiel</b> <div class="spoiler_text"><pre> <code class="json hljs">http://wiki.xxxxxx/rest/api/content/<span class="hljs-number"><span class="hljs-number">101743895</span></span>?expand=body,children.comment { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"97517865"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"current"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"w2019-47 comments status"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"children"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"comment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"results"</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"limit"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/child/page"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"styled_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"storage"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"anonymous_export_view"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"extensions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"_expandable"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"operations"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"restrictions"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/restriction/byOperation"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"history"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/history"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ancestors"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"descendants"</span></span>: <span class="hljs-string"><span class="hljs-string">"/rest/api/content/97517865/descendant"</span></span>, } }</code> </pre></div></div><br>  Und es gibt auch eine Beschr√§nkung der Anzahl der ausgegebenen Ergebnisse, die Paginierung.  Es ist serverseitig konfiguriert (API?) Und in unserem Fall ist es 25. Bei einigen Anforderungen kann es durch explizite Angabe ge√§ndert werden, funktioniert jedoch nur f√ºr die oberste Ebene.  Und wenn wir Kommentare zu der Seite ver√∂ffentlichen, bekommen wir trotzdem nur 25, w√§hrend die Gr√∂√üe auch falsch ist.  Im Beispiel waren es 29 in der Realit√§t.  Wir haben es geschafft, die Paginierung von Kommentaren mithilfe einer separaten Funktion im Confluence-Modul zu umgehen - get_page_comments mit der M√∂glichkeit, die Seitengr√∂√üe anzugeben. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    import re #      XML def replace_chars2(in_text): text = re.sub(r'&amp;', '&amp;', in_text) text = re.sub(r'\'', ''', text) text = re.sub(r'&lt;', '&lt;', text) text = re.sub(r'&gt;', '&gt;', text) text = re.sub(r'"', '"', text) return text</span></span></code> </pre><br>  Die n√§chste Gefahr lag in der Erhaltung und Herausgabe von Sonderzeichen.  Der Hauptteil einer Seite oder eines Kommentars kann in mehreren Ansichten abgerufen werden: Interner XML-Speicher, Zwischen-HTML ohne Makroausgabe-Ansicht und HTML mit Makroausgabe-export_view.  Der Titel des Seitentitels und der urspr√ºnglich kommentierte Text originalSelection werden jedoch immer in einer zum Lesen geeigneten Form ausgegeben.  Weil  Zuk√ºnftig werden diese Daten mit Statistiken in den Hauptteil der Seite geschrieben, und einige Zeichen f√ºhren zu Konvertierungsfehlern.  Ich musste ein Ersatzverfahren oben schreiben. <br><br><h2>  Seitenkommentare </h2><br>  Nun zum Parsen der Seite.  Dies ist eine Prozedur, die eine Seite l√§dt, ihre Daten sammelt, dann eine Liste von Kommentaren mit Antworten herausholt und sie in Korrespondenz sammelt.  Das Ergebnis ist eine Liste von W√∂rterb√ºchern, wobei jedes Element der Liste einem Kommentar mit Antworten entspricht.  Und alle Attribute dieses Kommentars liegen in den entsprechenden Feldern des W√∂rterbuchs. <br><br><div class="spoiler">  <b class="spoiler_title">Einzelseitenverarbeitung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_comments_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page_identifier)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#,      ,  , #   , #  ,    ,    #   (). expand_text = ('body.storage,extensions.inlineProperties' ',extensions.resolution,version,children.comment' ',children.comment.version,children.comment.body.storage' ) #    .     . conf_page = confluence.get_page_by_id(page_identifier, expand='body.storage') page_title = replace_chars2(conf_page['title']) #   . link_base = conf_page['_links']['base'] page_link = link_base + conf_page['_links']['webui'] page_code = '&lt;a href="{}"&gt;{}&lt;/a&gt;'.format(page_link, page_title) #   page_comments = confluence.get_page_comments(content_id=page_identifier, start=0, limit=1000, comments = [] #    for comment in page_comments['results']: #      - . if comment['extensions']['location'] == 'footer': continue #  comment_text = comment['body']['storage']['value'] comment_result = comment['extensions']['resolution']['status'] comment_link = '&lt;a href="{}"&gt;{}&lt;/a&gt;'\ .format(link_base + comment['_links']['webui'], 'link') #  comment_link = re.sub(r'&amp;focusedCommentId=', '&amp;focusedCommentId=', comment_link) #  created_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', comment['version']['when'])) created_by = comment['version']['by']['displayName'] orig_text = replace_chars2(comment['extensions'] ['inlineProperties']['originalSelection']) #    /. thread = '&lt;b&gt;To text: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(orig_text, created_when, created_by, comment_text) last_by = '' last_when = '' #  answers = comment['children']['comment']['size'] if answers &gt; 0: for message in comment['children']['comment']['results']: #  last_when = re.sub(r'\.000\+', ' GMT+', re.sub(r'T', ' ', message['version']['when'])) last_by = message['version']['by']['displayName'] #  thread += ('&lt;br/&gt;===next===&lt;br/&gt;&lt;b&gt;At: &lt;/b&gt;{}&lt;br/&gt;&lt;b&gt;By: ' '&lt;/b&gt;{}&lt;br/&gt;{}'.format(last_when, last_by, message['body']['storage']['value']) ) #  . row_comm = {"Page": page_code, "Comment": comment_link, "Thread": thread, "Result": comment_result, "Answers count": answers, "Creation Date": created_when, "Author": created_by, "Last Date": last_when, "Last Author": last_by} comments.append(row_comm) #   ,   , #     . if len(comments) == 0: row_comm = {"Page": page_code, "Comment": 'nolink', "Thread": 'nocomment', "Result": 'nocomment', "Answers count": 0, "Creation Date": 'never', "Author": 'nobody', "Last Date": 'never', "Last Author": 'nobody'} comments.append(row_comm) return comments</span></span></code> </pre></div></div><br><h2>  Statistiken und Tabellen </h2><br>  Zur Klarheit der Datenpr√§sentation sammeln wir Statistiken √ºber diese und ordnen sie in Form von Tabellen an. <br><br><div class="spoiler">  <b class="spoiler_title">Wir verarbeiten Statistiken</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">page_statistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comments_data)</span></span></span><span class="hljs-function">:</span></span> open_count = <span class="hljs-number"><span class="hljs-number">0</span></span> dang_count = <span class="hljs-number"><span class="hljs-number">0</span></span> comment_count = len(comments_data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> comment_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> comment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comments_data: <span class="hljs-comment"><span class="hljs-comment">#     if comment['Result'] not in ['resolved', 'nocomment']: if comment['Result'] in ['open', 'reopened']: open_count += 1 if comment['Result'] == 'dangling' and comment['Author'] not in excludeNames: dang_count += 1 res_dict = {'Page': comments_data[0]['Page'], 'Total': comment_count, 'Resolved': comment_count - open_count - dang_count, 'Dangling': dang_count, 'Open': open_count} return res_dict #   def total_statistics(stat_data): total_comment = 0 total_resolved = 0 total_open = 0 total_dangling = 0 for statRow in stat_data: total_comment += statRow['Total'] total_resolved += statRow['Resolved'] total_open += statRow['Open'] total_dangling += statRow['Dangling'] res_dict = {'Page': 'All Pages Total', 'Type': '', 'Jira': '', 'Status': '', 'Total': total_comment, 'Resolved': total_resolved, 'Dangling': total_dangling, 'Open': total_open} return res_dict</span></span></code> </pre></div></div><br>  Um die Daten in Form von Tabellen zu erstellen, f√ºhren wir eine weitere Prozedur aus.  Es bildet den HTML-Code der Tabelle aus der Liste der W√∂rterb√ºcher, f√ºgt als √úberschriften eine Zeile aus den Namen der W√∂rterbuchtasten und eine Spalte mit Zeilennummern hinzu. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tab_data)</span></span></span><span class="hljs-function">:</span></span> tab_start = <span class="hljs-string"><span class="hljs-string">'&lt;table style="width: 100.00%;"&gt;&lt;colgroup&gt;&lt;col /&gt;'</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;col /&gt;&lt;/colgroup&gt;&lt;tbody&gt;'</span></span> tab_end = <span class="hljs-string"><span class="hljs-string">'&lt;/tbody&gt;&lt;/table&gt;'</span></span> tab_code = tab_start + <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;'</span></span> row_num = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tab_data) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;Num&lt;/th&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data[<span class="hljs-number"><span class="hljs-number">0</span></span>].keys(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;th&gt;{}&lt;/th&gt;'</span></span>.format(key) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab_data: tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(row_num) row_num += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row.values(): tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;td&gt;{}&lt;/td&gt;'</span></span>.format(field) tab_code += <span class="hljs-string"><span class="hljs-string">'&lt;/tr&gt;'</span></span> tab_code += tab_end + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tab_code</code> </pre><br>  Jetzt ist alles fertig.  Nach dem Beschriften und Ausf√ºhren des Skripts erhalten wir eine Seite, die ungef√§hr so ‚Äã‚Äãaussieht: <br><br><img src="https://habrastorage.org/webt/-1/if/af/-1ifafmgt3mqvbayphkq7opy4mq.png"><br><br><h2>  PS </h2>  Das ist nat√ºrlich nicht alles, was sich am Ende herausgestellt hat.  Es wurde ein Seiten-Parsing durchgef√ºhrt und nach einem Makro mit der Aufgabennummer in Jira gesucht.  In Jira gab es eine automatische Kennzeichnung nach Aufgabennummern und Verkn√ºpfungen von diesen zu Confluence.  Es wurde ein Vergleich und eine √úberpr√ºfung der w√∂chentlichen Lieferlisten durchgef√ºhrt.  In Excel wurden Kommentare gespeichert und gemeinsame Daten aus mehreren w√∂chentlichen Excel-Dateien gesammelt.  Und k√ºrzlich wurde das Parsen von Kommentaren aus Word hinzugef√ºgt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485652/">https://habr.com/ru/post/de485652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485636/index.html">CRISPR-resistente Viren bauen Schutzr√§ume, um das Genom vor DNA-durchdringenden Enzymen zu sch√ºtzen</a></li>
<li><a href="../de485640/index.html">Methoden zum Ausblenden von Webseiten</a></li>
<li><a href="../de485646/index.html">N√ºtzliche Python-Tipps, die Sie noch nie zuvor getroffen haben. Teil 2</a></li>
<li><a href="../de485648/index.html">Der pythonische Ansatz f√ºr for: range () - und enumerate () - Schleifen</a></li>
<li><a href="../de485650/index.html">Docker-Bildverkleinerungstechniken</a></li>
<li><a href="../de485654/index.html">Eine Idee aus der Physik hilft der KI, in h√∂heren Dimensionen zu arbeiten.</a></li>
<li><a href="../de485660/index.html">Das DDoS-Schutzunternehmen selbst habe DDoS-Angriffe gestartet, gab sein Gr√ºnder zu</a></li>
<li><a href="../de485664/index.html">Erstellen dynamischer Parameter in einem Jenkins-Job oder wie Sie Ihre Aufgabe benutzerfreundlich gestalten k√∂nnen</a></li>
<li><a href="../de485672/index.html">Redis Best Practices, Teil 1</a></li>
<li><a href="../de485682/index.html">Zeitmanagement wird nicht helfen: Aufschub ist das Problem der Regulierung von Emotionen, nicht Zeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>