<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜£ï¸ ğŸ›¬ ğŸ‘ğŸ¿ Pengantar Pembelajaran Mesin ğŸŒ¬ï¸ ğŸ›ŒğŸ¾ ğŸ“¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kursus lengkap dalam bahasa Rusia dapat ditemukan di tautan ini . 
 Kursus bahasa Inggris asli tersedia di tautan ini . 



 Kuliah baru dijadwalkan s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Pembelajaran Mesin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  Kursus lengkap dalam bahasa Rusia dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . <br>  Kursus bahasa Inggris asli tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ini</a> . <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Kuliah baru dijadwalkan setiap 2-3 hari.</i> <br><br><h2>  Wawancara dengan Sebastian Trun, CEO Udacity </h2><br>  "Halo lagi, aku Paige dan kamu adalah tamuku hari ini, Sebastian." <br>  - Hai, saya Sebastian! <br>  - ... seorang pria yang memiliki karir yang luar biasa, yang berhasil melakukan banyak hal luar biasa!  Anda adalah salah satu pendiri Udacity, Anda mendirikan Google X, Anda adalah profesor di Stanford.  Anda telah melakukan penelitian luar biasa dan pembelajaran mendalam sepanjang karir Anda.  Apa yang paling memberi Anda kepuasan dan di bidang mana Anda menerima imbalan paling banyak untuk pekerjaan yang dilakukan? <br>  - Terus terang, saya sangat suka berada di Lembah Silikon!  Saya suka berada di sebelah orang-orang yang jauh lebih pintar daripada saya, dan saya selalu menganggap teknologi sebagai alat yang mengubah aturan main dalam berbagai cara - dari pendidikan hingga logistik, perawatan kesehatan, dll.  Semua ini berubah begitu cepat, dan ada keinginan yang luar biasa untuk menjadi peserta dalam perubahan ini, untuk mengamatinya.  Anda melihat sekeliling Anda dan memahami bahwa sebagian besar yang Anda lihat di sekitar tidak berfungsi sebagaimana mestinya - Anda selalu dapat menemukan sesuatu yang baru! <br>  - Nah, ini adalah pandangan yang sangat optimis tentang teknologi!  Apa eureka terbesar sepanjang karir Anda? <br>  - Tuhan, ada banyak sekali!  Saya ingat suatu hari ketika Larry Page menelepon saya dan menyarankan untuk membuat mobil autopilot yang dapat melewati semua jalan di California.  Pada saat itu saya dianggap ahli, saya mendapat peringkat di antara mereka dan, saya adalah orang yang mengatakan "tidak, ini tidak bisa dilakukan."  Setelah itu, Larry meyakinkan saya bahwa, pada prinsipnya, adalah mungkin untuk melakukan ini, Anda hanya perlu memulai dan mencoba.  Dan kami berhasil!  Ini adalah saat ketika saya menyadari bahwa bahkan para ahli pun salah dan mengatakan "tidak" kita 100% pesimistis.  Saya pikir kita harus lebih terbuka terhadap yang baru. <br>  - Atau, misalnya, jika Larry Page memanggil Anda dan berkata, "Hei, lakukan hal yang keren seperti Google X" dan Anda mendapatkan sesuatu yang sangat keren! <br>  - Ya, itu sudah pasti, tidak perlu mengeluh!  Maksud saya, semua ini adalah proses yang melewati banyak diskusi tentang cara implementasi.  Saya benar-benar beruntung bisa bekerja dan saya bangga akan hal itu, di Google X dan proyek lainnya. <br>  - Luar biasa!  Jadi, kursus ini adalah tentang bekerja dengan TensorFlow.  Apakah Anda memiliki pengalaman menggunakan TensorFlow atau mungkin Anda kenal (dengar) dengannya? <br>  - Ya!  Saya benar-benar menyukai TensorFlow, tentu saja!  Di laboratorium saya sendiri, kami sering menggunakannya dan banyak, salah satu karya paling signifikan berdasarkan TensorFlow dirilis sekitar dua tahun lalu.  Kami belajar bahwa iPhone dan Android bisa lebih efektif dalam mendeteksi kanker kulit daripada dokter kulit terbaik di dunia.  Kami menerbitkan penelitian kami di Nature dan ini menciptakan semacam keributan di bidang kedokteran. <br>  - Kedengarannya luar biasa!  Jadi, Anda tahu dan cinta TensorFlow, yang sangat bagus!  Sudahkah Anda bekerja dengan TensorFlow 2.0? <br>  - Tidak, sayangnya saya belum punya waktu. <br>  - Dia akan luar biasa!  Semua siswa dalam kursus ini akan bekerja dengan versi ini. <br>  - Aku iri pada mereka!  Saya pasti akan mencobanya! <br>  - Hebat!  Dalam kursus kami ada banyak siswa yang dalam kehidupan mereka tidak pernah terlibat dalam pembelajaran mesin, dari kata "sepenuhnya".  Bagi mereka, bidang mungkin baru, mungkin bagi seseorang pemrograman itu sendiri akan baru.  Apa saran Anda untuk mereka? <br>  - Saya ingin mereka tetap terbuka - untuk ide, teknik, solusi, posisi baru.  Pembelajaran mesin sebenarnya lebih mudah daripada pemrograman.  Dalam proses pemrograman, Anda perlu memperhitungkan setiap kasus dalam sumber data, mengadaptasi logika program dan aturan untuk itu.  Pada saat ini, menggunakan TensorFlow dan pembelajaran mesin, Anda pada dasarnya melatih komputer menggunakan contoh, membiarkan komputer menemukan aturannya sendiri. <br>  - Ini sangat menarik!  Saya tidak sabar untuk memberi tahu siswa dalam kursus ini sedikit lebih banyak tentang pembelajaran mesin!  Sebastian, terima kasih telah meluangkan waktu untuk datang kepada kami hari ini! <br>  - terima kasih  Tetap berkomunikasi! <br><br><h2>  Apa itu pembelajaran mesin? </h2><br>  Jadi, mari kita mulai dengan tugas berikut - memberikan nilai input dan output. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Ketika Anda memiliki nilai 0 sebagai nilai input, maka 32 sebagai nilai output. Ketika Anda memiliki 8 sebagai nilai input, maka 46,4 sebagai nilai output.  Ketika Anda memiliki 15 sebagai nilai input, maka 59 sebagai nilai output, dan seterusnya. <br><br>  Lihatlah lebih dekat nilai-nilai ini dan izinkan saya mengajukan pertanyaan kepada Anda.  Bisakah Anda menentukan apa yang akan dihasilkan jika kita mendapatkan 38 di input? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Jika Anda menjawab 100,4, maka Anda benar! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Jadi, bagaimana kita bisa menyelesaikan masalah ini?  Jika Anda melihat dengan cermat nilai-nilai itu, Anda bisa melihat bahwa itu terkait dengan ekspresi: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Di mana C - derajat Celcius (nilai input), F - Fahrenheit (nilai output). <br><br>  Apa yang baru saja dilakukan otak Anda - membandingkan nilai input dan nilai output dan menemukan model umum (koneksi, ketergantungan) di antaranya - inilah yang dilakukan pembelajaran mesin. <br><br>  Berdasarkan nilai input dan output, algoritma pembelajaran mesin akan menemukan algoritma yang sesuai untuk mengubah nilai input menjadi output.  Ini dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Mari kita lihat sebuah contoh.  Bayangkan kita ingin mengembangkan sebuah program yang akan mengubah derajat Celsius ke derajat Fahrenheit menggunakan rumus <code>F = C * 1.8 + 32</code> . <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  Solusinya, ketika mendekati dari sudut pandang pengembangan perangkat lunak tradisional, dapat diimplementasikan dalam bahasa pemrograman apa pun menggunakan fungsi: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Jadi apa yang kita miliki?  Fungsi mengambil nilai input C, kemudian menghitung nilai output F menggunakan algoritma eksplisit, dan kemudian mengembalikan nilai yang dihitung. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Di sisi lain, dalam pendekatan pembelajaran mesin, kami hanya memiliki nilai input dan output, tetapi bukan algoritma itu sendiri: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  Pendekatan pembelajaran mesin bergantung pada penggunaan jaringan saraf untuk menemukan hubungan antara nilai input dan output. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Anda dapat menganggap jaringan saraf sebagai tumpukan lapisan, yang masing-masing terdiri dari matematika (rumus) yang sebelumnya diketahui dan variabel internal.  Nilai input memasuki jaringan saraf dan melewati tumpukan lapisan neuron.  Saat melewati lapisan, nilai input dikonversi sesuai dengan matematika (rumus yang diberikan) dan nilai-nilai variabel internal lapisan, menghasilkan nilai output. <br><br>  Agar jaringan saraf dapat mempelajari dan menentukan hubungan yang benar antara nilai input dan output, kita perlu melatihnya - melatih. <br><br>  Kami melatih jaringan saraf melalui upaya berulang untuk mencocokkan nilai input dengan yang output. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  Dalam proses pelatihan, "fitting" (pemilihan) dari nilai-nilai variabel internal di lapisan jaringan saraf terjadi sampai jaringan belajar untuk menghasilkan nilai-nilai output yang sesuai dengan nilai input yang sesuai. <br><br>  Seperti yang akan kita lihat nanti, untuk melatih jaringan saraf dan memungkinkannya untuk memilih nilai-nilai variabel internal yang paling cocok, ribuan atau puluhan ribu iterasi (pelatihan) dilakukan. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Sebagai versi sederhana untuk memahami pembelajaran mesin, Anda dapat membayangkan algoritma pembelajaran mesin sebagai fungsi yang memilih nilai-nilai variabel internal sehingga nilai input yang benar sesuai dengan nilai output yang benar. <br><br>  Ada banyak jenis arsitektur jaringan saraf.  Namun, apa pun arsitektur yang Anda pilih, matematika di dalamnya (perhitungan mana yang dilakukan dan dalam urutan apa) akan tetap tidak berubah selama pelatihan.  Alih-alih mengubah matematika, variabel internal (bobot dan offset) berubah selama pelatihan. <br><br>  Misalnya, dalam tugas mengkonversi dari derajat Celcius ke Fahrenheit, model dimulai dengan mengalikan nilai input dengan angka tertentu (berat) dan menambahkan nilai lain (offset).  Pelatihan model terdiri dari menemukan nilai-nilai yang cocok untuk variabel-variabel ini, tanpa mengubah operasi multiplikasi dan penambahan yang dilakukan. <br><br>  Tapi satu hal keren untuk dipikirkan!  Jika Anda memecahkan masalah konversi derajat Celcius ke Fahrenheit, yang ditunjukkan dalam video dan dalam teks di bawah ini, Anda mungkin menyelesaikannya karena Anda memiliki pengalaman atau pengetahuan sebelumnya tentang cara melakukan konversi semacam ini dari derajat Celcius ke Fahrenheit.  Misalnya, Anda mungkin tahu bahwa 0 derajat Celcius sesuai dengan 32 derajat Fahrenheit.  Di sisi lain, sistem berbasis pembelajaran mesin tidak memiliki pengetahuan pendukung sebelumnya untuk menyelesaikan masalah.  Mereka belajar untuk memecahkan masalah seperti itu tidak berdasarkan pengetahuan sebelumnya dan dalam ketidakhadiran lengkap mereka. <br><br>  Cukup bicara - beralihlah ke bagian praktis dari perkuliahan! <br><br><h2>  CoLab: konversikan derajat Celcius ke derajat Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi Rusia dari kode sumber CoLab</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi bahasa Inggris dari kode sumber CoLab</a> . <br><br><h2>  Dasar-dasar: mempelajari model pertama </h2><br>  Selamat datang di CoLab, tempat kami akan melatih model pembelajaran mesin pertama kami! <br><br>  Kami akan berusaha menjaga kesederhanaan materi yang disajikan dan hanya memperkenalkan konsep dasar yang diperlukan untuk pekerjaan itu.  CoLabs selanjutnya akan berisi teknik yang lebih maju. <br><br>  Tugas yang akan kita selesaikan adalah konversi derajat Celcius ke derajat Fahrenheit.  Rumus konversi adalah sebagai berikut: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.425ex" height="2.419ex" viewBox="0 -780.1 7933.2 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-6B" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-61" x="3089" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-6C" x="3619" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMATHI-69" x="3917" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-31" x="4263" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-2C" x="4763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-38" x="5208" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-2B" x="5931" y="0"></use><g transform="translate(6932,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhjDTBswFbTOVknZN3Ixo8UOOBMXOw#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ kali 1,8 + 32 </script></p><br><br>  Tentu saja, akan lebih mudah untuk hanya menulis fungsi konversi dengan Python atau bahasa pemrograman lain yang akan melakukan perhitungan langsung, tetapi dalam hal ini tidak akan menjadi pembelajaran mesin :) <br><br>  Sebagai gantinya, kami memasukkan input TensorFlow derajat input kami yang tersedia Celcius (0, 8, 15, 22, 38) dan derajat Fahrenheit yang sesuai (32, 46, 59, 72, 100).  Kemudian kita akan melatih model sedemikian rupa sehingga kira-kira sesuai dengan rumus di atas. <br><br><h3>  Ketergantungan Impor </h3><br>  Hal pertama yang kami impor adalah <code>TensorFlow</code> .  Di sini dan di bawah ini kami menyebutnya dengan singkat <code>tf</code> .  Kami juga mengonfigurasi tingkat kesalahan hanya logging. <br><br>  Selanjutnya, impor <code>NumPy</code> sebagai <code>np</code> .  <code>Numpy</code> membantu kami menyajikan data sebagai daftar berperforma tinggi. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Persiapan data pelatihan </h3><br>  Seperti yang kita lihat sebelumnya, teknik pembelajaran mesin dengan guru didasarkan pada pencarian algoritma untuk mengkonversi data input ke output.  Karena tugas CoLab ini adalah membuat model yang dapat menghasilkan hasil konversi derajat Celcius ke derajat Fahrenheit, kami akan membuat dua daftar - <code>celsius_q</code> dan <code>fahrenheit_a</code> , yang kami gunakan saat melatih model kami. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Beberapa terminologi pembelajaran mesin: <br><br><ul><li>  <b>Properti</b> adalah nilai input dari model kami.  Dalam hal ini, nilai satuan adalah derajat Celcius. </li><li>  <b>Label</b> adalah nilai output yang diprediksi model kami.  Dalam hal ini, nilai satuan adalah derajat Fahrenheit. </li><li>  <b>Contohnya</b> adalah sepasang nilai input-output yang digunakan untuk pelatihan.  Dalam kasus ini, ini adalah sepasang nilai dari <code>celsius_q</code> dan <code>fahrenheit_a</code> bawah indeks tertentu, misalnya, (22,72). </li></ul><br><h2>  Buat model </h2><br>  Selanjutnya kita buat model.  Kami akan menggunakan model yang paling disederhanakan - model jaringan yang sepenuhnya terhubung (jaringan <code>Dense</code> ).  Karena tugasnya cukup sepele, jaringan juga akan terdiri dari satu lapisan dengan satu neuron. <br><br><h4>  Membangun jaringan </h4><br>  Kami akan memberi nama layer <code>l0</code> ( <b>l</b> ayer dan nol) dan membuatnya dengan menginisialisasi <code>tf.keras.layers.Dense</code> dengan parameter berikut: <br><br><ul><li>  <code>input_shape=[1]</code> - parameter ini menentukan dimensi parameter input - nilai tunggal.  1 Ã— 1 matriks dengan nilai tunggal.  Karena ini adalah lapisan pertama (dan satu-satunya), dimensi data input sesuai dengan dimensi keseluruhan model.  Satu-satunya nilai adalah nilai floating point yang mewakili derajat Celcius. </li><li>  <code>units=1</code> - parameter ini menentukan jumlah neuron dalam lapisan.  Jumlah neuron menentukan berapa banyak variabel lapisan internal yang akan digunakan untuk pelatihan dalam menemukan solusi untuk masalah tersebut.  Karena ini adalah lapisan terakhir, dimensinya sama dengan dimensi hasil - nilai keluaran model - angka titik-mengambang tunggal yang mewakili derajat Fahrenheit.  (Dalam jaringan multilayer, ukuran dan bentuk lapisan <code>input_shape</code> harus sesuai dengan ukuran dan bentuk lapisan berikutnya). </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Ubah layer menjadi model </h4><br>  Setelah lapisan didefinisikan mereka perlu dikonversi ke model.  <code>Sequential</code> mengambil argumen daftar lapisan dalam urutan di mana mereka harus diterapkan - dari nilai input ke nilai output. <br><br>  Model kami hanya memiliki satu lapisan - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Catatan</b> <br>  Cukup sering, Anda akan menemukan definisi layer secara langsung dalam fungsi model, daripada deskripsi awal dan penggunaan selanjutnya: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Kami mengkompilasi model dengan fungsi kehilangan dan optimisasi </h3><br>  Sebelum pelatihan, model harus dikompilasi (dirakit).  Saat menyusun untuk pelatihan, Anda perlu: <br><br><ul><li>  <b>fungsi kerugian</b> - cara mengukur seberapa jauh nilai prediksi dari nilai output yang diinginkan (perbedaan terukur disebut "kerugian"). </li><li>  <b>fungsi optimasi</b> - cara untuk menyesuaikan variabel internal untuk mengurangi kerugian. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  Fungsi kerugian dan fungsi optimisasi digunakan selama pelatihan model ( <code>model.fit(...)</code> disebutkan di bawah) untuk melakukan perhitungan awal pada setiap titik dan kemudian mengoptimalkan nilainya. <br><br>  Tindakan menghitung kerugian saat ini dan peningkatan selanjutnya dari nilai-nilai ini dalam model adalah pelatihan apa (satu iterasi). <br><br>  Selama pelatihan, fungsi optimisasi digunakan untuk menghitung penyesuaian nilai-nilai variabel internal.  Tujuannya adalah untuk menyesuaikan nilai-nilai variabel internal sedemikian rupa dalam model (dan ini, pada kenyataannya, adalah fungsi matematika) sehingga mereka mencerminkan sedekat mungkin ekspresi yang ada untuk mengkonversi derajat Celcius ke derajat Fahrenheit. <br><br>  TensorFlow menggunakan analisis numerik untuk melakukan operasi optimasi semacam ini, dan semua kompleksitas ini tersembunyi dari mata kami, jadi kami tidak akan membahas detail dalam kursus ini. <br><br>  Apa yang berguna untuk diketahui tentang opsi-opsi ini: <br><br>  Fungsi kerugian (kesalahan standar) dan fungsi optimisasi (Adam) yang digunakan dalam contoh ini adalah standar untuk model sederhana seperti itu, tetapi banyak yang lain tersedia di samping mereka.  Pada tahap ini, kami tidak peduli bagaimana fungsi ini bekerja. <br><br>  Yang harus Anda perhatikan adalah fungsi optimasi dan parameternya adalah koefisien <code>learning rate</code> , yang dalam contoh kami adalah <code>0.1</code> .  Ini adalah ukuran langkah yang digunakan ketika menyesuaikan nilai internal variabel.  Jika nilainya terlalu kecil, akan membutuhkan terlalu banyak iterasi pelatihan untuk melatih model.  Terlalu banyak - akurasi turun.  Menemukan nilai yang baik untuk koefisien tingkat pembelajaran memerlukan beberapa coba-coba, biasanya terletak pada kisaran <code>0.01</code> (secara default) hingga <code>0.1</code> . <br><br><h4>  Kami melatih model </h4><br>  Pelatihan model dilakukan dengan metode <code>fit</code> . <br><br>  Selama pelatihan, model menerima derajat Celcius pada input, melakukan transformasi menggunakan nilai-nilai variabel internal (disebut "bobot") dan mengembalikan nilai yang harus sesuai dengan derajat Fahrenheit.  Karena nilai awal bobot diatur secara sewenang-wenang, nilai yang dihasilkan akan jauh dari nilai yang benar.  Perbedaan antara hasil yang diinginkan dan aktual dihitung menggunakan fungsi kerugian, dan fungsi optimisasi menentukan bagaimana bobot harus disesuaikan. <br><br>  Siklus perhitungan, perbandingan, dan penyesuaian ini dikendalikan dalam metode <code>fit</code> .  Argumen pertama adalah nilai input, argumen kedua adalah nilai output yang diinginkan.  Argumen <code>epochs</code> menentukan berapa kali siklus pelatihan ini harus diselesaikan.  Argumen <code>verbose</code> mengontrol level logging. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  Dalam video-video berikut, kami akan menyelami rincian tentang bagaimana semua ini bekerja dan bagaimana tepatnya lapisan yang terhubung sepenuhnya (lapisan <code>Dense</code> ) "di bawah tenda". <br><br><h4>  Tampilkan statistik pelatihan </h4><br>  Metode <code>fit</code> mengembalikan objek yang berisi informasi tentang perubahan kerugian dengan setiap iterasi berikutnya.  Kita dapat menggunakan objek ini untuk membuat jadwal kerugian yang sesuai.  Kehilangan tinggi berarti bahwa derajat Fahrenheit yang diprediksi oleh model jauh dari nilai sebenarnya dalam array <code>fahrenheit_a</code> . <br><br>  Untuk visualisasi, kita akan menggunakan <code>Matplotlib</code> .  Seperti yang Anda lihat, model kami meningkat dengan sangat cepat di awal, dan kemudian mencapai peningkatan yang stabil dan lambat sampai hasilnya menjadi "dekat" -sempurna di akhir pelatihan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Kami menggunakan model untuk prediksi. </h4><br>  Sekarang kami memiliki model yang telah dilatih tentang nilai input <code>celsius_q</code> dan nilai output <code>fahrenheit_a</code> untuk menentukan hubungan di antara mereka.  Kita dapat menggunakan metode prediksi untuk menghitung derajat Fahrenheit yang sebelumnya kita tidak tahu derajat Celsius yang sesuai. <br><br>  Misalnya, berapa 100,0 derajat Celcius Fahrenheit?  Coba tebak sebelum Anda menjalankan kode di bawah ini. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Kesimpulan: <br><br> <code>[[211.29639]] <br></code> <br><br>  Jawaban yang benar adalah 100 Ã— 1,8 + 32 = 212, jadi model kami melakukannya dengan cukup baik! <br><br>  <b>Ulasan</b> <br><br><ul><li>  Kami membuat model menggunakan layer <code>Dense</code> . </li><li>  Kami melatihnya dengan 3.500 contoh (7 pasang nilai, 500 iterasi pelatihan) </li></ul><br>  Model kami menyesuaikan nilai-nilai variabel internal (bobot) di lapisan <code>Dense</code> sedemikian rupa untuk mengembalikan nilai derajat Fahrenheit yang benar ke nilai input sembarang derajat Celcius. <br><br><h3>  Kami melihat bobotnya </h3><br>  Mari kita tampilkan nilai-nilai variabel internal layer <code>Dense</code> . <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  Nilai variabel pertama mendekati ~ 1,8, dan yang kedua hingga ~ 32.  Nilai-nilai ini (1,8 dan 32) adalah nilai langsung dalam rumus untuk mengkonversi derajat Celcius ke derajat Fahrenheit. <br><br>  Ini benar-benar sangat dekat dengan nilai aktual dalam rumus!  Kami akan mempertimbangkan hal ini secara lebih rinci dalam video berikutnya, di mana kami menunjukkan cara kerja lapisan <code>Dense</code> , tetapi untuk sekarang Anda hanya perlu tahu bahwa satu neuron dengan input dan output tunggal berisi matematika sederhana - <code>y = mx + b</code> (sebagai persamaan direct), yang tidak lebih dari rumus kami untuk mengonversi derajat Celsius ke derajat Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Karena representasi yang sama, nilai-nilai variabel internal model harus menyatu dengan yang disajikan dalam rumus aktual, yang terjadi pada akhirnya. <br><br>  Dengan adanya neuron tambahan, nilai input tambahan dan nilai output, formula menjadi sedikit lebih rumit, tetapi esensinya tetap sama. <br><br><h4>  Sedikit eksperimen </h4><br>  Untuk bersenang-senang!  Apa yang terjadi jika kita membuat lebih banyak lapisan <code>Dense</code> dengan lebih banyak neuron, yang pada gilirannya akan mengandung lebih banyak variabel internal? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Seperti yang mungkin Anda perhatikan, model saat ini juga mampu memprediksi derajat Fahrenheit dengan cukup baik.  Namun, jika kita melihat nilai-nilai variabel internal (bobot) neuron demi lapis, maka kita tidak akan melihat nilai apa pun yang mirip dengan 1,8 dan 32.  Kompleksitas tambahan dari model menyembunyikan bentuk "sederhana" dari konversi derajat Celcius ke derajat Fahrenheit. <br><br>  Tetap terhubung dan di bagian selanjutnya kita akan melihat bagaimana lapisan padat bekerja "di bawah tenda". <br><br><h3>  Ringkasan Singkat </h3><br>  Selamat!  Anda baru saja melatih model pertama Anda.  Dalam praktiknya, kami melihat bagaimana, dengan nilai input dan output, model belajar mengalikan nilai input dengan 1,8 dan menambahkan 32 untuk mendapatkan hasil yang benar. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Ini sangat mengesankan, mengingat berapa banyak baris kode yang perlu kami tulis: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  Contoh di atas adalah rencana umum untuk semua program pembelajaran mesin.  Anda akan menggunakan konstruksi serupa untuk membuat dan melatih jaringan saraf dan untuk memecahkan masalah berikutnya. <br><br><h3>  Proses pelatihan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses pelatihan (berlangsung dalam metode </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) terdiri dari urutan tindakan yang sangat sederhana, yang hasilnya harus berupa nilai variabel internal yang memberikan hasil sedekat mungkin dengan aslinya. </font><font style="vertical-align: inherit;">Proses optimasi dimana hasil tersebut dicapai, disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gradient descent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menggunakan analisis numerik untuk menemukan nilai yang paling cocok untuk variabel internal model.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk terlibat dalam pembelajaran mesin, Anda, pada prinsipnya, tidak perlu memahami detail ini. Tetapi bagi mereka yang masih tertarik untuk belajar lebih banyak: penurunan gradien melalui iterasi mengubah nilai parameter sedikit, "menarik" mereka ke arah yang benar sampai hasil terbaik diperoleh. Dalam hal ini, "hasil terbaik" (nilai terbaik) berarti bahwa setiap perubahan parameter selanjutnya hanya akan memperburuk hasil model. Fungsi yang mengukur seberapa baik atau buruk model pada setiap iterasi disebut â€œfungsi kerugianâ€, dan tujuan dari setiap â€œtarikanâ€ (penyesuaian nilai internal) adalah untuk mengurangi nilai fungsi kerugian.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses pelatihan dimulai dengan blok "distribusi langsung", di mana parameter input pergi ke input jaringan saraf, ikuti neuron tersembunyi dan kemudian pergi ke akhir pekan. Model kemudian menerapkan transformasi internal pada nilai input dan variabel internal untuk memprediksi respons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh kami, nilai input adalah suhu dalam derajat Celcius dan model memperkirakan nilai yang sesuai dalam derajat Fahrenheit. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah nilainya diprediksi, perbedaan antara nilai yang diprediksi dan yang benar dihitung. Perbedaannya disebut "kehilangan" dan merupakan bentuk pengukuran seberapa baik model bekerja. Nilai kerugian dihitung oleh fungsi kerugian, yang kami tentukan oleh salah satu argumen saat memanggil metode </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menghitung nilai kerugian, variabel internal (bobot dan perpindahan) dari semua lapisan jaringan saraf disesuaikan untuk meminimalkan nilai kehilangan untuk memperkirakan nilai output ke nilai referensi awal yang benar. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses pengoptimalan ini disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gradient descent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Algoritma optimisasi spesifik digunakan untuk menghitung nilai baru untuk setiap variabel internal ketika metode dipanggil </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dalam contoh di atas, kami menggunakan algoritme pengoptimalan </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memahami prinsip-prinsip proses pelatihan tidak diperlukan untuk kursus ini, namun, jika Anda cukup ingin tahu Anda dapat menemukan informasi lebih lanjut tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Crash Course</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Terjemahan dan bagian praktis dari seluruh kursus diatur dalam rencana penulis untuk publikasi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, Anda harus sudah mengenal istilah-istilah berikut:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nilai input dari model kami;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : pasangan input + output;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nilai output model;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : kumpulan node yang bergabung bersama dalam jaringan saraf;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : representasi jaringan saraf Anda;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Padat dan terhubung sepenuhnya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : setiap simpul dalam satu lapisan terhubung ke setiap simpul dari lapisan sebelumnya.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bobot dan offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : model variabel internal;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehilangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : perbedaan antara nilai output yang diinginkan dan nilai output aktual dari model;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  Â«Â»       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kembali propagasi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : menghitung nilai-nilai variabel internal sesuai dengan algoritma optimasi mulai dari lapisan keluaran dan menuju lapisan input melalui semua lapisan menengah.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sense layers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian sebelumnya, kami menciptakan model yang mengubah derajat Celsius ke derajat Fahrenheit, menggunakan jaringan saraf sederhana untuk menemukan hubungan antara derajat Celcius dan derajat Fahrenheit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaringan kami terdiri dari satu lapisan yang sepenuhnya terhubung. </font><font style="vertical-align: inherit;">Tapi apa itu lapisan yang terhubung sepenuhnya? </font><font style="vertical-align: inherit;">Untuk mengetahuinya, mari buat jaringan saraf yang lebih kompleks dengan 3 parameter input, satu layer tersembunyi dengan dua neuron dan satu layer output dengan satu neuron.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingatlah bahwa jaringan saraf dapat dibayangkan sebagai seperangkat lapisan, yang masing-masing terdiri dari node yang disebut neuron. Neuron pada setiap level dapat dihubungkan ke neuron dari setiap lapisan berikutnya. Jenis lapisan di mana setiap neuron dari satu lapisan terhubung satu sama lain neuron dari lapisan berikutnya disebut sepenuhnya terhubung (sepenuhnya terhubung) atau lapisan padat ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-pemain). </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, ketika kita menggunakan lapisan yang terhubung penuh </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita semacam menginformasikan bahwa neuron dari lapisan ini harus terhubung ke semua neuron dari lapisan sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat jaringan saraf di atas, ekspresi berikut cukup bagi kami:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami menemukan apa itu neuron dan bagaimana mereka berhubungan. Tetapi bagaimana sebenarnya lapisan yang terhubung sepenuhnya berfungsi? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami apa yang sebenarnya terjadi di sana dan apa yang mereka lakukan, kita perlu melihat "di balik tudung" dan membongkar matematika internal neuron. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bayangkan bahwa model kami menerima tiga parameter - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- neuron jaringan kami. Ingat kami mengatakan bahwa neuron memiliki variabel internal? Jadi, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah variabel internal yang sama dari neuron, juga dikenal sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bobot</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpindahan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nilai-nilai dari variabel-variabel ini yang disesuaikan dalam proses pembelajaran untuk mendapatkan hasil paling akurat dari membandingkan nilai input dengan output. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pasti harus Anda ingat adalah bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matematika internal neuron tetap tidak berubah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dengan kata lain, selama proses pelatihan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bobot dan perpindahan yang </font><font style="vertical-align: inherit;">berubah </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda mulai belajar pembelajaran mesin, mungkin terasa aneh - fakta bahwa itu benar-benar berfungsi, tetapi itulah cara pembelajaran mesin bekerja! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke contoh konversi derajat Celsius ke derajat Fahrenheit.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan satu neuron, kita hanya memiliki satu berat dan satu perpindahan. Apakah kamu tahu? Persis seperti inilah rumus untuk mengubah derajat Celsius ke derajat Fahrenheit. Jika kita mengganti </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilainya </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan bukannya </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita mendapatkan model transformasi akhir! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita kembali ke hasil model kita dari bagian praktis, kita memperhatikan fakta bahwa indikator bobot dan perpindahan â€œdikalibrasiâ€ sedemikian rupa sehingga kira-kira sesuai dengan nilai-nilai dari formula.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sengaja menciptakan contoh praktis untuk menunjukkan perbandingan yang tepat antara bobot dan offset. Dengan menerapkan pembelajaran mesin, kita tidak akan pernah bisa membandingkan nilai variabel dengan algoritma target dengan cara ini, seperti pada contoh di atas. Bagaimana kita bisa melakukan ini? Tidak mungkin, karena kami bahkan tidak tahu algoritma target! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memecahkan masalah pembelajaran mesin, kami menguji berbagai arsitektur jaringan saraf dengan jumlah neuron yang berbeda di dalamnya - dengan coba-coba kami menemukan arsitektur dan model yang paling akurat dan berharap mereka memecahkan masalah dalam proses pembelajaran. Pada bagian praktis berikutnya, kita akan dapat mempelajari contoh-contoh spesifik dari pendekatan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap berkomunikasi, karena sekarang kesenangan dimulai!</font></font><br><br><h3>  Ringkasan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pelajaran ini kita belajar pendekatan dasar dalam pembelajaran mesin dan belajar bagaimana lapisan yang terhubung sepenuhnya ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-layers) bekerja. </font><font style="vertical-align: inherit;">Anda melatih model pertama Anda untuk mengonversi derajat Celsius ke derajat Fahrenheit. </font><font style="vertical-align: inherit;">Anda juga mempelajari istilah dasar yang digunakan dalam pembelajaran mesin, seperti properti, contoh, label. </font><font style="vertical-align: inherit;">Anda, antara lain, menulis baris utama kode dengan Python, yang merupakan tulang punggung dari algoritma pembelajaran mesin apa pun. </font><font style="vertical-align: inherit;">Anda melihat bahwa dalam beberapa baris kode Anda dapat membuat, melatih dan meminta prediksi dari jaringan saraf menggunakan </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... dan ajakan bertindak standar - daftar, beri nilai tambah, dan bagikan :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi video artikel</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegram: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453558/">https://habr.com/ru/post/id453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453542/index.html">Robot berkaki empat itu mampu menderek pesawat berbobot 3,3 ton</a></li>
<li><a href="../id453544/index.html">Seven-segment decoder menggunakan output BCD langsung dan terbalik</a></li>
<li><a href="../id453546/index.html">Butuh keyboard kecil - lakukan sendiri</a></li>
<li><a href="../id453548/index.html">Kami menghidupkan kembali pengereman Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../id453554/index.html">Bagaimana Starlink dari SpaceX Berubah</a></li>
<li><a href="../id453562/index.html">Acara digital di Moskow dari 27 Mei hingga 2 Juni</a></li>
<li><a href="../id453564/index.html">Make it True - Mengembangkan permainan logika di Unity</a></li>
<li><a href="../id453566/index.html">Pulihkan legenda: seruan untuk pertukaran data terbuka yang dapat membantu dalam pemulihan Notre Dame</a></li>
<li><a href="../id453568/index.html">Membangun kembali ikon: panggilan untuk berbagi data terbuka untuk membantu memulihkan Notre-Dame</a></li>
<li><a href="../id453570/index.html">Microsoft Edge untuk macOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>