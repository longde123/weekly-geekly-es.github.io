<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 🔗 🧢 使用任意机器学习模型在Apache Spark上对大量数据进行分类 🖲️ 🏖️ 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第2部分：解决方案 
 你好！ 今天，我将继续讲述我们如何使用任意机器学习模型在Apache Spark上对大量数据进行分类的故事。 在本文的第一部分中，我们研究了问题本身的陈述以及组织初始数据在其上存储和处理的集群与外部分类服务之间的交互时出现的主要问题。 在第二部分中，我们将考虑使用Reacti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用任意机器学习模型在Apache Spark上对大量数据进行分类</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2> 第2部分：解决方案 </h2><br> 你好！ 今天，我将继续讲述我们如何使用任意机器学习模型在Apache Spark上对大量数据进行分类的故事。 在本文的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中，</a>我们研究了问题本身的陈述以及组织初始数据在其上存储和处理的集群与外部分类服务之间的交互时出现的主要问题。 在第二部分中，我们将考虑使用Reactive Streams方法解决此问题的一种方法，以及使用akka-streams库实现的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3> 反应流概念 </h3><br> 要解决第一部分中描述的问题，您可以使用称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reactive Streams</a>的方法。 它使您可以控制在处理阶段之间传输数据流的过程，以不同的速度运行并且彼此独立，而无需缓冲。 如果其中一个处理阶段比上一个阶段慢，则有必要向更快的阶段发出信号，告知它目前准备处理多少输入数据。 这种相互作用称为背压。 它包含以下事实：较快的阶段处理的元素数量与较慢的阶段所需的元素数量一样多，而不是更多，然后释放了计算资源。 <br><br> 通常，反应式流是用于实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布者-订阅者</a>模板的规范。 该规范定义了一组四个接口（发布者，订阅者，处理器和订阅）以及它们的方法的协定。 <br><br> 让我们更详细地考虑以下接口： <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br> 发布者-订阅者模型有两个方面：发送和接收。 在实现反应式流时，实现Publisher接口的类负责数据传输，而Subscriber负责接收。 若要在它们之间建立通信，必须通过调用其Subscriber方法向Publisher注册注册。 根据规范，在注册订阅服务器后，发布者必须按以下顺序调用其方法： <br><br><ol><li>  onSubscribe。 向发布服务器注册订阅服务器后，立即调用此方法。 作为参数，订阅对象将传递给它，订阅者将通过该对象向发布者请求数据。 此对象应仅在此订户的上下文中存储和调用。 </li><li> 订阅服务器通过在相应的Subscription对象上调用request方法从发布服务器请求数据后，发布服务器可以调用订阅服务器的onNext方法，并传递下一个元素。 </li><li> 然后，订阅者可以定期在Subscription上调用request方法，但是Publisher不能调用onNext方法，而不能超过通过request方法请求的总数。 </li><li> 如果数据流是有限的，则在将所有元素传递给onNext方法之后，发布者必须调用onComplete方法。 </li><li> 如果Publisher中发生错误，并且无法进一步处理元素，则应调用onError方法 </li><li> 调用onComplete或onError方法后，应排除发布者与订阅者的进一步交互。 </li></ol><br> 方法调用可以视为在发布者和订阅者之间发送信号。 订阅服务器向发布服务器发出信号，指示它准备处理多少个元素，而发布服务器又向其发出信号，表明存在下一个元素，或者没有其他元素，或者发生了一些错误。 <br><br> 为了排除发布者和订阅者彼此之间的另一个影响，对实现反应式流接口的所有方法的调用必须是非阻塞的。 在这种情况下，它们之间的交互将完全异步。 <br><br> 可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关Reactive Streams接口规范的更多详细信息。 <br><br> 因此，通过将原始迭代器和生成的迭代器分别转换为Publisher和Subscriber来链接它们，我们可以解决本文前面部分中确定的问题。 通过订阅服务器请求一定数量的元素，可以解决阶段之间的缓冲区溢出问题。 通过分别通过onComplete或onError方法向订户发送信号来解决成功或不成功完成的问题。  Publisher负责发送这些信号，在我们的情况下，这些信号必须控制发送了多少HTTP请求以及其中有多少接收了响应。 收到最后一个响应并处理了所有返回结果后，它应该发送一个onComplete信号。 万一其中一个请求失败，它应该发送一个onError信号，并停止向订阅服务器发送其他元素，并从原始迭代器中减去元素。 <br><br> 生成的迭代器应实现为订阅服务器。 在这种情况下，我们不能没有一个缓冲区，当从Subscriber接口调用onNext方法时，将在其中写入元素，并从Iterator接口使用hasNext和next方法将其减去。 作为缓冲区实现，可以使用阻塞队列，例如LinkedBlockedQueue。 <br><br> 细心的读者会立即问一个问题：阻塞队列为什么是阻塞队列，因为根据Reactive Streams规范，所有方法的实现都应该是非阻塞的？ 但这没什么问题：由于我们要向Publisher要求严格定义数量的元素，因此onNext方法的调用次数不得超过此次数，并且队列始终可以添加新元素而不会阻塞。 <br><br> 另一方面，在队列为空的情况下调用hasNext方法时，可能会发生阻塞。 但是，没关系：hasNext方法不是Subscriber接口协定的一部分，它是在Iterator接口中定义的，正如我们前面所解释的，Iterator接口是一个阻塞数据结构。 调用next方法时，我们从队列中减去下一个元素，并且当其大小变得小于某个阈值时，我们将需要通过调用request方法来请求元素的下一部分。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>图7.使用Reactive Streams方法与外部服务进行异步交互</i> <br><br> 当然，在这种情况下，我们不会完全摆脱阻塞呼叫。 这是由于Reactive流之间的范式不匹配而导致的，后者假定完全异步交互，而后者在调用hasNext方法时必须调用trueN或false。 但是，与与外部服务的同步交互不同，可以通过增加处理器内核的总体负载来显着减少由于锁定导致的停机时间。 <br><br> 如果将来的版本中Apache Spark开发人员实现了可与Publisher和Subscriber一起使用的mapPartitions方法的类似物，将会很方便。 这将允许完全异步的交互，从而消除了阻塞线程的可能性。 <br><br><h3>  Akka-streams和akka-http作为Reactive Streams规范的实现 </h3><br> 当前，已经有十几个Reactive Streams规范的实现。 一种这样的实现是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">akka</a>库中的akka​​-streams模块。 在JVM的世界中，akka已经确立了其作为编写并行和分布式系统的最有效手段之一。 之所以能够实现这一目标，是因为其基础上奠定了基本原理，那就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参与者模型</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模型</a>使您可以编写竞争激烈的应用程序而无需直接控制线程及其池。 <br><br> 关于在akka中执行演员概念的方法已有许多文献报道，所以我们不会在此止步（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">akka的官方网站</a>是很好的信息来源，我也推荐<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">akka在行动中使用</a> ）。 在这里，我们将仔细研究JVM下实现的技术方面。 <br><br> 通常，参与者不是一个人存在，而是形成一个等级系统。 为了创建一个actor系统，您需要为其分配资源，因此使用akka的第一步是创建ActorSystem对象的实例。 当ActorSystem启动时，将创建一个单独的线程池，称为调度程序，其中将执行actor中定义的所有代码。 通常，一个线程执行多个参与者的代码，但是，如有必要，您可以为一组特定的参与者（例如，直接与阻塞API交互的参与者）配置单独的调度程序。 <br><br> 使用参与者解决的最常见任务之一是数据流的顺序处理。 以前，为此，必须手动构建actor链并确保它们之间没有瓶颈（例如，如果一个actor处理消息的速度比下一个actor快，那么他可能会传入消息队列溢出，从而导致OutOfMemoryError错误）。 <br><br> 从2.4版开始，akka-streams模块已添加到akka中，它允许您声明性地定义数据处理过程，然后为执行它创建必要的参与者。  Akka流还实现了反压原理，从而消除了处理中涉及的所有参与者溢出传入消息队列的可能性。 <br><br> 定义akka流中数据流处理方案的主要元素是Source，Flow和Sink。 通过将它们彼此组合，我们得到了一个可运行图。 要开始处理过程，将使用一个实现器，它会根据我们定义的图形（实现器接口及其实现ActorMaterializer）创建执行器。 <br><br> 让我们更详细地考虑阶段Source，Flow和Sink。 源定义数据源。  Akka-streams支持十几种不同的方法来创建源，包括从迭代器中进行创建： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br> 也可以通过转换现有源来获得源： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br> 如果转换是不平凡的操作，则可以将其表示为Flow实体。  Akka流支持多种创建Flow的方式。 最简单的方法是从函数创建： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br> 通过结合Source和Flow，我们得到了一个新Source。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br> 接收器用作数据处理的最后阶段。 与Source一样，akka-streams提供了十几个不同的Sink选项，例如，Sink.foreach为每个元素执行特定的操作，Sink.seq收集集合中的所有元素，等等。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br> 源，流和接收器分别通过输入和/或输出元素的类型进行参数化。 另外，每个处理阶段可能都有其工作结果。 为此，还可以通过确定操作结果的其他类型对Source，Flow和Sink进行参数化。 此类型称为实现值的类型。 如果该操作不表示存在其工作的其他结果，例如，当我们定义通过函数的流时，则将NotUsed类型用作实现值。 <br><br> 结合必要的Source，Flow和Sink，我们得到RunnableGraph。 它通过一种类型进行参数化，该类型确定了执行此图所获得的值的类型。 如有必要，在合并阶段时，您可以指定哪个阶段的结果将是整个操作图的结果。 默认情况下，采用Source阶段的结果： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br> 但是，如果接收阶段的结果对我们来说更重要，那么我们必须明确指出： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br> 定义操作图后，必须运行它。 为此，runnableGraph需要调用run方法。 作为一种参数，此方法采用ActorMaterializer对象（也可以在隐式范围内），该对象负责创建将执行操作的actor。 通常，ActorMaterializer是在ActorSystem创建后立即创建的，并附加到其生命周期，并使用它来创建actor。 考虑一个例子： <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(“system name”) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br> 在简单组合的情况下，您可以不创建单独的RunnableGraph而做，而只需将Source连接到Sink并通过在Source上调用runWith方法来启动它们。 此方法还假定隐式范围中存在ActorMaterializer对象。 另外，在这种情况下，将使用Sink中定义的物化值。 例如，使用以下代码，我们可以从Reactive Streams规范将Source转换为Publisher： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br> 因此，现在我们展示了如何通过从源迭代器创建Source并对其元素执行一些转换来获取Reactive Streams Publisher。 现在，我们可以将其与为数据提供给最终迭代器的订阅服务器关联。 还有一个问题要考虑：如何组织与外部服务的HTTP交互。 <br><br>  akka的结构包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://doc.akka.io/docs/akka-">akka-http</a>模块，该模块允许您组织基于HTTP的异步非阻塞通信。 此外，该模块基于akka流构建，允许您在数据流处理操作图中添加HTTP交互作为附加步骤。 <br><br> 为了连接外部服务，akka-http提供了三种不同的接口。 <br><br><ol><li> 请求级API-对于对任意计算机的单个请求，这是最简单的选项。 在此级别上，HTTP连接是完全自动管理的，并且在每个请求中，都必须将请求将发送到的计算机的完整地址。 </li><li> 主机级API-当我们知道要访问的计算机上的哪个端口时适用。 在这种情况下，akka-http将控制HTTP连接池，并且在请求中足以指定到所请求资源的相对路径。 </li><li> 连接级API-允许您完全控制HTTP连接的管理，即跨连接打开，关闭和分发请求。 </li></ol><br> 在我们的情况下，分类服务的地址是我们事先知道的，因此，仅与该特定机器组织HTTP交互是必要的。 因此，主机级API最适合我们。 现在，让我们来看一下使用HTTP连接池时如何创建它： <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br> 当在隐式作用域中的ActorSystem中调用Http（）。CachedHostConnectionPool [T]（hostAddress，portNumber）时，会分配资源来创建连接池，但不会建立连接本身。 调用的结果是，返回Flow，该Flow接收一对HTTP请求和一些Id标识对象作为输入。 由于akka-http中的HTTP调用是异步操作，因此需要标识对象才能将请求与相应的响应进行匹配，并且接收响应的顺序不一定与请求的发送顺序相对应。 因此，在输出处，Flow提供了一些查询结果和相应的标识对象。 <br><br> 直接启动（实现）图形（包括该流）时，将建立HTTP连接。  Akka-http的实现方式是，不管包含httpFlow的图已实现多少次，在一个ActorSystem中，始终将有一个公共的HTTP连接池，所有实现都将使用该HTTP连接。 这使您可以更好地控制网络资源的使用并避免过载。 <br><br> 因此，HTTP连接池的生命周期与ActorSystem有关。 如前所述，线程池的生命周期也已附加到该线程池中，在该线程池中执行参与者中定义的操作（或在我们的示例中，定义为akka-streams和akka-http阶段）。 因此，为了获得最大效率，我们必须在同一JVM进程中重用ActorSystem的一个实例。 <br><br><h3> 全部放在一起：实现与分类服务交互的示例 </h3><br> 因此，现在我们可以继续使用与外部服务的异步交互对Apache Spark上的大量分布式数据进行分类的过程。 这种交互的一般方案已在图7中显示。 <br><br> 假设我们已经定义了一些初始数据集[功能]。 对它应用mapPartitions操作，我们应该获得一个数据集，其中来自源集的每个id都标记有作为分类结果而获得的某个值（数据集[Score]）。 要在执行程序上组织异步处理，我们必须将响应式流规范中的源迭代器和生成的迭代器分别包装在Publisher和Subscriber中，并将它们链接在一起。 <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(“scoreService. batchesRequestCount”)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br> 在该实现中，考虑到一个呼叫的分类服务可以一次处理一组特征向量，因此，对其进行呼叫后的分类结果也将立即用于整个组。 因此，作为Publisher的参数类型，我们不仅拥有您可能期望的Score，还拥有Iterable [Score]。 因此，我们通过一次调用onNext方法将该组的分类结果发送到结果迭代器（也是订阅者）。 这比为每个元素调用onNext效率更高。 现在，我们将更详细地分析此代码。 <br><br><ol><li> 我们确定输入和输出数据的结构。 作为输入，我们将具有一堆带有特征向量的id标识符，作为输出，我们将具有一堆具有分类结果的数值的标识符。 </li><li> 我们确定一次订阅服务器将要从发布服务器请求的组数。 由于假定这些值将位于缓冲区中并等待直到从生成的迭代器中读取它们，所以此值取决于分配给执行程序的内存量。 </li><li> 从源迭代器创建Publisher。 他将负责与分类服务进行交互。 下面将讨论createPublisher函数。 </li><li> 创建一个订户，它将成为结果的迭代器。  IteratorSubscriber类代码也在下面给出。 </li><li> 向发布者注册订户。 </li><li> 返回iteratorSubscriber作为mapPartitions操作的结果。 </li></ol><br> 现在考虑createPublisher函数的实现。 <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前一节所述，要使用akka，您需要一个ActorSystem，该ActorSystem必须创建一次然后再使用。</font><font style="vertical-align: inherit;">不幸的是，我们无法调用Spark执行程序的全局环境，但是我们可以使用标准方法来创建全局对象。</font><font style="vertical-align: inherit;">由于Spark执行程序是一个单独的JVM进程，因此，在其中，我们可以创建一个全局对象，在其中将使用它存储ActorSystem和ActorMatrializer和httpFlow。</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们使用延迟初始化创建所有全局变量，也就是说，实际上将在首次需要它们时创建它们。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这将创建一个具有特定名称的新ActorSystem。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了正确地终止ActorSystem框架中执行的所有进程，我们必须在其上调用终止方法，该方法将依次使用其标准停止机制停止所有参与者。</font><font style="vertical-align: inherit;">为此，我们必须注册在JVM进程终止时调用的钩子。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来，我们创建一个ActorMaterializer，它将使用我们的ActorSystem开始执行akka-streams流程。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们创建httpFlow与外部服务进行交互。</font><font style="vertical-align: inherit;">如前一节所述，我们在ActorSystem框架内为HTTP连接池分配资源。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，在我们的HTTP交互过程中，将结果迭代器的实现视为订户。 </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IteratorSubscriber类是Producer-Consumer模型的实现。</font><font style="vertical-align: inherit;">实现Subscriber接口的部分是生产者，而实现Iterator的部分是消费者。</font><font style="vertical-align: inherit;">被实现为阻塞队列的缓冲区被用作通信手段。</font><font style="vertical-align: inherit;">从Apache Spark执行程序池的流中调用Iterator接口中的方法，并从ActorSystem拥有的池中调用Subscriber接口的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们详细了解给定的IteratorSubscriber实现代码。</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们为缓冲区元素定义代数数据类型。</font><font style="vertical-align: inherit;">在缓冲区中，我们可以是以下元素组，或者是成功完成Done的信号，或者是包含Throwable的导致失败的信号的失败。</font></font></li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next方法从当前迭代器返回下一个元素。</font><font style="vertical-align: inherit;">根据其调用的语义，在此之前，调用方必须调用hasNext方法，因此在调用next时，next元素应始终是next元素。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们向发布服务器发送信号，表明我们准备使用在发布服务器注册时收到的订阅对象来处理下一组结果。</font><font style="vertical-align: inherit;">组的数量由requestSize的值确定。</font><font style="vertical-align: inherit;">我们还通过此值增加了预期元素的数量。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，在执行程序上启动的对数据块进行完整处理的一般方案如下所示： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图8.参与者与源迭代器和结果迭代器的交互。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结论：此解决方案的优缺点 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方案的主要优点是，它允许您使用使用任何可用方法实现的机器学习模型。之所以能够实现此目标，是因为使用了HTTP协议来访问模型，这是应用程序之间进行通信的标准方式。因此，模型的实现不依赖于其接口。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个优点-这种方案允许您实现所有元素的水平缩放。根据负载最重的部分，我们可以将机器添加到Hadoop集群，也可以运行其他模型实例。结果，该方案是容错的，因为在任何一台机器出现问题的情况下，我们都可以轻松地替换它。这是由于以下事实而实现的：存储在hdfs上的数据被复制，并且分类服务不依赖于某些常规可变状态，因此可以在几种情况下进行部署。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，该方案为调优和优化提供了充足的机会。例如，由于akka-http在整个进程的整个生命周期内都使用一个连接池，因此很容易控制与外部服务的连接数。或者，如果集群分布在多个数据中心中，我们可以在每个数据中心中提升模型的实例，并配置Apache Spark进程，使其仅引用其实例，从而消除数据中心之间的调用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，使用设置，此方案几乎可以避免停机。通过选择发送用于分类的组的大小，分类服务的实例数和http连接池的大小，可以在服务端和群集端实现最大的计算能力负载。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方案的主要缺点之一是其相对复杂性，这是由于组件分离以及需要组织它们之间的交互而引起的。此外，部分计算能力将用于确保通信，这会稍微降低效率。可能还会发生其他通信错误。结果，需要附加设置来增加交互的有效性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了排除网络交互，可以考虑将服务实例与数据部署在同一台计算机上。但是，通常，Hadoop集群中的机器数量非常大，因此在每个机器上部署模型实例将是无利可图的，特别是在大型模型的情况下。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，通常，在Hadoop群集上，同时执行多个任务以争夺其资源，因此启动其他服务会降低群集的整体性能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总结一下，我想指出的是，该解决方案已在我们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CleverDATA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公司成功实现</font><font style="vertical-align: inherit;">。多亏了他，数据分析人员和应用程序开发人员团队可以使用任何合适的方式进行工作，而不会互相限制。实际上，唯一需要共同讨论和协调的地方是机器学习模型提供的界面，所有其他问题都可以在一个团队中解决。因此，团队可以彼此独立地解决常见问题。</font></font><br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java开发人员</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统工程师</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413141/">https://habr.com/ru/post/zh-CN413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413129/index.html">新手程序员的25个错误</a></li>
<li><a href="../zh-CN413133/index.html">流行的反模式：分页</a></li>
<li><a href="../zh-CN413135/index.html">初级React开发人员的代码审查测试分配</a></li>
<li><a href="../zh-CN413137/index.html">使用任意机器学习模型在Apache Spark上对大量数据进行分类</a></li>
<li><a href="../zh-CN413139/index.html">电动汽车：革命即将到来</a></li>
<li><a href="../zh-CN413143/index.html">Bobby Urban Lite：XD Design的新款Urban背包</a></li>
<li><a href="../zh-CN413145/index.html">分析师帮助企业赚钱</a></li>
<li><a href="../zh-CN413147/index.html">是否可以使用Tibero代替Oracle。 并且有必要吗</a></li>
<li><a href="../zh-CN413149/index.html">数据湖概念中的分布式数据仓库：从哪里开始</a></li>
<li><a href="../zh-CN413151/index.html">NSA提出了针对物联网设备的加密标准，但ISO拒绝了该标准</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>