<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔙 🆙 🚆 Automatisierung des Testens kostenpflichtiger Dienste unter iOS 📎 👨 👩🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Für diejenigen, die sich für das Thema Automatisierung unter iOS interessieren, habe ich zwei Neuigkeiten - gut und schlecht. Gut: In der iOS-Anwendun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung des Testens kostenpflichtiger Dienste unter iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/">  Für diejenigen, die sich für das Thema Automatisierung unter iOS interessieren, habe ich zwei Neuigkeiten - gut und schlecht.  Gut: In der iOS-Anwendung für kostenpflichtige Dienste wird nur ein Integrationspunkt verwendet - In-App-Käufe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Anwendung integrierte Käufe</a> ).  Schlecht: Apple bietet keine Tools zur Automatisierung von Testkäufen an. <br><br>  In diesem Artikel schlage ich vor, dass Sie und ich nach einer universellen Automatisierungsmethode suchen, die über Apples Gut und Böse hinausgeht.  Der Artikel ist für alle nützlich, die Dienste von Drittanbietern, die eine Black Box darstellen, in ihre Anwendungen integrieren: Werbung, Streaming, Standortverwaltung usw. Normalerweise sind solche Integrationen sehr schwer zu testen, da es keine Möglichkeit gibt, einen Dienst von Drittanbietern flexibel zum Testen der Anwendung zu konfigurieren. <br><br><img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br><a name="habracut"></a><br>  <i>Mein Name ist Victor Koronevich, ich bin Senior Test Automation Engineer bei Badoo.</i>  <i>Seit mehr als zehn Jahren in der mobilen Automatisierung tätig.</i>  <i>Zusammen mit meinem Kollegen Vladimir Solodov haben wir diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> auf der Heisenbug-Konferenz erstellt.</i>  <i>Er half mir auch bei der Vorbereitung dieses Textes.</i> <br><br>  Im vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel haben</a> wir beschrieben, mit welchen Methoden Badoo die Integration mit Zahlungsanbietern testet, von denen wir mehr als 70 haben. In diesem Artikel werden wir mehr darüber sprechen, wie wir es geschafft haben, eine stabile und kostengünstige Automatisierung des Testens von kostenpflichtigen Diensten in einer iOS-Anwendung zu erreichen. <br><br>  Beginnen wir mit einer allgemeinen Beschreibung unserer Forschung: <br><br><ol><li>  Problemdefinition <br></li><li>  Erklärung des Problems <br></li><li>  Lösung Nr. 1.  Apple Sandbox <br></li><li>  Entscheidung Nr. 2.  Funktions-Mock-Methode und Verwenden eines gefälschten Objekts <br></li><li>  Bewertung der Entscheidung: Hauptrisiken <br></li><li>  Ergebnis <br></li><li>  Fazit <br></li></ol><br><h2>  Problemdefinition </h2><br>  Automatisierung muss durchgeführt werden, wenn ein natürlicher Bedarf entsteht.  Wann kam dieser Moment mit uns? <br><br>  Es gibt viele kostenlose Funktionen in der Badoo-App, aber kostenpflichtige bieten dem Benutzer mehr Optionen.  Sie erhalten sie auf zwei Arten: für Kredite - die interne Währung von Badoo - oder durch den Kauf eines Premium-Abonnements.  Für eine bestimmte Anzahl von Credits können Sie Ihr Profil in den Suchergebnissen auf den ersten Platz heben, einem anderen Benutzer ein Geschenk machen und vieles mehr.  Das Premium-Abonnement ist für einen bestimmten Zeitraum gültig und bietet mehrere Optionen gleichzeitig: Aktivieren Sie den Unsichtbarkeitsmodus, sehen Sie Personen, die Sympathie für Sie gezeigt haben, stornieren Sie das Ergebnis Ihrer Abstimmung und andere. <br><br>  Diese Funktionen wurden nach und nach in Badoo angezeigt.  Und vor ein paar Jahren haben wir kostenpflichtige Dienste in iOS-Anwendungen nur manuell getestet.  Da jedoch Funktionen und neue Bildschirme angezeigt werden, dauerte das manuelle Testen immer länger.  Die Anforderungen für Änderungen in der Anwendung kamen von verschiedenen Seiten: von den Entwicklern der Clientseite, den Entwicklern der Serverseite und sogar vom Apple-Anbieter selbst.  Für einen Tester dauerte eine Testiteration ungefähr acht Stunden.  Es wurde unmöglich, innerhalb von 30 Minuten ein schnelles Feedback für einen Entwickler in seiner Branche zu erhalten, was sich letztendlich negativ auf die Wettbewerbsfähigkeit des Produkts auswirken könnte. <br><br>  Wir wollten so schnell wie möglich Testergebnisse erhalten.  Und sie stießen auf ein Problem: Wie können Regressionstests für kostenpflichtige Dienste in unseren iOS-Anwendungen kostengünstig organisiert werden, um schnelle und stabile Ergebnisse zu erzielen? <br><br><h2>  Erklärung des Problems </h2><br>  Unter Berücksichtigung der Besonderheiten unseres Lieferprozesses des Endprodukts und der Größe des Teams möchten wir: <br><br><ul><li>  Testen Sie alle Einkäufe innerhalb der Kundenanwendung (einmalige Zahlungen und Abonnements). <br></li></ul><br><ul><li>  Wiederholen Sie die Testiterationen 10 bis 20 Mal am Tag. <br></li><li>  Erhalten Sie Testergebnisse ~ 150 Testskripte in weniger als einer halben Stunde; <br></li><li>  Lärm loswerden; <br></li><li>  Sie können Tests für einen bestimmten Zweig des Entwicklercodes ausführen, unabhängig von den Ergebnissen anderer Läufe. <br></li></ul><br>  Nachdem wir die Aufgabe formuliert haben, ist es Zeit, die Reise in die wunderbare Welt der Ingenieure und ihrer Lösungen zu beginnen. <br><br><h2>  Lösung Nr. 1.  Apple Sandbox </h2><br>  Zunächst suchten wir in der Apple-Dokumentation nach Informationen zum Organisieren des automatischen Testens kostenpflichtiger Dienste.  Und sie haben nichts gefunden.  Die Automatisierungsunterstützung sieht sehr dürftig aus.  Wenn etwas angezeigt wird, ist es schwierig, die Automatisierung mit den vorgeschlagenen Tools <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzurichten</a> (erinnern wir uns zumindest an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIAutomation</a> sowie an die Zeit, als das erste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xcrun simctl-</a> Dienstprogramm für iOS Simulator erschien), und Sie müssen nach technischen Lösungen suchen, auch im Open-Source-Segment. <br><br>  In der Apple-Dokumentation zum Testen kostenpflichtiger Dienste finden Sie nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple Sandbox</a> .  Es war nicht klar, wie diese Sandbox mit der Automatisierung verbunden werden sollte, aber wir haben uns entschlossen, diese Lösung ernsthaft zu untersuchen.  Die Tatsache, dass die Android-Sandbox stabil war, gab uns Vertrauen, und zu diesem Zeitpunkt hatten wir bereits erfolgreich Tests für Android geschrieben.  Vielleicht ist die Apple Sandbox genauso gut? <br><br>  Aber als wir Autotests mit dieser Sandbox implementiert haben, haben wir voll getrunken.  Lassen Sie uns kurz auf die Hauptprobleme eingehen. <br><br><h3>  1. Der Pool der Testbenutzer </h3><br>  Die Haupteinschränkung für die Automatisierung sind die Merkmale des Inhalts im Pool der Testbenutzer, die die Unabhängigkeit des Starts von Autotests gewährleisten sollen. <br><br>  Um nur einen automatischen Kauf eines Abonnementkaufs durchzuführen, benötigen wir: <br><br><ol><li>  Nehmen Sie einen neuen Benutzer zur Autorisierung in die Sandbox. <br></li><li>  Ändern Sie auf dem Simulator die aktuell verknüpfte Apple ID. <br></li><li>  Melden Sie sich mit Badoo bei Badoo an <br></li><li>  Rufen Sie den Bildschirm des Abonnementkaufs auf und wählen Sie ein Produkt aus. <br></li><li>  Bestätigen Sie den Kauf und melden Sie sich über die Apple ID an. <br></li><li>  Stellen Sie sicher, dass der Kauf erfolgreich war. <br></li><li>  Badoo-Benutzer zur Reinigung senden; <br></li><li>  Löschen Sie den Benutzer der Sandbox von Abonnements. <br></li></ol><br>  Wenn Sie versuchen, im nächsten Test sofort denselben Benutzer zu verwenden, ist es unmöglich, ein zweites Abonnement zu kaufen.  Sie müssen warten, bis das erste Abonnement "schlecht" wird, oder sich in den Einstellungen abmelden.  Wie bereits im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erwähnt</a> , hat die Sandbox eine bestimmte Gültigkeitsdauer für Abonnements.  Wenn Sie ein Abonnement "für einen Monat" kaufen, müssen Sie fünf Minuten warten, um es automatisch zu schließen.  Der Abmeldevorgang selbst ist ebenfalls nicht schnell. <br><br>  Dementsprechend müssen wir für einen neuen Durchlauf desselben Tests entweder warten, bis das Abonnement endet, oder einen anderen „sauberen“ Benutzer nehmen.  Wenn wir zwei Tests gleichzeitig unabhängig voneinander ausführen möchten, müssen mindestens zwei Sandbox-Benutzer im Pool vorhanden sein.  Um 100 Autotests parallel in 100 Threads auszuführen, benötigen wir 100 verschiedene Benutzer. <br><br>  Stellen wir uns nun vor, wir führen einen Selbsttest mit zwei Agenten durch, von denen jeder sie in 100 Threads ausführen kann.  In diesem Fall benötigen wir mindestens 200 Benutzer! <br><br><h3>  2. "Schlechte" Benachrichtigungen </h3><br>  Nun, was zum Teufel scherzt nicht!  Wir organisierten einen Benutzerpool und begannen zu beobachten, wie Tests ablaufen.  Sie fielen die Straße entlang, aber die Mehrheit - aus neuen, uns unbekannten Gründen.  Wir begannen zu verstehen und erkannten, dass der App Store beim Autorisieren, Bestätigen eines Kaufs und Arbeiten als Benutzer in der Sandbox Warnungen sendet: Er fragt beispielsweise nach einem neuen Benutzernamen und Passwort, bestätigt die Autorisierung durch Klicken auf die Schaltfläche „OK“ und gibt Informationen über einen internen Fehler mit der Schaltfläche „OK“ aus .  Manchmal erscheinen sie, manchmal nicht.  Und wenn sie erscheinen, dann immer in einer anderen Reihenfolge. <br><br><img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br><br>  Wie ist es möglich, dass ein verdächtiger Fehler bei einem Autotest einfach ignoriert wird?  Und wenn ein echter Fehler eintritt, was soll ich dann tun?  Dieser Bereich wurde für uns automatisch zu einer „blinden Zone“, und wir mussten spezielle Handler für alle möglichen Warnungen schreiben, die aus dem App Store kommen konnten. <br><br>  All dies verlangsamte die Tests: <br><br><ul><li>  Warnungen können zu verschiedenen Schritten des Testszenarios führen und die Hauptidee des Tests zerstören - Vorhersagbares Testszenario;  Wir mussten einen Fehlerbehandler hinzufügen, der erwartete, dass eine mögliche Reihe bekannter ignorierter Warnungen angezeigt wird. <br></li><li>  Manchmal kamen neue Variationen von Warnungen an oder es traten andere Fehler auf, sodass wir die gefallenen Tests neu starten mussten.  Dies erhöhte die Laufzeit aller Tests. <br></li></ul><br><h3>  3. Gab es einen Test? </h3><br>  Benutzer im Pool werden also blockiert und dann für n Minuten gelöscht.  Wir führen Tests in 120 Threads durch, und es gibt bereits ziemlich viele Benutzer im Pool, aber das reicht nicht aus.  Wir haben unser Benutzerverwaltungssystem erstellt, einen Alert-Handler erstellt - und dann ist die IT passiert.  Die Sandbox ist für einige Testbenutzer seit einigen Tagen nicht mehr verfügbar. <br><br>  Niemand hat das erwartet.  Und dies war der letzte Strohhalm im Kelch unserer Geduld, der schließlich die Liebe zum Apfel-Sandkasten tötete und uns auf den Weg jenseits von Gut und Böse brachte.  Wir haben erkannt, dass wir eine solche Automatisierung nicht brauchen und dass wir mit dieser gefährlichen Entscheidung nicht mehr leiden wollen. <br><br><h2>  Entscheidung Nr. 2.  Funktions-Mock-Methode und Verwenden eines gefälschten Objekts </h2><br>  Also haben wir Probleme mit der Automatisierung in der Sandbox von Apple getrunken.  Aber denken Sie nicht, dass in der mobilen Welt alles völlig schlecht ist.  Unter Android ist die Sandbox viel stabiler - Sie können dort Autotests ausführen. <br><br>  Versuchen wir, eine andere Lösung für iOS zu finden.  Aber wie soll man aussehen?  Wo soll man suchen?  Schauen wir uns die Geschichte des Testens und der Softwareentwicklung an: Was ist mit der verrückten Welt von Apple passiert?  Was sagen Menschen, die eine Reihe von Büchern geschrieben und Autorität in der Welt der Automatisierung und Softwareentwicklung erworben haben? <br><br>  Ich erinnerte mich sofort an die Arbeit „xUnit Test Patterns: Refactoring Test Code“ von Gerard Mesaroche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rezension von</a> Martin Fowler) - meiner Meinung nach eines der besten Bücher für jeden Tester, der mindestens eine Programmiersprache auf hohem Niveau kennt und Automatisierung betreiben möchte .  Ein paar Kapitel dieses Buches, die sich dem isolierten Testen von SUT von anderen Komponenten der Anwendung widmen, die unsere „Black Box“ sind, können uns helfen. <br><br><h3>  1. Einführung in Mokka und Fake </h3><br>  Es sollte beachtet werden, dass es in der Welt des automatischen Testens keine allgemein akzeptierte Grenze zwischen den Konzepten Testdoppel, Teststub, Testspion, Scheinobjekt, gefälschtes Objekt, Dummy-Objekt gibt.  Sie müssen immer die Terminologie des Autors berücksichtigen.  Wir brauchen nur zwei Konzepte aus der großen Welt der Test Doubles: eine Scheinfunktion und ein gefälschtes Objekt.  Was ist das?  Und warum brauchen wir das?  Wir geben eine kurze Definition dieser Konzepte, damit wir keine Meinungsverschiedenheiten haben. <br><br>  Angenommen, wir haben eine Anwendung und eine Komponente eingebaut, die für uns eine „Black Box“ ist.  Innerhalb der Anwendung können wir Funktionen aufrufen, indem wir auf diese Komponente zugreifen und die Ergebnisse dieser Funktionen abrufen.  Je nach Ergebnis reagiert unsere Anwendung spezifisch.  Manchmal kann das Ergebnis der Funktionsausführung eine ganze Entität mit einer Reihe von Feldern sein, die die tatsächlichen Benutzerdaten widerspiegeln. <br><br>  Wenn Sie eine Funktion durch eine andere ersetzen, die das gewünschte Ergebnis zurückgibt, rufen Sie den Mock der Funktion oder einfach den Mock auf.  Diese Funktionen haben möglicherweise dieselbe Signatur, es handelt sich jedoch um zwei verschiedene Funktionen. <br><br>  Und das Ersetzen einer Entität, die als Ergebnis der Funktion für eine gefälschte Entität erhalten wird (die die erforderlichen Daten in den Feldern und manchmal sogar beschädigte Daten enthält), wird als Implementierung eines gefälschten Objekts bezeichnet.  Sie können mehr darüber in dem oben erwähnten Buch oder in einem anderen Kompendium zum Testen und zur Softwareentwicklung lesen. <br><br>  Lassen Sie uns abschließend einige Funktionen zur Verwendung von Scheinfunktionen und gefälschten Objekten hervorheben: <br><br><ol><li>  Um die Funktionen nass zu machen, müssen Sie auf den Quellcode zugreifen und wissen, wie die Anwendung auf Entwicklerebene von innen mit der Komponente funktioniert. <br></li><li>  Um ein gefälschtes Objekt zu implementieren, müssen Sie die Struktur des realen Objekts kennen. <br></li><li>  Die Verwendung der Mock-Funktion ermöglicht eine flexible Konfiguration der Anwendung mit der Komponente. <br></li><li>  Durch die Verwendung eines gefälschten Objekts können Sie einer Entität beliebige Eigenschaften verleihen. <br></li></ol><br>  Die Moki- und Fake-Object-Methode ist ideal, um den Betrieb einer Komponente innerhalb einer Anwendung zu isolieren.  Mal sehen, wie wir diese Methode anwenden können, um unser Problem zu lösen, wobei der App Store die Komponente sein wird.  Aufgrund der Besonderheiten dieser Methode müssen wir uns zunächst mit der Untersuchung der Art der Arbeit unserer Anwendung mit der Komponente befassen und dann mit der technischen Implementierung, um bestimmte Mokeys und gefälschte Objekte herzustellen. <br><br><h2>  2. Wie kommt es zu einem echten Kauf? </h2><br>  Bevor wir beginnen, die Interaktion aller Teile des Systems zu beschreiben, wollen wir die Hauptakteure hervorheben: <br><br><ul><li>  Anwendungsbenutzer - Jeder Akteur, der Aktionen mit der Anwendung ausführt, kann eine Person sein oder es kann ein Skript geben, das die erforderlichen Anweisungen ausführt. <br></li><li>  Anwendung (in unserem Fall verwenden wir die im iOS-Simulator installierte Badoo iOS-Anwendung); <br></li><li>  Server - ein Akteur, der Anforderungen von der Anwendung verarbeitet und Antworten oder asynchrone Benachrichtigungen ohne Clientanforderung zurücksendet (in diesem Fall meinen wir einen abstrakten Badoo-Server, um die Struktur zu vereinfachen); <br></li><li>  Der App Store ist ein Akteur, der für uns eine „Black Box“ darstellt: Wir wissen nicht, wie er im Inneren angeordnet ist, aber wir kennen die öffentliche Oberfläche für die Verarbeitung von Einkäufen innerhalb der Anwendung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StoreKit-Framework</a> ) und wissen auch, wie Daten auf einem Apple-Server überprüft werden. <br></li></ul><br>  Mal sehen, wie der Kauf erfolgt.  Der gesamte Prozess ist im Diagramm dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>  <i><font color="gray">Abbildung 1. Zahlungsschema im App Store</font></i> <br><br>  Wir werden Schritt für Schritt die Hauptaktionen der Akteure beschreiben. <br><br>  1. Ausgangspunkt ist der Status aller Akteure, bevor der Bildschirm mit einer Produktliste geöffnet wird. <br><br>  Was ist dieser Bildschirm und wie sind wir darauf gekommen? <br><br>  Angenommen, ein Benutzer hat eine interessante Person gefunden, sein Profil geöffnet, eine Nachricht geschrieben und wollte ein Geschenk senden.  Das Senden eines Geschenks ist eine kostenpflichtige Dienstleistung.  Der Benutzer kann im Profil zu dem Abschnitt zum Senden von Geschenken scrollen oder sofort ein Geschenk aus dem Chat auswählen. <br><br>  Wenn der Benutzer ein Geschenk auswählt und kein Geld auf dem Konto hat, wird eine Liste der verschiedenen Darlehenspakete (Zahlungsassistent) zum Kauf angezeigt.  Der Ausgangspunkt in unserem Beispiel ist eine Liste von Geschenken.  In der Abbildung können wir einen solchen Punkt auf jedem Bildschirm betrachten, bevor wir die Liste der Produkte für den Kauf von Darlehen oder Abonnements anzeigen. <br><br>  2. Öffnen einer Produktliste. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br>  Wir stehen zum Beispiel auf der Geschenkliste am Ausgangspunkt.  Der Benutzer wählt eines der Geschenke in der Anwendung aus.  Die Anwendung fordert unseren Server auf, eine Liste möglicher Produkt-ID-Darlehenspakete (100, 550, 2000, 5000) zu erhalten.  Der Server gibt diese Liste an die Anwendung zurück. <br><br>  Als Nächstes sendet die Anwendung die empfangene Produkt-ID-Liste zur Überprüfung an den App Store-Akteur (StoreKit-System-iOS-Framework, das an den Apple-Server gesendet wird).  Es gibt eine Liste bewährter Produkte zurück - und als Ergebnis zeigt die Anwendung dem Benutzer die endgültige Liste der Darlehenspakete mit Symbolen und Preisen. <br><br>  3. Produktauswahl und Quittungserstellung. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br>  Der Benutzer wählt ein kostenpflichtiges Produkt aus.  Der App Store erfordert einen Kaufnachweis und eine Autorisierung über die Apple ID.  Nach erfolgreicher Benutzerautorisierung wird die Kontrolle auf die Anwendung übertragen.  Die Anwendung wartet darauf, dass eine Quittung in ihrem eigenen Paket generiert wird.  Der Benutzer sieht zu diesem Zeitpunkt die Sonne, die den Bildschirm sperrt.  Diese generierte Quittung kann mit der Methode appStoreReceiptURL der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bundle-</a> Klasse verstanden werden.  Nachdem der Scheck vom App Store generiert wurde, wählt die Anwendung den Scheck aus ihrem Paket aus und sendet eine Anfrage mit dem Scheck und den Benutzerdaten an den Badoo-Server. <br><br>  4. Überprüfen Sie die Prüfung auf dem Badoo-Server. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br>  Sobald der Badoo-Server die Prüf- und Benutzerdaten erhält, sendet er diese an die Apple-Serverseite zurück, um den ersten Überprüfungszyklus durchzuführen.  Dies ist eine der Empfehlungen von Apple.  In diesem ersten Überprüfungszyklus erhält der Server dann Informationen über den aktuellen Status des Abonnements. <br><br>  5. Senden von Push-Benachrichtigungen (Push-Benachrichtigung) vom Server. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br>  Der Badoo-Server verarbeitet die empfangenen Informationen nach Überprüfung durch Apple erneut und sendet der Anwendung eine Antwort zusammen mit einer Push-Benachrichtigung. <br><br>  6. Push-Benachrichtigung in der Anwendung. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br>  Wenn es sich um einen Kauf von Darlehen handelte, ändert sich sofort das Guthaben des Benutzers in der Anwendung und er sieht das gesendete Geschenk im Chat.  Wenn dies ein Abonnementkauf war, sollte der Benutzer auf die endgültige Push-Benachrichtigung warten, dass das Abonnement aktiviert ist. <br><br><h3>  3. Ermittlung von Abhängigkeiten und Testschleife </h3><br><br>  Zur weiteren Diskussion stellen wir zwei weitere Konzepte vor - die externe Abhängigkeit und die Testschaltung. <br><br><h4>  Externe Abhängigkeit </h4><br>  Unter externen Abhängigkeiten verstehen wir jede Interaktion mit einer Komponente, die für uns eine „Black Box“ ist.  In diesem Fall fungiert der App Store als solche Komponente in Form eines iOS-Systemframeworks (StoreKit), mit dem unsere iOS-Anwendung funktioniert, und eines Apple-Servers, auf dem Überprüfungsanforderungen gestellt werden. <br><br>  Das Verwalten dieser Abhängigkeiten unter realen Bedingungen ist nicht möglich. Die Anwendung ist gezwungen, auf die Ausgangssignale der Black Box zu reagieren (siehe Abb. 2). <br><br>  Wir haben drei externe Abhängigkeiten: <br><br><ol><li>  Überprüfen von StoreKit-Produkten. <br></li><li>  Empfangen und Ersetzen eines Kaufbelegs. <br></li><li>  Überprüfen einer Prüfung auf einem Badoo-Server. <br></li></ol><br><img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>  <i><font color="gray">Abbildung 2. Externe Abhängigkeiten</font></i> <br><br><h4>  Testschaltung </h4><br>  Testschaltung - Dies sind Abschnitte des Pfades, den wir während des Testprozesses durchlaufen und überprüfen werden. <br><br><img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>  <i><font color="gray">Abbildung 3. Testschleife</font></i> <br><br>  Das Ziel unserer Arbeit zur Beseitigung von Abhängigkeiten ist es, eine Testschaltung zu erstellen, die so nah wie möglich am tatsächlichen Pfad liegt und es Ihnen ermöglicht, alle externen Abhängigkeiten auszuschließen und die Kontrolle auf Ihre Seite zu übertragen. <br><br>  Wir betrachten jede Abhängigkeit nacheinander. <br><br><h3>  4. Isolation von Abhängigkeiten: technische Umsetzung </h3><br>  In unserem Unternehmen wurde für die Implementierung von Zahlungen ein PPP-Konzept verwendet, das auf der Schnittstelle des Zahlungsanbieters basiert.  Dies ist die Hauptschnittstelle für die Interaktion mit dem App Store-Akteur (StoreKit) in unserer Anwendung, die über zwei Hauptmethoden verfügt: <br><br><ol><li>  vorbereiten ist die Methode, die für die Überprüfung der Produkte verantwortlich ist; <br></li><li>  makePayment ist eine Methode, die einen In-App-Kauf verarbeitet. <br></li></ol><br>  Alle Zahlungen unter iOS wurden gemäß diesem Konzept überarbeitet, wodurch wir einen einfachen und bequemen Mock Payment Provider der Klasse erhalten konnten.  Dies ist die Hauptschnittstelle für die Interaktion mit einer praktischen Kopie des StoreKit-Verhaltens in unserer Anwendung.  Was bedeutet "bequemes Kopieren"?  Dieser Anbieter verfügt über Verspottungen der Methoden prepare und makePayment, die das tun, was wir wollen.  Schauen wir uns ein Beispiel für Codeteile an, wie wir es geschafft haben, Moki zu integrieren. <br><br><h4>  Abhängigkeit Nr. 1.  Überprüfen von StoreKit-Produkten </h4><br>  Verwenden Sie zum Überprüfen der Produktliste die Vorbereitungsfunktion, die eine Liste der überprüften Produkte zurückgibt.  Wir können das Modell verwenden, in dem wir die Prüfung deaktivieren und die eingehende Liste der Produkte als vollständig verifiziert zurücksenden.  Somit wird die Abhängigkeit beseitigt. <br><br><img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>  <i><font color="gray">Abbildung 4. Das erste Schema zur Beseitigung von Abhängigkeiten</font></i> <br><br>  Ganz oben in der Architektur unserer Anwendung steht der Zahlungsanbieter.  Es spiegelt die Schnittstelle eines möglichen Anbieters in der Anwendung wider.  Der Code zum Implementieren von mok befindet sich in der Klasse Mock Payment Provider. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeKitTransactionID: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products } ... }</code> </pre> <br>  <i><font color="gray">Listing 1. Mock Client Check</font></i> <br><br>  Beim Mock Payment Provider können wir die Implementierung der Vorbereitungsmethode sehen.  Die Magie von Moka stellt sich als sehr einfach heraus: Die Methode übersprang die Überprüfung von Produkten auf der StoreKit-Seite und gibt einfach eine eingehende Liste von Produkten zurück.  Die eigentliche Implementierung von prepare sieht folgendermaßen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validatedProducts = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.productsSource.validate(products: products) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> validatedProducts }</code> </pre><br>  <i><font color="gray">Listing 2. Real Store Zahlungsanbieter</font></i> <br><br><h3>  Abhängigkeit Nr. 2.  Empfangen und Ersetzen eines Kaufbelegs </h3><br>  Die zweite Abhängigkeit ist etwas komplizierter: Wir müssen zuerst die Autorisierung entfernen, um den Pool der Benutzerkonten nicht zu behalten, und dann irgendwie die Prüfung selbst erhalten.  Wir können das Autorisierungsformular einfach löschen: <br><br><img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>  <i><font color="gray">Abbildung 5. Löschen eines Autorisierungsformulars bei der Zahlung</font></i> <br><br>  Mit einem Scheck ist das nicht so einfach.  Es gibt viele Fragen: <br><br><ol><li>  Wie bekomme ich im Voraus eine Quittung für das richtige Produkt? <br></li><li>  Wenn wir den Scheck erhalten haben, wann und wie können wir ihn in die Anwendung einfügen? <br></li></ol><br>  Hier hat der Schauspieler "User" eine neue Rolle - QA.  Wenn wir den Test ausführen, können wir nicht nur auf die Schaltflächen auf der Benutzeroberfläche klicken, sondern auch die API-Methoden des Testframeworks (Methoden, die Benutzeraktionen simulieren) und die REST-API-Services (Methoden, die vom internen Badoo-Service aus Magie ausführen können) aufrufen.  Wir bei Badoo verwenden ein sehr leistungsfähiges QA-API-Tool (alle Funktionen finden Sie unter dem Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://vimeo.com/116931200</a> ).  Er ist es, der uns beim Testen hilft und auf der Serverseite von Badoo nach dem richtigen Produkt sucht.  Der Badoo-Server ist der beste Ort, um Schecks zu generieren: Der Scheck wird verschlüsselt und entschlüsselt, sodass der Server alles über diese Datenstruktur weiß. <br><br>  Nachdem wir einen gefälschten Scheck erhalten haben, können wir ihn durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintertür</a> auf der Anwendungsseite stellen.  Als nächstes sendet die Anwendung einen gefälschten Scheck zusammen mit Benutzerdaten an unseren Server. <br><br><img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>  <i><font color="gray">Abbildung 6. Schema für den Empfang</font></i> <br><br>  Wie wurde dies technisch möglich? <br><br>  1. Um einen gefälschten Scheck in der Anwendung einzurichten, konnten wir eine Hintertür verwenden, die den gefälschten Scheck im Feld MockPaymentProvider der Quittung speicherte: <br><br><pre> <code class="swift hljs">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">BUILD_FOR_AUTOMATION</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadooAppDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMockPurchaseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> receipt: String?)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">PaymentProvidersFactory</span></span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt = receipt } ... } #endif</code> </pre> <br>  <i><font color="gray">Listing 3. Fake Check Backdoor</font></i> <br><br>  2. Die Anwendung konnte unseren Scheck dank MockPaymentProvider entgegennehmen, in dem wir das makePayment-Modell und den gespeicherten Scheck in MockPaymentProvider.receipt verwendet haben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePayment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transaction: BPDPaymentTransactionContext)</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiptData = <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt?.data(using: .utf8) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">BPDPurchaseReceiptRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkService.send(request, completion: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (<span class="hljs-number"><span class="hljs-number">_</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receipt = request.responsePayload() { sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt) } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate?.paymentProvider(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailTransaction: transaction) } } }</code> </pre> <br>  <i><font color="gray">Listing 4. Aufruf eines Kaufabwicklungs-Moka mit einem gefälschten Scheck</font></i> <br><br>  3. Einen gefälschten Scheck bekommen <br><br>  Um eine gefälschte Prüfung zu erhalten, haben wir die Methode auf dem Server verwendet (siehe Listing 5).  Es wird ein Standardarray mit Daten zum Generieren von Prüfdaten verwendet und die für ein bestimmtes Produkt erforderlichen Daten hinzugefügt. <br><br><pre> <code class="php hljs">$new_receipt_model = array_replace_recursive( <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;getDefaultModel(), //       //,      $this-&gt;enrichModelUsingSubscription($nr), //        $this-&gt;enrichModelUsingInput($input) ); //  $new_receipt = $this-&gt;signReceipt( json_encode($new_receipt_model, true), $new_receipt_model );</span></span></code> </pre><br>  <i><font color="gray">Listing 5. Serverteil der Scheckgenerierung</font></i> <br><br>  Um die Struktur einer echten Prüfung zu wiederholen, muss die von der Anwendung gesendete benutzerdefinierte Prüfung mit einem Zertifikat verschlüsselt werden.  Wir verwenden unser Arbeitszertifikat anstelle des Apple-Zertifikats. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt, $response)</span></span></span><span class="hljs-function">  </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     base64 $receipt = 'Subject: ' . base64_encode(json_encode($response)) . PHP_EOL . PHP_EOL . $receipt; file_put_contents($receipt_file, $receipt); ... //    $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, 'file://'.$path_cert, 'file://'.$path_key, [], PKCS7_BINARY); ... //  $signed_content_with_headers = file_get_contents($signed_receipt_file); list($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers); //  return str_replace(["\r\n", "\r", "\n"], '', $signed_content); }</span></span></code> </pre><br>  <i><font color="gray">Listing 6. Methode zum Signieren eines Schecks mit einem Zertifikat</font></i> <br><br>  4. Als Ergebnis erhalten wir im Test: <br><br><pre> <code class="ruby hljs">(<span class="hljs-regexp"><span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|service_type|</span></span> <span class="hljs-comment"><span class="hljs-comment">#    service_details = parse_options(service_type) #  QA API (  Badoo) receipt = QaApi::Billing.order_get_app_store_receipt(service_details) #   Backdoors.set_fake_receipt(receipt) end</span></span></code> </pre><br>  <i><font color="gray">Listing 7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurken-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testschritt</a> für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurken-</a> Framework</font></i> <br><br><h3>  Abhängigkeit Nr. 3.  Überprüfen einer Prüfung auf einem Badoo-Server </h3><br>  Um die dritte Abhängigkeit zu entfernen, müssen Sie die Überprüfungsüberprüfung auf dem Server entfernen.  Es ist wichtig zu bedenken, dass die Überprüfung in zwei Schritten erfolgt.  In der ersten Phase wird die Prüfung anhand von Signaturen und Zertifikaten authentifiziert.  Im zweiten Fall wird der Scheck an den App Store gesendet.  Im Falle einer erfolgreichen Validierung zu diesem Zeitpunkt erhalten wir einen entschlüsselten Scheck, der verarbeitet werden kann. <br><br><img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>  <i><font color="gray">Abbildung 7. Entfernen der Serverüberprüfung</font></i> <br><br>  Zunächst führt der Server die erste Überprüfung der Prüfung in der verifyReceiptByCert-Methode der übergeordneten Klasse durch.  Dadurch wird die Signatur mit dem App Store-Zertifikat überprüft.  Im Falle einer gefälschten Prüfung schlägt diese Überprüfung fehl, da sie von unserem Zertifikat signiert ist, und wir rufen die Methode zur Überprüfung mit dem lokalen Zertifikat verifyReceiptByLocalCert auf.  Bei dieser Methode versuchen wir, die Prüfung mit einem lokalen Zertifikat zu entschlüsseln. Wenn dies erfolgreich ist, platzieren wir das Entschlüsselungsergebnis im internen Feld local_receipt der untergeordneten Klasse (addLocallyVerifiedReceipt-Methode). <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">)  </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceiptByCert($receipt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($result)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;verifyReceiptByLocalCert($receipt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyReceiptByLocalCert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt)</span></span></span><span class="hljs-function"> </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response)); } unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">) </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  <i><font color="gray">Listing 8. Erstprüfung</font></i> <br><br>  Während der sekundären Überprüfung (verifyReceipt) erhalten wir den Wert des Felds local_receipt der untergeordneten Klasse getLocallyVerifiedReceipt.  Wenn es nicht leer ist, verwenden wir seinen Wert als Ergebnis der Überprüfung. <br><br>  Wenn das Feld leer ist, rufen wir die sekundäre Überprüfung von der übergeordneten Klasse ( <i>parent</i> :: verifyReceipt) auf.  Dort stellen wir eine Anfrage an den App Store zur Überprüfung auf seiner Seite.  Das Überprüfungsergebnis ist in beiden Fällen eine entschlüsselte Prüfung. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLocallyVerifiedReceipt($receipt_encoded); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($response)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($response, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceipt($receipt_encoded, $shared_secret, $env); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre> <br>  <i><font color="gray">Listing 9. Sekundäre Überprüfung</font></i> <br><br><h3>  5. Videotestlauf: Kredite und Abonnements kaufen </h3><br><h4>  Test Nummer 1.  Abonnementkauf </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Wann <br></td><td>  Ich melde mich als neuer Benutzer mit einem Foto bei der Anwendung an <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle einen neuen Abrechnungsscheck für ein Monat <br></td></tr><tr><td>  Und <br></td><td>  Ich gehe zu meinem Profil <br></td></tr><tr><td>  Dann <br></td><td>  Ich stelle sicher, dass das Abonnement deaktiviert ist <br></td></tr><tr><td>  Wann <br></td><td>  Ich öffne die Produktliste <br></td></tr><tr><td>  Und <br></td><td>  Ich kaufe ein einmonatiges Abonnementpaket <br></td></tr><tr><td>  Dann <br></td><td>  Ich überprüfe die Benachrichtigung über den erfolgreichen Kauf <br></td></tr><tr><td>  Und <br></td><td>  Ich stelle sicher, dass das Abonnement aktiviert ist <br></td></tr></tbody></table></div><br>  Testlauf Video: <br><br><img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br><h4>  Test Nummer 2.  Kredite kaufen und ein Geschenk schicken </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Wann <br></td><td>  Ich melde mich als neuer Benutzer mit einem Foto bei der Anwendung an <br></td></tr><tr><td>  Und <br></td><td>  Ich füge meinem Profil zehn Credits hinzu <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle eine neue Bonitätsprüfung für 550 Credits <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle einen neuen Benutzer Leela <br></td></tr><tr><td>  Und <br></td><td>  Leela hat für mich mit Ja gestimmt <br></td></tr><tr><td>  Und <br></td><td>  Ich gehe zu People Nearby und öffne ein Leela-Profil <br></td></tr><tr><td>  Und <br></td><td>  Ich stimme "Ja" für Leela <br></td></tr><tr><td>  Dann <br></td><td>  Ich überprüfe die Übereinstimmungsseite <br></td></tr><tr><td>  Wann <br></td><td>  Ich beschließe, ein normales Geschenk zu senden <br></td></tr><tr><td>  Dann <br></td><td>  Ich überprüfe den Zahlungsbildschirm mit einer Liste von Paketen <br></td></tr><tr><td>  Wann <br></td><td>  Ich kaufe 550 Credits <br></td></tr><tr><td>  Dann <br></td><td>  Ich überprüfe die Benachrichtigung über den erfolgreichen Kauf <br></td></tr><tr><td>  Und <br></td><td>  Ich stelle sicher, dass Leela ein Chat-Geschenk erhalten hat <br></td></tr></tbody></table></div><br><br>  Testlauf Video: <br><br><img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br><br><h2>  Bewertung der Entscheidung: Hauptrisiken </h2><br>  Das Entfernen externer Abhängigkeiten birgt bestimmte Risiken. <br><br>  1. Falsche Konfiguration. <br><br>  Da die Überprüfung nicht auf unserer Seite ist, können wir unsere Produkte auf der Apple-Seite falsch konfigurieren.  Zum Schutz vor Fehlern haben wir einen separaten serverseitigen Komponententest geschrieben, der überprüft, ob alle Produkte, die wir auf der Apple-Seite starten, mit den Produkten in unserer Konfiguration übereinstimmen. <br><br>  2. Grenzfälle. <br><br>  Wenn die Zahlung beispielsweise vollständig abgeschlossen ist, erhält der Benutzer eine Benachrichtigung, dass er die Zahlung abgeschlossen hat. Unsere Anwendung kann jedoch den Scheck nicht finden, der aufgrund dieser Zahlung gefälscht werden soll.  Das Risiko liegt in der Tatsache, dass wir den Scheck selbst mit Hilfe einer Hintertür anbringen und einen solchen Fall natürlich nicht nachverfolgen können.  Um dieses Risiko irgendwie auszugleichen, führen wir nach der Freigabe End-to-End-Überprüfungen über die Sandbox oder eine echte Zahlung durch. <br><br>  3. Unfaire Fälschung oder Betrug. <br><br>  Nachdem Sie diesen Artikel gelesen haben, könnten Sie denken, dass Sie, da Badoo gefälschte Schecks verwendet, etwas Falsches an uns anhängen und den Service kostenlos nutzen können.  Damit dieses Risiko nicht eintritt, unterschreiben wir alles mit unserem eigenen Zertifikat und beschränken die Verwendung von Moks und Fake Checks auf Funktionstests, die nur in unserer Entwicklungsumgebung ausgeführt werden. <br><br>  4. Ändern Sie das Format des Schecks. <br><br>  Dies ist das schwerwiegendste Risiko.  Das Format eines Schecks kann geändert werden, wenn Apple etwas ändert, ohne uns zu warnen.  Wir hatten einen solchen Fall: Beim Wechsel zu iOS 11 änderte sich das Format der Prüfung vollständig.  Wir haben einen gefälschten Check auf unserem Server generiert und im Test verwendet.  Bei uns war alles perfekt: Alle Felder sind vorhanden, alles ist wunderbar, alles wird verarbeitet.  Aber als wir zum realen System wechselten, funktionierte nichts.  Felder, die für die Prüfung von Bedeutung waren, existierten einfach nicht mehr. <br><br>  Wie kann dieses Risiko kompensiert werden?  Erstens schließen wir die Möglichkeit eines End-to-End-Tests der Sandbox vor der Veröffentlichung und einer tatsächlichen Zahlung nach der Veröffentlichung nicht aus.  Jetzt befinden wir uns in der aktiven Phase eines Projekts zur Überprüfung von Benachrichtigungen, wenn wir versuchen, alle Überprüfungen, die wir von der Produktion erhalten, danach zu klassifizieren, ob wir verstehen, was es ist oder nicht.  Wenn die Antwort Nein lautet, beginnen wir, alles manuell zu verarbeiten, um zu sehen, was sich geändert hat, was falsch ist und was in unserem System geändert werden muss. <br><div class="scrollable-table"><table><tbody><tr><td>  Risiko <br></td><td>  Grund <br></td><td>  Wie zu kompensieren <br></td></tr><tr><td>  falsche Konfiguration <br></td><td>  Scheck löschen <br></td><td>  Unit-Test auf dem Server <br></td></tr><tr><td>  Randfälle <br>  (Scheck nicht geliefert) <br></td><td>  Hintertür benutzen <br></td><td>  E2E-Schecks (Sandbox und echte Zahlung) <br></td></tr><tr><td>  betrügerischer Betrug, Betrug <br></td><td>  Benachrichtigung und Scheckgenerierung auf dem Server <br></td><td>  eigenes Zertifikat <br></td></tr><tr><td>  Prüfformat ändern <br></td><td>  Benachrichtigung und Scheckgenerierung auf dem Server <br></td><td>  Überprüfung der tatsächlichen Benachrichtigungen und Überprüfung des Produkts (neues Projekt), <br>  E2E-Schecks (Sandbox und echte Zahlung) <br></td></tr></tbody></table></div><br><h2>  Ergebnis </h2><br><br>  Betrachten Sie die Hauptvorteile, die wir durch die Anwendung der Moki-Methode und des gefälschten Objekts erzielen konnten. <br><br><h4>  Preiswerte, schnelle und stabile Automatisierung kostenpflichtiger Dienste unter iOS </h4><br>  Zusammen mit dem manuellen Testteam von iOS (besonderer Dank an Colin Chan) konnten wir mehr als 150 automatische Tests für Zahlungen schreiben.  Dies ist eine ziemlich große Abdeckung für einen Bereich der Anwendung. <br><br>  Dank der Parallelisierung können wir das Ergebnis in nur 15 bis 20 Minuten in jedem Zweig des iOS-Client-Entwicklers oder Abrechnungsserver-Entwicklers erhalten.  Vor der Automatisierung dauerte das manuelle Testen dieses Bereichs durch eine Person acht Stunden. <br><br>  Wir können auch die überwiegende Mehrheit der Testfälle testen, indem wir den Mock Payment Provider über das Moki so einrichten, wie wir es benötigen.  Mithilfe von Mooks haben wir gelernt, wie Sie die Produktprüfung deaktivieren und Fälle simulieren, in denen die Prüfung teilweise durchgeführt wird.  So haben wir Fälle eröffnet, die wir vorher prinzipiell nicht testen konnten. <br><br><h4>  Funktionale Regression bei der Entwicklung neuer Funktionen </h4><br>  Die Automatisierung funktionierte sehr gut in den Fällen, in denen der Entwickler bei der Arbeit an einer neuen Funktion die alte Funktionalität beeinträchtigte.  Wir hatten ein Beispiel, als ein Entwickler eine komplexe Funktion mit Caching ausführte und unsere automatischen Tests durchführte.  Einige von ihnen sind irrtümlich gefallen.  Er sah es und reparierte es.  Dann startete er die Autotests erneut - und wieder fiel etwas.  Infolgedessen führte er eine Reihe von Iterationen durch, bis auf der Anwendungsseite alles normal zu funktionieren begann. <br><br><h4>  Funktionale Regression beim Zahlungs-Refactoring </h4><br>  Die vielleicht erfolgreichste und effizienteste Automatisierung, die möglich ist, findet im Bereich des Code-Refactorings statt.  In diesem Fall ändert sich nur die interne Implementierung - der Autotest-Code muss nicht geändert werden.  Die Benutzeroberfläche ändert sich in keiner Weise und Autotests können effizient gesteuert werden. <br><br><h4>  Testen experimenteller Funktionen von Apple: Kulanzfrist </h4><br>  Ein ähnliches System ist vollständig austauschbar, wenn Sie neue Integrationen testen, die noch nicht in der Sandbox implementiert sind.  So war es auch mit der Gnadenfrist.  Diese Funktionalität befindet sich nicht in der Sandbox.  Die Nachfrist für Apple steht noch nicht allen zur Verfügung.  Dies ist ein Pilotprojekt, das Badoo mit Apple umsetzt.  Um dies mit einer Nachfrist zu überprüfen, mussten wir hier einen solchen JSON-Code hinzufügen: <br><br><pre> <code class="json hljs">pending_renewal_info:[ { expiration_intent: <span class="hljs-number"><span class="hljs-number">2</span></span> grace_period_expires_date: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> Etc/GMT auto_renew_product_id: badoo.productId original_transaction_id: <span class="hljs-number"><span class="hljs-number">560000361869085</span></span> is_in_billing_retry_period: <span class="hljs-number"><span class="hljs-number">1</span></span> grace_period_expires_date_pst: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> America/Los_Angeles product_id: badoo.productId grace_period_expires_date_ms: <span class="hljs-number"><span class="hljs-number">1556207457000</span></span> auto_renew_status: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  <i><font color="gray">Listing 10. Nachfrist für ein Abonnement</font></i> <br><br>  Wir haben das sehr einfach in wenigen Sekunden gemacht.  In unserem System konnten wir unsere Reaktion auf eine neue Funktion testen.  Jetzt führen wir diese Funktionalität auf dem Produkt aus. <br><br><h4>  Produktqualitätsprüfung in Zusammensetzungsmethoden </h4><br>  Als Ergebnis unserer Forschung konnten wir eine Methode beschreiben, die Rauschen durch externe Abhängigkeiten eliminiert.  Dies half Client-Entwicklern bei der Entwicklung von Funktionen, Fehler in einem frühen Stadium zu finden. <br><br>  Aber denken Sie nicht, dass wir mit dieser Methode alles testen konnten.  Um alles zu testen, ist es besser, eine Zusammensetzung von Methoden zu verwenden: Testen mit einer echten Karte auf dem Produkt, Testen in der Sandbox, Testen von Mokes und gefälschten Objekten, Testen von Einheiten und Integration.  Bitte denken Sie an das Gleichgewicht der Testpyramide und versuchen Sie nicht, alle Probleme mit einer Methode zu lösen.  Dies kann zu einer traurigen Automatisierung in der Sandbox, zu traurigen manuellen Tests mit einer echten Karte aller Fälle und zu vielen anderen schwerwiegenden Fehlern genau dort führen, wo ihr Erscheinungsbild am schmerzhaftesten ist. <br><br><h2>  Fazit </h2><br>  Als Ergebnis unserer Forschung haben wir eine kostengünstige, schnelle und stabile Methode erhalten, um nicht nur kostenpflichtige Dienste unter iOS zu testen, sondern auch alle Komponenten, die als „Black Box“ in die Anwendung eingebettet sind.  Jetzt implementieren wir bei Badoo diese Methode zum Testen auf kostenpflichtigen Android-Anbietern (Global Charge, Boku, Centili), die instabile Sandboxen oder andere Einschränkungen aufweisen.  Wir verwenden die Moki-Methode auch zum Testen von Werbung, Streaming und Geolocation. <br><br>  Es ist erwähnenswert, dass der Prozess der Einführung einer neuen Methode nicht schnell war.  Ich musste mit vier Teams verhandeln: iOS QA, iOS Dev, Billing QA, Billing Dev.  Nicht jeder wollte aus Angst vor Risiken auf eine neue Methode umsteigen.  Manchmal war es eine dogmatische Folge: Viele Jahre lang haben wir im Sandkasten getestet, und die Hauptkraft, die das Dogma zerstören konnte, war der Wunsch der Abrechnungstester und der iOS-Plattform, die Situation zu ändern und Qualen loszuwerden.  Später erkannten die Entwickler solche Vorteile dieser Methode wie eine genaue Diagnose (wir konnten keine Fehler in der Sandbox finden, aber Fehler unseres Clients oder Servers), Flexibilität beim Einrichten der Komponente (wir konnten negative Fälle auf Integrationsebene leicht testen) und natürlich die Antwort 30 Minuten auf einem Zweig mit entwickeltem Code. <br><br>  Vielen Dank an alle, die bis zum Ende gelesen haben.  Vielen Dank an alle, die an diesem Projekt mitgewirkt haben.  Besonderer Dank geht an diese Leute: <br><br><ul><li>  Peter Kolpashchikov ist ein iOS-Entwickler, der Moki auf der Client-Seite entwickelt und ein PPP-Konzept entwickelt hat. <br></li><li>  Vladimir Solodov - Billing QA, der mit der QA-API beim Generieren von gefälschten Schecks und Checkout vom Abrechnungsserver geholfen hat; <br></li><li>  Maxim Filatov und Vasily Stepanov - Billing Dev Team, die beim Abrechnungsservercode geholfen haben; <br></li><li>  iOS Dev Team - Entwickler, die unsere Zahlungen in einem neuen Konzept umgestalten konnten, um die Verwendung von Mokas zu ermöglichen; <br></li><li>  Das iOS QA Team ist ein großartiges Testteam, das eine Reihe von Autotests geschrieben hat. <br></li><li>  Billing QA Team - Tester, die bei der Erforschung von Problemen geholfen haben. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460667/">https://habr.com/ru/post/de460667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460651/index.html">Treffen der Society of Anonymous Testers: TMS, Überwachung, Überwachung der Bewertung der Suchqualität und native iOS-Tests</a></li>
<li><a href="../de460655/index.html">Wie ich Telegramm gebrochen habe</a></li>
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie über Node.js wissen müssen</a></li>
<li><a href="../de460665/index.html">Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards?</a></li>
<li><a href="../de460669/index.html">So gewährleisten Sie die Sicherheit der Entwicklung, sparen Zeit und Nerven</a></li>
<li><a href="../de460671/index.html">Eigentum und Ausleihe in D.</a></li>
<li><a href="../de460673/index.html">Enthülle die Magie von DiffUtil</a></li>
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
<li><a href="../de460683/index.html">Laravel Event Projector und Event Generation Concept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>