<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîô üÜô üöÜ Automatisierung des Testens kostenpflichtiger Dienste unter iOS üìé üë® üë©üèø‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="F√ºr diejenigen, die sich f√ºr das Thema Automatisierung unter iOS interessieren, habe ich zwei Neuigkeiten - gut und schlecht. Gut: In der iOS-Anwendun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung des Testens kostenpflichtiger Dienste unter iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/460667/">  F√ºr diejenigen, die sich f√ºr das Thema Automatisierung unter iOS interessieren, habe ich zwei Neuigkeiten - gut und schlecht.  Gut: In der iOS-Anwendung f√ºr kostenpflichtige Dienste wird nur ein Integrationspunkt verwendet - In-App-K√§ufe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Anwendung integrierte K√§ufe</a> ).  Schlecht: Apple bietet keine Tools zur Automatisierung von Testk√§ufen an. <br><br>  In diesem Artikel schlage ich vor, dass Sie und ich nach einer universellen Automatisierungsmethode suchen, die √ºber Apples Gut und B√∂se hinausgeht.  Der Artikel ist f√ºr alle n√ºtzlich, die Dienste von Drittanbietern, die eine Black Box darstellen, in ihre Anwendungen integrieren: Werbung, Streaming, Standortverwaltung usw. Normalerweise sind solche Integrationen sehr schwer zu testen, da es keine M√∂glichkeit gibt, einen Dienst von Drittanbietern flexibel zum Testen der Anwendung zu konfigurieren. <br><br><img src="https://habrastorage.org/webt/fg/if/j3/fgifj3qfcwf_98iuebxjx-fxrka.jpeg"><br><a name="habracut"></a><br>  <i>Mein Name ist Victor Koronevich, ich bin Senior Test Automation Engineer bei Badoo.</i>  <i>Seit mehr als zehn Jahren in der mobilen Automatisierung t√§tig.</i>  <i>Zusammen mit meinem Kollegen Vladimir Solodov haben wir diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> auf der Heisenbug-Konferenz erstellt.</i>  <i>Er half mir auch bei der Vorbereitung dieses Textes.</i> <br><br>  Im vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel haben</a> wir beschrieben, mit welchen Methoden Badoo die Integration mit Zahlungsanbietern testet, von denen wir mehr als 70 haben. In diesem Artikel werden wir mehr dar√ºber sprechen, wie wir es geschafft haben, eine stabile und kosteng√ºnstige Automatisierung des Testens von kostenpflichtigen Diensten in einer iOS-Anwendung zu erreichen. <br><br>  Beginnen wir mit einer allgemeinen Beschreibung unserer Forschung: <br><br><ol><li>  Problemdefinition <br></li><li>  Erkl√§rung des Problems <br></li><li>  L√∂sung Nr. 1.  Apple Sandbox <br></li><li>  Entscheidung Nr. 2.  Funktions-Mock-Methode und Verwenden eines gef√§lschten Objekts <br></li><li>  Bewertung der Entscheidung: Hauptrisiken <br></li><li>  Ergebnis <br></li><li>  Fazit <br></li></ol><br><h2>  Problemdefinition </h2><br>  Automatisierung muss durchgef√ºhrt werden, wenn ein nat√ºrlicher Bedarf entsteht.  Wann kam dieser Moment mit uns? <br><br>  Es gibt viele kostenlose Funktionen in der Badoo-App, aber kostenpflichtige bieten dem Benutzer mehr Optionen.  Sie erhalten sie auf zwei Arten: f√ºr Kredite - die interne W√§hrung von Badoo - oder durch den Kauf eines Premium-Abonnements.  F√ºr eine bestimmte Anzahl von Credits k√∂nnen Sie Ihr Profil in den Suchergebnissen auf den ersten Platz heben, einem anderen Benutzer ein Geschenk machen und vieles mehr.  Das Premium-Abonnement ist f√ºr einen bestimmten Zeitraum g√ºltig und bietet mehrere Optionen gleichzeitig: Aktivieren Sie den Unsichtbarkeitsmodus, sehen Sie Personen, die Sympathie f√ºr Sie gezeigt haben, stornieren Sie das Ergebnis Ihrer Abstimmung und andere. <br><br>  Diese Funktionen wurden nach und nach in Badoo angezeigt.  Und vor ein paar Jahren haben wir kostenpflichtige Dienste in iOS-Anwendungen nur manuell getestet.  Da jedoch Funktionen und neue Bildschirme angezeigt werden, dauerte das manuelle Testen immer l√§nger.  Die Anforderungen f√ºr √Ñnderungen in der Anwendung kamen von verschiedenen Seiten: von den Entwicklern der Clientseite, den Entwicklern der Serverseite und sogar vom Apple-Anbieter selbst.  F√ºr einen Tester dauerte eine Testiteration ungef√§hr acht Stunden.  Es wurde unm√∂glich, innerhalb von 30 Minuten ein schnelles Feedback f√ºr einen Entwickler in seiner Branche zu erhalten, was sich letztendlich negativ auf die Wettbewerbsf√§higkeit des Produkts auswirken k√∂nnte. <br><br>  Wir wollten so schnell wie m√∂glich Testergebnisse erhalten.  Und sie stie√üen auf ein Problem: Wie k√∂nnen Regressionstests f√ºr kostenpflichtige Dienste in unseren iOS-Anwendungen kosteng√ºnstig organisiert werden, um schnelle und stabile Ergebnisse zu erzielen? <br><br><h2>  Erkl√§rung des Problems </h2><br>  Unter Ber√ºcksichtigung der Besonderheiten unseres Lieferprozesses des Endprodukts und der Gr√∂√üe des Teams m√∂chten wir: <br><br><ul><li>  Testen Sie alle Eink√§ufe innerhalb der Kundenanwendung (einmalige Zahlungen und Abonnements). <br></li></ul><br><ul><li>  Wiederholen Sie die Testiterationen 10 bis 20 Mal am Tag. <br></li><li>  Erhalten Sie Testergebnisse ~ 150 Testskripte in weniger als einer halben Stunde; <br></li><li>  L√§rm loswerden; <br></li><li>  Sie k√∂nnen Tests f√ºr einen bestimmten Zweig des Entwicklercodes ausf√ºhren, unabh√§ngig von den Ergebnissen anderer L√§ufe. <br></li></ul><br>  Nachdem wir die Aufgabe formuliert haben, ist es Zeit, die Reise in die wunderbare Welt der Ingenieure und ihrer L√∂sungen zu beginnen. <br><br><h2>  L√∂sung Nr. 1.  Apple Sandbox </h2><br>  Zun√§chst suchten wir in der Apple-Dokumentation nach Informationen zum Organisieren des automatischen Testens kostenpflichtiger Dienste.  Und sie haben nichts gefunden.  Die Automatisierungsunterst√ºtzung sieht sehr d√ºrftig aus.  Wenn etwas angezeigt wird, ist es schwierig, die Automatisierung mit den vorgeschlagenen Tools <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einzurichten</a> (erinnern wir uns zumindest an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UIAutomation</a> sowie an die Zeit, als das erste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xcrun simctl-</a> Dienstprogramm f√ºr iOS Simulator erschien), und Sie m√ºssen nach technischen L√∂sungen suchen, auch im Open-Source-Segment. <br><br>  In der Apple-Dokumentation zum Testen kostenpflichtiger Dienste finden Sie nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple Sandbox</a> .  Es war nicht klar, wie diese Sandbox mit der Automatisierung verbunden werden sollte, aber wir haben uns entschlossen, diese L√∂sung ernsthaft zu untersuchen.  Die Tatsache, dass die Android-Sandbox stabil war, gab uns Vertrauen, und zu diesem Zeitpunkt hatten wir bereits erfolgreich Tests f√ºr Android geschrieben.  Vielleicht ist die Apple Sandbox genauso gut? <br><br>  Aber als wir Autotests mit dieser Sandbox implementiert haben, haben wir voll getrunken.  Lassen Sie uns kurz auf die Hauptprobleme eingehen. <br><br><h3>  1. Der Pool der Testbenutzer </h3><br>  Die Haupteinschr√§nkung f√ºr die Automatisierung sind die Merkmale des Inhalts im Pool der Testbenutzer, die die Unabh√§ngigkeit des Starts von Autotests gew√§hrleisten sollen. <br><br>  Um nur einen automatischen Kauf eines Abonnementkaufs durchzuf√ºhren, ben√∂tigen wir: <br><br><ol><li>  Nehmen Sie einen neuen Benutzer zur Autorisierung in die Sandbox. <br></li><li>  √Ñndern Sie auf dem Simulator die aktuell verkn√ºpfte Apple ID. <br></li><li>  Melden Sie sich mit Badoo bei Badoo an <br></li><li>  Rufen Sie den Bildschirm des Abonnementkaufs auf und w√§hlen Sie ein Produkt aus. <br></li><li>  Best√§tigen Sie den Kauf und melden Sie sich √ºber die Apple ID an. <br></li><li>  Stellen Sie sicher, dass der Kauf erfolgreich war. <br></li><li>  Badoo-Benutzer zur Reinigung senden; <br></li><li>  L√∂schen Sie den Benutzer der Sandbox von Abonnements. <br></li></ol><br>  Wenn Sie versuchen, im n√§chsten Test sofort denselben Benutzer zu verwenden, ist es unm√∂glich, ein zweites Abonnement zu kaufen.  Sie m√ºssen warten, bis das erste Abonnement "schlecht" wird, oder sich in den Einstellungen abmelden.  Wie bereits im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel erw√§hnt</a> , hat die Sandbox eine bestimmte G√ºltigkeitsdauer f√ºr Abonnements.  Wenn Sie ein Abonnement "f√ºr einen Monat" kaufen, m√ºssen Sie f√ºnf Minuten warten, um es automatisch zu schlie√üen.  Der Abmeldevorgang selbst ist ebenfalls nicht schnell. <br><br>  Dementsprechend m√ºssen wir f√ºr einen neuen Durchlauf desselben Tests entweder warten, bis das Abonnement endet, oder einen anderen ‚Äûsauberen‚Äú Benutzer nehmen.  Wenn wir zwei Tests gleichzeitig unabh√§ngig voneinander ausf√ºhren m√∂chten, m√ºssen mindestens zwei Sandbox-Benutzer im Pool vorhanden sein.  Um 100 Autotests parallel in 100 Threads auszuf√ºhren, ben√∂tigen wir 100 verschiedene Benutzer. <br><br>  Stellen wir uns nun vor, wir f√ºhren einen Selbsttest mit zwei Agenten durch, von denen jeder sie in 100 Threads ausf√ºhren kann.  In diesem Fall ben√∂tigen wir mindestens 200 Benutzer! <br><br><h3>  2. "Schlechte" Benachrichtigungen </h3><br>  Nun, was zum Teufel scherzt nicht!  Wir organisierten einen Benutzerpool und begannen zu beobachten, wie Tests ablaufen.  Sie fielen die Stra√üe entlang, aber die Mehrheit - aus neuen, uns unbekannten Gr√ºnden.  Wir begannen zu verstehen und erkannten, dass der App Store beim Autorisieren, Best√§tigen eines Kaufs und Arbeiten als Benutzer in der Sandbox Warnungen sendet: Er fragt beispielsweise nach einem neuen Benutzernamen und Passwort, best√§tigt die Autorisierung durch Klicken auf die Schaltfl√§che ‚ÄûOK‚Äú und gibt Informationen √ºber einen internen Fehler mit der Schaltfl√§che ‚ÄûOK‚Äú aus .  Manchmal erscheinen sie, manchmal nicht.  Und wenn sie erscheinen, dann immer in einer anderen Reihenfolge. <br><br><img src="https://habrastorage.org/webt/sq/tu/1j/sqtu1ja-altpboz3pcudwnz8flm.gif"><br><br>  Wie ist es m√∂glich, dass ein verd√§chtiger Fehler bei einem Autotest einfach ignoriert wird?  Und wenn ein echter Fehler eintritt, was soll ich dann tun?  Dieser Bereich wurde f√ºr uns automatisch zu einer ‚Äûblinden Zone‚Äú, und wir mussten spezielle Handler f√ºr alle m√∂glichen Warnungen schreiben, die aus dem App Store kommen konnten. <br><br>  All dies verlangsamte die Tests: <br><br><ul><li>  Warnungen k√∂nnen zu verschiedenen Schritten des Testszenarios f√ºhren und die Hauptidee des Tests zerst√∂ren - Vorhersagbares Testszenario;  Wir mussten einen Fehlerbehandler hinzuf√ºgen, der erwartete, dass eine m√∂gliche Reihe bekannter ignorierter Warnungen angezeigt wird. <br></li><li>  Manchmal kamen neue Variationen von Warnungen an oder es traten andere Fehler auf, sodass wir die gefallenen Tests neu starten mussten.  Dies erh√∂hte die Laufzeit aller Tests. <br></li></ul><br><h3>  3. Gab es einen Test? </h3><br>  Benutzer im Pool werden also blockiert und dann f√ºr n Minuten gel√∂scht.  Wir f√ºhren Tests in 120 Threads durch, und es gibt bereits ziemlich viele Benutzer im Pool, aber das reicht nicht aus.  Wir haben unser Benutzerverwaltungssystem erstellt, einen Alert-Handler erstellt - und dann ist die IT passiert.  Die Sandbox ist f√ºr einige Testbenutzer seit einigen Tagen nicht mehr verf√ºgbar. <br><br>  Niemand hat das erwartet.  Und dies war der letzte Strohhalm im Kelch unserer Geduld, der schlie√ülich die Liebe zum Apfel-Sandkasten t√∂tete und uns auf den Weg jenseits von Gut und B√∂se brachte.  Wir haben erkannt, dass wir eine solche Automatisierung nicht brauchen und dass wir mit dieser gef√§hrlichen Entscheidung nicht mehr leiden wollen. <br><br><h2>  Entscheidung Nr. 2.  Funktions-Mock-Methode und Verwenden eines gef√§lschten Objekts </h2><br>  Also haben wir Probleme mit der Automatisierung in der Sandbox von Apple getrunken.  Aber denken Sie nicht, dass in der mobilen Welt alles v√∂llig schlecht ist.  Unter Android ist die Sandbox viel stabiler - Sie k√∂nnen dort Autotests ausf√ºhren. <br><br>  Versuchen wir, eine andere L√∂sung f√ºr iOS zu finden.  Aber wie soll man aussehen?  Wo soll man suchen?  Schauen wir uns die Geschichte des Testens und der Softwareentwicklung an: Was ist mit der verr√ºckten Welt von Apple passiert?  Was sagen Menschen, die eine Reihe von B√ºchern geschrieben und Autorit√§t in der Welt der Automatisierung und Softwareentwicklung erworben haben? <br><br>  Ich erinnerte mich sofort an die Arbeit ‚ÄûxUnit Test Patterns: Refactoring Test Code‚Äú von Gerard Mesaroche ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rezension von</a> Martin Fowler) - meiner Meinung nach eines der besten B√ºcher f√ºr jeden Tester, der mindestens eine Programmiersprache auf hohem Niveau kennt und Automatisierung betreiben m√∂chte .  Ein paar Kapitel dieses Buches, die sich dem isolierten Testen von SUT von anderen Komponenten der Anwendung widmen, die unsere ‚ÄûBlack Box‚Äú sind, k√∂nnen uns helfen. <br><br><h3>  1. Einf√ºhrung in Mokka und Fake </h3><br>  Es sollte beachtet werden, dass es in der Welt des automatischen Testens keine allgemein akzeptierte Grenze zwischen den Konzepten Testdoppel, Teststub, Testspion, Scheinobjekt, gef√§lschtes Objekt, Dummy-Objekt gibt.  Sie m√ºssen immer die Terminologie des Autors ber√ºcksichtigen.  Wir brauchen nur zwei Konzepte aus der gro√üen Welt der Test Doubles: eine Scheinfunktion und ein gef√§lschtes Objekt.  Was ist das?  Und warum brauchen wir das?  Wir geben eine kurze Definition dieser Konzepte, damit wir keine Meinungsverschiedenheiten haben. <br><br>  Angenommen, wir haben eine Anwendung und eine Komponente eingebaut, die f√ºr uns eine ‚ÄûBlack Box‚Äú ist.  Innerhalb der Anwendung k√∂nnen wir Funktionen aufrufen, indem wir auf diese Komponente zugreifen und die Ergebnisse dieser Funktionen abrufen.  Je nach Ergebnis reagiert unsere Anwendung spezifisch.  Manchmal kann das Ergebnis der Funktionsausf√ºhrung eine ganze Entit√§t mit einer Reihe von Feldern sein, die die tats√§chlichen Benutzerdaten widerspiegeln. <br><br>  Wenn Sie eine Funktion durch eine andere ersetzen, die das gew√ºnschte Ergebnis zur√ºckgibt, rufen Sie den Mock der Funktion oder einfach den Mock auf.  Diese Funktionen haben m√∂glicherweise dieselbe Signatur, es handelt sich jedoch um zwei verschiedene Funktionen. <br><br>  Und das Ersetzen einer Entit√§t, die als Ergebnis der Funktion f√ºr eine gef√§lschte Entit√§t erhalten wird (die die erforderlichen Daten in den Feldern und manchmal sogar besch√§digte Daten enth√§lt), wird als Implementierung eines gef√§lschten Objekts bezeichnet.  Sie k√∂nnen mehr dar√ºber in dem oben erw√§hnten Buch oder in einem anderen Kompendium zum Testen und zur Softwareentwicklung lesen. <br><br>  Lassen Sie uns abschlie√üend einige Funktionen zur Verwendung von Scheinfunktionen und gef√§lschten Objekten hervorheben: <br><br><ol><li>  Um die Funktionen nass zu machen, m√ºssen Sie auf den Quellcode zugreifen und wissen, wie die Anwendung auf Entwicklerebene von innen mit der Komponente funktioniert. <br></li><li>  Um ein gef√§lschtes Objekt zu implementieren, m√ºssen Sie die Struktur des realen Objekts kennen. <br></li><li>  Die Verwendung der Mock-Funktion erm√∂glicht eine flexible Konfiguration der Anwendung mit der Komponente. <br></li><li>  Durch die Verwendung eines gef√§lschten Objekts k√∂nnen Sie einer Entit√§t beliebige Eigenschaften verleihen. <br></li></ol><br>  Die Moki- und Fake-Object-Methode ist ideal, um den Betrieb einer Komponente innerhalb einer Anwendung zu isolieren.  Mal sehen, wie wir diese Methode anwenden k√∂nnen, um unser Problem zu l√∂sen, wobei der App Store die Komponente sein wird.  Aufgrund der Besonderheiten dieser Methode m√ºssen wir uns zun√§chst mit der Untersuchung der Art der Arbeit unserer Anwendung mit der Komponente befassen und dann mit der technischen Implementierung, um bestimmte Mokeys und gef√§lschte Objekte herzustellen. <br><br><h2>  2. Wie kommt es zu einem echten Kauf? </h2><br>  Bevor wir beginnen, die Interaktion aller Teile des Systems zu beschreiben, wollen wir die Hauptakteure hervorheben: <br><br><ul><li>  Anwendungsbenutzer - Jeder Akteur, der Aktionen mit der Anwendung ausf√ºhrt, kann eine Person sein oder es kann ein Skript geben, das die erforderlichen Anweisungen ausf√ºhrt. <br></li><li>  Anwendung (in unserem Fall verwenden wir die im iOS-Simulator installierte Badoo iOS-Anwendung); <br></li><li>  Server - ein Akteur, der Anforderungen von der Anwendung verarbeitet und Antworten oder asynchrone Benachrichtigungen ohne Clientanforderung zur√ºcksendet (in diesem Fall meinen wir einen abstrakten Badoo-Server, um die Struktur zu vereinfachen); <br></li><li>  Der App Store ist ein Akteur, der f√ºr uns eine ‚ÄûBlack Box‚Äú darstellt: Wir wissen nicht, wie er im Inneren angeordnet ist, aber wir kennen die √∂ffentliche Oberfl√§che f√ºr die Verarbeitung von Eink√§ufen innerhalb der Anwendung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StoreKit-Framework</a> ) und wissen auch, wie Daten auf einem Apple-Server √ºberpr√ºft werden. <br></li></ul><br>  Mal sehen, wie der Kauf erfolgt.  Der gesamte Prozess ist im Diagramm dargestellt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kw/1l/tg/kw1ltgj7slrlftse7zykm-hrlec.png" width="600"></div><br>  <i><font color="gray">Abbildung 1. Zahlungsschema im App Store</font></i> <br><br>  Wir werden Schritt f√ºr Schritt die Hauptaktionen der Akteure beschreiben. <br><br>  1. Ausgangspunkt ist der Status aller Akteure, bevor der Bildschirm mit einer Produktliste ge√∂ffnet wird. <br><br>  Was ist dieser Bildschirm und wie sind wir darauf gekommen? <br><br>  Angenommen, ein Benutzer hat eine interessante Person gefunden, sein Profil ge√∂ffnet, eine Nachricht geschrieben und wollte ein Geschenk senden.  Das Senden eines Geschenks ist eine kostenpflichtige Dienstleistung.  Der Benutzer kann im Profil zu dem Abschnitt zum Senden von Geschenken scrollen oder sofort ein Geschenk aus dem Chat ausw√§hlen. <br><br>  Wenn der Benutzer ein Geschenk ausw√§hlt und kein Geld auf dem Konto hat, wird eine Liste der verschiedenen Darlehenspakete (Zahlungsassistent) zum Kauf angezeigt.  Der Ausgangspunkt in unserem Beispiel ist eine Liste von Geschenken.  In der Abbildung k√∂nnen wir einen solchen Punkt auf jedem Bildschirm betrachten, bevor wir die Liste der Produkte f√ºr den Kauf von Darlehen oder Abonnements anzeigen. <br><br>  2. √ñffnen einer Produktliste. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hn/9y/e-/hn9ye-ipwd_pblpxfgbawcpebok.jpeg" width="500"></div><br>  Wir stehen zum Beispiel auf der Geschenkliste am Ausgangspunkt.  Der Benutzer w√§hlt eines der Geschenke in der Anwendung aus.  Die Anwendung fordert unseren Server auf, eine Liste m√∂glicher Produkt-ID-Darlehenspakete (100, 550, 2000, 5000) zu erhalten.  Der Server gibt diese Liste an die Anwendung zur√ºck. <br><br>  Als N√§chstes sendet die Anwendung die empfangene Produkt-ID-Liste zur √úberpr√ºfung an den App Store-Akteur (StoreKit-System-iOS-Framework, das an den Apple-Server gesendet wird).  Es gibt eine Liste bew√§hrter Produkte zur√ºck - und als Ergebnis zeigt die Anwendung dem Benutzer die endg√ºltige Liste der Darlehenspakete mit Symbolen und Preisen. <br><br>  3. Produktauswahl und Quittungserstellung. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ua/3j/jd/ua3jjdi5ifqqc0n6fiaqmg3elvq.jpeg" width="500"></div><br>  Der Benutzer w√§hlt ein kostenpflichtiges Produkt aus.  Der App Store erfordert einen Kaufnachweis und eine Autorisierung √ºber die Apple ID.  Nach erfolgreicher Benutzerautorisierung wird die Kontrolle auf die Anwendung √ºbertragen.  Die Anwendung wartet darauf, dass eine Quittung in ihrem eigenen Paket generiert wird.  Der Benutzer sieht zu diesem Zeitpunkt die Sonne, die den Bildschirm sperrt.  Diese generierte Quittung kann mit der Methode appStoreReceiptURL der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bundle-</a> Klasse verstanden werden.  Nachdem der Scheck vom App Store generiert wurde, w√§hlt die Anwendung den Scheck aus ihrem Paket aus und sendet eine Anfrage mit dem Scheck und den Benutzerdaten an den Badoo-Server. <br><br>  4. √úberpr√ºfen Sie die Pr√ºfung auf dem Badoo-Server. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/4l/ag/qw4laggdbnz4zswxh-b6eopdk-y.jpeg" width="500"></div><br>  Sobald der Badoo-Server die Pr√ºf- und Benutzerdaten erh√§lt, sendet er diese an die Apple-Serverseite zur√ºck, um den ersten √úberpr√ºfungszyklus durchzuf√ºhren.  Dies ist eine der Empfehlungen von Apple.  In diesem ersten √úberpr√ºfungszyklus erh√§lt der Server dann Informationen √ºber den aktuellen Status des Abonnements. <br><br>  5. Senden von Push-Benachrichtigungen (Push-Benachrichtigung) vom Server. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/ne/ou/yqneoujlb2271__24hinousfjz8.jpeg" width="500"></div><br>  Der Badoo-Server verarbeitet die empfangenen Informationen nach √úberpr√ºfung durch Apple erneut und sendet der Anwendung eine Antwort zusammen mit einer Push-Benachrichtigung. <br><br>  6. Push-Benachrichtigung in der Anwendung. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mw/mx/vq/mwmxvqn6zutjpg45rmcq6tibudc.jpeg" width="500"></div><br>  Wenn es sich um einen Kauf von Darlehen handelte, √§ndert sich sofort das Guthaben des Benutzers in der Anwendung und er sieht das gesendete Geschenk im Chat.  Wenn dies ein Abonnementkauf war, sollte der Benutzer auf die endg√ºltige Push-Benachrichtigung warten, dass das Abonnement aktiviert ist. <br><br><h3>  3. Ermittlung von Abh√§ngigkeiten und Testschleife </h3><br><br>  Zur weiteren Diskussion stellen wir zwei weitere Konzepte vor - die externe Abh√§ngigkeit und die Testschaltung. <br><br><h4>  Externe Abh√§ngigkeit </h4><br>  Unter externen Abh√§ngigkeiten verstehen wir jede Interaktion mit einer Komponente, die f√ºr uns eine ‚ÄûBlack Box‚Äú ist.  In diesem Fall fungiert der App Store als solche Komponente in Form eines iOS-Systemframeworks (StoreKit), mit dem unsere iOS-Anwendung funktioniert, und eines Apple-Servers, auf dem √úberpr√ºfungsanforderungen gestellt werden. <br><br>  Das Verwalten dieser Abh√§ngigkeiten unter realen Bedingungen ist nicht m√∂glich. Die Anwendung ist gezwungen, auf die Ausgangssignale der Black Box zu reagieren (siehe Abb. 2). <br><br>  Wir haben drei externe Abh√§ngigkeiten: <br><br><ol><li>  √úberpr√ºfen von StoreKit-Produkten. <br></li><li>  Empfangen und Ersetzen eines Kaufbelegs. <br></li><li>  √úberpr√ºfen einer Pr√ºfung auf einem Badoo-Server. <br></li></ol><br><img src="https://habrastorage.org/webt/ix/dd/mr/ixddmrcv7pwgene4fw12269cfeg.jpeg"><br>  <i><font color="gray">Abbildung 2. Externe Abh√§ngigkeiten</font></i> <br><br><h4>  Testschaltung </h4><br>  Testschaltung - Dies sind Abschnitte des Pfades, den wir w√§hrend des Testprozesses durchlaufen und √ºberpr√ºfen werden. <br><br><img src="https://habrastorage.org/webt/26/m3/_u/26m3_uxzsdcrewtozcmgqihwbyu.jpeg"><br>  <i><font color="gray">Abbildung 3. Testschleife</font></i> <br><br>  Das Ziel unserer Arbeit zur Beseitigung von Abh√§ngigkeiten ist es, eine Testschaltung zu erstellen, die so nah wie m√∂glich am tats√§chlichen Pfad liegt und es Ihnen erm√∂glicht, alle externen Abh√§ngigkeiten auszuschlie√üen und die Kontrolle auf Ihre Seite zu √ºbertragen. <br><br>  Wir betrachten jede Abh√§ngigkeit nacheinander. <br><br><h3>  4. Isolation von Abh√§ngigkeiten: technische Umsetzung </h3><br>  In unserem Unternehmen wurde f√ºr die Implementierung von Zahlungen ein PPP-Konzept verwendet, das auf der Schnittstelle des Zahlungsanbieters basiert.  Dies ist die Hauptschnittstelle f√ºr die Interaktion mit dem App Store-Akteur (StoreKit) in unserer Anwendung, die √ºber zwei Hauptmethoden verf√ºgt: <br><br><ol><li>  vorbereiten ist die Methode, die f√ºr die √úberpr√ºfung der Produkte verantwortlich ist; <br></li><li>  makePayment ist eine Methode, die einen In-App-Kauf verarbeitet. <br></li></ol><br>  Alle Zahlungen unter iOS wurden gem√§√ü diesem Konzept √ºberarbeitet, wodurch wir einen einfachen und bequemen Mock Payment Provider der Klasse erhalten konnten.  Dies ist die Hauptschnittstelle f√ºr die Interaktion mit einer praktischen Kopie des StoreKit-Verhaltens in unserer Anwendung.  Was bedeutet "bequemes Kopieren"?  Dieser Anbieter verf√ºgt √ºber Verspottungen der Methoden prepare und makePayment, die das tun, was wir wollen.  Schauen wir uns ein Beispiel f√ºr Codeteile an, wie wir es geschafft haben, Moki zu integrieren. <br><br><h4>  Abh√§ngigkeit Nr. 1.  √úberpr√ºfen von StoreKit-Produkten </h4><br>  Verwenden Sie zum √úberpr√ºfen der Produktliste die Vorbereitungsfunktion, die eine Liste der √ºberpr√ºften Produkte zur√ºckgibt.  Wir k√∂nnen das Modell verwenden, in dem wir die Pr√ºfung deaktivieren und die eingehende Liste der Produkte als vollst√§ndig verifiziert zur√ºcksenden.  Somit wird die Abh√§ngigkeit beseitigt. <br><br><img src="https://habrastorage.org/webt/nr/nd/xj/nrndxjbquf5uuddom1zw4pcwkky.jpeg"><br>  <i><font color="gray">Abbildung 4. Das erste Schema zur Beseitigung von Abh√§ngigkeiten</font></i> <br><br>  Ganz oben in der Architektur unserer Anwendung steht der Zahlungsanbieter.  Es spiegelt die Schnittstelle eines m√∂glichen Anbieters in der Anwendung wider.  Der Code zum Implementieren von mok befindet sich in der Klasse Mock Payment Provider. <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> receipt: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeKitTransactionID: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products } ... }</code> </pre> <br>  <i><font color="gray">Listing 1. Mock Client Check</font></i> <br><br>  Beim Mock Payment Provider k√∂nnen wir die Implementierung der Vorbereitungsmethode sehen.  Die Magie von Moka stellt sich als sehr einfach heraus: Die Methode √ºbersprang die √úberpr√ºfung von Produkten auf der StoreKit-Seite und gibt einfach eine eingehende Liste von Produkten zur√ºck.  Die eigentliche Implementierung von prepare sieht folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(products: [BMProduct])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">BMProduct</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> validatedProducts = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.productsSource.validate(products: products) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> validatedProducts }</code> </pre><br>  <i><font color="gray">Listing 2. Real Store Zahlungsanbieter</font></i> <br><br><h3>  Abh√§ngigkeit Nr. 2.  Empfangen und Ersetzen eines Kaufbelegs </h3><br>  Die zweite Abh√§ngigkeit ist etwas komplizierter: Wir m√ºssen zuerst die Autorisierung entfernen, um den Pool der Benutzerkonten nicht zu behalten, und dann irgendwie die Pr√ºfung selbst erhalten.  Wir k√∂nnen das Autorisierungsformular einfach l√∂schen: <br><br><img src="https://habrastorage.org/webt/ir/zr/ak/irzrakxn_kx2ylzcdaudvux5pv4.jpeg"><br>  <i><font color="gray">Abbildung 5. L√∂schen eines Autorisierungsformulars bei der Zahlung</font></i> <br><br>  Mit einem Scheck ist das nicht so einfach.  Es gibt viele Fragen: <br><br><ol><li>  Wie bekomme ich im Voraus eine Quittung f√ºr das richtige Produkt? <br></li><li>  Wenn wir den Scheck erhalten haben, wann und wie k√∂nnen wir ihn in die Anwendung einf√ºgen? <br></li></ol><br>  Hier hat der Schauspieler "User" eine neue Rolle - QA.  Wenn wir den Test ausf√ºhren, k√∂nnen wir nicht nur auf die Schaltfl√§chen auf der Benutzeroberfl√§che klicken, sondern auch die API-Methoden des Testframeworks (Methoden, die Benutzeraktionen simulieren) und die REST-API-Services (Methoden, die vom internen Badoo-Service aus Magie ausf√ºhren k√∂nnen) aufrufen.  Wir bei Badoo verwenden ein sehr leistungsf√§higes QA-API-Tool (alle Funktionen finden Sie unter dem Link: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://vimeo.com/116931200</a> ).  Er ist es, der uns beim Testen hilft und auf der Serverseite von Badoo nach dem richtigen Produkt sucht.  Der Badoo-Server ist der beste Ort, um Schecks zu generieren: Der Scheck wird verschl√ºsselt und entschl√ºsselt, sodass der Server alles √ºber diese Datenstruktur wei√ü. <br><br>  Nachdem wir einen gef√§lschten Scheck erhalten haben, k√∂nnen wir ihn durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hintert√ºr</a> auf der Anwendungsseite stellen.  Als n√§chstes sendet die Anwendung einen gef√§lschten Scheck zusammen mit Benutzerdaten an unseren Server. <br><br><img src="https://habrastorage.org/webt/uu/h5/03/uuh503gnoqehjqguhzjhydujvs8.jpeg"><br>  <i><font color="gray">Abbildung 6. Schema f√ºr den Empfang</font></i> <br><br>  Wie wurde dies technisch m√∂glich? <br><br>  1. Um einen gef√§lschten Scheck in der Anwendung einzurichten, konnten wir eine Hintert√ºr verwenden, die den gef√§lschten Scheck im Feld MockPaymentProvider der Quittung speicherte: <br><br><pre> <code class="swift hljs">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">BUILD_FOR_AUTOMATION</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BadooAppDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMockPurchaseReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> receipt: String?)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">PaymentProvidersFactory</span></span>.useMockPaymentProviderForITunesPayments = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt = receipt } ... } #endif</code> </pre> <br>  <i><font color="gray">Listing 3. Fake Check Backdoor</font></i> <br><br>  2. Die Anwendung konnte unseren Scheck dank MockPaymentProvider entgegennehmen, in dem wir das makePayment-Modell und den gespeicherten Scheck in MockPaymentProvider.receipt verwendet haben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockPaymentProvider</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentProvider</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePayment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transaction: BPDPaymentTransactionContext)</span></span></span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receiptData = <span class="hljs-type"><span class="hljs-type">MockPaymentProvider</span></span>.receipt?.data(using: .utf8) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">BPDPurchaseReceiptRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.networkService.send(request, completion: { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (<span class="hljs-number"><span class="hljs-number">_</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> receipt = request.responsePayload() { sSelf.delegate?.paymentProvider(sSelf, didReceiveReceipt: receipt) } }) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.delegate?.paymentProvider(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailTransaction: transaction) } } }</code> </pre> <br>  <i><font color="gray">Listing 4. Aufruf eines Kaufabwicklungs-Moka mit einem gef√§lschten Scheck</font></i> <br><br>  3. Einen gef√§lschten Scheck bekommen <br><br>  Um eine gef√§lschte Pr√ºfung zu erhalten, haben wir die Methode auf dem Server verwendet (siehe Listing 5).  Es wird ein Standardarray mit Daten zum Generieren von Pr√ºfdaten verwendet und die f√ºr ein bestimmtes Produkt erforderlichen Daten hinzugef√ºgt. <br><br><pre> <code class="php hljs">$new_receipt_model = array_replace_recursive( <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;getDefaultModel(), //       //,      $this-&gt;enrichModelUsingSubscription($nr), //        $this-&gt;enrichModelUsingInput($input) ); //  $new_receipt = $this-&gt;signReceipt( json_encode($new_receipt_model, true), $new_receipt_model );</span></span></code> </pre><br>  <i><font color="gray">Listing 5. Serverteil der Scheckgenerierung</font></i> <br><br>  Um die Struktur einer echten Pr√ºfung zu wiederholen, muss die von der Anwendung gesendete benutzerdefinierte Pr√ºfung mit einem Zertifikat verschl√ºsselt werden.  Wir verwenden unser Arbeitszertifikat anstelle des Apple-Zertifikats. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signReceipt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt, $response)</span></span></span><span class="hljs-function">  </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     base64 $receipt = 'Subject: ' . base64_encode(json_encode($response)) . PHP_EOL . PHP_EOL . $receipt; file_put_contents($receipt_file, $receipt); ... //    $sign_result = openssl_pkcs7_sign( $receipt_file, $signed_receipt_file, 'file://'.$path_cert, 'file://'.$path_key, [], PKCS7_BINARY); ... //  $signed_content_with_headers = file_get_contents($signed_receipt_file); list($headers, $signed_content) = explode(PHP_EOL . PHP_EOL, $signed_content_with_headers); //  return str_replace(["\r\n", "\r", "\n"], '', $signed_content); }</span></span></code> </pre><br>  <i><font color="gray">Listing 6. Methode zum Signieren eines Schecks mit einem Zertifikat</font></i> <br><br>  4. Als Ergebnis erhalten wir im Test: <br><br><pre> <code class="ruby hljs">(<span class="hljs-regexp"><span class="hljs-regexp">/       "((\d+) |  (\d+) ?/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|service_type|</span></span> <span class="hljs-comment"><span class="hljs-comment">#    service_details = parse_options(service_type) #  QA API (  Badoo) receipt = QaApi::Billing.order_get_app_store_receipt(service_details) #   Backdoors.set_fake_receipt(receipt) end</span></span></code> </pre><br>  <i><font color="gray">Listing 7. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurken-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testschritt</a> f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurken-</a> Framework</font></i> <br><br><h3>  Abh√§ngigkeit Nr. 3.  √úberpr√ºfen einer Pr√ºfung auf einem Badoo-Server </h3><br>  Um die dritte Abh√§ngigkeit zu entfernen, m√ºssen Sie die √úberpr√ºfungs√ºberpr√ºfung auf dem Server entfernen.  Es ist wichtig zu bedenken, dass die √úberpr√ºfung in zwei Schritten erfolgt.  In der ersten Phase wird die Pr√ºfung anhand von Signaturen und Zertifikaten authentifiziert.  Im zweiten Fall wird der Scheck an den App Store gesendet.  Im Falle einer erfolgreichen Validierung zu diesem Zeitpunkt erhalten wir einen entschl√ºsselten Scheck, der verarbeitet werden kann. <br><br><img src="https://habrastorage.org/webt/pd/9g/p_/pd9gp_uz1kjnsb9rsk9weczdngw.jpeg"><br>  <i><font color="gray">Abbildung 7. Entfernen der Server√ºberpr√ºfung</font></i> <br><br>  Zun√§chst f√ºhrt der Server die erste √úberpr√ºfung der Pr√ºfung in der verifyReceiptByCert-Methode der √ºbergeordneten Klasse durch.  Dadurch wird die Signatur mit dem App Store-Zertifikat √ºberpr√ºft.  Im Falle einer gef√§lschten Pr√ºfung schl√§gt diese √úberpr√ºfung fehl, da sie von unserem Zertifikat signiert ist, und wir rufen die Methode zur √úberpr√ºfung mit dem lokalen Zertifikat verifyReceiptByLocalCert auf.  Bei dieser Methode versuchen wir, die Pr√ºfung mit einem lokalen Zertifikat zu entschl√ºsseln. Wenn dies erfolgreich ist, platzieren wir das Entschl√ºsselungsergebnis im internen Feld local_receipt der untergeordneten Klasse (addLocallyVerifiedReceipt-Methode). <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">)  </span></span>{ $result = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceiptByCert($receipt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result === <span class="hljs-number"><span class="hljs-number">-1</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($result)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;verifyReceiptByLocalCert($receipt); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyReceiptByLocalCert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($receipt)</span></span></span><span class="hljs-function"> </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($result) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addLocallyVerifiedReceipt($receipt, base64_decode($response)); } unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceiptByCert</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt</span></span></span><span class="hljs-class">) </span></span>{ $receipt_file = tempnam(sys_get_temp_dir(), <span class="hljs-string"><span class="hljs-string">'rcp'</span></span>); file_put_contents($receipt_file, base64_decode($receipt)); $result = openssl_pkcs7_verify($receipt_file, PKCS7_BINARY, <span class="hljs-string"><span class="hljs-string">'/dev/null'</span></span>, [$DIR]); unlink($receipt_file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  <i><font color="gray">Listing 8. Erstpr√ºfung</font></i> <br><br>  W√§hrend der sekund√§ren √úberpr√ºfung (verifyReceipt) erhalten wir den Wert des Felds local_receipt der untergeordneten Klasse getLocallyVerifiedReceipt.  Wenn es nicht leer ist, verwenden wir seinen Wert als Ergebnis der √úberpr√ºfung. <br><br>  Wenn das Feld leer ist, rufen wir die sekund√§re √úberpr√ºfung von der √ºbergeordneten Klasse ( <i>parent</i> :: verifyReceipt) auf.  Dort stellen wir eine Anfrage an den App Store zur √úberpr√ºfung auf seiner Seite.  Das √úberpr√ºfungsergebnis ist in beiden F√§llen eine entschl√ºsselte Pr√ºfung. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EngineTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLocallyVerifiedReceipt($receipt_encoded); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($response)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($response, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>::verifyReceipt($receipt_encoded, $shared_secret, $env); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Engine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">verifyReceipt</span></span></span><span class="hljs-class">($</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receipt_encoded</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_secret</span></span></span><span class="hljs-class">, $</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">) </span></span>{ $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_sendRequest($receipt_encoded, $shared_secret, $env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response; }</code> </pre> <br>  <i><font color="gray">Listing 9. Sekund√§re √úberpr√ºfung</font></i> <br><br><h3>  5. Videotestlauf: Kredite und Abonnements kaufen </h3><br><h4>  Test Nummer 1.  Abonnementkauf </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Wann <br></td><td>  Ich melde mich als neuer Benutzer mit einem Foto bei der Anwendung an <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle einen neuen Abrechnungsscheck f√ºr ein Monat <br></td></tr><tr><td>  Und <br></td><td>  Ich gehe zu meinem Profil <br></td></tr><tr><td>  Dann <br></td><td>  Ich stelle sicher, dass das Abonnement deaktiviert ist <br></td></tr><tr><td>  Wann <br></td><td>  Ich √∂ffne die Produktliste <br></td></tr><tr><td>  Und <br></td><td>  Ich kaufe ein einmonatiges Abonnementpaket <br></td></tr><tr><td>  Dann <br></td><td>  Ich √ºberpr√ºfe die Benachrichtigung √ºber den erfolgreichen Kauf <br></td></tr><tr><td>  Und <br></td><td>  Ich stelle sicher, dass das Abonnement aktiviert ist <br></td></tr></tbody></table></div><br>  Testlauf Video: <br><br><img src="https://habrastorage.org/webt/xc/ut/ag/xcutagbl8qmu9wzgva0zop2xqg0.gif"><br><h4>  Test Nummer 2.  Kredite kaufen und ein Geschenk schicken </h4><br><div class="scrollable-table"><table><tbody><tr><td>  Wann <br></td><td>  Ich melde mich als neuer Benutzer mit einem Foto bei der Anwendung an <br></td></tr><tr><td>  Und <br></td><td>  Ich f√ºge meinem Profil zehn Credits hinzu <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle eine neue Bonit√§tspr√ºfung f√ºr 550 Credits <br></td></tr><tr><td>  Und <br></td><td>  Ich erstelle einen neuen Benutzer Leela <br></td></tr><tr><td>  Und <br></td><td>  Leela hat f√ºr mich mit Ja gestimmt <br></td></tr><tr><td>  Und <br></td><td>  Ich gehe zu People Nearby und √∂ffne ein Leela-Profil <br></td></tr><tr><td>  Und <br></td><td>  Ich stimme "Ja" f√ºr Leela <br></td></tr><tr><td>  Dann <br></td><td>  Ich √ºberpr√ºfe die √úbereinstimmungsseite <br></td></tr><tr><td>  Wann <br></td><td>  Ich beschlie√üe, ein normales Geschenk zu senden <br></td></tr><tr><td>  Dann <br></td><td>  Ich √ºberpr√ºfe den Zahlungsbildschirm mit einer Liste von Paketen <br></td></tr><tr><td>  Wann <br></td><td>  Ich kaufe 550 Credits <br></td></tr><tr><td>  Dann <br></td><td>  Ich √ºberpr√ºfe die Benachrichtigung √ºber den erfolgreichen Kauf <br></td></tr><tr><td>  Und <br></td><td>  Ich stelle sicher, dass Leela ein Chat-Geschenk erhalten hat <br></td></tr></tbody></table></div><br><br>  Testlauf Video: <br><br><img src="https://habrastorage.org/webt/jb/dl/oj/jbdlojncgj656usnr5bsylaese4.gif"><br><br><h2>  Bewertung der Entscheidung: Hauptrisiken </h2><br>  Das Entfernen externer Abh√§ngigkeiten birgt bestimmte Risiken. <br><br>  1. Falsche Konfiguration. <br><br>  Da die √úberpr√ºfung nicht auf unserer Seite ist, k√∂nnen wir unsere Produkte auf der Apple-Seite falsch konfigurieren.  Zum Schutz vor Fehlern haben wir einen separaten serverseitigen Komponententest geschrieben, der √ºberpr√ºft, ob alle Produkte, die wir auf der Apple-Seite starten, mit den Produkten in unserer Konfiguration √ºbereinstimmen. <br><br>  2. Grenzf√§lle. <br><br>  Wenn die Zahlung beispielsweise vollst√§ndig abgeschlossen ist, erh√§lt der Benutzer eine Benachrichtigung, dass er die Zahlung abgeschlossen hat. Unsere Anwendung kann jedoch den Scheck nicht finden, der aufgrund dieser Zahlung gef√§lscht werden soll.  Das Risiko liegt in der Tatsache, dass wir den Scheck selbst mit Hilfe einer Hintert√ºr anbringen und einen solchen Fall nat√ºrlich nicht nachverfolgen k√∂nnen.  Um dieses Risiko irgendwie auszugleichen, f√ºhren wir nach der Freigabe End-to-End-√úberpr√ºfungen √ºber die Sandbox oder eine echte Zahlung durch. <br><br>  3. Unfaire F√§lschung oder Betrug. <br><br>  Nachdem Sie diesen Artikel gelesen haben, k√∂nnten Sie denken, dass Sie, da Badoo gef√§lschte Schecks verwendet, etwas Falsches an uns anh√§ngen und den Service kostenlos nutzen k√∂nnen.  Damit dieses Risiko nicht eintritt, unterschreiben wir alles mit unserem eigenen Zertifikat und beschr√§nken die Verwendung von Moks und Fake Checks auf Funktionstests, die nur in unserer Entwicklungsumgebung ausgef√ºhrt werden. <br><br>  4. √Ñndern Sie das Format des Schecks. <br><br>  Dies ist das schwerwiegendste Risiko.  Das Format eines Schecks kann ge√§ndert werden, wenn Apple etwas √§ndert, ohne uns zu warnen.  Wir hatten einen solchen Fall: Beim Wechsel zu iOS 11 √§nderte sich das Format der Pr√ºfung vollst√§ndig.  Wir haben einen gef√§lschten Check auf unserem Server generiert und im Test verwendet.  Bei uns war alles perfekt: Alle Felder sind vorhanden, alles ist wunderbar, alles wird verarbeitet.  Aber als wir zum realen System wechselten, funktionierte nichts.  Felder, die f√ºr die Pr√ºfung von Bedeutung waren, existierten einfach nicht mehr. <br><br>  Wie kann dieses Risiko kompensiert werden?  Erstens schlie√üen wir die M√∂glichkeit eines End-to-End-Tests der Sandbox vor der Ver√∂ffentlichung und einer tats√§chlichen Zahlung nach der Ver√∂ffentlichung nicht aus.  Jetzt befinden wir uns in der aktiven Phase eines Projekts zur √úberpr√ºfung von Benachrichtigungen, wenn wir versuchen, alle √úberpr√ºfungen, die wir von der Produktion erhalten, danach zu klassifizieren, ob wir verstehen, was es ist oder nicht.  Wenn die Antwort Nein lautet, beginnen wir, alles manuell zu verarbeiten, um zu sehen, was sich ge√§ndert hat, was falsch ist und was in unserem System ge√§ndert werden muss. <br><div class="scrollable-table"><table><tbody><tr><td>  Risiko <br></td><td>  Grund <br></td><td>  Wie zu kompensieren <br></td></tr><tr><td>  falsche Konfiguration <br></td><td>  Scheck l√∂schen <br></td><td>  Unit-Test auf dem Server <br></td></tr><tr><td>  Randf√§lle <br>  (Scheck nicht geliefert) <br></td><td>  Hintert√ºr benutzen <br></td><td>  E2E-Schecks (Sandbox und echte Zahlung) <br></td></tr><tr><td>  betr√ºgerischer Betrug, Betrug <br></td><td>  Benachrichtigung und Scheckgenerierung auf dem Server <br></td><td>  eigenes Zertifikat <br></td></tr><tr><td>  Pr√ºfformat √§ndern <br></td><td>  Benachrichtigung und Scheckgenerierung auf dem Server <br></td><td>  √úberpr√ºfung der tats√§chlichen Benachrichtigungen und √úberpr√ºfung des Produkts (neues Projekt), <br>  E2E-Schecks (Sandbox und echte Zahlung) <br></td></tr></tbody></table></div><br><h2>  Ergebnis </h2><br><br>  Betrachten Sie die Hauptvorteile, die wir durch die Anwendung der Moki-Methode und des gef√§lschten Objekts erzielen konnten. <br><br><h4>  Preiswerte, schnelle und stabile Automatisierung kostenpflichtiger Dienste unter iOS </h4><br>  Zusammen mit dem manuellen Testteam von iOS (besonderer Dank an Colin Chan) konnten wir mehr als 150 automatische Tests f√ºr Zahlungen schreiben.  Dies ist eine ziemlich gro√üe Abdeckung f√ºr einen Bereich der Anwendung. <br><br>  Dank der Parallelisierung k√∂nnen wir das Ergebnis in nur 15 bis 20 Minuten in jedem Zweig des iOS-Client-Entwicklers oder Abrechnungsserver-Entwicklers erhalten.  Vor der Automatisierung dauerte das manuelle Testen dieses Bereichs durch eine Person acht Stunden. <br><br>  Wir k√∂nnen auch die √ºberwiegende Mehrheit der Testf√§lle testen, indem wir den Mock Payment Provider √ºber das Moki so einrichten, wie wir es ben√∂tigen.  Mithilfe von Mooks haben wir gelernt, wie Sie die Produktpr√ºfung deaktivieren und F√§lle simulieren, in denen die Pr√ºfung teilweise durchgef√ºhrt wird.  So haben wir F√§lle er√∂ffnet, die wir vorher prinzipiell nicht testen konnten. <br><br><h4>  Funktionale Regression bei der Entwicklung neuer Funktionen </h4><br>  Die Automatisierung funktionierte sehr gut in den F√§llen, in denen der Entwickler bei der Arbeit an einer neuen Funktion die alte Funktionalit√§t beeintr√§chtigte.  Wir hatten ein Beispiel, als ein Entwickler eine komplexe Funktion mit Caching ausf√ºhrte und unsere automatischen Tests durchf√ºhrte.  Einige von ihnen sind irrt√ºmlich gefallen.  Er sah es und reparierte es.  Dann startete er die Autotests erneut - und wieder fiel etwas.  Infolgedessen f√ºhrte er eine Reihe von Iterationen durch, bis auf der Anwendungsseite alles normal zu funktionieren begann. <br><br><h4>  Funktionale Regression beim Zahlungs-Refactoring </h4><br>  Die vielleicht erfolgreichste und effizienteste Automatisierung, die m√∂glich ist, findet im Bereich des Code-Refactorings statt.  In diesem Fall √§ndert sich nur die interne Implementierung - der Autotest-Code muss nicht ge√§ndert werden.  Die Benutzeroberfl√§che √§ndert sich in keiner Weise und Autotests k√∂nnen effizient gesteuert werden. <br><br><h4>  Testen experimenteller Funktionen von Apple: Kulanzfrist </h4><br>  Ein √§hnliches System ist vollst√§ndig austauschbar, wenn Sie neue Integrationen testen, die noch nicht in der Sandbox implementiert sind.  So war es auch mit der Gnadenfrist.  Diese Funktionalit√§t befindet sich nicht in der Sandbox.  Die Nachfrist f√ºr Apple steht noch nicht allen zur Verf√ºgung.  Dies ist ein Pilotprojekt, das Badoo mit Apple umsetzt.  Um dies mit einer Nachfrist zu √ºberpr√ºfen, mussten wir hier einen solchen JSON-Code hinzuf√ºgen: <br><br><pre> <code class="json hljs">pending_renewal_info:[ { expiration_intent: <span class="hljs-number"><span class="hljs-number">2</span></span> grace_period_expires_date: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> Etc/GMT auto_renew_product_id: badoo.productId original_transaction_id: <span class="hljs-number"><span class="hljs-number">560000361869085</span></span> is_in_billing_retry_period: <span class="hljs-number"><span class="hljs-number">1</span></span> grace_period_expires_date_pst: <span class="hljs-number"><span class="hljs-number">2019</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span> America/Los_Angeles product_id: badoo.productId grace_period_expires_date_ms: <span class="hljs-number"><span class="hljs-number">1556207457000</span></span> auto_renew_status: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  <i><font color="gray">Listing 10. Nachfrist f√ºr ein Abonnement</font></i> <br><br>  Wir haben das sehr einfach in wenigen Sekunden gemacht.  In unserem System konnten wir unsere Reaktion auf eine neue Funktion testen.  Jetzt f√ºhren wir diese Funktionalit√§t auf dem Produkt aus. <br><br><h4>  Produktqualit√§tspr√ºfung in Zusammensetzungsmethoden </h4><br>  Als Ergebnis unserer Forschung konnten wir eine Methode beschreiben, die Rauschen durch externe Abh√§ngigkeiten eliminiert.  Dies half Client-Entwicklern bei der Entwicklung von Funktionen, Fehler in einem fr√ºhen Stadium zu finden. <br><br>  Aber denken Sie nicht, dass wir mit dieser Methode alles testen konnten.  Um alles zu testen, ist es besser, eine Zusammensetzung von Methoden zu verwenden: Testen mit einer echten Karte auf dem Produkt, Testen in der Sandbox, Testen von Mokes und gef√§lschten Objekten, Testen von Einheiten und Integration.  Bitte denken Sie an das Gleichgewicht der Testpyramide und versuchen Sie nicht, alle Probleme mit einer Methode zu l√∂sen.  Dies kann zu einer traurigen Automatisierung in der Sandbox, zu traurigen manuellen Tests mit einer echten Karte aller F√§lle und zu vielen anderen schwerwiegenden Fehlern genau dort f√ºhren, wo ihr Erscheinungsbild am schmerzhaftesten ist. <br><br><h2>  Fazit </h2><br>  Als Ergebnis unserer Forschung haben wir eine kosteng√ºnstige, schnelle und stabile Methode erhalten, um nicht nur kostenpflichtige Dienste unter iOS zu testen, sondern auch alle Komponenten, die als ‚ÄûBlack Box‚Äú in die Anwendung eingebettet sind.  Jetzt implementieren wir bei Badoo diese Methode zum Testen auf kostenpflichtigen Android-Anbietern (Global Charge, Boku, Centili), die instabile Sandboxen oder andere Einschr√§nkungen aufweisen.  Wir verwenden die Moki-Methode auch zum Testen von Werbung, Streaming und Geolocation. <br><br>  Es ist erw√§hnenswert, dass der Prozess der Einf√ºhrung einer neuen Methode nicht schnell war.  Ich musste mit vier Teams verhandeln: iOS QA, iOS Dev, Billing QA, Billing Dev.  Nicht jeder wollte aus Angst vor Risiken auf eine neue Methode umsteigen.  Manchmal war es eine dogmatische Folge: Viele Jahre lang haben wir im Sandkasten getestet, und die Hauptkraft, die das Dogma zerst√∂ren konnte, war der Wunsch der Abrechnungstester und der iOS-Plattform, die Situation zu √§ndern und Qualen loszuwerden.  Sp√§ter erkannten die Entwickler solche Vorteile dieser Methode wie eine genaue Diagnose (wir konnten keine Fehler in der Sandbox finden, aber Fehler unseres Clients oder Servers), Flexibilit√§t beim Einrichten der Komponente (wir konnten negative F√§lle auf Integrationsebene leicht testen) und nat√ºrlich die Antwort 30 Minuten auf einem Zweig mit entwickeltem Code. <br><br>  Vielen Dank an alle, die bis zum Ende gelesen haben.  Vielen Dank an alle, die an diesem Projekt mitgewirkt haben.  Besonderer Dank geht an diese Leute: <br><br><ul><li>  Peter Kolpashchikov ist ein iOS-Entwickler, der Moki auf der Client-Seite entwickelt und ein PPP-Konzept entwickelt hat. <br></li><li>  Vladimir Solodov - Billing QA, der mit der QA-API beim Generieren von gef√§lschten Schecks und Checkout vom Abrechnungsserver geholfen hat; <br></li><li>  Maxim Filatov und Vasily Stepanov - Billing Dev Team, die beim Abrechnungsservercode geholfen haben; <br></li><li>  iOS Dev Team - Entwickler, die unsere Zahlungen in einem neuen Konzept umgestalten konnten, um die Verwendung von Mokas zu erm√∂glichen; <br></li><li>  Das iOS QA Team ist ein gro√üartiges Testteam, das eine Reihe von Autotests geschrieben hat. <br></li><li>  Billing QA Team - Tester, die bei der Erforschung von Problemen geholfen haben. <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460667/">https://habr.com/ru/post/de460667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460651/index.html">Treffen der Society of Anonymous Testers: TMS, √úberwachung, √úberwachung der Bewertung der Suchqualit√§t und native iOS-Tests</a></li>
<li><a href="../de460655/index.html">Wie ich Telegramm gebrochen habe</a></li>
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie √ºber Node.js wissen m√ºssen</a></li>
<li><a href="../de460665/index.html">Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards?</a></li>
<li><a href="../de460669/index.html">So gew√§hrleisten Sie die Sicherheit der Entwicklung, sparen Zeit und Nerven</a></li>
<li><a href="../de460671/index.html">Eigentum und Ausleihe in D.</a></li>
<li><a href="../de460673/index.html">Enth√ºlle die Magie von DiffUtil</a></li>
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
<li><a href="../de460683/index.html">Laravel Event Projector und Event Generation Concept</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>