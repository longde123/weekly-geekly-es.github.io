<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùÔ∏è ü§û üëÉüèΩ Escribir un traductor simple en Lisp - I üí™üèª üí© üë©üèæ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intentemos escribir en Lisp ... un traductor de un lenguaje imperativo simple. No, no, no me equivoqu√©: es el traductor. Se transmitir√° en el c√≥digo L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir un traductor simple en Lisp - I</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419103/"><p>  Intentemos escribir en Lisp ... un traductor de un lenguaje imperativo simple.  No, no, no me equivoqu√©: es el traductor.  Se transmitir√° en el c√≥digo Lisp.  Y luego este c√≥digo puede ser ejecutado por el sistema Lisp. </p><br><p>  Aqu√≠, el servicio inestimable ser√° proporcionado por el hecho de que en Lisp no existe una barrera entre el c√≥digo y los datos (esta es una propiedad rara de algunos lenguajes de programaci√≥n llamados "homo-identidad").  Pero las capacidades visuales de Lisp tambi√©n jugar√°n un papel importante. </p><br><p>  Como implementaci√≥n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar√© HomeLisp</a> .  Los interesados ‚Äã‚Äãpueden adaptar este proyecto a Common Lisp.  Dir√© de inmediato: en relaci√≥n con el problema en consideraci√≥n, la diferencia significativa entre Common Lisp y HomeLisp es solo en el procesamiento de l√≠neas y archivos. </p><br><p>  Descargue una versi√≥n port√°til de HomeLisp <a href="">aqu√≠</a> .  La documentaci√≥n tambi√©n se encuentra en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el mismo</a> sitio.  Aquellos que lo deseen pueden copiar el c√≥digo del art√≠culo y verificar de inmediato el rendimiento. </p><br><p> El tema que llam√≥ su atenci√≥n sirvi√≥ de base para mi taller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el famoso Novosibirsk LSHUP-2018</a> .  Los resultados del taller se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Y luego establec√≠ mi enfoque.  Supongo que el lector est√° familiarizado con el lenguaje Lisp. </p><br><h4 id="pristupaem">  Bajando </h4><br><p>  Comencemos con el "lenguaje imperativo simple" que transmitiremos en Lisp. <br>  El idioma solo procesar√° datos num√©ricos.  El c√≥digo en este lenguaje consta de funciones (procedimientos que devuelven valores).  Entre estas funciones, una deber√≠a llamarse main.  Es con esta funci√≥n que comienza la ejecuci√≥n del c√≥digo.  Aunque ¬øpor qu√© atarte as√≠?  Escribimos funciones en un lenguaje imperativo, se transmiten en Lisp y se pueden usar junto con las funciones de Lisp.  Pero no nos adelantemos ... </p><a name="habracut"></a><br><p>  El conjunto de operadores de lenguaje es habitual: asignaci√≥n, ramificaci√≥n, ciclo aritm√©tico, salida anticipada del ciclo, entrada, salida y llamada a funciones.  Sin embargo, sint√°cticamente, una llamada de funci√≥n se ejecuta como una asignaci√≥n (resultado de una llamada).  Deje que los comentarios contengan un asterisco en la primera posici√≥n de la l√≠nea.  El lenguaje, por supuesto, deber√≠a proporcionar la capacidad de crear funciones recursivas.  Para hacerlo m√°s claro, dar√© ejemplos de c√≥digo: imprimir n√∫meros impares sucesivos y calcular su suma: </p><br><pre><code class="hljs lua">proc main() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> s,n,k <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span> to n k=<span class="hljs-number"><span class="hljs-number">2</span></span>*i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> k s=s+k end_for <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> s end_proc</code> </pre> <br><p>  En su esp√≠ritu, es un lenguaje b√°sico.  Lo llamar√© "mini-b√°sico".  Nuestro traductor debe convertir el c√≥digo dado a la siguiente funci√≥n Lisp: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> main <span class="hljs-literal"><span class="hljs-literal">nil</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">n</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">k</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> n (<span class="hljs-name"><span class="hljs-name">read</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> i from <span class="hljs-number"><span class="hljs-number">1</span></span> to n) (<span class="hljs-name"><span class="hljs-name">setq</span></span> k (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">*</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> i) <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">printline</span></span> k) (<span class="hljs-name"><span class="hljs-name">setq</span></span> s (<span class="hljs-name"><span class="hljs-name">+</span></span> sk))) (<span class="hljs-name"><span class="hljs-name">printline</span></span> s)))</code> </pre> <br><p>  Realmente me gusta el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">iterate</a> , que se implementa como una macro en los paquetes profesionales Common Lisp.  En HomeLisp, la funci√≥n iter (que implementa una gran parte de las capacidades de iteraci√≥n macro) se incluye en el lenguaje principal.  Fue mi adicci√≥n a iter lo que hizo que los ciclos de nuestro "mini-b√°sico" se tradujeran en llamadas de iter. </p><br><p>  ¬øD√≥nde comenzar la implementaci√≥n?  Comencemos seleccionando el archivo a transmitir y leyendo e imprimiendo ese archivo l√≠nea por l√≠nea.  Tendremos que iniciar el traductor muchas veces, por lo que es conveniente que comience desde el principio.  As√≠ es como podr√≠a verse esta funci√≥n: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>)))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  La funci√≥n tiene un par√°metro opcional <strong>fname</strong> : el nombre del archivo cuyos contenidos se transmitir√°n.  Al ingresar a la funci√≥n, se crean dos variables globales: <strong><em>numLine,</em></strong> n√∫mero de l√≠nea del archivo fuente y <strong><em>flagerr</em></strong> , el indicador de estado de error.  Antes de que la funci√≥n finalice, estas variables se destruyen (la funci√≥n HomeLisp no establecida destruye las variables globales). </p><br><p>  Si se omite el nombre del archivo de entrada, se llama al cuadro de di√°logo est√°ndar de Windows para seleccionar el archivo <strong>(sysGetOpenName)</strong> .  El directorio actual <strong>(sysHome) se</strong> utiliza como directorio de inicio.  A continuaci√≥n, se crea un car√°cter √∫nico para el manipulador de archivos y el archivo se abre para la lectura de texto.  Luego, en un bucle sin fin, el archivo se lee l√≠nea por l√≠nea (funci√≥n <strong>getLine</strong> ).  Despu√©s de cada operaci√≥n, se verifica si se ha producido un error y si se alcanza el final del archivo.  Si se produce un error o se corrige el final del archivo, el ciclo se rompe, el archivo se cierra y, si hubo errores, se muestra un mensaje final. <br>  En realidad, la funci√≥n <strong>getLine</strong> realiza la lectura del archivo: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">return</span></span> stri)))))</code> </pre> <br><p>  Esta funci√≥n acepta el identificador de un archivo abierto y, en un bucle infinito, realiza las siguientes acciones: </p><br><ul><li>  comprueba el final del estado del archivo.  En este caso, el bucle se rompe y la funci√≥n devuelve una cadena vac√≠a; </li><li>  el contador de l√≠neas le√≠das aumenta en uno; </li><li>  se lee la siguiente l√≠nea del archivo; </li><li>  la l√≠nea de lectura se imprime con la eliminaci√≥n de posibles espacios a la derecha; </li><li>  si la l√≠nea de lectura no est√° vac√≠a y no contiene un asterisco en la primera posici√≥n, entonces <br>  vuelve de la funci√≥n; </li></ul><br><p>  Por lo tanto, todas las l√≠neas del archivo en su forma original caen en la lista de salida. </p><br><h4 id="razbivaem-na-procedury">  Entramos en procedimientos </h4><br><p>  Ahora ense√±emos nuestro c√≥digo para dividir la secuencia de entrada en procedimientos separados.  Primero, la cadena ingresada deber√° dividirse en tokens (unidades l√©xicas de entrada indivisibles).  Este proceso se llama an√°lisis;  Tenemos que crear un analizador.  Escribir analizadores es un tema cl√°sico, hay bibliotecas de analizadores listos para usar y herramientas especiales que le permiten generar el analizador necesario ... Seguiremos nuestro propio camino. </p><br><p>  Antes de describir el algoritmo analizador, prestamos atenci√≥n al hecho de que todos los caracteres de la cadena de entrada se pueden dividir en dos clases: </p><br><ul><li>  Caracteres ordinarios; </li><li>  Separador de caracteres. </li></ul><br><p>  Entonces, en el operador de asignaci√≥n <strong>"x = 15 + y ^ 2", los</strong> caracteres <strong>x, 1,5, y</strong> y <strong>2</strong> son caracteres ordinarios, y los caracteres <strong>"espacio"</strong> , <strong>+</strong> , <strong>^</strong> son delimitadores.  ¬øC√≥mo es un personaje normal diferente de un separador?  Separador: siempre separa un token de otro.  Nuestro operador de asignaci√≥n, dividido en tokens, se ve as√≠: <strong>‚Äúx‚Äù, ‚Äú=‚Äù, ‚Äù15‚Äù, ‚Äúy‚Äù, ‚Äú^‚Äù, ‚Äú2‚Äù</strong> . </p><br><p>  Como puede ver, no todos los delimitadores caen en el resultado del an√°lisis (los espacios, en particular, no caen).  Llamaremos a los separadores que no entran en el resultado como separadores del primer tipo.  Otros separadores se llamar√°n separadores del segundo tipo. </p><br><p>  La entrada del analizador ser√° una cadena, la salida es una lista de tokens de cadena.  Como unidad, se utilizar√° una variable local: la bater√≠a.  La bater√≠a inicialmente contiene una cadena vac√≠a. </p><br><p>  El algoritmo de an√°lisis puede ser el siguiente: leemos la l√≠nea de entrada car√°cter por car√°cter.  Si conoces un personaje normal, concatena con la bater√≠a.  Si se encuentra un delimitador, entonces: </p><br><ul><li>  Para el separador del primer tipo, restablecemos el valor de la bater√≠a (si no est√° vac√≠o) a la lista de salida, borramos la bater√≠a y procedemos a leer el siguiente car√°cter; </li><li>  Para el separador del segundo tipo, tambi√©n volcamos el valor de una bater√≠a no vac√≠a en la lista de salida, y luego ingresamos el separador aceptado del segundo tipo (como un token independiente) en la lista de salida, borramos la bater√≠a y procedemos a leer el siguiente car√°cter. </li></ul><br><p>  Aqu√≠ est√° el c√≥digo del analizador: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> parser (<span class="hljs-name"><span class="hljs-name">txt</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">d1</span></span> <span class="hljs-string"><span class="hljs-string">" ,"</span></span>) (<span class="hljs-name"><span class="hljs-name">d2</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lex</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) ) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> s in-string (<span class="hljs-name"><span class="hljs-name">strCat</span></span> txt (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> d1 <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d1 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) ((<span class="hljs-name"><span class="hljs-name">plusp</span></span> (<span class="hljs-name"><span class="hljs-name">strInd</span></span> d2 s)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> lex) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> lex into res)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> s into res) (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> lex (<span class="hljs-name"><span class="hljs-name">strCat</span></span> lex s))))) res))</code> </pre> <br><p>  Adem√°s del par√°metro requerido, la funci√≥n tiene dos par√°metros opcionales: <strong>d1</strong> contiene una cadena, cada uno de los cuales tiene un separador del primer tipo, y la l√≠nea <strong>d2</strong> contiene separadores del segundo tipo. </p><br><p>  La l√≥gica del programa de la funci√≥n del <strong>analizador</strong> se describi√≥ anteriormente.  Solo debe tenerse en cuenta que antes de comenzar a trabajar, se agrega un separador al final de la l√≠nea de entrada.  Esto se hace para que el √∫ltimo token procesado "cuelgue" en la bater√≠a (la variable local <strong>lex</strong> juega el papel de la bater√≠a). </p><br><p>  Vamos a ver nuestro analizador "en acci√≥n": </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">parser</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-string"><span class="hljs-string">"x"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"15"</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-string"><span class="hljs-string">"y"</span></span> <span class="hljs-string"><span class="hljs-string">"^"</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span>)</code> </pre> <br><p>  As√≠ es, ¬øno es as√≠?  Pero trabajar con listas de cadenas no es del todo Lisp.  Pasemos de la lista de cadenas a la lista de √°tomos.  Para hacer esto, necesitamos una funci√≥n que ... pegue todos los tokens nuevamente en una l√≠nea larga (pero inserte un espacio entre los tokens), luego pegue el corchete de apertura al comienzo de esta l√≠nea, cierre el corchete de cierre hasta el final ... y luego fuerce a Lisp a leer la lista: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>))))</code> </pre> <br><p>  Ahora, si enviamos el operador de asignaci√≥n a la entrada de la funci√≥n mk-intf, obtenemos: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"x = 15 + y^2"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">X</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span> + Y ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  Lo cual, ves, es mucho mejor. </p><br><p>  Ahora cambiemos un poco la funci√≥n de inicio: esta funci√≥n tendr√° que leer y procesar procedimientos completos: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> fname) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">when</span></span> fname (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi)) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*))</code> </pre> <br><p>  En el cuerpo del bucle, se llama a la funci√≥n <strong>action-proc</strong> (para procesar el procedimiento), que formar√° el cuerpo del procedimiento aceptado ya en Lisp.  El cuerpo del procedimiento, almacenado como una expresi√≥n S en la variable <strong>curr-proc</strong> , se pasa a la entrada de <strong>eval</strong> .  ¬°Y la funci√≥n aceptada se "reencarna" en el entorno Lisp! </p><br><p>  ¬øQu√© debe hacer <strong>action-proc</strong> ?  Esta funci√≥n recibe el identificador del archivo abierto como par√°metro.  La funci√≥n lee el archivo l√≠nea por l√≠nea del archivo, omite l√≠neas vac√≠as y comentarios, analiza el resto de las l√≠neas, lo traduce a un formulario de lista y genera el cuerpo del procedimiento. </p><br><p>  Gradualmente "aprenderemos" la generaci√≥n de <strong>acci√≥n-proc</strong> .  Y comencemos ense√±ando nuestra funci√≥n para reconocer el principio y el final de un procedimiento.  En un mini-b√°sico, el comienzo del procedimiento es: </p><br><pre> <code class="hljs lisp">proc name(<span class="hljs-name"><span class="hljs-name">p1</span></span>,p2,p3)</code> </pre> <br><p>  intenta analizar una l√≠nea como esta: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> <span class="hljs-string"><span class="hljs-string">"proc name(p1,p2,p3)"</span></span>) ==&gt; (<span class="hljs-name"><span class="hljs-name">PROC</span></span> NAME (<span class="hljs-name"><span class="hljs-name">P1</span></span> P2 P3))</code> </pre> <br><p>  ¬øC√≥mo deber√≠a responder la funci√≥n <strong>action-proc</strong> a esta entrada?  Naturalmente, asegur√°ndose de que el encabezado de la lista sea un √°tomo <strong>PROC</strong> , debe tomar el segundo elemento de la lista como el nombre de la funci√≥n y el tercer elemento como la lista de par√°metros.  El nombre y la lista de par√°metros deben almacenarse en variables locales.  Cuando se <strong>lee el</strong> operador <strong>end_proc</strong> , debe formar un formulario <strong>defun</strong> con un cuerpo vac√≠o (hasta ahora) del nombre de la funci√≥n y la lista de par√°metros, y devolver este formulario como resultado.  As√≠ es como se ve: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm (quote OK))))</code> </pre> <br><p>  Para la formaci√≥n final de la cl√°usula <strong>defun</strong> , se utiliza un bloqueo inverso.  Tenga en cuenta que el procedimiento generado devolver√° un √°tomo <strong>OK</strong> como resultado. </p><br><p>  Ahora podemos verificar nuestro c√≥digo en acci√≥n.  Ponga el siguiente c√≥digo en el archivo 0000.mbs: </p><br><pre> <code class="hljs lisp">proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) end_proc proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) end_proc</code> </pre> <br><p>  Ejecute el procedimiento de <strong>inicio</strong> , seleccione 0000.mbs y vea en la consola: </p><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">0001</span></span> proc f1(<span class="hljs-name"><span class="hljs-name">x</span></span>,y) <span class="hljs-number"><span class="hljs-number">0002</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0003</span></span> proc f2(<span class="hljs-name"><span class="hljs-name">x</span></span>) <span class="hljs-number"><span class="hljs-number">0004</span></span> end_proc</code> </pre> <br><p>  Si lo desea, puede asegurarse de que la m√°quina Lisp ahora tenga dos funciones (hasta ahora in√∫tiles) <strong>f1</strong> y <strong>f2</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">QUOTE</span></span> OK))</code> </pre> <br><p>  Por otra parte!  Ya se pueden iniciar: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">f1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK (<span class="hljs-name"><span class="hljs-name">f2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) ==&gt; OK</code> </pre> <br><p>  Nuestro traductor respir√≥ por primera vez ... </p><br><h4 id="vvod-vyvod-i-lokalnye-peremennye">  Entrada, salida y variables locales. </h4><br><p>  Ahora es el momento de ense√±arle a nuestro traductor reci√©n nacido c√≥mo manejar la <strong>entrada</strong> , la <strong>impresi√≥n</strong> y <strong>los</strong> operadores <strong>locales</strong> . </p><br><p>  La forma m√°s f√°cil de manejar la entrada y la impresi√≥n.  Ambos operadores tienen la misma estructura de sintaxis: palabra clave y variable.  La <strong>entrada del</strong> operador <strong>x</strong> debe convertirse en una forma de Lisp <strong>(setq x (lectura))</strong> .  En consecuencia, el operador de <strong>impresi√≥n x se</strong> convierte en un formulario <strong>(l√≠nea de impresi√≥n x)</strong> .  Para almacenar estos formularios, debe proporcionar el <strong>cuerpo</strong> de la variable local en la funci√≥n <strong>action-proc</strong> .  Esta variable acumular√° formas que realizan c√°lculos de la funci√≥n futura.  Entonces todo es bastante simple: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) `(defun ,proc-name ,proc-parm ,@body)))</code> </pre> <br><p>  Ahora preparemos este c√≥digo fuente en un mini-b√°sico: </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> y end_proc <span class="hljs-keyword"><span class="hljs-keyword">proc</span></span> f2(x) input x <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x end_proc</code> </pre> <br><p>  e intente traducirlo ... Tendremos dos funciones Lisp <strong>f1</strong> y <strong>f2</strong> .  Veamos sus expresiones definitorias y asegur√©monos de que se generen correctamente: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f1) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">XY</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> Y)) (<span class="hljs-name"><span class="hljs-name">getd</span></span> 'f2) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> (<span class="hljs-name"><span class="hljs-name">X</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> X (<span class="hljs-name"><span class="hljs-name">READ</span></span>)) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> X))</code> </pre> <br><p>  Puede llamar a estas funciones y asegurarse de que funcionan exactamente como se esperaba.  No deje que le moleste que ingresemos el valor en la variable del par√°metro, simplemente todav√≠a no tenemos variables locales ... Vamos a agregarlas. </p><br><p>  El operador <strong>local</strong> puede estar en cualquier parte del procedimiento y ocurrir m√°s de una vez.  Si se encuentra el operador <strong>local</strong> durante el procesamiento de un procedimiento, debe tomar una lista de variables y guardarla en una variable local.  Una <strong>vez</strong> que se <strong>cumple la</strong> instrucci√≥n <strong>end_proc,</strong> debe generar el formulario <strong>let</strong> y "encerrar" todas las instrucciones ejecutables (por ahora, solo <strong>ingresar</strong> e <strong>imprimir</strong> ).  As√≠ es como se ver√° <strong>action-proc</strong> : </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) `(defun ,proc-name ,proc-parm (let ,lv ,@body))))</code> </pre> <br><p>  La lista de variables locales se acumula en la variable <strong>loc-var</strong> .  Una vez que se completa el procesamiento del procedimiento, se crea una lista de pares del formulario <strong>(nombre 0) a</strong> partir de esta lista.  Al mismo tiempo, la duplicaci√≥n de nombres id√©nticos no es deseable ... ¬øC√≥mo prevenirlo?  Por supuesto, es posible verificar en cada procesamiento del operador <strong>local</strong> si hay nombres duplicados (si los hay, dar un mensaje de error).  Pero, me parece, es mejor eliminar las repeticiones, que es lo que hace la llamada <strong>setof</strong> .  Ahora traduzcamos y ejecutemos este programa: </p><br><pre> <code class="hljs lua">proc f1(x,y) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> a,b,c <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> a end_proc</code> </pre> <br><p>  Nos aseguramos de que funcione exactamente como sugiere el algoritmo.  ¬°Pero lo m√°s interesante est√° por delante! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desde aqu√≠</a> puedes descargar la versi√≥n final de lo que estamos haciendo <del>  w </del>  codificado ... </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬°Continuar√°!</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419103/">https://habr.com/ru/post/es419103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419091/index.html">Objetos radiactivos entre nosotros</a></li>
<li><a href="../es419095/index.html">Escribimos CSS mejor y m√°s hermoso</a></li>
<li><a href="../es419097/index.html">Mambot: un bot en Telegram para mujeres embarazadas</a></li>
<li><a href="../es419099/index.html">WebSockets en Angular. Parte 2. Soluciones de productos</a></li>
<li><a href="../es419101/index.html">Crea un juego en el hackathon nocturno</a></li>
<li><a href="../es419105/index.html">Enlace a la transmisi√≥n de Slurm (Intensivo de Kubernetes)</a></li>
<li><a href="../es419107/index.html">Descripci√≥n general de la parte del archivo de Dell EMC Unity y ejemplos de configuraci√≥n</a></li>
<li><a href="../es419109/index.html">Explica las explosiones en Android P. ¬øQu√© hacer con Android Cutout?</a></li>
<li><a href="../es419111/index.html">Food Design Digest Julio 2018</a></li>
<li><a href="../es419115/index.html">CD de arranque y juego retro en un solo tweet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>