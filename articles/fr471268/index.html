<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçã üë¥üèø ‚ôåÔ∏è Comprendre les courtiers de messages. Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka. Chapitre 2. ActiveMQ üå¥ ü§±üèø üß¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Poursuite de la traduction d'un petit livre: 
 "Comprendre les courtiers de messages", 
 auteur: Jakub Korab, √©diteur: O'Reilly Media, Inc., date de p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre les courtiers de messages. Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka. Chapitre 2. ActiveMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/">  Poursuite de la traduction d'un petit livre: <br>  "Comprendre les courtiers de messages", <br>  auteur: Jakub Korab, √©diteur: O'Reilly Media, Inc., date de publication: juin 2017, ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traduction termin√©e</a></b> <br><br>  Partie pr√©c√©dente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre les courtiers de messages.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 1. Introduction</a> <br><a name="habracut"></a><br><h2>  CHAPITRE 2 </h2><br><h2>  Activemq </h2><br>  ActiveMQ est mieux d√©crit comme un syst√®me de messagerie classique.  Il a √©t√© √©crit en 2004 pour r√©pondre au besoin d'un courtier de messages open source.  √Ä cette √©poque, si vous vouliez utiliser la messagerie dans vos applications, le seul choix √©tait des produits commerciaux co√ªteux. <br><br>  ActiveMQ a √©t√© d√©velopp√© comme une impl√©mentation de la sp√©cification JMS (Java Message Service).  Cette d√©cision a √©t√© prise pour r√©pondre aux exigences de mise en ≈ìuvre de la messagerie compatible JMS dans le projet Apache Geronimo, un serveur d'applications J2EE open source. <br>  Un syst√®me de messagerie (ou middleware orient√© message, comme on l'appelle parfois) qui impl√©mente la sp√©cification JMS comprend les composants suivants: <br><br>  <b>Courtier</b> <br><br>  Un middleware central distribuant des messages. <br><br>  <b>Client</b> <br><br>  Le logiciel qui envoie des messages via un courtier.  Il se compose √† son tour des artefacts suivants: <br><br><ul><li>  Code √† l'aide de l'API JMS. </li><li>  L'API JMS est un ensemble d'interfaces pour interagir avec un courtier conform√©ment aux garanties √©nonc√©es dans la sp√©cification JMS. </li><li>  La biblioth√®que cliente du syst√®me qui fournit l'impl√©mentation de l'API et interagit avec le courtier. </li></ul><br>  Le client et le courtier communiquent entre eux via le protocole de couche application, √©galement appel√© <i>protocole d'interaction</i> <a href="">(figure 2-1)</a> .  La sp√©cification JMS a laiss√© les d√©tails de ce protocole √† des impl√©mentations sp√©cifiques. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>Figure 2-1.</i>  <i>Examen JMS</i> <br><br>  JMS utilise le terme <i>fournisseur</i> pour d√©crire l'impl√©mentation par le fournisseur du syst√®me de messagerie sous-jacent √† l'API JMS, qui inclut le courtier, ainsi que ses biblioth√®ques clientes. <br><br>  Le choix en faveur de la mise en ≈ìuvre de JMS a eu des cons√©quences profondes sur les d√©cisions de mise en ≈ìuvre prises par les auteurs d'ActiveMQ.  La sp√©cification elle-m√™me fournit des indications claires sur les responsabilit√©s du client du syst√®me de messagerie et du courtier avec qui il communique, en privil√©giant l'obligation du courtier de distribuer et de livrer des messages.  La responsabilit√© principale du client est d'interagir avec le destinataire (file d'attente ou sujet) des messages envoy√©s par lui.  La sp√©cification elle-m√™me vise √† rendre l'interaction de l'API avec le courtier relativement simple. <br><br>  Ce domaine, comme nous le verrons plus loin, a eu un impact significatif sur les performances d'ActiveMQ.  Outre la complexit√© du courtier, le package de compatibilit√© pour la sp√©cification fournie par Sun Microsystems avait de nombreuses nuances, avec leur propre impact sur les performances.  Ces nuances auraient d√ª toutes √™tre prises en compte pour que ActiveMQ soit consid√©r√© comme compatible JMS. <br><br><h3>  La communication </h3><br>  Bien que l'API et le comportement attendu soient bien d√©finis dans la sp√©cification JMS, le protocole de communication client-courtier r√©el a √©t√© d√©lib√©r√©ment exclu de la sp√©cification afin que les courtiers existants puissent √™tre rendus conformes √† JMS.  Ainsi, ActiveMQ √©tait libre de d√©finir son propre protocole d'interaction, OpenWire.  OpenWire est utilis√© par l'impl√©mentation de la biblioth√®que cliente ActiveMQ JMS, ainsi que ses homologues en .Net et C ++: NMS et CMS, qui sont des sous-projets ActiveMQ h√©berg√©s par Apache Software Foundation. <br><br>  Au fil du temps, la prise en charge d'autres protocoles d'interaction a √©t√© ajout√©e √† ActiveMQ, ce qui a augment√© la capacit√© d'interagir avec d'autres langages et environnements: <br><br>  <b>AMQP 1.0</b> <br><br>  Le protocole Advanced Message Queuing (ISO / IEC 19464: 2014) ne doit pas √™tre confondu avec son pr√©d√©cesseur 0.X, qui est impl√©ment√© dans d'autres syst√®mes de messagerie, en particulier RabbitMQ, qui utilise 0.9.1.  AMQP 1.0 est un protocole binaire √† usage g√©n√©ral pour l'√©change de messages entre deux n≈ìuds.  Il n'a aucun concept de clients ou de courtiers et comprend des fonctions telles que le contr√¥le de flux, les transactions et diverses QoS (pas plus d'une fois, au moins une fois et exactement une fois). <br><br>  <b>STOMP</b> <br><br>  Simple / Streaming Text Oriented Messaging Protocol, un protocole facile √† impl√©menter qui a des dizaines d'impl√©mentations client dans diff√©rentes langues. <br><br>  <b>Xmpp</b> <br><br>  Messagerie extensible et protocole de pr√©sence.  (Protocole de messagerie et de pr√©sence extensible).  Anciennement appel√© Jabber, ce protocole bas√© sur XML a √©t√© initialement d√©velopp√© pour les syst√®mes de chat, mais a √©t√© √©tendu au-del√† de ses cas d'utilisation d'origine pour inclure la messagerie de publication-abonnement. <br><br>  <b>MQTT</b> <br><br>  Le protocole l√©ger de publication-abonnement (ISO / IEC 20922: 2016) utilis√© pour les applications Machine-to-Machine (M2M) et Internet of Things (IoT). <br><br>  ActiveMQ prend √©galement en charge l'imposition des protocoles ci-dessus sur WebSockets, qui permet l'√©change de donn√©es en duplex int√©gral entre les applications d'un navigateur Web et les destinations du courtier. <br><br>  Compte tenu de cela, maintenant, lorsque nous parlons d'ActiveMQ, nous ne faisons plus r√©f√©rence exclusivement √† la pile d'interaction bas√©e sur les biblioth√®ques JMS / NMS / CMS et le protocole OpenWire.  La combinaison et la s√©lection des langues, des plates-formes et des biblioth√®ques externes les mieux adapt√©es √† cette application deviennent de plus en plus populaires.  Par exemple, il est possible qu'une application JavaScript s'ex√©cute dans un navigateur √† l'aide de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Eclipse Paho</a> MQTT pour envoyer des messages √† ActiveMQ via des sockets Web, et ces messages sont lus par un processus serveur C ++ qui utilise AMQP via la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Qpid Proton</a> .  De ce point de vue, le paysage de la messagerie se diversifie. <br><br>  En regardant vers l'avenir, AMQP, en particulier, aura beaucoup plus d'opportunit√©s qu'aujourd'hui, car les composants qui ne sont ni clients ni courtiers deviennent une partie plus famili√®re du paysage de la messagerie.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Qpid Dispatch Router</a> agit comme un routeur de messages, auquel les clients se connectent directement, permettant √† diff√©rentes destinations de traiter diff√©rentes adresses, tout en offrant la possibilit√© d'un partage (s√©paration). <br><br>  Lorsque vous travaillez avec des biblioth√®ques tierces et des composants externes, veuillez noter qu'ils ont une qualit√© variable et peuvent ne pas √™tre compatibles avec les fonctions fournies dans ActiveMQ.  √Ä titre d'exemple tr√®s simple - il est impossible d'envoyer des messages √† la file d'attente via MQTT (sans configurer le routage dans le courtier).  Ainsi, vous devrez passer un certain temps √† travailler avec des options pour d√©terminer la pile du syst√®me de messagerie qui convient le mieux aux exigences de votre application. <br><br><h3>  Le compromis entre performance et fiabilit√© </h3><br>  Avant de nous plonger dans les d√©tails du fonctionnement de la messagerie point √† point dans ActiveMQ, nous devons parler un peu de ce √† quoi tous les syst√®mes √† traitement intensif des donn√©es sont confront√©s: un compromis entre performances et fiabilit√©. <br><br>  Tout syst√®me qui accepte des donn√©es, qu'il s'agisse d'un courtier de messages ou d'une base de donn√©es, doit √™tre inform√© de la fa√ßon de traiter ces donn√©es en cas de d√©faillance.  L'√©chec peut prendre de nombreuses formes, mais pour simplifier, nous allons le r√©duire √† une situation o√π le syst√®me perd son alimentation et s'arr√™te imm√©diatement.  Dans cette situation, nous devons sp√©culer sur ce qui arrivera aux donn√©es qui √©taient dans le syst√®me.  Si les donn√©es (dans ce cas, les messages) √©taient en m√©moire ou dans la partie volatile du fer, par exemple, dans le cache, alors ces donn√©es seront perdues.  Cependant, si les donn√©es ont √©t√© envoy√©es vers un stockage non volatile, par exemple sur le disque, elles seront √† nouveau disponibles lorsque le syst√®me reprendra le travail. <br><br>  De ce point de vue, il est logique que si nous ne voulons pas perdre de messages en cas de d√©faillance d'un courtier, nous devons les √©crire dans le stockage permanent.  Malheureusement, le co√ªt de cette solution particuli√®re est assez √©lev√©. <br><br>  Notez que la diff√©rence entre l'√©criture d'un m√©gaoctet de donn√©es sur le disque est 100 √† 1000 fois plus lente que l'√©criture dans la m√©moire.  Par cons√©quent, le d√©veloppeur de l'application doit d√©cider si la fiabilit√© du message vaut la perte de performances.  De telles d√©cisions doivent √™tre prises en fonction d'un sc√©nario d'utilisation. <br><br>  Le compromis entre performances et fiabilit√© est bas√© sur une gamme d'options.  Plus la fiabilit√© est √©lev√©e, plus les performances sont faibles.  Si vous d√©cidez de rendre le syst√®me moins fiable, par exemple en ne stockant des messages qu'en m√©moire, votre productivit√© augmentera consid√©rablement.  Par d√©faut, JMS est configur√© pour avoir ActiveMQ pr√™t √† l'emploi pour la fiabilit√©.  Il existe de nombreux m√©canismes qui vous permettent de configurer le courtier et d'interagir avec lui √† une position dans ce spectre qui convient le mieux √† des sc√©narios sp√©cifiques d'utilisation du syst√®me de messagerie. <br><br>  Ce compromis s'applique au niveau des courtiers individuels.  Cependant, une fois la mise en place d'un courtier individuel termin√©e, il est possible de faire √©voluer le syst√®me de messagerie au-del√† de ce point en examinant attentivement les flux de messages et en partageant le trafic entre plusieurs courtiers.  Ceci peut √™tre r√©alis√© en fournissant des destinataires sp√©cifiques avec leurs propres courtiers ou en divisant le flux de messages global soit au niveau de l'application, soit en utilisant un composant interm√©diaire.  Plus loin, nous verrons plus en d√©tail comment prendre en compte les topologies des courtiers. <br><br><h3>  Sauvegarde des messages </h3><br>  ActiveMQ est livr√© avec un certain nombre de strat√©gies de r√©tention de messages enfichables.  Ils se pr√©sentent sous la forme d'adaptateurs de persistance (persistance), qui peuvent √™tre consid√©r√©s comme des moteurs de stockage de messages.  Il s'agit notamment de solutions sur disque telles que KahaDB et LevelDB, ainsi que la possibilit√© d'utiliser la base de donn√©es via JDBC.  √âtant donn√© que les premiers sont les plus couramment utilis√©s, nous concentrerons notre discussion sur eux. <br><br>  Lorsqu'un courtier re√ßoit des messages persistants, ils sont d'abord √©crits sur le disque dans un journal.  Un journal est une structure de donn√©es sur disque dans laquelle vous ne pouvez ajouter que des donn√©es et compos√© de plusieurs fichiers.  Les messages entrants sont s√©rialis√©s par le courtier dans une repr√©sentation ind√©pendante de protocole de l'objet, puis marshal√©s sous forme binaire, qui est ensuite √©crit √† la fin du journal.  Le journal contient un journal de tous les messages entrants, ainsi que des informations sur les messages dont la lecture a √©t√© confirm√©e par le client. <br><br>  Les adaptateurs de disque de persistance prennent en charge les fichiers d'index qui suivent l'emplacement des messages transf√©r√©s suivants dans le journal.  Lorsque tous les messages du fichier journal sont lus, ils sont supprim√©s ou archiv√©s par le flux de travail en arri√®re-plan ActiveMQ.  Si ce journal est endommag√© lors de l'√©chec du courtier, ActiveMQ le reconstruira en fonction des informations contenues dans les fichiers journaux. <br><br>  Les messages de toutes les files d'attente sont √©crits dans les m√™mes fichiers journaux, ce qui signifie que si un message n'est pas lu, le fichier entier (g√©n√©ralement la valeur par d√©faut est de 32 Mo ou 100 Mo, selon l'adaptateur de persistance) ne peut pas √™tre effac√©.  Cela peut entra√Æner des probl√®mes d'espace disque faible au fil du temps. <br><blockquote>  Les courtiers de messages classiques ne sont pas con√ßus pour un stockage √† long terme - lisez vos messages! </blockquote>  Les journaux sont un m√©canisme extr√™mement efficace pour le stockage et la r√©cup√©ration ult√©rieure des messages, car l'acc√®s au disque est s√©quentiel pour les deux op√©rations.  Sur les disques durs conventionnels, cela minimise le nombre de recherches de disque par cylindres, car les t√™tes sur le disque continuent simplement √† lire ou √† √©crire des secteurs sur le substrat rotatif du disque.  De m√™me, sur les SSD, l'acc√®s s√©quentiel est beaucoup plus rapide que l'acc√®s al√©atoire, car le premier utilise mieux les pages de m√©moire du lecteur. <br><br><h3>  Facteurs de performance du disque </h3><br>  Il existe un certain nombre de facteurs qui d√©terminent la vitesse √† laquelle un disque peut fonctionner.  Pour comprendre cela, consid√©rez la m√©thode d'√©criture sur un disque √† travers un mod√®le mental simplifi√© d'un tuyau ( <a href="">figure 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>Figure 2-2.</i>  <i>Mod√®le de tube de performance de disque</i> <br><br>  Un tuyau a trois dimensions: <br><br>  <b>La longueur</b> <br><br>  Correspond √† la <i>latence</i> attendue pour terminer une op√©ration.  Pour la plupart des disques locaux, il est assez bon, mais il peut devenir un facteur limitant majeur dans les environnements cloud o√π le disque local est r√©ellement en ligne.  Par exemple, au moment de la r√©daction (avril 2017), Amazon garantit que l'√©criture sur son stockage EBS se fera "en moins de 2 ms".  Si nous enregistrons s√©quentiellement, cela donne un d√©bit maximum de 500 enregistrements par seconde. <br><br>  <b>Largeur</b> <br><br>  D√©termine la <i>capacit√© de charge ou la bande passante d'une</i> seule op√©ration.  Les caches de syst√®me de fichiers utilisent cette propri√©t√© en combinant de nombreux petits enregistrements dans un ensemble plus petit d'op√©rations d'√©criture plus importantes effectu√©es sur le disque. <br><br>  <b>Bande passante au fil du temps</b> <br><br>  L'id√©e est pr√©sent√©e sous la forme d'une s√©rie d'√©v√©nements qui peuvent √™tre dans le tuyau en m√™me temps, exprim√©s par une m√©trique appel√©e <i>IOPS (nombre d'op√©rations d'E / S par seconde)</i> .  IOPS est couramment utilis√© par les fabricants de stockage et les fournisseurs de cloud pour mesurer les performances.  Le disque dur aura diff√©rentes valeurs IOPS dans diff√©rents contextes: si la charge de travail se compose principalement de lecture, d'√©criture ou d'une combinaison d'entre elles, et si ces op√©rations sont s√©quentielles, arbitraires ou mixtes.  Les mesures IOPS les plus int√©ressantes du point de vue du courtier sont des op√©rations de lecture et d'√©criture s√©quentielles, car elles correspondent √† la lecture et √† l'√©criture des journaux d'un journal. <br><br>  Le d√©bit maximal d'un courtier de messages est d√©termin√© par la <i>r√©alisation de la premi√®re de ces restrictions,</i> et la configuration du courtier d√©pend en grande partie de la fa√ßon dont vous interagissez avec les disques.  Cela n'est pas seulement un facteur de la configuration, par exemple, du courtier, mais d√©pend √©galement de la fa√ßon dont les producteurs interagissent avec le courtier.  Comme pour tout ce qui concerne les performances, il est n√©cessaire de tester le courtier sur une charge de travail repr√©sentative (c'est-√†-dire aussi proche que possible des vrais messages) et sur la configuration de stockage r√©elle qui sera utilis√©e dans PROM.  Ceci est fait afin de comprendre comment le syst√®me se comportera dans la r√©alit√©. <br><br><h3>  API JMS </h3><br>  Avant d'entrer dans les d√©tails de la fa√ßon dont ActiveMQ communique avec les clients, nous devons d'abord apprendre l'API JMS.  L'API d√©finit un ensemble d'interfaces de programmation utilis√©es par le code client: <br><br>  <b>ConnectionFactory</b> <br><br>  Il s'agit de l'interface de niveau sup√©rieur utilis√©e pour √©tablir des connexions avec le courtier.  Dans une application de messagerie typique, il n'y a qu'une seule instance de cette interface.  Dans ActiveMQ, il s'agit d'un ActiveMQConnectionFactory.  Au niveau sup√©rieur, cette conception indique l'emplacement du courtier de messages, ainsi que des d√©tails de bas niveau sur la fa√ßon d'interagir avec lui.  Comme son nom l'indique, ConnectionFactory est le m√©canisme par lequel les objets Connection sont cr√©√©s. <br><br>  <b>Connexion</b> <br><br>  Il s'agit d'un objet √† longue dur√©e de vie qui ressemble √† peu pr√®s √† une connexion TCP - apr√®s sa cr√©ation, il existe g√©n√©ralement tout au long du cycle de vie de l'application jusqu'√† sa fermeture.  La connexion est thread-safe et peut fonctionner avec plusieurs threads simultan√©ment.  Les objets de connexion vous permettent de cr√©er des objets Session. <br><br>  <b>S√©ance</b> <br><br>  Il s'agit d'un descripteur de flux lors de l'interaction avec un courtier.  Les objets de session ne sont pas thread-safe, ce qui signifie qu'ils ne sont pas accessibles par plusieurs threads en m√™me temps.  La session est le principal descripteur transactionnel avec lequel le programmeur peut valider et annuler les messages de restauration s'il est en mode transactionnel.  √Ä l'aide de cet objet, vous cr√©ez des objets Message, MessageConsumer et MessageProducer, ainsi que des pointeurs (descripteurs) vers des objets Rubrique et File d'attente. <br><br>  <b>MessageProducer</b> <br><br>  Cette interface vous permet d'envoyer un message au destinataire. <br><br>  <b>Messageconsumer</b> <br><br>  Cette interface permet au d√©veloppeur de recevoir des messages.  Il existe deux m√©canismes de r√©cup√©ration des messages: <br><br><ul><li>  Enregistrez MessageListener.  Il s'agit de l'interface du gestionnaire de messages que vous avez impl√©ment√©e, qui traitera s√©quentiellement tous les messages √©mis par le courtier √† l'aide d'un seul flux. </li><li>  Interrogation des messages √† l'aide de la m√©thode receive (). </li></ul><br>  <b>Message</b> <br><br>  Il s'agit probablement de la structure la plus importante car elle transf√®re vos donn√©es.  Les messages dans JMS se composent de deux aspects: <br><br><ul><li>  M√©tadonn√©es du message.  Le message contient des en-t√™tes et des propri√©t√©s.  Cela et cela peuvent √™tre consid√©r√©s comme des √©l√©ments d'une carte.  Les en-t√™tes sont des √©l√©ments bien connus d√©finis par la sp√©cification JMS et disponibles directement via l'API, tels que JMSDestination et JMSTimestamp.  Les propri√©t√©s sont des √©l√©ments arbitraires de message d√©finis pour simplifier le traitement ou le routage des messages sans avoir √† lire la charge utile du message lui-m√™me.  Vous pouvez, par exemple, d√©finir l'en-t√™te sur AccountID ou OrderType. </li><li>  Corps du message.  Depuis Session, plusieurs types de messages diff√©rents peuvent √™tre cr√©√©s en fonction du type de contenu qui sera envoy√© dans le corps, les plus courants √©tant TextMessage pour les cha√Ænes et BytesMessage pour les donn√©es binaires. </li></ul><br><h3>  Comment fonctionnent les files d'attente: une histoire √† deux cerveaux </h3><br>  Un mod√®le de travail ActiveMQ utile, quoique inexact, est un mod√®le de deux moiti√©s du cerveau.  Une partie est charg√©e de recevoir les messages du producteur, et l'autre envoie ces messages aux consommateurs.  Les relations sont en fait plus complexes √† des fins d'optimisation des performances, mais le mod√®le est suffisant pour une compr√©hension de base. <br><br><h4>  Envoi de messages √† la file d'attente </h4><br>  Examinons l'interaction qui se produit lors de l'envoi d'un message. <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La figure 2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous montre un mod√®le simplifi√© du processus par lequel les messages sont re√ßus par le courtier. Il ne correspond pas enti√®rement au comportement dans chaque cas, mais il est tout √† fait appropri√© pour obtenir une compr√©hension de base. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2-3. Envoi de messages √† JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans une application cliente, un thread re√ßoit un pointeur vers un MessageProducer. Il cr√©e un message avec une charge utile de message estim√©e et appelle MessageProducer.send ("commandes", message), avec la file d'attente comme destination finale du message. √âtant donn√© que le programmeur ne souhaite pas perdre le message en cas de panne du courtier, l'en-t√™te du message JMSDeliveryMode a √©t√© d√©fini sur PERSISTENT (comportement par d√©faut).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade (1), le flux d'envoi appelle la biblioth√®que cliente et rassemble le message au format OpenWire. Ensuite, le message est envoy√© au courtier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le courtier, le flux de r√©ception supprime le message de la ligne et le d√©masque √† l'objet interne. Ensuite, l'objet de message est transmis √† l'adaptateur de persistance, qui rassemble le message √† l'aide du format de tampons de protocole Google et l'√©crit dans le stockage (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir enregistr√© le message dans le stockage, l'adaptateur de persistance devrait recevoir la confirmation que le message a bien √©t√© enregistr√© (3). C'est g√©n√©ralement la partie la plus lente de toute l'interaction; plus sur cela plus tard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s que le courtier s'assure que le message a bien √©t√© enregistr√©, il envoie une r√©ponse de confirmation (4) au client. Apr√®s cela, le thread client qui a initialement appel√© l'op√©ration send () peut continuer son travail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette confirmation en attente de messages persistants est la base de la garantie fournie par l'API JMS - si vous souhaitez que le message soit enregistr√©, il est probablement √©galement important pour vous si le message a √©t√© re√ßu par le courtier en premier lieu. Il existe un certain nombre de raisons pour lesquelles cela peut ne pas √™tre possible, par exemple, une limite de m√©moire ou de disque a √©t√© atteinte. Au lieu d'√©chouer, le courtier suspend l'op√©ration d'envoi, for√ßant le producteur √† attendre jusqu'√† ce que suffisamment de ressources syst√®me apparaissent pour traiter le message (un processus appel√© Producer Flow Control), ou il enverra une confirmation n√©gative au producteur, lan√ßant une exception. Le comportement exact est personnalisable pour chaque courtier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette op√©ration simple, un nombre important d'interactions d'E / S ont lieu: deux op√©rations r√©seau entre le producteur et le courtier, une op√©ration de sauvegarde et une √©tape de confirmation. L'op√©ration de sauvegarde peut √™tre une simple √©criture sur le disque ou une autre transition r√©seau vers le serveur de stockage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela soul√®ve une question importante concernant les courtiers de messages: leur travail est associ√© √† un flux extr√™mement intensif d'op√©rations d'E / S et ils sont tr√®s sensibles √† l'infrastructure utilis√©e, en particulier aux disques.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons de plus pr√®s l'√©tape de confirmation (3) dans l'interaction ci-dessus. </font><font style="vertical-align: inherit;">Si l'adaptateur de persistance est bas√© sur un fichier, le stockage du message implique l'√©criture dans le syst√®me de fichiers. </font><font style="vertical-align: inherit;">Si oui, alors pourquoi dois-je confirmer que l'op√©ration d'√©criture est termin√©e? </font><font style="vertical-align: inherit;">Le fait de terminer un enregistrement signifie-t-il vraiment qu'un enregistrement a eu lieu?</font></font><br>  Pas vraiment.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme cela se produit habituellement, plus vous √©tudiez quelque chose en profondeur, plus il s'av√®re complexe. </font><font style="vertical-align: inherit;">Dans ce cas particulier, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise en cache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le coupable </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caches, caches partout </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'un processus du syst√®me d'exploitation, tel qu'un courtier, √©crit des donn√©es sur le disque, il interagit avec le syst√®me de fichiers. Un syst√®me de fichiers est un processus qui r√©sume les d√©tails de l'interaction avec le support de stockage utilis√©, fournissant une API pour les op√©rations de fichiers telles que OPEN, CLOSE, READ et WRITE. L'une de ces fonctions consiste √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimiser le nombre d'op√©rations d'√©criture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en mettant en m√©moire tampon les donn√©es √©crites par le syst√®me d'exploitation dans des blocs qui peuvent √™tre enregistr√©s sur le disque en une seule approche. Les op√©rations d'√©criture du syst√®me de fichiers qui semblent interagir avec les disques sont en fait √©crites dans ce </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache tampon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, c'est pourquoi votre ordinateur se plaint lorsque vous √©jectez un lecteur USB en toute s√©curit√© - les fichiers que vous avez copi√©s peuvent ne pas avoir √©t√© r√©ellement √©crits! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s que les donn√©es d√©passent le cache de tampon, elles passent au niveau suivant de mise en cache, cette fois au niveau mat√©riel - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le cache du contr√¥leur de disque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ils sont particuli√®rement importants pour les syst√®mes RAID et remplissent la m√™me fonction que la mise en cache au niveau du syst√®me d'exploitation: minimiser le nombre d'interactions requises pour les disques eux-m√™mes. Ces caches se r√©partissent en deux cat√©gories: les </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©critures √† √©criture</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> imm√©diate sont transf√©r√©es sur le disque d√®s leur r√©ception. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©√©criture</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'enregistrement est effectu√© sur les disques uniquement lorsque le tampon est plein atteint une certaine valeur de seuil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les donn√©es stock√©es dans ces caches peuvent √™tre facilement perdues lors d'une panne de courant, car la m√©moire qu'ils utilisent est g√©n√©ralement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volatile (volatile)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Les cartes plus ch√®res ont des batteries redondantes (BBU) qui prennent en charge l'alimentation du cache jusqu'√† ce que tout le syst√®me puisse restaurer l'alimentation, apr√®s quoi les donn√©es seront √©crites sur le disque. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier niveau de cache se trouve sur les disques eux-m√™mes. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caches de disque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situ√©s sur des disques durs (√† la fois sur des disques durs standard et sur des disques SSD) et peuvent √™tre √† √©criture directe ou √† r√©√©criture. La plupart des lecteurs commerciaux utilisent des caches de r√©√©criture et sont volatils, ce qui signifie encore une fois que les donn√©es peuvent √™tre perdues en cas de panne de courant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De retour au courtier de messages, vous devez terminer l'√©tape de confirmation pour vous assurer que les donn√©es ont bien atteint le disque. Malheureusement, l'interaction avec ces tampons mat√©riels d√©pend du syst√®me de fichiers, donc tout ce qu'un processus comme ActiveMQ peut faire est d'envoyer un signal au syst√®me de fichiers indiquant qu'il veut synchroniser tous les tampons syst√®me avec le p√©riph√©rique utilis√©. Pour ce faire, le courtier appelle la m√©thode java.io.FileDescriptor.sync (), qui, √† son tour, d√©marre l'op√©ration POSIX fsync ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce comportement de synchronisation est une exigence du JMS pour garantir que tous les messages marqu√©s comme persistants sont r√©ellement enregistr√©s sur le disque et donc ex√©cut√©s apr√®s la r√©ception de chaque message ou ensemble de messages associ√©s dans une transaction. </font><font style="vertical-align: inherit;">Par cons√©quent, la vitesse √† laquelle un disque peut ex√©cuter sync () est critique pour les performances du courtier.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflits internes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation d'un journal pour toutes les files d'attente ajoute une complexit√© suppl√©mentaire. √Ä tout moment, plusieurs producteurs peuvent envoyer des messages simultan√©ment. Le courtier dispose de plusieurs flux qui re√ßoivent ces messages des sockets entrantes. Chaque thread doit enregistrer son message dans le journal. √âtant donn√© que plusieurs threads ne peuvent pas √©crire dans le m√™me fichier en m√™me temps, car les enregistrements entreront en conflit les uns avec les autres, puis les enregistrements doivent √™tre mis en file d'attente √† l'aide du m√©canisme d'exclusion mutuelle. Nous appelons ce </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conflit de thread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque message doit √™tre enti√®rement enregistr√© et synchronis√© avant de traiter le message suivant. Cette restriction affecte simultan√©ment toutes les files d'attente du courtier. Ainsi, la vitesse √† laquelle un message peut √™tre re√ßu est le temps qu'il faut pour √©crire sur le disque, plus le temps d'attente pour que d'autres flux terminent l'enregistrement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ActiveMQ comprend un tampon d'√©criture, dans lequel les flux de r√©ception √©crivent leurs messages, en attendant la fin de l'enregistrement pr√©c√©dent. Ensuite, le tampon est √©crit en une seule action lorsque le message devient disponible. √Ä la fin, les threads sont notifi√©s. Ainsi, le courtier maximise l'utilisation de la bande passante de stockage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour minimiser l'impact des conflits de threads, les ensembles de files d'attente peuvent se voir attribuer leurs propres journaux √† l'aide de l'adaptateur mKahaDB. </font><font style="vertical-align: inherit;">Cette approche r√©duit la latence d'√©criture, car √† tout moment, les threads √©crivent tr√®s probablement dans des journaux diff√©rents et n'ont pas besoin de se faire concurrence pour un acc√®s exclusif √† un fichier journal.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les transactions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'avantage d'utiliser un seul journal pour toutes les files d'attente est que, du point de vue des auteurs du courtier, il est beaucoup plus facile d'impl√©menter des transactions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardons un exemple o√π plusieurs messages sont envoy√©s par un producteur √† plusieurs files d'attente. L'utilisation d'une transaction signifie que l'ensemble des messages √† envoyer doit √™tre consid√©r√© comme une seule op√©ration atomique. Dans cette interaction, la biblioth√®que cliente ActiveMQ est en mesure d'effectuer des optimisations qui augmenteront consid√©rablement la vitesse d'envoi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'op√©ration illustr√©e √† la </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 2-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le producteur envoie trois messages, tous dans des files d'attente diff√©rentes. </font><font style="vertical-align: inherit;">Au lieu de l'interaction habituelle avec le courtier, lorsque chaque message est confirm√©, le client envoie les trois messages de mani√®re asynchrone, c'est-√†-dire sans attendre de r√©ponse. </font><font style="vertical-align: inherit;">Ces messages sont stock√©s dans la m√©moire du courtier. </font><font style="vertical-align: inherit;">D√®s que l'op√©ration est termin√©e, le producteur informe ses sessions de la n√©cessit√© de valider, ce qui oblige le courtier √† effectuer un grand enregistrement avec une seule op√©ration de synchronisation. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2-4. </font><font style="vertical-align: inherit;">Envoi de messages dans les transactions</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans ce type d'op√©ration, ActiveMQ utilise deux optimisations pour augmenter la vitesse:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La suppression du temps d'attente avant la prochaine exp√©dition par le producteur devient possible </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combiner de nombreuses op√©rations de petits disques en une seule - cela vous permet d'utiliser toute la bande passante du bus de disque </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous comparons cela avec la situation o√π chaque file d'attente est stock√©e dans son propre journal, alors le courtier devrait fournir quelque chose comme la coordination des transactions entre tous les enregistrements. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Soustraire des messages de la file d'attente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le processus de lecture des messages commence lorsque le consommateur exprime sa volont√© de les accepter soit en configurant un MessageListener pour traiter les messages √† leur arriv√©e, soit en appelant la m√©thode MessageConsumer.receive () ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2-5. Lecture de messages via JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque ActiveMQ prend connaissance d'un consommateur, il (ActiveMQ) lit (pages) les messages page par page du stockage vers la m√©moire de distribution (1). Ces messages sont ensuite redirig√©s (envoy√©s) vers le comptable (2), souvent en plusieurs parties pour r√©duire la quantit√© d'interaction r√©seau. Le courtier garde une trace des messages qui ont √©t√© redirig√©s et vers quel consommateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les messages re√ßus par le consommateur ne sont pas trait√©s imm√©diatement par l'application, mais sont plac√©s dans une zone m√©moire appel√©e</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tampon de </font><font style="vertical-align: inherit;">pr√©lecture (tampon de </font><font style="vertical-align: inherit;">pr√©lecture)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le but de ce tampon est de rationaliser le flux de messages afin que le courtier puisse √©mettre des messages au superviseur lorsqu'ils deviennent disponibles pour l'envoi, tandis que le consommateur peut les recevoir de mani√®re ordonn√©e, une √† la fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä un certain moment apr√®s √™tre entr√© dans le tampon de pr√©lecture, les messages sont lus par la logique d'application (X) et la confirmation de la relecture est envoy√©e au courtier (3). Le d√©lai entre le traitement des messages et la confirmation est configur√© √† l'aide d'un param√®tre de session JMS appel√© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mode d'accus√© de r√©ception</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dont nous parlerons un peu plus tard.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√®s que le courtier accepte la confirmation de remise du message, celle-ci est supprim√©e de la m√©moire et de la m√©moire de messages (4). Le terme ¬´suppression¬ª est quelque peu trompeur, car en r√©alit√©, un enregistrement de confirmation est √©crit dans le journal et l'indice dans l'indice augmente. La suppression effective du fichier journal contenant le message sera effectu√©e par le garbage collector dans le thread d'arri√®re-plan en fonction de ces informations.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le comportement d√©crit ci-dessus est une simplification pour faciliter la compr√©hension. </font><font style="vertical-align: inherit;">En fait, ActiveMQ ne se contente pas de lire les donn√©es page par page √† partir du disque, mais utilise √† la place le m√©canisme de curseur entre les parties de r√©ception et de redirection du courtier pour minimiser l'interaction avec le r√©f√©rentiel du courtier dans la mesure du possible. </font><font style="vertical-align: inherit;">La pagination, comme d√©crit ci-dessus, est l'un des modes utilis√©s dans ce m√©canisme. </font><font style="vertical-align: inherit;">Les curseurs peuvent √™tre vus comme un cache au niveau de l'application qui doit √™tre synchronis√© avec le r√©f√©rentiel du courtier. </font><font style="vertical-align: inherit;">Le protocole de coh√©rence utilis√© est une partie importante de ce qui rend le m√©canisme de r√©partition ActiveMQ beaucoup plus complexe que le m√©canisme Kafka d√©crit dans le chapitre suivant.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modes de confirmation et de transaction </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diff√©rents modes de confirmation, qui d√©terminent l'ordre entre la relecture et la confirmation, ont un impact significatif sur la logique √† impl√©menter dans le client. Ils sont les suivants: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est le mode le plus utilis√©, peut-√™tre parce qu'il a le mot AUTO. Ce mode force la biblioth√®que cliente √† accuser r√©ception du message en m√™me temps que le message est lu par l'appel receive (). Cela signifie que si la logique m√©tier initi√©e par le message l√®ve une exception, le message est perdu car il a d√©j√† √©t√© supprim√© sur le courtier. Si le message est lu par l'auditeur, le message ne sera confirm√© qu'apr√®s que l'auditeur a termin√© avec succ√®s le travail. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une confirmation sera envoy√©e uniquement lorsque le code consommateur appelle explicitement la m√©thode Message.acknowledge (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, les confirmations seront mises en m√©moire tampon par le consommateur avant de les envoyer simultan√©ment afin de r√©duire la quantit√© de trafic r√©seau. Cependant, si le syst√®me client s'arr√™te, les confirmations seront perdues et les messages seront renvoy√©s et trait√©s une deuxi√®me fois. Par cons√©quent, le code doit prendre en compte la probabilit√© de messages en double.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les modes de confirmation sont compl√©t√©s par des outils de lecture transactionnelle. </font><font style="vertical-align: inherit;">Lors de la cr√©ation d'une session, elle peut √™tre marqu√©e comme transactionnelle. </font><font style="vertical-align: inherit;">Cela signifie que le programmeur doit appeler explicitement Session.commit () ou Session.rollback (). </font><font style="vertical-align: inherit;">Du c√¥t√© des consommateurs, les transactions √©largissent la gamme d'interactions que le code peut effectuer comme une seule op√©ration atomique. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez lire et traiter plusieurs messages dans leur ensemble, ou soustraire un message d'une file d'attente, puis l'envoyer √† une autre √† l'aide du m√™me objet Session.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Envoi et plusieurs consommateurs </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous avons discut√© du comportement de lecture des messages avec un seul consommateur. Voyons maintenant comment ce mod√®le est applicable √† plusieurs consommateurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque plusieurs consommateurs s'abonnent √† la file d'attente, le comportement par d√©faut du courtier consiste √† envoyer des messages √† tour de r√¥le aux consommateurs qui ont une place dans les tampons de pr√©lecture. Les messages seront envoy√©s dans l'ordre dans lequel ils sont arriv√©s dans la file d'attente - c'est la seule garantie FIFO fournie (premier entr√©, premier sorti; premier entr√©, premier sorti). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque le consommateur s'arr√™te subitement, tous les messages qui lui sont envoy√©s, mais pas encore confirm√©s, seront renvoy√©s √† un autre client disponible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela soul√®ve une question importante: m√™me lorsque des transactions avec les consommateurs sont utilis√©es, rien ne garantit que le message ne sera pas trait√© plusieurs fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenez compte de la logique de traitement suivante √† l'int√©rieur du consommateur:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le message est soustrait de la file d'attente. </font><font style="vertical-align: inherit;">La transaction commence.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un service Web est appel√© avec le contenu du message. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transaction est valid√©e. </font><font style="vertical-align: inherit;">Une confirmation est envoy√©e au courtier.</font></font></li></ol><br>  Si le client termine entre les √©tapes 2 et 3, la relecture du message a d√©j√† affect√© un autre syst√®me en appelant le service Web.  Les appels de service Web sont des requ√™tes HTTP et, en tant que tels, ne sont pas transactionnels. <br><br>  Ce comportement est vrai pour tous les syst√®mes de mise en file d'attente - m√™me s'ils sont transactionnels, ils ne peuvent garantir qu'il n'y aura pas d'effets secondaires lors du traitement des messages.  Apr√®s avoir examin√© en d√©tail le traitement des messages, nous pouvons affirmer avec confiance que: <br><br>  <i>La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livraison de messages n'existe pas une seule fois</a> .</i> <br><br>  Les files d'attente offrent une garantie de livraison <i>au moins une fois,</i> et les parties sensibles du code doivent toujours envisager la possibilit√© de recevoir des messages r√©p√©t√©s.  Nous verrons plus loin comment un client de messagerie peut utiliser la lecture idempotente pour suivre les messages qui ont d√©j√† √©t√© consult√©s et √©viter les doublons. <br><br><h4>  Tri des messages </h4><br>  Pour un ensemble de messages arrivant dans l'ordre de [A, B, C, D], et pour deux consommateurs C1 et C2, la distribution normale des messages sera la suivante: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  √âtant donn√© que le courtier ne contr√¥le pas le fonctionnement des processus de lecture et que l'ordre de traitement est parall√®le, il n'est pas d√©terministe.  Si C1 est plus lent que C2, alors l'ensemble initial de messages peut √™tre trait√© comme [B, D, A, C]. <br><br>  Ce comportement peut surprendre les d√©butants qui s'attendent √† ce que les messages soient trait√©s dans l'ordre et, sur cette base, d√©veloppent leur propre application de messagerie.  L'exigence selon laquelle les messages envoy√©s par le m√™me exp√©diteur doivent √™tre trait√©s dans l'ordre les uns par rapport aux autres, √©galement appel√©e <i>ordre causal</i> , est assez courante. <br><br>  Prenons l'exemple d'utilisation suivant tir√© des paris en ligne: <br><br><ol><li>  Le compte utilisateur est configur√©. </li><li>  L'argent est cr√©dit√© sur le compte. </li><li>  Un pari est effectu√© qui retire de l'argent du compte. </li></ol><br>  Il est logique ici que les messages soient trait√©s dans l'ordre dans lequel ils ont √©t√© envoy√©s, de sorte que l'√©tat g√©n√©ral du compte soit pris en compte.  Des choses √©tranges peuvent se produire si le syst√®me essaie de retirer de l'argent d'un compte qui n'a pas de fonds.  Il existe bien s√ªr des moyens de contourner ce probl√®me. <br><br>  Le mod√®le <i>client exclusif</i> comprend l'envoi de tous les messages de la file d'attente √† un client.  En utilisant cette approche, lorsque vous connectez plusieurs instances d'applications ou de threads √† la file d'attente, ils sont sign√©s √† l'aide d'un param√®tre de destinataire sp√©cial: <code>my.queue?consumer.exclusive=true</code> .  Lorsque vous connectez un consommateur monopole, il re√ßoit tous les messages.  Lorsque le deuxi√®me consommateur est connect√©, il ne recevra aucun message tant que le premier ne se d√©connecte pas.  Ce deuxi√®me consommateur est en fait une r√©serve chaude, tandis que le premier consommateur recevra d√©sormais des messages exactement dans l'ordre dans lequel ils ont √©t√© enregistr√©s dans le journal - dans un ordre causal. <br>  L'inconv√©nient de cette approche est que, bien que le traitement des messages soit coh√©rent, il s'agit d'un goulot d'√©tranglement car tous les messages doivent √™tre trait√©s par un seul ordinateur. <br><br>  Pour mieux comprendre ce cas d'utilisation, vous devez reconsid√©rer le probl√®me.  Tous les messages doivent-ils √™tre trait√©s dans l'ordre?  Dans le cas du traitement des offres d√©crites ci-dessus, il est n√©cessaire de traiter uniquement les messages li√©s √† un compte de mani√®re s√©quentielle.  ActiveMQ fournit un m√©canisme pour faire face √† cette situation appel√© <i>groupes de messages JMS</i> . <br><br>  Les groupes de messages sont une sorte de m√©canisme de partitionnement qui permet aux producteurs de distribuer des messages en groupes qui seront trait√©s s√©quentiellement selon une cl√© m√©tier.  Cette cl√© m√©tier est d√©finie dans une propri√©t√© de message appel√©e <code>JMSXGroupID</code> . <br><br>  La cl√© naturelle en cas de traitement des offres sera l'identifiant du compte. <br>  Pour illustrer le fonctionnement de l'envoi, consid√©rez un ensemble de messages arrivant dans l'ordre suivant: <br><br><pre> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  Lorsqu'un message est trait√© par le m√©canisme de r√©partition dans ActiveMQ et qu'il voit un <code>JMSXGroupID</code> qui n'existait pas auparavant, cette cl√© est affect√©e au consommateur sur une base cyclique.  D√©sormais, tous les messages avec cette cl√© seront envoy√©s √† ce comptable. <br><br>  Ici, les groupes seront r√©partis entre deux consommateurs: C1 et C2, comme suit: <br><br><pre> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  Les messages seront redirig√©s et trait√©s comme suit: <br><br><pre> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  Si le consommateur tombe en panne, tous les groupes qui lui sont attribu√©s seront redistribu√©s parmi le reste des consommateurs et tous les messages non confirm√©s seront redirig√©s √† nouveau.  Par cons√©quent, bien que nous puissions garantir que tous les messages associ√©s seront trait√©s dans l'ordre, nous ne pouvons pas pr√©tendre qu'ils seront trait√©s par le m√™me consommateur. <br><br><h3>  Haute disponibilit√© </h3><br>  ActiveMQ offre une haute disponibilit√© avec un ma√Ætre-esclave bas√© sur le stockage partag√©.  Dans ce sch√©ma, deux ou plusieurs courtiers (bien que g√©n√©ralement deux) sont configur√©s sur des serveurs distincts et leurs messages sont stock√©s dans un magasin de messages situ√© dans un emplacement externe.  Un magasin de messages ne peut pas √™tre utilis√© simultan√©ment par plusieurs instances d'un courtier, donc sa fonction secondaire (magasin) est d'agir comme un m√©canisme de blocage pour d√©terminer quel courtier obtiendra un acc√®s exclusif ( <a href="">figure 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>Figure 2-6.</i>  <i>Le courtier A est le principal; le courtier B est en veille en tant qu'esclave</i> <br><br>  Pour se connecter au r√©f√©rentiel, le premier courtier (Broker A) assume le r√¥le de leader et ouvre ses ports pour le trafic des messages.  Lorsque le deuxi√®me courtier (Broker B) se connecte au r√©f√©rentiel, il essaie d'obtenir un verrou et, comme il ne r√©ussit pas, s'arr√™te pendant une courte p√©riode avant d'essayer d'obtenir √† nouveau un verrou.  C'est ce qu'on appelle le confinement entra√Æn√©. <br><br>  Dans le m√™me temps, le client alterne les adresses des deux courtiers pour tenter de se connecter au port entrant, appel√© connecteur de transport.  D√®s que le courtier principal est disponible, le client se connecte √† son port et peut envoyer et lire des messages. <br>  Lorsque le courtier A, agissant en tant que leader, √©choue en raison d'une d√©faillance du processus ( <a href="">figure 2-7</a> ), les √©v√©nements suivants se produisent: <br><br><ol><li>  Le client se d√©connecte et essaie imm√©diatement de se reconnecter, en alternant les adresses de deux courtiers. </li><li>  Le verrou du message est lib√©r√©.  Le timing d√©pend de l'impl√©mentation du stockage. </li><li>  Le courtier B, qui √©tait en mode esclave, essayant p√©riodiquement d'obtenir un verrou, r√©ussit enfin et assume le r√¥le de ma√Ætre, ouvrant ses ports. </li><li>  Le client se connecte au Broker B et poursuit son travail. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>Figure 2-7.</i>  <i>Le courtier A se termine en perdant la connexion au r√©f√©rentiel.</i>  <i>Le courtier B prend les devants</i> <br><blockquote>  La logique d'alternance entre plusieurs adresses de courtier n'est pas garantie d'√™tre int√©gr√©e dans la biblioth√®que cliente, comme c'est le cas dans les impl√©mentations JMS / NMS / CMS.  Si la biblioth√®que ne fournit que la reconnexion √† une seule adresse, vous devrez peut-√™tre placer quelques courtiers derri√®re un √©quilibreur de charge, qui devrait √©galement √™tre hautement disponible. </blockquote>  Le principal inconv√©nient de cette approche est que pour simplifier le travail d'un courtier logique, plusieurs serveurs physiques sont n√©cessaires.  Dans ce cas, l'un des deux serveurs du courtier est inactif, attendant la d√©connexion de son partenaire avant de pouvoir commencer √† fonctionner. <br><br>  Cette approche pr√©sente √©galement la complexit√© suppl√©mentaire que le stockage du courtier utilis√©, qu'il s'agisse d'un syst√®me de fichiers r√©seau partag√© ou d'une base de donn√©es, doit √©galement √™tre hautement accessible.  Cela entra√Æne des co√ªts suppl√©mentaires pour l'√©quipement et l'administration des param√®tres du courtier.  Dans ce sc√©nario, il est tentant de r√©utiliser des r√©f√©rentiels √† haute disponibilit√© existants utilis√©s par d'autres parties de l'infrastructure, comme une base de donn√©es, mais c'est une erreur. <br><br>  Il est important de se rappeler que le disque est le principal limiteur des performances globales du courtier.  Si le disque lui-m√™me est utilis√© simultan√©ment par un processus autre que le courtier de messages, l'interaction de ce processus avec le disque ralentit probablement l'enregistrement du courtier et, par cons√©quent, la vitesse √† laquelle les messages peuvent transiter par le syst√®me.  De tels ralentissements sont difficiles √† diagnostiquer et la seule solution consiste √† s√©parer les deux processus en diff√©rents volumes de stockage. <br><br>  Pour assurer le fonctionnement stable du courtier, un stockage d√©di√© et exclusif est n√©cessaire. <br><br><h3>  Mise √† l'√©chelle verticale et horizontale </h3><br>  √Ä un moment donn√© de la vie du projet, vous pouvez rencontrer une limitation des performances sur le courtier de messages.  Ces limitations concernent g√©n√©ralement les ressources, en particulier les interactions ActiveMQ avec le stockage utilis√©.  Ces probl√®mes surviennent g√©n√©ralement en raison de conflits de volume de messages ou de bande passante entre les destinataires, par exemple, lorsqu'une file d'attente d√©borde du courtier pendant les p√©riodes de pointe. <br><br>  Il existe plusieurs fa√ßons d'obtenir plus de performances de l'infrastructure du courtier: <br><br><ul><li>  N'utilisez pas la persistance si ce n'est pas n√©cessaire.  Certains sc√©narios d'utilisation autorisent la perte de messages lors de plantages, en particulier lorsqu'un syst√®me envoie un autre √©tat d'instantan√© complet √† l'autre via la file d'attente, p√©riodiquement ou √† la demande. </li><li>  Ex√©cutez le courtier sur des disques plus rapides.  En conditions r√©elles, des diff√©rences significatives dans la bande passante d'enregistrement ont √©t√© not√©es entre le disque dur standard et les alternatives bas√©es sur la m√©moire. </li><li>  Tirez le meilleur parti des tailles de disque.  Comme le montre le mod√®le d'interaction de pipeline de disques d√©crit ci-dessus, un d√©bit plus √©lev√© peut √™tre atteint en utilisant des transactions pour envoyer des groupes de messages, combinant ainsi plusieurs op√©rations d'√©criture en une plus grande. </li><li>  Utilisez le partitionnement du trafic.  Vous pouvez obtenir un d√©bit plus √©lev√© en fractionnant les destinations de l'une des mani√®res suivantes: </li></ul><br><ol><li>  Plusieurs disques dans un courtier, par exemple, en utilisant l'adaptateur de persistance mKahaDB pour plusieurs r√©pertoires, chacun √©tant mont√© sur un disque distinct. </li><li>  Plusieurs courtiers, et le partitionnement du trafic est effectu√© manuellement par l'application cliente.  ActiveMQ ne fournit aucune fonction native √† cet effet. </li></ol><br>  L'une des causes les plus courantes des probl√®mes de performances des courtiers est simplement une tentative d'en faire trop avec une seule instance.  En r√®gle g√©n√©rale, cela se produit dans des situations o√π le courtier est na√Øvement divis√© entre plusieurs applications sans prendre en compte la charge existante sur le courtier ou comprendre les volumes.  Au fil du temps, un courtier est de plus en plus charg√© jusqu'√† ce qu'il cesse de se comporter correctement. <br><br>  Le probl√®me se pose souvent pendant la phase de conception du syst√®me, lorsque l'architecte du syst√®me peut proposer un tel sch√©ma comme dans la <a href="">figure 2-8</a> . <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>Figure 2-8.</i>  <i>Vue conceptuelle de l'infrastructure de messagerie</i> <br><br>  L'objectif est que plusieurs applications communiquent entre elles de mani√®re asynchrone via ActiveMQ.  L'objectif n'est plus sp√©cifi√©, puis le sch√©ma d√©termine la base de la configuration r√©elle du courtier.  Cette approche est appel√©e Universal Data Pipeline. <br><br>  Il ne prend pas en compte l'√©tape fondamentale d'analyse entre la conception conceptuelle mentionn√©e ci-dessus et la mise en ≈ìuvre physique.  Avant de proc√©der √† la construction d'une configuration sp√©cifique, il est n√©cessaire d'effectuer une analyse, qui sera ensuite utilis√©e pour justifier le projet physique.  La premi√®re √©tape de ce processus consiste √† d√©terminer quels syst√®mes interagissent les uns avec les autres - un diagramme assez simple avec des rectangles et des fl√®ches ( <a href="">figure 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>Figure 2-9.</i>  <i>Esquissez les flux de messages entre les syst√®mes</i> <br><br>  Apr√®s son approbation, vous pouvez acc√©der aux d√©tails pour r√©pondre aux questions suivantes: <br><br><ul><li>  Combien de files d'attente et de sujets seront utilis√©s? </li><li>  Quels volumes de messages sont attendus pour chacun d'eux? </li><li>  Quelle est la taille des messages de chaque destinataire?  Les messages volumineux peuvent provoquer des probl√®mes dans le processus de pagination, entra√Ænant le d√©passement des limites de m√©moire et le blocage du courtier. </li><li>  Les flux de messages seront-ils uniformes tout au long de la journ√©e ou y aura-t-il des pointes dues aux travaux par lots?  Des lots volumineux dans une file d'attente moins utilis√©e peuvent interf√©rer avec les √©critures de disque en temps opportun pour les destinations hautes performances. </li><li>  Les syst√®mes sont-ils dans le m√™me centre de donn√©es ou dans diff√©rents?  La communication √† distance implique une sorte de courtier r√©seau. </li></ul><br>  L'id√©e est de d√©finir des sc√©narios de messagerie distincts qui peuvent √™tre combin√©s ou divis√©s par des courtiers individuels ( <a href="">Figure 2-10</a> ). <br>  Apr√®s une telle panne, les sc√©narios d'utilisation peuvent √™tre simul√©s en combinant les uns avec les autres √† l'aide du module de performance ActiveMQ pour identifier les probl√®mes. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>Figure 2-10.</i>  <i>Identification des courtiers individuels</i> <br><br>  Apr√®s avoir d√©termin√© le nombre appropri√© de courtiers logiques, vous pouvez d√©terminer comment les impl√©menter au niveau physique √† l'aide de configurations et de r√©seaux de courtiers hautement accessibles. <br><br><h3>  R√©sum√© </h3><br>  Dans ce chapitre, nous avons examin√© le m√©canisme par lequel ActiveMQ re√ßoit et distribue les messages.  Nous avons discut√© des fonctionnalit√©s prises en charge par cette architecture, y compris l'√©quilibrage de charge permanent des messages et des transactions associ√©s.  Dans le m√™me temps, nous avons introduit un ensemble de concepts communs √† tous les syst√®mes de messagerie, y compris les protocoles de communication et les magazines.  Nous avons √©galement examin√© en d√©tail les difficult√©s li√©es √† l'√©criture sur disque et comment les courtiers peuvent utiliser des techniques telles que l'√©criture de paquets pour am√©liorer les performances.  Enfin, nous avons examin√© comment ActiveMQ peut √™tre rendu hautement disponible et comment le faire √©voluer au-del√† des capacit√©s d'un courtier individuel. <br><br>  Dans le chapitre suivant, nous verrons Apache Kafka et comment son architecture red√©finit la relation entre les clients et les courtiers pour fournir un pipeline de messages incroyablement robuste avec une bande passante qui est beaucoup plus grande qu'un courtier de messages classique.  Nous discuterons de la fonctionnalit√© qu'il utilise pour atteindre cet objectif et examinerons bri√®vement l'architecture des applications qui fournissent cette fonctionnalit√©. <br><br>  Partie suivante: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre les courtiers de messages.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 3. Kafka</a> <br><br>  <b>Traduction termin√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471268/">https://habr.com/ru/post/fr471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471258/index.html">Syst√®me de stockage / chargement de donn√©es</a></li>
<li><a href="../fr471260/index.html">Kali Linux NetHunter sur Android Partie 2: attaques sur les r√©seaux sans fil</a></li>
<li><a href="../fr471262/index.html">Holivar. Histoire de Runet. Partie 5. Trolls: apprendre, imprimante fr√©n√©tique, cuivre</a></li>
<li><a href="../fr471264/index.html">Choisir une alternative √† Mailchimp: pourquoi changer et quel produit choisir</a></li>
<li><a href="../fr471266/index.html">L'avenir est ici ou encod√© directement dans le navigateur</a></li>
<li><a href="../fr471270/index.html">Nous automatisons la r√©ception de donn√©es sur la vitesse de chargement d'un site √† partir de Google PageSpeed ‚Äã‚ÄãInsights [mod√®le]</a></li>
<li><a href="../fr471272/index.html">Les avantages de la frappe forte en C ++: exp√©rience pratique</a></li>
<li><a href="../fr471278/index.html">G√©n√©ration de texte en russe par des mod√®les</a></li>
<li><a href="../fr471282/index.html">Recherche de pneumonie aux rayons X avec Fast.ai</a></li>
<li><a href="../fr471288/index.html">Cr√©ation du visage d'un personnage pour le jeu "OnAir"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>