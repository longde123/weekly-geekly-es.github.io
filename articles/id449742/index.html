<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 🔶 🤶 Proses pengembangan dan pengujian dengan Docker dan Gitlab CI 👩🏾‍⚕️ 🛤️ 🆑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menyarankan agar Anda membiasakan diri dengan transkrip laporan oleh Alexander Sigachev dari Inventos "Proses pengembangan dan pengujian dengan D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proses pengembangan dan pengujian dengan Docker dan Gitlab CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449742/"><p>  <strong>Saya menyarankan agar Anda membiasakan diri dengan transkrip laporan oleh Alexander Sigachev dari Inventos "Proses pengembangan dan pengujian dengan Docker + Gitlab CI"</strong> </p><br><p>  Mereka yang baru mulai mengimplementasikan proses pengembangan dan pengujian berdasarkan Docker + Gitlab CI sering mengajukan pertanyaan mendasar.  Di mana untuk memulai?  Bagaimana cara berorganisasi?  Bagaimana cara menguji? </p><br><p>  Laporan ini baik untuk memberi tahu Anda secara terstruktur tentang proses pengembangan dan pengujian menggunakan Docker dan Gitlab CI.  Laporan 2017 sendiri.  Saya pikir dari laporan ini Anda bisa menggambar dasar-dasar, metodologi, ide, pengalaman penggunaan. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lJsqRwULRVA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Siapa yang peduli, tolong, di bawah kucing. <a name="habracut"></a></p><br><p>  Nama saya Alexander Sigachev.  Saya bekerja untuk Inventos.  Saya akan bercerita tentang pengalaman saya menggunakan Docker dan bagaimana kami secara bertahap mengimplementasikannya pada proyek-proyek di perusahaan. </p><br><p>  Topik: Proses pengembangan menggunakan Docker dan Gitlab CI. </p><br><p><img src="https://habrastorage.org/webt/iu/r2/qt/iur2qtjwp2qa_f4vdvmetzii-no.png"></p><br><p>  Ini adalah pembicaraan saya yang kedua tentang Docker.  Pada saat laporan pertama, kami menggunakan Docker hanya dalam Pengembangan pada mesin pengembangan.  Jumlah karyawan yang menggunakan Docker adalah sekitar 2-3 orang.  Lambat laun, pengalaman diperoleh dan kami bergerak sedikit lebih jauh.  Tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan pertama</a> kami. </p><br><p>  Apa yang akan ada dalam laporan ini?  Kami akan membagikan pengalaman kami tentang rake mana yang kami kumpulkan, masalah apa yang kami pecahkan.  Tidak di mana-mana itu indah, tetapi dibiarkan bergerak. </p><br><p>  Moto kami adalah: meratakan segala yang dicapai oleh tangan kami. </p><br><p><img src="https://habrastorage.org/webt/rg/wx/pb/rgwxpblyvmjf0hb0ly4eecmntf0.png"></p><br><p>  Masalah apa yang kita pecahkan? </p><br><p>  Ketika sebuah perusahaan memiliki beberapa tim, programmer adalah sumber daya bersama.  Ada beberapa tahapan ketika seorang programmer ditarik keluar dari satu proyek dan diberikan untuk beberapa waktu ke proyek lain. </p><br><p>  Agar programmer dapat dengan cepat menyelidiki hal itu, ia perlu mengunduh kode sumber proyek dan meluncurkan lingkungan sesegera mungkin, yang akan memungkinkannya untuk lebih lanjut menyelesaikan tugas-tugas proyek ini. </p><br><p>  Biasanya, jika Anda memulai dari awal, maka dokumentasi dalam proyek tidak cukup.  Hanya orang-orang tua yang memiliki informasi tentang cara mengatur.  Karyawan secara mandiri mengatur tempat kerja mereka dalam satu hingga dua hari.  Untuk mempercepat ini, kami menggunakan Docker. </p><br><p>  Alasan berikutnya adalah standarisasi pengaturan dalam Pembangunan.  Dalam pengalaman saya, pengembang selalu mengambil inisiatif.  Dalam setiap kasus kelima, domain khusus dimasukkan, misalnya, vasya.dev.  Terdekat adalah tetangga Petya, yang domainnya adalah petya.dev.  Mereka sedang mengembangkan situs web atau komponen sistem menggunakan nama domain ini. </p><br><p>  Ketika sistem tumbuh dan nama-nama domain ini mulai jatuh ke dalam konfigurasi, maka ada konflik lingkungan pengembangan dan jalur situs ditulis ulang. </p><br><p> Hal yang sama terjadi dengan pengaturan basis data.  Seseorang tidak peduli dengan keamanan dan bekerja dengan kata sandi root yang kosong.  Seseorang pada tahap instalasi MySQL meminta kata sandi dan kata sandinya ternyata adalah 123. Sering terjadi bahwa konfigurasi basis data terus berubah tergantung pada komit pengembang.  Seseorang dikoreksi, seseorang tidak memperbaiki konfigurasi.  Ada trik ketika kami mengeluarkan semacam test config di <code>.gitignore</code> dan setiap pengembang harus menginstal database.  Ini mempersulit proses awal.  Antara lain, Anda perlu mengingat tentang database.  Basis data harus diinisialisasi, kata sandi harus terdaftar, pengguna harus terdaftar, piring harus dibuat, dan sebagainya. </p><br><p>  Masalah lain adalah berbagai versi perpustakaan.  Sering terjadi bahwa pengembang bekerja dengan berbagai proyek.  Ada proyek Legacy yang dimulai lima tahun lalu (dari 2017 - note. Ed.).  Pada awalnya, kami mulai dengan MySQL 5.5.  Ada juga proyek modern di mana kami mencoba untuk memperkenalkan versi MySQL yang lebih modern, misalnya 5.7 atau lebih lama (pada 2017 - note. Ed.) </p><br><p>  Siapa pun yang bekerja dengan MySQL tahu bahwa pustaka ini menarik dependensi.  Cukup bermasalah untuk menjalankan 2 pangkalan bersama.  Paling tidak, bermasalah bagi pelanggan lama untuk terhubung ke database baru.  Ini pada gilirannya menyebabkan beberapa masalah. </p><br><p>  Masalah berikutnya adalah ketika pengembang bekerja pada mesin lokal, ia menggunakan sumber daya lokal, file lokal, RAM lokal.  Semua interaksi pada saat mengembangkan solusi untuk masalah dilakukan dalam kerangka fakta bahwa ia bekerja pada satu mesin.  Contohnya adalah ketika kita memiliki server backend di Production 3, dan pengembang menyimpan file ke direktori root dan dari sana nginx mengambil file untuk menanggapi permintaan.  Ketika kode tersebut jatuh ke dalam Produksi, ternyata file tersebut ada di salah satu dari 3 server. </p><br><p>  Sekarang arah layanan mikro sedang berkembang.  Ketika kita membagi aplikasi besar kita menjadi beberapa komponen kecil yang saling berinteraksi.  Ini memungkinkan Anda memilih teknologi untuk tumpukan tugas tertentu.  Ini juga memungkinkan Anda berbagi pekerjaan dan bidang tanggung jawab antara pengembang. </p><br><p>  Pengembang Frondend, berkembang di JS, praktis tidak memengaruhi Backend.  Pengembang backend, pada gilirannya, mengembangkan, dalam kasus kami, Ruby on Rails dan tidak mengganggu Frondend.  Interaksi dilakukan menggunakan API. </p><br><p>  Sebagai bonus, dengan Docker kami dapat memanfaatkan sumber daya di Pementasan.  Setiap proyek, karena kekhususannya, memerlukan pengaturan tertentu.  Secara fisik, perlu untuk memilih server virtual dan mengkonfigurasinya secara terpisah, atau untuk berbagi beberapa jenis variabel lingkungan dan proyek dapat saling mempengaruhi tergantung pada versi perpustakaan. </p><br><p><img src="https://habrastorage.org/webt/ue/fu/5h/uefu5hbokfkhivcwpffwt5xi4hi.png"></p><br><p>  Alat  Apa yang kita gunakan </p><br><ul><li>  Langsung Docker itu sendiri.  Dockerfile menjelaskan ketergantungan satu aplikasi. </li><li>  Docker-compose adalah bundel yang menyatukan beberapa aplikasi Docker kami. </li><li>  GitLab kami gunakan untuk menyimpan kode sumber. </li><li>  Kami menggunakan GitLab-CI untuk integrasi sistem. </li></ul><br><p><img src="https://habrastorage.org/webt/yq/z-/zb/yqz-zbkwsjbklpjpkxf6pzqasya.png"></p><br><p>  Laporan ini terdiri dari dua bagian. </p><br><p>  Bagian pertama akan berbicara tentang cara menjalankan Docker pada mesin pengembangan. </p><br><p>  Bagian kedua akan berbicara tentang bagaimana berinteraksi dengan GitLab, bagaimana kita menjalankan tes dan bagaimana kita menjalankan Staging. </p><br><p><img src="https://habrastorage.org/webt/tk/4w/lm/tk4wlm_ul847kzentzlw1ikjypq.png"></p><br><p>  Docker adalah teknologi yang memungkinkan (menggunakan pendekatan deklaratif) untuk menggambarkan komponen yang diperlukan.  Ini adalah contoh Dockerfile.  Di sini kami mengumumkan bahwa kami mewarisi dari gambar Ruby Docker resmi: 2.3.0.  Ini berisi Ruby versi 2.3 yang diinstal.  Kami memasang pustaka build dan NodeJS yang diperlukan.  Kami menjelaskan bahwa kami membuat direktori <code>/app</code> .  Tetapkan direktori aplikasi ke direktori kerja.  Dalam direktori ini kami menempatkan Gemfile dan Gemfile.lock minimum yang diperlukan.  Kemudian kami membangun proyek yang memasang gambar dependensi ini.  Kami mengindikasikan bahwa kontainer akan siap untuk mendengarkan pada port eksternal 3000. Perintah terakhir adalah perintah yang secara langsung meluncurkan aplikasi kita.  Jika kita menjalankan perintah mulai proyek, aplikasi akan mencoba untuk mengeksekusi dan meluncurkan perintah yang ditentukan. </p><br><p><img src="https://habrastorage.org/webt/yc/vn/mp/ycvnmp4_o5pcl9r9hobxbchmntw.png"></p><br><p>  Ini adalah contoh minimal dari file komposisi buruh pelabuhan.  Dalam hal ini, kami menunjukkan bahwa ada hubungan antara kedua wadah.  Ini langsung ke layanan basis data dan layanan web.  Aplikasi web kami dalam banyak kasus memerlukan beberapa jenis database sebagai backend untuk menyimpan data.  Karena kita menggunakan MySQL, contohnya adalah dengan MySQL - tetapi tidak ada yang mencegah kita menggunakan beberapa jenis database teman (PostgreSQL, Redis). </p><br><p>  Kami mengambil gambar 5.7.14 MySQL dari sumber resmi dengan hub Docker tidak berubah.  Gambar yang bertanggung jawab atas aplikasi web kami, kami kumpulkan dari direktori saat ini.  Dia, selama peluncuran pertama, mengumpulkan gambar untuk kami.  Kemudian meluncurkan perintah yang kami jalankan di sini.  Jika kita kembali, kita akan melihat bahwa perintah peluncuran melalui Puma telah ditentukan.  Puma adalah layanan yang ditulis dalam Ruby.  Dalam kasus kedua, kami mendefinisikan ulang.  Perintah ini bisa sewenang-wenang tergantung pada kebutuhan atau tugas kita. </p><br><p>  Kami juga menjelaskan apa yang Anda perlukan untuk meneruskan port pada mesin host kami dari 3.000 ke 3.000 kontainer port.  Ini dilakukan secara otomatis menggunakan iptables dan mekanismenya sendiri, yang langsung disematkan di Docker. </p><br><p>  Pengembang dapat, seperti sebelumnya, menerapkan ke alamat IP yang tersedia, misalnya, 127.0.0.1 alamat IP lokal atau eksternal mesin. </p><br><p>  Baris terakhir mengatakan bahwa wadah web tergantung pada wadah db.  Saat kami menyebut peluncuran wadah web, komposisi buruh pelabuhan akan memulai database untuk kami.  Sudah di awal database (pada kenyataannya, setelah memulai wadah! Ini tidak menjamin kesiapan database), kami akan meluncurkan aplikasi, backend kami. </p><br><p>  Ini memungkinkan Anda untuk menghindari kesalahan ketika database tidak dinaikkan dan memungkinkan Anda untuk menghemat sumber daya ketika kami menghentikan wadah basis data, membebaskan sumber daya untuk proyek-proyek lain. </p><br><p><img src="https://habrastorage.org/webt/s3/r1/9g/s3r19gc5pybevceyecewxzsdyxq.png"></p><br><p>  Apa yang memberi kami penggunaan database buruh pelabuhan pada proyek.  Kita semua pengembang memperbaiki versi MySQL.  Ini memungkinkan Anda untuk menghindari beberapa kesalahan yang mungkin terjadi ketika ada perbedaan versi, ketika sintaks, konfigurasi, dan pengaturan default berubah.  Ini memungkinkan Anda menentukan nama host umum untuk basis data, login, kata sandi.  Kami menjauh dari nama kebun binatang dan konflik dalam file konfigurasi yang sebelumnya. </p><br><p>  Kami dapat menggunakan konfigurasi yang lebih optimal untuk lingkungan Pengembangan, yang akan berbeda dari standarnya.  MySQL dikonfigurasi secara default pada mesin yang lemah dan kinerjanya di luar kotak sangat rendah. </p><br><p><img src="https://habrastorage.org/webt/b2/qh/uz/b2qhuzt2zgbx5upj9etfnoilrnw.png"></p><br><p>  Docker memungkinkan Anda untuk menggunakan juru bahasa Python, Ruby, NodeJS, PHP dari versi yang diinginkan.  Kami menyingkirkan kebutuhan untuk menggunakan semacam pengelola versi.  Sebelumnya, Ruby menggunakan paket rpm, yang memungkinkan pengubahan versi tergantung pada proyeknya.  Ini juga memungkinkan wadah Docker untuk memigrasi kode dengan lancar dan menggantinya bersama dengan dependensi.  Kami tidak memiliki masalah memahami versi penerjemah dan kode.  Untuk memutakhirkan versi, turunkan wadah lama dan angkat wadah baru.  Jika terjadi kesalahan, kami dapat menurunkan wadah baru, menaikkan wadah lama. </p><br><p>  Setelah merakit gambar, wadah dalam Pengembangan dan Produksi akan sama.  Ini terutama berlaku untuk instalasi besar. </p><br><p><img src="https://habrastorage.org/webt/c3/vy/yx/c3vyyxestdms3fuo6vqpst5hhus.png">  Di Frontend, kami menggunakan JavaScipt dan NodeJS. </p><br><p>  Sekarang kami memiliki proyek terbaru di ReacJS.  Pengembang menjalankan seluruh wadah dan dikembangkan menggunakan hot-reload. </p><br><p>  Selanjutnya, tugas merakit JavaScipt diluncurkan dan kode yang dikumpulkan dalam statika diberikan melalui sumber daya nginx hemat. </p><br><p><img src="https://habrastorage.org/webt/6k/8y/ds/6k8yds401e1tmspqtvsnpv9hyq8.png"></p><br><p>  Di sini saya memberikan diagram proyek terakhir kami. </p><br><p>  Tugas apa yang Anda selesaikan?  Kami memiliki kebutuhan untuk membangun sistem yang berinteraksi dengan perangkat seluler.  Mereka mendapatkan data.  Salah satu opsi adalah mengirim pemberitahuan push ke perangkat ini. </p><br><p>  Apa yang telah kami lakukan untuk ini? </p><br><p>  Kami dibagi menjadi beberapa komponen aplikasi seperti: bagian admin di JS, backend, yang berfungsi melalui antarmuka REST di bawah Ruby on Rails.  Backend berinteraksi dengan database.  Hasil yang dihasilkan diberikan kepada klien.  Admin dengan backend dan basis data berinteraksi melalui antarmuka REST. </p><br><p>  Kami juga perlu mengirim pemberitahuan push.  Sebelum itu, kami memiliki proyek di mana mekanisme dilaksanakan yang bertanggung jawab untuk mengirimkan pemberitahuan ke platform seluler. </p><br><p>  Kami mengembangkan skema seperti itu: operator dari browser berinteraksi dengan panel admin, panel admin berinteraksi dengan backend, tugasnya adalah mengirim pemberitahuan Push. </p><br><p>  Pemberitahuan push berinteraksi dengan komponen lain yang diterapkan pada NodeJS. </p><br><p>  Antrian sedang dibangun, dan kemudian mengirimkan pemberitahuan mengikuti mekanismenya sendiri. </p><br><p>  Dua database diambil di sini.  Saat ini, dengan bantuan Docker, kami menggunakan 2 database independen, yang sama sekali tidak terhubung satu sama lain.  Selain itu, mereka memiliki jaringan virtual umum, dan data fisik disimpan di direktori yang berbeda di mesin pengembang. </p><br><p><img src="https://habrastorage.org/webt/7l/vd/iz/7lvdizkbaiozesiqkfy6zeu0ila.png"></p><br><p>  Hal yang sama, tetapi dalam jumlah.  Penggunaan kembali kode penting di sini. </p><br><p>  Jika sebelumnya kita berbicara tentang menggunakan kembali kode dalam bentuk perpustakaan, dalam contoh ini layanan kami, yang menanggapi pemberitahuan push, digunakan kembali sebagai server sepenuhnya.  Ini menyediakan API.  Dan sudah dengan perkembangan baru kami berinteraksi dengannya. </p><br><p>  Pada saat itu, kami menggunakan NodeJS versi 4.  Sekarang (tahun 2017 - note. Ed.) Dalam perkembangan terakhir kami menggunakan versi 7 dari NodeJS.  Tidak ada masalah dalam komponen baru untuk menarik versi perpustakaan baru. </p><br><p>  Jika perlu, Anda dapat melakukan refactor dan meningkatkan versi NodeJS dari layanan push notification. </p><br><p>  Dan jika kita dapat mempertahankan kompatibilitas API, maka kita dapat menggantinya dengan proyek lain yang digunakan sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/wd/xv/4a/wdxv4acjvor1iz_4ay2iaxhwylg.png"></p><br><p>  Apa yang Anda perlu tambahkan Docker?  Tambahkan Dockerfile ke repositori kami yang menjelaskan dependensi yang diperlukan.  Dalam contoh ini, komponen dipecah oleh logika.  Ini adalah satu set minimal pengembang backend. </p><br><p>  Saat membuat proyek baru, buat Dockerfile, jelaskan ekosistem yang diinginkan (Python, Ruby, NodeJS).  Susunan buruh pelabuhan menjelaskan ketergantungan yang diperlukan - database.  Kami menjelaskan bahwa kami membutuhkan database versi ini dan itu, untuk menyimpan data di suatu tempat. </p><br><p>  Kami menggunakan wadah ketiga yang terpisah dengan nginx untuk membuat statis.  Anda dapat mengunggah gambar.  Backend menempatkan mereka dalam volume yang disiapkan sebelumnya, yang juga dipasang dalam wadah dengan nginx, yang memberikan statis. </p><br><p>  Untuk menyimpan konfigurasi nginx, mysql, kami menambahkan folder Docker, di mana kami menyimpan konfigurasi yang diperlukan.  Ketika seorang pengembang membuat repositori git clone di mesinnya, ia sudah mendapatkan proyek yang siap untuk pengembangan lokal.  Pertanyaannya tidak muncul port mana atau pengaturan mana yang diterapkan. </p><br><p><img src="https://habrastorage.org/webt/vx/by/f2/vxbyf2i8sss85npgtavlhvgoe10.png"></p><br><p>  Selanjutnya, kami memiliki beberapa komponen: admin, inform-API, notifikasi push. </p><br><p>  Untuk menjalankan semuanya, kami membuat repositori lain yang disebut aplikasi dockerized.  Saat ini, kami menggunakan beberapa repositori hingga setiap komponen.  Mereka hanya berbeda secara logis - di GitLab kelihatannya seperti folder, dan pada mesin pengembang, folder untuk proyek tertentu.  Satu tingkat di bawah ini adalah komponen yang akan digabungkan. </p><br><p><img src="https://habrastorage.org/webt/jd/ny/wq/jdnywqfo2xha1huuqqmnhb1bvpm.png"></p><br><p>  Ini adalah contoh dari hanya isi dari aplikasi dockerized.  Kami juga membawa katalog Docker di sini, di mana kami mengisi konfigurasi yang diperlukan untuk interaksi semua komponen.  Ada README.md, yang secara singkat menjelaskan cara memulai proyek. </p><br><p>  Di sini kami menggunakan dua file docker-compose.  Ini dilakukan agar dapat berjalan dalam langkah-langkah.  Ketika seorang pengembang bekerja dengan kernel, ia tidak perlu pemberitahuan Push, maka ia hanya meluncurkan file menulis buruh pelabuhan dan karenanya sumber daya disimpan. </p><br><p>  Jika ada kebutuhan untuk integrasi dengan pemberitahuan push, maka docker-compose.yaml dan docker-compose-push.yaml diluncurkan. </p><br><p>  Karena docker-compose.yaml dan docker-compose-push.yaml ada di folder, sebuah jaringan virtual tunggal secara otomatis dibuat. </p><br><p><img src="https://habrastorage.org/webt/hb/sj/ua/hbsjuao3tzaozzkhtv97lzhinn8.png"></p><br><p>  Deskripsi komponen.  Ini adalah file yang lebih maju yang bertanggung jawab untuk mengumpulkan komponen.  Apa yang luar biasa di sini?  Di sini kami memperkenalkan komponen penyeimbang. </p><br><p>  Ini adalah gambar Docker yang sudah jadi di mana nginx diluncurkan dan aplikasi yang mendengarkan soket Docker.  Dinamis, ketika wadah hidup dan mati, konfigurasi nginx akan menghasilkan ulang.  Kami mendistribusikan penanganan komponen dengan nama domain tingkat ketiga. </p><br><p>  Untuk lingkungan Pengembangan, kami menggunakan domain .dev - api.informer.dev.  Aplikasi dengan domain .dev tersedia di mesin pengembang lokal. </p><br><p>  Kemudian konfigurasi ditransfer ke setiap proyek dan semua proyek diluncurkan bersamaan pada saat yang sama. </p><br><p><img src="https://habrastorage.org/webt/ew/i0/_u/ewi0_udkilodmivdjgfjoqt9try.png"></p><br><p>  Jika digambarkan secara grafis, ternyata klien adalah browser kami atau beberapa alat yang dengannya kami melakukan permintaan untuk penyeimbang. </p><br><p>  Penyeimbang nama domain menentukan wadah mana yang akan diakses. </p><br><p>  Ini bisa berupa nginx, yang memberikan area admin JS.  Ini bisa berupa nginx, yang memberikan API atau file statis yang diberikan kepada nginx dalam bentuk memuat gambar. </p><br><p>  Diagram menunjukkan bahwa kontainer terhubung oleh jaringan virtual dan disembunyikan di belakang proxy. </p><br><p>  Di mesin pengembang, Anda dapat beralih ke wadah dengan mengetahui IP, tetapi kami pada dasarnya tidak menggunakan ini.  Kebutuhan untuk perawatan langsung secara praktis tidak muncul. </p><br><p><img src="https://habrastorage.org/webt/6j/wa/af/6jwaaff9m7e_lwmgvxi88fxxkbi.png"></p><br><p>  Contoh apa yang harus dilihat untuk membuat aplikasi galangan?  Menurut pendapat saya contoh yang baik adalah gambar buruh pelabuhan resmi untuk MySQL. </p><br><p>  Cukup rumit.  Ada banyak versi.  Tetapi fungsinya memungkinkan Anda untuk memenuhi banyak kebutuhan yang mungkin timbul dalam proses pengembangan lebih lanjut.  Jika Anda menghabiskan waktu dan mencari tahu bagaimana semua ini berinteraksi, maka saya pikir Anda tidak akan memiliki masalah dalam implementasi diri. </p><br><p>  Di hub.docker.com, biasanya ada tautan ke github.com, yang menyediakan data mentah langsung dari mana Anda dapat mengumpulkan gambar sendiri. </p><br><p>  Lebih lanjut dalam repositori ini adalah skrip docker-endpoint.sh, yang bertanggung jawab untuk inisialisasi awal dan untuk pemrosesan lebih lanjut dari peluncuran aplikasi. </p><br><p>  Juga dalam contoh ini ada kemungkinan konfigurasi menggunakan variabel lingkungan.  Dengan mendefinisikan variabel lingkungan ketika memulai wadah tunggal atau melalui docker-compose, kita dapat mengatakan bahwa kita perlu mengatur kata sandi kosong untuk buruh pelabuhan pada root di MySQL atau apa pun yang kita inginkan. </p><br><p>  Ada opsi untuk membuat kata sandi acak.  Kami mengatakan bahwa kami membutuhkan pengguna, kami perlu menetapkan kata sandi untuk pengguna, dan kami perlu membuat database. </p><br><p>  Dalam proyek kami, kami sedikit menyatukan Dockerfile, yang bertanggung jawab untuk inisialisasi.  Di sana, kami mengoreksi kebutuhan kami untuk membuat perpanjangan hak pengguna yang digunakan aplikasi.  Ini memungkinkan di masa depan untuk hanya membuat database dari konsol aplikasi.  Aplikasi Ruby memiliki perintah untuk membuat, memodifikasi, dan menghapus basis data. </p><br><p><img src="https://habrastorage.org/webt/sj/cn/jy/sjcnjytvgchv17vawenbd66upls.png"></p><br><p>  Ini adalah contoh tampilan versi MySQL tertentu di github.com.  Anda dapat membuka dockerfile dan melihat bagaimana instalasi terjadi di sana. </p><br><p>  skrip docker-endpoint.sh bertanggung jawab atas titik masuk.  Selama inisialisasi awal, beberapa langkah persiapan diperlukan dan semua tindakan ini diambil hanya untuk skrip inisialisasi. </p><br><p><img src="https://habrastorage.org/webt/7h/z4/hy/7hz4hyunbt1ftm38hf9lnmesv3q.png"></p><br><p>  Kami lolos ke bagian kedua. </p><br><p>  Untuk menyimpan kode sumber, kami beralih ke gitlab.  Ini adalah sistem yang cukup kuat yang memiliki antarmuka visual. </p><br><p>  Salah satu komponen dari Gitlab adalah Gitlab CI.  Ini memungkinkan Anda untuk menggambarkan perintah tindak lanjut yang selanjutnya akan digunakan untuk mengatur sistem pengiriman kode atau menjalankan pengujian otomatis. </p><br><p>  Laporan Gitlab CI 2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://goo.gl/uohKjI</a> - laporan dari klub Ruby Russia - cukup rinci dan mungkin akan menarik bagi Anda. </p><br><p><img src="https://habrastorage.org/webt/9f/s8/pk/9fs8pkzbqq4uozrmd2bu4tq0-dg.png"></p><br><p>  Sekarang kita akan mempertimbangkan apa yang diperlukan untuk mengaktifkan Gitlab CI.  Untuk memulai Gitlab CI, cukup bagi kami untuk meletakkan file .gitlab-ci.yml di root proyek. </p><br><p>  Di sini kami menjelaskan bahwa kami ingin melakukan urutan kondisi seperti pengujian, penggunaan. </p><br><p>  Kami menjalankan skrip yang secara langsung memanggil buruh pelabuhan-menyusun perakitan aplikasi kami.  Ini adalah contoh backend. </p><br><p>  Selanjutnya, kami mengatakan bahwa perlu untuk mendorong migrasi untuk mengubah database dan menjalankan tes. </p><br><p>  Jika skrip dieksekusi dengan benar dan tidak mengembalikan kode kesalahan, maka, sesuai, sistem melanjutkan ke tahap kedua penyebaran. </p><br><p>  Fase penyebaran saat ini diterapkan untuk pementasan.  Kami tidak mengatur restart dengan lancar. </p><br><p>  Kami secara paksa memadamkan semua kontainer, dan kemudian kami mengangkat semua kontainer lagi, dikumpulkan pada tahap pertama selama pengujian. </p><br><p>  Kami menjalankannya untuk lingkungan variabel saat ini dari migrasi basis data, yang ditulis oleh pengembang. </p><br><p>  Ada catatan yang berlaku ini hanya untuk cabang master. </p><br><p>  Saat mengganti cabang lain tidak dijalankan. </p><br><p>  Dimungkinkan untuk mengatur peluncuran di cabang-cabang. </p><br><p><img src="https://habrastorage.org/webt/2x/vc/6t/2xvc6tp0zrtrewnpnekatolnipm.png"></p><br><p>  Untuk mengatur ini lebih lanjut, kita perlu menginstal Gitlab Runner. </p><br><p>  Utilitas ini ditulis dalam Golang.  Ini adalah file tunggal seperti biasa di dunia Golang, yang tidak memerlukan dependensi. </p><br><p>  Saat startup, kami mendaftarkan Gitlab Runner. </p><br><p>  Kami mendapatkan kunci di antarmuka web Gitlab. </p><br><p>  Kemudian kita memanggil perintah init pada baris perintah. </p><br><p>  Konfigurasikan Gitlab Runner dalam mode dialog (Shell, Docker, VirtualBox, SSH) </p><br><p>  Kode pada Gitlab Runner akan dijalankan di setiap commit, tergantung pada pengaturan .gitlab-ci.yml. </p><br><p><img src="https://habrastorage.org/webt/jj/nx/c-/jjnxc-msfkvaey7qs-t6n3kbzww.png"></p><br><p>  Tampilan visualnya di Gitlab dalam antarmuka web.  Setelah menghubungkan GItlab CI, sebuah bendera muncul yang menunjukkan status build saat ini. </p><br><p>  Kami melihat bahwa komit dibuat 4 menit yang lalu, yang lulus semua tes dan tidak menimbulkan masalah. </p><br><p><img src="https://habrastorage.org/webt/da/vg/3h/davg3h0aqnoewa2xlu3eebuz5jg.png"></p><br><p>  Kita bisa melihat bangunan lebih detail.  Di sini kita melihat bahwa dua negara telah berlalu.  Menguji status dan status penempatan pada pementasan. </p><br><p>  Jika kita mengklik build tertentu, maka akan ada output konsol dari perintah yang diluncurkan dalam proses sesuai dengan .gitlab-ci.yml. </p><br><p><img src="https://habrastorage.org/webt/dg/zq/a5/dgzqa5difiuz1yw0e4i99jzgfik.png"></p><br><p>  Ini adalah bagaimana sejarah produk kita terlihat.  Kami melihat bahwa ada upaya yang berhasil.  Ketika tes diserahkan, itu tidak melanjutkan ke langkah berikutnya dan kode untuk staging tidak diperbarui. </p><br><p><img src="https://habrastorage.org/webt/cp/g9/rv/cpg9rvvjttpmkvdmi-ve-ugtoh0.png"></p><br><p>  Tugas apa yang kita selesaikan tentang pementasan ketika kita memperkenalkan buruh pelabuhan?           ,   ,     ,     . </p><br><p>         . </p><br><p>              Docker-compose           . </p><br><p>    ,     Docker .  Docker-compose        . </p><br><p>    ,           . </p><br><p>   —   staging   . </p><br><p>            production   80  443 ,     WEB. </p><br><p><img src="https://habrastorage.org/webt/7w/4n/_d/7w4n_dfgts6p7pxijvb6eznq0m0.png"></p><br><p>    ?    Gitlab Runner   . </p><br><p> Gitlab     Gitlab Runner,    -      ,  . </p><br><p>             Gitlab Runner,       . </p><br><p>   nginx-proxy           . </p><br><p>      ,        .       . </p><br><p>        80      ,    . </p><br><p><img src="https://habrastorage.org/webt/az/ke/y8/azkey8kpxp3ruww8fbdc1bnfowk.png"></p><br><p>    ?           root.  root  root  . </p><br><p>     ,    root  ,         root. </p><br><p>         - ,   ,    ,        ,     . </p><br><p>    ?   ,    . </p><br><p>   ,    ? </p><br><p>        ID  (UID)  ID  (GID). </p><br><p>           ID 1000. </p><br><p>               Ubuntu.    Ubuntu    ID 1000. </p><br><p><img src="https://habrastorage.org/webt/wx/th/35/wxth352n7tza8gkpdfcmtaern3m.png"></p><br><p>    ? </p><br><p>    Docker.   ,  . ,    -  ,   . </p><br><p>  ,         . </p><br><p>         . </p><br><p>       Docker    Docker Swarm,    .   -     Docker Swarm. </p><br><p>       .   .    .          web-. </p><br><p><img src="https://habrastorage.org/webt/k8/uh/lw/k8uhlwuir8yffyugvdrupropoba.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449742/">https://habr.com/ru/post/id449742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449722/index.html">Efek sudut</a></li>
<li><a href="../id449724/index.html">Likuidator Baja</a></li>
<li><a href="../id449728/index.html">Lalu Lintas atau Enkripsi lalu lintas di Direct Connect, bagian 3</a></li>
<li><a href="../id449730/index.html">Cryptocurrency: hidup atau mati? Bagian 2. Tren politik dan ekonomi</a></li>
<li><a href="../id449740/index.html">Kami menonton "Window on the city" dengan kualitas tinggi</a></li>
<li><a href="../id449744/index.html">Caching Hasil Kueri Global di ASP.NET CORE</a></li>
<li><a href="../id449746/index.html">DockerHub diretas</a></li>
<li><a href="../id449748/index.html">Siapa yang sumber terbuka - Bagian 2: biek geek</a></li>
<li><a href="../id449750/index.html">Alat pemantauan jaringan terbuka dengan perangkat IoT</a></li>
<li><a href="../id449752/index.html">Kartu magnetik buatan sendiri untuk kalkulator Casio PRO fx-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>