<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏼 💫 ⛈️ Tests unitaires à Laravel 💅🏿 💑 🎪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parmi les discussions dans la communauté, j'entends souvent l'opinion que les tests unitaires à Laravel sont faux, compliqués, et les tests eux-mêmes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests unitaires à Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457866/"><p>  Parmi les discussions dans la communauté, j'entends souvent l'opinion que les tests unitaires à Laravel sont faux, compliqués, et les tests eux-mêmes sont longs et ne donnent aucun avantage.  Pour cette raison, peu écrivent ces tests, se limitant uniquement aux tests de fonctionnalités, et l'utilisation de tests unitaires tend à 0. <br>  J'ai aussi pensé une fois, mais une fois que j'y ai pensé et que je me suis demandé - peut-être que je ne sais pas comment les cuisiner? </p><br><p>  Pendant un certain temps, j'ai compris et à la sortie, j'ai eu une nouvelle compréhension des tests unitaires, et les tests sont devenus clairs, amicaux, rapides et ont commencé à m'aider. <br>  Je veux partager ma compréhension avec la communauté, et encore mieux comprendre ce sujet, rendre mes tests encore meilleurs. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Un peu de philosophie et de limites </h2><br><p>  Laravel est une sorte de cadre à certains endroits.  Surtout en termes de façades et d'éloquent.  Je n'aborderai pas les discussions ou les condamnations de ces points, mais je montrerai comment je les combine avec des tests unitaires. <br>  J'écris des tests après (ou en même temps) l'écriture du code principal.  Peut-être que mon approche ne sera pas compatible avec l'approche TDD ou nécessitera des ajustements partiels. </p><br><p> La question la plus importante que je me pose avant de passer un test est "qu'est-ce que je veux tester exactement?".  C'est un problème important.  C'est cette idée qui m'a permis de reconsidérer mon point de vue sur l'écriture de tests unitaires et le code du projet lui-même. </p><br><p>  Les tests doivent être stables et dépendre au minimum de l'environnement.  Si, lorsque vous effectuez des mutations, vos tests échouent, ils sont très probablement bons.  A l'inverse, s'ils ne tombent pas, ils ne sont probablement pas très bons. </p><br><p>  Prêt à l'emploi, Laravel prend en charge 3 types de tests: </p><br><ul><li>  Navigateur </li><li>  Fonctionnalité </li><li>  Unité </li></ul><br><p>  Je parlerai principalement des tests unitaires. </p><br><p>  Je ne teste pas tout le code via des tests unitaires (ce n'est peut-être pas correct).  Je ne teste pas du tout le code (plus de détails ci-dessous). </p><br><p>  Si des moques sont utilisés dans les tests, n'oubliez pas de faire Mockery :: close () sur tearDown. </p><br><p>  Certains exemples de tests sont «extraits d'Internet». </p><br><h2 id="kak-ya-testiruyu">  Comment je teste </h2><br><p>  Ci-dessous, je vais regrouper les exemples de test par groupe de classe et essayer de donner des exemples de test pour chaque groupe de classe.  Pour la plupart des groupes de classe, je ne donnerai pas d'exemples du code lui-même. </p><br><h3 id="middleware">  Middleware </h3><br><p>  Pour le test unitaire du middleware, je crée un objet de la classe Request, un objet du middleware souhaité, puis j'appelle la méthode handle et exécute les assertions nécessaires.  Le middleware en fonction des actions effectuées peut être divisé en 3 groupes: </p><br><ul><li>  modification de l'objet de demande (modification de la demande de corps ou des sessions) </li><li>  redirection (modification du statut de la réponse) </li><li>  ne rien faire avec l'objet de requête <br>  Essayons de donner un exemple de test pour chaque groupe: </li></ul><br><p>  Supposons que nous ayons le middleware suivant, dont la tâche consiste à modifier le champ de titre: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  Un test pour un middleware similaire pourrait ressembler à ceci: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Les tests pour les groupes 2 et 3 seront d'un tel plan, respectivement: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Classe de demande </h3><br><p>  La tâche principale de ce groupe de classe est l'autorisation et la validation des demandes. </p><br><p>  Je ne teste pas ces classes à travers des tests unitaires (j'avoue que ce n'est peut-être pas vrai), seulement à travers des tests de fonctionnalités.  À mon avis, les tests unitaires sont redondants pour ces classes, mais j'ai trouvé quelques exemples intéressants de la façon dont cela peut être fait.  Peut-être qu'ils vous aideront si vous décidez de tester votre classe d'unité de demande avec des tests: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Contrôleur </h3><br><p>  Je ne teste pas non plus les contrôleurs via des tests unitaires.  Mais lorsque je les teste, j'utilise une fonctionnalité dont je voudrais parler. </p><br><p>  Les contrôleurs, à mon avis, devraient être légers.  Leur tâche est d'obtenir la bonne demande, d'appeler les services et référentiels nécessaires (puisque ces deux termes sont «étrangers» à Laravel, je vais expliquer ma terminologie ci-dessous), renvoyez la réponse.  Déclenche parfois un événement, un travail, etc. <br>  Par conséquent, lors des tests par le biais de tests de fonctionnalités, nous devons non seulement appeler le contrôleur avec les paramètres nécessaires et vérifier la réponse, mais également verrouiller les services nécessaires et vérifier qu'ils sont réellement appelés (ou non).  Parfois - créez un enregistrement dans la base de données. </p><br><p>  Un exemple de test de contrôleur avec une maquette de classe de service: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  Un exemple de test de contrôleur avec une maquette de façade (dans notre cas, un événement, mais par analogie se fait pour d'autres façades Laravel): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Service et référentiels </h3><br><p>  Ces types de classes sont prêts à l'emploi.  J'essaie de garder les contrôleurs minces, alors j'ai mis tout le travail supplémentaire dans l'un de ces groupes de classe. </p><br><p>  J'ai déterminé la différence entre eux comme suit: </p><br><ul><li>  Si j'ai besoin d'implémenter une logique métier, je la mets dans la couche de service (classe) appropriée. </li><li>  Dans tous les autres cas, je l'ai mis dans le groupe de classes de référentiel.  En règle générale, le fonctionnel avec Eloquent va là-bas.  Je comprends que ce n'est pas tout à fait la définition correcte du niveau de référentiel.  J'ai également entendu dire que certains endurent tout ce qui concerne Eloquent dans le modèle.  Mon approche est une sorte de compromis, à mon avis, bien que "académiquement" ne soit pas tout à fait vrai. </li></ul><br><p>  Pour les classes de référentiel, je n'écris presque pas de tests. </p><br><p>  Exemple de test de classe de service ci-dessous: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Event-Listener, Jobs </h3><br><p>  Ces classes sont testées presque selon le principe général - nous préparons les données nécessaires aux tests;  Nous appelons la classe souhaitée depuis le framework et vérifions le résultat. <br>  Exemple pour l'auditeur: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Console console </h3><br><p>  Je considère les commandes de la console comme une sorte de contrôleur qui peut en outre produire (et effectuer des manipulations plus complexes avec les entrées-sorties de la console décrites dans la documentation).  En conséquence, les tests sont similaires au contrôleur: nous vérifions que les méthodes de service nécessaires sont appelées, les événements sont déclenchés (ou non), et nous vérifions également l'interaction avec la console (sortie ou demande de données). </p><br><p>  Un exemple d'un test similaire: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Bibliothèques externes séparées </h3><br><p>  En règle générale, si des bibliothèques distinctes ont des fonctionnalités pour les tests unitaires, elles sont décrites dans la documentation.  Dans d'autres cas, le travail avec ce code est testé de la même manière que la couche service.  Cela n'a aucun sens de couvrir les bibliothèques elles-mêmes avec des tests (uniquement si vous voulez envoyer des RP à cette bibliothèque) et vous devez les considérer comme une sorte de boîte noire. </p><br><p>  Sur de nombreux projets, je dois interagir via l'API avec d'autres services.  Laravel utilise souvent la bibliothèque Guzzle à ces fins.  Il m'a semblé commode de regrouper tout le travail avec d'autres services dans une classe distincte du service NetworkService.  Cela m'a facilité l'écriture et le test du code principal, et a aidé à standardiser les réponses et la gestion des erreurs. </p><br><p>  Je donne des exemples de plusieurs tests pour ma classe NetworkService: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  Conclusions </h2><br><p>  Cette approche me permet d'écrire du code meilleur et plus compréhensible, de tirer parti des approches SOLID et SRP lors de l'écriture de code.  Mes tests sont devenus plus rapides et, surtout, ils ont commencé à me profiter. </p><br><p>  Avec une refactorisation active lors de l'extension ou de la modification des fonctionnalités, nous voyons immédiatement ce qui tombe exactement et nous pouvons corriger rapidement et précisément les erreurs sans les libérer de l'environnement local.  Cela rend la correction d'erreurs aussi bon marché que possible. </p><br><p>  J'espère que les principes et les approches que j'ai décrits vous aideront à gérer les tests unitaires dans Laravel et à faire des tests unitaires vos assistants dans le développement de code. </p><br><p>  Écrivez vos ajouts et commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457866/">https://habr.com/ru/post/fr457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457852/index.html">Analyse: comment les problèmes avec les autorités américaines affecteront Huawei et les activités informatiques</a></li>
<li><a href="../fr457854/index.html">Bonjour des programmeurs des années 80</a></li>
<li><a href="../fr457860/index.html">Développement d'une application de streaming à l'aide de Node.js et React</a></li>
<li><a href="../fr457862/index.html">iOS Digest n ° 8 (14 juin - 27 juin)</a></li>
<li><a href="../fr457864/index.html">Mythes et légendes de l'analyse de système ou de ce qu'un analyste d'une banque fait</a></li>
<li><a href="../fr457870/index.html">Infrastructure de construction de projet avec docker</a></li>
<li><a href="../fr457872/index.html">Comment gérer le temps et arrêter de tergiverser?</a></li>
<li><a href="../fr457874/index.html">Pourquoi les employés reviennent-ils? Histoires de départ et de retour</a></li>
<li><a href="../fr457876/index.html">Traduction: Norme IEEE 802.15.4z. Qu'est-ce qui nous attend dans le futur?</a></li>
<li><a href="../fr457884/index.html">Internet souverain - clarifier les ordonnances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>