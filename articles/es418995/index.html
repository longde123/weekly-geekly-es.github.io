<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèø üë©‚Äçüè≠ ü§úüèª ¬øPor qu√© grab√© un CD 300 veces? üê™ üé° üå≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Colecciono m√∫sica: compro CD, los digitalizo con Exact Audio Copy y escaneo portadas e inserciones. A veces no es f√°cil si el CD se lanz√≥ en una edici...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© grab√© un CD 300 veces?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Colecciono m√∫sica: compro CD, los digitalizo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exact Audio Copy</a> y escaneo portadas e inserciones.  A veces no es f√°cil si el CD se lanz√≥ en una edici√≥n limitada en el extranjero hace 10 a√±os.  Lo m√°s dif√≠cil es si el CD tiene un defecto de fabricaci√≥n, y algunas pistas no se pueden leer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> √°lbum de arreglos para piano <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Altneuland</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Â∏∞ „Çã „Åπ „Åç Âüé</a> fue lanzado en 2005.  Lo encontr√© tres a√±os despu√©s (probablemente en YouTube), descargu√© la mejor copia y la puse en la lista de futuras compras.  Los recientes avances en la tecnolog√≠a de correo internacional han permitido comprar un disco usado el a√±o pasado.  Desafortunadamente, ninguna de mis unidades de CD pod√≠a leer la pista n√∫mero 3. Esto sucede a menudo al comprar discos viejos, especialmente cuando pasaron por el centro de env√≠o internacional de USPS.  Lo puse a un lado y comenc√© a buscar otra copia que encontr√© el mes pasado.  Lleg√≥ el viernes, e inmediatamente intent√© destrozarlo.  Pero con empujado con <i>exactamente el mismo error</i> .  Parece que esto no es una cuesti√≥n de desgaste o da√±o: el disco probablemente sali√≥ defectuoso directamente de f√°brica. <br><br>  ADICI√ìN: Despu√©s de la investigaci√≥n, ya no creo que este sea un defecto de f√°brica.  Cuando escribo el principio o el final de una pista incorrecta en un CD-R vac√≠o y lo copio, ¬°el extractor produce el mismo error!  Pru√©belo usted mismo con el archivo <a href="">minimal.flac</a> . <br><a name="habracut"></a><br>  Quedan dos opciones: intentar alg√∫n d√≠a encontrar otra copia que se copie con √©xito (poco probable) o de alguna manera restaurar los datos de sonido originales de los discos da√±ados.  Ya sabes qu√© opci√≥n he elegido. <br><br><h1>  C√≥mo funciona el destripador </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC no pudo leer la pista No. 3 del disco [Â∏∞ „Çã „Åπ „Åç Âüé]</font></i> <br><br>  Los CD almacenan datos digitales, pero hay una interfaz completamente anal√≥gica entre discos, l√°seres y diodos √≥pticos.  Los errores de lectura se producen por varios motivos: medios sucios, ara√±azos en la capa protectora de policarbonato, vibraci√≥n del propio disco.  Los c√≥digos de correcci√≥n de errores primitivos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el est√°ndar CDDA</a> ayudan a minimizar la distorsi√≥n del sonido en discos raramente utilizados, pero no pueden restaurar completamente el flujo de bits en un CD con una gran cantidad de errores.  Los extractores modernos resuelven el problema con dos m√©todos importantes de detecci√≥n de errores: lectura redundante y AccurateRip. <br><br>  La p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EAC: Tecnolog√≠a de extracci√≥n</a> describe c√≥mo EAC produce lecturas redundantes: <br><br><blockquote>  En modo seguro, el programa lee cada sector al menos dos veces [...] Si ocurre un error (leer o sincronizar), el programa contin√∫a leyendo este sector hasta que 8 de 16 intentos sean id√©nticos.  Tal procedimiento se lleva a cabo como m√°ximo una vez, tres o cinco veces (de acuerdo con la calidad seleccionada de recuperaci√≥n de errores).  ¬°En el peor de los casos, los sectores defectuosos se leen 82 veces! </blockquote><br>  Todo es simple  Si una solicitud de lectura a veces devuelve datos incorrectos, l√©elos nuevamente y luego tenga especial cuidado si las dos primeras lecturas dan resultados diferentes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AccurateRip</a> utiliza el mismo principio, pero de manera distribuida: los extractores env√≠an sumas de verificaci√≥n de los archivos de audio copiados a este servicio.  La idea es que si mil personas copiaron una pista con los mismos bits, esta es probablemente la copia correcta. <br><br>  Este art√≠culo trata sobre qu√© hacer si ambos m√©todos no pueden ayudar.  EAC no da un resultado si cada lectura devuelve datos diferentes, y en la base de datos AccurateRip solo hay un registro sobre un disco raro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "Pas√© diez mil pasajes, diez mil pasajes para verte" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Unidades √≥pticas Asus, LG, Lite-On, Pioneer y OEM desconocido</font></i> <br><br>  Si el CD no se copia, entonces es l√≥gico usar una unidad diferente.  A veces, un modelo en particular es m√°s condescendiente con las especificaciones de CDDA, o hay un mejor firmware para corregir errores u otra cosa.  El foro DBpoweramp tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una clasificaci√≥n de precisi√≥n de unidad de CD / DVD</a> para seleccionar la unidad de extracci√≥n m√°s adecuada. <br><br>  El s√°bado por la ma√±ana, compr√© cinco nuevas unidades de CD de diferentes fabricantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[2]</a> <a name="2_2"></a>  , Los prob√© todos y encontr√© uno que pod√≠a mantener la sincronizaci√≥n en una pista de ritmo.  Desafortunadamente, no se pudo obtener la confirmaci√≥n de extracci√≥n: entre todas las copias hab√≠a aproximadamente 20,000 bytes diferentes. <br><br>  Pero ahora ten√≠a archivos .wav en el disco, y puede beneficiarse de esto.  Razon√© que los errores de lectura en una mala pista est√°n cerca del "correcto".  Por lo tanto, tiene sentido hacer varias extracciones y encontrar un valor de "consenso" para bytes inestables.  Este enfoque fue finalmente exitoso, pero requiri√≥ mucho m√°s trabajo del que esperaba. <br><br><h1>  "La cantidad entra en calidad" </h1><br>  Comenc√© copiando el disco repetidamente en una de las unidades, escribiendo todos los valores para cada byte y declarando el error "corregible" si m√°s de la mitad de las rasgaduras produce un valor de byte espec√≠fico para esta posici√≥n.  El comienzo fue bueno: el n√∫mero de errores no corregibles disminuy√≥ de casi ~ 6900 bytes a N = 4 a ~ 5000 bytes a N = 10.  El beneficio de cada rasgadura adicional disminuy√≥ con el tiempo, hasta que alrededor de N = 80 el n√∫mero de errores no corregibles se estabiliz√≥ en ~ 3700.  Dej√© de rasgar a N = 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Errores fijos y fatales en el n√∫mero de rasgaduras</font></i> <br><br>  Luego intent√© copiar el disco 100 veces en la segunda unidad y usar dos tarjetas de correcci√≥n para "llenar" las posiciones de error que no se pueden corregir desde la primera unidad.  Pero no funcion√≥: ¬°en cada unidad hab√≠a miles de correcciones que no correspond√≠an a las correcciones de la otra!  Resulta que el ruido no puede eliminarse combin√°ndolo con otra fuente de ruido pero relacionada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">Lo mismo, pero para dos discos de validaci√≥n cruzada</font></i> <br><br><h1>  Arte artesanal </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  Hay otro buen recurso en el sitio web de EAC: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba de calidad DAE</a> , que determina la calidad del firmware de una unidad por el nivel de errores que se corrigen.  Este es un manejo de errores de nivel inferior cuando la unidad <i>corrige los</i> errores de lectura en lugar de solo informarlos.  El problema es que el "modo seguro" del EAC solo est√° disponible cuando deshabilita este c√≥digo de correcci√≥n de errores incorporado, lo que sugiere que no funciona correctamente. <br><br>  Prepar√© la prueba grabando el archivo .wav en CD-R, resaltando el sector exacto en la superficie de datos y pint√°ndolo cuidadosamente con un marcador negro.  Estos son errores fatales garantizados en un patr√≥n determinista. <br><br>  Prob√© todas las unidades y obtuve dos resultados interesantes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  Utilic√© la unidad Lite-On para evitar errores de sincronizaci√≥n.  Mastic√≥ el marcador m√°gico con placer, pero estaba muy confundido por las l√≠neas rectas en la superficie de datos.  Puede ver c√≥mo, en lugar de tres picos separados a la derecha, hay un blob fallido gigante. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  La unidad Pioneer recibi√≥ el puntaje DAE m√°s alto.  En mi opini√≥n, el cuadro no parece especial, pero la herramienta de an√°lisis dice que este es el mejor firmware para corregir errores en mi peque√±o conjunto. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  ‚ÄúDesde cierto momento, los n√∫meros importan‚Äù </h1><br>  ¬øC√≥mo utilizar el firmware de Pioneer con una buena correcci√≥n de errores si el EAC de "modo seguro" lo ignora?  Muy simple: cambie el EAC al "modo de r√°faga" y escriba en el disco el flujo de bits en la forma en que el firmware los informa.  ¬øC√≥mo convertir este grupo de archivos .wav no verificados en un archivo de buena calidad, como en "modo seguro"?  S√≠, la misma herramienta de an√°lisis de errores que utilizamos en rips con Lite-On! <br><br>  Despu√©s de algunos ajustes de configuraci√≥n de EAC y despu√©s de cien rasgaduras, obtenemos un diagrama tan hermoso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Errores fijos e incorregibles en el n√∫mero de rasgaduras (Pioneer)</font></i> <br><br>  Lo que se puede notar: <br><br><ul><li>  Los errores de bits fatales tienden r√°pidamente a cero, pero nunca lo alcanzan. </li><li>  Un gran salto en errores corregidos en 53-54 rasgaduras. </li><li>  El n√∫mero de errores antes y despu√©s de este gran salto pr√°cticamente no cambia, lo que indica √°reas de estabilidad en los datos copiados. </li></ul><br><h1>  0xA595BC09 </h1><br>  Utilizando una correcci√≥n de error casi perfecta de Pioneer, gener√© un archivo de "mejor conjetura" y comenc√© a compararlo con las rasgaduras de Pioneer.  Como se esperaba, se descubrieron varias secciones de baja calidad, que correg√≠ haciendo otras 10 rasgaduras: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  Tambi√©n encontr√© algo realmente interesante: ¬°varias rasgaduras produjeron <i>exactamente el</i> mismo contenido!  Recuerde, este es precisamente el criterio para el √©xito en el EAC "modo seguro".  <code>shncat -q -e | rhash --print="%C"</code> comando <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> usa para calcular la suma de verificaci√≥n CRC32 de datos de audio <code>shncat -q -e | rhash --print="%C"</code> : es lo que usa el EAC. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Mientras tanto, los cortes repetidos de secciones de baja calidad nos permitieron completar el an√°lisis con cero errores fatales.  Y cuando revis√© este archivo, ¬°hab√≠a exactamente el mismo contenido de audio que en el rip "normal"!  Esto es suficiente para declarar la victoria. <br><br>  Estoy 99% seguro de haber copiado con √©xito este CD problem√°tico, y 0xA595BC09 es la cantidad correcta de CRC para la pista n√∫mero 3. <br><br><h1>  Ap√©ndice A: compare.rs </h1><br>  Us√© esta herramienta para calcular posibles errores de byte.  No est√° destinado a un uso a largo plazo, por lo que es un poco feo, pero puede ser interesante para quienes tropezaron con esta p√°gina, resolviendo el mismo problema. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1) <a name="1"></a>  En este √∫nico registro AccurateRip, el CRC para todas las pistas excepto la pista n√∫mero 3 coincide con mi disco: la suma es 0x84B9DD1A, y tengo 0xA595BC09.  Sospecho que el destripador no entendi√≥ que tiene una mala conducci√≥n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[volver]</a> <br><br>  2) <a name="2"></a>  La pregunta obvia al comprar una unidad de CD o DVD en 2018 es: "Maldici√≥n, ¬ød√≥nde puedo comprarlos?"  Y no necesitaba uno, sino <i>varios</i> de <i>diferentes marcas</i> .  S√© que solo hay una tienda cercana que tiene unidades de DVD de 5.25 "disponibles. Solo una tienda es lo suficientemente grande como para no lamentar el espacio en el estante para tales unidades, y lo suficientemente extra√±o como para no parecer fuera de lugar. Por supuesto, hablando de Frys Electronics. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[volver]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418995/">https://habr.com/ru/post/es418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418979/index.html">Mientras volaba por todo el pa√≠s, implementando un proyecto para varios miles de empleos</a></li>
<li><a href="../es418981/index.html">M√©todos num√©ricos para resolver ecuaciones el√≠pticas.</a></li>
<li><a href="../es418985/index.html">An√°lisis y dise√±o en su conjunto.</a></li>
<li><a href="../es418987/index.html">Firefox evita f√°cilmente la protecci√≥n en la nueva interfaz de Gmail</a></li>
<li><a href="../es418991/index.html">El microfilm existir√° durante medio milenio.</a></li>
<li><a href="../es418997/index.html">Contribuci√≥n real al c√≥digo abierto real</a></li>
<li><a href="../es418999/index.html">[Anuncio, Peter] Reuni√≥n de JUG.ru con Andrei Belyaev y Alexei Stukalov - Troll oprime a CUBA: Preguntas frecuentes</a></li>
<li><a href="../es419001/index.html">5 "super habilidades" necesarias para el trabajo del futuro</a></li>
<li><a href="../es419003/index.html">Resumen de noticias de blockchain</a></li>
<li><a href="../es419005/index.html">Excursi√≥n a la subestaci√≥n 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>