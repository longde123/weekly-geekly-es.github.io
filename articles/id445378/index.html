<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏾 🌽 🧖🏾 Labirin: klasifikasi, pembangkitan, mencari solusi 🚶🏿 🔫 😛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting klasik ini merinci cara paling populer untuk membuat dan melewati labirin. Artikel ini dibagi menjadi empat bagian: klasifikasi, algoritma pem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labirin: klasifikasi, pembangkitan, mencari solusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Posting klasik ini merinci cara paling populer untuk membuat dan melewati labirin.</i>  <i>Artikel ini dibagi menjadi empat bagian: klasifikasi, algoritma pembangkitan, algoritma untuk memecahkan labirin dan operasi lainnya dengan labirin.</i> <br><br><h2>  Klasifikasi labirin </h2><br>  Labirin secara keseluruhan (dan karenanya algoritma untuk membuatnya) dapat dibagi menjadi tujuh klasifikasi yang berbeda: dimensi, hyperdimension, topologi, tessellation, routing, tekstur dan prioritas.  Labirin dapat menggunakan satu elemen dari setiap kelas dalam kombinasi apa pun. <a name="habracut"></a><br>  <b>Dimensi:</b> kelas dimensi pada dasarnya menentukan berapa banyak dimensi di ruang yang diisi labirin.  Jenis-jenis berikut tersedia: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Dua dimensi</b> <b>:</b> sebagian besar labirin, baik kertas dan nyata, memiliki dimensi ini, yaitu, kita selalu dapat menampilkan rencana labirin pada selembar kertas dan bergerak di sepanjang itu tanpa melintasi koridor lain dari labirin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Tiga dimensi</b></a> <b>:</b> labirin tiga dimensi memiliki beberapa tingkatan;  di dalamnya (setidaknya dalam versi ortogonal), bagian-bagian dapat, di samping empat arah mata angin, turun dan naik.  Labirin 3D sering divisualisasikan sebagai array level 2D dengan naik turun tangga. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Dimensi yang lebih tinggi</b> <b>:</b> Anda dapat membuat labirin empat dimensi dan bahkan lebih multidimensi.  Kadang-kadang mereka divisualisasikan sebagai labirin 3D dengan "portal" memimpin melalui dimensi keempat, misalnya, portal ke "masa lalu" dan "masa depan". </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Menjalin</b> <b>:</b> labirin dengan menjalin - ini pada dasarnya adalah labirin dua dimensi (atau lebih tepatnya 2,5 dimensi), di mana, bagaimanapun, bagian dapat tumpang tindih satu sama lain.  Saat ditampilkan, biasanya cukup jelas di mana buntu dan bagaimana satu bagian di atas yang lain.  Labirin dari dunia nyata, di mana ada jembatan yang menghubungkan satu bagian labirin dengan yang lain, sebagian terjalin. </li></ul><br>  <b>Hyperdimension:</b> klasifikasi menurut hyperdimension sesuai dengan dimensi objek yang bergerak melalui labirin, dan bukan labirin itu sendiri.  Jenis-jenis berikut tersedia: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Non-hyperlabyrinths</b> <b>:</b> hampir semua labirin, bahkan yang dibuat dalam dimensi tinggi atau dengan aturan khusus, biasanya non-hyperlabyrinths.  Di dalamnya kita bekerja dengan titik atau objek kecil, misalnya, bola atau pemain sendiri, yang bergerak dari titik ke titik, dan rute beraspal membentuk garis.  Di setiap titik, ada jumlah pilihan yang mudah dihitung. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyperlabyrinths:</a></b> hyperlabyrinths adalah labirin di mana objek yang dipecahkan bukan hanya sebuah titik.  Hyperlabyrinth standar (atau hyperlabyrinth orde pertama) terdiri dari garis yang membentuk permukaan saat bergerak di sepanjang jalan.  Hyperlabyrinth hanya bisa ada dalam 3D atau dalam medium dengan dimensi yang lebih besar, dan pintu masuk ke hyperlabyrinth seringkali bukan sebuah titik, melainkan sebuah garis.  Hyperlabyrinth secara fundamental berbeda, karena itu perlu untuk memperhitungkan dan secara bersamaan bekerja dengan beberapa bagian di sepanjang garis, dan pada waktu tertentu ada jumlah negara yang hampir tak terbatas dan opsi untuk apa yang dapat dilakukan dengan garis.  Garis solusi tidak terbatas, atau titik akhir berada di luar hyperlabyrinth untuk menghindari garis yang dikompresi ke titik, karena dalam kasus ini dapat dianggap sebagai non-hyperlabyrinth. </li><li>  <b>Hyper-hyperlabyrinth:</b> hyperlabyrinths dapat memiliki dimensi tinggi yang berubah-ubah.  Hyper-hyperlabyrinth (atau hyperlabyrinth orde kedua) kembali meningkatkan dimensi objek yang sedang diselesaikan.  Di sini, objek yang akan dipecahkan adalah pesawat, yang, ketika bergerak di sepanjang jalan, membentuk sosok tiga dimensi.  Hyper-hyperlabyrinth hanya bisa ada di lingkungan 4D atau dimensi yang lebih tinggi. </li></ul><br>  <b>Topologi: Kelas</b> topologi menggambarkan geometri ruang labirin tempat keberadaannya secara keseluruhan.  Jenis-jenis berikut tersedia: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> Ini adalah labirin standar di ruang Euclidean. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>:</b> Istilah "planair" menggambarkan setiap labirin dengan topologi yang tidak biasa.  Biasanya ini berarti bahwa ujung-ujung labirin terhubung dengan cara yang menarik.  Contoh: labirin di permukaan kubus, labirin di permukaan jalur Mobius dan labirin setara dengan yang ada di torus di mana sisi kiri dan kanan, atas dan bawah terhubung berpasangan. </li></ul><br>  <b>Tessellation:</b> klasifikasi geometri sel-sel individu yang membentuk labirin.  Jenis yang ada: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonal</b> <b>:</b> Ini adalah kotak persegi panjang standar di mana sel memiliki bagian berpotongan pada sudut kanan.  Dalam konteks tessellation, mereka juga bisa disebut labirin gamma. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> Delta labirin terdiri dari segitiga yang terhubung, dan setiap sel dapat memiliki hingga tiga bagian yang terhubung dengannya. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>:</b> Labirin Sigma terdiri dari segi enam terhubung;  setiap sel dapat memiliki hingga enam lintasan. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Theta</b> <b>:</b> Labirin Theta terdiri dari lingkaran konsentris lorong-lorong di mana awal atau akhir berada di tengah dan yang lainnya di tepi luar.  Sel biasanya memiliki empat jalur koneksi yang mungkin, tetapi mungkin ada lebih banyak karena lebih banyak sel di cincin luar lorong. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>:</b> Labirin Epsilon terdiri dari octagons atau kuadrat yang terhubung, setiap sel di dalamnya dapat memiliki hingga delapan atau empat lintasan. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>:</b> Labirin zeta terletak di kotak persegi panjang, hanya di samping lorong horisontal dan vertikal, lorong diagonal diperbolehkan pada sudut 45 derajat. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Omega</b> <b>:</b> istilah omega mengacu pada hampir setiap labirin dengan tessellation non-ortogonal yang konstan.  Labirin delta, sigma, theta, dan ipsilon adalah dari jenis ini, seperti banyak skema lain yang dapat Anda pikirkan, misalnya, sebuah labirin yang terdiri dari pasangan segitiga siku-siku. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Retak</b> <b>:</b> Labirin retak adalah labirin amorf tanpa penghentian konstan, di mana dinding dan jalur pejalan kaki terletak pada sudut acak. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fraktal</b> <b>:</b> Labirin fraktal adalah labirin yang terdiri dari labirin yang lebih kecil.  Labirin fraktal dari sel bersarang adalah labirin di setiap sel tempat labirin lainnya ditempatkan, dan proses ini dapat diulang beberapa kali.  Labirin fraktal rekursif tak terhingga adalah fraktal sejati di mana isi labirin mereplikasi dirinya sendiri, menciptakan labirin besar yang pada dasarnya tak terhingga. </li></ul><br>  <b>Routing:</b> Klasifikasi oleh routing mungkin merupakan aspek yang paling menarik dalam menghasilkan labirin.  Dari dikaitkan dengan jenis lintasan dalam geometri yang didefinisikan dalam kategori yang dijelaskan di atas. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> "ideal" adalah labirin tanpa loop atau sirkuit tertutup dan tanpa area yang tidak terjangkau.  Ini juga disebut Labirin yang terhubung sederhana.  Dari setiap titik ada tepat satu jalur ke titik lain.  Labirin hanya memiliki satu solusi.  Dari sudut pandang pemrograman, labirin seperti itu dapat digambarkan sebagai pohon, sekumpulan sel atau simpul penghubung. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Jalinan</b> <b>:</b> Jalinan berarti bahwa tidak ada jalan buntu di labirin.  Ini juga disebut labirin labirin yang terhubung secara murni.  Dalam labirin seperti itu, lorong-lorong digunakan sedekat itu dan kembali satu sama lain (karenanya disebut "anyaman"), mereka membuat mereka menghabiskan lebih banyak waktu berjalan dalam lingkaran daripada masuk ke jalan buntu.  Labirin anyaman yang berkualitas bisa jauh lebih rumit daripada labirin ideal dengan ukuran yang sama. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Rute tunggal (Unicursal)</b> <b>:</b> <b>rute</b> tunggal berarti labirin tanpa garpu.  Labirin satu arah berisi satu lorong panjang berliku yang mengubah arah sepanjang labirin.  Ini tidak terlalu rumit, hanya jika Anda tidak sengaja kembali setengah jalan dan tidak kembali ke awal. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Jarang:</b> labirin jarang tidak melewati setiap sel, artinya, beberapa di antaranya tidak dibuat.  Ini menyiratkan adanya daerah yang tidak terjangkau, yaitu, dalam arti, itu adalah kebalikan dari labirin anyaman.  Konsep serupa dapat diterapkan ketika menambahkan dinding, sehingga Anda bisa mendapatkan labirin yang tidak rata dengan lorong dan kamar yang luas. </li><li>  <b>Parsial Wicker:</b> Sebagian Wicker Maze adalah labirin campuran yang memiliki kedua loop dan jalan buntu.  Kata "anyaman" dapat digunakan untuk penilaian kuantitatif, yaitu, "labirin dengan tenunan yang kuat" adalah labirin dengan banyak loop atau dinding dihilangkan, dan hanya ada beberapa di "labirin dengan tenun lemah". </li></ul><br>  <b>Tekstur:</b> klasifikasi <b>tekstur</b> menjelaskan gaya lintasan dengan rute dan geometri yang berbeda.  Tekstur bukan hanya parameter yang bisa dihidupkan atau dimatikan.  Berikut ini beberapa contoh variabel: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Bias</b> <b>:</b> dalam labirin dengan lorong-lorong yang bergeser, lorong lurus cenderung lebih ke satu arah daripada di yang lain.  Misalnya, dalam labirin dengan perpindahan horisontal yang tinggi, kita akan memiliki lorong panjang dari kiri ke kanan, dan hanya lorong pendek dari atas ke bawah yang menghubungkannya.  Labirin seperti itu biasanya lebih sulit untuk dilewati “melintasi serat”. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Overflight</b> <b>:</b> Metrik <b>Overflight</b> menentukan berapa lama lorong akan diperlukan sebelum belokan paksa muncul.  Dalam labirin dengan rentang rendah, tidak akan ada bagian lurus lebih lama dari tiga atau empat sel, dan itu akan terlihat sangat acak.  Dalam labirin dengan rentang tinggi, labirin akan memiliki persentase lintasan panjang yang besar, yang akan membuatnya terlihat seperti microchip. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elitisme:</b> indikator "elit" dari labirin menentukan panjang solusi relatif terhadap ukuran labirin.  Labirin elit biasanya memiliki solusi langsung yang pendek, sedangkan di labirin non-elit, solusi melewati sebagian besar area labirin.  Labirin elit berkualitas tinggi bisa jauh lebih rumit daripada labirin non-elit. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Simetri</b> <b>:</b> labirin simetris memiliki bagian simetris, misalnya, dalam simetri rotasi relatif ke pusat, atau tercermin sepanjang sumbu horizontal atau vertikal.  Labirin dapat sebagian atau seluruhnya simetris, dan dapat mengulangi polanya beberapa kali. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogenitas:</b> algoritma homogen menghasilkan semua labirin yang memungkinkan dengan probabilitas yang sama.  Labirin dapat disebut memiliki tekstur homogen jika terlihat seperti labirin khas yang dihasilkan oleh algoritma homogen.  Algoritma heterogen secara teoritis juga dapat menghasilkan semua labirin yang memungkinkan di ruang apa pun, tetapi tidak dengan probabilitas yang sama.  Heterogenitas dapat melangkah lebih jauh - mungkin ada labirin yang tidak akan pernah dihasilkan oleh algoritma. </li><li>  <b>Aliran Sungai: Karakteristik</b> "aliran" berarti bahwa ketika membuat labirin, algoritme akan mencari dan membersihkan sel-sel tetangga (atau dinding) ke sel saat ini, yaitu, ia akan mengalir (maka istilah "fluiditas") ke bagian labirin yang masih belum dibuat, seperti air.  Dalam labirin ideal dengan laju aliran yang lebih rendah, biasanya akan ada banyak jalan buntu pendek, dan dalam labirin lebih "cair" akan ada lebih sedikit jalan buntu, tetapi mereka akan lebih lama. </li></ul><br>  <b>Prioritas:</b> klasifikasi ini menunjukkan bahwa proses pembuatan labirin dapat dibagi menjadi dua jenis utama: menambahkan dinding dan lorong ukiran.  Biasanya, ketika membuat ini, hanya turun ke perbedaan dalam algoritma, dan tidak untuk perbedaan yang nyata dalam labirin, tetapi masih berguna untuk mempertimbangkan ini.  Labirin yang sama sering dihasilkan dalam dua cara: <br><br><ul><li>  <b>Menambah dinding:</b> Algoritma di mana dinding menjadi prioritas dimulai dengan area kosong (atau perbatasan eksternal), menambahkan dinding dalam proses.  Di dunia nyata, labirin nyata yang terdiri dari pagar, langit-langit atau dinding kayu jelas menambah dinding. </li><li>  <b>Pemotongan gang:</b> Algoritma yang prioritasnya adalah gang mulai dengan blok padat dan memotong bagian di dalamnya dalam proses.  Di dunia nyata, labirin seperti itu adalah terowongan tambang atau labirin di dalam pipa. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Templat:</b> tentu saja, labirin dapat secara bersamaan memotong lorong dan menambahkan dinding;  beberapa algoritma komputer melakukan itu.  Templat labirin adalah gambar grafik yang bukan labirin, yang dalam beberapa langkah berubah menjadi labirin nyata, tetapi masih mempertahankan tekstur templat grafik asli.  Gaya labirin yang kompleks, seperti berpotongan spiral, lebih mudah diimplementasikan sebagai pola di komputer, daripada mencoba membuat labirin yang tepat sambil mempertahankan gayanya. </li></ul><br>  <b>Lainnya: yang di</b> atas tidak berarti daftar lengkap dari semua kelas atau elemen yang mungkin dalam setiap kelas.  Ini hanya tipe-tipe labirin yang saya buat sendiri.  Perhatikan bahwa hampir setiap jenis labirin, termasuk labirin dengan aturan khusus, dapat dinyatakan sebagai grafik terarah, di mana akan ada jumlah negara hingga dan sejumlah pilihan hingga di setiap negara, dan ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>kesetaraan labirin</b></a> .  Berikut adalah beberapa klasifikasi dan jenis labirin lainnya: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientasi</b> <b>:</b> pada bagian-bagian tertentu Anda hanya dapat bergerak dalam satu arah.  Dari sudut pandang pemrograman, labirin seperti itu akan dijelaskan oleh grafik berarah, berbeda dengan grafik tidak berarah yang menggambarkan semua jenis lainnya. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentasi</b> <b>:</b> labirin dapat memiliki bagian yang berbeda sesuai dengan kelas yang berbeda. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labirin dengan panjang tak hingga:</b> kita dapat membuat labirin panjang tak terhingga (sejumlah kolom dan jumlah baris terbatas), tetapi pada saat yang sama menyimpan hanya satu bagian dari labirin dalam memori, "menggulir" dari satu ujung ke ujung lainnya dan menghancurkan garis sebelumnya ketika membuat yang berikutnya.  Salah satu contoh adalah versi modifikasi dari algoritma Hunt and Kill.  Orang bisa membayangkan labirin yang tak berujung berpotensi dalam bentuk film panjang yang terdiri dari frame individu.  Hanya dua frame berturut-turut yang disimpan dalam memori sekaligus.  Mari kita jalankan algoritma Hunt and Kill, meskipun itu menciptakan bias yang cenderung ke frame atas, jadi itu berakhir dulu.  Setelah selesai, bingkai tidak lagi diperlukan, Anda dapat mencetaknya atau melakukan hal lain dengannya.  Namun, buanglah, buat frame bawah yang baru dibuat sebagian menjadi frame atas baru dan kosongkan frame bawah yang baru.  Ulangi proses ini sampai kami memutuskan untuk berhenti, dan kemudian menunggu sampai Hunt And Kill menyelesaikan kedua frame.  Satu-satunya batasan adalah bahwa labirin tidak akan pernah memiliki jalan bercabang menuju pintu masuk untuk panjang lebih dari dua bingkai.  Cara termudah untuk membuat labirin tak berujung adalah algoritma Eller atau algoritma Sidewinder, karena mereka sudah membuat labirin satu baris pada satu waktu, sehingga Anda bisa membiarkan mereka menambahkan baris tanpa akhir ke labirin. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="gambar"><br><br></b>  <b>Virtual labirin fraktal:</b> virtual adalah labirin di mana seluruh labirin tidak disimpan dalam memori pada saat yang sama.  Misalnya, itu hanya dapat menyimpan bagian dari lorong 100x100 di dekat lokasi Anda dalam simulasi tempat Anda berjalan melalui labirin besar.  Perpanjangan labirin fraktal bersarang dapat digunakan untuk membuat labirin virtual yang sangat besar, misalnya, satu miliar per miliar lintasan.  Jika kita membuat salinan nyata labirin dari satu miliar per miliar lintasan (dengan jarak enam kaki di antara lintasan), maka itu akan memenuhi permukaan bumi lebih dari 6.000 kali!  Pertimbangkan sebuah labirin dengan 10 <sup>9</sup> hingga 10 <sup>9</sup> lintasan, atau sebuah labirin tertutup dengan hanya 9 tingkat.  Jika kita ingin memiliki setidaknya 100x100 bagian di sekitar kita, maka cukup bagi kita untuk membuat pada level terendah sub labirin 100x100 lintasan dan tujuh 10x10 labirin di mana ia tertanam untuk mengetahui dengan tepat di mana dinding berada di dalam bagian 100x100.  (Sebenarnya, lebih baik memiliki empat bagian yang berdekatan berukuran 100x100, membentuk bujur sangkar jika Anda berada di dekat tepi atau sudut bagian tersebut, tetapi konsep yang sama berlaku di sini.) Untuk memastikan labirin konstan dan tidak berubah ketika bergerak di sekitarnya, kami memiliki rumus, mendefinisikan nomor benih acak untuk setiap koordinat di setiap tingkat bersarang.  Labirin fraktal virtual mirip dengan fraktal Mandelbrot, dalam gambar yang memang ada, dan kita perlu mengunjungi koordinat tertentu dengan perbesaran yang cukup tinggi.  sehingga muncul. </li></ul><br><h2>  Algoritma Labirin </h2><br>  Berikut adalah daftar algoritma umum untuk membuat berbagai kelas labirin yang dijelaskan di atas: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> untuk membuat labirin ideal standar, biasanya perlu “menumbuhkannya”, memastikan tidak adanya loop dan area yang terisolasi.  Kami mulai dari dinding luar dan secara acak menambahkan fragmen dinding yang menyentuhnya.  Kami terus menambahkan segmen dinding secara acak ke labirin, tetapi pastikan bahwa setiap segmen baru menyentuh dari satu ujung dinding yang ada, dan ujung lainnya berada di bagian labirin yang masih belum dibuat.  Jika Anda menambahkan segmen dinding, kedua ujungnya dipisahkan dari sisa labirin, maka ini akan membuat dinding yang tidak terhubung dengan lingkaran di sekitarnya, dan jika Anda menambahkan segmen, kedua ujungnya menyentuh labirin, ini akan membuat area yang tidak terjangkau.  Ini adalah metode penambahan dinding;  hampir analog dengan memotong bagian-bagian, di mana bagian-bagian bagian dipotong sehingga hanya satu ujung yang menyentuh bagian yang ada. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -«», (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        —   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  «»        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     «»    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  —  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     —       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak cara untuk membuat labirin yang sempurna, dan masing-masing memiliki karakteristiknya sendiri. </font><font style="vertical-align: inherit;">Di bawah ini adalah daftar algoritma spesifik. </font><font style="vertical-align: inherit;">Semua dari mereka menggambarkan penciptaan labirin dengan memotong jalan, namun, kecuali dinyatakan sebaliknya, masing-masing juga dapat diimplementasikan dengan menambahkan dinding:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracker rekursif </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     «»   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Algoritma Prima (benar)</b> <b>:</b> Algoritma ini menciptakan pohon rentang minimum dengan memproses bobot tepi acak yang unik.  Jumlah memori yang dibutuhkan sebanding dengan ukuran labirin.  Kita mulai dari titik mana pun (labirin jadi akan sama, tidak peduli dari atas kita mulai).  Kami memilih tepi lorong dengan bobot terkecil yang menghubungkan labirin ke titik yang belum ada di dalamnya, dan kemudian menempelkannya ke labirin.  Labirin selesai ketika ujung-ujungnya tidak lagi tersisa.  Untuk memilih tepi berikutnya secara efisien, Anda memerlukan antrian prioritas (biasanya diimplementasikan menggunakan heap) yang menyimpan semua tepi perbatasan.  Namun, algoritma ini agak lambat karena butuh log (n) waktu untuk memilih item dari heap.  Oleh karena itu, lebih baik untuk memilih algoritma Kraskal, yang juga membuat pohon spanning minimal, karena lebih cepat dan menciptakan labirin dengan struktur yang identik.  Faktanya, dengan seed acak yang sama, algoritma Prima dan Kraskal dapat membuat labirin yang sama. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Algoritma Prim (Sederhana)</b> <b>:</b> Algoritma Prim ini membuat pohon spanning minimal.  Ini disederhanakan sedemikian rupa sehingga semua bobot tepi adalah sama.  Ini membutuhkan kapasitas memori sebanding dengan ukuran labirin.  Kami mulai dari puncak acak.  Kami secara acak memilih tepi lorong yang menghubungkan labirin dengan titik yang belum ada di dalamnya, dan kemudian menempelkannya ke labirin.  Labirin selesai ketika ujung-ujungnya tidak lagi tersisa.  Karena tepinya tidak berbobot dan tidak dipesan, maka dapat disimpan sebagai daftar sederhana, yaitu pemilihan elemen dari daftar akan sangat cepat dan membutuhkan waktu yang konstan.  Oleh karena itu, ini jauh lebih cepat daripada algoritma Prim sejati dengan bobot tepi acak.  Tekstur labirin yang dibuat akan memiliki indeks hasil lebih rendah dan solusi yang lebih sederhana daripada algoritma Prima yang sebenarnya, karena menyebar dari titik awal secara merata, seperti sirup yang tumpah, dan tidak mem-bypass fragmen tulang rusuk dengan bobot lebih tinggi, yang diperhitungkan kemudian. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Algoritma Prim (dimodifikasi)</b> <b>:</b> Algoritma Prim ini membuat pohon spanning minimal, dimodifikasi sehingga semua bobot tepi adalah sama.  Namun, ini diterapkan sedemikian rupa sehingga alih-alih tepi itu melihat sel.  Jumlah memori sebanding dengan ukuran labirin.  Dalam proses penciptaan, setiap sel dapat memiliki satu dari tiga jenis: (1) "internal": sel adalah bagian dari labirin dan sudah dipotong di dalamnya, (2) "batas": sel bukan bagian dari labirin dan belum dipotong di dalamnya, tetapi terletak di sebelah sel yang sudah "internal", dan (3) "eksternal": sel belum menjadi bagian dari labirin, dan tidak ada tetangganya yang juga sel "internal".  Kami mulai dengan memilih sel, menjadikannya "internal", dan untuk semua tetangganya kami menyetel jenisnya menjadi "batas".  Kami secara acak memilih sel "batas" dan memotong satu bagian dari salah satu sel "internal" di sekitarnya.  Kami mengubah status sel "batas" ini menjadi "internal" dan mengubah jenis semua tetangganya dari "eksternal" menjadi "perbatasan".  Labirin diselesaikan ketika tidak ada lagi sel "batas" yang tersisa (yaitu, tidak ada sel "eksternal" yang tersisa, yang berarti bahwa setiap orang telah menjadi "internal").  Algoritma ini menciptakan labirin dengan indeks hasil yang sangat rendah, memiliki banyak deadlock pendek dan solusi yang lebih mudah.  Labirin yang dihasilkan sangat mirip dengan hasil dari algoritma Prima yang disederhanakan, dengan sedikit perbedaan: void dalam spanning tree diisi hanya jika sel batas dipilih secara acak, berbeda dengan probabilitas tiga kali lipat untuk mengisi sel ini melalui salah satu sel batas yang mengarah ke sana.  Selain itu, algoritma ini sangat cepat, lebih cepat daripada algoritma Prim yang disederhanakan, karena tidak perlu mengkompilasi dan memproses daftar edge. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  Algoritma <b>Aldous-Broder</b> : apa yang menarik dalam algoritma ini adalah bahwa itu homogen, yaitu, ia menciptakan dengan probabilitas yang sama semua labirin yang mungkin dari ukuran yang diberikan.  Selain itu, tidak memerlukan memori atau tumpukan tambahan.  Kami memilih titik dan secara acak pindah ke sel tetangga.  Jika kita masuk ke sel yang belum dipotong, maka potong bagian dari sel sebelumnya ke dalamnya.  Kami terus bergerak ke sel tetangga sampai kami memotong bagian ke semua sel.  Algoritma ini menciptakan labirin dengan laju aliran rendah, hanya sedikit lebih tinggi dari algoritma Kraskal.  (Ini berarti bahwa untuk pertukaran yang diberikan, ada lebih banyak labirin dengan indeks hasil rendah daripada dengan yang tinggi, karena labirin dengan probabilitas rata-rata sama rendahnya.) Hal buruk tentang algoritma ini adalah sangat lambat karena tidak melakukan pencarian intelektual untuk yang terakhir. sel, yaitu, pada kenyataannya, tidak memiliki jaminan penyelesaian.  Namun, karena kesederhanaannya, ia dapat dengan cepat melewati banyak sel, sehingga selesai lebih cepat dari yang Anda kira.  Rata-rata, dibutuhkan tujuh kali lebih lama untuk menyelesaikan daripada algoritma standar, meskipun dalam kasus yang buruk bisa lebih lama jika generator angka acak terus-menerus menghindari beberapa sel terakhir.  Ini dapat diimplementasikan sebagai dinding tambahan, jika dinding perbatasan dianggap sebagai simpul tunggal, mis., Misalnya, jika memindahkan kita ke dinding perbatasan, kita akan berteleportasi ke titik acak di sepanjang perbatasan, dan hanya kemudian terus bergerak.  Dalam hal penambahan dinding, ia bekerja hampir dua kali lebih cepat, karena teleportasi di sepanjang dinding perbatasan memungkinkan akses yang lebih cepat ke bagian-bagian labirin yang jauh. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Algoritma Wilson</b> <b>:</b> ini adalah versi perbaikan dari algoritma Aldous-Broder, ini menciptakan labirin dengan tekstur yang persis sama (algoritmanya homogen, artinya, semua labirin yang mungkin dihasilkan dengan probabilitas yang sama), tetapi algoritma Wilson jauh lebih cepat.  Perlu memori hingga ukuran labirin.  Kami mulai dengan sel labirin awal yang dipilih secara acak.  Kami memilih sel acak yang belum menjadi bagian dari labirin dan melakukan jalan acak hingga kami menemukan sel yang sudah dimiliki labirin.  Segera setelah kita menemukan bagian labirin yang telah dibuat, kita kembali ke sel acak yang dipilih dan memotong seluruh jalur yang dilakukan dengan menambahkan sel-sel ini ke labirin.  Lebih khusus lagi, ketika kita kembali di sepanjang jalan, kita memotong di setiap sel ke arah di mana berjalan acak terjadi terakhir kali kita meninggalkan sel.  Ini menghindari tampilan loop di sepanjang jalan kembali, sehingga satu bagian panjang bergabung dengan labirin.  Labirin selesai ketika semua sel melekat padanya.  Algoritme memiliki masalah kecepatan yang sama dengan Aldous-Broder, karena dapat memakan waktu lama untuk menemukan jalur acak pertama ke sel awal, tetapi setelah menempatkan beberapa jalur, sisa labirin dipotong cukup cepat.  Rata-rata, ini berjalan lima kali lebih cepat dari Aldous-Broder, dan kurang dari dua kali lebih lambat dari algoritma terbaik.  Perlu dipertimbangkan bahwa dalam kasus penambahan dinding, ia bekerja dua kali lebih cepat, karena seluruh dinding perbatasan awalnya merupakan bagian dari labirin, sehingga dinding pertama bergabung lebih cepat. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  Algoritma <b>berburu dan membunuh</b> <b>:</b> algoritma ini mudah digunakan karena tidak memerlukan memori tambahan atau tumpukan, dan karenanya cocok untuk membuat labirin besar atau labirin pada komputer yang lemah karena ketidakmungkinan kehabisan memori.  Karena tidak memiliki aturan yang harus diikuti terus-menerus, ia juga paling mudah untuk memodifikasi dan membuat labirin dengan tekstur berbeda yang menggunakannya.  Ini hampir mirip dengan backtracker rekursif, hanya saja tidak ada sel yang tidak dibuat di dekat posisi saat ini.  Kami memasuki mode "berburu" dan memindai labirin secara sistematis hingga kami menemukan sel yang belum dibuat di sebelah sel yang sudah dipotong.  Pada tahap ini, kami kembali mulai memotong di lokasi baru ini.  Labirin selesai ketika dalam mode "berburu" semua sel dipindai.  Algoritma ini cenderung membuat labirin dengan laju aliran tinggi, tetapi tidak setinggi backtracker rekursif.  Anda dapat memaksanya untuk menghasilkan labirin dengan laju aliran yang lebih rendah, lebih sering memasuki mode "berburu".  Ini berjalan lebih lambat karena waktu yang dihabiskan untuk berburu sel terakhir, tetapi tidak jauh lebih lambat daripada algoritma Kraskal.  Ini dapat diimplementasikan sesuai dengan prinsip menambahkan dinding, jika Anda sesekali teleport secara acak untuk menghindari masalah yang melekat pada backtracker rekursif. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Algoritma yang berkembang</b> <b><br></b>  <b>tree (Growing tree algorithm)</b> <b>:</b> ini adalah algoritma umum yang dapat membuat labirin dengan tekstur yang berbeda.  Memori yang dibutuhkan dapat mencapai ukuran labirin.  Setiap kali sel dipotong, kami menambahkannya ke daftar.  Pilih sel dari daftar dan potong bagian ke sel yang tidak dibuat di sebelahnya.  Jika tidak ada sel yang belum dibuat di dekat yang sekarang, hapus sel saat ini dari daftar.  Labirin selesai ketika tidak ada yang lain dalam daftar.  Hal yang menarik tentang algoritme adalah bahwa, tergantung pada bagaimana Anda memilih sel dari daftar, Anda dapat membuat banyak tekstur yang berbeda.  Misalnya, jika Anda selalu memilih sel yang ditambahkan terakhir, maka algoritme ini berubah menjadi pelacak mundur rekursif.  Jika Anda selalu memilih sel secara acak, maka berperilaku serupa, tetapi tidak identik dengan algoritma Prim.  Jika Anda selalu memilih sel tertua yang ditambahkan ke daftar, maka kami akan membuat labirin dengan indeks hasil serendah mungkin, bahkan lebih rendah dari pada algoritma Prim.  Jika Anda biasanya memilih sel terakhir, tetapi sesekali memilih sel acak, maka labirin akan memiliki laju aliran tinggi, tetapi solusi singkat dan langsung.  Jika salah satu sel terbaru dipilih secara acak, labirin akan memiliki laju aliran rendah, tetapi solusi yang panjang dan berliku. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Algoritma hutan tumbuh</b> <b>:</b> Ini adalah algoritma yang lebih umum menggabungkan jenis berdasarkan pohon dan set.  Ini adalah perpanjangan dari algoritma pertumbuhan pohon, yang pada dasarnya mencakup beberapa contoh yang berkembang secara bersamaan.  Kami mulai dengan semua sel yang diurutkan secara acak ke dalam daftar "baru";  Selain itu, setiap sel memiliki set sendiri, seperti pada awal algoritma Kruskal.  Pertama, pilih satu atau lebih sel dengan memindahkannya dari daftar "baru" ke daftar "aktif".  Pilih sel dari daftar "aktif" dan hilangkan bagian ke sel yang tidak dibuat berikutnya dari daftar "baru", menambahkan sel baru ke daftar "aktif" dan menggabungkan set dua sel.  Jika suatu upaya dilakukan untuk memotong bagian labirin yang ada, maka aktifkan jika sel-sel berada di set yang berbeda dan menggabungkan sel-sel, seperti yang dilakukan dalam algoritma Kraskal.  Jika tidak ada sel "baru" di dekat sel saat ini, maka pindahkan sel saat ini ke daftar yang "selesai".  Labirin selesai ketika daftar "aktif" menjadi kosong.  Pada akhirnya, kami menggabungkan semua set yang tersisa, seperti pada algoritma Kruskal.  Secara berkala, Anda dapat membuat pohon baru dengan memindahkan satu atau lebih sel dari daftar "baru" ke daftar "aktif", seperti yang dilakukan di awal.  Dengan mengontrol jumlah pohon asli dan bagian dari pohon yang baru dibuat, Anda dapat menghasilkan banyak tekstur unik yang digabungkan dengan parameter yang sudah fleksibel dari algoritma penanaman pohon. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Algoritma Eller</b> <b>:</b> ini adalah algoritma khusus, karena tidak hanya lebih cepat dari yang lain, tetapi juga tidak memiliki bias atau kekurangan yang jelas;  selain itu, ketika dibuat, memori digunakan paling efisien.  Bahkan tidak mengharuskan seluruh labirin ada di memori, ia menggunakan volume yang proporsional dengan ukuran garis.  Ini menciptakan garis labirin demi baris, setelah generasi string selesai, algoritma tidak lagi memperhitungkannya.  Setiap sel dalam satu baris terkandung dalam satu set;  dua sel milik set yang sama jika ada jalur di antara mereka di sepanjang labirin yang sudah dibuat.  Informasi ini memungkinkan Anda untuk memotong bagian-bagian di jalur saat ini tanpa membuat loop atau area yang terisolasi.  Bahkan, ini sangat mirip dengan algoritma Kraskal, hanya di sini ia dibentuk satu baris pada satu waktu, sementara Kraskal melihat melalui seluruh labirin.  Membuat baris terdiri dari dua bagian: sambungkan sel yang berdekatan secara acak di dalam baris, mis.  kita memotong bagian horisontal, lalu secara acak menghubungkan sel-sel antara arus dan baris berikutnya, mis.  memotong bagian vertikal.  Saat memotong bagian horisontal, kita tidak menghubungkan sel yang sudah ada di set yang sama (karena loop akan dibuat sebaliknya), dan ketika memotong bagian vertikal kita harus menghubungkan sel jika memiliki ukuran satuan (karena jika Anda meninggalkannya, itu akan membuat area yang terisolasi).  Saat memotong bagian horisontal, kami menghubungkan sel jika mereka berada di set yang sama (karena sekarang ada jalur di antara mereka), dan ketika memotong bagian vertikal ketika kami tidak terhubung dengan sel, kami meletakkannya di set yang terpisah (karena sekarang dipisahkan dari sisa labirin) )  Penciptaan dimulai dengan fakta bahwa sebelum menghubungkan sel-sel di baris pertama, setiap sel memiliki set sendiri.  Pembuatan selesai setelah sel terhubung di baris terakhir.  Ada aturan khusus penyelesaian: pada saat selesai, masing-masing sel harus dalam set yang sama untuk menghindari daerah yang terisolasi.  (Baris terakhir dibuat dengan menggabungkan masing-masing pasangan sel tetangga yang belum dalam set yang sama.) Yang terbaik untuk mengimplementasikan set menggunakan daftar sel yang saling terkait secara siklik (yang bisa berupa array yang mengikat sel ke pasangan sel di kedua sisi set yang sama), memungkinkan melakukan penyisipan, penghapusan dan verifikasi keberadaan sel tetangga dalam satu set untuk waktu yang konstan.  Masalah dengan algoritma ini adalah ketidakseimbangan dalam memproses tepi yang berbeda dari labirin;  Untuk menghindari noda pada tekstur, Anda perlu menghubungkan dan melewati sel penghubung dalam proporsi yang benar. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Pembagian rekursif:</b> algoritma ini agak mirip dengan backtracking rekursif, karena mereka berdua menggunakan tumpukan, hanya bekerja tidak dengan lorong, tetapi dengan dinding.  Kita mulai dengan membuat dinding horizontal atau vertikal acak yang memotong area yang dapat diakses dalam baris atau kolom acak, dan secara acak menempatkan ruang kosong di sepanjang itu.  Kemudian kami mengulangi proses secara rekursif untuk dua subregional yang dihasilkan oleh dinding pemisah.  Untuk hasil terbaik, Anda perlu menambahkan penyimpangan dalam pilihan horizontal atau vertikal berdasarkan proporsi area, misalnya, area yang lebarnya dua kali tingginya harus lebih sering dibagi dengan dinding vertikal.  Ini adalah algoritme tercepat tanpa penyimpangan arah, dan seringkali dapat bersaing dengan labirin yang didasarkan pada pohon biner, karena ia menciptakan beberapa sel pada saat yang sama, meskipun ia memiliki kelemahan yang jelas dalam bentuk dinding panjang yang memotong interior labirin.  Algoritma ini adalah semacam labirin fraktal yang tertanam, tetapi alih-alih secara konstan membuat labirin sel dengan ukuran tetap dengan labirin dengan ukuran yang sama di dalam setiap sel, algoritma ini secara acak membagi area tertentu menjadi labirin ukuran acak: 1x2 atau 2x1.  Pembagian rekursif tidak dapat digunakan untuk memotong bagian-bagian, karena ini mengarah pada penciptaan solusi yang jelas yang mengikuti sepanjang tepi luar, atau sebaliknya langsung memotong bagian dalam. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labirin yang didasarkan pada pohon biner</b> <b>:</b> sebenarnya, ini adalah algoritma yang paling sederhana dan tercepat, namun, labirin yang dibuat memiliki tekstur dengan bias yang sangat tinggi.  Untuk setiap sel, kami memotong bagian baik ke atas atau ke kiri, tetapi tidak pernah di kedua arah.  Dalam versi dengan penambahan dinding, segmen dinding ditambahkan untuk setiap titik mengarah ke bawah atau ke kanan, tetapi tidak di kedua arah.  Setiap sel independen dari semua sel lain, karena kita tidak perlu memeriksa keadaan beberapa sel lain saat membuatnya.  Oleh karena itu, ini adalah algoritma nyata untuk menghasilkan labirin tanpa memori, tidak dibatasi oleh ukuran labirin yang dibuat.  Sebenarnya, ini adalah pohon biner, jika kita menganggap sudut kiri atas sebagai root, dan setiap simpul atau sel memiliki satu simpul induk unik, yang merupakan sel di atas atau di sebelah kiri darinya.  Labirin yang didasarkan pada pohon biner berbeda dari labirin ideal standar, karena lebih dari setengah jenis sel tidak dapat ada di dalamnya.  Sebagai contoh, tidak akan pernah ada persimpangan di dalamnya, dan semua jalan buntu memiliki bagian mengarah ke atas atau ke kiri, dan tidak pernah mengarah ke bawah atau ke kanan.  Labirin cenderung memiliki lorong-lorong yang mengarah secara diagonal dari kiri atas ke kanan bawah, dan jauh lebih mudah untuk bergerak dari kanan bawah ke kiri atas.  Anda selalu dapat bergerak ke atas atau ke kiri, tetapi tidak pernah secara bersamaan di kedua arah, sehingga Anda selalu dapat bergerak secara deterministik diagonal ke atas dan ke kiri, tanpa menemui hambatan.  Anda akan memiliki kesempatan untuk memilih dan jatuh ke jalan buntu dengan bergerak ke bawah dan ke kanan. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   «    ».   ,       sidewinder —      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b>% </b> </td><td> <b></b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b></b> </td><td> <b>% </b> </td></tr><tr><td>  </td><td> 0 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 379 </td><td> 100.0 </td></tr><tr><td> Recursive Backtracker </td><td>  10 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  27 </td><td> 19.0 </td></tr><tr><td> Hunt and Kill </td><td> 11 (21) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0 </td><td> 100 (143) </td><td> 9.5 (3.9) </td></tr><tr><td>   </td><td>  23 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  10 </td><td> 7.2 </td></tr><tr><td>   </td><td>  25 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td>  10 </td><td> 2.0 </td></tr><tr><td> Sidewinder </td><td>  27 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td>  12 </td><td> 2.6 </td></tr><tr><td>   </td><td>  28 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  20 </td><td> 4.2 (3.2) </td></tr><tr><td>   </td><td>  Tanggal 29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 (25) </td><td> 4.5 </td></tr><tr><td>  - </td><td>  Tanggal 29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0 </td><td> 279 (208) </td><td> 4.5 </td></tr><tr><td>   </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  33 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 160 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  32 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 59 </td><td> 2.3 </td></tr><tr><td>   () </td><td> 36 (31) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  30 </td><td> 2.3 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 </td><td> 11.0 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 76 </td><td> 11.0 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel ini merangkum karakteristik algoritma untuk membuat labirin ideal yang dijelaskan di atas. Sebagai perbandingan, algoritma labirin rute tunggal telah ditambahkan (secara teoritis, labirin rute tunggal ideal). Penjelasan kolom:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . «» ,    . «» ,            ,     . «» ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     «»  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak cara untuk mengatasi labirin, dan masing-masing memiliki karakteristik sendiri. </font><font style="vertical-align: inherit;">Berikut adalah daftar algoritma tertentu:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengikuti sepanjang dinding (Pengikut dinding) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        («»),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    «»    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   —  -1,    —  1.            ,      , ..     360   ,        «».  ,         «»,      ,        ,      ,      ,         .  ,             ,           .      ,    —    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      «»      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   «», ,     ,  «», ,       .  ,         ,    «»;    «»       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Trémaux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  —   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   —   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   «» ,          (      ),   «»  , ,     .      «»,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   «» ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    «» ,          (  ).   « »       (   ),       ,   .      «»,     ,       ,   ,     . ( ,    «»,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td> + </td><td>  </td><td>  </td><td>  </td><td>  </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backtracker rekursif </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamu adalah </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma Tremo </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamu adalah </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di dalam / di atas </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengisi buntu </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Labirin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berakhir </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengisi kul-de-sac </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Labirin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berakhir </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sealer lorong buta </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Labirin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengisi lorong buta </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Labirin </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berakhir </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemecah tabrakan </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua yang terpendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari jalur terpendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua yang terpendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cari jalur terpendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 terpendek </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel ini secara singkat mencantumkan karakteristik algoritma penyelesaian labirin yang dijelaskan di atas. </font><font style="vertical-align: inherit;">Menurut kriteria ini, dimungkinkan untuk mengklasifikasikan dan mengevaluasi algoritma untuk memecahkan labirin. </font><font style="vertical-align: inherit;">Penjelasan Kolom:</font></font><br><br><ul><li> <b>:</b>       ,   .        .  ,  ()       . Dead end filler  cul-de-sac filler (  blind alley sealer     )   ,      ,        ,      «+». </li><li> <b>:</b>        .  Random mouse  «»,      ,   wall follower     «»,       ,     .  dead end filler  cul-de-sac filler  «»,           . </li><li> <b>:</b>      :   «» (  )    .    ,       (   «»)    («+»)          .    ,          . </li><li> <b> :</b>        ,     ,     .   ,   «»,    ,    (  ),  ,   ,    ,     .            . </li><li> <b>  :</b>      .   ,       ,     ,     ,         . Wall follower,             . Recursive backtracker  shortest path(s) finder     . </li><li> <b>  :</b>         .                    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cepat:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah proses pengambilan keputusan dianggap cepat. </font><font style="vertical-align: inherit;">Algoritma yang paling efisien cukup untuk melihat setiap sel labirin hanya sekali, atau mereka dapat sepenuhnya melewati bagian-bagiannya. </font><font style="vertical-align: inherit;">Runtime harus proporsional dengan ukuran labirin, atau O (n ^ 2), di mana n adalah jumlah sel di satu sisi. </font><font style="vertical-align: inherit;">Mouse acak lambat karena penyelesaiannya tidak dijamin, dan pengisi jalan buntu berpotensi memecahkan labirin dari setiap garpu.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operasi lain dengan labirin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain membuat dan menyelesaikan labirin, Anda dapat melakukan operasi lain dengannya: </font></font><br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br> :</b>  «  »,      ,         Fill  FloodFill.  FloodFill   ,      ,     .  ,       ,  FloodFill  ,     .  ,      ,  FloodFill  ,      ,        .          «»    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br>    (Isolation remover):</b>    ,        ,        .   ,       .    ,     .   (   ,      )    ,    .         ,        ,      .         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br>  :</b>    ,            ,               .        ,      ,  .    ,    .   (   ,       )        .         ,    ,        ,     .                ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br> <b>  </b> <b>:</b>       ,       .   ,       ,    ,        ,    .  ,      ,   .       ,        .           ,    blind alley sealer (    ,            ).   ,    ,   . </li></ul><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>Daedalus</b></a> <b>:</b>           Daedalus,       Windows.    Daedalus    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445378/">https://habr.com/ru/post/id445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445362/index.html">Buku "Sistem Terdistribusi. Pola Desain</a></li>
<li><a href="../id445366/index.html">Cara mempercepat enkripsi menurut GOST 28147-89 pada prosesor Baikal-T1 karena blok SIMD</a></li>
<li><a href="../id445368/index.html">Muat pengujian game dengan beberapa ratus ribu pengguna virtual</a></li>
<li><a href="../id445370/index.html">Analisis TSDB di Prometheus 2</a></li>
<li><a href="../id445372/index.html">Visi mesin vs intuisi manusia: algoritma untuk mengganggu operasi program pengenalan objek</a></li>
<li><a href="../id445380/index.html">PHP modern itu indah dan produktif</a></li>
<li><a href="../id445384/index.html">Misi Chang'e-4 - peralatan ilmiah pada modul pendaratan dan satelit repeater</a></li>
<li><a href="../id445390/index.html">IDE orang normal atau mengapa kami memilih Monako</a></li>
<li><a href="../id445392/index.html">Pemasaran ulang dinamis MyTarget: rekomendasi produk non-pribadi</a></li>
<li><a href="../id445394/index.html">Perubahan protokol aman 3D: memenuhi 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>