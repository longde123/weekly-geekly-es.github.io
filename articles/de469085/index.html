<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌺 👴🏻 🐻 Wir nehmen die Software aus dem passwortgeschützten Mikrocontroller Renesas M16C heraus 👨🏾‍🔧 🙆🏾 🧑🏽‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe einen Freund, der sich mit der Reparatur von Autoeisen beschäftigt. Er brachte mir irgendwie einen Mikrocontroller, der von einer autonomen H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir nehmen die Software aus dem passwortgeschützten Mikrocontroller Renesas M16C heraus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469085/"><img src="https://habrastorage.org/webt/-f/lc/co/-flcco15l02rsp0smi3ha4ov224.jpeg"><br><br>  Ich habe einen Freund, der sich mit der Reparatur von Autoeisen beschäftigt.  Er brachte mir irgendwie einen Mikrocontroller, der von einer autonomen Heizungssteuereinheit gelötet wurde.  Er sagte, dass sein Programmierer es nicht nimmt, und er möchte in der Lage sein, Firmware hin und her zu übertragen, weil  Es gibt viele Blöcke, in Eisen sind sie oft gleich, aber die Einheiten, die sie steuern, sind unterschiedlich.  Und es scheint, dass es einen Block anstelle eines fehlerhaften gibt, aber die Software ist anders und Sie können ihn einfach nicht ersetzen.  Da die Aufgabe interessant war, beschloss ich, herumzustöbern.  Wenn das Thema für Sie interessant ist, bitte unter der Katze ... <a name="habracut"></a><br><br>  Betreff war M306N5FCTFP.  Dies ist ein Mikrocontroller der M16C / 6N5-Gruppe.  Der M16C / 60-Kern wurde von Mitsubishi und as entwickelt  Seit 2003 ist Renesas der Nachfolger dieses Unternehmens in Bezug auf MK. Jetzt sind diese Mikrocontroller unter dieser Marke bekannt. <br><br><h4>  Ein bisschen über den Mikrocontroller selbst </h4><br>  Der Kiesel ist ein 16-Bit-Mikrocontroller in einem 100-Pin-QFP-Gehäuse.  Der Kernel verfügt über 1 MB Adressraum, eine Taktfrequenz von 20 MHz für die Fahrzeugleistung.  Der Satz an Peripheriegeräten ist ebenfalls sehr umfangreich: Zwei 16-Bit-Timer und die Möglichkeit, eine 3-Phasen-PWM zur Steuerung von Motoren, alle Arten von UART, SPI, I2C natürlich, 2 DMA-Kanäle, einen eingebauten CAN2.0B-Controller sowie eine PLL zu erzeugen.  Meiner Meinung nach ist es sehr gut für den alten Mann.  Hier ist eine Übersichtstabelle aus der Dokumentation: <br><br><img src="https://habrastorage.org/webt/mb/we/0z/mbwe0zgfqxwxd2ihcirztjtepqg.png"><br><br>  Da es meine Aufgabe ist, die Software herauszureißen, interessiert sie sich auch sehr für das Gedächtnis.  Dieser MK wurde in zwei Versionen hergestellt: maskiert und Flash.  Ich habe, wie oben erwähnt, den M306N5FCTFP bekommen.  Über ihn sagt die Beschreibung Folgendes: <br><br><ul><li>  Flash-Speicherversion </li><li>  128 KByte + 4K (zusätzliche 4K - der sogenannte Block A als Geschenk an den Benutzer zum Speichern von Daten, kann aber auch das Programm speichern) </li><li>  V-ver.  (Automobilversion mit einem Bereich von + 125 ° C) </li></ul><br><h4>  Wie man vom Gerät zieht, was Entwickler gezogen haben </h4><br>  Es ist nur natürlich, dass Sie versuchen sollten, etwas aus dem Mikrocontroller herauszuholen, indem Sie die Mechanismen untersuchen, die der Chipentwickler für Speicherprogrammierungsaufgaben integriert.  Das Handbuch besagt, dass der Hersteller freundlicherweise einen Bootloader für die Anforderungen der In-Circuit-Programmierung des Geräts in den Speicher gestellt hat. <br><br><img src="https://habrastorage.org/webt/q6/yq/ol/q6yqolkgde-5fd6fdcwm_y6skc8.png"><br><br>  Wie Sie auf dem Bild oben sehen können, ist der Speicher in zwei Teile unterteilt: den Benutzerbereich und den Bootloader-Bereich.  Im zweiten Schritt wird ab Werk ein Standard-Bootloader geladen, der den Benutzerspeicher schreiben, lesen, löschen und über eine asynchrone, synchrone oder CAN-Schnittstelle kommunizieren kann.  Es wird angezeigt, dass es nach Ihren Wünschen umgeschrieben werden kann oder nicht.  Am Ende lässt sich dies leicht überprüfen, indem versucht wird, den Standard-Bootloader zumindest über UART anzuklopfen ... Mit Blick auf die Zukunft: Der Hersteller der Heizung hat sich nicht um seinen Bootloader gekümmert, sodass Sie weiter in diese Richtung graben können.  Machen Sie sofort einen Vorbehalt, dass es noch eine parallele Programmiermethode gibt, aber seitdem  Ich hatte keinen Programmierer dafür, ich habe diese Option nicht in Betracht gezogen. <br><br>  Das Aufrufen des Bootloader-Betriebsmodus erfolgt durch eine bestimmte Kombination an den Eingängen CNVSS, P5_0, P5_5 während eines Hardware-Resets.  Schreiben Sie als Nächstes entweder Ihr eigenes Dienstprogramm, um den Inhalt des Speichers zu kopieren, oder verwenden Sie das fertige.  Renesas bietet ein eigenes Dienstprogramm namens "M16C Flash Starter", das jedoch über eine reduzierte Lesefunktion verfügt.  Es speichert nicht das, was es liest, auf der Festplatte, sondern vergleicht es mit einer Datei von der Festplatte.  Das heißt,  Dies ist in der Tat kein Lesen, sondern eine Überprüfung.  Es gibt jedoch ein deutsches kostenloses Dienstprogramm namens M16C-Flasher, das Firmware lesen kann.  Im Allgemeinen wurde das erste Toolkit abgeholt. <br><br><h4>  Informationen zum Leseschutz </h4><br><img src="https://habrastorage.org/webt/oe/zd/-l/oezd-l9m2zan5js3uwr0obomgta.png"><br><br>  Alles wäre ganz einfach, wenn der Bootloader keinen Schutz vor unbefugtem Zugriff bieten würde.  Ich werde nur eine sehr kostenlose Übersetzung aus dem Handbuch geben. <br><br>  <i>ID-Überprüfungsfunktion</i> <i><br><br></i>  <i>Wird im seriellen und CAN-Austauschmodus verwendet.</i>  <i>Die vom Programmierer übertragene Kennung wird mit der im Flash-Speicher aufgezeichneten Kennung verglichen.</i>  <i>Wenn die Bezeichner nicht übereinstimmen, werden vom Programmierer gesendete Befehle nicht akzeptiert.</i>  <i>Wenn jedoch 4 Bytes des Rücksetzvektors FFFFFFFFh sind, werden die Bezeichner nicht verglichen, sodass alle Befehle ausgeführt werden können.</i>  <i>Der Bezeichner besteht aus 7 Bytes, die beginnend mit dem ersten Byte nacheinander an den Adressen 0FFFDFh, 0FFFE3h, 0FFFEBh, 0FFFEFh, 0FFFF3h, 0FFFF7h und 0FFFFBh gespeichert werden.</i> <br><br>  Um auf das Programm zugreifen zu können, müssen Sie die geschätzten 7 Bytes kennen.  Mit Blick auf die Zukunft stellte ich erneut eine Verbindung zu MK mit demselben „M16C Flash Starter“ her und stellte sicher, dass Kombinationen aus Nullen und FF nicht funktionierten und dieses Problem irgendwie gelöst werden musste.  Hier tauchte sofort eine Idee mit einem Angriff über Kanäle von Drittanbietern auf.  Ich gab bereits vor, ein Kopftuch in meinem Kopf zu sein, mit dem ich den Strom im Stromkreis messen kann, entschied jedoch, dass das Internet groß ist und die meisten Fahrräder bereits erfunden wurden.  Nachdem ich einige Suchanfragen durchgeführt hatte, fand ich auf hackaday.io schnell das Projekt Serge 'q3k' Bazanski mit dem Titel „Reverse Engineering Toshiba R100 BIOS“.  Und im Rahmen dieses Projekts löste der Autor im Wesentlichen genau das gleiche Problem: das Extrahieren der Firmware aus MK M306K9FCLR.  Außerdem - zu diesem Zeitpunkt wurde die Aufgabe bereits erfolgreich von ihm gelöst.  Einerseits war ich ein wenig verärgert - ein interessantes Rätsel wurde von mir nicht gelöst.  Auf der anderen Seite verwandelte sich die Aufgabe von einer Suche nach Schwachstellen in eine Ausnutzung, die eine viel schnellere Lösung versprach. <br><br>  Kurz gesagt, q3k begann die Studie nach genau der gleichen Logik mit einer Analyse des aktuellen Verbrauchs, in dieser Hinsicht unter viel günstigeren Bedingungen, weil  Er hatte ChipWhisperer, ich habe dieses Ding immer noch nicht.  Aber seitdem  Seine erste Sonde, die den Verbrauchsstrom entfernte, erwies sich als unangemessen und er konnte nichts Nützliches vom Rauschen isolieren. Er beschloss, einen einfachen Angriff auf die Reaktionszeit zu versuchen.  Tatsache ist, dass der Bootloader während der Ausführung des Befehls die BUSY-Ausgabe abruft, um den Host darüber zu informieren, dass er beschäftigt ist oder bereit ist, den nächsten Befehl auszuführen.  Gemäß der Annahme von q3k könnte das Messen der Zeit von der Übertragung des letzten Bits des Bezeichners bis zum Entfernen des Besetztzeichens als Informationsquelle während der Aufzählung dienen.  Bei der Überprüfung dieser Annahme durch Aufzählung des ersten Bytes des Schlüssels wurde tatsächlich nur in einem Fall eine Zeitabweichung festgestellt - wenn das erste Byte gleich FFh war.  Zur Vereinfachung der Zeitmessung verlangsamte der Autor den MK sogar, indem er den Quarzresonator ausschaltete und eine 666-kHz-Rechteckwelle an den Takteingang anlegte, um den Messvorgang zu vereinfachen.  Danach wurde die Kennung erfolgreich ausgewählt und die Software abgerufen. <br><br><h4>  Der erste Pfannkuchen - ein Rechen </h4><br>  Ha!  Ich dachte ... Jetzt niete ich das Programm schnell an meinen STM32VLDiscovery c STM32F100 an Bord, der den Code sendet, die Reaktionszeit misst und die Messergebnisse im Terminal ausspuckt.  Weil  Das Steckbrett mit dem Zielcontroller war zuvor über den USB-UART-Adapter mit dem PC verbunden. Um nichts am Steckbrett zu ändern, arbeiten wir im asynchronen Modus. <br><br><img src="https://habrastorage.org/webt/4h/j0/ex/4hj0ext4dvwval--yospml-loso.png"><br><br>  Wenn beim Start des Bootloaders der Eingang CLK1 zu Boden gezogen wird, erkennt er, dass sie eine asynchrone Kommunikation von ihm wünschen.  Deshalb habe ich es benutzt - der Hosenträger war bereits gelötet und ich habe nur die beiden Platinen mit Drähten verbunden: Discovery und das Steckbrett mit dem Ziel M306. <br><br>  <i>Hinweis zur Harmonisierung der Ebenen:</i> <i><br><br></i>  <i>Weil</i>  <i>Da M16 über TTL-Pegel an den Terminals verfügt und STM32 über LVTTL (vereinfacht, Einzelheiten siehe Datenblatt), ist eine Pegelanpassung erforderlich.</i>  <i>Weil</i>  <i>Dies ist kein Gerät, das wie eine bekannte Batterie funktionieren, funktionieren und funktionieren sollte, aber tatsächlich wird es einmal auf dem Tisch angeschlossen, dann habe ich mich nicht um Pegelübersetzer gekümmert: die 5-Volt-MK-verdauten Ausgangspegel von STM32 im Sinne von 3 Volt, die es als "1" wahrnimmt. werden die Ausgänge von M16 den 5V-toleranten STM32-Eingängen zugeführt, damit es sich nicht schlecht anfühlt, und wir vergessen nicht, das Bein, das RESET M16 zieht, in den Open-Drain-Modus zu versetzen.</i>  <i>Ich habe es vergessen, und das sind + 2 Stunden bis zum Sparschwein der verlorenen Zeit.</i> <i><br></i>  <i>Dieses Minimum reicht aus, um die Drüsen des anderen zu verstehen.</i> <br><br>  Die Logik der angreifenden Software lautet wie folgt: <br><br><ol><li>  Wir stellen eine Verbindung mit dem Controller her.  Dazu müssen Sie warten, bis der Reset abgeschlossen ist, und dann 16 Nullzeichen mit einem Intervall von mehr als 20 ms übertragen.  Dies dient dazu, den Algorithmus zur automatischen Ermittlung des Wechselkurses zu erarbeiten, weil  Die Schnittstelle ist asynchron und MK weiß nichts über ihre Frequenz.  Die Startgeschwindigkeit des Senders sollte 9600 Baud betragen, bei dieser Geschwindigkeit berechnet der Lader.  Danach können Sie auf Wunsch einen anderen von fünf verfügbaren Wechselkursen im Bereich 9600-115200 anfordern (obwohl sich der Lader in meinem Fall geweigert hat, an 115200 zu arbeiten).  Ich muss die Geschwindigkeit nicht ändern, daher habe ich nur die Bootloader-Version angefordert, um die Synchronisation zu steuern.  Wir passieren FBh, der Lader antwortet mit einer Zeile wie „VER.1.01“. <br></li><li>  Wir senden den Befehl "entsperren", der die aktuelle Iteration des Schlüssels enthält, und messen die Zeit, bis das Besetztzeichen gelöscht wird. <br><img src="https://habrastorage.org/webt/wg/qh/ne/wgqhnehwy7ycyxmwenvyx0n2lwk.png"><br>  Der Befehl besteht aus F5h-Code, drei Bytes der Adresse, an der der Bezeichnerbereich beginnt (in meinem Fall 0FFFDFh für den M16C-Kernel), der Länge (07h) und dem Bezeichner selbst. <br></li><li>  Wir messen die Zeit zwischen der Übertragung des letzten Bits der Kennung und dem Entfernen des Besetztzeichens. <br></li><li>  Wir erhöhen das zu sortierende Schlüsselbyte (KEY1 in der Anfangsphase) und kehren zu Schritt 2 zurück, bis wir alle 255 Werte des aktuellen Bytes sortiert haben. <br></li><li>  Wir setzen die Statistiken auf das Terminal zurück (oder wir führen die Analyse „an Bord“ durch). <br></li></ol><br>  Um mit dem Ziel-MK zu kommunizieren, habe ich USART in STM32 zum Messen der Zeit verwendet - einen Timer im Input Capture-Modus.  Der Einfachheit halber habe ich nicht die Zeit zwischen dem letzten Bit des Schlüssels und dem Entfernen des Flags gemessen, sondern zwischen dem Beginn der Übertragung und dem Flag.  Der Grund war, dass sich das letzte Bit ändern konnte und im asynchronen Modus nichts an die Erfassungseingabe angehängt werden konnte.  Gleichzeitig ist UART Hardware und die Übertragungszeit ist grundsätzlich identisch und es sollten keine greifbaren Fehler auftreten. <br><br>  Infolgedessen waren die Ergebnisse für alle Werte identisch.  Völlig identisch.  Die Taktfrequenz des Timers betrug 24 MHz, die Zeitauflösung beträgt 41,6 ns.  Okay, ich habe versucht, das Ziel MK zu verlangsamen.  Nichts hat sich geändert.  Hier stellte sich in meinem Kopf die Frage: Was mache ich falsch, wie es Q3K getan hat?  Nach dem Vergleich wurde der Unterschied festgestellt: Es wird eine synchrone Austauschschnittstelle (SPI) verwendet, und ich bin asynchron (UART).  Und irgendwo hier machte ich auf den Moment aufmerksam, den ich am Anfang verpasst hatte.  Selbst in Schaltplänen für synchrone und asynchrone Bootloader-Modi wird die Bereitschaftsausgabe unterschiedlich benannt: <br><br><img src="https://habrastorage.org/webt/d0/js/gb/d0jsgbifm7vo1jgbypc70elfoqu.png"><br><br>  In synchron ist es "BUSY", in asynchron ist es "Monitor".  Wir sehen uns die Tabelle „Ausgabefunktionen im seriellen Standard-E / A-Modus“ an: <br><br><img src="https://habrastorage.org/webt/ja/qk/zh/jaqkzhx4dielaovn5d3n9gykcxo.png"><br>  <i>"Semyon Semenych ..."</i> <br><br>  Die Kleinigkeit, die zuerst übersehen wurde, brachte den falschen Ort.  Wenn dies im synchronen Modus genau das Bootloader-Besetzt-Flag ist, ist der asynchrone Modus (der im seriellen E / A-Modus 2) nur ein „Blinker“, um den Betrieb anzuzeigen.  Vielleicht im Allgemeinen das Hardware-Signal der Bereitschaft des Transceivers und damit die erstaunliche Genauigkeit seiner Anhebung. <br><br>  Im Allgemeinen löten wir den Widerstand am SCLK-Pin von Masse nach VCC, löten den Draht dort, haken alles an SPI und beginnen von vorne ... <br><br><h4>  Erfolg! </h4><br><img src="https://habrastorage.org/webt/qh/ce/l1/qhcel11fibxpkxoa8zibgerddgc.png"><br><br>  Im synchronen Modus ist fast alles gleich, es ist nur kein vorläufiges Verfahren zum Herstellen einer Verbindung erforderlich, die Synchronisation wird vereinfacht und die Zeiterfassung kann genauer durchgeführt werden.  Wenn ich diesen Modus sofort wählen würde, würde ich Zeit sparen ... Ich habe die Zeit vom letzten Bit an nicht kompliziert und gemessen, sondern den Timer gestartet, bevor die Übertragung des letzten Bytes des Schlüssels gestartet wurde, d. H.  Wir schalten den Timer ein und senden ihn an den KEY7-Sender (im obigen Screenshot sehen Sie vom Logikanalysator aus den Abstand zwischen den Cursorn. Dies ist das gemessene Zeitintervall). <br><br>  Dies war mehr als genug für eine erfolgreiche Identifizierung.  Hier ist die Aufzählung eines Bytes: <br><br><img src="https://habrastorage.org/webt/dz/zx/l_/dzzxl_-wct4qfyr0gqpmuaqlos8.png"><br><br>  Auf der x-Achse haben wir die Anzahl der diskreten Zählungen, auf der y-Achse jeweils den übertragenen Schlüsselwert.  Das Signal-Rausch-Verhältnis ist so, dass auch keine Filter erforderlich sind, wie in der Schule in einer Informatikstunde: Wir finden das Maximum im Array und gehen zur Auswahl des nächsten Bytes.  Die ersten 6 Bytes werden einfach und schnell ausgewählt, etwas schwieriger mit den letzten: Da es nur dreistes Busting ist, das nicht funktioniert, müssen Sie das "Opfer" vor jedem Versuch zurücksetzen.  Infolgedessen dauert jeder Versuch ungefähr 400 ms, und die Suche erfolgt im schlimmsten Fall im Bereich von eineinhalb Minuten.  Aber das ist das Schlimmste.  Nach jedem Versuch fordern wir einen Status an und hören auf, sobald wir vermuten.  Zuerst ging ich im Allgemeinen nur schnell mit Stiften über die Kennung, fügte die Konsolenausgabe in Excel ein und zeichnete das Diagramm, umso mehr, als es eine einmalige Aufgabe war, aber für den Artikel entschied ich mich, eine automatische Iteration hinzuzufügen, um einer schönen Konsole willen ... <br><br><img src="https://habrastorage.org/webt/pd/dj/en/pddjenvq4joplvadcxy3lpd9gu0.png"><br><br>  Wenn der Entwickler den Bootloader löschen würde (durch seinen eigenen ersetzt), wäre es natürlich nicht so einfach, herauszukommen, aber in der Automobilelektronik sind MKs oft überhaupt nicht geschlossen.  Insbesondere in der Steuereinheit einer anderen Heizung, in der der V850 desselben Renesas installiert war, wurde alles durch Löten eines Kabelpaares und Kopieren der Firmware mit einem Standarddienstprogramm entschieden.  Dies ist die gesamte Kryptowährungs-Engine in der ECU-Welt.  Anscheinend mögen die Hersteller das Phänomen des Chip-Tunings und anderer Arten von Interferenzen nicht ... Obwohl dies wie ein Rennen aus Rüstungen und Granaten ist - die Drüsen sind steiler, teurer, aber es gibt keinen Gewinner ... <br><br>  Referenzen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.dataman.com/media/datasheet/Renesas/M16C6N5Group.pdf</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://hackaday.io/project/723-reverse-engineering-toshiba-r100-bios/log/51302-ec-firmware-dumped</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://q3k.org/slides-recon-2018.pdf</a> <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469085/">https://habr.com/ru/post/de469085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469071/index.html">Künstliche Intelligenz Microsoft beherrschte Mahjong</a></li>
<li><a href="../de469073/index.html">Diskrete Ableitung oder Zusammenfassung der Summenreihen</a></li>
<li><a href="../de469075/index.html">Grokay DLR</a></li>
<li><a href="../de469077/index.html">Microsofts neuer Python-Kurs [auf Englisch]</a></li>
<li><a href="../de469079/index.html">Python in Visual Studio Code: September-Erweiterungsupdate</a></li>
<li><a href="../de469087/index.html">MVCC in PostgreSQL-2. Gabeln, Dateien, Seiten</a></li>
<li><a href="../de469093/index.html">Vergleich weniger populärer und nicht sehr CLI-Bibliotheken: Cliff, Plac, Plumbum und andere (Teil 2)</a></li>
<li><a href="../de469095/index.html">ML.NET- und Model Builder-Updates veröffentlicht: Was ist neu?</a></li>
<li><a href="../de469097/index.html">CentOS 8 Webserver mit PHP7, Node.js und Redis</a></li>
<li><a href="../de469099/index.html">Testaufgaben beim Interview des Entwicklers - macht das Sinn?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>