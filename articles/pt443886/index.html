<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦‍👦 👩🏿‍🌾 📐 Resolvendo uma tarefa de uma entrevista do Google sobre JavaScript: 4 maneiras diferentes 〰️ 💇🏾 🌼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando eu estava estudando o desempenho de algoritmos, me deparei com este vídeo da falsa entrevista do Google . Ele não apenas fornece uma idéia de c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolvendo uma tarefa de uma entrevista do Google sobre JavaScript: 4 maneiras diferentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/443886/"><img src="https://habrastorage.org/getpro/habr/post_images/83f/a6b/8bb/83fa6b8bb04adab1ec1067682d5a2fd1.jpg"><br><br>  Quando eu estava estudando o desempenho de algoritmos, me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este vídeo da falsa entrevista do Google</a> .  Ele não apenas fornece uma idéia de como as entrevistas são realizadas em grandes empresas de tecnologia, mas também permite que você entenda como os problemas algorítmicos são resolvidos e com mais eficiência. <br><br>  Este artigo é um tipo de acompanhamento para o vídeo.  Nele, faço comentários sobre todas as soluções mostradas, além da minha própria versão da solução em JavaScript.  As nuances de cada algoritmo também são discutidas. <br><a name="habracut"></a><br><blockquote>  <b>Lembramos que:</b> <i>para todos os leitores de "Habr" - um desconto de 10.000 rublos ao se inscrever em qualquer curso Skillbox usando o código promocional "Habr".</i> <br><br>  <b>A Skillbox recomenda:</b> Curso prático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Mobile Developer PRO"</a> . <br></blockquote><br><h3>  Declaração do problema </h3><br>  Nos é dado um array ordenado e um valor específico.  Em seguida, eles pedem para criar uma função que retorne verdadeiro ou falso, dependendo se a soma de quaisquer dois números da matriz pode ser igual ao valor fornecido. <br><br>  Em outras palavras, existem dois números inteiros xey na matriz que, quando adicionados, são iguais ao valor especificado? <br><br>  <b>Exemplo A</b> <br><br>  Se nos foi dado um array [1, 2, 4, 9] e um valor de 8, a função retornará false, porque nenhum número da matriz pode dar 8 no total. <br><br>  <b>Exemplo B</b> <br><br>  Mas se for uma matriz [1, 2, 4, 4] e o valor for 8, a função retornará true, porque 4 + 4 = 8. <br><br>  <b>Solução 1. Bruteforce</b> <br><br>  <i>Dificuldade temporal: O (N²).</i> <i><br></i>  <i>Complexidade espacial: O (1).</i> <br><br>  O significado mais óbvio é usar um par de loops aninhados. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; arr.length; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i !== j &amp;&amp; arr[i] + arr[j] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  Essa solução não pode ser considerada eficaz, pois verifica todas as somas possíveis de dois elementos na matriz e também compara cada par de índices duas vezes.  (Por exemplo, quando i = 1 ej = 2 - na verdade, é o mesmo que comparar com i = 2 ej = 1, mas nesta solução tentamos as duas opções). <br><br>  Como nossa solução usa um par de aninhados para loops, ela é quadrática com uma complexidade de tempo de O (N²). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/aMLOyb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Solução 2. Pesquisa binária (binária)</b> <br><br>  <i>Dificuldade temporal: O (Nlog (N)).</i> <i><br></i>  <i>Complexidade espacial: O (1)</i> . <br><br>  Como as matrizes são ordenadas, podemos procurar uma solução usando a pesquisa binária.  Este é o algoritmo mais eficiente para matrizes ordenadas.  A própria pesquisa binária possui um tempo de execução O (log (N)).  No entanto, você ainda precisa usar um loop for para verificar cada elemento em relação a todos os outros valores. <br><br>  Aqui está a aparência da solução.  Para esclarecer tudo, usamos uma função separada para controlar a pesquisa binária.  Assim como a função removeIndex (), que retorna a versão da matriz menos o índice especificado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (binarySearch(removeIndex(arr, i), val - arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> removeIndex = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, i).concat(arr.slice(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, arr.length)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> binarySearch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(arr.length / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; arr[pivot]) { end = pivot - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; arr[pivot]) { start = pivot + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; pivot = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((start + end) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[pivot] === val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  O algoritmo começa no índice [0].  Em seguida, ele cria uma versão da matriz, excluindo o primeiro índice, e usa uma pesquisa binária para verificar se algum dos valores restantes pode ser adicionado à matriz para obter a quantidade desejada.  Esta ação é executada uma vez para cada elemento na matriz. <br><br>  O loop for em si terá uma complexidade de tempo linear de O (N), mas dentro do loop for realizamos uma pesquisa binária, que fornece a complexidade de tempo total de O (Nlog (N)).  Esta solução é melhor que a anterior, mas ainda há algo a melhorar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/MxEYdB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Solução 3. Tempo linear</b> <br><br>  <i>Dificuldade temporal: O (N).</i> <i><br></i>  <i>Complexidade espacial: O (1).</i> <br><br>  Agora vamos resolver o problema, lembrando que a matriz está classificada.  A solução é pegar dois números: um no começo e outro no final.  Se o resultado for diferente do necessário, alteramos os pontos inicial e final. <br><br>  No final, atingimos o valor desejado e retornamos true, ou os pontos inicial e final convergem e retornam false. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = arr.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = arr[start] + arr[end]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &gt; val) { end -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &lt; val) { start += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/jJGERY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Agora está tudo bem, a solução parece ser ótima.  Mas quem garantirá que a matriz foi encomendada? <br><br><h3>  O que então? </h3><br>  À primeira vista, poderíamos apenas classificar a matriz primeiro e depois usar a solução acima.  Mas como isso afetará o tempo de execução? <br><br>  O melhor algoritmo é a classificação rápida com complexidade de tempo O (Nlog (N)).  Se o usarmos em nossa solução ideal, ele mudará seu desempenho de O (N) para O (Nlog (N)).  É possível encontrar uma solução linear com uma matriz não ordenada? <br><br>  <b>Decisão 4</b> <br><br>  <i>Dificuldade temporal: O (N).</i> <i><br></i>  <i>Complexidade espacial: O (N).</i> <br><br>  Sim, existe uma solução linear, para isso você precisa criar uma nova matriz contendo uma lista de correspondências que estamos procurando.  A desvantagem aqui é o uso mais ativo da memória: esta é a única solução no artigo com complexidade espacial superior a O (1). <br><br>  Se o primeiro valor dessa matriz for 1 e o valor da pesquisa for 8, podemos adicionar o valor 7 à matriz dos "valores da pesquisa". <br><br>  Depois, processando cada elemento da matriz, podemos verificar a matriz dos "valores de pesquisa" e ver se um deles é igual ao nosso valor.  Se sim, retorne verdadeiro. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> findSum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, val</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchValues = [val - arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; arr.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> searchVal = val - arr[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchValues.includes(arr[i])) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchValues.push(searchVal); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; };</code> </pre> <br>  A base da solução é o loop for, que, como vimos acima, possui complexidade de tempo linear O (N). <br><br>  A segunda parte da iteração de nossa função é Array.prototype.include (), um método JavaScript que retornará verdadeiro ou falso, dependendo de a matriz conter o valor especificado. <br><br>  Para descobrir a complexidade de tempo de Array.prototype.includes (), podemos examinar o polyfill fornecido pelo MDN (e escrito em JavaScript) ou usar um método no código-fonte de um mecanismo JavaScript como o Google V8 (C ++). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// https://tc39.github.io/ecma262/#sec-array.prototype.includes if (!Array.prototype.includes) { Object.defineProperty(Array.prototype, 'includes', { value: function(valueToFind, fromIndex) { if (this == null) { throw new TypeError('"this" is null or not defined'); } // 1. Let O be ? ToObject(this value). var o = Object(this); // 2. Let len be ? ToLength(? Get(O, "length")). var len = o.length &gt;&gt;&gt; 0; // 3. If len is 0, return false. if (len === 0) { return false; } // 4. Let n be ? ToInteger(fromIndex). // (If fromIndex is undefined, this step produces the value 0.) var n = fromIndex | 0; // 5. If n ≥ 0, then // a. Let k be n. // 6. Else n &lt; 0, // a. Let k be len + n. // b. If k &lt; 0, let k be 0. var k = Math.max(n &gt;= 0 ? n : len - Math.abs(n), 0); function sameValueZero(x, y) { return x === y || (typeof x === 'number' &amp;&amp; typeof y === 'number' &amp;&amp; isNaN(x) &amp;&amp; isNaN(y)); } // 7. Repeat, while k &lt; len while (k &lt; len) { // a. Let elementK be the result of ? Get(O, ! ToString(k)). // b. If SameValueZero(valueToFind, elementK) is true, return true. if (sameValueZero(o[k], valueToFind)) { return true; } // c. Increase k by 1. k++; } // 8. Return false return false; } }); }</span></span></code> </pre> <br>  Aqui, a parte iterativa de Array.prototype.include () é o loop while na etapa 7, que (quase) atravessa todo o comprimento da matriz especificada.  Isso significa que sua complexidade temporal também é linear.  Bem, como está sempre um passo atrás da nossa matriz principal, a complexidade do tempo é O (N + (N - 1)).  Usando a notação O grande, simplificamos para O (N) - porque é N que tem a maior influência com o aumento do tamanho da entrada. <br><br>  Quanto à complexidade espacial, é necessária uma matriz adicional, cujo comprimento reflete a matriz original (menos uma, sim, mas isso pode ser ignorado), o que leva à complexidade espacial de O (N).  Bem, o aumento do uso de memória garante a máxima eficiência do algoritmo. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/vPeYqb" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Espero que este artigo seja útil para você como anexo de uma entrevista em vídeo.  Isso mostra que um problema simples pode ser resolvido de várias maneiras diferentes, com diferentes quantidades de recursos utilizados (tempo, memória). <br><br><blockquote>  <b>A Skillbox recomenda:</b> <br><br><ul><li>  Curso online de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Python Data Analyst</a> aplicado. <br></li><li>  Curso on-line <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Profissão frontend-developer"</a> . </li><li>  Curso anual prático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"PHP-developer from 0 to PRO"</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443886/">https://habr.com/ru/post/pt443886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443874/index.html">Comparação de estruturas de aprendizado profundo: TensorFlow, PyTorch, Keras, MXNet, Microsoft Cognitive Toolkit, Caffe, etc.</a></li>
<li><a href="../pt443876/index.html">Estamos desenvolvendo um bot Telegram para rastrear filmes no NodeJS e TypeScript</a></li>
<li><a href="../pt443878/index.html">DEV Labs 2019. Python para resolver tarefas não triviais. Mitap Online</a></li>
<li><a href="../pt443882/index.html">MOSDROID # 15 Phosphorus: video performance</a></li>
<li><a href="../pt443884/index.html">3 qualidades-chave de um gerente de produto de sucesso: Anton Danilov</a></li>
<li><a href="../pt443894/index.html">O quarto nível do multi-universo de Max Tegmark</a></li>
<li><a href="../pt443896/index.html">Dívida técnica como tetris</a></li>
<li><a href="../pt443898/index.html">Pregos na tampa do caixão de Runet</a></li>
<li><a href="../pt443900/index.html">Como medimos a qualidade e a eficácia do desenvolvimento da documentação. Antecedentes e princípios. Relatório Yandex</a></li>
<li><a href="../pt443902/index.html">Como vencemos o hackathon interno aprendendo skibidi, uso do fio dental e javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>