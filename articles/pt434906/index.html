<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 👩‍👩‍👧 📩 Testes em C ++ sem macros e memória dinâmica 🖐🏾 🐁 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitas bibliotecas populares para teste, por exemplo, Google Test, Catch2, Boost.Test, estão fortemente ligadas ao uso de macros; portanto, como um ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes em C ++ sem macros e memória dinâmica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434906/"><p> Muitas bibliotecas populares para teste, por exemplo, Google Test, Catch2, Boost.Test, estão fortemente ligadas ao uso de macros; portanto, como um exemplo de testes nessas bibliotecas, você geralmente vê uma imagem como esta: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  As macros em C ++ são cautelosas, por que elas são tão prósperas nas bibliotecas para criar testes? </p><a name="habracut"></a><br><p>  A biblioteca de teste de unidade deve fornecer aos usuários uma maneira de escrever testes para que o tempo de execução do teste possa encontrá-los e executá-los de alguma forma.  Quando você pensa em como fazer isso, o uso de macros parece ser mais fácil.  A macro TEST () geralmente define de alguma forma uma função (no caso do Google Test, a macro também cria uma classe) e garante que o endereço dessa função chegue a algum contêiner global. </p><br><p>  A conhecida biblioteca na qual a abordagem sem uma única macro é implementada é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tut</a> .  Vamos ver o exemplo dela no tutorial: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  A ideia subjacente é bastante interessante e funciona, não é muito difícil.  Em resumo, você tem uma classe base que implementa uma função de modelo que envolve parametrização com um número inteiro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Agora, quando você escreve esse teste: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Na verdade, você cria uma especialização de método de teste para um número específico N = 1 (é exatamente isso que o <code>template&lt;&gt;template&lt;&gt;</code> representa).  Ao chamar <code>test&lt;N&gt;()</code> o tempo de execução do teste pode entender se foi um teste real ou se um stub está olhando para o valor <code>called_method_was_a_dummy_test_</code> após a execução do teste. </p><br><p>  Em seguida, quando você declara um grupo de teste: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Primeiro, você enumera todo o <code>test&lt;N&gt;</code> para uma determinada constante conectada à biblioteca e, em segundo lugar, por efeito colateral, adiciona informações sobre o grupo ao contêiner global (nome do grupo e endereços de todas as funções de teste). </p><br><p>  Exceções são usadas como condições de teste no tut, portanto, a função <code>tut::ensure_equals()</code> simplesmente lançará uma exceção se os dois valores passados ​​a ela não forem iguais e o ambiente de execução de teste capturar uma exceção e considerar o teste como falhado.  Eu gosto dessa abordagem, fica imediatamente claro para qualquer desenvolvedor de C ++ onde essas asserções podem ser usadas.  Por exemplo, se meu teste criou um encadeamento auxiliar, é inútil colocar afirmações lá, ninguém as capturará.  Além disso, está claro para mim que meu teste deve poder liberar recursos no caso de uma exceção, como se fosse um código comum de exceção para segurança. </p><br><p>  Em princípio, a biblioteca tut-framework parece muito boa, mas existem algumas desvantagens em sua implementação.  Por exemplo, para o meu caso, eu gostaria que o teste tivesse não apenas um número, mas também outros atributos, em particular o nome, bem como o "tamanho" do teste (por exemplo, é um teste de integração ou um teste de unidade).  Isso pode ser resolvido dentro da estrutura do tut API, e até algo já existe, e algo pode ser realizado se você adicionar um método à API da biblioteca e chamá-lo para o corpo do teste para definir qualquer um de seus parâmetros: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Outro problema é que o ambiente de execução de teste tut não sabe nada sobre um evento como o início de um teste.  O ambiente executa o <code>object::test&lt;N&gt;()</code> e não sabe antecipadamente se o teste foi implementado para um determinado N ou se é apenas um esboço.  Ela só <code>called_method_was_a_dummy_test_</code> quando o teste termina, analisando o valor <code>called_method_was_a_dummy_test_</code> .  Esse recurso não se mostra muito bem nos sistemas de CI, capazes de agrupar a saída que o programa produziu entre o início e o final do teste. </p><br><p>  No entanto, na minha opinião, a principal coisa que pode ser aprimorada (uma "falha fatal") é a presença de código auxiliar extra necessário para escrever testes.  Há muitas coisas no tutorial tut-framework: é proposto primeiro criar uma certa classe de <code>struct basic{}</code> e descrever os testes como métodos do objeto associado a isso.  Nesta classe, você pode definir os métodos e dados que deseja usar no grupo de teste, e o construtor e o destruidor enquadram a execução do teste, criando algo como um dispositivo elétrico da jUnit.  Na minha prática com tut, esse objeto está quase sempre vazio, mas arrasta-se por um certo número de linhas de código. </p><br><p>  Então, vamos à oficina de bicicletas e tentamos organizar a ideia na forma de uma pequena biblioteca. </p><br><p>  É assim que o arquivo de teste mínimo se parece na biblioteca testada: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  Além da falta de macros, o bônus é a ausência do uso de memória dinâmica dentro da biblioteca. </p><br><h3 id="opredelenie-test-keysov">  Definição de casos de teste </h3><br><p>  Para o registro de testes, a magia elementar do nível de entrada é usada com o mesmo princípio de tut.  Em algum lugar no testing.h existe uma função padrão deste tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Os casos de teste escritos pelos usuários da biblioteca são simplesmente especializações desse método.  A função é declarada estática, ou seja,  em cada unidade de tradução, criamos especializações que não se cruzam por nome durante a vinculação. </p><br><p>  Existe uma regra que primeiro você precisa chamar <code>StartCase()</code> , para a qual você pode passar coisas como o nome do teste e talvez outras que ainda estejam em desenvolvimento. </p><br><p>  Quando um teste chama <code>runtime-&gt;StartTest()</code> , coisas interessantes podem acontecer.  Primeiro, se os testes estiverem agora no modo de execução, você poderá dizer em algum lugar que o teste iniciou a execução.  Em segundo lugar, se houver um modo de coletar informações sobre os testes disponíveis, o <code>StartTest()</code> lançará um tipo especial de exceção, o que significa que o teste é real e não um esboço. </p><br><h3 id="registraciya">  Registo </h3><br><p>  Em algum momento, você precisa coletar os endereços de todos os casos de teste e colocá-los em algum lugar.  Nos testados, isso é feito usando grupos.  O construtor da classe testing :: Group faz isso como um efeito colateral: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  O construtor cria um grupo com o nome especificado e adiciona a todos os <code>Case&lt;N&gt;</code> que encontra na unidade de tradução atual.  Acontece que em uma unidade de tradução você não pode ter dois grupos.  Isso também significa que você não pode dividir um grupo em várias unidades de tradução. </p><br><p>  O parâmetro do modelo é quantos casos de teste procurar na unidade de tradução atual para o grupo criado. </p><br><h3 id="linkovka">  Link </h3><br><p>  No exemplo acima, a criação do objeto testing :: Group () ocorre dentro da função que devemos chamar de nosso aplicativo para registrar os testes: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  Uma função nem sempre é necessária; às vezes você pode simplesmente declarar um objeto da classe <code>tested::Group</code> dentro de um arquivo.  No entanto, minha experiência é que o vinculador às vezes "otimiza" o arquivo inteiro se ele estiver montado dentro da biblioteca e nenhum aplicativo principal usa caracteres desse arquivo cpp: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  Quando o calc_test.cpp não está vinculado da fonte run_test.exe, o vinculador simplesmente remove completamente esse arquivo da consideração, juntamente com a criação de um objeto estático, apesar de ter os efeitos colaterais de que precisamos. </p><br><p>  Se essa cadeia resultar de run_test.exe, o objeto estático aparecerá no arquivo executável.  E não importa exatamente como isso é feito, como no exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  ou mais: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  A primeira opção, na minha opinião, é melhor porque o construtor é chamado após o início de main () e o aplicativo tem algum controle sobre esse processo. </p><br><p>  Eu acho que essa configuração de muletas é necessária para qualquer biblioteca de teste de unidade que use variáveis ​​globais e efeitos colaterais do construtor para criar um banco de dados de teste.  No entanto, provavelmente isso pode ser evitado vinculando a biblioteca de teste à chave --whole-archive (um analógico no MSVC apareceu apenas no Visual Studio 2015.3). </p><br><h3 id="makrosy">  Macros </h3><br><p>  Prometi que não haverá macros, mas é - <code>CASE_COUNTER</code> .  A opção de trabalho é que ele seja usado por <code>__COUNTER__</code> , uma macro que o compilador incrementa em um cada vez que é usado dentro da unidade de conversão. <br>  Suportado por GCC, CLANG, MSVC, mas não o padrão.  Se isso é frustrante, aqui estão algumas alternativas: </p><br><ul><li>  use os números 0, 1, 2 </li><li>  use o padrão <code>__LINE__</code> . </li><li>  use constexpr magic do nível 80.  Você pode procurar por "contador de constexpr" e tentar encontrar o compilador no qual ele funcionará. </li></ul><br><p>  O problema com <code>__LINE__</code> é que o uso de números grandes nas opções do modelo cria um tamanho de arquivo executável grande.  É por isso que limitei o tipo do padrão de caractere assinado a 128 como o número máximo de testes no grupo. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  Falha na memória dinâmica </h3><br><p>  Aconteceu que, ao registrar testes, você não pode usar a memória dinâmica, que eu usei.  É possível que seu ambiente não tenha memória dinâmica ou você use a procura de vazamentos de memória em casos de teste, portanto, a intervenção do ambiente de execução de teste não é o que você precisa.  O Google Test está lutando com isso. Aqui está um trecho: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  E nós simplesmente não podemos criar dificuldades. </p><br><p>  Como, então, obtemos uma lista de testes?  Esses são internos mais técnicos, que são mais fáceis de ver no código-fonte, mas eu vou lhe dizer assim mesmo. </p><br><p>  Ao criar um grupo, sua classe receberá um ponteiro para a função <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , que coletará todos os testes de unidade de conversão em uma lista.  Veja como funciona: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  Acontece que em cada unidade de conversão são criadas muitas variáveis ​​estáticas do tipo CaseListEntry CaseCollector \ :: s_caseListEntry, que são elementos da lista de testes, e o método collect () coleta esses elementos em uma lista conectada individualmente.  Aproximadamente da mesma maneira, a lista forma grupos de testes, mas sem padrões e recursão. <br></p><br><h3 id="struktura">  Estrutura </h3><br><p>  Os testes precisam de uma ligação diferente, como saída para o console em letras vermelhas. Falha, criando relatórios de teste em um formato compreensível para CI ou GUI, no qual você pode ver a lista de testes e executar os selecionados - em geral, muitas coisas.  Eu tenho uma visão de como isso pode ser feito, o que é diferente do que vi anteriormente na biblioteca de testes.  A reivindicação é principalmente para bibliotecas que se autodenominam "somente cabeçalho", incluindo uma grande quantidade de código, que não é essencialmente para arquivos de cabeçalho. </p><br><p>  A abordagem que eu assumo é que dividimos a biblioteca em front-end - isso é testado.he as próprias bibliotecas de back-end.  Para escrever testes, você só precisa de testing.h, que agora é C ++ 17 (devido ao std :: std :: string_view), mas supõe-se que haverá C ++ 98.  Tested.h, na verdade, realiza o registro e pesquisa de testes, uma opção de inicialização minimamente conveniente, bem como a capacidade de exportar testes (grupos, endereços de funções de caso de teste).  As bibliotecas de back-end que ainda não existem podem fazer o que precisam em termos de saída de resultados e inicialização usando a funcionalidade de exportação.  Da mesma forma, você pode adaptar o lançamento às necessidades do seu projeto. </p><br><h3 id="itog">  Sumário </h3><br><p>  A biblioteca testada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código do github</a> ) ainda precisa de alguma estabilização.  Em um futuro próximo, adicione a capacidade de executar testes assíncronos (necessários para testes de integração no WebAssembly) e indicar o tamanho dos testes.  Na minha opinião, a biblioteca ainda não está pronta para o uso em produção, mas de repente passei muito tempo e o estágio parou, respire fundo e peça feedback à comunidade.  Você estaria interessado em usar esse tipo de biblioteca?  Talvez haja outras idéias no arsenal de C ++, pois seria possível criar uma biblioteca sem macros?  Essa afirmação do problema é interessante? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434906/">https://habr.com/ru/post/pt434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434892/index.html">Código de desenho no Swift, PaintCode</a></li>
<li><a href="../pt434894/index.html">A arte do xamanismo ou firmware personalizado para o Olinuxino. Parte 1</a></li>
<li><a href="../pt434896/index.html">Consumer Electronics Hall of Fame: As histórias dos melhores gadgets dos últimos 50 anos, Parte 1</a></li>
<li><a href="../pt434898/index.html">Grasp2Vec: aprendendo a representar objetos por meio da captura de autoaprendizagem</a></li>
<li><a href="../pt434902/index.html">Criando um gerador de consultas personalizado no Spring Data Neo4j (parte 1)</a></li>
<li><a href="../pt434908/index.html">Educação para programadores - O quê? Onde Quando?</a></li>
<li><a href="../pt434912/index.html">O estoque anual da Porsche Taycan já está reservado, principalmente pelos proprietários da Tesla</a></li>
<li><a href="../pt434924/index.html">O que ler sobre organização de locais de trabalho, coworking e design de espaços para trabalho remoto</a></li>
<li><a href="../pt434928/index.html">Métodos de aplicação e distorção de precisão em jogos. Gráficos visuais para comparação</a></li>
<li><a href="../pt434930/index.html">Anúncio em vídeo hoje: deve ter um negócio bem-sucedido</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>