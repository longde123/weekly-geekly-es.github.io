<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 🚟 👨🏼‍🍳 HomeKit und ioBroker Lass uns zu Hause Freunde finden 🥉 🦁 📂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ohne Zweifel bleibt Apple iOS eines der beliebtesten mobilen Betriebssysteme, was bedeutet, dass moderne Automatisierungssysteme in der Lage sein müss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HomeKit und ioBroker Lass uns zu Hause Freunde finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iobroker/blog/433798/"><p><img src="https://habrastorage.org/webt/r6/5c/kp/r65ckpg2b-xatrgqefbyo7lflxa.png"></p><br><p>  Ohne Zweifel bleibt Apple iOS eines der beliebtesten mobilen Betriebssysteme, was bedeutet, dass moderne Automatisierungssysteme in der Lage sein müssen, sich in dieses Ökosystem zu integrieren und die Fähigkeit zur Interaktion bereitzustellen.  Genau dafür wurde das Homekit-Framework entwickelt, mit dem Sie mit intelligenten Geräten vom iPhone / iPad / iWatch-Bildschirm und in jüngerer Zeit vom Mac (macOS Mojave) aus arbeiten können. </p><br><p>  Die meisten Automatisierungssysteme (ich mag den Marketingnamen "Smart Home" nicht) enthalten seit langem Module für die Integration in Homekit, aber selbst ein geschulter Benutzer kann nicht immer nur herausfinden, wie sein Gerät in der Home- (oder Eve-) Anwendung verfügbar gemacht werden kann. </p><br><p>  Heute werde ich Ihnen erklären, wie diese Manipulationen im ioBroker-System durchgeführt werden (dies ist ein offenes und freies Automatisierungssystem).  Aber um nicht dumm all die vielen Beispiele für Geräte zu nennen, möchte ich einige Prinzipien erklären und Ansätze aufzeigen, wobei ich weiß, welche Sie andere Beispiele leicht implementieren können. </p><br><p>  <em>"Die Kenntnis einiger Prinzipien gleicht leicht die Unkenntnis einiger Fakten aus."</em> <em><br></em>  <em>Claude Adrian Helvetius</em> </p><a name="habracut"></a><br><h3 id="iobroker-drayvery-ustroystva-i-sostoyaniya">  ioBroker.  Treiber, Geräte und Status </h3><br><p>  Zunächst möchte ich erklären, was ein Gerät im ioBroker-System ist und wie es dargestellt wird. </p><br><p>  Ich möchte Sie daran erinnern, dass das ioBroker-System modular aufgebaut ist und die Erweiterungsmodule als Treiber (oder Adapter) bezeichnet werden.  Ein Treiber ist ein Integrationsmodul mit einem Gerät oder einer Gruppe von Geräten, die durch eine gemeinsame Funktionalität, ein gemeinsames Protokoll oder einen gemeinsamen Hersteller verbunden sind, und kann daher ein oder mehrere Geräte in das ioBroker-System "ziehen".  Eine weitere Funktion ist die Möglichkeit, mehrere Instanzen desselben Treibers zu erstellen, die sich in den Einstellungen unterscheiden. </p><br><p>  Aber jedes Gerät ist einzigartig und unnachahmlich, hat unterschiedliche Eigenschaften und Fähigkeiten.  Auf dieser Grundlage konzentriert sich ioBroker in erster Linie nicht auf das Gerät selbst, sondern auf seine Eigenschaften, die durch Zustände dargestellt werden.  <strong>Ein Status</strong> ist ein internes ioBroker-Objekt, das einen Wert akzeptiert und speichert.  Synonyme des Staates können berücksichtigt werden: Zeichen, Attribute, Eigenschaften, Eigenschaften, Ereignisse.  Beispiele für Bedingungen: "Temperatur", "Helligkeitsstufe", "Batteriestand", "Einschaltflag", "Fehlerflag", "Druckflag", "Doppelpressflag" usw.  Somit wird jedes Gerät durch viele verschiedene Zustände dargestellt. </p><br><p><img src="https://habrastorage.org/webt/oc/mn/q_/ocmnq_d-zdyhjj7bflfxaa3dxb8.png" alt="Objektstruktur" title="Objektstruktur"></p><br><p>  Zustände können in informative Zustände unterteilt werden - sie zeigen Informationen vom Gerät an und veränderbare - sie können vom Benutzer oder Skript geändert und diese Änderungen an das Gerät gesendet werden.  Wenn sich auf dem Gerät etwas ändert - diese Daten werden in den Status angezeigt und wenn sich der Status von ioBroker ändert (vom Benutzer oder vom Skript) -, erhält das Gerät ein Signal über die Änderung und muss entsprechend reagieren (dies hängt vom Gerät selbst und dem Treiber ab funktioniert). </p><br><p>  Alle Gerätezustände werden in einem einzigen Baum (Registrierung) von Zuständen zusammengefasst.  Sie werden zuerst nach Gerät (in einigen Fällen wird immer noch Channeling verwendet) und dann nach Treiberinstanzen gruppiert. </p><br><p>  Das Konzept der MQTT-Protokollthemen passt problemlos in einen solchen Statusbaum.  Auf diese Weise können Sie zusätzliche Geräte oder Systeme von Drittanbietern anschließen, die das MQTT-Protokoll unterstützen.  Es reicht aus, den MQTT-Treiber zu installieren - der entsprechende Zweig wird im Statusbaum angezeigt. </p><br><p>  Und es gibt alle Arten von Online-Diensten, die nützliche Informationen liefern und / oder die Steuerung anderer Geräte (z. B. Autoalarme) ermöglichen.  Das Ergebnis der Interaktion mit diesen Diensten wird auch als eine Reihe von Zuständen dargestellt. </p><br><p><img src="https://habrastorage.org/webt/xi/qk/ay/xiqkay8bgotkcb7qjhouj5-zln4.png" alt="Staatsbaum" title="Staatsbaum"></p><br><p>  Insgesamt scheint ein Gerät in ioBroker eine Reihe von Zuständen zu sein, die das Gerät charakterisieren und die Interaktion mit ihm ermöglichen. </p><br><h3 id="homekit-aksessuary-servisy-i-harakteristiki">  Homekit  Zubehör, Dienstleistungen und Spezifikationen </h3><br><p>  Wenden Sie sich nun an Homekit.  Hier wird die Klassifizierung von Geräten, deren Funktionalität und Eigenschaften angewendet. </p><br><p><img src="https://habrastorage.org/webt/xk/ch/8m/xkch8mdj6gv4zxw5g-kapazvuyy.png" alt="Homekit-Gerätekategorien" title="Homekit-Gerätekategorien"></p><br><p>  <strong>Zubehör</strong> entspricht einem physischen Gerät.  Das Zubehör verfügt über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kategorie</a> , mit der es einer bestimmten Gruppe zugeordnet werden kann. </p><br><p>  <strong>Services</strong> entsprechen der Funktionalität eines Zubehörs.  Ein Zubehör kann mehrere Dienste haben. </p><br><p>  Die Dienste zeigen die Funktionen des Geräts an: Lampe, Batterie, Taste, Luftqualitätssensor, Tür, Luftfilter, Kamera. </p><br><p>  Es ist der Dienst, der die Anzeige, das Verhalten des Geräts und die Eigenschaften bestimmt. </p><br><p>  <strong>Merkmal</strong> ist das Äquivalent der Attribute / Eigenschaften, die einen Dienst charakterisieren.  Diese Eigenschaften bestimmen, ob das Gerät eingeschaltet ist, wie hell die Lampe ist oder wie oft die Taste gedrückt wird.  Ein einzelner Dienst kann viele Eigenschaften haben. </p><br><p><img src="https://habrastorage.org/webt/2f/rl/io/2frliotkqesh2zanlhpfiaskmaq.png" alt="Objektstruktur" title="Objektstruktur"></p><br><p>  Anwendungen, die mit Homekit arbeiten, lesen die Dienste und Eigenschaften von Zubehör und zeigen die Werte in den Eigenschaften über die Benutzeroberfläche an und können sie ändern.  Die geänderten Werte werden an die Homekit-Geräte gesendet, um sie anzuwenden, und von den Homekit-Geräten werden auch die Werte der Merkmale mit einigen Änderungen von der Seite des Geräts gesendet. </p><br><p>  Insgesamt scheint das Gerät in HomeKit ein Zubehör mit einer Reihe von Diensten und Funktionen zu sein. </p><br><h3 id="yahka-stykuem-koncepcii">  Yahka.  Wir schließen uns dem Konzept an </h3><br><p>  Für die Arbeit mit Homekit verwendet ioBroker den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yahka-</a> Treiber ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusätzliche Module</a> müssen vor der Installation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installiert werden</a> ) - ein Add-On zu einer bekannten Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/KhaosT/HAP-NodeJS</a> , das auch das beliebte HomeBridge-Projekt erstellt.  Diese Bibliothek dient zum Erstellen eines virtuellen Gateways / einer virtuellen Brücke, die eine Reihe virtueller Geräte in HomeKit bereitstellt.  Wenn Sie die virtuellen Geräte und Dienste entsprechend konfigurieren und die Werte der Merkmale festlegen, erhalten Sie das fertige Gerät in Homekit und der Home-Anwendung, und wir können Siri auch bitten, es zu verwalten. </p><br><p>  Der Yahka-Treiber dient lediglich zum Konfigurieren von Zubehör, zum Hinzufügen von Diensten und zum Anzeigen der Entsprechung von Merkmalen (HomeKit) und Status (ioBroker). </p><br><p>  Nach der Installation müssen Sie jedoch zuerst das Gateway konfigurieren und in die Home-Anwendung integrieren.  Nach der Konfiguration werden alle zum Gateway hinzugefügten Geräte automatisch zur Startseite hinzugefügt.  Geben Sie dazu "Gerätename" an (es ist wünschenswert, nur lateinische Buchstaben anzugeben) und merken Sie sich den PIN-Code (oder legen Sie Ihren eigenen fest). </p><br><p><img src="https://habrastorage.org/webt/mj/b9/lf/mjb9lfsfvknvbjjmec9x0nexnns.png" alt="Gateway-Setup" title="Gateway-Setup"></p><br><div class="spoiler">  <b class="spoiler_title">Wir gehen zur Home-Anwendung und fügen ein neues Zubehör hinzu.</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5k/m1/hr/5km1hrkrxh6whzmb8dn5zcvqtm4.png"><br><img src="https://habrastorage.org/webt/fo/p-/oz/fop-oz-o99nnegmciq7drkxjdyu.png"></p></div></div><br><p>  Kommen wir nun zu den Geräten.  Alles wäre in Ordnung, wenn die Status für das Gerät in ioBroker eindeutig mit den Diensten und Funktionen in HomeKit übereinstimmen würden.  Und es wäre noch besser, wenn die Werte in den Zuständen für die Werte der Merkmale geeignet wären.  Aber oft ist dies nicht der Fall, und Sie müssen sich ungewöhnliche Möglichkeiten zum Andocken einfallen lassen.  Ich werde im Folgenden auf einige davon eingehen, und Sie müssen alle anderen Optionen selbst implementieren, "im Bild und in der Ähnlichkeit". </p><br><p>  Der Einfachheit halber habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Dokument</a> mit der Übersetzung von Diensten und Typen sowie den möglichen Werten der Merkmale erstellt.  Alle verwendeten Typen und Dienste entsprechen der <a href="">HAP-NodeJS-Bibliothek</a> . </p><br><h3 id="datchik-temperatury">  Temperatursensor </h3><br>  Dies ist das einfachste Beispiel. Sie müssen lediglich einen Zustand haben, der den numerischen Wert der Temperatur enthält.  Es kann von überall bezogen werden: von Sensoren oder von Internetdiensten (Wetter). <br><p>  Sie müssen ein Gerät der Kategorie Sensor hinzufügen, dem Gerät den TemperatureSensor-Dienst hinzufügen und diesem Dienst einen Namen geben.  Es gibt 5 Merkmale in diesem Dienst, von denen das wichtigste für uns die aktuelle Temperatur ist. </p><br><p><img src="https://habrastorage.org/webt/xn/yr/k7/xnyrk7hwwcmtwhiy_kcbub-nlms.png" alt="Zubehör-Thermometer" title="Zubehör-Thermometer"></p><br><p><img src="https://habrastorage.org/webt/j4/bj/bn/j4bjbnuijam7qadtoq9r9eh16ns.png" alt="TemperatureSensor Service" title="TemperatureSensor Service"></p><br><p>  Es reicht aus, den Namen des Zustands anzugeben, der der Temperatur in der CurrentTemperature-Kennlinie entspricht. </p><br><p>  Fügen Sie hier auch den HumiditySensor-Feuchtigkeitsservice hinzu, und in Homekit wird ein separates Zubehörsymbol erstellt. </p><br><p><img src="https://habrastorage.org/webt/ag/na/90/agna90qhvaz84v3qutrvu4dltei.png" alt="HumiditySensor Service" title="HumiditySensor Service"></p><br><p>  Speichern und fertig.  Jetzt können Sie sich an Siri wenden und sie nach Temperatur und Luftfeuchtigkeit fragen. </p><br><p><img src="https://habrastorage.org/webt/s4/cx/kg/s4cxkg72-7ycfuaentktjrhpdjy.png"></p><br><div class="spoiler">  <b class="spoiler_title">Gespräch mit Siri</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/p9/tt/ffp9ttfpcj3_wcbt4ztgisnwxzi.png"><br><img src="https://habrastorage.org/webt/ax/7z/1i/ax7z1ioiynurem96c3gof_2gnha.png"></p></div></div><br><h3 id="batareyka">  Batterie </h3><br><p>  Ein weiterer einfacher Service.  Sein Trick ist, dass es zu fast jedem Zubehör hinzugefügt werden kann.  Fügen Sie den BatteryService-Dienst hinzu und geben Sie in der BatteryLevel-Kennlinie einen Zustand an, der den Prozentsatz der Batterieladung enthält.  Danach werden die Ladedaten in den zusätzlichen Daten zum Gerät angezeigt. </p><br><p><img src="https://habrastorage.org/webt/pd/4p/ib/pd4pibwilwjymthk2g30ldqneey.png" alt="BatteryService" title="Batterieservice"></p><br><p>  Sie können sofort das Vorzeichen "Low Charge" (Merkmal StatusLowBattery) setzen. Wenn der Wert des angegebenen Status gleich 1 ist, wird das entsprechende Symbol auf dem Gerätebild angezeigt. </p><br><p>  Aber was ist, wenn Sie keinen solchen Status haben, aber das Symbol für niedrigen Batteriestand sehen möchten?  Sie müssen diesen Status manuell oder mithilfe eines Skripts erstellen und den erstellten Status in den Merkmalen angeben. </p><br><p>  Jetzt bleibt nur noch die korrekte Einstellung des Wertes true in diesem Zustand.  Zu diesem Zweck verwenden wir ein Skript, das auf true gesetzt wird, wenn der Akku 30 Prozent erreicht. </p><br><pre><code class="javascript hljs">createState(<span class="hljs-string"><span class="hljs-string">""</span></span>); on({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"zigbee.0.00158d0001f41725.battery"</span></span>, <span class="hljs-attr"><span class="hljs-attr">change</span></span>: <span class="hljs-string"><span class="hljs-string">"ne"</span></span>}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj.state.val; setState(<span class="hljs-string"><span class="hljs-string">"javascript.0."</span></span>, (value &lt;= <span class="hljs-number"><span class="hljs-number">30</span></span>)); });</code> </pre> <br><p>  Nach dem ersten Durchlauf erstellt das Skript einen Status und kann in den Merkmalen ausgewählt werden. </p><br><p><img src="https://habrastorage.org/webt/tx/2z/6r/tx2z6r4deofbbram-k_muwaxut0.png"></p><br><p>  Dieses Zeichen wird auf den Bildern des Zubehörs angezeigt </p><br><p><img src="https://habrastorage.org/webt/9o/nu/it/9onuitzmxs8exjofr7cfkwtwrqi.png"></p><br><div class="spoiler">  <b class="spoiler_title">und Gerätedetails</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/fx/jg/av/fxjgavhu-spu27lskbzkmvb_dh8.png"></p></div></div><br><h3 id="lampy">  Lampen </h3><br><p>  Glühbirnen sind unterschiedlich - hell, warm, rot.  Es gibt 4 Fälle: </p><br><ul><li>  Einfach - durch Ein- und Ausschalten gesteuert </li><li>  Dimmbar - wird auch durch die Helligkeit gesteuert </li><li>  Mit der Temperatur - ist es möglich, die Temperatur des Glühens zu steuern </li><li>  Farbe - Sie können die Farbe des Lichts steuern </li></ul><br><p>  Für jeden dieser Fälle gibt es im Glühbirnen-Service ein entsprechendes Merkmal: </p><br><ul><li>  Ein - Ein / Aus </li><li>  Helligkeit - Helligkeitsstufe </li><li>  Farbton - Schatten </li><li>  Sättigung - Sättigung </li><li>  Farbtemperatur - Farbtemperatur </li></ul><br><p>  Im einfachen Fall geben wir in der Eigenschaft "Ein" den Zustand an, der für das Ein- und Ausschalten verantwortlich ist. </p><br><p><img src="https://habrastorage.org/webt/7p/2j/l2/7p2jl2cqi7q8rbw98d_ytedxwke.png"></p><br><p>  Wenn die Lampe dimmbar ist, geben wir zusätzlich den Status mit der Helligkeitsstufe an. </p><br><p><img src="https://habrastorage.org/webt/b6/da/n1/b6dan1fjltcn8sry8doex2hl6ck.png"></p><br><p>  Neben der Zuweisung korrekter Zustände ist es wichtig, das Intervall akzeptabler Werte zu beachten! </p><br><p>  Beispiel: In einigen Fällen kann der für die Lampenhelligkeit verantwortliche Status Werte von 0 bis 255 annehmen. In Homekit sind diese Werte jedoch auf ein Intervall von 0 bis 100 begrenzt. In diesem Fall können Sie die Konvertierungsfunktionen des Yahka-Treibers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwenden</a> .  Die Funktion "level255" konvertiert nur das Intervall der Werte 0..255 in das Intervall 0..100 (und umgekehrt). </p><br><p>  Die folgenden Schwierigkeiten können auftreten, wenn Ihre Lampe farbig ist, die verwendete Farbe jedoch RGB ist.  Es können entweder drei verschiedene Zustände oder eine Zahl (oder Zeichenfolge) sein.  In diesem Fall müssen Sie von einem RGB-Farbraum in einen anderen XYB-Raum (dieser Raum wird von HomeKit verwendet) oder in die XY-Ebene konvertieren. </p><br><p>  Dazu müssen Sie zwei neue Zustände (Farbton und Sättigung) erstellen, in die wir die Werte aus dem RGB-Zustand konvertieren und umgekehrt. </p><br><div class="spoiler">  <b class="spoiler_title">Das resultierende Skript für die Farbe ist</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       createState("Hue"); createState("Sat"); //      RGB- on({id: "Hue", ack: false, change: 'any'}, function (obj) {  var hue = parseInt(obj.state.val);  var sat = parseInt(getState('Sat').val);  var res = hsvToRgb(hue, sat, 100);  setRGB(parseInt(res[0]), parseInt(res[1]), parseInt(res[2])); }); //    RGB- function setRGB(r, g, b){  var val = ('00'+r.toString(16)).slice(-2)+('00'+g.toString(16)).slice(-2)+('00'+b.toString(16)).slice(-2);  // RGB-   setState('zigbee.0.00124b0014d016ab.color', val, false); } //   HSV   RGB function hsvToRgb(h, s, v) {  var r, g, b;  var i;  var f, p, q, t;   h = Math.max(0, Math.min(360, h));  s = Math.max(0, Math.min(100, s));  v = Math.max(0, Math.min(100, v));  s /= 100;  v /= 100;   if(s == 0) {      r = g = b = v;      return [          Math.round(r * 255),          Math.round(g * 255),          Math.round(b * 255)      ];  }   h /= 60;  i = Math.floor(h);  f = h - i;  p = v * (1 - s);  q = v * (1 - s * f);  t = v * (1 - s * (1 - f));   switch(i) {      case 0:          r = v;          g = t;          b = p;          break;       case 1:          r = q;          g = v;          b = p;          break;       case 2:          r = p;          g = v;          b = t;          break;       case 3:          r = p;          g = q;          b = v;          break;       case 4:          r = t;          g = p;          b = v;          break;       default: // case 5:          r = v;          g = p;          b = q;  }   return [      Math.round(r * 255),      Math.round(g * 255),      Math.round(b * 255)  ]; }</span></span></code> </pre> </div></div><br><p>  Die Farbtemperatur kann einfacher eingestellt werden. Wenn der Bereich der verfügbaren Werte für Ihre Lampe bekannt ist, kann er (über die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scaleInt</a> ) in das für HomeKit verfügbare Intervall konvertiert werden. </p><br><p><img src="https://habrastorage.org/webt/f0/vm/xh/f0vmxhpcndendf_efjf9xrmjxke.png" alt="Glühbirnen-Service" title="Glühbirnen-Service"></p><br><p><img src="https://habrastorage.org/webt/et/sp/fg/etspfg0idwn5v-cun2hh2y9xmm0.png"></p><br><div class="spoiler">  <b class="spoiler_title">Tiefer in der Lampe</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w_/q8/8p/w_q88pboeca8hl0fygtssrjegim.png"><br><img src="https://habrastorage.org/webt/bt/5c/bc/bt5cbc59jttu8ibjev1hfnnwkdm.png"></p></div></div><br><h3 id="termostat">  Thermostat </h3><br><p>  Thermostat - ein Gerät zur Aufrechterhaltung der eingestellten Temperatur (Thermostat-Service).  Dementsprechend ist das Hauptmerkmal des Thermostats die gewünschte Temperatur (TargetTemperature).  Zusätzlich zur eingestellten Temperatur kann die aktuelle Temperatur (CurrentTemperature) angezeigt werden, die informativer Natur ist (da das Gerät sie nur von den Sensoren liest). </p><br><p>  In der Home-Anwendung wird die Zieltemperatur im Thermostat eingestellt und die aktuelle Temperatur verfolgt.  In meinem Thermostat (Zont) gab es nur diese beiden Zustände - sie waren über die Service Cloud API verfügbar. </p><br><p>  Für die Schönheit der Anzeige des Geräts in HomeKit musste ich einige Konstanten hinzufügen: Der aktuelle Heizzustand ist aktiv (1), der Zielheizzustand ist automatisch (3). </p><br><p><img src="https://habrastorage.org/webt/vn/dd/ey/vnddeyypjlofn2jkxrqwe5ybwuw.png" alt="Thermostat-Service" title="Thermostat-Service"></p><br><p><img src="https://habrastorage.org/webt/pk/9u/k3/pk9uk3vfurepl1kfgow5lrp66dc.png"></p><br><div class="spoiler">  <b class="spoiler_title">Temperaturauswahl</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/_4/g8/co/_4g8coln1rlsodscr8sah8p_h9o.png"></p></div></div><br><h3 id="vorota">  Tore </h3><br><p>  Mit einem Garagentor (GarageDoorOpener-Service) ist alles schwieriger als mit einem Thermostat. </p><br><p>  Von den verfügbaren Eigenschaften hat das Gate einen Zielzustand (TargetDoorState), der unseren Wunsch anzeigt, dass das Gate "offen" oder "geschlossen" ist.  Sie müssen aber auch den aktuellen Status des Gates (CurrentDoorState) korrekt anzeigen: Sind sie geöffnet oder geschlossen oder öffnen oder schließen sie sich? </p><br><p>  In meinem Fall wurden die Tore über mqtt in ioBroker mit mehreren Informationszuständen geöffnet: </p><br><ul><li>  Zeichen der Toroffenheit (OB) </li><li>  Zeichen der Bewegung des Tores (LW) </li></ul><br><p><img src="https://habrastorage.org/webt/aw/b3/ip/awb3ipo5vz8qrn8jawhcfunuouc.png" alt="Garagentor-Kontrollzustände" title="Garagentor-Kontrollzustände"></p><br><p>  Dank dieser Zustände können Sie den aktuellen Status des Tors berechnen: </p><br><ul><li>  Wenn es keinen OB und keinen DV gibt, werden die Tore geschlossen </li><li>  Wenn es keinen OB und einen DV gibt, öffnen sich die Tore </li><li>  Wenn es einen OB und keinen DV gibt, sind die Tore offen </li><li>  Wenn es OB und DV gibt, schließt sich das Tor </li></ul><br><p>  Um ein Signal zum Öffnen und Schließen des Gates zu senden, habe ich zwei separate Zustände (es wäre möglich, mit einem Zustand zu verwalten, aber ich habe zwei), die eine Nachricht über mqtt an den Gate-Steuercontroller senden: </p><br><ul><li>  Eröffnungssignal </li><li>  Schließsignal </li></ul><br><p>  Um ein Signal zu senden, müssen Sie eine "Klick" -Schaltfläche simulieren: Setzen Sie den Wert auf true und setzen Sie ihn nach einer Weile auf false zurück.  In diesem Zusammenhang war es für die Integration in HomeKit erforderlich, einen anderen Status zu erstellen - den „Zielstatus des Gates“. Wenn dieser geändert wird, wird das entsprechende Signal gesendet. </p><br><p>  Das Zeichen der Offenheit des Tors kann durch den Zielzustand ersetzt werden (d. H. Was das Ziel anstrebt): </p><br><ul><li>  Wenn die CA „geschlossen“ ist und kein DV vorhanden ist, ist das Gate geschlossen </li><li>  Wenn die CA „geschlossen“ ist und ein DV vorhanden ist, öffnen sich die Tore </li><li>  Wenn die Zertifizierungsstelle „offen“ ist und kein DV vorhanden ist, ist das Gate geöffnet </li><li>  Wenn die Zertifizierungsstelle „offen“ ist und ein DV vorhanden ist, wird das Gate geschlossen </li></ul><br><p>  Wir werden auch einen separaten Status "Aktueller Gate-Status" erstellen und diesen abhängig vom Wert der Zeichen und vom Zielstatus in das Skript einfügen. </p><br><div class="spoiler">  <b class="spoiler_title">Zustandsänderungsskript für Garagentore</b> <div class="spoiler_text"><pre> <code class="javascript hljs">createState(<span class="hljs-string"><span class="hljs-string">"gate_0.current"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   createState("gate_0.target"); //   //    0,   300 on({id: "mqtt.0.gate.gpio.13", ack: false, val: 1}, function (obj) {  setStateDelayed("mqtt.0.gate.gpio.13", 0,  300); }); on({id: "mqtt.0.gate.gpio.12", ack: false, val: 1}, function (obj) {  setStateDelayed("mqtt.0.gate.gpio.12", 0,  300); }); //     on({id: "mqtt.0.gate.is_open", ack: false, val: 1}, function (obj) {  // ""  setState("javascript.0.gate_0.current", 0, true); }); on({id: "mqtt.0.gate.is_open", ack: false, val: 0}, function (obj) {  // ""  setState("javascript.0.gate_0.current", 1, true); }); //    - ,      on({id: "javascript.0.gate_0.target", ack: false, val: 0}, function (obj) {  setState("mqtt.0.gate.gpio.12", 1); }); //    - ,      on({id: "javascript.0.gate_0.target", ack: false, val: 1}, function (obj) {  setState("mqtt.0.gate.gpio.13", 1); }); on({id: "mqtt.0.gate.in_progress", ack: true, change: 'any'}, function (obj) {  //    " ",      if (obj.state.val === 1) {      //    "",         const target = getState("javascript.0.gate_0.target");      if (target.val === 0) {          // ""          setState("javascript.0.gate_0.current", 2, true);      } else {          // ""          setState("javascript.0.gate_0.current", 3, true);      }  }  //    " ",      if (obj.state.val === 0) {      //    "",         const target = getState("javascript.0.gate_0.target");      if (target.val === 0) {          // ""          setState("javascript.0.gate_0.current", 0, true);      } else {          // ""          setState("javascript.0.gate_0.current", 1, true);      }  } });</span></span></code> </pre> </div></div><br><p>  Nach dem Ausführen des Skripts können Sie die Eigenschaften des Garagentor-Service konfigurieren: </p><br><p><img src="https://habrastorage.org/webt/lb/cm/t5/lbcmt51du7vnivrjbj2o_h_u28u.png" alt="GarageDoorOpener Service" title="GarageDoorOpener Service"></p><br><p><img src="https://habrastorage.org/webt/pg/rh/ey/pgrhey_qs-cxm8rg6yj_lufgmgs.png"></p><br><h3 id="kamera">  Kamera </h3><br><p>  Um HomeKit eine Kamera hinzuzufügen, wird die "klassische" Methode verwendet.  Die Übertragung des Bildes von der Kamera über das ffmpeg-Modul ist organisiert.  Dadurch wird der Eingabestream verschlüsselt, verschlüsselt und an Homekit übergeben. </p><br><p>  Zunächst müssen Sie ffmpeg auf dem Server installieren, auf dem sich ioBroker befindet. </p><br><p>  Für jede Plattform wird sie auf unterschiedliche Weise installiert. Sie können sie aus der Quelle zusammenstellen oder nach einer fertigen Baugruppe suchen, z. B.: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.johnvansickle.com/ffmpeg/</a> Muss einen libx264-Encoder haben.  Sie können den Encoder nach der Installation von ffmpeg mit dem folgenden Befehl überprüfen: </p><br><pre> <code class="plaintext hljs">ffmpeg -codecs | grep 264</code> </pre> <br><p>  Die Ergebnisse sollten eine Zeile des Formulars enthalten: </p><br><pre> <code class="plaintext hljs">DEV.LS h264                 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (decoders: h264 h264_v4l2m2m h264_vdpau ) (encoders: libx264 libx264rgb h264_v4l2m2m )</code> </pre> <br><p>  Für Raspberry Pi 3 können Sie die <a href="">vorgefertigte Assembly verwenden</a> , die einen Codec mit Unterstützung für die GPU-Hardwarecodierung enthält (h264_omx verbraucht weniger Ressourcen).  Sagen Sie es so: </p><br><pre> <code class="plaintext hljs">wget https://github.com/legotheboss/YouTube-files/raw/master/ffmpeg_3.1.4-1_armhf.deb sudo dpkg -i ffmpeg_3.1.4-1_armhf.deb</code> </pre> <br><p>  Beide Codecs sind in dieser Assembly vorhanden: libx264 und h264_omx </p><br><p>  Als Nächstes müssen Sie die Adresse des Kamerastreams abrufen, der gesendet werden soll (dieser Schritt geht über den Rahmen dieses Artikels hinaus).  Sie können beispielsweise einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigten öffentlichen Stream verwenden</a> . </p><br><p>  Fügen Sie nun die Kamera zu Yahka hinzu, geben Sie die Adresse des Streams an und ändern Sie gegebenenfalls die Parameter des Codecs, der Bildgröße und der Bildrate. </p><br><p>  <strong>Wichtig: Kombinationen von Parametern sind für die korrekte Anzeige der Kamera in Homekit sehr wichtig und hängen von der Kamera und dem Stream ab.</strong>  <strong>Dies wirkt sich auch auf die Systemleistung aus</strong>  <strong>Der laufende Prozess von ffmpeg verbraucht viele Ressourcen.</strong> </p><br><p><img src="https://habrastorage.org/webt/zh/uj/6g/zhuj6gv7alolh2nfvmpyxgmnoju.png" alt="Hinzufügen einer Kamera" title="Fehlen einer Kamera"></p><br><p><img src="https://habrastorage.org/webt/w7/_z/pl/w7_zplfretbtbw0v66nb9ip9ira.png" alt="Stream-Setup" title="Stream-Setup"></p><br><div class="spoiler">  <b class="spoiler_title">Kameras werden als separate Geräte außerhalb des Gateways hinzugefügt und müssen genau wie das Gateway hinzugefügt werden</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ib/8v/s9/ib8vs9ksuw5mk4ese_-gg6rnrv4.png"></p></div></div><br><p><img src="https://habrastorage.org/webt/0d/hp/qd/0dhpqdbfe_hgez4u7x2edcu92za.png" alt="Miniaturansicht der Kamera" title="Miniaturansicht der kamera"></p><br><p><img src="https://habrastorage.org/webt/ue/tj/o4/uetjo4rqvi-fsae2rlkt56cmaji.png" alt="Ausstrahlung von der Kamera" title="Ausstrahlung von der Kamera"></p><br><h3 id="bonus">  Bonus </h3><br><p>  Als Bonus werde ich über die ungewöhnliche Verwendung von Kamerasendungen sprechen. </p><br><p>  Mit demselben ffmpeg können Sie anstelle der Kamera versuchen, das Bild und jedes Bild zu übertragen.  Diese Bilder können auch mit dem Videostream kombiniert werden.  Sie können Text, Grafiken und andere Informationen auf dem Bild anzeigen. </p><br><p><img src="https://habrastorage.org/webt/sg/cl/f7/sgclf7ssws1pkm_rlf3qy_avmhi.png" alt="Text Overlay Cast" title="Text Overlay Cast"></p><br><p>  Als Ergebnis erhalten Sie ein interessantes Dashboard.  Wenn Sie das Bild regelmäßig aktualisieren, erhalten Sie dynamische Daten. </p><br><p>  Als Beispiel habe ich eine grafische Darstellung der Änderungen einiger Indikatoren in Form eines Bildes (Datei auf der Festplatte) erstellt.  Dieses Diagramm wird einmal pro Minute aktualisiert und überschreibt das Bild in der Datei. </p><br><div class="spoiler">  <b class="spoiler_title">(Die Funktionen createImage1, createImage2, die Bildung eines Diagramms und das Auferlegen von Text auf ein Bild gehen über den Rahmen dieses Artikels hinaus, aber ich werde einen Hinweis geben).</b> <div class="spoiler_text"><p>  Ich werde Ihnen sagen, wie Sie ein Diagramm in Form eines Bildes erhalten können. </p><br><p>  IoBroker bietet eine Standardmethode zum Erstellen von Diagrammen - den Flot-Treiber.  Dieser Treiber ist mit einem Webtreiber gekoppelt und zeigt das Ergebnis in einem Browser an.  Um das erstellte Diagramm auf dem Server (im Skript) als Bild zu erhalten, wird jedoch ein zusätzlicher PhantomJS-Treiber benötigt, der einen „Screenshot“ der Seite erstellt (auf der ein Flot-Diagramm gezeichnet wird). </p><br><p>  Ich werde jedoch über eine alternative Methode zum Erstellen von Diagrammen auf dem Server in einem Skript sprechen. </p><br><p>  Es gibt eine solche Chart.js-Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.chartjs.org/</a> , mit der Sie gut aussehende Grafiken im Browser zeichnen können (Beispiele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.chartjs.org/samples/latest/</a> ). </p><br><p>  Zum Zeichnen wird die „Leinwand“ (Leinwand, Leinwand) des Browsers verwendet.  Um mit dieser Bibliothek auf dem Server zu zeichnen, müssen Sie daher die "Server" -Version der "Canvas" - und DOM-Objekte verwenden.  Dies ist, was das chartjs-node-Paket tut ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/vmpowerio/chartjs-node</a> ). </p><br><p>  Die Hauptabhängigkeit für dieses Paket ist das Canvas-Paket ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Automattic/node-canvas</a> ), das global (oder im iobroker-Ordner) installiert werden sollte.  Es ist wichtig, alle Abhängigkeiten für die Plattform zu installieren, auf der Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Automattic/node-canvas#compiling ablegen</a> . </p><br><p>  Danach können Sie in den Javascript-Treibereinstellungen die Module chart.js und chartjs-node hinzufügen.  Sie sollten korrekt und fehlerfrei installiert werden.  Andernfalls behandeln Sie Fehler und beheben Sie sie. </p><br><p>  Und dann können Sie ein Skript schreiben. </p><br><p>  Unten finden Sie ein Skript für ein Beispiel wie  Es enthält die Verwendung des Verlaufstreibers und verwendet bestimmte Statusnamen. </p><br><p>  Achtung!  Das Skript hat komplizierte Konstruktionen für Anfänger - Versprechen.  Dies ist eine bequeme Möglichkeit, keine Funktionen mit Rückruf zu schreiben, sondern Ketten von Schritten zu erstellen.  So ist es beispielsweise zweckmäßig, Daten aus der Zustandsgeschichte zu erhalten. </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ChartjsNode = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chartjs-node'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/** *  sendTo  Promise,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendToPromise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">adapter, cmd, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { sendTo(adapter, cmd, params, (result) =&gt; { resolve(result); }); }); } <span class="hljs-comment"><span class="hljs-comment">//    const chartColors = { black: 'rgb(0, 0, 0)', red: 'rgb(255, 99, 132)', orange: 'rgb(255, 159, 64)', yellow: 'rgb(255, 205, 86)', green: 'rgb(75, 192, 192)', blue: 'rgb(54, 162, 235)', purple: 'rgb(153, 102, 255)', grey: 'rgb(201, 203, 207)' }; /** *        * : * @param config -     * @param filename -     * : * @param Promise -    */ function doDraw(config, filename) { //     640x480  var chartNode = new ChartjsNode(640, 480); return chartNode.drawChart(config) .then(() =&gt; { //     return chartNode.writeImageToFile('image/png', filename); }); } /** *     ChartJS. * : * @param Promise -    */ function prepareDraw0(){ // ,    var ; //  Promise     return new Promise((resolve, reject)=&gt;{resolve()}) //       ,      .then(()=&gt;{ //  ,   ,      = [ {"val":3,"ack":1,"ts":1539063874301}, {"val":5,"ack":1,"ts":1539063884299}, {"val":5.3,"ack":1,"ts":1539063894299}, {"val":3.39,"ack":1,"ts":1539063904301}, {"val":5.6,"ack":1,"ts":1539063914300}, {"val":-1.3,"ack":1,"ts":1539063924300}, {"val":-6.3,"ack":1,"ts":1539063934302}, {"val":1.23,"ack":1,"ts":1539063944301}, ]; }) //   -    .then(()=&gt;{ const chartJsOptions = { //   -  type: 'line', data: { //    datasets: [ { //   label: '', //  backgroundColor: chartColors.black, borderColor: chartColors.black, //   pointRadius: 3, //    borderWidth: 3, //     ''        data: .map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), //   -  fill: false, } ] }, options: { //   legend: { labels: { //   fontSize: 20, }, }, //   scales: { //  X xAxes: [{ //  -   type: 'time', display: true, //   scaleLabel: { display: true, labelString: '' }, }], //  Y yAxes: [{ //  -  type: 'linear', display: true, //   scaleLabel: { display: true, labelString: '' }, }] } } }; return chartJsOptions; }); } /** *     ChartJS. *         , *     . * * : * @param hours -  ,     * : * @param Promise -    */ function prepareDraw1(hours){ //   ,      const end = new Date().getTime(), start = end - 3600000*(hours || 1); // 1 =   //  ,       //   var , 2, 1, 2, 2; //  Promise     return new Promise((resolve, reject)=&gt;{resolve()}) //       'mqtt.0.ESP_Easy..Temperature' .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'mqtt.0.ESP_Easy..Temperature', options: { start: start, end: end, aggregate: 'onchange' } } ).then((result) =&gt; { //     ''  = result.result; }); }) //       'sonoff.0.chicken2.DS18B20_Temperature' .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.DS18B20_Temperature', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ //     '2' 2 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.sonoff_chicken_vent.DS18B20_Temperature', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 1 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.POWER1', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 2 = result.result; }); }) .then(() =&gt; { return sendToPromise('history.0', 'getHistory', { id: 'sonoff.0.chicken2.POWER2', options: { start: start, end: end, aggregate: 'onchange' } }).then((result)=&gt;{ 2 = result.result; }); }) //   -    .then(()=&gt;{ const chartJsOptions = { //   -  type: 'line', data: { //    datasets: [ { //           label: ' ('+[.length - 1].val+')', //  backgroundColor: chartColors.blue, borderColor: chartColors.blue, //  . 0 -   pointRadius: 0, //    borderWidth: 3, //     ''        data: .map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), //   -  fill: false, //   Y yAxisID: 'y-axis-1', },{ label: ' 1 ('+1[1.length - 1].val+')', backgroundColor: chartColors.green, borderColor: chartColors.green, pointRadius: 0, borderWidth: 3, data: 1.map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), fill: false, yAxisID: 'y-axis-1', },{ label: ' 2 ('+2[2.length - 1].val+')', backgroundColor: chartColors.red, borderColor: chartColors.red, pointRadius: 0, borderWidth: 3, data: 2.map((item) =&gt; { return {y: item.val, t: new Date(item.ts)} }), fill: false, yAxisID: 'y-axis-1', },{ label: ' 2  ('+2[2.length - 1].val+')', backgroundColor: chartColors.yellow, borderColor: chartColors.yellow, pointRadius: 0, borderWidth: 1, data: 2.map((item) =&gt; { return {y: (item.val) ? 1 : 0, t: new Date(item.ts)} }), fill: true, lineTension: 0, steppedLine: true, yAxisID: 'y-axis-2', },{ label: ' 2  ('+2[2.length - 1].val+')', backgroundColor: chartColors.grey, borderColor: chartColors.grey, pointRadius: 0, borderWidth: 1, data: 2.map((item) =&gt; { return {y: (item.val) ? -1 : 0, t: new Date(item.ts)} }), fill: true, lineTension: 0, steppedLine: true, yAxisID: 'y-axis-2', } ] }, options: { //   legend: { labels: { //   fontSize: 20, }, }, //   scales: { //  X xAxes: [{ //  -   type: 'time', display: true, //   scaleLabel: { display: true, labelString: '' }, //    () time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } }, }], //  Y yAxes: [{ //  -  type: 'linear', display: true, //   scaleLabel: { display: true, labelString: '' }, //   -  position: 'left', //   id: 'y-axis-1', },{ type: 'linear', display: true, scaleLabel: { display: true, labelString: '  ' }, ticks: { min: -4, max: 2 }, //   -  position: 'right', id: 'y-axis-2', }] } } }; return chartJsOptions; }); } function createImage(filename, callback){ // filename -  ,       //    prepareDraw1(2) //     .then((result) =&gt; { //        return doDraw(result, filename); }) .then(()=&gt;{ if (callback) callback(); }) .catch((err)=&gt;{ console.error(err); }); }</span></span></code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/4c/d5/bs/4cd5bslfzniznrd16qfmqu0tuly.png" alt="Broadcast-Bild statt Stream" title="Broadcast-Bild statt Stream"></p><br><p>  Das Miniaturbild wird ungefähr einmal pro Minute aktualisiert, daher werden wir festlegen, dass das Bild alle 10 Sekunden aktualisiert wird: </p><br><pre> <code class="plaintext hljs">var fs = require('fs'); //  10    schedule("*/10 * * * * *", () =&gt; {  createImage1('/tmp/1_new.jpg', ()=&gt; {      fs.renameSync('/tmp/1_new.jpg', '/tmp/1.jpg');  });  createImage2('/tmp/2_new.jpg', ()=&gt; {      fs.renameSync('/tmp/2_new.jpg', '/tmp/2.jpg');  }); });</code> </pre> <br><p>  Die Besonderheit ist, dass beim Senden des Bildes das Bild schnell genug ersetzt werden muss, damit ffmpeg nicht abstürzt :) Daher wird das Bild zuerst in eine Datei umgewandelt und dann in die für die Übersetzung verwendete Datei umbenannt. </p><br><p>  Geben Sie nun in den Kameraeinstellungen den Namen der generierten Datei anstelle der Stream-Adresse an und fügen Sie die Einstellungen hinzu, dass das Bild "aktualisiert" wird (Parameter "-loop 1").  Dies wird in den erweiterten Eigenschaften der Kamera konfiguriert.  Diese Eigenschaften sind nichts anderes als Befehlszeilenoptionen zum Ausführen von ffmpeg.  Daher sollten Kombinationen von Parametern in der ffmpeg-Dokumentation und in den Beispielen gefunden werden. </p><br><p>  Die Eigenschaften sind in zwei Typen unterteilt: zum Erhalten einer „Vorschau“ (ein kleines Kamerabild) und zum Senden.  Daher können Sie verschiedene Bildquelldateien angeben, beispielsweise mit unterschiedlichen Details. </p><br><p><img src="https://habrastorage.org/webt/zy/30/b4/zy30b4wc2zud54wr-px_ezovdgu.png" alt="Ffmpeg-Startoptionen" title="Ffmpeg-startoptionen"></p><br><p><img src="https://habrastorage.org/webt/mk/l5/qi/mkl5qizqb41if_youa62qrgm9hc.png" alt="Live-Übertragung Bild" title="Live-Übertragung bild"></p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>         ioBroker     .       ,       . ,   ,        . </p><br><p>  ,    Yahka       ,      Material.           ,            HomeKit. </p><br><p>       Yahka,    HomeKit     —  Ham,     HomeBridge         .       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433798/">https://habr.com/ru/post/de433798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433786/index.html">Fintech Digest: Kryptowährung ist Eigentum, eine Rekordzahl von Kreditkarten wurde in der Russischen Föderation ausgestellt</a></li>
<li><a href="../de433788/index.html">Secure Deal und neue freiberufliche Bewertungen</a></li>
<li><a href="../de433790/index.html">Erweiterte mehrstufige Build-Vorlagen</a></li>
<li><a href="../de433792/index.html">Shell-Skripte in Ansible</a></li>
<li><a href="../de433796/index.html">Wie Homo Sapiens die Welt eroberte. Kommunikations- und Verhandlungsfähigkeiten</a></li>
<li><a href="../de433800/index.html">Verwenden der UDB-PSoC-Controller von Cypress, um Unterbrechungen in einem 3D-Drucker zu reduzieren</a></li>
<li><a href="../de433802/index.html">Wie und warum wir den Big Data Track beim Urban Tech Challenge Hackathon gewonnen haben</a></li>
<li><a href="../de433804/index.html">Mixture Density Networks</a></li>
<li><a href="../de433806/index.html">Wenn das Online-Archiv vergisst</a></li>
<li><a href="../de433808/index.html">5 häufigste Fehler, die Programmierer beim Interview machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>