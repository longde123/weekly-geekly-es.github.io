<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🆖 👩‍🚒 In Python verwendete Optimierungen: Liste und Tupel 🍱 👂 🥡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Python gibt es zwei ähnliche Typen - Liste (Liste) und Tupel (Tupel). Der bekannteste Unterschied zwischen den beiden ist, dass Tupel unveränderlic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In Python verwendete Optimierungen: Liste und Tupel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417783/">  In Python gibt es zwei ähnliche Typen - Liste (Liste) und Tupel (Tupel).  Der bekannteste Unterschied zwischen den beiden ist, dass Tupel unveränderlich sind. <br><br>  Sie können Objekte in Tupel nicht ändern: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">10</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Sie können jedoch veränderbare Objekte in einem Tupel ändern: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>b = (<span class="hljs-number"><span class="hljs-number">1</span></span>,[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>],<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; b[<span class="hljs-number"><span class="hljs-number">1</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; b[<span class="hljs-number"><span class="hljs-number">1</span></span>].append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; b (<span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><a name="habracut"></a><br>  In CPython (dem Standardinterpreter) werden die Liste und das Tupel als Blatt von Zeigern (Links) auf Python-Objekte implementiert, d. H.  physisch speichern sie keine Objekte nebeneinander.  Wenn Sie ein Objekt aus der Liste löschen, wird der Verweis auf dieses Objekt gelöscht.  Wenn jemand anderes auf das Objekt verweist, bleibt es weiterhin im Speicher. <br><br><h4>  Tupel </h4><br>  Trotz der Tatsache, dass Tupel im Code viel seltener und nicht so beliebt sind, ist dies ein sehr grundlegender Typ, den Python ständig für interne Zwecke verwendet. <br><br>  Sie werden es vielleicht nicht bemerken, aber Sie verwenden Tupel, wenn: <br><br><ul><li>  arbeiten mit Argumenten oder Parametern (sie werden als Tupel gespeichert) </li><li>  zwei oder mehr Variablen von einer Funktion zurückgeben </li><li>  iterieren Sie Werteschlüssel in einem Wörterbuch </li><li>  Verwenden Sie die Zeichenfolgenformatierung </li></ul><br>  Normalerweise verwendet das einfachste Skript Tausende von Tupeln: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_stats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_obj)</span></span></span><span class="hljs-function">:</span></span> ... count = <span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gc.get_objects(): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type(obj) == type_obj: ... count += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count ... &gt;&gt;&gt; type_stats(tuple) <span class="hljs-number"><span class="hljs-number">3136</span></span> &gt;&gt;&gt; type_stats(list) <span class="hljs-number"><span class="hljs-number">659</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas &gt;&gt;&gt; type_stats(tuple) <span class="hljs-number"><span class="hljs-number">6953</span></span> &gt;&gt;&gt; type_stats(list) <span class="hljs-number"><span class="hljs-number">2455</span></span></code> </pre><br><h4>  Leere Listen gegen leere Tupel </h4><br>  Ein leeres Tupel funktioniert wie ein Singleton, d. H.  Es gibt immer nur ein leeres Tupel im Speicher eines laufenden Python-Skripts.  Alle leeren Tupel beziehen sich einfach auf dasselbe Objekt. Dies ist möglich, da Tupel unveränderlich sind.  Dieser Ansatz spart viel Speicher und beschleunigt die Arbeit mit leeren Tupeln. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = () &gt;&gt;&gt; b = () &gt;&gt;&gt; a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; id(a) <span class="hljs-number"><span class="hljs-number">4409020488</span></span> &gt;&gt;&gt; id(b) <span class="hljs-number"><span class="hljs-number">4409020488</span></span> &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">#  CPython,  id    .</span></span></code> </pre><br>  Dies funktioniert jedoch nicht mit Listen, da diese geändert werden können: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = [] &gt;&gt;&gt; b = [] &gt;&gt;&gt; a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> &gt;&gt;&gt; id(a) <span class="hljs-number"><span class="hljs-number">4465566920</span></span> &gt;&gt;&gt; id(b) <span class="hljs-number"><span class="hljs-number">4465370632</span></span></code> </pre><br><h4>  Optimierung der Speicherzuordnung für Tupel </h4><br>  Um die Speicherfragmentierung zu verringern und die Erstellung von Tupeln zu beschleunigen, verwendet Python alte Tupel, die gelöscht wurden.  Wenn ein Tupel aus weniger als 20 Elementen besteht und nicht mehr verwendet wird, platziert Python es nicht mehr, sondern in einer speziellen Liste, in der Tupel zur Wiederverwendung frei gespeichert werden. <br><br>  Diese Liste ist in 20 Gruppen unterteilt, wobei jede Gruppe eine Liste von Tupeln der Größe n ist, wobei n zwischen 0 und 20 liegt. Jede Gruppe kann bis zu 2.000 freie Tupel speichern.  Die erste Gruppe speichert nur ein Element und ist eine Liste eines leeren Tupels. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) &gt;&gt;&gt; id(a) <span class="hljs-number"><span class="hljs-number">4427578104</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> a &gt;&gt;&gt; b = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; id(b) <span class="hljs-number"><span class="hljs-number">4427578104</span></span></code> </pre><br>  Im obigen Beispiel können wir sehen, dass a und b dieselbe Adresse im Speicher haben.  Dies liegt daran, dass wir sofort ein kostenloses Tupel der gleichen Größe genommen haben. <br><br><h4>  Optimieren der Speicherzuordnung für Listen </h4><br>  Da sich Listen ändern können, kann die gleiche Optimierung wie bei Tupeln nicht mehr gestartet werden.  Trotzdem verwenden Listen ähnliche Optimierungen, die auf leere Listen abzielen.  Wenn die leere Liste gelöscht wird, kann sie auch in Zukunft wiederverwendet werden. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = [] &gt;&gt;&gt; id(a) <span class="hljs-number"><span class="hljs-number">4465566792</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> a &gt;&gt;&gt; b = [] &gt;&gt;&gt; id(b) <span class="hljs-number"><span class="hljs-number">4465566792</span></span></code> </pre><br><h4>  Liste der Größe ändern </h4><br>  Um den Aufwand für die ständige Größenänderung von Listen zu vermeiden, ändert Python die Größe nicht jedes Mal, wenn dies erforderlich ist.  Stattdessen enthält jede Liste eine Reihe zusätzlicher Zellen, die für den Benutzer ausgeblendet sind, aber später für neue Elemente verwendet werden können.  Sobald die versteckten Zellen enden, fügt Python zusätzlichen Platz für neue Elemente hinzu.  Und er tut es mit einem guten Spielraum. Die Anzahl der ausgeblendeten Zellen wird basierend auf der aktuellen Größe der Liste ausgewählt. Je größer sie ist, desto mehr zusätzliche ausgeblendete Slots für neue Elemente. <br><br>  Diese Optimierung ist besonders hilfreich, wenn Sie versuchen, viele Elemente in einer Schleife hinzuzufügen. <br><br>  Das Wachstumsmuster der Listengröße sieht ungefähr so ​​aus: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ... <br><br>  Wenn Sie beispielsweise einer Liste mit 8 Elementen ein neues Element hinzufügen möchten, befinden sich keine freien Zellen darin, und Python erweitert seine Größe sofort auf 16 Zellen, von denen 9 belegt und für den Benutzer sichtbar sind. <br><br>  Python-Größenformel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_new_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n_items)</span></span></span><span class="hljs-function">:</span></span> ... new_size = n_items + (n_items // <span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">3</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n_items &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>: ... new_size += <span class="hljs-number"><span class="hljs-number">3</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: ... new_size += <span class="hljs-number"><span class="hljs-number">6</span></span> ... ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_size ... &gt;&gt;&gt; get_new_size(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br><h4>  Geschwindigkeit </h4><br>  Wenn wir diese beiden Arten in der Geschwindigkeit vergleichen, sind Tupel in einem Krankenhaus im Durchschnitt etwas schneller als Listen.  Raymond Hettinger hat eine großartige Erklärung für den Geschwindigkeitsunterschied beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapelüberlauf</a> . <br><br>  PS: Ich bin der Autor dieses Artikels, Sie können alle Fragen stellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417783/">https://habr.com/ru/post/de417783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417773/index.html">Selbstgemachtes OpenPnP-Komponenteninstallationsprogramm</a></li>
<li><a href="../de417775/index.html">Bitcoin-Provisionsmechanismus und warum mit Bergleuten befreundet sein</a></li>
<li><a href="../de417777/index.html">Wochenendlesung: 25 Materialien für Vinyl-Anfänger</a></li>
<li><a href="../de417779/index.html">Verwenden von Unity3D in einer nativen iOS / Android-Anwendung zum Modellieren der Beleuchtung von Freiflächen</a></li>
<li><a href="../de417781/index.html">Die NASA-Sonde „berührt“ die Sonne - und schmilzt nicht</a></li>
<li><a href="../de417785/index.html">Welcher Systemadministrator träumt nicht von seinem Outsourcing-Unternehmen?</a></li>
<li><a href="../de417787/index.html">Meine Berufserfahrung zur Rolle des agilen Coach in Europa, Teil 1</a></li>
<li><a href="../de417789/index.html">Diskussionen über Telekommunikationsaussichten</a></li>
<li><a href="../de417791/index.html">Wie wir zur New York Developer Week gegangen sind</a></li>
<li><a href="../de417793/index.html">Vergessen Sie die Megastrukturen von Außerirdischen: Neue Beobachtungen erklären das Verhalten des Sterns Tabby nur Staub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>