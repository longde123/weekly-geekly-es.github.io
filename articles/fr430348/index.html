<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèπ ‚úãüèæ ‚ÜñÔ∏è OpenSceneGraph: encapsulation d'une machine d'√©tat OpenGL üñ®Ô∏è üéä üë®üèæ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 En r√®gle g√©n√©rale, lorsque vous travaillez avec des param√®tres de rendu, OpenGL agit comme une machine √† √©tats. Un √©tat de rendu est un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: encapsulation d'une machine d'√©tat OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430348/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  En r√®gle g√©n√©rale, lorsque vous travaillez avec des param√®tres de rendu, OpenGL agit comme une machine √† √©tats.  Un √©tat de rendu est une collection d'attributs d'√©tat, tels que les sources lumineuses, les mat√©riaux, les textures et les modes d'affichage, activ√©s et d√©sactiv√©s par les fonctions glEnable () et glDisable ().  Lorsqu'un certain √©tat est d√©fini, il reste en vigueur jusqu'√† ce qu'une autre fonction le modifie.  Le pipeline OpenGL prend en charge une pile d'√©tats pour enregistrer et restaurer des √©tats √† tout moment.  La machine √† √©tats donne au d√©veloppeur un contr√¥le complet sur les √©tats de rendu actuels et enregistr√©s sur la pile. <br><br>  Cependant, cette approche n'est pas pratique lorsque vous travaillez avec OSG.  Pour cette raison, la machine √† √©tats OpenGL est encapsul√©e par la classe osg :: StateSet, qui s'occupe de travailler avec la pile d'√©tats et de les param√©trer dans le processus de travers√©e du graphe de sc√®ne. <br><a name="habracut"></a><br>  Une instance de la classe osg :: StateSet contient un sous-ensemble des diff√©rents √©tats de rendu et peut les appliquer aux n≈ìuds de sc√®ne osg :: Node et aux objets g√©om√©triques osg :: Drawable √† l'aide de la m√©thode setStateSet () <br><br><pre><code class="cpp hljs">osg::StateSet *stateset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::StateSet; node-&gt;setStateSet(stateset);</code> </pre> <br>  Un moyen plus s√ªr serait d'utiliser la m√©thode getOrCreateStateSet (), qui garantit le retour de l'√©tat correct et son attachement au n≈ìud ou √† l'objet dessinable <br><br><pre> <code class="cpp hljs">osg::StateSet *stateset = node-&gt;getOrCreateStateSet();</code> </pre><br>  Les classes osg :: Node et osg :: Drawable contr√¥lent la variable membre osg :: StateSet via le pointeur intelligent osg :: ref_ptr &lt;&gt;.  Cela signifie qu'un ensemble d'√©tats peut √™tre divis√© entre plusieurs objets de la sc√®ne et ne sera d√©truit que lorsque tous ces objets seront d√©truits. <br><br><h1>  1. Attributs et modes </h1><br>  OSG d√©finit la classe osg :: StateAttribute pour stocker les attributs de rendu.  Il s'agit d'une classe de base virtuelle h√©rit√©e de divers attributs de rendu tels que la lumi√®re, le mat√©riau et le brouillard. <br><br>  Les modes de rendu fonctionnent comme des commutateurs qui peuvent √™tre activ√©s et d√©sactiv√©s.  De plus, ils sont associ√©s √† des √©num√©rateurs, qui sont utilis√©s pour indiquer le type de mode OpenGL.  Parfois, le mode de rendu est associ√© √† un attribut, par exemple, le mode GL_LIGHTING inclut des variables pour les sources lumineuses qui sont envoy√©es au pipeline OpenGL lorsqu'il est activ√©, et d√©sactive l'√©clairage autrement. <br><br>  La classe osg :: StateSet divise les attributs et les modes en deux groupes: texture et non-texture.  Il a plusieurs m√©thodes publiques pour ajouter des attributs et des modes non textur√©s √† un ensemble d'√©tats: <br><br><ol><li>  setAttribute () - Ajoute un objet de type osg :: StateAttribute √† l'ensemble d'√©tats.  Les attributs du m√™me type ne peuvent pas coexister dans le m√™me ensemble d'√©tats.  Le point de consigne pr√©c√©dent sera remplac√© par le nouveau. <br></li><li>  setMode () - attache un √©num√©rateur de mode √† un ensemble d'√©tats et d√©finit sa valeur sur osg :: StateAttribute :: ON ou osg :: StateAttribute :: OFF, ce qui signifie activer ou d√©sactiver le mode. <br></li><li>  setAttributeAndModes () - attache l'attribut de rendu et son mode associ√© et d√©finit la valeur du commutateur (par d√©faut ON).  Il convient de garder √† l'esprit que tous les attributs n'ont pas un mode correspondant, mais vous pouvez utiliser cette m√©thode dans tous les cas. <br></li></ol><br>  Pour d√©finir l'attribut et son mode associ√©, vous pouvez utiliser ce code <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(attr, osg::StateAttribute::ON);</code> </pre><br>  Pour d√©finir les attributs de texture, un param√®tre suppl√©mentaire doit √™tre transmis pour indiquer la texture √† laquelle il doit √™tre appliqu√©.  Osg :: StateSet fournit plusieurs autres m√©thodes publiques pour cela, telles que setTextureAttribute (), setTextureMode () et setTextureAttributeAndModes () <br><br><pre> <code class="cpp hljs">stateset-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, textattr, osg::StateAttribute::ON);</code> </pre><br>  applique l'attribut textattr √† la texture avec l'identifiant 0. <br><br><h1>  2. D√©finition du mode d'affichage des polygones pour les n≈ìuds de sc√®ne </h1><br>  Nous illustrons la th√©orie ci-dessus avec un exemple pratique - changer le mode de pixellisation des polygones OpenGL en utilisant la classe osg :: PolygonMode, qui h√©rite d'osg :: StateAttribute.  Cette classe encapsule la fonction glPolygonMode () et fournit une interface pour d√©finir le mode d'affichage des polygones pour un n≈ìud de sc√®ne particulier. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple en mode polygone</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::PolygonMode&gt; pm = new osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Ici, nous t√©l√©chargeons le mod√®le de notre bien-aim√© cessna et en lui appliquant des transformations, nous obtenons deux instances du mod√®le.  √Ä l'un d'eux, √† gauche, nous appliquons un attribut qui d√©finit le mode d'affichage filaire des polygones <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PolygonMode&gt; pm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get());</code> </pre><br><img src="https://habrastorage.org/webt/pg/v5/ew/pgv5ewaulc_tfjztw5h8gyyap1i.png"><br><br>  Si nous nous tournons vers la sp√©cification OpenGL, nous pouvons facilement imaginer quelles options d'affichage de polygone seront disponibles lorsque nous utiliserons setMode () dans ce cas particulier.  Le premier param√®tre peut prendre les valeurs osg :: PolygonMode :: FRONT, BACK et FRONT_AND_BACK, correspondant aux √©num√©rateurs OpenGL GL_FRONT, GL_BACK, GL_FRONT_AND_BACK.  Le deuxi√®me param√®tre peut prendre les valeurs osg :: PolygonMode :: POINT, LINE et FILL, qui correspondent √† GL_POINT, GL_LINE et GL_FILL.  Aucune autre astuce, comme c'est souvent le cas lors du d√©veloppement sur un OpenGL pur, n'est pas n√©cessaire ici - OSG prend en charge la plupart du travail.  Le mode d'affichage polygonal n'a pas de mode associ√© et ne n√©cessite pas d'appeler la paire glEnable () / glDisable ().  La m√©thode setAttributeAndModes () fonctionnera √©galement tr√®s bien dans ce cas, mais la valeur de son troisi√®me param√®tre sera inutile. <br><br><h1>  3. H√©ritage des √©tats de rendu.  Application d'attributs et de modes </h1><br>  L'ensemble des √©tats de n≈ìud affecte le n≈ìud actuel et tous ses enfants.  Par exemple, l'attribut osg :: PolygonMode d√©fini pour transform1 dans l'exemple pr√©c√©dent sera appliqu√© √† tous les enfants de ce n≈ìud.  Cependant, le n≈ìud enfant peut remplacer les attributs parents, c'est-√†-dire que l'√©tat de rendu sera h√©rit√© du n≈ìud parent si le n≈ìud enfant ne change pas le comportement. <br><br>  Parfois, vous devez red√©finir le comportement d'un n≈ìud en termes d'utilisation d'attribut.  Par exemple, dans la plupart des √©diteurs 3D, l'utilisateur peut charger plusieurs mod√®les et changer le mode d'affichage pour tous les mod√®les charg√©s en m√™me temps, quelle que soit la fa√ßon dont ils ont √©t√© affich√©s pr√©c√©demment.  En d'autres termes, tous les mod√®les de l'√©diteur doivent h√©riter d'un seul attribut, quelle que soit la fa√ßon dont ils √©taient pr√©c√©demment d√©finis pour chacun des mod√®les.  Dans OSG, cela peut √™tre impl√©ment√© en utilisant le drapeau osg :: StateAttribute :: OVERRIDE, par exemple <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttribute(attr, osg::StateAttribute::OVERRIDE);</code> </pre><br>  Lors de la d√©finition des modes et des modes avec des attributs, l'op√©rateur OR au niveau du bit est utilis√© <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttributeAndModes(attr, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);</code> </pre><br>  En outre, l'attribut peut √©galement √™tre prot√©g√© contre la substitution - pour cela, il doit √™tre marqu√© avec l'indicateur osg :: StateAttribute :: PROTECTED. <br><br>  Il existe un troisi√®me indicateur, osg :: StateAttribute :: INHERIT, qui est utilis√© pour indiquer que cet attribut doit √™tre h√©rit√© de l'ensemble d'√©tats du n≈ìud parent. <br><br>  Voici un court exemple utilisant les drapeaux OVERRIDE et PROTECTED.  Le n≈ìud racine sera d√©fini sur OVERRIDE pour forcer tous les n≈ìuds enfants √† h√©riter de ses attributs et modes.  Dans ce cas, les n≈ìuds enfants essaieront de changer leur √©tat avec ou sans l'aide de l'indicateur PROTECTED, ce qui conduira √† des r√©sultats diff√©rents. <br><br><div class="spoiler">  <b class="spoiler_title">H√©riter du texte d'exemple</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/glider.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-0.5f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(0.5f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/lf/8h/u4/lf8hu4n3ii1bor6lgsktbischd0.png"><br><br>  Pour comprendre ce qui se passe, vous devez regarder √† quoi ressemble un deltaplane normalement √©clair√© en t√©l√©chargeant son OSGviewer OSG √† plein temps <br><br><pre> <code class="bash hljs">$ osgviewer glider.osg</code> </pre><br>  Dans l'exemple, nous essayons de changer le mode d'√©clairage pour les n≈ìuds transform1 et transform2 en √©teignant compl√®tement l'√©clairage. <br><br><pre> <code class="cpp hljs">transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  Dans ce cas, nous activons le mode d'√©clairage pour le n≈ìud racine et utilisons l'indicateur OVERRIDE pour tous ses n≈ìuds enfants, afin qu'ils h√©ritent de l'√©tat du n≈ìud racine.  Cependant, trnsform2 utilise l'indicateur PROTECTED pour emp√™cher les param√®tres du n≈ìud racine d'affecter. <br><br><pre> <code class="cpp hljs">transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  En cons√©quence, malgr√© le fait que nous d√©sactivions l'√©clairage au niveau du n≈ìud transform1, le deltaplane gauche est toujours allum√©, car les param√®tres de la racine de la sc√®ne ont bloqu√© notre tentative de d√©sactiver l'√©clairage pour lui.  Le deltaplane droit s'affiche sans √©clairage (il semble plus lumineux uniquement parce qu'il est inond√© d'une couleur simple sans rendu de lumi√®re), car transform2 est prot√©g√© contre l'h√©ritage des attributs du n≈ìud racine. <br><br><h1>  4. Liste des attributs OpenGL pris en charge dans OpenSceneGraph </h1><br>  OSG prend en charge presque tous les attributs et modes de rendu pris en charge par OpenGL via des classes d√©riv√©es d'osg :: StateAttribute.  Le tableau pr√©sente tous les param√®tres de la machine d'√©tat OpenGL disponibles √† partir du moteur. <br><table><thead><tr><th>  ID de type d'attribut </th><th>  Nom de classe </th><th>  Mode associ√© </th><th>  Fonction OpenGL √©quivalente </th></tr></thead><tbody><tr><td>  ALPHEFUNC </td><td>  osg :: AlphaFunc </td><td>  GL_ALPHA_TEST </td><td>  glAlphaFunc () </td></tr><tr><td>  BLENDFUNC </td><td>  osg :: BlendFunc </td><td>  GL_BLEND </td><td>  glBlendFunc () et glBlendFuncSeparate () </td></tr><tr><td>  CLIPPLANE </td><td>  osg :: ClipPlane </td><td>  GL_CLIP_PLANEi (i de 1 √† 5) </td><td>  glClipPlane () </td></tr><tr><td>  Colormask </td><td>  osg :: ColorMask </td><td>  - </td><td>  glColorMask () </td></tr><tr><td>  CULLFACE </td><td>  osg :: CullFace </td><td>  GL_CULLFACE </td><td>  glCullFace () </td></tr><tr><td>  Profondeur </td><td>  osg :: Profondeur </td><td>  GL_DEPTH_TEST </td><td>  glDepthFunc (), glDepthRange () et glDepthMask () </td></tr><tr><td>  BROUILLARD </td><td>  osg :: Brouillard </td><td>  GL_FOG </td><td>  glFog () </td></tr><tr><td>  FRONTFACE </td><td>  osg :: FrontFace </td><td>  - </td><td>  glFrontFace () </td></tr><tr><td>  Lumi√®re </td><td>  osg :: Light </td><td>  GL_LIGHTi (i de 1 √† 7) </td><td>  glLight () </td></tr><tr><td>  LIGHTMODEL </td><td>  osg :: LightModel </td><td>  - </td><td>  glLightModel () </td></tr><tr><td>  LINESTRIPPLE </td><td>  osg :: LineStripple </td><td>  GL_LINE_STRIPPLE </td><td>  glLineStripple () </td></tr><tr><td>  LARGEUR </td><td>  osg :: LineWidth </td><td>  - </td><td>  glLineWidht () </td></tr><tr><td>  LOGICOP </td><td>  osg :: LogicOp </td><td>  GL_COLOR_LOGIC_OP </td><td>  glLogicOp () </td></tr><tr><td>  MATERIEL </td><td>  osg :: Mat√©riel </td><td>  - </td><td>  glMaterial () et glColorMaterial () </td></tr><tr><td>  POINT </td><td>  osg :: Point </td><td>  GL_POINT_SMOOTH </td><td>  glPointParameter () </td></tr><tr><td>  POINTSPRITE </td><td>  osg :: PointSprite </td><td>  GL_POINT_SPRITE_ARB </td><td>  Fonctions pour travailler avec les sprites OpenGL </td></tr><tr><td>  POLYGONMODE </td><td>  osg :: PolygonMode </td><td>  - </td><td>  glPolygonMode () </td></tr><tr><td>  POLYGONOFFSET </td><td>  osg :: PolygonOffset </td><td>  GL_POLYGON_OFFSET_POINT </td><td>  glPolygonOffset () </td></tr><tr><td>  POLYGONSTRIPPLE </td><td>  osg :: PolygonStripple </td><td>  GL_POLYGON_STRIPPLE </td><td>  glPolygonStripple () </td></tr><tr><td>  CISEAUX </td><td>  osg :: Ciseaux </td><td>  GL_SCISSOR_TEST </td><td>  glScissor () </td></tr><tr><td>  SHADEMODEL </td><td>  osg :: ShadeModel </td><td>  - </td><td>  glShadeModel () </td></tr><tr><td>  POCHOIR </td><td>  osg :: Pochoir </td><td>  GL_STENCIL_TEST </td><td>  glStencilFunc (), glStencilOp () et glStencilMask () </td></tr><tr><td>  Texenv </td><td>  osg :: TexEnv </td><td>  - </td><td>  glTexEnv () </td></tr><tr><td>  Texgen </td><td>  osg :: TexGen </td><td>  GL_TEXTURE_GEN_S </td><td>  glTexGen () </td></tr></tbody></table><br>  La colonne ID de type d'attribut indique l'identifiant OSG sp√©cifique qui identifie cet attribut dans les √©num√©rateurs de la classe osg :: StateAttribute.  Il peut √™tre utilis√© dans la m√©thode getAttribute pour obtenir la valeur d'un attribut sp√©cifique. <br><br><pre> <code class="cpp hljs">osg::PolygonMode *pm = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::PolygonMode *&gt;(stateset-&gt;getAttribute(osg::StateAttribute::POLYGONMODE));</code> </pre><br>  Un pointeur valide indique que l'attribut a √©t√© d√©fini pr√©c√©demment.  Sinon, la m√©thode sera NULL.  Vous pouvez √©galement obtenir la valeur du mode actuel en utilisant l'appel <br><br><pre> <code class="cpp hljs">osg::StateAttribute::GLModeValue value = stateset-&gt;getMode(GL_LIGHTING);</code> </pre><br>  Ici, l'√©num√©rateur GL_LIGHTING est utilis√© pour activer / d√©sactiver l'√©clairage dans toute la sc√®ne. <br><br><h1>  5. Application de brouillard au mod√®le dans la sc√®ne </h1><br>  Citons l'effet de brouillard comme un moyen id√©al de montrer comment travailler avec divers attributs et modes de rendu.  OpenGL utilise une √©quation lin√©aire et deux √©quations exponentielles d√©crivant le mod√®le de brouillard, prises en charge par la classe osg :: Fog. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de brouillard de texte</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Fog&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Fog&gt; fog = new osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(500.0f); fog-&gt;setEnd(2500.0f); fog-&gt;setColor(osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/lz.osg"); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get()); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Cr√©ez d'abord l'attribut fog.  Nous utilisons un mod√®le lin√©aire, ajustons la plage d'affichage du brouillard par la distance au mod√®le <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Fog&gt; fog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(<span class="hljs-number"><span class="hljs-number">500.0f</span></span>); fog-&gt;setEnd(<span class="hljs-number"><span class="hljs-number">2500.0f</span></span>); fog-&gt;setColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Nous chargeons l'exemple de paysage lz.osg et lui appliquons cet attribut <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/lz.osg"</span></span>); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get());</code> </pre><br>  Dans la fen√™tre de visualisation, nous voyons un paysage flou et nous pouvons voir comment la densit√© du brouillard change en fonction de la distance au mod√®le <br><br><img src="https://habrastorage.org/webt/gq/8f/fu/gq8ffuswpsbsl1-xxqzprwvprle.png"><br><br><img src="https://habrastorage.org/webt/3z/st/f6/3zstf6mlxlvenapqhvj3zsxyh2i.png"><br><br><img src="https://habrastorage.org/webt/k-/mc/cj/k-mccjrssmakzwwrht-b5azkzg4.png"><br><br><h1>  6. Travailler avec des sources lumineuses et l'√©clairage </h1><br>  Comme avec OpenGL, OSG prend en charge jusqu'√† huit sources de lumi√®re pour rencontrer directement des objets de sc√®ne.  Comme OpenGL, OSG ne calcule pas automatiquement les ombres.  Les rayons lumineux proviennent de sources en lignes droites, sont r√©fl√©chis par les objets et dispers√©s par eux, apr√®s quoi ils sont per√ßus par les yeux du spectateur.  Pour un traitement d'√©clairage de haute qualit√©, il est n√©cessaire de d√©finir les propri√©t√©s des mat√©riaux, la g√©om√©trie normale des objets, etc. <br><br>  La classe osg :: Light fournit des m√©thodes pour contr√¥ler les sources de lumi√®re, notamment: setLightNum () et getLightNum () - pour travailler avec le nombre de sources;  setAmbient () et getAmbient () pour contr√¥ler le composant environnant;  setDiffuse () et getDiffuse () - pour travailler avec un composant dispers√©, etc. <br><br>  OSG d√©crit √©galement la classe osg :: LightSource pour ajouter des sources de lumi√®re √† la sc√®ne.  Il fournit la m√©thode setLight () et est le n≈ìud feuille du graphe de sc√®ne avec un seul attribut.  Tous les autres n≈ìuds du graphique de sc√®ne sont affect√©s par la source de lumi√®re si le mode correspondant pour GL_LIGHTi est d√©fini.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1 osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum( 1 ); ... //       osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight( light.get() ); ... //             root-&gt;addChild( lightSource.get() ); root-&gt;getOrCreateStateSet()-&gt;setMode( GL_LIGHT1, osg::StateAttribute::ON );</span></span></code> </pre><br>  Une autre solution plus pratique est la m√©thode setStateSetModes (), avec laquelle la source de lumi√®re avec le nombre souhait√© est automatiquement attach√©e au n≈ìud racine <br><br><pre> <code class="cpp hljs">root-&gt;addChild( lightSource.get() ); lightSource-&gt;setStateSetModes( root-&gt;getOrCreateStateSet(), osg::StateAttribute::ON );</code> </pre><br>  Vous pouvez ajouter des n≈ìuds enfants √† la source de lumi√®re, mais cela ne signifie pas du tout, vous illuminerez le sous-graphique qui lui est associ√© d'une mani√®re sp√©ciale.  Il sera trait√© comme une g√©om√©trie, repr√©sent√©e par la forme physique de la source lumineuse. <br><br>  Le n≈ìud osg :: LightSource peut √™tre attach√© au n≈ìud de transformation et, par exemple, une source de lumi√®re ponctuelle peut √™tre d√©plac√©e dans l'espace.  Ceci peut √™tre d√©sactiv√© en d√©finissant le syst√®me de coordonn√©es absolu pour la source lumineuse. <br><br><pre> <code class="cpp hljs">lightSource-&gt;setReferenceFrame( osg::LightSource::ABSOLUTE_RF );</code> </pre><br><h1>  7. Cr√©ation de sources de lumi√®re dans la sc√®ne </h1><br>  Par d√©faut, OSG d√©finit automatiquement la source de lumi√®re sur le num√©ro 0, qui √©met une lumi√®re directionnelle uniforme vers la sc√®ne.  Cependant, √† tout moment, vous pouvez ajouter plusieurs sources de lumi√®re suppl√©mentaires et m√™me les contr√¥ler √† l'aide des n≈ìuds de transformation de coordonn√©es.  Seules les sources de position (sources ponctuelles) peuvent √™tre d√©plac√©es.  La lumi√®re directionnelle n'a qu'une direction (un flux de rayons parall√®les venant de l'infini) et n'est pas li√©e √† une position sp√©cifique sur la sc√®ne.  OpenGL et OSG utilisent le quatri√®me composant du param√®tre de position pour sp√©cifier le type de source lumineuse.  S'il vaut 0, alors la lumi√®re est consid√©r√©e comme dirig√©e;  avec une valeur de 1 - positionnel. <br><br>  Prenons un petit exemple de travail avec l'√©clairage. <br><br><div class="spoiler">  <b class="spoiler_title">Cap de spoiler</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osg/LightSource&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLightSource(int num, const osg::Vec3 &amp;trans, const osg::Vec4 &amp;color) { osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = new osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); return sourceTrans.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); osg::Node *light0 = createLightSource(0, osg::Vec3(-20.0f, 0.0f, 0.0f), osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::Node *light1 = createLightSource(1, osg::Vec3(0.0f, -20.0f, 0.0f), osg::Vec4(0.0f, 1.0f, 1.0f, 1.0f)); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pour cr√©er une source de lumi√®re, nous avons une fonction distincte <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLightSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;trans, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec4 &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release(); }</code> </pre><br>  Dans cette fonction, nous d√©terminons d'abord les param√®tres d'√©clairage donn√©s par la source, cr√©ant ainsi l'attribut GL_LIGHTi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; <span class="hljs-comment"><span class="hljs-comment">//    light-&gt;setLightNum(num); //   light-&gt;setDiffuse(color); //  .     ,    light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f));</span></span></code> </pre><br>  Apr√®s cela, une source lumineuse est cr√©√©e √† laquelle cet attribut est affect√©. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light);</code> </pre><br>  Nous cr√©ons et configurons le n≈ìud de transformation, en lui passant notre source de lumi√®re comme n≈ìud enfant <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get());</code> </pre><br>  Retourne un pointeur sur le n≈ìud de transformation <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release();</code> </pre><br>  Dans le corps du programme principal, nous chargeons un mod√®le tridimensionnel (encore une fois, notre cessna pr√©f√©r√©) <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get());</code> </pre><br>  Nous cr√©ons deux sources lumineuses avec les nombres 0 et 1. La premi√®re brillera en jaune, la seconde - bleu-vert <br><br><pre> <code class="cpp hljs">osg::Node *light0 = createLightSource(<span class="hljs-number"><span class="hljs-number">0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::Node *light1 = createLightSource(<span class="hljs-number"><span class="hljs-number">1</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Nous informons la machine d'√©tat OpenGL qu'il est n√©cessaire d'activer les sources lumineuses 0 et 1 et d'ajouter les sources que nous avons cr√©√©es √† la sc√®ne <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1);</code> </pre><br>  Apr√®s avoir initialis√© et d√©marr√© la visionneuse, nous obtenons une image <br><br><img src="https://habrastorage.org/webt/0s/or/ph/0sorphad56jc2zc8iwfb591qcxk.png"><br><br><h1>  Conclusion </h1><br>  Tr√®s √©mu par l'attention des personnes int√©ress√©es √† ce cycle.  Cette action n'a pas beaucoup commenc√©, mais je pense que la communaut√© a besoin d'articles.  Merci pour toutes sortes de retours positifs. <br><br>  Aujourd'hui, j'ai essay√© de consid√©rer, encore une fois, les choses plut√¥t basiques du moteur OSG.  Je ne sais pas ce qui est sorti cool.  Mais jusqu'√† pr√©sent, j'expose des choses pr√©cis√©ment primitives, dans la veine o√π je les ai moi-m√™me comprises.  J'ai v√©rifi√© personnellement tous les exemples, mon r√©f√©rentiel est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Merci, chers coll√®gues, je vais essayer de continuer cette histoire ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430348/">https://habr.com/ru/post/fr430348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430336/index.html">En tant que programmeur, une nouvelle machine a √©t√© s√©lectionn√©e</a></li>
<li><a href="../fr430340/index.html">Nous attendons les √©couteurs d'Apple: AirPods 2019 et les pr√©visions des premiers-n√©s en taille r√©elle</a></li>
<li><a href="../fr430342/index.html">Goldratt et ravitaillement</a></li>
<li><a href="../fr430344/index.html">Dell XPS 15 9575: ordinateur portable convertible puissant et portable pour un travail s√©rieux</a></li>
<li><a href="../fr430346/index.html">Scrum et Agile ne sauveront pas votre projet de l'√©chec</a></li>
<li><a href="../fr430352/index.html">Premier certificat SSL utilisant des caract√®res cyrilliques</a></li>
<li><a href="../fr430354/index.html">Qu'est-ce que la Chine en avance sur les autres?</a></li>
<li><a href="../fr430356/index.html">√âv√©nements num√©riques √† Moscou du 19 au 25 novembre</a></li>
<li><a href="../fr430358/index.html">Le√ßon ouverte "Justification des activit√©s techniques"</a></li>
<li><a href="../fr430360/index.html">Pourquoi et pour qui la traduction automatique convient-elle?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>