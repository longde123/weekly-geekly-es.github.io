<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚ÄçüöÄ üóΩ üöû Implementasi Tipe String di CPython üë∏ üòò üöµüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan melanjutkan analisis yang tidak tergesa-gesa tentang implementasi tipe dasar dalam CPython, kamus dan bilangan bulat sebelumnya dipertimbang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi Tipe String di CPython</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480324/">  Saya akan melanjutkan analisis yang tidak tergesa-gesa tentang implementasi tipe dasar dalam CPython, <a href="https://habr.com/en/post/432996/">kamus</a> dan <a href="https://habr.com/en/post/455114/">bilangan bulat</a> sebelumnya dipertimbangkan.  Mereka yang berpikir bahwa tidak ada yang menarik dan licik dalam penerapannya didorong untuk bergabung dengan artikel ini.  Mereka yang sudah membacanya tahu bahwa CPython memiliki banyak fitur menarik dan fitur implementasi.  Mereka dapat bermanfaat untuk diketahui saat menulis skrip Anda sendiri, atau sebagai panduan untuk solusi arsitektur dan algoritmik.  String tidak terkecuali di sini. <br><br><img src="https://habrastorage.org/webt/3m/lq/kc/3mlqkcmwvt31uagvuvhdqek1rp4.png"><br><a name="habracut"></a><br>  Mari kita mulai dengan penyimpangan singkat ke dalam sejarah.  Python muncul pada 1990-91.  Awalnya, ketika mengembangkan basis encoding di python, ada satu byte, ascii tua yang bagus.  Tetapi, pada waktu yang hampir bersamaan (sesaat kemudian), umat manusia sudah lelah berurusan dengan ‚Äúkebun binatang‚Äù penyandian, dan pada tahun 1991 standar Unicode diusulkan.  Namun, pertama kali juga, itu tidak berhasil.  Pengenalan pengkodean dua byte dimulai, tetapi segera menjadi jelas bahwa dua byte tidak akan cukup untuk semua orang, pengodean 4 byte diusulkan.  Sayangnya, mengalokasikan 4 byte untuk setiap karakter tampak seperti pemborosan ruang disk dan memori, terutama di negara-negara di mana satu byte ascii sudah cukup sebelumnya.  Beberapa kruk digergaji menjadi pengodean 2-byte untuk mendukung lebih banyak karakter, dan semua ini mulai menyerupai situasi sebelumnya dengan ‚Äúkebun binatang‚Äù penyandian. <br><br>  Tetapi pada tahun 1993 utf-8 diperkenalkan.  Yang merupakan kompromi: ascii adalah himpunan bagian yang valid dari utf-8, semua karakter lain memperluasnya, namun, untuk mendukung kemungkinan ini, saya harus berpisah dengan panjang tetap masing-masing karakter.  Tetapi dialah yang ditakdirkan untuk <s>memerintah semua orang</s> untuk menjadi Unicode, yaitu, satu pengkodean didukung oleh sebagian besar program di mana sebagian besar file disimpan.  Ini terutama dipengaruhi oleh perkembangan Internet, karena halaman web biasanya digunakan hanya utf-8. <br><br>  Dukungan untuk pengkodean ini secara bertahap diperkenalkan ke bahasa pemrograman yang, seperti python, dikembangkan sebelum utf-8, dan oleh karena itu digunakan pengkodean lainnya.  Ada <a href="https://www.python.org/dev/peps/pep-0100/" rel="nofollow">PEP</a> dengan angka 100 bagus yang membahas dukungan Unicode.  Dan dalam <a href="https://www.python.org/dev/peps/pep-0263/" rel="nofollow">PEP-0263</a> menjadi mungkin untuk mendeklarasikan penyandian file sumber.  Pengodean masih merupakan pengkodean dasar, awalan `u` digunakan untuk menyatakan string unicode, bekerja dengan mereka masih tidak nyaman dan cukup alami.  Tetapi ada kesempatan untuk menciptakan bid'ah berikut: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ÎπÑÎπîÎ∞•:</span></span> _ = <span class="hljs-number"><span class="hljs-number">2</span></span> ◊ê = ÎπÑÎπîÎ∞•() print(◊ê)</code> </pre> <br>  Pada 3 Desember 2008, sebuah peristiwa bersejarah terjadi untuk seluruh komunitas python (dan mengingat betapa luasnya bahasa ini telah menyebar sekarang, lalu, mungkin, untuk seluruh dunia) - python 3. dirilis. Diputuskan untuk mengakhiri masalah sekali dan untuk semua karena banyak penyandian, dan karenanya Unicode telah menjadi basis penyandian.  Tetapi kita ingat bahwa pengkodean itu rumit dan tidak berhasil pertama kali.  Kali ini tidak berhasil. <br><br>  Kelemahan utama utf-8 adalah bahwa panjang karakter tidak tetap, yang mengarah pada fakta bahwa operasi sederhana seperti mengakses indeks memiliki kompleksitas O (N), karena offset elemen tidak diketahui sebelumnya, selain itu, mengetahui ukuran buffer, dialokasikan untuk menyimpan string, Anda tidak dapat menghitung panjangnya dalam karakter. <br><br>  Untuk menghindari semua masalah ini dalam python, diputuskan untuk menggunakan pengkodean 2 dan 4 byte (tergantung pada platform).  Penanganan indeks disederhanakan - hanya perlu mengalikan indeks dengan 2 atau 4. Namun, ini memerlukan masalah: <br><br><ol><li>  Setiap platform memiliki encoding sendiri, yang dapat menyebabkan masalah dengan portabilitas kode </li><li>  Peningkatan konsumsi memori dan / atau masalah penyandian untuk karakter rumit yang tidak cocok menjadi dua byte </li></ol><br>  Solusi untuk masalah ini diusulkan dalam <a href="https://www.python.org/dev/peps/pep-0393/" rel="nofollow">PEP-393</a> , dan kami akan membicarakannya. <br><br>  Diputuskan untuk meninggalkan garis sebagai array karakter, untuk memfasilitasi akses dengan indeks dan operasi lainnya, namun, panjang karakter mulai bervariasi.  Saat membuat string, interpreter memindai semua karakter dan mengalokasikan untuk setiap jumlah byte yang diperlukan untuk menyimpan yang "terbesar", yaitu, jika Anda mendeklarasikan string ascii, maka semua karakter akan menjadi byte tunggal, namun, jika Anda memutuskan untuk menambahkan satu karakter ke string dari Cyrillic, semua karakter sudah dua byte.  Ada tiga opsi yang mungkin: 1, 2, dan 4 byte per karakter. <br><br>  Jenis string (PyUnicodeObject) dideklarasikan <a href="" rel="nofollow">sebagai berikut</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Strings allocated through PyUnicode_FromUnicode(NULL, len) use the PyUnicodeObject structure. The actual string data is initially in the wstr block, and copied into the data block using _PyUnicode_Ready. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyCompactUnicodeObject _base; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; } data; <span class="hljs-comment"><span class="hljs-comment">/* Canonical, smallest-form Unicode buffer */</span></span> } PyUnicodeObject;</code> </pre><br>  Pada gilirannya, PyCompactUnicodeObject mewakili <a href="" rel="nofollow">struktur berikut</a> (disediakan dengan beberapa penyederhanaan dan komentar saya): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    ascii  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyASCIIObject _base; Py_ssize_t utf8_length; <span class="hljs-comment"><span class="hljs-comment">/*    utf-8  (  \0 )*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *utf8; <span class="hljs-comment"><span class="hljs-comment">/* UTF-8  ( \0 )*/</span></span> Py_ssize_t wstr_length; <span class="hljs-comment"><span class="hljs-comment">/*  code point  wstr. */</span></span> } PyCompactUnicodeObject; <span class="hljs-comment"><span class="hljs-comment">/*   ascii  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-comment"><span class="hljs-comment">/*   (     ) */</span></span> Py_ssize_t length; <span class="hljs-comment"><span class="hljs-comment">/*  code point   */</span></span> Py_hash_t hash; <span class="hljs-comment"><span class="hljs-comment">/*   -1,      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* SSTATE_NOT_INTERNED (0) SSTATE_INTERNED_MORTAL (1) SSTATE_INTERNED_IMMORTAL (2) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> interned:<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  : - PyUnicode_WCHAR_KIND (0): * wchar_t (16  32 ,     ( )) - PyUnicode_1BYTE_KIND (1): - PyUnicode_2BYTE_KIND (2): - PyUnicode_4BYTE_KIND (4): */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kind:<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ( ,        ,   -  data   ). */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compact:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*       U+0000-U+007F (ASCII) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ascii:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,    ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ready:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> :<span class="hljs-number"><span class="hljs-number">24</span></span>; } state; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> *wstr; <span class="hljs-comment"><span class="hljs-comment">/* wchar_t  (  \0 ) */</span></span> } PyASCIIObject;</code> </pre><br>  Jadi, 4 representasi garis dimungkinkan: <br><br><ol><li>  string lawas, siap <br><br><pre> <code class="markdown hljs"> <span class="hljs-bullet"><span class="hljs-bullet">* structure = PyUnicodeObject structure *</span></span>   : !PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_IS_</span></span>COMPACT(op) &amp;&amp; kind != PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_WCHAR_</span></span>KIND <span class="hljs-bullet"><span class="hljs-bullet">* kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND *</span></span> compact = 0 <span class="hljs-bullet"><span class="hljs-bullet">* ready = 1 *</span></span> data.any is not NULL <span class="hljs-bullet"><span class="hljs-bullet">* utf8   data.any  utf8_length = length  ascii = 1 *</span></span> utf8<span class="hljs-emphasis"><span class="hljs-emphasis">_length = 0  utf8 is NULL * wstr   with data.any  wstr_</span></span>length = length  kind=PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_2BYTE_</span></span>KIND and sizeof(wchar<span class="hljs-emphasis"><span class="hljs-emphasis">_t)=2 or if kind=PyUnicode_</span></span>4BYTE<span class="hljs-emphasis"><span class="hljs-emphasis">_KIND and sizeof(wchar_</span></span>4)=4 * wstr_length = 0  wstr is NULL</code> </pre></li><li>  string lawas, belum siap <br><br><pre> <code class="markdown hljs"> <span class="hljs-bullet"><span class="hljs-bullet">* structure = PyUnicodeObject *</span></span>   : kind == PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_WCHAR_</span></span>KIND <span class="hljs-bullet"><span class="hljs-bullet">* length = 0 (use wstr_length) *</span></span> hash = -1 <span class="hljs-bullet"><span class="hljs-bullet">* kind = PyUnicode_WCHAR_KIND *</span></span> compact = 0 <span class="hljs-bullet"><span class="hljs-bullet">* ascii = 0 *</span></span> ready = 0 <span class="hljs-bullet"><span class="hljs-bullet">* interned = SSTATE_NOT_INTERNED *</span></span> wstr is not NULL <span class="hljs-bullet"><span class="hljs-bullet">* data.any is NULL *</span></span> utf8 is NULL * utf8_length = 0</code> </pre></li><li>  ascii kompak <br><br><pre> <code class="markdown hljs"> <span class="hljs-bullet"><span class="hljs-bullet">* structure = PyASCIIObject *</span></span>   : PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_IS_</span></span>COMPACT<span class="hljs-emphasis"><span class="hljs-emphasis">_ASCII(op) * kind = PyUnicode_</span></span>1BYTE_KIND <span class="hljs-bullet"><span class="hljs-bullet">* compact = 1 *</span></span> ascii = 1 <span class="hljs-bullet"><span class="hljs-bullet">* ready = 1 *</span></span> (length ‚Äî  utf8  wstr ) <span class="hljs-bullet"><span class="hljs-bullet">* (data    ) *</span></span> (  ascii    utf8 string   data)</code> </pre></li><li>  padat <br><br><pre> <code class="markdown hljs"> <span class="hljs-bullet"><span class="hljs-bullet">* structure = PyCompactUnicodeObject *</span></span>   : PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_IS_</span></span>COMPACT(op) &amp;&amp; !PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_IS_</span></span>ASCII(op) <span class="hljs-bullet"><span class="hljs-bullet">* kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND *</span></span> compact = 1 <span class="hljs-bullet"><span class="hljs-bullet">* ready = 1 *</span></span> ascii = 0 <span class="hljs-bullet"><span class="hljs-bullet">* utf8  data  *</span></span> utf8<span class="hljs-emphasis"><span class="hljs-emphasis">_length = 0  utf8 is NULL * wstr   data  wstr_</span></span>length=length  kind=PyUnicode<span class="hljs-emphasis"><span class="hljs-emphasis">_2BYTE_</span></span>KIND and sizeof(wchar<span class="hljs-emphasis"><span class="hljs-emphasis">_t)=2 or if kind=PyUnicode_</span></span>4BYTE<span class="hljs-emphasis"><span class="hljs-emphasis">_KIND and sizeof(wchar_</span></span>t)=4 <span class="hljs-bullet"><span class="hljs-bullet">* wstr_length = 0  wstr is NULL *</span></span> (data    )</code> </pre></li></ol><br>  Perlu dicatat bahwa python 3 juga mendukung sintaksis untuk mendeklarasikan string unicode melalui awalan `u`. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>b = <span class="hljs-string"><span class="hljs-string">u""</span></span> &gt;&gt;&gt; b <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre><br>  Fitur ini ditambahkan untuk memfasilitasi kode porting dari versi kedua ke yang ketiga dalam <a href="https://www.python.org/dev/peps/pep-0414/" rel="nofollow">PEP-414</a> hanya dalam Februari 2012, izinkan saya mengingatkan Anda bahwa python 3 dirilis pada Desember 2008, tetapi tidak ada yang terburu-buru dengan transisi. <br><br>  Berbekal pengetahuan ini dan modul ctypes standar, kita dapat mengakses bidang internal string. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interned</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(enum.Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># SSTATE_NOT_INTERNED (0) # SSTATE_INTERNED_MORTAL (1) # SSTATE_INTERNED_IMMORTAL (2) # If interned != SSTATE_NOT_INTERNED, the two references from the # dictionary to this object are *not* counted in ob_refcnt. SSTATE_NOT_INTERNED = 0 SSTATE_INTERNED_MORTAL = 1 SSTATE_INTERNED_IMMORTAL = 2 class Kind(enum.Enum): PyUnicode_WCHAR_KIND = 0 PyUnicode_1BYTE_KIND = 1 PyUnicode_2BYTE_KIND = 2 PyUnicode_4BYTE_KIND = 4 # PyUnicodeObject class StrStruct(ctypes.Structure): _fields_ = [("refcnt", ctypes.c_long), ("type", ctypes.c_void_p), ("length", ctypes.c_long), ("hash", ctypes.c_void_p), # ascii fields ("_interned", ctypes.c_uint, 2), ("_kind", ctypes.c_uint, 3), ("compact", ctypes.c_uint, 1), ("ascii", ctypes.c_uint, 1), ("ready", ctypes.c_uint, 1), ("_rest_state", ctypes.c_uint, 16), # for future use ("wstr", ctypes.c_wchar_p), # PyCompactUnicodeObject ("utf8_length", ctypes.c_ssize_t), # Number of bytes in utf8, excluding the terminating \0. ("utf8", ctypes.c_char_p), ("wstr_length", ctypes.c_ssize_t), # Number of code points ("data", ctypes.c_void_p) # canonical, smallest-form Unicode buffer ] _printable_fields = ("refcnt", "length", "hash", "interned", "kind", "compact", "ascii", "ready", "wstr", "utf8_length", "utf8", "wstr_length", "data") @property def interned(self): return Interned(self._interned) @property def kind(self): return Kind(self._kind) def __repr__(self): new_line = '\n' # f-string expression part cannot include a backslash return f"StrStruct({new_line.join(f'{key}={getattr(self, key)}' for key in self._printable_fields)})" if __name__ == '__main__': string = sys.argv[1] s = StrStruct.from_address(id(string)) print(s)</span></span></code> </pre><br>  Dan bahkan "mematahkan" penerjemah, seperti yang Anda lakukan pada bagian <a href="https://habr.com/en/post/455114/">sebelumnya</a> . <br><br>  PENOLAKAN: Kode berikut diberikan sebagaimana adanya, penulis tidak bertanggung jawab dan tidak dapat menjamin keadaan penerjemah, serta kesehatan mental Anda dan kolega Anda, setelah menjalankan kode ini.  Kode ini diuji pada cpython versi 3.7 dan, sayangnya, tidak berfungsi dengan string ascii. <br><br>  Untuk melakukan ini, ubah kode yang dijelaskan di atas menjadi: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_some_magic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str1, str2)</span></span></span><span class="hljs-function">:</span></span> s1 = StrStruct.from_address(id(str1)) s2 = StrStruct.from_address(id(str2)) s2.data = s1.data <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: string = <span class="hljs-string"><span class="hljs-string">"ÎπÑÎπîÎ∞•"</span></span> string2 = <span class="hljs-string"><span class="hljs-string">"h√°ƒç"</span></span> print(string == string2) <span class="hljs-comment"><span class="hljs-comment"># False make_some_magic(string, string2) print(string == string2) # True</span></span></code> </pre><br><br>  Contoh-contoh ini menggunakan interpolasi string yang ditambahkan dalam <a href="https://www.python.org/dev/peps/pep-0498/" rel="nofollow">python 3.6</a> .  Python tidak segera datang ke metode ini menghasilkan string:% sintaks, format, sesuatu yang <a href="https://www.python.org/dev/peps/pep-3101/" rel="nofollow">mirip</a> dicoba (deskripsi yang lebih rinci dengan contoh-contoh dapat ditemukan di <a href="https://habr.com/en/post/421993/">sini</a> ). <br>  Mungkin perubahan ini untuk waktunya (sebelum python 3.8 dengan operator `: =`) adalah yang paling kontroversial.  Diskusi (dan kecaman) dilakukan baik pada <a href="https://www.reddit.com/r/Python/comments/3k6qi8/pep_498_approved/" rel="nofollow">reddit</a> dan bahkan dalam bentuk <a href="https://www.python.org/dev/peps/pep-0502/" rel="nofollow">PEP</a> .  Gagasan perbaikan / koreksi diungkapkan dalam bentuk menambahkan <a href="https://www.python.org/dev/peps/pep-0501/" rel="nofollow">garis-i</a> yang dapat digunakan pengguna untuk menulis parser, untuk kontrol yang lebih baik dan untuk menghindari injeksi SQL dan masalah lainnya.  Namun, perubahan ini ditunda, sehingga orang terbiasa dengan f-line dan mengidentifikasi masalah, jika ada. <br><br>  F-lines memiliki satu kekhasan (drawback): Anda tidak dapat menentukan karakter khusus dengan garis miring di dalamnya, misalnya, '\ n' '\ t'.  Namun, ini dapat dengan mudah dielakkan dengan mendeklarasikan baris terpisah yang berisi karakter khusus dan meneruskannya ke f-line, yang dilakukan pada contoh di atas, tetapi Anda dapat menggunakan tanda kurung bersarang. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>number = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; precision = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{number:.{precision}</span></span></span><span class="hljs-string">f}"</span></span> <span class="hljs-number"><span class="hljs-number">2.000</span></span> <span class="hljs-comment"><span class="hljs-comment"># , format     &gt;&gt;&gt; "{:{}f}".format(number, precision) 2.000</span></span></code> </pre><br>  Seperti yang Anda lihat, string menyimpan hash mereka, ada <a href="https://mail.python.org/pipermail/python-dev/2012-October/122238.html%2B%26cd%3D1%26hl%3Den%26ct%3Dclnk%26gl%3Dru%26client%3Dfirefox-b-d" rel="nofollow">saran untuk</a> menggunakan nilai ini untuk membandingkan string, berdasarkan aturan sederhana: jika string adalah sama, maka mereka memiliki hash yang sama, dan itu berarti bahwa string dengan hash yang berbeda tidak sama.  Namun, itu tetap tidak terpenuhi. <br><br>  Ketika membandingkan dua string, diperiksa apakah pointer ke string merujuk ke alamat yang sama, jika tidak, maka perbandingan karakter-per-karakter atau memcmp dimulai dalam kasus di mana hal ini diizinkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PyUnicode_Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PyObject *left, PyObject *right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PyUnicode_Check(left) &amp;&amp; PyUnicode_Check(right)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PyUnicode_READY(left) == <span class="hljs-number"><span class="hljs-number">-1</span></span> || PyUnicode_READY(right) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unicode_compare(left, right); <span class="hljs-comment"><span class="hljs-comment">//    memcmp }   }</span></span></code> </pre> <br>  Namun, nilai hash secara tidak langsung mempengaruhi perbandingan.  Faktanya adalah bahwa di cpython, string diinternir, yaitu disimpan dalam satu kamus.  Ini tidak benar untuk semua baris, semua konstanta, kunci kamus, bidang dan variabel, dan garis ascii dengan panjang kurang dari 20 diinternir. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: string = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] string2 = sys.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] print(id(string) == id(string2))</code> </pre><br><pre> <code class="plaintext hljs">$ python check_interned.py aa True $ python check_interned.py ÎπÑÎπîÎ∞• ÎπÑÎπîÎ∞• False $ python check_interned.py aaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaa False</code> </pre><br>  Dan senar kosong umumnya singleton <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PyUnicodeObject * _PyUnicode_New(Py_ssize_t length) { PyUnicodeObject *unicode; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_size; <span class="hljs-comment"><span class="hljs-comment">/* Optimization for empty strings */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; unicode_empty != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { Py_INCREF(unicode_empty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (PyUnicodeObject*)unicode_empty; } ... }</code> </pre><br>  Seperti yang dapat kita lihat, cpython mampu membuat implementasi string yang efisien, tetapi pada saat yang sama.  Dimungkinkan untuk mengurangi memori yang digunakan dan mempercepat operasi dalam beberapa kasus, berkat memcmp, fungsi memcpy, alih-alih operasi karakter demi karakter.  Seperti yang Anda lihat, tipe string sama sekali tidak semudah diimplementasikan seperti yang terlihat pertama kali.  Tetapi pengembang cpython telah cukup mendekati bisnis mereka dan oleh karena itu kita dapat menggunakannya dan bahkan tidak berpikir tentang apa yang ada di balik tudung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480324/">https://habr.com/ru/post/id480324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480306/index.html">Mengapa mengalahkan pintu yang tertutup?</a></li>
<li><a href="../id480310/index.html">Detektif Habra: rahasia editor berita</a></li>
<li><a href="../id480316/index.html">Cara mengurangi konsumsi modul wifi hingga sepuluh kali atau lebih</a></li>
<li><a href="../id480318/index.html">Pilihan acara gratis mendatang untuk pengembang di Moskow # 3 (16-24 Desember)</a></li>
<li><a href="../id480320/index.html">Sepuluh tahun ONYX di Rusia - bagaimana teknologi, pembaca, dan pasar telah berubah selama ini</a></li>
<li><a href="../id480326/index.html">F5 Networks Corporation mengirimkan surat kepada pelanggannya untuk memberi tahu mereka tentang situasi saat ini dengan NGINX</a></li>
<li><a href="../id480328/index.html">Bagaimana cara berteman PyTorch dan C ++. Menggunakan TorchScript</a></li>
<li><a href="../id480330/index.html">Alat penilaian karyawan yang ideal</a></li>
<li><a href="../id480332/index.html">Analisis data pemungutan suara blockchain 2019 di Duma Kota Moskow</a></li>
<li><a href="../id480334/index.html">QtQML / panel korelasi cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>