<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏻 👀 👂🏻 Monorepositórios: por favor 🔅 👨🏻‍🎨 🙆🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma tradução do artigo foi preparada para os alunos do curso DevOps Practices and Tools no projeto educacional OTUS . 



 Você deve escolher um mono-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monorepositórios: por favor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453958/"><p><img src="https://habrastorage.org/webt/zb/qs/gu/zbqsgutqkd38ocudlbvzx5zeldc.png" alt="imagem"></p><br><p>  <em>Uma tradução do artigo foi preparada para os alunos do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOps Practices and Tools no</a> projeto educacional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OTUS</a> .</em> </p><br><hr><br><p>  Você deve escolher um mono-repositório, porque o comportamento que ele promove em suas equipes é a transparência e a responsabilidade coletiva, especialmente quando as equipes crescem.  De qualquer forma, você terá que investir em ferramentas, mas é sempre melhor quando o comportamento padrão é o que você deseja ver em seus comandos. <a name="habracut"></a></p><br><h1 id="pochemu-my-govorim-ob-etom">  Por que estamos falando sobre isso? </h1><br><p>  Matt Klein escreveu um artigo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Monorepos: Por favor, não!"</a>  (comentário do tradutor: tradução em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hub "Monorepositórios: por favor, não"</a> ).  Eu gosto de Matt, acho que ele é muito inteligente, e você deve ler o ponto de vista dele.  Ele originalmente twittou a enquete: </p><br><p><img src="https://habrastorage.org/webt/x2/pl/sm/x2plsmnmw3xzn-hoeo7ksirx1rm.png" alt="imagem"></p><br><p>  <em>Tradução:</em> <br>  <em>Neste dia de ano novo, discutirei sobre o quão ridículos são os monorepositórios.</em>  <em>2019 começou despercebido.</em>  <em>Nesse espírito, ofereço-lhe uma pesquisa.</em>  <em>Quem são os grandes fanáticos?</em>  <em>Apoiantes:</em> <br>  - <em>Monorepositório</em> <br>  - <em>Ferrugem</em> <br>  - <em>Inquérito errado / aqueles e aqueles</em> </p><br><p>  Minha resposta foi: "Eu literalmente sou essas duas pessoas".  Em vez de falar sobre que tipo de droga Rust, vamos descobrir por que acho que ele está errado sobre os mono-repositórios.  Um pouco sobre você.  Eu sou o CTO do Chef Software.  Temos cerca de 100 engenheiros, uma base de código de 11 a 12 anos e 4 produtos principais.  Parte desse código está no poli-repositório (minha posição inicial), parte no monorepositório (minha posição atual). </p><br><p>  Antes de começar: todo argumento que cito aqui será aplicado aos dois tipos de repositórios.  Na minha opinião, não há razões técnicas para você escolher um ou outro tipo de repositório.  Você pode fazer qualquer abordagem funcionar.  Fico feliz em falar sobre isso, mas não estou interessado nas razões técnicas artificiais pelas quais uma é superior à outra. </p><br><p>  Eu concordo com a primeira parte do ponto de vista de Matt: </p><br><p>  <em>Como, em grande escala, o monorepositório resolverá todos os mesmos problemas que o poli-repositório, mas ao mesmo tempo, provocará uma forte coerência do seu código e exigirá esforços incríveis para aumentar a escalabilidade do seu sistema de controle de versão.</em> </p><br><p>  Você precisa resolver os mesmos problemas, independentemente de escolher um monorepositório ou poli-repositório.  Como você libera lançamentos?  Qual é a sua abordagem para atualizações?  Compatível com versões anteriores?  Dependências entre projetos?  Quais estilos de arquitetura são aceitáveis?  Como você gerencia sua infraestrutura de construção e teste?  A lista é interminável.  E você resolverá todos eles à medida que crescer.  Não há queijo grátis. </p><br><p>  Eu acho que o argumento de Matt é semelhante às opiniões compartilhadas por muitos engenheiros (e gerentes) que eu respeito.  Isso acontece do ponto de vista do engenheiro que trabalha no componente ou da equipe que trabalha no componente.  Você ouve coisas como: </p><br><ul><li>  A base de código é complicada - não preciso de todo esse lixo. </li><li> Isso é mais difícil de testar porque tenho que verificar todo esse lixo que não preciso. </li><li>  É mais difícil trabalhar com dependências externas. </li><li>  Eu preciso dos meus próprios sistemas de controle de versão virtual. </li></ul><br><p>  Claro, todos esses pontos são razoáveis.  Isso acontece nos dois casos - no poli-repositório, eu tenho minhas próprias coisas, além do que é necessário para a montagem ... Eu também posso precisar de outras coisas.  Portanto, "apenas" crio ferramentas que fazem checkout de todo o projeto.  Ou estou criando um repositório mono falso com submódulos.  Nós poderíamos andar o dia todo por isso.  Mas acho que o argumento de Matt erra o principal motivo, que eu quase virei a favor do monorepositório: </p><br><h1 id="on-provociruet-obschenie-i-pokazyvaet-problemy">  Provoca comunicação e mostra problemas. </h1><br><p>  Quando compartilhamos repositórios, de fato criamos um problema de coordenação e transparência.  Isso corresponde à maneira como pensamos sobre as equipes (especialmente à maneira como os participantes pensam sobre elas): somos responsáveis ​​por um componente específico.  Trabalhamos em relativo isolamento.  Os limites são fixos na minha equipe e nos componentes em que estamos trabalhando. </p><br><p>  Com a complexidade da arquitetura, uma equipe não pode mais gerenciá-la sozinha.  Muito poucos engenheiros mantêm todo o sistema em mente.  Suponha que você controle um componente comum A, usado pelos comandos B, C e D. Os refatoradores da equipe A, aprimoram a API e também alteram a implementação interna.  Como resultado, as mudanças são incompatíveis com versões anteriores.  Que conselho você daria? </p><br><ul><li>  Encontre todos os lugares onde a API antiga é usada. </li><li>  Existem lugares onde a nova API não pode ser usada? </li><li>  Você pode consertar e testar outros componentes para garantir que eles não quebrem? </li><li>  Essas equipes podem verificar suas alterações agora? </li></ul><br><p>  Observe que essas perguntas são independentes do tipo de repositório.  Você precisará encontrar as equipes B, C e D. Você precisará conversar com elas, descobrir o tempo, entender suas prioridades.  Pelo menos, esperamos que você faça isso. </p><br><p>  Ninguém realmente quer fazer isso.  Isso é muito menos divertido do que apenas consertar a maldita API.  Tudo isso é humano e confuso.  No repositório, você pode simplesmente fazer alterações, revisar aqueles que estão trabalhando neste componente (provavelmente não B, C ou D) e seguir em frente.  As equipes B, C e D podem simplesmente permanecer na versão atual.  Eles serão atualizados quando perceberem seu gênio! </p><br><p>  Em um único repositório, a responsabilidade é alterada por padrão.  A equipe A altera seu componente e, se não tomar cuidado, interrompe imediatamente B, C e D. Isso faz com que B, C e D apareçam na porta A, perguntando-se por que a equipe A interrompeu a montagem.  Isso ensina A que eles não podem pular minha lista acima.  Eles devem falar sobre o que vão fazer.  B, C e D podem se mover?  E se B e C puderem, mas D estiver intimamente relacionado a um efeito colateral do antigo algoritmo? </p><br><p>  Então precisamos conversar sobre como saímos dessa situação: </p><br><ol><li>  Suporte para várias APIs internas, enquanto o algoritmo antigo será marcado como obsoleto até que D possa parar de usá-lo. </li><li>  Suporte para várias versões de versões, uma com a interface antiga e outra com a nova. </li><li>  Liberação atrasada das alterações em A até que B, C e D possam aceitá-la. </li></ol><br><p>  Suponha que selecionemos 1, várias APIs.  Nesse caso, temos dois pedaços de código.  Velho e novo.  Muito útil em algumas situações.  Retornamos o código antigo, marcamos como obsoleto e concordamos com uma programação para sua remoção com o comando D. É essencialmente idêntico para poli e para o mono-repositório. </p><br><p>  Para lançar várias versões, precisamos de um ramo.  Agora temos dois componentes - A1 e A2.  As equipes B e C usam A2 e D usa A1.  Precisamos que cada componente esteja pronto para o lançamento, porque antes que o D possa seguir em frente, podem ser necessárias atualizações de segurança e outras correções.  No repositório, podemos ocultá-lo em um ramo de longa duração que se sente bem.  No mono-repositório, forçamos o código no novo módulo.  A equipe D ainda precisará fazer alterações no componente "antigo".  Todos podem ver o custo que pagamos aqui - agora temos o dobro do código e quaisquer correções de erros que se apliquem a A1 e A2 devem ser aplicadas a ambos.  Com a abordagem de usar ramificações em um repositório, isso está oculto por trás da seleção de cereja.  Consideramos o custo menor porque não há duplicação.  Do ponto de vista prático, o custo é o mesmo: você criará, liberará e manterá duas bases de código basicamente idênticas até poder excluir uma delas.  A diferença é que, no monorepositório, essa dor é direta e visível.  <strong>Isso é ainda pior e bom.</strong> </p><br><p>  Finalmente, chegamos ao terceiro ponto.  Atraso de liberação.  É possível que as alterações feitas por A melhorem a vida da equipe A. É importante, mas não urgente.  Podemos apenas aguentar?  No repositório, estamos pressionando isso para consolidar o artefato.  Claro, estamos falando sobre esse time D. Apenas fique na versão antiga até você se atualizar!  Isso cria um jogo covarde.  A equipe A continua trabalhando no seu componente, ignorando o fato de que a equipe D está usando uma versão cada vez mais desatualizada (esse é um problema para a equipe D, eles são estúpidos).  Enquanto isso, a equipe D está falando mal da atitude descuidada da equipe A em relação à estabilidade do código, se é que falam sobre isso.  Meses se passam.  Finalmente, a equipe D decide dar uma olhada na opção de atualização, mas há apenas mais alterações em A.  A equipe A mal lembra quando e como eles quebraram D. A atualização é mais dolorosa e levará mais tempo.  O que o envia mais abaixo na pilha de prioridades.  Até aquele dia, até que tenhamos um problema de segurança em A, o que nos força a fazer uma filial.  A equipe A deve voltar no tempo, encontrar o momento em que D estava estável, corrigir o problema e prepará-lo para o lançamento.  <strong>Essa é a escolha de fato que as pessoas fazem, e é de longe a pior.</strong>  Isso parece ser bom para as equipes A e D, desde que possamos nos ignorar. </p><br><p>  No monorepositório, o terceiro não é realmente uma opção.  Você é forçado a lidar com a situação de duas maneiras.  Você precisa ver os custos de ter duas ramificações de liberação.  Aprenda a se proteger de atualizações que quebram a compatibilidade com versões anteriores.  Mas a principal coisa: <em>você não pode evitar uma conversa difícil.</em> </p><br><p>  Na minha experiência, quando as equipes se tornam grandes, não é mais possível manter todo o sistema em mente, e essa é a parte mais importante.  Você precisa melhorar a visibilidade das divergências no sistema.  Você deve trabalhar ativamente para que as equipes desviem os olhos dos componentes e examinem o trabalho de outras equipes e consumidores. </p><br><p>  Sim, você pode criar ferramentas que tentarão resolver o problema dos poli-repositórios.  Mas minha experiência no ensino da entrega e automação contínuas em grandes empresas me diz o seguinte: o comportamento padrão sem o uso de ferramentas adicionais é o que você espera ver.  <strong>O comportamento padrão do repositório é o isolamento, esse é o ponto.</strong>  <strong>O comportamento padrão de um mono-repositório é responsabilidade e transparência compartilhadas, esse é o ponto.</strong>  Nos dois casos, vou criar uma ferramenta que suavizará cantos afiados.  Como líder, sempre escolherei um mono-repositório, porque os instrumentos devem fortalecer a cultura que eu quero, e a cultura vem de pequenas decisões e do trabalho diário da equipe. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453958/">https://habr.com/ru/post/pt453958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453942/index.html">Sobre ética com o exemplo do PMI Codex</a></li>
<li><a href="../pt453944/index.html">Erros mascarados no embedd</a></li>
<li><a href="../pt453950/index.html">Você deveria estar aqui! 22 anos do lançamento do lendário jogo Duke Nukem 3D</a></li>
<li><a href="../pt453952/index.html">“A solicitação amadureceu”: Alexei Fedorov sobre uma nova conferência sobre sistemas distribuídos</a></li>
<li><a href="../pt453956/index.html">Museum DataArt. Terminal de vídeo ADM-3A. O carro é pesado, confiável, abate</a></li>
<li><a href="../pt453960/index.html">Global DevOps Bootcamp 2019 em Moscou</a></li>
<li><a href="../pt453962/index.html">RxSwift e Coroutines na Kotlin - desenvolvimento móvel opcional da AGIMA e GeekBrains</a></li>
<li><a href="../pt453964/index.html">POO na linguagem R (parte 1): classes S3</a></li>
<li><a href="../pt453968/index.html">Desaprender práticas de revisão de código tóxico</a></li>
<li><a href="../pt453970/index.html">Escrevemos o proxy reverso socks5 no PowerShell.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>