<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👦 👨🏻‍⚖️ 🌷 Implementierung des WCF-Verbindungspools für .Net Core mithilfe von HttpClientFactory 🤙🏽 🚱 🍫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unser Produkt wurde auf der .Net Core 2.2-Plattform unter Verwendung von WCF 4.5 für die Interaktion mit dem SOAP-Client-Service entwickelt. Während d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung des WCF-Verbindungspools für .Net Core mithilfe von HttpClientFactory</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/465255/">  Unser Produkt wurde auf der .Net Core 2.2-Plattform unter Verwendung von WCF 4.5 für die Interaktion mit dem SOAP-Client-Service entwickelt.  Während des Dienstes stellten die Datenbusentwickler eine hohe Belastung des Servers fest.  Außerdem traten Probleme beim Zugriff auf den Dienst auf.  Als Ergebnis wurde festgestellt, dass der Grund in der Anzahl der Wirkstoffe liegt. <br><br>  Es gibt ein Problem wie die Erschöpfung der Verbindung.  Dies kann auf das Fehlen verfügbarer Ports beim Herstellen einer Verbindung oder auf die Begrenzung der Anzahl der Verbindungen zu externen oder internen Diensten zurückzuführen sein.  Es gibt zwei Lösungen: <br><br>  • Erhöhung der verfügbaren Ressourcen, <br>  • Reduzierung der Anzahl der Verbindungen. <br><br>  Die erste Option steht uns nicht zur Verfügung, da eine Erhöhung der Ressourcen nur auf Seiten des Dienstleisters erfolgen kann.  Aus diesem Grund haben wir uns entschlossen, nach Optionen zur Optimierung der Anzahl der Verbindungen zu suchen.  In diesem Artikel werden wir über die gefundene Lösung sprechen. <br><br><img src="https://habrastorage.org/webt/pp/zw/sq/ppzwsq2l98gcj1dkq5enfnbsslk.jpeg"><br><a name="habracut"></a><br><h2>  Idee </h2><br>  Wie sich herausstellte, bestand das Problem darin, dass wir für jede Anforderung eine neue Instanz des WCF-Clients erstellt haben.  Dies machte es unmöglich, den bereits in WCF implementierten Verbindungspool zu verwenden, da der Pool für jeden Kanal erstellt wird und wir für jede Anforderung einen neuen Kanal erstellen.  Natürlich können Sie den Dienst, der für die Interaktion mit WCF verantwortlich ist, mithilfe eines statischen WCF-Clients neu schreiben.  In diesem Fall wäre der Pool jedoch auch statisch, was zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel beschriebenen</a> DNS-Änderungsproblem führen könnte.  Es wurde auch über die Lösung gesprochen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://docs.microsoft.com/ru-ru/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-">HttpClientFactory</a> .  Das Wesentliche der Lösung ist, dass die Fabrik mit einem eigenen Pool arbeiten kann, in dem die Verbindungen regelmäßig aktualisiert werden.  Die Standardaktualisierungsdauer beträgt zwei Minuten, kann jedoch geändert werden. <br><br>  In unserem Produkt haben wir HttpClientFactory bereits für die Interaktion mit anderen Diensten verwendet, und die Verwendung der Factory in WCF schien eine gute Alternative zu einem statischen WCF-Client zu sein.  In diesem Fall müssten wir keine Änderungen an der Implementierung des WCF-Dienstes vornehmen.  Aber sie könnten den Pool benutzen, mit dem die Fabrik arbeiten kann.  Auf diese Weise konnten wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das in diesem Artikel beschriebene</a> Problem mit der NTLM-Authentifizierung unter Linux lösen, da Sie bei der Konfiguration des http-Clients das Authentifizierungsschema für den Nachrichtenhandler festlegen können. <br><br><h3>  Implementierung </h3><br>  Um mit HttpClientFactory zu arbeiten, fügen Sie einfach die Client-Konfigurationsbeschreibung zu ConfigureServices hinzu.  Dort können Sie mehrere benannte oder typisierte Clients mit Ihrer eigenen Konfiguration hinzufügen.  In diesem Fall verwendet jeder Client seinen eigenen Verbindungspool.  Im Beispiel verwenden wir einen benannten Client. <br><br><pre><code class="plaintext hljs">services.AddHttpClient("ClientName");</code> </pre> <br>  In WCF können Sie Ihre eigenen Nachrichtenhandler für den http-Client hinzufügen.  Fügen Sie dazu den Bindungsparametern einen von der Methode initialisierten Delegaten hinzu.  Dort erhalten wir als Eingabeparameter einen auf der WCF-Seite erstellten Handler und geben unseren eigenen Handler zurück.  Infolgedessen wird der von der Delegate-Methode erhaltene Handler an den http-Designer des Clients auf der WCF-Seite übergeben. <br><br>  Wenn Sie den Handler aus dem Factory-Pool zurückgeben, ersetzen wir den eingehenden Handler durch diesen.  Um den Handler aus dem Factory-Pool abzurufen, verwenden wir die HttpMessageHandlerFactory.  Um Zugriff auf die Bindungsparameter zu erhalten, muss eine von IEndpointBehavior geerbte Klasse implementiert werden.  Und fügen Sie es dann unserem WCF-Client hinzu. <br><br>  Schematisch sieht der Algorithmus zum Erstellen eines neuen Clients auf der WCF-Seite so aus. <br><br><img src="https://habrastorage.org/webt/wu/3j/eo/wu3jeomxr57pctuyf327lf56rua.png"><br><br>  Wir implementieren CustomEndpointBehaviour. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomEndpointBehavior</span></span></span><span class="hljs-class"> :</span></span> IEndpointBehavior { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Func&lt;HttpMessageHandler&gt; _httpHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomEndpointBehavior</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IHttpMessageHandlerFactory factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       _httpHandler = () =&gt; factory.CreateHandler("ClientName"); } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { //      bindingParameters.Add(new Func&lt;HttpClientHandler, HttpMessageHandler&gt;(handler =&gt; _httpHandler())); } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void Validate(ServiceEndpoint endpoint) { } }</span></span></code> </pre> <br>  Fügen Sie als Nächstes unser EndpointBehavior zum WCF-Client hinzu. <br><br><pre> <code class="cpp hljs">var httpMessageHandler = serviceProvider.GetRequiredService&lt;IHttpMessageHandlerFactory&gt;(); var client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WcfClient(); client.Endpoint.EndpointBehaviors.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomEndpointBehavior(httpMessageHandler));</code> </pre><br>  Beim Erstellen von Verbindungen über WCF werden nach Möglichkeit Handlerinstanzen aus dem Pool verwendet.  Dies verringert die Anzahl der Wirkstoffe. <br><br><h3>  Test </h3><br>  Zur Überprüfung haben wir 100 identische Anfragen gesendet.  Infolgedessen erreichte der Peak der Verbindungen ohne Pool 53, und mit einem Pool überschritt er 7 nicht. <br><br>  Überwachen von Verbindungen ohne Pool: <br><br><img src="https://habrastorage.org/webt/oi/wq/-m/oiwq-mdsy5lw0ex3axsdb9umuvs.png"><br><br>  Poolverbindungen überwachen: <br><br><img src="https://habrastorage.org/webt/2z/ai/o5/2zaio5zart9ocfkomqlyf77ingc.png"><br><br><h3>  Fazit </h3><br>  Wir von True Engineering haben einen Verbindungspool in WCF implementiert, der nicht von der Implementierung der Arbeit mit dem WCF-Client abhängt.  Außerdem werden Ressourcen sowohl auf der Serverseite, auf der die Anwendung ausgeführt wird, als auch auf der Seite des Dienstanbieters effektiv gespart. <br><br>  Wir haben viel Zeit damit verbracht, nach Optimierungsoptionen zu suchen, aber die Lösung selbst erwies sich als präzise und einfach.  Nimm es, solange es heiß ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465255/">https://habr.com/ru/post/de465255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465241/index.html">Mein siebter Tag mit Haiku: Auflisten, Scannen, Netzwerk</a></li>
<li><a href="../de465245/index.html">Sehen Sie die Benutzeroberfläche „mit den Augen des Designers“: über die Interaktion des Frontends mit dem Designer</a></li>
<li><a href="../de465247/index.html">Winkelig Grundlegendes zu @Input, @Output und EventEmitter</a></li>
<li><a href="../de465249/index.html">Vortrag von Richard Stallman am Moskauer Polytechnikum. August 2019</a></li>
<li><a href="../de465251/index.html">Der Sommer ist fast vorbei. Es sind fast keine Daten durchgesickert</a></li>
<li><a href="../de465257/index.html">"Vorsicht, FAS!": McDonald's Tricks, göttliches Döner, falsches Clooney und etwas Straßenmagie</a></li>
<li><a href="../de465259/index.html">ValueTask <TResult> - warum, warum und wie?</a></li>
<li><a href="../de465261/index.html">Die magische Kraft von Makros oder wie man einem AVR-Assembler-Programmierer das Leben leichter macht</a></li>
<li><a href="../de465263/index.html">Sperren in PostgreSQL: 3. Sperrt andere Objekte</a></li>
<li><a href="../de465267/index.html">TypeScript Ausdruck Magie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>