<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èÆÔ∏è üòµ üèß D√©veloppement du compilateur C pour le nouveau neuroprocesseur multiclet üè• üë©üèΩ‚ÄçüöÄ üÜì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors d'une conf√©rence des d√©veloppeurs de syst√®mes et d'outils logiciels - OS DAY 2016, qui s'est tenue √† Innopolis du 9 au 10 juin 2016 (Kazan) lors ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement du compilateur C pour le nouveau neuroprocesseur multiclet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480962/"><img src="https://habrastorage.org/webt/nm/q_/3x/nmq_3x1b_eccqomclbciqkb5go8.jpeg"><br><br>  Lors d'une conf√©rence des d√©veloppeurs de syst√®mes et d'outils logiciels - OS DAY 2016, qui s'est tenue √† Innopolis du 9 au 10 juin 2016 (Kazan) lors de la discussion d'un rapport sur l'architecture multicellulaire, l'id√©e a √©t√© exprim√©e qu'elle serait la plus efficace pour r√©soudre les probl√®mes d'intelligence artificielle.  Les conditions pour le d√©veloppement d'un nouveau processeur polyvalent ax√© sur les t√¢ches d'IA se sont d√©velopp√©es cette ann√©e. <br><br>  Le neuroprocesseur S2 Multiclet, dont le projet a √©t√© pr√©sent√© pour la premi√®re fois au Huawei Innovation Forum 2019, est un nouveau d√©veloppement de l'architecture multicellulaire.  Il diff√®re des multicellules pr√©c√©demment cr√©√©es avec un syst√®me de commandes, √† savoir l'introduction de nouveaux types de donn√©es de petite taille (√† virgule fixe et flottante) et les op√©rations avec celles-ci.  Le nombre de cellules a √©t√© augment√© - 256 et la fr√©quence - 2,5 GHz, ce qui devrait fournir une performance de pointe de 81,9 TFlops √† 16F et, en cons√©quence, le rendre comparable, en termes de calculs neuronaux, aux capacit√©s des TPU ASIC sp√©cialis√©s modernes (TPU-3: 90 TFlops √† 16F). <br><br>  √âtant donn√© que l'efficacit√© de l'utilisation des processeurs d√©pend largement de l'optimalit√© du compilateur, un sch√©ma d'optimisation de code d√©velopp√© a √©t√© d√©velopp√©. <br>  Examinons-le plus en d√©tail. <br><a name="habracut"></a><br>  L' <a href="https://habr.com/ru/post/434982/">article pr√©c√©dent</a> mentionnait les optimisations du compilateur qui m√©ritent d'√™tre impl√©ment√©es.  Vous y trouverez des mat√©riaux sur l'architecture multicellulaire si vous ne la connaissez pas d√©j√†. <br><br><h4>  G√©n√©ration de commandes √† deux arguments avec deux constantes </h4><br>  Un nouveau format d'instruction a √©t√© introduit avec le processeur S1, permettant aux deux arguments d'√™tre sp√©cifi√©s comme une valeur constante.  Cela vous permet de r√©duire le nombre de commandes dans le code, en supprimant les commandes inutiles telles que les constantes de chargement √† chargement dans le commutateur. <br><br>  Par exemple: <br><br><pre><code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre> <br>  peut √™tre remplac√© par: <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre> <br>  Ou m√™me deux √©quipes √† la fois: <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre> <br>  Il y a deux adresses constantes, et leur lecture peut √©galement √™tre substitu√©e directement dans les arguments de la commande: <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Cette optimisation a √©t√© mise en ≈ìuvre pour tous ceux qui prennent en charge ce format.  Malheureusement, cela s'est av√©r√© tr√®s inefficace, pour deux raisons: <br><br><ul><li>  Le nombre de situations o√π une telle optimisation peut √™tre r√©alis√©e est tr√®s faible.  Dans le code d'arbitrage, les situations se produisent rarement lorsque vous devez traiter en quelque sorte deux valeurs connues √† l'avance.  Le plus souvent, de telles choses sont d√©cid√©es au stade de la compilation, et il ne reste que peu √† faire pendant l'ex√©cution.  Habituellement, ce sont des op√©rations sur les adresses, encore une fois, constantes. </li><li>  La suppression de la commande de chargement ne lib√®re pas le processeur du processus de g√©n√©ration de la constante, mais uniquement de la r√©cup√©ration d'une commande de chargement distincte, qui ne donne qu'une faible acc√©l√©ration, et m√™me pas toujours. </li></ul><br><h4>  Optimisation du transfert des registres virtuels entre les unit√©s de base </h4><br>  Dans LLVM, les blocs de base sont des sections lin√©aires dans lesquelles le code est ex√©cut√© sans branchement.  Les paragraphes d'une architecture multicellulaire remplissent exactement la m√™me fonction, par cons√©quent, le plus souvent lors de la g√©n√©ration d'un code, un paragraphe refl√®te un bloc de base.  Dans le processeur R1, tout transfert de registres virtuels entre paragraphes a √©t√© effectu√© par la m√©moire en √©crivant la valeur du registre souhait√© dans la pile et en la relisant dans le paragraphe qui a besoin de ce registre.  Ce m√©canisme est divis√© en 2 parties: transfert du registre virtuel vers un autre paragraphe pour une utilisation directe et transfert du registre virtuel comme param√®tre pour le n≈ìud phi. <br><br>  Les n≈ìuds Phi sont une cons√©quence de la forme <a href="https://ru.wikipedia.org/wiki/SSA" rel="nofollow">SSA (Static Single Assignment)</a> dans laquelle le langage de pr√©sentation LLVM est repr√©sent√©.  Sous cette forme, une variable (ou, comme dans le cas de LLVM IR - registres virtuels) ne peut √™tre √©crite qu'une seule fois.  Par exemple, ce pseudo code: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = a;</code> </pre> <br>  non pr√©sent√© sous forme SSA, car la valeur de la variable <b>a</b> peut √™tre √©cras√©e.  Le code peut √™tre r√©√©crit sous cette forme, si vous utilisez le n≈ìud phi: <br><br><pre> <code class="cpp hljs">a1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = phi(a2, a3);</code> </pre> <br>  Le n≈ìud phi s√©lectionne a2 ou a3, selon la provenance du flux de contr√¥le: <br><img src="https://habrastorage.org/webt/ug/rw/-b/ugrw-brljdidipmpwg-iobfvjkm.png"><br>  Dans LLVM IR phi, les n≈ìuds sont impl√©ment√©s comme une instruction distincte, qui s√©lectionne diff√©rents registres virtuels en fonction de l'unit√© de base d'o√π provient le contr√¥le.  La mise en ≈ìuvre sur le processeur de cette instruction via la m√©moire est assez simple: diff√©rents blocs de base √©crivent des donn√©es diff√©rentes dans la m√™me cellule de m√©moire, et au niveau du n≈ìud phi du site, cette cellule de m√©moire est lue, et les donn√©es seront diff√©rentes en fonction du bloc de base pr√©c√©dent. <br><br>  Le formulaire SSA implique que lorsque le registre est initialis√©, la valeur y sera toujours la m√™me.  Lors du transfert direct de registres virtuels, lorsque la valeur de chaque registre virtuel est √©crite dans sa propre cellule m√©moire s√©par√©e, la condition SSA est remplie sans probl√®me: les donn√©es sont en m√©moire jusqu'√† ce qu'elles soient √©cras√©es.  Cependant, si nous voulons transf√©rer le registre via le commutateur, nous devons nous rappeler: sa taille n'est que de 63 cellules et toute valeur dispara√Æt lorsque 63 commandes sont ex√©cut√©es.  Par cons√©quent, si le registre virtuel est √©crit dans un premier paragraphe et est utilis√© une fois que des centaines d'autres sont termin√©s, il est impossible de le transf√©rer via le commutateur;  il ne reste que la m√©moire. <br>  La mise en ≈ìuvre de cette optimisation a √©t√© d√©marr√©e pr√©cis√©ment avec l'optimisation des n≈ìuds phi, car, contrairement au transfert direct des registres virtuels, les valeurs des param√®tres pour le n≈ìud phi sont toujours initialis√©es directement dans les paragraphes pr√©c√©dents (blocs de base), ce qui vous permet de ne pas trop penser si le commutateur est suffisamment grand si nous voulons passer ces param√®tres √† travers elle. <br><br>  L'assembleur multicellulaire vous permet d'attribuer des noms aux r√©sultats des commandes et d'utiliser leurs r√©sultats sous ce nom.  Au lieu que chaque programmeur doive calculer combien de commandes ce r√©sultat a √©t√© obtenu, l'assembleur le calcule lui-m√™me: <br><br><pre> <code class="plaintext hljs">result := add_l [A], [B] ; ;    ; wr_l @result, C</code> </pre> <br>  Ce m√©canisme fonctionne parfaitement dans le paragraphe actuel, car il s'agit d'une section lin√©aire et l'ordre des commandes y est connu.  Ceci est activement utilis√© lorsque le compilateur g√©n√®re du code: toutes les commandes re√ßoivent des noms et le compilateur n'a pas √† se soucier de la num√©rotation des commandes.  Plus pr√©cis√©ment, cela n'√©tait pas n√©cessaire, car si nous voulons obtenir le r√©sultat d'une commande ex√©cut√©e dans un autre paragraphe, alors le m√©canisme ne fonctionne pas: au stade de l'assemblage, il est impossible de savoir quel paragraphe a √©t√© r√©ellement ex√©cut√© par le pr√©c√©dent s'il y a plusieurs entr√©es dans le courant.  Par cons√©quent, la seule option est d'acc√©der aux r√©sultats des √©quipes via le num√©ro.  Pour cette raison, vous ne pouvez pas simplement supprimer des enregistrements / lectures suppl√©mentaires de la m√©moire dans les paragraphes voisins et remplacer les r√©f√©rences de registre de la commande de lecture par la commande du paragraphe pr√©c√©dent. <br><br>  Ici, il convient de pr√™ter attention √† une cons√©quence tr√®s importante: si un paragraphe a plusieurs entr√©es, alors <b>@ 1</b> dans la premi√®re commande de cette section peut faire r√©f√©rence √† des r√©sultats compl√®tement diff√©rents, selon le paragraphe qui √©tait le pr√©c√©dent.  Le n≈ìud Phi est une telle situation.  Auparavant, dans tous les blocs de base initialisant le n≈ìud phi, les donn√©es √©taient √©crites dans la m√™me cellule de m√©moire, et √† la place du n≈ìud phi, il y avait une lecture dans cette cellule.  Ainsi, ce n'√©tait absolument pas important l'endroit o√π il y avait un enregistrement dans cette cellule dans les paragraphes pr√©c√©dents, tout comme l'endroit o√π cette cellule √©tait lue.  Si vous vous d√©barrassez de l'utilisation de la m√©moire - cela change. <br><br>  Pour permettre aux h√¥tes phi d'utiliser un commutateur au lieu de la m√©moire, les op√©rations suivantes ont √©t√© effectu√©es: <br><br><ol><li>  Tous les n≈ìuds phi dans l'unit√© de base actuelle sont compt√©s (et il peut y en avoir plusieurs), sont marqu√©s d'un num√©ro de s√©rie et sont dispos√©s dans cet ordre </li><li>  Pour chaque n≈ìud phi, les blocs de base l'initialisant sont contourn√©s; des commandes pour charger les valeurs dans le commutateur ( <b>loadu_q</b> ), marqu√©es par le num√©ro de s√©rie du n≈ìud phi correspondant, leur sont ajout√©es </li><li>  L'instruction phi du n≈ìud lui-m√™me est √©galement remplac√©e par <b>loadu_q</b> avec son num√©ro de s√©rie </li><li>  Toutes les commandes ajout√©es sont r√©organis√©es dans l'ordre donn√© </li></ol><br>  Le quatri√®me point est n√©cessaire pour la raison d√©j√† indiqu√©e: si nous voulons que la commande <b>loadu_q @ 3</b> acc√®de au r√©sultat sp√©cifiquement pour son n≈ìud phi, alors tous les paragraphes d'initialisation de la commande qui charge les donn√©es dans le commutateur doivent √™tre exactement dans le m√™me ordre.  Donnons un exemple du r√©sultat r√©el de la compilation de code dans lequel il y a deux n≈ìuds phi dans une unit√© de base. <br><br>  Paragraphes avec initialiseurs phi n≈ìuds: <br><br><pre> <code class="plaintext hljs">LBB1_27: LBB1_30: SR4 := loadu_q @1 setjf_l @0, LBB1_31 setjf_l @0, LBB1_31 SR4 := loadu_q [#SP + 8] SR5 := loadu_q [#SP + 16] SR5 := loadu_q [#SP] SR6 := loadu_l 0x1 SR6 := add_l @SR4, 0xffffffff SR7 := add_l @SR6, [@SR4] loadu_q @SR5 wr_l @SR7, @SR4 loadu_q @SR6 loadu_q @SR6 complete loadu_q @SR5 complete</code> </pre><br>  Un paragraphe avec deux n≈ìuds phi: <br><br><pre> <code class="plaintext hljs">LBB1_31: SR4 := loadu_q @2 SR5 := loadu_q @2 SR6 := loadu_l [#SP + 124] SR7 := loadu_l [#SP + 120] setjf_l @0, @SR7 setrg_q #RETV, @SR4 wr_l @SR5, @SR6 setrg_q #SP, #SP + 120 complete</code> </pre> <br>  Auparavant, au lieu des commandes <b>loadu_q,</b> il y avait des √©critures dans la m√©moire et des lectures √† partir de celle-ci. <br>  Dans le processus de mise en ≈ìuvre de cette optimisation, il y a √©galement eu des probl√®mes qui n'√©taient pas pr√©vus √† l'avance: <br><br><ul><li>  Certaines optimisations de code existantes r√©organisent les commandes √† certains endroits, par exemple en pla√ßant l'adresse du paragraphe suivant au tout d√©but du paragraphe actuel, ou l'emplacement des commandes de lecture / √©criture en m√©moire au d√©but / √† la fin du paragraphe, respectivement.  Ces optimisations se produisent apr√®s des op√©rations avec des n≈ìuds phi (les instructions dites d'abaissement LLVM avant les instructions du processeur), de sorte qu'elles perturbent souvent l'ordre de <b>construction des</b> commandes <b>loadu_q</b> .  Afin de ne pas perturber le travail de ces optimisations, j'ai d√ª cr√©er une passe LLVM distincte, qui organise les commandes pour les n≈ìuds phi dans le bon ordre apr√®s toutes les autres manipulations avec les commandes. </li><li>  Il s'est av√©r√© qu'une situation peut se produire dans laquelle une unit√© de base initialise des n≈ìuds phi pour deux unit√©s de base diff√©rentes.  Autrement dit, en suivant l'algorithme indiqu√©, ces blocs de base seront ajout√©s √† la commande d'initialisation <b>loadu_q</b> pour chaque n≈ìud phi.  Dans ce cas, m√™me s'ils n'ont qu'un seul n≈ìud phi, dans la section d'initialisation, il y aura 2 <b>commandes loadu_q</b> , qui, logiquement, les deux devraient √™tre √† la derni√®re place, ce qui, bien s√ªr, est impossible.  Heureusement, de telles situations sont assez rares, donc s'il existe une telle unit√© de base dans laquelle les n≈ìuds phi sont initialis√©s pour plus d'une autre unit√© de base, alors seul le premier utilise le commutateur selon l'algorithme, pour le reste - comme auparavant, via la m√©moire. </li></ul><br>  Toute cette optimisation des n≈ìuds phi peut √™tre compl√©t√©e un peu plus.  Par exemple, si vous regardez le paragraphe <b>LBB1_30</b> ci-dessus, vous pouvez voir que les <b>commandes loadu_q</b> chargent des valeurs qui ne sont utilis√©es nulle part ailleurs.  Autrement dit, si vous supprimez <b>loadu_q</b> et d√©finissez les commandes qui cr√©ent ces valeurs dans le m√™me ordre, les commandes <b>loadu_q @ 2</b> de la section suivante chargeront √©galement les valeurs correctes. <br><br><h4>  Rep√®res </h4><br>  Les r√©sultats d'optimisation actuels ont √©t√© test√©s sur les benchmarks CoreMark et WhetStone, dont une description se trouve dans l' <a href="https://habr.com/ru/post/434982/">article pr√©c√©dent</a> .  Commen√ßons par les r√©sultats CoreMark sur le noyau S2 en comparaison avec les anciens r√©sultats (version pr√©c√©dente du compilateur sur le noyau S1). <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>Multiclet s2</b> </th><th>  Multiclet s1 </th><th>  Elbrus-4C (E2S) </th><th>  Texas Inst.  AM5728 ARM Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Fr√©quence d'horloge, MHz </td><td>  <b>2500</b> </td><td>  1600 </td><td>  800 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Score global CoreMark </td><td>  <b>122425</b> </td><td>  18356 </td><td>  8850 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr></tbody></table></div><br>  Les valeurs relatives CoreMark / MHz sont affich√©es dans l'histogramme: <br><br><img src="https://habrastorage.org/webt/nw/c6/kw/nwc6kwtqwiejo48poskzc0zrzky.png"><br><br>  Pour obtenir une estimation de l'acc√©l√©ration uniquement due √† l'optimisation des n≈ìuds phi, vous pouvez recalculer l'indicateur CoreMark sur une multicellule sur les c≈ìurs S1 et S2 pour une fr√©quence de 1600 MHz: ils sont respectivement de 1147 et 1224, ce qui signifie une augmentation de 6,7%. <br><br>  Avec WhetStone, la situation est quelque peu diff√©rente.  Les changements dans le noyau ont ici influenc√© le r√©sultat.En outre, cette r√©f√©rence fonctionne sur un c≈ìur (multicellulaire) et est calcul√©e en m√©gahertz, de sorte que la fr√©quence du processeur ne joue aucun r√¥le. <br><br>  Tableau de bord Whetstone: <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>MultiClet S2</b> </th><th>  MultiClet S1 </th><th>  Core i7 4820K </th><th>  ARM v8-A53 </th></tr><tr><td>  MWIPS / MHz </td><td>  <b>0,326</b> </td><td>  0,342 </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  <b>0,141</b> </td><td>  0,156 </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  <b>0,094</b> </td><td>  0,111 </td><td>  0,308 </td><td>  0,241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  <b>0,108</b> </td><td>  0,124 </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  <b>0,007</b> </td><td>  0,008 </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  <b>0,005</b> </td><td>  0,005 </td><td>  0,014 </td><td>  0,004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  <b>0,115</b> </td><td>  0,116 </td><td>  0,998 </td><td>  1,197 </td></tr><tr><td>  SI MOPS / MHz </td><td>  <b>0,196</b> </td><td>  0,196 </td><td>  1,504 </td><td>  1,436 </td></tr><tr><td>  EGAL MOPS / MHz </td><td>  <b>0,156</b> </td><td>  0,149 </td><td>  0,251 </td><td>  0,439 </td></tr></tbody></table></div><br>  Maintenant, il est clair que m√™me lors de l'utilisation de la version pr√©c√©dente du compilateur sur le noyau S1, l'index global est plus √©lev√©, principalement en raison des tests en virgule flottante MFLOPS1-3.  Cet inconv√©nient a √©t√© constat√© lors des tests et est d√ª au fait que le convoyeur interne du bloc √† virgule flottante en S2, par rapport √† S1, est un pas de plus.  En cons√©quence, les cha√Ænes successives de commandes li√©es aux donn√©es ont perdu une mesure sur chaque commande.  La n√©cessit√© de cette √©tape a √©t√© caus√©e par une r√©duction de la dur√©e du cycle d'horloge (une augmentation de la fr√©quence du processeur de 1,6 GHz √† 2,5 GHz et une augmentation de la nomenclature des commandes, par exemple, l'apparition de la commande de multiplication avec l'accumulation de MAC).  Cette d√©cision est provisoire.  Des travaux visant √† r√©duire la longueur du pipeline sont en cours et, √† l'avenir, ils seront corrig√©s, mais des tests ont √©t√© effectu√©s sur la version actuelle de S2. <br><br>  Pour √©valuer l'acc√©l√©ration de l'optimisation du compilateur, WhetStone a √©galement √©t√© compil√© sur une version pr√©c√©dente et lanc√© sur la version actuelle de S2.  L'indicateur total √©tait de 0,3068 MWIPS / MHz contre 0,32267 MWIPS / MHz sur le nouveau compilateur, soit  ce qui montre une acc√©l√©ration de 6,5% en raison des optimisations ci-dessus. <br><br>  Le syst√®me d'optimisation d√©velopp√© et test√© vous permet de mettre en ≈ìuvre √† l'avenir le prochain sch√©ma d'optimisation, √† savoir le transfert direct des registres virtuels via le commutateur.  Comme d√©j√† mentionn√©, toutes les copies du registre virtuel ne peuvent pas √™tre effectu√©es via le commutateur.  En raison de la taille limit√©e du commutateur et de l'impossibilit√© d'acc√©der correctement aux r√©sultats des paragraphes pr√©c√©dents s'il y a plusieurs points d'entr√©e vers celui en cours (cela est partiellement r√©solu par les n≈ìuds phi), la seule option possible est de copier les registres virtuels d'un paragraphe directement au suivant, mais il n'y en a qu'un pr√©c√©dent .  De tels cas, en fait, ne sont pas si rares, il est souvent n√©cessaire de transf√©rer des donn√©es aussi directement, bien que la quantit√© d'acc√©l√©ration de code qu'elle donnera √† dire √† l'avance soit, bien s√ªr, difficile. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480962/">https://habr.com/ru/post/fr480962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480950/index.html">Analyse du quiz Android du stand hh.ru au Mobius 2019 Moscou</a></li>
<li><a href="../fr480954/index.html">Num√©ro de t√¢che 1. D√©couvrez le sexe et le degr√© de relation</a></li>
<li><a href="../fr480956/index.html">Comment j'ai trouv√© un moyen de suivre tous les pilotes Citimobil</a></li>
<li><a href="../fr480958/index.html">Connexion satellite. Vue d'ensemble des soci√©t√©s op√©rateurs et un peu sur la notation</a></li>
<li><a href="../fr480960/index.html">Trouvez des fichiers perdus dans plusieurs cibles Xcode</a></li>
<li><a href="../fr480964/index.html">Qu'est-ce que la zone de Fresnel et CCQ (Client Connection Quality) ou les facteurs fondamentaux d'un pont sans fil de haute qualit√©</a></li>
<li><a href="../fr480970/index.html">10 meilleures pratiques pour s√©curiser les images Docker. Partie 1</a></li>
<li><a href="../fr480974/index.html">D√©veloppement d'applications dans les mini-applications VK</a></li>
<li><a href="../fr480976/index.html">Biblioth√®que de test de l'API JSON-RPC</a></li>
<li><a href="../fr480978/index.html">Y a-t-il une vie apr√®s Signora?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>