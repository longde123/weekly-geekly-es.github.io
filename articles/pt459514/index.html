<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø üß¶ üë∏üèø .NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 2 üßë üçÖ ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publico o artigo original sobre Habr, cuja tradu√ß√£o est√° publicada no blog da Codingsight . 

 Continuo criando uma vers√£o em texto da minha palestra ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459514/">  <i>Publico o artigo original sobre Habr, cuja tradu√ß√£o est√° publicada no blog da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codingsight</a> .</i> <br><br>  Continuo criando uma vers√£o em texto da minha palestra na reuni√£o multithreading.  A primeira parte pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ; havia mais sobre o conjunto b√°sico de ferramentas para iniciar um thread ou Tarefa, maneiras de visualizar seu status e algumas pequenas coisas doces como o PLinq.  Neste artigo, quero me concentrar mais nos problemas que podem surgir em um ambiente multithread e em algumas maneiras de resolv√™-los. <br><br><h2>  Conte√∫do </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre recursos compartilhados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Poss√≠veis problemas ao trabalhar em um ambiente multithread</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Impasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Condi√ß√£o de corrida</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espera ocupada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inani√ß√£o de thread</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas de sincroniza√ß√£o</a> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intertravado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Enter, Monitor.Exit, bloquear</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpinLock, SpinWait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitor.Wait, Monitor.Pulse [Tudo]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReaderWriterLockSlim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fam√≠lia ResetEvent</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conclus√µes</a> </li></ul><br><a name="habracut"></a><br><a name="SharedResources"></a><br><h2>  Sobre recursos compartilhados </h2><br>  √â imposs√≠vel escrever um programa que funcione em v√°rios threads, mas ao mesmo tempo n√£o teria um √∫nico recurso compartilhado:  mesmo que funcione no seu n√≠vel de abstra√ß√£o, ao descer um ou mais n√≠veis abaixo, ainda h√° um recurso comum.  Vou dar alguns exemplos: <br><br>  <b>Exemplo 1:</b> <br><br>  Com medo de poss√≠veis problemas, voc√™ fez os threads funcionarem com arquivos diferentes.  Por arquivo para transmitir.  Parece que o programa n√£o possui um √∫nico recurso comum. <br><br>  Depois de descer v√°rios n√≠veis abaixo, entendemos que existe apenas um disco r√≠gido e seu driver ou sistema operacional ter√° que resolver os problemas de garantir o acesso a ele. <br><br>  <b>Exemplo 2:</b> <br><br>  Depois de ler o <i>exemplo</i> 1, voc√™ decidiu colocar os arquivos em duas m√°quinas remotas diferentes, com duas pe√ßas fisicamente diferentes de ferro e sistemas operacionais.  Mantemos 2 conex√µes diferentes via FTP ou NFS. <br><br>  Ao descer v√°rios n√≠veis abaixo, entendemos que nada mudou e o driver da placa de rede ou do sistema operacional da m√°quina em que o programa est√° sendo executado ter√° que resolver o problema do acesso competitivo. <br><br>  <b>Exemplo 3:</b> <br><br>  Tendo perdido uma parte consider√°vel do seu cabelo na tentativa de provar a possibilidade de escrever um programa multiencadeado, voc√™ recusa completamente os arquivos e decomp√µe os c√°lculos em dois objetos diferentes, links para cada um dos quais est√£o dispon√≠veis apenas para um fluxo. <br><br>  Martelo a √∫ltima d√∫zia de pregos no caix√£o dessa id√©ia: um tempo de execu√ß√£o e coletor de lixo, agendador de threads, fisicamente uma RAM e mem√≥ria, um processador ainda s√£o recursos compartilhados. <br><br>  Portanto, descobrimos que √© imposs√≠vel escrever um programa multithread sem um √∫nico recurso compartilhado em todos os n√≠veis de abstra√ß√£o em toda a largura de toda a pilha de tecnologia.  Felizmente, como regra geral, cada um dos n√≠veis de abstra√ß√£o resolve parcialmente ou completamente os problemas do acesso competitivo ou simplesmente o pro√≠be (exemplo: qualquer estrutura de interface do usu√°rio pro√≠be trabalhar com elementos de diferentes threads); portanto, os problemas geralmente surgem com recursos compartilhados em seu n√≠vel de abstra√ß√£o.  Para resolv√™-los, introduza o conceito de sincroniza√ß√£o. <br><a name="Problems"></a><br><h2>  Poss√≠veis problemas ao trabalhar em um ambiente multithread </h2><br>  Os erros no software podem ser divididos em v√°rios grupos: <br><br><ol><li>  O programa n√£o produz um resultado.  Falha ou congela. </li><li>  O programa retorna um resultado incorreto. </li><li>  O programa produz o resultado correto, mas n√£o atende a um ou outro requisito n√£o funcional.  Executa muito tempo ou consome muitos recursos. </li></ol><br>  Em um ambiente multithread, os dois principais problemas que causam os erros 1 e 2 s√£o <b>deadlock</b> e <b>condi√ß√£o de corrida</b> . <br><a name="Deadlock"></a><br><h3>  Impasse </h3><br>  Impasse - impasse.  Existem muitas varia√ß√µes diferentes.  Os mais comuns s√£o os seguintes: <br><br><img src="https://habrastorage.org/webt/fl/ij/aj/flijajjtgsaczutpuk9t1filaig.png"><br><br>  Enquanto o <b>Thread # 1 estava</b> fazendo alguma coisa, o <b>Thread # 2</b> bloqueou o recurso <b>B</b> , um pouco mais tarde o <b>Thread # 1</b> bloqueou o recurso <b>A</b> e tentou bloquear o recurso <b>B</b> , infelizmente isso nunca acontecer√°, porque  <b>O segmento # 2</b> liberar√° o recurso <b>B</b> somente ap√≥s o bloqueio do recurso <b>A.</b> <br><a name="RaceCondition"></a><br><h3>  Condi√ß√£o de corrida </h3><br>  Condi√ß√£o de corrida - condi√ß√£o de corrida.  A situa√ß√£o em que o comportamento e o resultado dos c√°lculos executados pelo programa dependem do trabalho do planejador de encadeamentos em tempo de execu√ß√£o. <br>  O desagrado desta situa√ß√£o reside precisamente no fato de que seu programa pode n√£o funcionar apenas uma vez em cem ou mesmo em um milh√£o. <br><br>  A situa√ß√£o √© agravada pelo fato de que os problemas podem andar juntos, por exemplo: com um determinado comportamento do planejador de encadeamentos, ocorre um conflito. <br><br>  Al√©m desses dois problemas que levam a erros √≥bvios no programa, tamb√©m existem aqueles que podem n√£o levar a um resultado de c√°lculo incorreto, mas ser√° gasto mais tempo ou poder de processamento para obt√™-lo.  Dois desses problemas s√£o: <b>espera ocupada</b> e <b>falta de thread</b> . <br><a name="BusyWait"></a><br><h3>  Espera ocupada </h3><br>  Aguardar ocupado √© um problema no qual o programa consome recursos do processador n√£o para c√°lculos, mas para aguardar. <br><br>  Muitas vezes, esse problema no c√≥digo se parece com isso: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!hasSomethingHappened) ;</code> </pre> <br>  Este √© um exemplo de c√≥digo extremamente ruim, pois  Esse c√≥digo ocupa completamente um n√∫cleo do seu processador, sem fazer absolutamente nada √∫til.  Pode ser justificado se e somente se for criticamente importante processar uma altera√ß√£o em algum valor em outro encadeamento.  E falando r√°pido, estou falando do caso em que voc√™ n√£o pode esperar nem alguns nanossegundos.  Em outros casos, ou seja, em tudo o que pode produzir um c√©rebro saud√°vel, √© mais razo√°vel usar as variedades ResetEvent e suas vers√µes Slim.  Sobre eles abaixo. <br><br>  Talvez um dos leitores proponha resolver o problema de carregar completamente um n√∫cleo com uma espera in√∫til, adicionando constru√ß√µes como Thread.Sleep (1) ao loop.  Isso realmente resolver√° o problema, mas criar√° outro: o tempo de resposta √† mudan√ßa ser√° em m√©dia de meio milissegundo, o que pode n√£o ser muito, mas catastroficamente mais do que voc√™ poderia usar as primitivas de sincroniza√ß√£o da fam√≠lia ResetEvent. <br><a name="ThreadStarvation"></a><br><h3>  Inani√ß√£o de thread </h3><br>  Aus√™ncia de thread √© um problema em que o programa tem muitos threads trabalhando simultaneamente.  O que significa exatamente aqueles fluxos que est√£o ocupados com os c√°lculos, e n√£o apenas aguardando uma resposta de qualquer IO.  Com esse problema, todo o ganho de desempenho poss√≠vel com o uso de threads √© perdido, porque  O processador gasta muito tempo alternando contextos. <br>  √â conveniente procurar esses problemas usando v√°rios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criadores de</a> perfil. Abaixo est√° um exemplo de uma captura de tela do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criador de</a> perfil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotTrace</a> iniciado no modo Linha de tempo. <br><br> <a href=""><img src="https://habrastorage.org/webt/qy/n9/nk/qyn9nkwglryzuu60cipo8zdi0ra.png"></a> <br>  <i>(A imagem √© clic√°vel)</i> <br><br>  No programa que n√£o sofre de fome de fluxo cont√≠nuo, n√£o haver√° cor rosa nos gr√°ficos que refletem fluxos.  Al√©m disso, na categoria Subsistemas, fica claro que 30,6% do programa estava aguardando a CPU. <br><br>  Quando esse problema √© diagnosticado, ele √© resolvido com muita simplicidade: voc√™ iniciou muitos threads ao mesmo tempo, inicia menos ou n√£o todos de uma vez. <br><a name="SyncPrimitives"></a><br><h2>  Ferramentas de sincroniza√ß√£o </h2><br><a name="Interlocked"></a><br><h3>  Intertravado </h3><br>  Esta √© talvez a maneira mais leve de sincronizar.  Interlocked √© uma cole√ß√£o de opera√ß√µes at√¥micas simples.  Uma opera√ß√£o at√¥mica √© chamada de opera√ß√£o no momento em que nada pode acontecer.  No .NET, Interlocked √© representado pela classe est√°tica de mesmo nome com v√°rios m√©todos, cada um dos quais implementa uma opera√ß√£o at√¥mica. <br><br>  Para perceber o horror das opera√ß√µes n√£o at√¥micas, tente escrever um programa que inicie 10 threads, cada um dos quais faz um milh√£o de incrementos da mesma vari√°vel e, no final do trabalho, imprima o valor dessa vari√°vel - infelizmente, ser√° muito diferente de 10 milh√µes. Cada vez que o programa inicia, ser√° diferente.  Isso acontece porque mesmo uma opera√ß√£o t√£o simples como um incremento n√£o √© at√¥mica, mas envolve extrair um valor da mem√≥ria, calcular um novo e escrever de volta.  Portanto, dois encadeamentos podem executar simultaneamente cada uma dessas opera√ß√µes; nesse caso, o incremento ser√° perdido. <br><br>  A classe Interlocked fornece m√©todos de Incremento / Decremento; √© f√°cil adivinhar o que eles fazem.  Eles s√£o convenientes de usar se voc√™ estiver processando dados em v√°rios threads e considerar algo.  Esse c√≥digo funcionar√° muito mais r√°pido que o bloqueio cl√°ssico.  Se Intertravado for usado para a situa√ß√£o descrita no √∫ltimo par√°grafo, o programa distribuir√° 10 milh√µes de maneira est√°vel em qualquer situa√ß√£o. <br><br>  O m√©todo CompareExchange executa, √† primeira vista, uma fun√ß√£o bastante √≥bvia, mas toda a sua presen√ßa permite implementar muitos algoritmos interessantes, especialmente a fam√≠lia sem bloqueio. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareExchange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> location1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comparand</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  O m√©todo usa tr√™s valores: o primeiro √© passado por refer√™ncia e este √© o valor que ser√° alterado para o segundo, se no momento da compara√ß√£o o local1 corresponder ao comparando, o valor original do local1 ser√° retornado.  Parece um pouco confuso, porque √© mais f√°cil escrever c√≥digo que executa as mesmas opera√ß√µes que o CompareExchange: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> original = location1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location1 == comparand) location1 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> original;</code> </pre><br>  Somente uma implementa√ß√£o na classe Interlocked ser√° at√¥mica.  Ou seja, se n√≥s escrev√™ssemos esse c√≥digo, uma situa√ß√£o poderia ter ocorrido quando a condi√ß√£o location1 == comparand j√° tivesse sido atendida, mas quando a express√£o location1 = value foi executada, outro encadeamento alterou o valor do location1 e ele seria perdido. <br><br>  Podemos encontrar um bom exemplo de uso desse m√©todo no c√≥digo que o compilador gera para qualquer evento C #. <br><br>  Vamos escrever uma classe simples com um evento MyEvent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vamos</a> criar o projeto na configura√ß√£o Release e abrir o assembly usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dotPeek</a> com a op√ß√£o Show <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Generator</a> Generated Code ativada: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CompilerGenerated</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler MyEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent, (EventHandler) Delegate.Combine((Delegate) comparand, (Delegate) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>), comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } [CompilerGenerated] <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The same algorithm but with Delegate.Remove } }</span></span></code> </pre><br>  Aqui voc√™ pode ver que nos bastidores, o compilador gerou um algoritmo bastante sofisticado.  Esse algoritmo protege contra a situa√ß√£o de perda de uma inscri√ß√£o de evento quando v√°rios threads se inscrevem nesse evento simultaneamente.  Vamos escrever o m√©todo add com mais detalhes, lembrando o que o m√©todo CompareExchange faz nos bastidores <br><br><pre> <code class="cs hljs">EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MyEvent; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; <span class="hljs-comment"><span class="hljs-comment">// Begin Atomic Operation if (MyEvent == comparand) { eventHandler = MyEvent; MyEvent = Delegate.Combine(MyEvent, value); } // End Atomic Operation } while (eventHandler != comparand);</span></span></code> </pre><br>  Isso j√° √© um pouco mais claro, embora provavelmente ainda precise de uma explica√ß√£o.  Em palavras, eu descreveria esse algoritmo da seguinte maneira: <br><br>  <i>Se o MyEvent ainda √© o mesmo que era no momento em que come√ßamos a executar o Delegate.Combine, escreva nele o que o Delegate.Combine retorna e, se n√£o, n√£o importa, tente novamente e repita at√© que saia.</i> <i><br></i> <br><br>  Portanto, nenhuma assinatura de evento ser√° perdida.  Voc√™ ter√° que resolver um problema semelhante se desejar repentinamente implementar uma matriz din√¢mica livre de bloqueios, segura para threads.  Se v√°rios fluxos correm para adicionar elementos a ele, √© importante que todos sejam adicionados no final. <br><a name="Lock"></a><br><h3>  Monitor.Enter, Monitor.Exit, bloquear </h3><br>  Essas s√£o as constru√ß√µes mais usadas para sincroniza√ß√£o de encadeamentos.  Eles implementam a ideia de uma se√ß√£o cr√≠tica: ou seja, o c√≥digo gravado entre as chamadas para Monitor.Enter, Monitor.Exit em um recurso pode ser executado ao mesmo tempo em apenas um thread.  A instru√ß√£o de bloqueio √© um a√ß√∫car sint√°tico em torno das chamadas de Enter / Exit envolvidas no try-finalmente.  Um bom recurso da implementa√ß√£o de uma se√ß√£o cr√≠tica no .NET √© a capacidade de inseri-la novamente no mesmo fluxo.  Isso significa que esse c√≥digo ser√° executado sem problemas: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(a) { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (a) { ... } }</code> </pre><br>  √â improv√°vel, √© claro, que algu√©m escreva dessa maneira, mas se voc√™ espalhar esse c√≥digo em v√°rios m√©todos de pilha de chamadas em profundidade, esse recurso poder√° economizar alguns ifs.  Para tornar poss√≠vel esse truque, os desenvolvedores do .NET precisaram adicionar uma restri√ß√£o - apenas uma inst√¢ncia de um tipo de refer√™ncia pode ser usada como um objeto de sincroniza√ß√£o e v√°rios bytes s√£o adicionados implicitamente a cada objeto em que o identificador do fluxo ser√° gravado. <br><br>  Esse recurso da se√ß√£o cr√≠tica em c # imp√µe uma limita√ß√£o interessante na opera√ß√£o da instru√ß√£o de bloqueio: voc√™ n√£o pode usar a instru√ß√£o de espera dentro da instru√ß√£o de bloqueio.  No come√ßo, ele me surpreendeu, porque uma compila√ß√£o Monitor.Enter / Exit de tentativa e finalmente compilada.  Qual √© o problema?  Aqui, voc√™ deve reler cuidadosamente o √∫ltimo par√°grafo mais uma vez e, em seguida, adicionar algum conhecimento sobre o princ√≠pio de async / waitit: o c√≥digo ap√≥s aguardar n√£o ser√° necessariamente executado no mesmo encadeamento que o c√≥digo antes de aguardar, depende do contexto de sincroniza√ß√£o e da presen√ßa ou nenhuma chamada para ConfigureAwait.  Daqui resulta que Monitor.Exit pode ser executado em um thread que n√£o seja Monitor.Enter, que lan√ßar√° um <b>SynchronizationLockException</b> .  Se voc√™ n√£o acredita, pode executar o seguinte c√≥digo em um aplicativo de console: ele lan√ßar√° um SynchronizationLockException. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Monitor.Enter(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Monitor.Exit(syncObject); Console.WriteLine(Thread.CurrentThread.ManagedThreadId);</code> </pre><br>  Vale ressaltar que no WinForms ou em um aplicativo WPF, esse c√≥digo funcionar√° corretamente se for chamado do thread principal.  haver√° um contexto de sincroniza√ß√£o que implementa um retorno ao thread da interface do usu√°rio ap√≥s aguardar.  De qualquer forma, voc√™ n√£o deve brincar com a se√ß√£o cr√≠tica no contexto do c√≥digo que cont√©m o operador aguardar.  Nesses casos, √© melhor usar primitivas de sincroniza√ß√£o, que ser√£o discutidas mais adiante. <br><br>  Falando sobre o trabalho da se√ß√£o cr√≠tica no .NET, vale ressaltar outro recurso de sua implementa√ß√£o.  A se√ß√£o cr√≠tica no .NET opera em dois modos: modo de espera de rota√ß√£o e modo de kernel.  O algoritmo spin-wait √© convenientemente representado como o seguinte pseudo-c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!TryEnter(syncObject)) ;</code> </pre><br>  Essa otimiza√ß√£o visa a captura mais r√°pida da se√ß√£o cr√≠tica em um curto espa√ßo de tempo, com base no pressuposto de que, se o recurso estiver ocupado agora, ele est√° prestes a se libertar.  Se isso n√£o ocorrer em um curto per√≠odo de tempo, o thread aguardar√° no modo kernel, o que, como retornar dele, leva tempo.  Os desenvolvedores do .NET otimizaram o cen√°rio de bloqueio curto o m√°ximo poss√≠vel, infelizmente, se muitos threads come√ßarem a rasgar a se√ß√£o cr√≠tica, isso poder√° levar a uma carga de CPU alta e repentina. <br><a name="SpinLock"></a><br><h3>  SpinLock, SpinWait </h3><br>  Como mencionei o algoritmo spin-wait, vale a pena mencionar as estruturas BCL SpinLock e SpinWait.  Eles devem ser usados ‚Äã‚Äãse houver motivos para acreditar que sempre haver√° uma oportunidade de trancar rapidamente.  Por outro lado, n√£o vale a pena lembrar deles antes que os resultados da cria√ß√£o de perfil mostrem que o uso de outras primitivas de sincroniza√ß√£o √© o gargalo do seu programa. <br><a name="Pulse"></a><br><h3>  Monitor.Wait, Monitor.Pulse [Tudo] </h3><br>  Este par de m√©todos deve ser considerado em conjunto.  Com a ajuda deles, v√°rios cen√°rios Produtor-Consumidor podem ser implementados. <br><br>  <i>Produtor-Consumidor - um padr√£o de design com v√°rios processos / multithread assumindo a presen√ßa de um ou mais threads / processos que produzem dados e um ou mais processos / threads que processam esses dados.</i>  <i>Geralmente usa uma cole√ß√£o compartilhada.</i> <br><br>  Ambos os m√©todos podem ser chamados apenas se o encadeamento que os est√° causando tiver um bloqueio no momento.  O m√©todo Wait libera o bloqueio e trava at√© que outro thread chame Pulse. <br><br>  Para demonstrar o trabalho, escrevi um pequeno exemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/0-/7k/uy/0-7kuyx2b8evi2iwzmt-6-capv0.png"><br>  <i>(Usei a imagem, n√£o o texto, para mostrar visualmente a ordem de execu√ß√£o das instru√ß√µes)</i> <br><br>  <u>Analisar:</u> defina um atraso de 100ms no in√≠cio do segundo fluxo, especificamente para garantir que sua execu√ß√£o seja iniciada mais tarde. <br>  - T1: o fluxo da linha 2 inicia <br>  - T1: o fluxo da linha 3 entra na se√ß√£o cr√≠tica <br>  - T1: Linha 6, o fluxo adormece <br>  - T2: in√≠cio da linha # 3 <br>  - T2: a linha 4 congela enquanto aguarda uma se√ß√£o cr√≠tica <br>  - T1: a linha 7 libera a se√ß√£o cr√≠tica e congela enquanto aguarda o pulso sair <br>  - T2: a linha 8 entra na se√ß√£o cr√≠tica <br>  - T2: a linha 11 notifica T1 usando o m√©todo Pulse <br>  - T2: a linha 14 sai da se√ß√£o cr√≠tica.  At√© ent√£o, T1 n√£o pode continuar a execu√ß√£o. <br>  - T1: a linha 15 acorda <br>  - T1: a linha 16 sai da se√ß√£o cr√≠tica <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O MSDN</a> possui uma observa√ß√£o importante sobre o uso dos m√©todos Pulse / Wait, a saber: O Monitor n√£o armazena informa√ß√µes de status, o que significa que, se o m√©todo Pulse for chamado antes da chamada do m√©todo Wait, poder√° levar a um impasse.</i>  <i>Se essa situa√ß√£o for poss√≠vel, √© melhor usar uma das classes da fam√≠lia ResetEvent.</i> <br><br>  O exemplo anterior demonstra claramente como os m√©todos Wait / Pulse da classe Monitor funcionam, mas ainda deixa d√∫vidas sobre quando deve ser usado.  Um bom exemplo seria essa implementa√ß√£o do BlockingQueue &lt;T&gt;, por outro lado, a implementa√ß√£o do BlockingCollection &lt;T&gt; do System.Collections.Concurrent usa o SemaphoreSlim para sincroniza√ß√£o. <br><a name="ReaderWriterLockSlim"></a><br><h3>  ReaderWriterLockSlim </h3><br>  Esta √© minha primitiva de sincroniza√ß√£o amada, representada pela classe de espa√ßo para nome System.Threading com o mesmo nome.  Parece-me que muitos programas funcionariam melhor se seus desenvolvedores usassem essa classe em vez do bloqueio usual. <br><br>  <i>Id√©ia: muitos threads podem ler, apenas uma grava√ß√£o.</i>  <i>Assim que o fluxo declara seu desejo de gravar, novas leituras n√£o podem ser iniciadas, mas aguardam a conclus√£o da grava√ß√£o.</i>  <i>Existe tamb√©m o conceito de bloqueio de leitura atualiz√°vel, que pode ser usado se voc√™ entender durante o processo de leitura que precisa escrever algo; esse bloqueio ser√° convertido em bloqueio de grava√ß√£o em uma opera√ß√£o at√¥mica.</i> <br><br>  <i>H√° tamb√©m uma classe ReadWriteLock no espa√ßo para nome System.Threading, mas √© altamente recomend√°vel para novo desenvolvimento.</i>  <i>A vers√£o Slim permitir√° evitar v√°rios casos que levam a conflitos, al√©m de permitir a captura r√°pida do bloqueio, porque</i>  <i>suporta sincroniza√ß√£o no modo espera por rota√ß√£o antes de sair para o modo kernel.</i> <br><br>  Se, no momento da leitura deste artigo, voc√™ ainda n√£o conhecia essa classe, acho que agora voc√™ se lembrou de alguns exemplos do c√≥digo escrito recentemente, em que essa abordagem de bloqueios permitiria que o programa funcionasse com efici√™ncia. <br><br>  A interface da classe ReaderWriterLockSlim √© simples e direta, mas seu uso dificilmente pode ser chamado de conveniente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { @lock.ExitReadLock(); }</span></span></code> </pre><br>  Eu gosto de agrupar seu uso em uma classe, o que o torna muito mais conveniente. <br>  Id√©ia: criar m√©todos Read / WriteLock que retornam um objeto com o m√©todo Dispose, isso permitir√° que eles sejam usados ‚Äã‚Äãno uso e pelo n√∫mero de linhas dificilmente ser√° diferente do bloqueio usual. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RWLock</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WriteLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterWriteLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitWriteLock(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ReadLockToken : IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLockToken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReaderWriterLockSlim @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">lock</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.EnterReadLock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.ExitReadLock(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReaderWriterLockSlim @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReaderWriterLockSlim(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ReadLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> WriteLockToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WriteLockToken(@<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; @<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>.Dispose(); }</code> </pre><br>  Esse truque permite que voc√™ simplesmente escreva mais: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rwLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RWLock(); <span class="hljs-comment"><span class="hljs-comment">// ... using(rwLock.ReadLock()) { // ... }</span></span></code> </pre><br><a name="ResetEvent"></a><br><h3>  Fam√≠lia ResetEvent </h3><br>  Incluo as classes ManualResetEvent, ManualResetEventSlim, AutoResetEvent a esta fam√≠lia. <br>  As classes ManualResetEvent, sua vers√£o Slim e a classe AutoResetEvent podem estar em dois estados: <br>  - Um engatilhado (n√£o sinalizado), nesse estado, todos os threads que chamaram WaitOne congelam at√© que o evento seja transferido para um estado sinalizado. <br>  - O estado abaixado (sinalizado), nesse estado, todos os fluxos pendurados na chamada WaitOne s√£o liberados.  Todas as novas chamadas do WaitOne em um evento de degrada√ß√£o passam instantaneamente condicionalmente. <br><br>  A classe AutoResetEvent difere da classe ManualResetEvent, pois entra automaticamente em um estado armado depois que libera exatamente um thread.  Se v√°rios threads ficarem esperando enquanto o AutoResetEvent, a chamada Set liberar√° apenas um arbitr√°rio, diferente do ManualResetEvent.  ManualResetEvent lan√ßar√° todos os threads. <br><br>  Vejamos um exemplo de como o AutoResetEvent funciona: <br><pre> <code class="cs hljs">AutoResetEvent evt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoResetEvent(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Thread t1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T1); t1.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Thread t2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(T2); t2.Start();</code> </pre><img src="https://habrastorage.org/webt/ku/us/k2/kuusk2oupkj4_gftf8fixy_51pu.png"><br><br>  O exemplo mostra que o evento entra em estado de arma√ß√£o (sem sinaliza√ß√£o) automaticamente apenas deixando o encadeamento suspenso na chamada WaitOne. <br><br>  A classe ManualResetEvent, diferentemente do ReaderWriterLock, n√£o √© marcada como obsoleta e n√£o √© recomendada para uso ap√≥s o aparecimento de sua vers√£o Slim.  A vers√£o slim desta classe √© usada eficientemente para pequenas expectativas, como  Isso acontece no modo Spin-Wait, a vers√£o regular √© adequada para as longas. <br><br>  Al√©m das classes ManualResetEvent e AutoResetEvent, a classe CountdownEvent tamb√©m existe.  Essa classe √© conveniente para a implementa√ß√£o de algoritmos, onde a parte que conseguiu ser paralelizada √© seguida pela parte de reunir os resultados.  Essa abordagem √© conhecida como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jun√ß√£o de garfo</a> .  Um excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo √©</a> dedicado ao trabalho desta classe, portanto, n√£o o analisarei em detalhes aqui. <br><a name="Conclusions"></a><br><h2>  Conclus√µes </h2><br><ul><li>  Ao trabalhar com encadeamentos, dois problemas que resultam em resultados incorretos ou ausentes s√£o condi√ß√£o de corrida e impasse </li><li>  Os problemas que fazem com que o programa gaste mais tempo ou recursos - falta de thread e espera ocupada </li><li>  .NET √© rico em sincroniza√ß√£o de threads </li><li>  Existem 2 modos de espera de bloqueio - Spin Wait, Core Wait.  Algumas primitivas de sincroniza√ß√£o de encadeamento .NET usam ambos </li><li>  Interlocked √© um conjunto de opera√ß√µes at√¥micas, usado em algoritmos sem bloqueio, √© a primitiva de sincroniza√ß√£o mais r√°pida </li><li>  O operador de bloqueio e o Monitor.Enter / Exit implementam a ideia de uma se√ß√£o cr√≠tica - um peda√ßo de c√≥digo que s√≥ pode ser executado por um encadeamento de cada vez </li><li>  Os m√©todos Monitor.Pulse / Wait s√£o convenientes para implementar scripts Producer-Consumer </li><li>  O ReaderWriterLockSlim pode ser mais eficiente do que o bloqueio regular em scripts em que a leitura paralela √© aceit√°vel </li><li>  A fam√≠lia de classes ResetEvent pode ser √∫til para sincroniza√ß√£o de threads. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459514/">https://habr.com/ru/post/pt459514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459500/index.html">HTML √© a web</a></li>
<li><a href="../pt459502/index.html">Continuamos a desenvolver uma plataforma de aventura para os russos: recursos de interface e prefer√™ncias de ver√£o</a></li>
<li><a href="../pt459504/index.html">Curso para jovens designers de jogos: como contar o equil√≠brio de caracteres e equipamentos sem matem√°tica</a></li>
<li><a href="../pt459506/index.html">As aventuras dos indescrit√≠veis Malvari, parte III: intrincados scripts VBA para riso e lucro</a></li>
<li><a href="../pt459508/index.html">5 slides que os apresentadores experientes ignoram</a></li>
<li><a href="../pt459518/index.html">Explica√ß√£o da tarefa Python com entrevistas de emprego</a></li>
<li><a href="../pt459520/index.html">Um modelo de uma s√©rie natural de n√∫meros e seus elementos. Rhombuses</a></li>
<li><a href="../pt459528/index.html">Como ensinamos ecologia francesa e coletamos garrafas</a></li>
<li><a href="../pt459530/index.html">Microbiota. Hist√≥ria dos m√©todos de estudo e pesquisa</a></li>
<li><a href="../pt459532/index.html">Como escolher um n√∫mero aleat√≥rio de 1 a 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>