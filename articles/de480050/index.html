<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🍳 🗓️ 🏂 Feldstudien zum Konzept „Dokumentation als Code“ 🎾 ✋🏻 👩‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Denis Oleynik, ich arbeite als technischer Direktor bei 1Service. 

 In unserem Unternehmen widmen wir viel Zeit der B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Feldstudien zum Konzept „Dokumentation als Code“</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480050/"> Hallo allerseits!  Mein Name ist Denis Oleynik, ich arbeite als technischer Direktor bei 1Service. <br><br>  In unserem Unternehmen widmen wir viel Zeit der Bearbeitung von Anforderungen.  Als wir Erfahrungen gesammelt haben, stellten wir fest, dass die Tools, die üblicherweise für die Entwicklung von Softwareprodukten verwendet werden, dazu führen, dass wir nicht sagen können, dass wir genau das umgesetzt haben, was der Kunde von uns wollte.  Gerade weil es irgendwann eine Lücke zu den anfänglich gesammelten Anforderungen aus deren Softwareimplementierung und nachfolgenden Tests gibt. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ab/n_/zv/abn_zvcxme2j8ecgq6busq2we7o.png"></div><br>  Diese Linie liegt irgendwo zwischen den in Confluence erfassten Anforderungen und den Aufgaben für deren Implementierung in Jira.  Eine weitere Linie führt zwischen den Testfällen im Testtool und den gleichen Anforderungen in Confluence, wobei der mit den Aufgaben in Jira verbundene Code im Auge behalten wird.  Das Fehlen klarer Antworten auf die Fragen: „Warum / warum haben wir das so umgesetzt?“ Oder „Haben wir alles getan, was der Kunde von uns wollte?“ - hat uns sehr beschäftigt. <br><a name="habracut"></a><br>  Und irgendwann schien es uns, dass das Konzept „Dokumentation ist Code“ (Dokumentation als Code) uns erlauben wird, Antworten auf diese Fragen zu finden.  Das Konzept „Dokumentation ist Code“ setzt voraus, dass wir Anforderungen, Architekturlösungen und Benutzeranweisungen in Form von einfachen Textdateien speichern, die mithilfe von <abbr title="Distributed Version Control System">(D) VCS-</abbr> Klassensystemen versioniert werden können. <abbr title="Distributed Version Control System">Idealerweise</abbr> sollten die Eingabe- / Ausgabedatenmodelle auch in einer Ebene gespeichert werden Textform.  Echte „lesbare“ Dokumente (sowie ausführbare Module) werden als Ergebnis der Zusammenstellung des Projekts angezeigt.  In diesem Fall wird die technische Dokumentation zusammen mit der Entwicklung des gesamten Projekts nach denselben Prinzipien der Codeversionierung erstellt, wodurch die Kriterien der durchgängigen Rückverfolgbarkeit, Verifizierung und Relevanz erfüllt werden.  Dieser Ansatz löst auch das Problem der Organisation der sogenannten "Basisversion von Anforderungen" (Baselines), die für viele Anforderungsmanagementsysteme zu einem echten Problem wird.  Insbesondere in Confluence wird empfohlen, dieses Problem zu lösen, indem eine Kopie des ursprünglichen Bereichs erstellt wird, in dem die Anforderungen erstellt wurden, während jegliche Verbindung und Vererbung der Anforderungen verloren geht.  Eigentlich ist dieser Artikel der Feldforschung dieses Konzepts in unserem Unternehmen gewidmet. <br><br><h2>  Hintergrund </h2><br>  Was unserer Meinung nach die breite Anwendung dieses Konzepts in der Masse aufhält, ist das Elend der Werkzeuge zur visuellen Darstellung und Verwaltung von Anforderungen in einer flachen Textform.  Dies bedeutet, dass Sie keine einfachen Textdateien für den Product Owner anzeigen, damit er Project Scope in ihnen sieht. Sie können keine Textdateien auf der Präsentationsseite für die Stakeholder anzeigen, sie haben keine Grafiken, Diagramme und Bilder in der Bearbeitungsphase - und dies mag Business-Analysten bereits nicht was im Wesentlichen Inhalte generieren sollte.  Und nur die Entwickler sind glücklich und rufen: „Cool!  nur hardcore!  mehr Verpflichtungen! “und andere Häresien. <br><br>  Es gibt noch einen anderen subtilen Punkt.  Aus irgendeinem Grund sind sich Apologeten des Konzepts "Dokumentation ist Code" sicher, dass, sobald die Dokumentation neben dem Code im Repository liegt, dies zu einer obligatorischen Anpassung und Synchronisierung mit Änderungen des Codes führt, wodurch dieser auf dem neuesten Stand gehalten werden kann ( <a href="https://doctoolchain.github.io/docToolchain/" rel="nofollow">Abschnitt 1.2.1</a> )  Aber unserer Meinung nach wird dieser Moment eine Frage der Disziplin bleiben, da niemand die Mühe macht, den Code zu ändern, und die Dokumentation sich nicht ändert.  Das heißt, die Relevanz der Dokumentation bei einer solchen Implementierung des Konzepts bleibt der Verwaltung des Entwicklungsprozesses überlassen, wobei der obligatorische Schritt vor der Freigabe darin besteht, "die Relevanz der Dokumentation zu überprüfen".  In diesem Fall ist „Dokumentation ist ein Code“ nicht weit von Word-Dateien entfernt, wenn Sie beim Kompilieren der resultierenden Dokumente einige Automatisierungsschritte nicht berücksichtigen. <br><br>  Ja, erstens ist es "unbequem, geliebt, trocken", und zweitens decken technische Chips das Problem der Aktualisierung der Dokumentation mit einem Tuch ab.  Es gibt ein allgemeines Stereotyp: "Wir sind im Gefängnis - aber wir brauchen keine Dokumentation im Gefängnis!"  Um es milde auszudrücken, das ist nicht ganz richtig.  Ich möchte diesen Fehler durch einen Vergleich der Use-Case- und User-Story-Ansätze aus Karl Wigers exzellentem Buch „Software Requirements Development“ [4] widerlegen.  Wenn wir Entwicklungsansätze, die auf User Stories basieren, mit der Agile-Methodik in Beziehung setzen, formuliert Wigers die Entwicklung von Anforderungen, die auf User Stories basieren, folgendermaßen: <blockquote>  Benutzerhistorie → (Diskussionen) → Aktualisierte Benutzerhistorie (mit Akzeptanzkriterien) → (Diskussionen) → Akzeptanztests </blockquote>  (S. 169, Abb. 8-1).  Daher ist die Ausgabedokumentation als Ergebnis der Entwicklung der anfänglichen Anforderungen in agilen Entwicklungsprojekten Abnahmetests.  Heutzutage sind Testskripte, die in der Sprache <a href="https://cucumber.io/docs/gherkin/reference/" rel="nofollow">Gherkin</a> [5] geschrieben sind und in sogenannten Feature-Dateien (einfach, Text) gespeichert sind, eine weit verbreitete Methode zum Organisieren von Abnahmetests. <br><br>  Um <b>die Umsetzung des Konzepts „Dokumentation ist Code“ in agilen Entwicklungsprojekten zu unterstützen, benötigen wir daher ein Tool, das die Entwicklung der Anforderungen vom User Story-Format bis zu Abnahmetests begleitet</b> und aufgrund ihrer erfolgreichen Ausführung relevante Dokumentationen generiert.  Leider gibt es bis heute kein Tool, das diesen Prozess vollständig unterstützt (oder zumindest den Wunsch postuliert, ihn zu unterstützen). <br><br><h2>  Architektur der Forschungswerkzeuge </h2><br>  Es gibt also kein Werkzeug, aber ich möchte das Konzept untersuchen.  Aus Hoffnungslosigkeit mussten wir es entwickeln.  Wenn es ein solches Tool (nennen wir es StoryMapper) bereits gab, welche Architektur hätte es, um sich mit minimalem Stress unauffällig in ein vorhandenes Ökosystem des Entwicklungsprozesses zu integrieren?  Wenn dies bereits ein aufgebauter Entwicklungsprozess ist, wird die <abbr title="Kontinuierliche Integration / kontinuierliche Lieferung">CI / CD-</abbr> Schleife wahrscheinlich bereits ausgeführt, und das Versionskontrollsystem, das höchstwahrscheinlich auf Git basiert, wird zweifellos verwendet.  In diesem Fall zeigt das folgende Diagramm die Position von StoryMapper während des Entwicklungsprozesses: <br><br><div style="text-align:center;"> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/ax/5m/p7/ax5mp7qkhpzqsilbvpzrbun3-ue.png"></a> </div><br>  <i>Abb.</i>  <i>1 Platzieren Sie das StoryMapper-Tool in der Struktur des Entwicklungsprozesses</i> <br><br>  Somit interagiert StoryMapper direkt mit den Hosting-Diensten von Git-Repositories und mit der <abbr title="Kontinuierliche Integration / kontinuierliche Lieferung">CI / CD-</abbr> Schleife.  Die Integration mit Git-Hosting-Diensten ist erforderlich, um die aktuelle Sammlung von Feature-Dateien (falls vorhanden) abzurufen sowie die Ergebnisse von Änderungen an Feature-Dateien, Service-Dateien im Zusammenhang mit der Strukturierung der Dokumentation, Beispiele für Eingabe- und Ausgabedaten in das Repository usw. zu übertragen. . <abbr title="Kontinuierliche Integration / kontinuierliche Lieferung">CD</abbr> usw. die Interaktion mit der Kontur <abbr title="Kontinuierliche Integration / kontinuierliche Lieferung">CI /</abbr> notwendig , um die Montage Szenariotests (manuell oder geplant) und für nachfolgende Testergebnisse in der Lage sein zu laufen - sie mit einem entsprechenden Merkmal-Dateien entsprechen (wie Obra  th wird die Überprüfung und die Überprüfung der Dokumentation Relevanz). <br><br>  Man muss verstehen, dass StoryMapper kaum den Titel eines „weiteren Gherkin-Editors“ beanspruchen muss.  Ja, die grundlegenden Funktionen zum Bearbeiten von Feature-Dateien sollten festgelegt werden. Wir sind uns jedoch darüber im Klaren, dass <abbr title="Wirtschaftsanalytiker">BA</abbr> oder <abbr title="Qualitätssicherung (Ingenieur)">QA</abbr> , wenn sie sich für VSC, Sublime, Notepad ++ oder sogar vi entschieden haben (warum nicht?), Sie davon überzeugen, nur mit Anforderungen in StoryMapper zu arbeiten die aufgabe ist nicht so undankbar, sondern falsch.  Daher gehen wir davon aus, dass die Möglichkeit einer vielfältigen Verwendung von StoryMapper festgelegt werden sollte, insbesondere: Die Entwicklung von Features in Ihrem bevorzugten Editor, und StoryMapper wird zum Strukturieren von vorgefertigten Feature-Dateien verwendet.  Mehr dazu im Abschnitt Forschungsrichtungen. <br><br><h2>  Erforderliche Mindestfunktionalität </h2><br>  Da sich StoryMapper derzeit im MVP-Status befindet, sind dies die Mindestanforderungen, die wir an StoryMapper gestellt haben, damit wir es wirklich verwenden können: <br><br><ul><li>  Git-basiertes Story-Mapping; </li><li>  Gurken-Editor; </li><li>  Starten der Zusammenstellung von Szenariotests (manuell und gemäß Zeitplan); </li><li>  Reflexion der Ergebnisse von Szenariotests auf der Karte von User Stories. </li></ul><br>  Ich werde nicht auf die Funktionalität des Werkzeugs eingehen, da das Thema dieses Artikels der Operationsverlauf und nicht das Skalpell des Chirurgen ist. <br><br><h2>  Forschungsbereiche </h2><br>  Die Hauptidee ist folgende: <b>Wenn Sie bei der Verwendung des Konzepts "Dokumentation ist Code" nicht die Anforderungen des Kunden erfüllen und beim Schreiben des Codes eine beliebige Dokumentation erstellen, wird diese Dokumentation so schnell ungültig wie die Version mit Dateien im MS-Format Wort</b>  Aus diesem Grund wollten wir überlegen und untersuchen, ob das Konzept für den gesamten Entwicklungszyklus verwendet werden kann.  Andererseits interessierten wir uns auch für den Übergangszeitpunkt, in dem das Team nicht das Konzept „Dokumentation ist ein Code“ verwendet, sondern es anwenden möchte - wie soll man in diesem Fall vorgehen? <br><br>  StoryMapper ist also ein Tool, das nicht den einzig wahren Anwendungsfall regelt.  Im Gegenteil, jeder potenzielle Benutzer kann seine Optionen für die Verwendung des Tools sehen.  Wir haben uns auf drei Hauptbereiche konzentriert: <br><br><ul><li>  Flexible Entwicklung: von einer Story Map bis zu Akzeptanztests; </li><li>  Strukturieren und Visualisieren einer Sammlung von Feature-Dateien; </li><li>  Produktivitätsüberwachung. </li></ul><br>  Im Folgenden werde ich detailliert beschreiben, welche Ergebnisse wir in jeder Richtung erzielt haben. <br><br><h3>  Flexible Entwicklung: von Story Cards bis zu Abnahmetests </h3><br>  Diese Richtung beinhaltet die Entwicklung eines neuen Produkts oder die Verfeinerung eines bestehenden.  Die Arbeit in dieser Richtung erfolgte unter dem Codenamen "BDDSM": als Kombination der Story-Mapping-Technik und der <abbr title="Verhaltensorientierte Entwicklung">BDD-</abbr> Entwicklungsmethodik.  Und es hat Wurzeln geschlagen. <br><br>  Für den Anfang wird ein Git-Repository für Feature-Dateien erstellt, in dem ein Zweig für die Interaktion mit StoryMapper zugeordnet ist.  In StoryMapper wird ein Projekt erstellt, das mit Geschäftsanalysten verbunden ist, die an dem Projekt arbeiten.  In der Kommunikation mit Stakeholdern beginnen Business Analysten, eine gemeinsame Vision des Produkts zu formulieren und diese in Form eines Skeletts einer User Story Map [1,2] zu fixieren, zunächst eine Skizze der ersten Ebene von <abbr title="Nutzungsablauf">UF</abbr> : <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/ev/lv/k8/evlvk8xeq30ksqkv0vkyzovqmca.png"></a> <br>  <i>Abb.</i>  <i>6 Oberes Skelett der Karte der User Stories (anklickbar)</i> <br><br>  Und dann schrittweise die zweite Ebene der Benutzeraktivitäten ausfüllen: <br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/lh/bw/fi/lhbwfi8y02ykxh4tm-ri_-ra-ms.png"></a> <br>  <i>Abb.</i>  <i>7 Gerüst der zweiten Ebene der Karte mit User Stories</i> <br><br>  Da es sich bei jeder Karte um eine Textdatei handelt, entweder in der Phase des Sammelns von Anforderungen (wenn die Karte im Zuge der Kommunikation mit dem Benutzer zusammengestellt wird) oder in der Phase der Nachbearbeitung der Interviews, werden die Kommunikationsergebnisse direkt an die <abbr title="Nutzungsablauf">UF-</abbr> und <abbr title="Benutzeraktivität">UA-</abbr> Karten übertragen.  Dies ist die Grundlage für eine weitere Zerlegung der Anforderungen auf die Ebene der User Stories. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/8h/es/vp/8hesvpc9r36merm_u_nasdpm8pm.png"></a> <br>  <i>Abb.</i>  <i>8 Anforderungenstext ohne Gherkin-Syntax auf <abbr title="Nutzungsablauf">UF-</abbr> Ebene</i> <br><br>  Als Nächstes lernen Business-Analysten, wie Benutzeraktivitäten in User Stories zerlegt werden, und bilden im StoryMapper - <abbr title="User Story">US</abbr> eine dritte Kartenebene.  Die Isolation der <abbr title="User Story">USA ist</abbr> mit der Formulierung von Akzeptanzkriterien verbunden, dh wenn Sie als jemand etwas wollen, werden wir überprüfen, ob Sie es erhalten haben [3].  Akzeptanzkriterien für Starter können in den <abbr title="User Story">USA auch</abbr> als Flachtext festgelegt werden. <br><br>  Nachdem die Akzeptanzkriterien festgelegt und mit den Stakeholdern abgestimmt wurden, setzen sie die Geschäftsanalysten in Form von Skripten in der Sprache Gherkin ein.  Tatsächlich wird an jedes Akzeptanzkriterium der Text „Szenario: KP-Nr.“ Angehängt, der die bisher abstrakte User Story in eine Feature-Datei verwandelt. <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/s7/lb/sg/s7lbsgymsjujxfj10dtwlok3ol4.png"></a> <br>  <i>Abb.</i>  <i>8.1 Akzeptanzkriterien für User Stories als Skripte auf Gherkin</i> <br><br>  Danach wird jedes Szenario durch mehrere vergrößerte Schritte entschlüsselt, aus denen hervorgeht, wie genau ein bestimmtes Akzeptanzkriterium überprüft wird.  Ferner werden diese Schritte entweder von den Entwicklern programmiert oder aus der Bibliothek der Schritte des verwendeten Gherkin-Frameworks eingegeben und zum Exportieren von Skripten exportiert. <br><br>  Parallel dazu wird ein Prüfstand eingerichtet, auf dem der Assembly-Server Funktionstests durchführt und wartet, bis die <abbr title="User Story">USA</abbr> mit Skripten fertig sind.  Sobald das Produkt und die Szenarien, in denen die Akzeptanzkriterien implementiert sind, fertig sind, gibt der Assembly-Server Berichte in den Formaten Allure und Cucumber aus und sendet sie an StoryMapper. Dadurch wird das Assembly-Ergebnis im Format Cucumber auf die User Story Map projiziert: <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/hp/nw/e7/hpnwe7qsihsq9a-i9dyen1t1ahw.png"></a> <br>  <i>Abb.</i>  <i>9 Karte mit User Stories mit Skriptergebnissen</i> <br><br>  Gleichzeitig bietet StoryMapper drei Ebenen für das Verständnis der Produktbereitschaft: UF ist die oberste Ebene, auf der die Anzahl der ordnungsgemäß funktionierenden Skripte (die die Akzeptanzkriterien erfüllen) angezeigt wird, die fehlerhaft arbeiten und noch nicht bereit sind.  Das heißt, die oberste Ebene ist ein Indikator für die Produktbereitschaft und ein Indikator dafür, wie viel noch zu tun ist (dies ist die Ebene des Product Owner).  In den unteren Ebenen können Sie genau herausfinden, welche Art von Benutzeraktivitäten es gibt und wo Sie Anstrengungen unternehmen müssen, um das Produkt fertigzustellen (dies ist die Ebene der Scrum Master in größerem Umfang und der Product Owner in geringerem Umfang).  Die niedrigere Ebene in den <abbr title="User Story">USA</abbr> ist die Ebene, auf der Geschäftsanalysten, Entwickler und Qualitätssicherung interagieren und gemeinsam genau das Produkt entwickeln, das die Stakeholder von ihnen erwarten. <br><br>  Außerdem wird in einem der letzten Schritte der Fertigungslinie eine automatische Dokumentation erstellt.  Mehr dazu können Sie mit <a href="https://habr.com/ru/post/420175/">Kollegen</a> lesen.  Dies ist nicht die einzige Option. Wir planen, das <a href="https://github.com/picklesdoc/pickles/" rel="nofollow">Pickles-</a> Paket in unser Tool aufzunehmen - den De-facto-Standard in der Welt der „Live-Dokumentation“. <br><br><h3>  Strukturieren und Visualisieren einer Sammlung von Feature-Dateien </h3><br>  Bei unserer Arbeit in diese Richtung haben wir uns einen solchen Fall angesehen.  Das Entwicklungsteam hat sich nach dem Hype um das Thema BDD, Funktionstests und Branchenentwicklungsstandards vorgenommen, Feature-Dateien zu schreiben.  Und die Dornen durchbrechen, hat eine ziemlich große Sammlung im Repository angesammelt.  Wenn Sie jedoch 10 Dateien in Ihrer Sammlung haben, gibt der Bericht im Allure-Format immer noch ein zuverlässiges Bild des Produktzustands.  Aber wenn die Anzahl der Feature-Dateien in Dutzenden und manchmal Hunderten gemessen wird, werden Sie sie früher oder später irgendwie strukturieren wollen.  Das erste, was mir einfällt, ist, sie in thematische Ordner zu sortieren.  Und wofür?  Von Stakeholdern, von Metadaten, von Subsystemen?  Dies sind alles andere als leere Fragen.  Und wenn sich später herausstellt, dass Feature-Dateien ursprünglich so geschrieben wurden, wie Gott es der Seele vorschreibt, und es Skripte gibt, die sich auf mehrere Ordner gleichzeitig beziehen, wie dann? <br><br>  Dieser Anwendungsfall impliziert also den Wunsch, Ihre Dokumentation zu bereinigen, um von „Funktionen separat, Dokumentation separat“ zu „Dokumentation ist ein Code“ zu wechseln.  Wenn ein solches Repository mit StoryMapper verbunden ist, fallen alle Feature-Dateien in die erste Spalte unter UF0 und UA0.  Der nächste Schritt bei der Strukturierung besteht darin, das Gerüst der Struktur zusammenzusetzen.  In StoryMapper sind dies alle <abbr title="Nutzungsablauf">UF</abbr> und <abbr title="Benutzeraktivität">UA gleich</abbr> , aber niemand besteht darauf, sie nur aus diesem Blickwinkel zu betrachten.  Sie können einfach als zwei Hierarchieebenen betrachtet werden, unter denen zuvor unstrukturierte Feature-Dateien abgelegt werden können.  Nachdem die Struktur festgelegt wurde, werden Feature-Dateien aus der ersten Spalte unter der entsprechenden <abbr title="Benutzeraktivität">UA auseinandergezogen</abbr> .  Zweifellos verursacht dieser Prozess einen Angriff der Reflexion und Umgestaltung von Features, da beim Ziehen die gesamte Tiefe des Chaos deutlich wird, das sich während des anfänglichen Schreibens ereignet hat.  Manchmal reicht es aus, das Skript von einer Datei in eine andere zu übertragen, manchmal eine große Datei in mehrere zu teilen, um die semantische Konnektivität wiederherzustellen, und manchmal es einfach in den Papierkorb zu werfen, da alte, nicht ausführbare Manuskripte im Repository lagen. <br><br>  Wenn die Assembly-Linie bereits konfiguriert wurde (da es ein Feature-File-Repository gibt, müssen sie irgendwo gesammelt werden), müssen Sie einen Schritt hinzufügen, um die Assembly-Ergebnisse an StoryMapper zu senden.  Das Endergebnis ist das letzte Bild aus dem vorherigen Abschnitt (Abb. 9): Strukturierte Feature-Dateien mit Markierungen auf den Ergebnissen ihrer Skripte. <br><br>  Wie benutzt man ein solches Bild?  Es kann dem Managementteam gezeigt werden, um über die Ergebnisse des Teams zu berichten und den Grad der Bereitschaft / Qualität des Produkts nachzuweisen.  Es kann vom Team bei der Durchführung einer Retrospektive verwendet werden, um <abbr title="Definition von getan">DoD</abbr> zu korrigieren oder den Prozess irgendwie zu korrigieren.  Es kann für die Rückstandsbereinigung verwendet werden, dies erfordert jedoch bereits Arbeiten gemäß dem im vorherigen Abschnitt beschriebenen Szenario, wenn nach der anfänglichen Strukturierung der Anforderungen die weitere Entwicklung in einem vollständigen Zyklus durch StoryMapper (oder zumindest unter Berücksichtigung von StoryMapper) ausgeführt wird. <br><br><h3>  Produktüberwachung </h3><br>  Ein weiterer Nebenanwendungsfall, der in unserer Praxis Fuß gefasst hat.  Tatsächlich ist es ein modernes und modisches Thema - warum nicht direkt im Produkt testen.  Immerhin gibt es keinen Fehler, nein, und ja, sie werden es schaffen.  Dies ist insbesondere dann relevant, wenn die IT-Aktivität nicht für das Unternehmen relevant ist und die Entwicklung auslagert, insbesondere wenn es sich um kleine und mittlere Online-Shops handelt. <br><br>  Wie wir es sehen.  Eine einfache Option: Aus der Reihe der Funktionstests wird eine bestimmte Teilmenge nicht modifizierender Datenbanktests ausgewählt, die das Front-End überprüfen.  :  ,  -,   ,    ,    -,        ,           .     ,            .       StoryMapper  Allure,   ,         —          ,   ,      ,      IT-      . <br><br>         ,           ,         . ,    ,  ,       ,   -      . <br><br> ,      ,  : <br><br><ul><li>    ,   ; </li><li>  ,     ,     ; </li><li> StoryMapper          ; </li><li>   StoryMapper      . </li></ul><br><h2>  Entwicklungsrichtungen </h2><br> ,     StoryMapper    MVP.   ,    «  », ,   ,  ,  .    ,  ,    «   ».     ,      : <br><br><ul><li>      « »,        « —  »; </li><li>      (,  etc. ); </li><li> /    / Excel; </li><li> -   Jira (   ,  ). </li></ul><br>    ,           ,         ,        .              ,          . <br><br><h2>    </h2><br>            (    ),           ,        (  !) —     <a href="https://t.me/joinchat/HFo0pFlks_KXD41PjjbFoQ" rel="nofollow">telegram</a> ,    . <br><br><h2>     </h2><br><ol><li>  ,  .    , ., , 2017. </li><li>  ,  .    , .-.-, , 2012. </li><li> Gojko Adjic, Specification by Example, NY, Manning Publication, 2011. </li><li>  ,  ,     , .:  ; .: -, 2014. </li><li> <a href="https://dannorth.net/whats-in-a-story/" rel="nofollow">   BDD   «What's in a story»</a> </li><li> <a href="https://www.writethedocs.org/guide/docs-as-code/" rel="nofollow">   « —  »   «Write the docs»</a> </li><li>   « —  »   " <a href="https://doctoolchain.github.io/docToolchain/" rel="nofollow">docToolchain</a> " </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480050/">https://habr.com/ru/post/de480050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480038/index.html">Bewegen Sie sich mit Xamarin.Forms 4.4</a></li>
<li><a href="../de480040/index.html">Was bedeutet es für die Rambler Group, Nginx und die Gründer zu treffen und wie wirkt es sich auf die Online-Branche aus?</a></li>
<li><a href="../de480042/index.html">Selbstständige und eigene Projekte. Nach Nginx</a></li>
<li><a href="../de480044/index.html">Ein zweites Jahr von Q #</a></li>
<li><a href="../de480048/index.html">Entmystifizierung des neuen .NET Core 3 Worker Service</a></li>
<li><a href="../de480052/index.html">SEO vs. PPC - Was ist besser für Ihr Unternehmen?</a></li>
<li><a href="../de480056/index.html">Versteckte Kameraaktivierung durch Browser: Big Brother oder Technologie-Fehleinschätzung?</a></li>
<li><a href="../de480058/index.html">Transformatorstern auf dem Weihnachtsbaum</a></li>
<li><a href="../de480060/index.html">Einfacher P300-Klassifikator für offene Daten</a></li>
<li><a href="../de480062/index.html">10 Steuersysteme. Wo ist es bequemer, über Aufgaben zu kommunizieren und Dateien zu teilen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>