<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎴 🤸🏽 🧑🏽 Apakah mudah untuk menambahkan fitur baru ke kerangka lama? Pilihan tepung pada contoh pengembangan SObjectizer 🤳 ☔️ 🔎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengembangkan kerangka kerja gratis untuk kebutuhan pengembang adalah topik khusus. Jika pada saat yang sama kerangka hidup dan berkembang untuk waktu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah mudah untuk menambahkan fitur baru ke kerangka lama? Pilihan tepung pada contoh pengembangan SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  Mengembangkan kerangka kerja gratis untuk kebutuhan pengembang adalah topik khusus.  Jika pada saat yang sama kerangka hidup dan berkembang untuk waktu yang agak lama, maka spesifik ditambahkan.  Hari ini saya akan mencoba menunjukkan ini menggunakan contoh upaya untuk memperluas fungsionalitas kerangka kerja “aktor” untuk C ++ yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> . <br><br>  Faktanya adalah bahwa kerangka kerja ini sudah cukup lama, telah berubah secara dramatis beberapa kali.  Bahkan inkarnasinya saat ini, SObjectizer-5, telah mengalami banyak perubahan, baik yang serius maupun yang tidak.  Selain itu, kami cukup peka terhadap kompatibilitas dan memperkenalkan perubahan yang merusak kompatibilitas terlalu serius bagi kami untuk memutuskannya. <br><br>  Saat ini kita perlu memutuskan bagaimana menambahkan fitur baru ke versi berikutnya.  Dalam proses menemukan solusi yang cocok, dua opsi muncul.  Keduanya terlihat cukup bisa diwujudkan.  Tetapi mereka sangat berbeda satu sama lain.  Baik dari segi kompleksitas dan kompleksitas implementasi, dan dalam "penampilannya".  Yaitu  apa yang akan ditangani pengembang akan terlihat berbeda di setiap opsi.  Mungkin bahkan berbeda secara mendasar. <br><br>  Dan sekarang, sebagai pengembang kerangka kerja, kita harus membuat pilihan yang mendukung satu atau solusi lainnya.  Atau kita harus mengakui bahwa tidak ada yang memuaskan dan, oleh karena itu, sesuatu yang lain perlu diciptakan.  Keputusan seperti itu selama sejarah SObjectizer harus dibuat lebih dari sekali.  Jika seseorang tertarik untuk merasakan perkembangan kerangka kerja seperti itu, maka Anda dapat melakukannya. <br><a name="habracut"></a><br><h1>  Masalah asli </h1><br>  Jadi, singkatkan esensi dari masalah aslinya.  Sejak awal keberadaannya, SObjectizer memiliki fitur berikut: pesan penghitung waktu tidak mudah dibatalkan.  Di bawah timer akan dipahami, pertama-tama, pesan yang tertunda.  Yaitu  pesan yang tidak boleh segera dikirim ke penerima, tetapi setelah beberapa waktu.  Sebagai contoh, kami melakukan send_delay dengan jeda 1s.  Ini berarti bahwa pada kenyataannya pesan akan dikirim oleh timer 1s setelah panggilan send_delayed. <br><br>  Pesan yang tertunda dapat, pada dasarnya, dibatalkan.  Jika pesan masih memiliki timer, maka pesan setelah pembatalan tidak akan pergi ke mana pun.  Itu akan dilemparkan oleh timer dan hanya itu.  Tetapi jika timer sudah mengirim pesan dan sekarang ada di antrian permintaan untuk agen penerima, maka membatalkan timer tidak akan berfungsi.  Tidak ada mekanisme dalam SObjectizer untuk menghapus pesan dari antrian aplikasi. <br><br>  Masalahnya diperparah oleh setidaknya dua faktor. <br><br>  Pertama, SObjectizer mendukung pengiriman dalam mode 1: N, mis.  jika pesan dikirim ke mbox Multi-Konsumen, maka pesan tidak akan berada dalam satu antrian, tetapi dalam beberapa antrian untuk penerima N sekaligus. <br><br>  Kedua, SObjectizer menggunakan mekanisme dispatcher dan dispatcher bisa sangat berbeda, termasuk yang ditulis oleh pengguna untuk kebutuhan spesifik mereka.  Antrian permintaan dikelola oleh operator.  Dan di antarmuka dispatcher tidak ada fungsi untuk menarik aplikasi yang sudah ditransfer ke dispatcher.  Tetapi bahkan jika fungsi tersebut tertanam dalam antarmuka, itu jauh dari kenyataan bahwa itu dapat diimplementasikan secara efektif dalam semua kasus.  Belum lagi fakta bahwa fungsionalitas seperti itu akan meningkatkan kompleksitas pengembangan dispatcher baru. <br><br>  Secara umum, secara objektif, jika timer telah mengirim pesan yang tertunda ke penerima, maka memaksa SObjectizer untuk tidak mengirimkan instance pesan ini saat ini adalah mustahil. <br><blockquote>  Faktanya, masalah ini juga relevan untuk pesan berkala (mis. Pesan yang harus dikirim timer secara berkala pada interval waktu yang telah ditentukan).  Namun dalam praktiknya, membatalkan pesan berkala jauh lebih tidak penting daripada membatalkan pesan yang tertunda.  Setidaknya dalam praktik kami begini. </blockquote><h2>  Apa yang bisa dilakukan sekarang? </h2><br>  Jadi, masalah ini bukanlah hal yang baru dan untuk waktu yang lama ada rekomendasi tentang bagaimana menghadapinya. <br><br><h3>  Id unik di dalam pesan tertunda </h3><br>  Cara termudah adalah menjaga konter.  Agen memiliki penghitung, saat mengirim pesan yang tertunda, nilai penghitung saat ini dikirim dalam pesan.  Ketika pesan dibatalkan, penghitung di agen bertambah.  Setelah menerima pesan, nilai penghitung saat ini di agen dibandingkan dengan nilai dari pesan.  Jika nilainya tidak cocok, maka pesannya ditolak: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  Masalah dengan metode ini adalah bahwa pengembang agen perlu bingung dengan mempertahankan counter ini.  Dan jika sebagai pesan tertunda kita perlu mengirim pesan orang lain bahwa orang lain melakukannya, dan di mana tidak ada bidang id_, maka kita menemukan diri kita dalam situasi yang sulit. <br><br>  Meskipun, di sisi lain, ini adalah cara paling efektif yang ada saat ini. <br><br><h3>  Gunakan mbox unik untuk pesan yang tertunda </h3><br>  Cara lain yang berfungsi dengan baik adalah dengan menggunakan kotak surat unik (mbox) untuk pesan yang tertunda.  Dalam hal ini, kami membuat mbox baru untuk setiap pesan yang tertunda, berlangganan dan mengirim pesan yang tertunda ke mbox ini.  Ketika sebuah pesan perlu dibatalkan, maka kami cukup menghapus langganan mbox. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Metode ini sudah dapat berfungsi dengan pesan orang lain, di dalamnya tidak ada pengidentifikasi unik.  Tetapi itu juga membutuhkan tenaga dan perhatian dari pengembang. <br><br>  Misalnya, dalam perwujudan di atas, tidak ada perlindungan terhadap fakta bahwa satu pesan yang tertunda telah dikirim sebelumnya.  Dengan cara yang baik, sebelum mengirim pesan tertunda yang baru, Anda harus selalu melakukan tindakan dari on_cancel_event (), jika tidak, agen akan memiliki langganan yang tidak perlu. <br><br><h2>  Mengapa masalah ini belum terpecahkan sebelumnya? </h2><br>  Semuanya cukup sederhana di sini: pada kenyataannya, ini bukan masalah serius seperti kelihatannya.  Setidaknya dalam kehidupan nyata Anda tidak harus sering menghadapinya.  Biasanya pesan yang tertunda dan berkala tidak dibatalkan sama sekali (oleh karena itu, fungsi send_delayed tidak mengembalikan timer_id).  Dan ketika kebutuhan untuk pembatalan muncul, maka Anda dapat menggunakan salah satu metode yang dijelaskan di atas.  Atau bahkan menggunakan yang lain.  Misalnya, buat agen terpisah yang akan memproses pesan yang tertunda.  Agen-agen ini dapat dideregistrasi ketika pesan yang tertunda perlu dibatalkan. <br><br>  Jadi, dengan latar belakang tugas-tugas lain yang berhadapan dengan kami, menyederhanakan pembatalan pesan yang tertunda tidak diprioritaskan untuk menghabiskan sumber daya kami untuk menyelesaikan masalah ini. <br><br><h2>  Mengapa masalah ini relevan sekarang? </h2><br>  Semuanya sesederhana di sini.  Di satu sisi, tangan akhirnya mencapai. <br><br>  Di sisi lain, ketika orang baru yang tidak memiliki pengalaman bekerja dengannya mulai menggunakan SObjectizer, fitur ini dengan pembatalan timer sangat mengejutkan mereka.  Tidak terlalu mengejutkan.  Dan jika demikian, maka saya ingin meminimalkan kesan negatif untuk mengenal alat kami. <br><br>  Selain itu, kami memiliki tugas kami sendiri, kami tidak perlu terus-menerus membatalkan pesan yang tertunda.  Dan pengguna baru memiliki tugas mereka sendiri, mungkin semuanya sebaliknya. <br><br><h1>  Pernyataan masalah baru </h1><br>  Hampir segera, segera setelah pertimbangan kemungkinan "pembatalan waktu dijamin" dimulai, muncul pikiran di benak saya bahwa tugas itu dapat diperluas.  Anda dapat mencoba untuk memecahkan masalah mengingat salah satu pesan yang dikirim sebelumnya, tidak harus ditunda dan berkala. <br><br>  Dari waktu ke waktu kesempatan ini sangat diminati.  Misalnya, bayangkan kami memiliki beberapa agen yang berinteraksi dari dua jenis: entry_point (menerima permintaan dari klien), dan prosesor (memproses permintaan): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Agen Entry_point mengirim permintaan ke agen prosesor, yang memprosesnya sebanyak mungkin dan merespons agen entry_point.  Tetapi kadang-kadang, entry_point mungkin menemukan bahwa memproses permintaan yang dikirim sebelumnya tidak lagi diperlukan.  Misalnya, klien mengirim perintah pembatalan atau klien "jatuh" dan Anda tidak perlu lagi memproses permintaannya.  Sekarang, jika pesan permintaan diantrekan oleh agen prosesor, maka Anda tidak dapat mengingatnya.  Dan itu akan bermanfaat. <br><br>  Oleh karena itu, pendekatan saat ini untuk memecahkan masalah "pembatalan waktu yang dijamin" dilakukan tepat seperti menambahkan dukungan untuk "pesan penarikan kembali".  Kami mengirim pesan apa pun dengan cara khusus, kami dapat menangani, yang dengannya Anda dapat mengingat pesan tersebut.  Dan itu tidak begitu penting apakah pesan biasa atau yang ditunda merespons. <br><br><h1>  Upaya untuk memunculkan implementasi "recall message" </h1><br>  Jadi, Anda perlu memperkenalkan konsep "recall message" dan mendukung konsep ini di SObjectizer.  Jadi, untuk tetap dalam cabang 5,5.  Versi pertama dari utas ini, 5.5.0, keluar hampir empat tahun lalu, pada Oktober 2014.  Sejak itu, belum ada perubahan besar yang terjadi pada 5.5.  Proyek yang sudah beralih atau segera mulai pada SObjectize-5.5 dapat beralih ke rilis baru di cabang 5.5 tanpa masalah.  Kompatibilitas ini harus dipertahankan saat ini. <br><br>  Secara umum, semuanya sederhana: Anda perlu mengambil dan melakukan. <br><br><h2>  Yang jelas gimana caranya </h2><br>  Setelah pendekatan pertama ke masalah, dua hal menjadi jelas tentang implementasi "pesan recall". <br><br><h3>  Bendera atom dan verifikasi sebelum pemrosesan pesan </h3><br>  Pertama, jelas bahwa dalam kerangka arsitektur SObjectizer-5.5 saat ini (dan mungkin bahkan lebih global: dalam kerangka prinsip-prinsip SObjectizer-5 itu sendiri), tidak mungkin untuk menghapus pesan dari antrian permintaan dispatcher, di mana pesan menunggu sampai agen penerima memprosesnya.  Mencoba melakukan ini akan mematikan seluruh ide para pengirim yang heterogen, yang bahkan dapat dilakukan sendiri oleh pengguna, sesuai dengan spesifikasi tugas mereka (misalnya, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ).  Selain itu, dalam hal mengirim pesan dalam mode 1: N, di mana N akan besar, akan mahal untuk menyimpan daftar petunjuk ke instance dari pesan yang dikirim di semua antrian. <br><br>  Ini berarti bahwa bersama dengan pesan, beberapa jenis bendera atom harus ditransmisikan, yang perlu dianalisis segera setelah pesan dihapus dari antrian permintaan, tetapi sebelum pesan dikirim untuk diproses ke agen penerima.  Yaitu  pesan memasuki antrian dan tidak dihapus di mana pun dari sana.  Tetapi ketika giliran datang ke pesan, benderanya diperiksa.  Dan jika bendera mengatakan bahwa pesan telah ditarik, maka pesan tersebut tidak diproses. <br><br>  Karenanya, penarikan kembali pesan itu sendiri terdiri dari pengaturan nilai khusus untuk bendera atom di dalam pesan. <br><br><h3>  Revocable_handle_t &lt;M&gt; objek </h3><br>  Kedua, sejauh ini (?) Jelas bahwa untuk mengirim pesan yang dapat dibatalkan, bukan metode biasa untuk mengirim pesan yang harus digunakan, tetapi objek khusus di bawah nama kondisional revocable_handle_t. <br><br>  Untuk mengirim pesan yang dapat dibatalkan, pengguna harus membuat instance dari revocable_handle_t, dan kemudian memanggil metode kirim pada instance ini.  Dan jika pesan perlu dipanggil kembali, maka ini dilakukan dengan menggunakan metode pencabutan.  Sesuatu seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Belum ada detail yang jelas dari implementasi revocable_handle_t, yang tidak mengherankan  mekanisme kerja pesan recall belum dipilih.  Tetapi prinsip kerjanya adalah bahwa di revocable_handle_t tautan pintar disimpan ke pesan yang dikirim dan ke bendera atom untuknya.  Metode pencabutan () mencoba untuk mengganti nilai bendera.  Jika ini berhasil, maka pesan, setelah diekstraksi dari antrian pesanan, tidak akan lagi diproses. <br><br><h3>  Apa yang tidak akan berteman dengan </h3><br>  Sayangnya, ada beberapa hal yang membuat pesan yang ditarik tidak dapat ditautkan dengan benar.  Hanya karena pesan yang ditarik terus tetap dalam antrian di mana pesan itu telah tiba. <br><br><h4>  message_limits </h4><br>  Fitur SObjectizer yang penting seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">message_limits</a> dirancang untuk melindungi agen dari kelebihan muatan.  Message_limits berfungsi berdasarkan jumlah pesan dalam antrian.  Antrian pesan - menambah penghitung.  Keluar jalur - dikurangi. <br><br>  Karena  ketika pesan dicabut, ia masih berada dalam antrian, maka message_limits tidak memengaruhi respons pesan.  Oleh karena itu, ternyata antrian memiliki batas jumlah pesan tipe M, tetapi semuanya telah dipanggil kembali.  Bahkan, tidak satu pun dari mereka akan diproses.  Tetapi mengantri pesan baru tipe M tidak akan berhasil, karena  batas terlampaui. <br><br>  Situasinya tidak bagus.  Tapi bagaimana cara keluar dari situ?  Tidak jelas. <br><br><h4>  memperbaiki antrian mchains </h4><br>  Di SObjectizer, sebuah pesan dapat dikirim tidak hanya ke mbox, tetapi juga ke mchain (ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analog dari saluran CSP kami</a> ).  Dan rantai dapat memiliki ukuran tetap untuk antrian mereka.  Upaya untuk menempatkan pesan baru untuk mchain dengan ukuran tetap di mchain penuh harus mengarah pada semacam reaksi.  Misalnya, menunggu keluarnya ruang dalam antrian.  Atau untuk mendorong pesan tertua. <br><br>  Dalam kasus penarikan pesan, pesan itu akan tetap berada di dalam antrian mchain.  Ternyata pesan itu tidak lagi diperlukan, tetapi membutuhkan ruang di antrian mchain.  Dan mencegah pesan baru dikirim ke mchain. <br><br>  Situasi buruk yang sama dengan message_limits.  Dan lagi, tidak jelas bagaimana itu bisa diperbaiki. <br><br><h2>  Yang tidak jelas gimana caranya </h2><br>  Jadi kita sampai pada pilihan antara dua (sejauh ini?) Opsi untuk mengimplementasikan pesan recall.  Opsi pertama adalah sederhana untuk diimplementasikan dan tidak memerlukan perubahan jeroan ayam itik dari SObjectizer.  Opsi kedua jauh lebih rumit, tetapi di dalamnya penerima pesan bahkan tidak tahu bahwa ia berurusan dengan pesan yang dapat dibatalkan.  Kami akan mempertimbangkan secara singkat masing-masing dari mereka. <br><br><h3>  Terima pesan yang dapat dibatalkan sebagai revocable_t &lt;M&gt; </h3><br>  Solusi pertama, yang terlihat, pertama, layak dan, kedua, cukup praktis, adalah pengenalan pembungkus khusus revocable_t &lt;M&gt;.  Saat pengguna mengirimkan pesan tipe M yang dapat dibatalkan melalui revocable_handle_t &lt;M&gt;, itu bukan pesan M yang dikirim, tetapi pesan M di dalam pembungkus khusus revocable_t &lt;M&gt;.  Dan, karenanya, pengguna tidak akan menerima dan memproses pesan bertipe M, tetapi pesan revocable_t &lt;M&gt;.  Misalnya, dengan cara ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  Metode revocable_t &lt;M&gt; :: try_handle () memeriksa nilai flag atom dan, jika pesan tersebut tidak dipanggil, panggilan fungsi lambda diteruskan ke sana.  Jika pesan ditarik, maka try_handle () tidak melakukan apa-apa. <br><br><h4>  Pro dan kontra dari pendekatan ini </h4><br>  Kelebihan utama adalah bahwa perjalanan ini mudah diimplementasikan (setidaknya sejauh ini tampaknya).  Faktanya, revocable_handle_t &lt;M&gt; dan revocable_t &lt;M&gt; hanya akan menjadi tambahan yang halus untuk SObjectizer. <br><br>  Intervensi dalam SObjectizer internal mungkin diperlukan untuk membuat teman revocable_t dan mutable_msg.  Faktanya adalah bahwa dalam SObjectizer ada konsep pesan tidak berubah (mereka dapat dikirim baik dalam mode 1: 1 dan dalam mode 1: N).  Dan ada konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pesan</a> yang bisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diubah</a> yang hanya bisa dikirim dalam mode 1: 1.  Dalam hal ini, SObjectizer dengan cara khusus memperlakukan marker mutable_msg &lt;M&gt; dan melakukan pemeriksaan terkait pada saat run-time.  Dalam kasus revocable_t &lt;mutable_msg &lt;M&gt;&gt;, Anda perlu mengajari SObjectizer untuk memperlakukan konstruk ini sebagai mutable_msg &lt;M&gt;. <br><br>  Kelebihan lainnya adalah bahwa overhead tambahan (baik pada metadata dari pesan yang dapat dibatalkan dan pada verifikasi bendera atom) hanya akan berada di tempat di mana Anda tidak dapat melakukannya tanpa itu.  Jika pesan penarikan tidak digunakan, tidak akan ada overhead tambahan sama sekali. <br><br>  Tetapi minus utama adalah ideologis.  Dalam pendekatan ini, fakta menggunakan pesan yang dapat dibatalkan mempengaruhi pengirim (menggunakan revocable_handle_t &lt;M&gt;) dan penerima (menggunakan revocable_t &lt;M&gt;).  Tetapi penerima hanya tidak perlu tahu bahwa ia menerima pesan penarikan.  Selain itu, sebagai penerima, Anda dapat memiliki agen pihak ketiga yang sudah jadi yang ditulis tanpa revocable_t &lt;M&gt;. <br><br>  Selain itu, pertanyaan ideologis tetap tentang, misalnya, kemungkinan meneruskan pesan tersebut.  Tetapi, menurut perkiraan pertama, masalah ini diselesaikan. <br><br><h3>  Terima pesan recall sebagai pesan biasa </h3><br>  Pendekatan kedua adalah hanya melihat pesan tipe M di sisi penerima dan tidak memiliki gagasan tentang keberadaan revocable_handle_t &lt;M&gt; dan revocable_t &lt;M&gt;.  Yaitu  jika prosesor harus menerima permintaan, maka itu hanya akan melihat permintaan, tanpa pembungkus tambahan. <br><br>  Sebenarnya, seseorang tidak dapat melakukannya tanpa pembungkus dalam pendekatan ini, tetapi mereka akan disembunyikan di dalam SObjectizer dan pengguna seharusnya tidak melihatnya.  Setelah aplikasi diambil dari antrian, SObjectizer akan menentukan sendiri bahwa ini adalah pesan yang dapat dibatalkan yang dibungkus khusus, memeriksa tanda relevansi pesan, dan memperluas pesan jika masih relevan.  Kemudian akan mengirim pesan ke agen untuk diproses seolah-olah itu adalah pesan biasa. <br><br><h4>  Pro dan kontra dari pendekatan ini </h4><br>  Keuntungan utama dari pendekatan ini jelas - penerima pesan tidak tahu pesan apa yang ia gunakan.  Ini memungkinkan pengirim pesan menarik pesan dengan tenang untuk agen apa pun, bahkan yang ditulis oleh pengembang lain. <br><br>  Kelebihan penting lainnya adalah kemampuan untuk berintegrasi dengan mekanisme penelusuran pengiriman pesan (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini peran mekanisme ini dijelaskan secara lebih rinci</a> ).  Yaitu  jika msg_tracing diaktifkan dan pengirim menarik pesan, maka jejak ini dapat ditemukan di log msg_tracing.  Yang sangat nyaman saat debugging. <br><br>  Tetapi kelemahan utama adalah kompleksitas penerapan pendekatan ini.  Di mana beberapa faktor perlu diperhitungkan. <br><br>  Pertama, overhead.  Segala macam hal. <br><br>  Katakanlah Anda dapat membuat panji khusus di dalam pesan yang menunjukkan apakah pesan ini dapat dibatalkan atau tidak.  Dan kemudian periksa bendera ini sebelum mulai memproses setiap pesan.  Secara kasar, lain jika ditambahkan ke mekanisme pengiriman pesan, yang akan berfungsi saat memproses masing-masing (!) Pesan. <br><br>  Saya yakin bahwa dalam aplikasi nyata kerugian ini jika hampir tidak terlihat.  Namun drawdown pada benchmark sintetis pasti akan muncul.  Selain itu, semakin abstrak tolok ukurnya, semakin sedikit pekerjaan yang dia lakukan, semakin dia akan tenggelam.  Dan ini buruk dari sudut pandang pemasaran, karena  ada sejumlah individu yang menarik kesimpulan tentang kerangka kerja dalam hal tolok ukur sintetis.  Dan mereka melakukannya secara spesifik: tidak memahami apa jenis tolok ukurnya, bahwa itu pada dasarnya menunjukkan perangkat keras mana yang bekerja, tetapi membandingkan total dengan kinerja beberapa alat khusus, dalam skenario lain, pada perangkat keras lain, dll. , dll. <br><br>  Secara umum, karena kami membuat kerangka kerja universal, yang ternyata dinilai dengan angka abstrak dalam tolok ukur abstrak, kami tidak ingin kehilangan, katakanlah, 5% dari kinerja dalam mekanisme pengiriman <i>semua</i> pesan karena penambahan fitur yang hanya membutuhkan waktu dari waktu ke waktu dan tidak untuk semua pengguna. <br><br>  Oleh karena itu, Anda perlu memastikan bahwa ketika mengirim pesan ke penerima, SObjectizer memahami bahwa ketika Anda mengekstrak pesan, Anda perlu menanganinya dengan cara khusus.  Pada prinsipnya, ketika pesan dikirim ke agen, SObjectizer menyimpan dengan pesan penunjuk ke fungsi yang akan digunakan saat memproses pesan.  Ini diperlukan sekarang untuk menangani pesan asinkron dan permintaan sinkron dengan berbagai cara.  Sebenarnya, beginilah tampilan permintaan untuk pesan yang ditujukan kepada agen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  Di mana demand_handler_pfn_t adalah pointer fungsi reguler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  Mekanisme yang sama juga dapat digunakan untuk secara khusus memproses pesan yang ditarik.  Yaitu  ketika mbox mengirim pesan ke agen, agen tahu apakah pesan asinkron atau permintaan sinkron dikirim ke sana.  Demikian pula, agen dapat diberi pesan panggilan balik tidak sinkron dengan cara khusus.  Dan agen akan menyimpan, bersama dengan pesan, sebuah penunjuk ke fungsi yang tahu bagaimana seharusnya menangani pesan yang dicabut. <br><br>  Semuanya tampak baik-baik saja, tetapi ada dua "tapi" besar ... :( <br><br>  Pertama, antarmuka mbox yang ada (yaitu, <a href="">abstract_message_mbox_t</a> class) tidak memiliki metode untuk mengirim pesan recall.  Jadi antarmuka ini perlu diperluas.  Dan agar implementasi mbox orang lain yang terikat ke abstract_message_box_t dari SObjectizer-5.5 tidak rusak (khususnya, seri mbox diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">so_5_extra</a> dan saya tidak ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merusaknya</a> ). <br><br>  Kedua, pesan dapat dikirim tidak hanya ke mbox-s, di belakang agen mana yang disembunyikan, tetapi juga ke mchain-s.  Yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mitra kami ke saluran CSP</a> .  Dan sampai sekarang, aplikasi itu berbohong tanpa petunjuk tambahan ke fungsi.  Untuk memperkenalkan pointer tambahan ke setiap elemen mchain antrian aplikasi ... Anda tentu saja bisa, tetapi sepertinya solusi yang agak mahal.  Selain itu, implementasi mchain sendiri belum menyediakan situasi di mana pesan yang diekstraksi perlu diperiksa dan mungkin dibuang. <br><br>  Jika Anda mencoba merangkum semua masalah yang dijelaskan di atas, masalah utama dari pendekatan ini adalah tidak begitu mudah untuk membuat implementasinya sehingga lebih murah untuk kasus-kasus ketika pesan recall tidak digunakan. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tapi bagaimana dengan pembatalan dijamin pesan tertunda? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya khawatir masalah aslinya telah hilang di belantara detail teknis. </font><font style="vertical-align: inherit;">Misalkan ada pesan yang dapat dibatalkan, bagaimana pembatalan pesan yang tertunda / berkala akan terjadi? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini, seperti yang mereka katakan, opsi dimungkinkan. </font><font style="vertical-align: inherit;">Misalnya, bekerja dengan pesan tertunda / berkala dapat menjadi bagian dari fungsionalitas revocable_handle_t &lt;M&gt;:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atau Anda dapat membuat di atas revocable_handle_t &lt;M&gt; kelas pembantu tambahan cancelable_timer_t &lt;M&gt;, yang akan memberikan metode send_delayed / send_ periodic. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bintik putih: permintaan sinkron </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 mendukung tidak hanya interaksi asinkron antara entitas dalam program (dengan mengirim pesan ke mbox dan mchain), tetapi juga interaksi sinkron melalui request_value / request_future. </font><font style="vertical-align: inherit;">Interaksi yang sinkron ini tidak hanya berfungsi untuk agen.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda tidak hanya dapat mengirim permintaan sinkron ke agen melalui mbox-nya. </font><font style="vertical-align: inherit;">Dalam kasus mchains, Anda juga dapat membuat permintaan sinkron, misalnya, ke utas kerja lainnya, yang menerima () atau pilih () dipanggil untuk mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, masih belum jelas apakah harus diizinkan untuk menggunakan permintaan sinkron bersama dengan pesan yang dapat dibatalkan. </font><font style="vertical-align: inherit;">Di satu sisi, mungkin ini masuk akal. </font><font style="vertical-align: inherit;">Dan mungkin terlihat, misalnya, seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sisi lain, masih ada banyak pesan yang tidak dapat dipahami dengan pesan recall, sehingga masalah interaksi sinkron telah ditunda hingga waktu yang lebih baik. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pilih, tapi hati-hati. </font><font style="vertical-align: inherit;">Tapi pilih</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi ada pemahaman tentang masalahnya. </font><font style="vertical-align: inherit;">Ada dua opsi untuk menyelesaikannya. </font><font style="vertical-align: inherit;">Yang saat ini sepertinya layak. </font><font style="vertical-align: inherit;">Tetapi mereka sangat berbeda dalam tingkat kenyamanan yang diberikan kepada pengguna, dan bahkan lebih kuat mereka berbeda dalam biaya implementasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda harus memilih di antara dua opsi ini. </font><font style="vertical-align: inherit;">Atau menghasilkan sesuatu yang lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa kesulitan memilih? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesulitannya adalah bahwa SObjectizer adalah kerangka kerja gratis. </font><font style="vertical-align: inherit;">Dia tidak langsung membawa kita uang. </font><font style="vertical-align: inherit;">Kita melakukannya, seperti kata mereka, untuk kita sendiri. </font><font style="vertical-align: inherit;">Oleh karena itu, murni dari preferensi ekonomi, opsi yang lebih sederhana dan lebih cepat untuk diterapkan lebih menguntungkan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi, di sisi lain, tidak semuanya diukur dalam uang, dan dalam jangka panjang, alat yang dibuat dengan baik, fitur-fitur yang biasanya terhubung satu sama lain, lebih baik daripada tambal sulam yang terbuat dari tambalan yang saling menempel entah bagaimana. Kualitas dievaluasi oleh pengguna dan diri kami sendiri, ketika kami selanjutnya menemani pengembangan kami dan menambahkan fitur baru ke dalamnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, pilihannya, pada kenyataannya, terjadi antara manfaat jangka pendek dan prospek jangka panjang. Benar, di dunia modern, alat C ++ dengan prospek jangka panjang entah bagaimana berkabut. Yang membuat pilihan semakin sulit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kondisi seperti itulah Anda harus memilih. Perhatian Tapi pilih.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel ini kami mencoba menunjukkan sedikit proses mendesain dan mengimplementasikan fitur-fitur baru dalam kerangka kerja kami. </font><font style="vertical-align: inherit;">Proses semacam itu terjadi secara teratur bersama kami. </font><font style="vertical-align: inherit;">Sebelumnya sering karena </font><font style="vertical-align: inherit;">Pada 2014-2016 SObjectizer berkembang jauh lebih aktif. </font><font style="vertical-align: inherit;">Sekarang laju rilis versi baru telah menurun. </font><font style="vertical-align: inherit;">Yang objektif, termasuk karena menambahkan fungsionalitas baru tanpa merusak apa pun, menjadi lebih sulit dengan setiap versi baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap menarik untuk melihat di belakang layar kepada kami.</font></font> Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423879/">https://habr.com/ru/post/id423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423869/index.html">Masa depan pekerjaan. Hal utama dari laporan World Economic Forum</a></li>
<li><a href="../id423871/index.html">Kami memecahkan masalah logis untuk siswa dalam SQL</a></li>
<li><a href="../id423873/index.html">Gambaran Umum PICASO 3D Designer X 3D Printer</a></li>
<li><a href="../id423875/index.html">Penyimpanan sejumlah besar file</a></li>
<li><a href="../id423877/index.html">29-31 Oktober: membuat kluster Kubernet yang siap produksi</a></li>
<li><a href="../id423881/index.html">Apa tukang las untuk optik (bagian dua)</a></li>
<li><a href="../id423885/index.html">Undangan untuk pertunjukan cahaya dan orang dalam kecil dari platform Circle of Light di Moskow</a></li>
<li><a href="../id423889/index.html">Kekecewaan saya pada perangkat lunak</a></li>
<li><a href="../id423891/index.html">Pohon Ekspresi Pengembangan Perusahaan</a></li>
<li><a href="../id423893/index.html">Hello World untuk menerima data dari perangkat Bluetooth (BLE) melalui C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>