<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèéÔ∏è üë©‚Äç‚ù§Ô∏è‚Äçüë® üë° Ingenier√≠a inversa del emulador NES en el juego para GameCube üç≥ üçß üçò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mientras buscaba formas de activar los men√∫s del desarrollador que quedaban en Animal Crossing, incluido el men√∫ de selecci√≥n de juegos para el emulad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ingenier√≠a inversa del emulador NES en el juego para GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="imagen"></div><br>  Mientras buscaba formas de activar los men√∫s del desarrollador que quedaban en Animal Crossing, incluido el men√∫ de selecci√≥n de juegos para el emulador NES, encontr√© una caracter√≠stica interesante que existe en el juego original y estaba constantemente activa, pero Nintendo nunca la us√≥. <br><br>  Adem√°s de los juegos NES / Famicom del juego, puedes descargar nuevos juegos NES desde una tarjeta de memoria. <br><br>  Tambi√©n logr√© encontrar una manera de usar este cargador de arranque ROM para parchear mi c√≥digo y mis datos en el juego, lo que te permite ejecutar c√≥digo a trav√©s de una tarjeta de memoria. <br><br><h2>  Introducci√≥n - Objetos de consola NES </h2><br>  Los juegos normales de NES, que se pueden obtener de Animal Crossing, son muebles separados en forma de una consola de NES con un cartucho sobre √©l. <br><br>  Habiendo localizado este objeto en tu casa e interactuando con √©l, puedes ejecutar este √∫nico juego.  La imagen a continuaci√≥n muestra Excitebike y Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  Tambi√©n hay un objeto de consola NES com√∫n en el que no hay juegos integrados.  Se puede comprar en Redd, y a veces se obtiene a trav√©s de eventos aleatorios, por ejemplo, leyendo en el tabl√≥n de anuncios de la ciudad que la consola est√° enterrada en un punto aleatorio de la ciudad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Este objeto se parece a una consola NES en la que no hay cartuchos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  El problema con este objeto es que se pens√≥ que no se pod√≠a reproducir.  Cada vez que interact√∫as con √©l, solo ves un mensaje que dice que no tienes software de juego. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  ¬°Result√≥ que este objeto en realidad est√° tratando de escanear la tarjeta de memoria en busca de archivos especialmente dise√±ados que contienen im√°genes ROM para NES!  El emulador NES utilizado para ejecutar juegos integrados parece ser el emulador NES est√°ndar completo para GameCube y es capaz de lanzar la mayor√≠a de los juegos. <br><br>  Antes de demostrar estas caracter√≠sticas, explicar√© el proceso de ingenier√≠a inversa. <br><br><h2>  Buscar ROM bootloader en la tarjeta de memoria </h2><br><h3>  Estamos buscando un men√∫ de desarrollador </h3><br>  Inicialmente, quer√≠a encontrar un c√≥digo que active varios men√∫s de desarrollador, como el men√∫ de selecci√≥n de mapas o el men√∫ de selecci√≥n de juegos para el emulador NES.  El men√∫ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Forest Map Select</a> , gracias al cual puedes cargar f√°cilmente instant√°neamente diferentes ubicaciones del juego, fue bastante simple de encontrar: solo busqu√© la l√≠nea FOREST MAP SELECT que aparece en la parte superior de la pantalla (se puede ver en diferentes videos y capturas de pantalla en Internet ) <br><br>  En "FOREST MAP SELECT" hay referencias cruzadas de datos a la funci√≥n <code>select_print_wait</code> , lo que conduce a un mont√≥n de otras funciones que tambi√©n tienen el prefijo <code>select_*</code> , incluida la funci√≥n <code>select_init</code> .  Result√≥ ser funciones que controlan el men√∫ de selecci√≥n del mapa. <br><br>  La funci√≥n <code>select_init</code> conduce a otra funci√≥n interesante llamada <code>game_get_next_game_dlftbl</code> .  Esta funci√≥n enlaza todos los dem√°s men√∫s y "escenas" que puede ejecutar: una pantalla con el logotipo de Nintendo, la pantalla principal, el men√∫ de selecci√≥n de tarjetas, el men√∫ del emulador NES (Famicom), etc.  Comienza al comienzo del procedimiento principal del juego, encuentra qu√© funci√≥n de inicializaci√≥n de escena debe ejecutar y encuentra su entrada en la estructura de datos de la tabla llamada <code>game_dlftbls</code> .  Esta tabla contiene enlaces a las funciones de procesamiento de varias escenas, as√≠ como algunos otros datos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Un estudio cuidadoso del primer bloque de la funci√≥n mostr√≥ que carga la funci√≥n "siguiente inicio del juego", y luego comienza a compararla con una serie de funciones de inicio conocidas: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  Uno de los punteros de funci√≥n que est√° buscando es <code>famicom_emu_init</code> , que es responsable de ejecutar el emulador NES / Famicom.  <code>game_get_next_game_init</code> resultado de <code>game_get_next_game_init</code> a <code>famicom_emu_init</code> o <code>select_init</code> en el depurador Dolphin, pude mostrar men√∫s especiales.  El siguiente paso es determinar c√≥mo se configuran estos punteros de la manera normal durante la ejecuci√≥n del programa.  Lo √∫nico que hace la funci√≥n <code>game_get_next_game_init</code> es cargar el valor en el desplazamiento <code>0xC</code> primer argumento en <code>game_get_next_game_dlftbl</code> . <br><br>  Hacer un seguimiento de estos valores establecidos en varias estructuras de datos fue un poco aburrido, as√≠ que ir√© directamente al n√∫cleo.  Lo m√°s importante que encontr√©: <br><br><ul><li>  Cuando el juego comienza de la manera habitual, realiza la siguiente secuencia de acciones: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> establece el siguiente inicio en <code>select_init</code> .  Esta pantalla deber√≠a permitirle seleccionar un jugador inmediatamente despu√©s de elegir una carta, pero parece que no funciona correctamente. </li></ul><br>  Tambi√©n encontr√© una funci√≥n sin nombre que define la funci√≥n init del emulador, pero no encontr√© nada que establezca la funci√≥n init en el valor init del jugador o la opci√≥n de mapa. <br><br>  En este punto, me di cuenta de que ten√≠a otro est√∫pido problema con la forma en que cargaba los nombres de funciones en la IDA: debido a la expresi√≥n regular utilizada para cortar l√≠neas en el archivo de s√≠mbolos de depuraci√≥n, me perd√≠ todos los nombres de funciones que comienzan con una letra may√∫scula .  La funci√≥n que configur√≥ <code>famicom_emu_init</code> parec√≠a transiciones entre escenas y, por supuesto, se llamaba <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> maneja las transiciones entre escenas, como <code>Game_play_fbdemo_wipe_proc</code> pantalla y apagones. <br><br>  Bajo ciertas condiciones, la transici√≥n de la pantalla se realiz√≥ de la jugabilidad habitual a la visualizaci√≥n del emulador.  Fue √©l quien configur√≥ la funci√≥n de inicio del emulador. <br><br><h3>  Manejo de objetos de la consola </h3><br>  En realidad, los manipuladores de objetos de muebles para consolas NES hacen que el controlador de transici√≥n de pantalla cambie al emulador.  Cuando un jugador interact√∫a con una de las consolas, se <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Al llamar a la funci√≥n, <code>r6</code> contiene el valor de √≠ndice correspondiente a los n√∫meros en los nombres de los archivos del juego NES en <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> es un formato de archivo de propiedad). <br><br>  Cuando <code>r6</code> no <code>r6</code> igual a cero, se pasa en <code>aMR_RequestStartEmu</code> llamada <code>aMR_RequestStartEmu</code> .  En este caso, se activa la transici√≥n al emulador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  Sin embargo, si <code>r6</code> es cero, se <code>aMR_RequestStartEmu_MemoryC</code> funci√≥n <code>aMR_RequestStartEmu_MemoryC</code> .  Al establecer el valor en el depurador en 0, recib√≠ el mensaje "No tengo ning√∫n software".  No record√© de inmediato que necesitaba verificar el objeto de la consola NES para asegurarme de que restablece el valor <code>r6</code> , pero result√≥ que el √≠ndice cero se usa para el objeto de la consola sin un cartucho. <br><br>  Aunque <code>aMR_RequestStartEmu</code> simplemente almacena el valor del √≠ndice en alg√∫n tipo de estructura de datos, <code>aMR_RequestStartEmu_MemoryC</code> realiza operaciones mucho m√°s complejas ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Este tercer bloque de c√≥digo llama <code>aMR_GetCardFamicomCount</code> y busca un resultado distinto de cero; de lo contrario, omite la mayor√≠a de las cosas interesantes en el lado izquierdo del gr√°fico de funciones. <br><br>  <code>aMR_GetCardFamicomCount</code> llama a <code>famicom_get_disksystem_titles</code> , que luego llama a <code>memcard_game_list</code> , y aqu√≠ todo se vuelve muy interesante. <br><br>  <code>memcard_game_list</code> monta la tarjeta de memoria y comienza a dar vueltas en el ciclo de escritura de archivos, verificando cada uno de los valores.  Al rastrear la funci√≥n en el depurador, pude entender que estaba comparando los valores con cada uno de mis archivos en la tarjeta de memoria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  La funci√≥n decide si descargar o no el archivo, dependiendo de los resultados de la verificaci√≥n de varias l√≠neas.  En primer lugar, comprueba la presencia de las l√≠neas "GAFE" y "01", que son los identificadores del juego y la empresa.  01 significa Nintendo, GAFE significa Animal Crossing.  Creo que significa GameCube Animal Forest English. <br><br>  Luego verifica las l√≠neas "DobutsunomoriP_F_" y "SAVE".  En este caso, la primera l√≠nea debe coincidir, pero no la segunda.  Result√≥ que "DobutsunomoriP_F_SAVE" es el nombre del archivo que almacena los datos de los juegos incrustados para NES.  Por lo tanto, todos los archivos, excepto este, se cargar√°n con el prefijo "DobutsunomoriP_F_". <br><br>  Utilizando el depurador Dolphin para omitir las comparaciones de cadenas con "SAVE" y haciendo que el juego enga√±e para creer que mi archivo "SAVE" se puede descargar de forma segura, obtuve este men√∫ despu√©s de usar la consola NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  Respond√≠ "S√≠" e intent√© cargar el archivo guardado como un juego, despu√©s de lo cual vi por primera vez la pantalla de bloqueo del juego incorporada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Genial  Ahora s√© que en realidad est√° intentando descargar juegos desde una tarjeta de memoria, y puedo comenzar a analizar el formato de los archivos guardados para ver si se puede descargar una ROM real. <br><br>  Lo primero que intent√© hacer fue tratar de encontrar d√≥nde se lee el nombre del juego del archivo de la tarjeta de memoria.  Al buscar la l√≠nea "FEFSC" que estaba presente en el mensaje "¬øDesea jugar &lt;nombre&gt;?", Encontr√© el desplazamiento en el que se le√≠a del archivo: <code>0x642</code> .  Copi√© el archivo de guardar, cambi√© el nombre del archivo a "DobutsunomoriP_F_TEST", cambi√© los bytes en el desplazamiento <code>0x642</code> a "PRUEBA" e <code>0x642</code> el guardado modificado, despu√©s de lo cual el nombre que necesitaba apareci√≥ en el men√∫. <br><br>  Despu√©s de agregar algunos archivos m√°s en este formato, aparecieron algunas opciones m√°s en el men√∫: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  Descargar ROM </h3><br>  Si <code>aMR_GetCardFamicomCount</code> devuelve distinto de cero, la memoria se asigna en el mont√≥n, <code>famicom_get_disksystem_titles</code> se llama directamente <code>famicom_get_disksystem_titles</code> , despu√©s de lo cual se especifican un mont√≥n de compensaciones aleatorias en la estructura de datos.  En lugar de descifrar d√≥nde se leer√°n estos valores, comenc√© a estudiar la lista de funciones de <code>famicom</code> . <br><br>  Result√≥ que necesitaba <code>famicom_rom_load</code> .  Controla la carga de ROM, ya sea desde una tarjeta de memoria o desde los recursos internos del juego. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  Lo m√°s importante en este bloque de "arranque desde la tarjeta de memoria" es que llama <br>  <code>memcard_game_load</code> .  Ella vuelve a montar el archivo en la tarjeta de memoria, lo lee y analiza.  Aqu√≠ es donde las opciones de formato de archivo m√°s importantes se hacen evidentes. <br><br><h4>  Valor de suma de control </h4><br>  Lo primero que sucede despu√©s de cargar el archivo es el c√°lculo de la suma de verificaci√≥n.  Se <code>calcSum</code> funci√≥n <code>calcSum</code> , que es un algoritmo muy simple que suma los valores de todos los bytes en los datos de la tarjeta de memoria.  Los ocho bits inferiores del resultado deben ser cero.  Es decir, para pasar esta verificaci√≥n, debe sumar los valores de todos los bytes en el archivo fuente, calcular el valor que debe agregarse para que los ocho bits inferiores se conviertan en cero y luego asignar este valor al byte de suma de verificaci√≥n en el archivo. <br><br>  Si la verificaci√≥n falla, recibir√° un mensaje sobre la imposibilidad de leer correctamente la tarjeta de memoria, y no sucede nada.  Durante la depuraci√≥n, todo lo que tengo que hacer es omitir esta verificaci√≥n. <br><br><h4>  Copiar ROM </h4><br>  Cerca del final de <code>memcard_game_load</code> , sucede otra cosa interesante.  Hay varios bloques de c√≥digo m√°s interesantes entre √©l y la suma de verificaci√≥n, pero ninguno de ellos genera ramificaciones que omiten la ejecuci√≥n de este comportamiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Si un cierto valor entero de 16 bits le√≠do desde la tarjeta de memoria no es igual a cero, se llama a una funci√≥n que verifica el encabezado de compresi√≥n en el b√∫fer.  Comprueba los formatos de compresi√≥n patentados de Nintendo al observar el comienzo del b√∫fer Yay0 o Yaz0.  Si se encuentra una de estas l√≠neas, se llama a la funci√≥n de desempaquetado.  De lo contrario, se realiza una funci√≥n de copia simple.  En cualquier caso, despu√©s de eso, <code>nesinfo_data_size</code> una variable llamada <code>nesinfo_data_size</code> . <br><br>  Otro indicio de contexto aqu√≠ es que los archivos ROM para juegos NES integrados usan la compresi√≥n Yaz0, y esta l√≠nea est√° presente en los encabezados de sus archivos. <br><br>  Despu√©s de observar el valor que se verifica para cero, y el b√∫fer pas√≥ a las funciones de verificaci√≥n de compresi√≥n, r√°pidamente descubr√≠ de d√≥nde se estaba leyendo el juego en el archivo de la tarjeta de memoria.  La comprobaci√≥n cero se realiza para parte del b√∫fer de 32 bytes copiado del desplazamiento <code>0x640</code> en el archivo, que probablemente sea el encabezado ROM.  Esta funci√≥n tambi√©n verifica otras partes del archivo, y es en ellas donde se encuentra el nombre del juego (comenzando con el tercer byte del encabezado). <br><br>  En la ruta de ejecuci√≥n del c√≥digo que encontr√©, el b√∫fer de ROM se encuentra inmediatamente despu√©s de este b√∫fer de encabezado de 32 bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Esta informaci√≥n es suficiente para intentar crear un archivo ROM que funcione.  Acabo de tomar uno de los otros archivos guardados de Animal Crossing y lo <code>DobutsunomoriP_F_TEST</code> en un editor hexadecimal para reemplazar el nombre del archivo con <code>DobutsunomoriP_F_TEST</code> y borrar todas las √°reas donde quer√≠a pegar los datos. <br><br>  Para una ejecuci√≥n de prueba, utilic√© la ROM del juego Pinball, que ya est√° en el juego, e insert√© su contenido despu√©s del encabezado de 32 bytes.  En lugar de calcular el valor de la suma de verificaci√≥n, establezco puntos de interrupci√≥n para simplemente omitir <code>calcSum</code> y tambi√©n observar los resultados de otras verificaciones que pueden conducir a una rama que omite el proceso de arranque de ROM. <br><br>  Finalmente, import√© el nuevo archivo a trav√©s del administrador de tarjetas de memoria Dolphin, reinici√© el juego e intent√© iniciar la consola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  Funcion√≥!  Hubo algunos peque√±os errores gr√°ficos relacionados con los par√°metros de Dolphin, que afectaron el modo gr√°fico utilizado por el emulador NES, pero en general el juego funcion√≥ bien.  (En las versiones m√°s recientes de Dolphin, deber√≠a funcionar de forma predeterminada). <br><br>  Para asegurarme de que otros juegos tambi√©n comiencen, trat√© de escribir otras ROM que no estaban en el juego.  Battletoads comenz√≥, pero dej√≥ de funcionar despu√©s del texto de la pantalla de inicio (despu√©s de otras configuraciones logr√© hacer que se pueda jugar).  Mega Man, por otro lado, funcion√≥ perfectamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Para aprender a generar nuevos archivos ROM que podr√≠an cargarse sin la intervenci√≥n de depuradores, tuve que comenzar a escribir c√≥digo y comprender mejor el an√°lisis del formato de archivo. <br><br><h3>  Formato de archivo ROM externo </h3><br>  La parte m√°s importante del an√°lisis de archivos ocurre en <code>memcard_game_load</code> .  Hay seis secciones principales de bloques de an√°lisis de c√≥digo en esta funci√≥n: <br><br><ul><li>  Suma de comprobaci√≥n </li><li>  Guardar nombre de archivo </li><li>  Encabezado de archivo ROM </li><li>  Buffer desconocido copiado sin ning√∫n procesamiento </li><li>  Comentario de texto, icono y cargador de banner (para crear un nuevo archivo guardado) </li><li>  Cargador de arranque ROM </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Suma de comprobaci√≥n </h4><br>  Los ocho bits inferiores de la suma de todos los valores de bytes en el archivo guardado deben ser cero.  Aqu√≠ hay un c√≥digo simple de Python que genera el byte de suma de verificaci√≥n necesario: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Probablemente haya un lugar especial para almacenar el byte de suma de comprobaci√≥n, pero agregarlo al espacio vac√≠o al final del archivo de guardar funciona bastante bien. <br><br><h4>  Nombre de archivo </h4><br>  Nuevamente, el nombre del archivo guardado debe comenzar con "DobutsunomoriP_F_" y terminar con algo que no contenga "GUARDAR".  Este nombre de archivo se copia un par de veces, y en un caso la letra "F" se reemplaza por "S".  Este ser√° el nombre de los archivos guardados para el juego NES ("DobutsunomoriP_S_NAME"). <br><br><h4>  Encabezado ROM </h4><br>  Se carga en la memoria una copia directa del encabezado de 32 bytes.  Algunos de los valores en este encabezado se usan para determinar c√≥mo manejar secciones subsiguientes.  B√°sicamente, estos son algunos valores de tama√±o de 16 bits y bits de par√°metros empaquetados. <br><br>  Si traza el puntero copiado por el encabezado hasta el inicio de la funci√≥n y encuentra la posici√≥n de su argumento, la firma de la funci√≥n a continuaci√≥n mostrar√° que en realidad tiene el tipo <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Buffer desconocido </h4><br>  Comprueba el valor de tama√±o de 16 bits del encabezado.  Si no es igual a cero, el n√∫mero correspondiente de bytes se copia directamente desde el b√∫fer de archivo a un nuevo bloque de memoria asignada.  Esto mueve el puntero de datos en el b√∫fer de archivos para que pueda continuar la copia desde la siguiente secci√≥n. <br><br><h4>  Banner, √≠cono y comentario </h4><br>  Se verifica otro valor de tama√±o en el encabezado, y si no es igual a cero, se llama a la funci√≥n de verificaci√≥n de compresi√≥n de archivos.  Si es necesario, se iniciar√° el algoritmo de desempaquetado, despu√©s de lo cual se <code>SetupExternCommentImage</code> . <br><br>  Esta funci√≥n hace tres cosas: "comentario", imagen de banner e icono.  Para cada uno de ellos, hay un c√≥digo en el encabezado de la ROM que muestra c√≥mo manejarlos.  Existen las siguientes opciones: <br><br><ol><li>  Usar valor predeterminado </li><li>  Copie de la secci√≥n de banner / icono / comentario en el archivo ROM </li><li>  Copiar desde el b√∫fer alternativo </li></ol><br>  Los valores predeterminados del c√≥digo hacen que el √≠cono o pancarta se cargue desde el recurso en el disco, y el nombre del archivo guardado y el comentario (descripci√≥n de texto del archivo) se les asignan los valores "Animal Crossing" y "NES Cassette Save Data".  As√≠ es como se ve: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  El segundo valor del c√≥digo simplemente copia el nombre del juego del archivo ROM (una alternativa a "Animal Crossing"), y luego trata de encontrar la cadena "] ROM" en el comentario del archivo y reemplazarlo con "] SAVE".  Aparentemente, se supon√≠a que los archivos que Nintendo quer√≠a lanzar ten√≠an el formato de los nombres "Game Name [NES] ROM" o algo similar. <br><br>  Para el icono y el banner, el c√≥digo intenta determinar el formato de la imagen, obtener un valor de tama√±o fijo correspondiente a este formato y luego copiar la imagen. <br><br>  En el √∫ltimo valor del c√≥digo, el nombre y la descripci√≥n del archivo se copian sin cambios desde el b√∫fer, y el icono y el banner tambi√©n se cargan desde el b√∫fer alternativo. <br><br><h4>  ROM </h4><br>  Si observa cuidadosamente la captura de pantalla de la <code>memcard_game_load</code> ROM de copia <code>memcard_game_load</code> , puede ver que el valor de 16 bits verificado para igualdad a cero se desplaza a la izquierda por 4 bits (multiplicado por 16), y luego se usa como el tama√±o de la funci√≥n de <code>memcpy</code> si no se detecta compresi√≥n.  Este es otro valor de tama√±o presente en el encabezado. <br><br>  Si el tama√±o no es igual a cero, se comprueba la compresi√≥n de los datos de la ROM y luego se copia. <br><br><h3>  B√∫fer desconocido y b√∫squeda de errores </h3><br>  Aunque descargar nuevas ROM es bastante curioso, lo m√°s interesante de este cargador de ROM para m√≠ fue que, de hecho, esta es la √∫nica parte del juego que recibe la entrada del usuario de tama√±o variable y la copia en diferentes ubicaciones de memoria.  Casi todo lo dem√°s usa buffers de tama√±o constante.  Cosas como nombres y textos de letras pueden parecer diferentes en longitud, pero esencialmente el espacio vac√≠o simplemente est√° lleno de espacios.  Las cadenas terminadas en cero se usan con poca frecuencia, evitando errores comunes de corrupci√≥n de memoria, como el uso de <code>strcpy</code> con un b√∫fer que es demasiado peque√±o para copiar cadenas. <br><br>  Estaba muy interesado en la posibilidad de encontrar un exploit del juego basado en guardar archivos, y parec√≠a que esta era la mejor opci√≥n. <br><br>  La mayor√≠a de las operaciones de archivos ROM descritas anteriormente usan copias de tama√±o constante, con la excepci√≥n de un buffer desconocido y datos ROM.  Desafortunadamente, el c√≥digo que procesa este b√∫fer asigna exactamente tanto espacio como sea necesario para copiarlo, por lo que no hay desbordamiento, y establecer tama√±os de archivo ROM muy grandes no fue muy √∫til. <br><br>  Pero a√∫n quer√≠a saber qu√© sucede con este b√∫fer, que se copia sin ning√∫n procesamiento. <br><br><h4>  Manejadores de etiquetas de informaci√≥n de NES </h4><br>  <code>famicom_rom_load</code> a <code>famicom_rom_load</code> .  Despu√©s de cargar ROM desde una tarjeta de memoria o disco, se llaman varias funciones: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Despu√©s de haber rastreado el lugar donde se copia el b√∫fer desconocido, me asegur√© de que estas tareas realicen esta tarea.  Comienzan con una llamada a <code>nesinfo_next_tag</code> , que realiza un algoritmo simple: <br><br><ul><li>  Comprueba si el puntero especificado <code>nesinfo_tags_end</code> puntero en <code>nesinfo_tags_end</code> .  Si es menor que <code>nesinfo_tags_end</code> o <code>nesinfo_tags_end</code> es cero, entonces verifica la presencia de la cadena "END" en el encabezado del puntero. <br><br><ul><li>  Si se alcanza "FIN", o el puntero ha subido a <code>nesinfo_tags_end</code> , la funci√≥n devuelve nulo. </li><li>  De lo contrario, el byte en el desplazamiento <code>0x3</code> puntero se agrega a 4 y al puntero actual, despu√©s de lo cual se devuelve el valor. </li></ul></li></ul><br>  Esto nos dice que hay alg√∫n tipo de formato de etiqueta a partir de un nombre de tres letras, un valor de tama√±o de datos y los datos en s√≠.  El resultado es un puntero a la siguiente etiqueta, porque se omite la etiqueta actual ( <code>cur_ptr + 4</code> omite el nombre de tres letras y un byte, y <code>size_byte</code> omite los datos). <br><br>  Si el resultado no es cero, la funci√≥n de procesamiento de etiquetas realiza una serie de comparaciones de cadenas para determinar qu√© etiqueta debe procesarse.  Algunos de los nombres de etiquetas <code>nesinfo_tag_process1</code> en <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR y QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Si se encuentra una coincidencia de etiqueta, se ejecuta alg√∫n c√≥digo de controlador.  Algunos de los controladores no hacen nada m√°s que mostrar una etiqueta en el mensaje de depuraci√≥n.  Otros tienen manejadores m√°s complejos.  Despu√©s de procesar la etiqueta, la funci√≥n intenta obtener la siguiente etiqueta y continuar procesando. <br><br>  Afortunadamente, hay muchos mensajes detallados de depuraci√≥n que se muestran cuando se detectan etiquetas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos est√°n en japon√©s, por lo que primero deben decodificarse de Shift-JIS y traducirse. Por ejemplo, un mensaje para QDS podr√≠a leer "Cargando un √°rea de guardado de disco" o "Dado que esta es la primera ejecuci√≥n, cree un √°rea de guardado de disco". Los mensajes para el BBR dicen "cargar una copia de seguridad de la bater√≠a" o "dado que este es el primer inicio, realizamos una limpieza". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos c√≥digos tambi√©n cargan algunos valores de la secci√≥n de datos de sus etiquetas y los usan para calcular el desplazamiento en los datos de ROM, despu√©s de lo cual realizan operaciones de copia. Obviamente, son responsables de determinar las partes en la memoria ROM asociadas con la preservaci√≥n del estado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n hay una etiqueta "HSC" con un mensaje de depuraci√≥n que dice que est√° procesando registros de puntos. </font><font style="vertical-align: inherit;">Ella obtiene un desplazamiento en ROM de los datos de su etiqueta, as√≠ como el valor del registro de puntaje original. </font><font style="vertical-align: inherit;">Estas marcas se pueden usar para indicar un lugar en la memoria del juego NES para almacenar puntuaciones altas, posiblemente para guardarlas y restaurarlas en el futuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estas etiquetas crean un sistema de descarga de metadatos de ROM bastante complejo. </font><font style="vertical-align: inherit;">Adem√°s, muchos de ellos conducen a llamadas </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basadas en los valores transmitidos en los datos de la etiqueta.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caza de insectos </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de las etiquetas que conducen a la manipulaci√≥n de la memoria no son muy √∫tiles para exploits, porque todas tienen valores m√°ximos de desplazamiento y tama√±o especificados como enteros de 16 bits. </font><font style="vertical-align: inherit;">Esto es suficiente para trabajar con el espacio de direcciones NES de 16 bits, pero no es suficiente para escribir valores de destino √∫tiles, como punteros a funciones o direcciones de retorno en la pila en el espacio de direcciones GameCube de 32 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay varios casos donde los valores de las compensaciones de tama√±o transmitidas </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pueden exceder </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> QDS </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QDS carga un desplazamiento de 24 bits de sus datos de etiqueta, as√≠ como un valor de tama√±o de 16 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo bueno aqu√≠ es que el desplazamiento se usa para calcular la direcci√≥n de destino de la operaci√≥n de copia. La direcci√≥n base del desplazamiento es el comienzo de los datos descargados, el origen de la copia est√° en el archivo ROM de la tarjeta de memoria y el tama√±o se establece mediante el valor de tama√±o de 16 bits de la etiqueta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor de 24 bits tiene un valor m√°ximo </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es mucho m√°s de lo necesario para escribir fuera de los datos ROM cargados. Sin embargo, hay ciertos problemas ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primero es que, aunque el valor de tama√±o m√°ximo es igual </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, inicialmente se usa para restablecer la partici√≥n de memoria. Si el valor del tama√±o es demasiado alto (no mucho m√°s grande </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), esto restablecer√° la marca "QDS" en el c√≥digo del juego.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y ah√≠ radica el problema, porque en </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realidad se llama dos veces. Por primera vez, recibe informaci√≥n sobre el espacio que necesita para prepararse para los datos almacenados. Las etiquetas QDS y BBR no se procesan completamente en la primera ejecuci√≥n. Despu√©s de la primera ejecuci√≥n, se prepara un lugar para guardar los datos y se vuelve a llamar a la funci√≥n. Esta vez, las etiquetas QDS y BBR se procesan completamente, pero si las cadenas de nombre de la etiqueta se borran de la memoria, ¬°entonces es imposible que las etiquetas vuelvan a coincidir! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se puede evitar estableciendo un valor de tama√±o m√°s peque√±o. Otro problema es que el valor de desplazamiento solo puede avanzar en la memoria, y los datos de ROM NES se encuentran en el mont√≥n bastante cerca del final de la memoria disponible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de ellos solo hay unos pocos montones, y ninguno de ellos tiene algo particularmente √∫til, como punteros de funci√≥n obvios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso normal, podr√≠a usar esto para explotar un desbordamiento de mont√≥n, pero en la implementaci√≥n </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizada para este mont√≥n, se han agregado bastantes bytes de comprobaciones de estado en bloques </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Podemos escribir sobre los valores del puntero en los siguientes bloques de mont√≥n. Sin controles de estado, esto podr√≠a usarse para escribir en un √°rea de memoria arbitraria cuando se solicita </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un bloque de mont√≥n involucrado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, la implementaci√≥n utilizada aqu√≠ </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">busca un patr√≥n de byte espec√≠fico ( </font></font><code>0x7373</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) al comienzo de los bloques siguientes y anteriores que manipular√° cuando se llame</font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si no encuentra estos bytes, llama </font></font><code>OSPanic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el juego se congela.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incapaz de influir en la presencia de estos bytes en alguna ubicaci√≥n de destino, no es posible escribir aqu√≠. </font><font style="vertical-align: inherit;">En otras palabras, es imposible grabar algo en un lugar arbitrario sin poder grabar algo cerca de este lugar. </font><font style="vertical-align: inherit;">Puede haber alguna forma de hacer que el valor </font></font><code>0x73730000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacenado en la pila directamente en frente de la direcci√≥n de retorno </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lugar al que se refiere el valor que queremos escribir en la direcci√≥n de destino (tambi√©n se verificar√° como si fuera un puntero a un bloque de mont√≥n), pero esto es dif√≠cil de lograr y usar esto en un exploit.</font></font><br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra funci√≥n con respecto a las etiquetas QDS, BBR y HSC es esta </font></font><code>nesinfo_update_highscore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Los tama√±os de las marcas QDS, BBR y OFS (desplazamiento) se utilizan para calcular el desplazamiento en el que grabar, y la marca HSC incluye la grabaci√≥n en esa ubicaci√≥n. Esta funci√≥n se realiza para cada cuadro procesado por el emulador NES. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor de desplazamiento m√°ximo para cada etiqueta en este caso, incluso para QDS, es igual </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sin embargo, durante el ciclo de procesamiento de etiquetas, los valores de dimensi√≥n de las etiquetas BBR y QDS realmente se </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acumulan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto significa que se pueden usar varias marcas para calcular casi cualquier valor de desplazamiento. La limitaci√≥n es el n√∫mero de etiquetas que pueden caber en la secci√≥n de datos de las etiquetas ROM en un archivo en una tarjeta de memoria, y tambi√©n tiene un tama√±o m√°ximo </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direcci√≥n base a la que se agrega el desplazamiento es el </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b√∫fer de guardar datos. </font><font style="vertical-align: inherit;">Esta direcci√≥n es mucho m√°s baja que los datos ROM, lo que nos da m√°s libertad para elegir una ubicaci√≥n de grabaci√≥n. </font><font style="vertical-align: inherit;">Por ejemplo, ser√° bastante simple reescribir la direcci√≥n de retorno en la pila a la direcci√≥n </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamentablemente, esto tampoco funcion√≥. </font><font style="vertical-align: inherit;">Resulta que </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n verifica el tama√±o acumulado de las compensaciones de estas etiquetas, y usa este tama√±o para inicializar el espacio:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el valor de compensaci√≥n que estaba tratando de calcular, esto condujo al hecho de que </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76,386,796) bytes de memoria </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">borraron, por lo que el juego se bloque√≥ espectacularmente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marca PAT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya hab√≠a comenzado a perder la esperanza, porque todas estas etiquetas que hac√≠an llamadas desprotegidas </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hab√≠an fallado incluso antes de que pudiera usarlas. Decid√≠ documentar el prop√≥sito de cada etiqueta y gradualmente llegu√© a las etiquetas </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de los manejadores de etiquetas </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca se inician, porque solo funcionan cuando el puntero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">cero. Nada en el c√≥digo asigna un valor distinto de cero a este puntero. Se inicializa con un valor nulo y nunca se vuelve a usar. Cuando se carga la ROM solo est√° configurada </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que parece un c√≥digo muerto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay una etiqueta que todav√≠a puede funcionar cuando no es cero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Esta es la etiqueta m√°s dif√≠cil en una funci√≥n </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n se usa como puntero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero nunca lo verifica por cero. </font><font style="vertical-align: inherit;">La etiqueta PAT lee su propio b√∫fer de datos de etiqueta, procesando c√≥digos que calculan las compensaciones. </font><font style="vertical-align: inherit;">Estos desplazamientos se agregan al puntero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular la direcci√≥n de destino, y luego los bytes se copian desde el b√∫fer de parches a esta ubicaci√≥n. </font><font style="vertical-align: inherit;">Esta copia se realiza cargando y guardando bytes, no usando instrucciones </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que no lo he notado antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada b√∫fer de datos de marca PAT tiene un c√≥digo de tipo de 8 bits, un tama√±o de parche de 8 bits y un valor de desplazamiento de 16 bits, seguido de los datos del parche.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el c√≥digo es 2, el valor de compensaci√≥n se agrega a la suma actual de las compensaciones. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el c√≥digo es 9, el desplazamiento se desplaza 4 bits hacia arriba y se agrega a la suma actual de los desplazamientos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el c√≥digo es 3, la suma de las compensaciones se restablece a 0. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tama√±o m√°ximo de la etiqueta de informaci√≥n NES es 255, es decir, el tama√±o de parche PAT m√°s grande es 251 bytes. </font><font style="vertical-align: inherit;">Sin embargo, se pueden usar m√∫ltiples marcas PAT, es decir, puede parchear m√°s de 251 bytes, as√≠ como parchear espacios no contiguos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras tengamos una serie de suelas PAT con c√≥digo 2 o c√≥digo 9, el desplazamiento del puntero de destino contin√∫a acumul√°ndose. </font><font style="vertical-align: inherit;">Al copiar los datos del parche, se restablece a cero, pero si usa un tama√±o de parche cero, esto se puede evitar. </font><font style="vertical-align: inherit;">Est√° claro que esto puede usarse para calcular alg√∫n desplazamiento arbitrario con un puntero nulo </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando muchas marcas PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay dos comprobaciones m√°s de valores de c√≥digo ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el c√≥digo est√° entre </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces se agrega a </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego se desplaza hacia arriba 16 bits. </font><font style="vertical-align: inherit;">Luego se agrega al valor de desplazamiento de 16 bits y se usa como la direcci√≥n final del parche.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Esto nos permite asignar una direcci√≥n de destino para el parche en el rango de </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Aqu√≠ es donde reside la mayor parte del c√≥digo de Animal Crossing en la memoria. </font><font style="vertical-align: inherit;">Esto significa que podemos parchear el c√≥digo de Animal Crossing usando etiquetas de metadatos ROM de un archivo en una tarjeta de memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la ayuda de un peque√±o cargador de parches, incluso puede descargar f√°cilmente parches m√°s grandes de una tarjeta de memoria a cualquier direcci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como comprobaci√≥n r√°pida, cre√© un parche que inclu√≠a "zuru mode 2" (modo desarrollador de juegos, descrito en mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) cuando un usuario carga una ROM desde un mapa del juego. </font><font style="vertical-align: inherit;">Result√≥ que el combo de trucos de las teclas solo activa el modo "zuru mode 1", que no tiene acceso a las funciones que tiene el Modo 2. Con este parche, gracias a la tarjeta de memoria, podemos obtener acceso completo al modo desarrollador en hardware real.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las marcas de parche se procesar√°n cuando se inicie la ROM. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de cargar ROM, debe salir del emulador NES para ver el resultado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Funciona! <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formato de etiqueta de informaci√≥n de parche </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las marcas de informaci√≥n en el archivo de guardar que ejecuta este parche se ven as√≠: </font></font><br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: marca de inicio ignorada. </font></font><code>0x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es el tama√±o de su b√∫fer de datos: cero.</font></font></li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Parche </font></font><code>0x80206F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><ul><li> <code>0x08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es el tama√±o del b√∫fer de etiquetas. </font></font></li><li> <code>0xA0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se agrega a se </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convierte </font></font><code>0x8020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, los 16 bits superiores de la direcci√≥n de destino.</font></font></li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es el tama√±o de los datos del parche ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Son los 16 bits inferiores de la direcci√≥n de destino. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Son los datos del parche. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : marca de marcador final. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea experimentar por su cuenta con la creaci√≥n de un parche o archivos de almacenamiento ROM, entonces en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publiqu√© un c√≥digo muy simple para generar archivos. </font><font style="vertical-align: inherit;">Se puede generar un parche como el que se muestra arriba con el siguiente comando:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ejecuci√≥n de c√≥digo arbitrario </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a esta etiqueta, puede lograr la ejecuci√≥n de c√≥digo arbitrario en Animal Crossing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero aqu√≠ llega el √∫ltimo obst√°culo: el uso de parches para datos funciona bien, pero surgen problemas al parchear las instrucciones del c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se registran parches, el juego contin√∫a siguiendo las viejas instrucciones que estaban en su lugar. Esto parece un problema de almacenamiento en cach√©, y en realidad lo es. La CPU GameCube tiene cach√©s de instrucciones, como se describe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en las especificaciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comprender c√≥mo puede borrar el cach√©, comenc√© a estudiar las funciones relacionadas con el cach√© de la documentaci√≥n del SDK de GameCube y descubr√≠ </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta funci√≥n invalida los bloques de instrucciones en cach√© en la direcci√≥n de memoria especificada, lo que permite que la memoria de instrucciones modificada se ejecute con c√≥digo actualizado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, sin la capacidad de ejecutar el c√≥digo original, a√∫n no podemos llamar </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para una ejecuci√≥n exitosa del c√≥digo, necesitamos un truco m√°s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al estudiar la implementaci√≥n </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para la posibilidad de usar un exploit con desbordamiento de mont√≥n, aprend√≠ que las funciones de implementaci√≥n </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se pueden deshabilitar din√°micamente usando una estructura de datos llamada </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carga un puntero a la implementaci√≥n actual </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde un lugar est√°tico en la memoria, y luego llama a esta funci√≥n, pasando todos los argumentos pasados </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El emulador NES usa activamente</font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para asignar y liberar memoria para datos NES relacionados con ROM, por lo que estaba seguro de que se lanzar√≠a varias veces aproximadamente al mismo tiempo que las marcas PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carga un puntero desde la memoria y hace una transici√≥n a √©l, puedo cambiar el proceso de ejecuci√≥n del programa simplemente sobrescribiendo el puntero para que apunte a la funci√≥n actual </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El almacenamiento en cach√© de herramientas no evitar√° que esto suceda, ya que no es necesario cambiar las instrucciones </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El desarrollador del proyecto D≈çbutsu no Mori e + fan, llamado Cuyler, escribi√≥ dicho cargador en el ensamblador PowerPC y demostr√≥ su uso para inyectar nuevo c√≥digo en este video: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/watch?v=BdxN7gP6WIc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(D≈çbutsu no Mori e + fue la √∫ltima iteraci√≥n de Animal Crossing en GameCube, que tuvo la mayor cantidad de actualizaciones. Lanzado solo en Jap√≥n). El parche descarga un c√≥digo que permite al jugador crear cualquier objeto ingresando su ID por letra y presionando el bot√≥n Z.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a esto, puedes descargar mods, trucos y homebrew en una copia regular de Animal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing en un GameCube real.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417117/">https://habr.com/ru/post/es417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417107/index.html">Creador del juego mientras es verdadero: aprenda () sobre la programaci√≥n de gamedev, los problemas de realidad virtual y las simulaciones de ML</a></li>
<li><a href="../es417109/index.html">Richard Hamming: Cap√≠tulo 10. Teor√≠a de la codificaci√≥n - I</a></li>
<li><a href="../es417111/index.html">Conferencias en l√≠nea: transmisi√≥n vs seminario web</a></li>
<li><a href="../es417113/index.html">Impresora italiana 3D en Rusia: Raise3D N1 Dual - modelado y creaci√≥n de prototipos</a></li>
<li><a href="../es417115/index.html">Para enterrar o quemar Flutter.io?</a></li>
<li><a href="../es417119/index.html">Paginaci√≥n en Vue.js</a></li>
<li><a href="../es417123/index.html">Integraci√≥n de Spark Streaming y Kafka</a></li>
<li><a href="../es417125/index.html">RTC Meetup .Net: invitar a la primera reuni√≥n</a></li>
<li><a href="../es417127/index.html">Tesla firma un acuerdo para construir Gigafactory 3 en China</a></li>
<li><a href="../es417129/index.html">Universo de la mente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>