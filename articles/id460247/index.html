<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÇÔ∏è üå°Ô∏è üë®üèæ‚Äçü§ù‚Äçüë®üèª Resep untuk ELF ü§æüèº üíè üê≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Rusia, tidak ada informasi yang cukup tentang cara bekerja dengan file ELF (Format Executable dan Linkable - format utama untuk file yang dapat die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resep untuk ELF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/460247/"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="gambar"></p><br><p>  Di Rusia, tidak ada informasi yang cukup tentang cara bekerja dengan file ELF (Format Executable dan Linkable - format utama untuk file yang dapat dieksekusi dari Linux dan banyak sistem Unix).  Kami tidak mengklaim untuk sepenuhnya mencakup semua kemungkinan skenario bekerja dengan elf, tetapi kami berharap bahwa informasi tersebut akan berguna dalam bentuk buku referensi dan koleksi resep untuk programmer dan insinyur balik. </p><br><p>  Dapat dipahami bahwa pembaca pada tingkat dasar sudah terbiasa dengan format ELF (jika tidak, kami merekomendasikan serangkaian artikel yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijalankan dan Format yang Dapat Ditautkan 101</a> ). </p><br><p>  Di bawah potongan akan terdaftar alat untuk bekerja, teknik yang dijelaskan untuk membaca meta-informasi, modifikasi, verifikasi dan <del>  berkembang biak </del>  membuat elf, serta tautan ke materi yang bermanfaat. </p><a name="habracut"></a><br><blockquote>  "Aku juga peri ... Biru merah ... Peri sangat sabar ... Biru merah ... Dan kita peri! ... Biru merah ... Hanya ada masalah dari sihir ... <br>  (c) Kerajaan Kecil Ben dan Holly </blockquote><br><h1 id="instrumenty">  Alat-alatnya </h1><br><p>  Dalam kebanyakan kasus, contoh-contoh dapat dijalankan di Linux dan Windows. </p><br><p>  Dalam resep kami akan menggunakan alat-alat berikut: </p><br><ul><li>  utilitas dari set binutils (objcopy, objdump, readelf, strip); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka kerja radare2</a> ; </li><li>  hex editor dengan dukungan untuk templat file (contoh menunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">010Editor</a> , tetapi Anda dapat menggunakan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Veles</a> gratis); </li><li>  Python dan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LIEF</a> ; </li><li>  utilitas lain (tautan ada di resep). </li></ul><br><h1 id="testovye-elfy">  Tes elf </h1><br><p>  Sebagai "eksperimental" kita akan menggunakan file ELF <em>sederhana</em> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas</a> PieIsMyFav nutcake di crackmes.one, tetapi perwakilan keluarga "elven" akan melakukannya.  Jika file selesai dengan karakteristik yang diperlukan tidak ditemukan di domain publik, maka metode untuk membuat peri seperti itu akan diberikan. </p><br><p>  Elf Gratis juga dapat ditemukan di tautan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh elf untuk platform berbeda</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elf uji untuk radare2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek ElfHacks di Github</a> - pilihan elf kecil dengan pengaturan berbeda; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Crackme untuk Unix / Linux</a> - tetapi perlu diingat bahwa sampel rumit dapat ditemukan di sini. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Membaca, mendapatkan informasi </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  Jenis File, Judul, Bagian </h2><br><p>  Tergantung pada tugasnya, berikut ini mungkin menarik: </p><br><ul><li>  tipe file (DYN - library, EXEC - executable, RELOC - linkable); </li><li>  arsitektur target (E_MACHINE - x86_64, x86, ARM, dll.); </li><li>  titik masuk aplikasi (Entry Point); </li><li>  informasi bagian. </li></ul><br><h3 id="010editor">  010 Editor </h3><br><p> Editor HEX 010Editor menyediakan sistem template.  Untuk file ELF, templat ini disebut, cukup aneh, <em>ELF.bt</em> dan terletak di kategori <em>Eksekusi</em> (Templat menu - Eksekusi). <br>  Yang menarik, misalnya, titik masuk ke file yang dapat dieksekusi (titik masuk) (direkam di header file). </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="gambar"></p><br><h3 id="readelf">  membaca sendiri </h3><br><p>  Utilitas readelf dapat dianggap sebagai standar de facto untuk mendapatkan informasi tentang file ELF. </p><br><ul><li>  Baca tajuk file: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Baca informasi tentang segmen dan bagian: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><p>  Untuk keterbacaan, alamat dikonversi ke format 32-bit: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Baca informasi bagian: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><p>  Untuk keterbacaan, alamat dikonversi ke format 32-bit: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Baca informasi simbol: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><p>  Output disingkat agar mudah dibaca: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  Opsi <code>-W</code> diperlukan untuk meningkatkan lebar keluaran konsol (default, 80 karakter). </p><br><h3 id="lief">  Lief </h3><br><p>  Anda dapat membaca informasi tajuk dan bagian menggunakan kode Python dan perpustakaan LIEF (menyediakan API tidak hanya untuk Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Informasi Penyusun </h2><br><p>  Untuk informasi tentang kompiler dan build, lihat <code>.note</code> dan <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  membaca sendiri </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  Saya akan menghitung Anda dengan ... RPATH </h2><br><p>  Elf dapat menyimpan jalur untuk menemukan perpustakaan yang terhubung secara dinamis.  Agar tidak mengatur variabel sistem <code>LD_LIBRARY_PATH</code> sebelum memulai aplikasi, Anda bisa "menyematkan" jalur ini ke file ELF. </p><br><p>  Untuk melakukan ini, gunakan entri di bagian <code>.dynamic</code> dengan tipe <code>DT_RPATH</code> atau <code>DT_RUNPATH</code> (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Direktori yang Dicari oleh bab Runtime Linker</a> dalam dokumentasi). </p><br><p>  <strong>Dan berhati-hatilah, pengembang muda, jangan "tidur" direktori proyek Anda!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  Bagaimana RPATH muncul? </h3><br><p>  Alasan utama untuk penampilan catatan RPATH di peri adalah opsi linker <code>-rpath</code> untuk mencari pustaka dinamis.  Sesuatu seperti ini: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Perintah seperti itu akan membuat catatan RPATH di bagian <code>.dynamic</code> dengan nilai <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  membaca sendiri </h3><br><p>  Anda dapat melihat elemen dari bagian <code>.dynamic</code> (di antaranya ada RPATH) sebagai berikut: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil tim</b> <div class="spoiler_text"><p>  Untuk memudahkan membaca, hasil dari perintah diperpendek: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  Lief </h3><br><p>  Menggunakan perpustakaan LIEF, Anda juga dapat membaca catatan RPATH di peri: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca tentang bagian .dinamik</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Memeriksa Elf untuk Keamanan </h2><br><p>  Skrip pemeriksaan keamanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checksec.sh</a> dari peneliti Tobias Klein (penulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">A Bug Hunter's Diary</a> ) belum diperbarui sejak 2011.  Script file ELF ini memeriksa ketersediaan opsi RelRO (Read Only Relocations), NX (Non-Executable Stack), Stack Canaries, PIE (Position Independent Executables) dan menggunakan utilitas readelf untuk pekerjaannya. </p><br><h3 id="lief-3">  Lief </h3><br><p>  Anda dapat membuat analog sendiri <del>  lutut </del>  Python dan LIEF (sedikit lebih pendek dari nenek moyang dan dengan verifikasi tambahan dari opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode terpisah</a> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h3 id="radare2">  Radare2 </h3><br><p>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dukebarman</a> untuk penambahan penggunaan Radare2 untuk menampilkan informasi yang mirip dengan <em>checksec</em> : </p><br><pre> <code class="bash hljs">&gt; r2 -ci~pic,canary,nx,crypto,stripped,static,relocs test_stack_proteck</code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  Kode Mentah dari Elf (biner dari ELF) </h2><br><p>  Ada situasi ketika "pakaian elf" dalam bentuk struktur ELF tidak diperlukan, tetapi hanya kode aplikasi yang dapat dieksekusi "telanjang" yang diperlukan. </p><br><h3 id="objcopy">  keberatan </h3><br><p>  Menggunakan <em>objcopy</em> mungkin tidak asing bagi mereka yang menulis firmware: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - untuk menghapus informasi karakter; </li><li>  <code>-g</code> - untuk menghapus informasi debug. </li></ul><br><h3 id="lief-4">  Lief </h3><br><p>  Tanpa sihir.  Ambil saja isi bagian yang dimuat dan buat binar darinya: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Mangled - nama fungsi demangled </h2><br><p>  Dalam ELF yang dibuat dari kode C ++, nama-nama fungsi didekorasi (di-mangled) untuk mempermudah pencarian fungsi kelas yang sesuai.  Namun, membaca nama-nama seperti itu dalam analisis tidaklah nyaman. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uji peri</a> </p><br><h3 id="nm">  nm </h3><br><p>  Untuk mewakili nama dalam bentuk yang dapat dibaca manusia, Anda dapat menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nm</a> dari set binutils: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-5">  Lief </h3><br><p>  Menampilkan nama simbol dalam bentuk demangulasi menggunakan perpustakaan LIEF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Perakitan, perekaman, modifikasi peri </h1><br><h2 id="elf-bez-metainformacii">  Elf tanpa meta-informasi </h2><br><p>  Setelah aplikasi debugged dan dirilis ke dunia liar, masuk akal untuk menghapus meta-informasi: </p><br><ul><li>  bagian debug - tidak berguna dalam banyak kasus; </li><li>  nama-nama variabel dan fungsi - benar-benar tidak mempengaruhi apa pun untuk pengguna akhir (sedikit mempersulit kebalikannya); </li><li>  tabel bagian - sama sekali tidak diperlukan untuk menjalankan aplikasi (kekurangannya akan sedikit menyulitkan kebalikannya). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Hapus informasi karakter </h2><br><p>  Informasi karakter adalah nama-nama objek dan fungsi.  Tanpa itu, kebalikan dari aplikasi sedikit lebih rumit. </p><br><h3 id="strip">  menelanjangi </h3><br><p>  Dalam kasus paling sederhana, Anda dapat menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strip</a> dari set binutils.  Untuk menghapus semua informasi karakter, cukup jalankan perintah: </p><br><ul><li>  untuk file yang dapat dieksekusi: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  untuk perpustakaan dinamis: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  sstrip </h3><br><p>  Untuk menghapus informasi karakter dengan hati-hati (termasuk nol byte yang tidak perlu di akhir file), Anda dapat menggunakan utilitas sstrip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">suite ELFkickers</a> .  Untuk menghapus semua informasi karakter, cukup jalankan perintah: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-6">  Lief </h3><br><p>  Menggunakan perpustakaan LIEF, Anda juga dapat membuat strip cepat (tabel simbol dihapus - bagian <code>.symtab</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Menghapus Tabel Partisi </h2><br><p>  Seperti disebutkan di atas, ada / tidaknya tabel bagian tidak mempengaruhi operasi aplikasi.  Tetapi pada saat yang sama, tanpa tabel bagian, kebalikan dari aplikasi menjadi sedikit lebih rumit. <br>  Kami akan menggunakan perpustakaan LIEF di bawah Python dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh menghapus tabel bagian</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  Ubah dan hapus RPATH </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  Untuk mengubah RPATH di Linux, Anda dapat menggunakan utilitas <em>chrpath</em> (tersedia di sebagian besar distribusi) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PatchELF</a> . </p><br><ul><li><p>  Ubah RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  atau </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  Hapus RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  atau </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-7">  Lief </h3><br><p>  Perpustakaan LIEF juga memungkinkan Anda untuk memodifikasi dan menghapus data RPATH. </p><br><ul><li><p>  Ubah RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  Hapus RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Kebingungan informasi karakter </h2><br><p>  Untuk mempersulit kebalikan dari aplikasi, Anda dapat menyimpan informasi simbolik, tetapi membingungkan nama-nama objek.  Kami menggunakan elf <em>crackme01_32bit</em> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crackme01 oleh seveb</a> sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">subjek</a> uji. </p><br><p>  Versi sederhana dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> dari perpustakaan LIEF mungkin terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  Sebagai hasilnya, kita mendapatkan: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Substitusi fungsi melalui PLT / GOT </h2><br><p>  Juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">INFEKSI ELF PLT</a> . </p><br><p>  Agar tidak menyalin, tempel tautan di topik: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalihan fungsi di perpustakaan ELF bersama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menginfeksi PLT / dapatkan dengan LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Ubah titik masuk </h2><br><p>  Ini dapat berguna saat membuat tambalan, memasang kait dan instrumentasi dinamis lainnya, atau untuk menjalankan fungsi tersembunyi.  Sebagai percobaan, kami menggunakan elf crackme01_32bit dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crackme01 oleh seveb</a> </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  radare2 dimulai dalam mode perekaman (opsi <code>-w</code> ) - perubahan akan dilakukan ke file asli: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-8">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Patch kode </h2><br><p>  Sebagai tes sederhana, ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crackmepal novn91 dengan crack</a> .  Ketika diluncurkan tanpa parameter, program menampilkan: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  Saat diluncurkan dengan parameter string acak, ini menampilkan: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Kami akan membuat tambalan sehingga program segera saat startup menampilkan pesan ‚Äúpekerjaan bagus!  sekarang keygen aku! " </p><br><h3 id="radare2-2">  radare2 </h3><br><p>  radare2 dapat menambal format apa pun yang didukungnya sendiri.  Dalam hal ini, dimungkinkan untuk menggambarkan tambalan dalam format teks: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Anda dapat menerapkan tambalan seperti itu dengan perintah: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Baca tentang menambal kode melalui radare2: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binary Patching Menggunakan Radare2 oleh wolfshirtz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjelajahan Radare2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial 1 - Patch Sederhana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ground Zero: Bagian 3-2 - Teknik Reverse - Menambal Binari dengan Radare2 - ARM64</a> </li></ul><br><h3 id="lief-9">  Lief </h3><br><p>  LIEF memungkinkan Anda untuk menambal elf (menimpa byte) di alamat virtual yang ditentukan.  Patch bisa dalam bentuk array byte atau sebagai nilai integer: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  Setelah menerapkan tambalan, program akan menampilkan: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Tambahkan Bagian ke ELF </h2><br><h3 id="objcopy-1">  keberatan </h3><br><p>  <em>objcopy</em> memungkinkan Anda untuk menambahkan bagian, tetapi bagian ini tidak akan menjadi bagian dari segmen apa pun dan tidak akan dimuat ke dalam RAM ketika aplikasi dimulai: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-10">  Lief </h3><br><p>  Perpustakaan LIEF memungkinkan Anda untuk menambahkan bagian baru dan segmen yang sesuai ( <strong><code>loaded=True</code></strong> flag) ke ELF yang ada: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Ubah Bagian </h2><br><h3 id="objcopy-2">  keberatan </h3><br><p>  <em>objcopy</em> memungkinkan <em>Anda</em> untuk mengganti konten bagian dengan data dari file, serta mengubah alamat virtual bagian dan bendera: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-11">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Hapus Bagian </h2><br><h3 id="objcopy-3">  keberatan </h3><br><p>  <em>Keberatan</em> memungkinkan <em>Anda</em> untuk menghapus bagian tertentu dengan nama: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-12">  Lief </h3><br><p>  Menghapus bagian menggunakan perpustakaan LIEF terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Wadah elf </h2><br><p>  Resep ini terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sihir GREMLIN dan ELF: bagaimana jika file ELF adalah sebuah wadah?</a>  .  Ada juga man's tentang utilitas elfwrap yang berasal dari Solaris, yang memungkinkan Anda untuk membuat file ELF dari data sewenang-wenang, dan format ELF digunakan hanya sebagai wadah. </p><br><p>  Mari kita coba melakukan hal yang sama dengan Python dan LIEF. <br>  Sayangnya, saat ini, perpustakaan LIEF tidak dapat membuat file elf dari awal, jadi Anda perlu membantunya - membuat templat ELF kosong: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Sekarang Anda dapat menggunakan templat ini untuk mengisi data: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elf "dengan trailer" </h2><br><p>  Format ELF tidak memberlakukan batasan pada data yang ada dalam file, tetapi tidak termasuk segmen mana pun.  Dengan demikian, dimungkinkan untuk membuat file yang dapat dieksekusi, yang akan disimpan setelah struktur ELF.  Ini adalah <em>sesuatu yang</em> tidak akan dimuat ke dalam RAM saat runtime, tetapi akan ditulis ke disk, dan setiap saat dapat dibaca dari disk. </p><br><ul><li>  <em>IDA Pro tidak akan mempertimbangkan data ini saat menganalisis</em> </li></ul><br><p>  <em>Contoh struktur file dengan trailer</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="gambar"></p><br><h3 id="radare2-3">  radare2 </h3><br><p>  Kehadiran "trailer" dapat ditetapkan dengan membandingkan ukuran file yang nyata dan dihitung: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  membaca sendiri </h3><br><p>  <em>readelf</em> tidak menampilkan informasi tentang keberadaan "trailer", tetapi dapat dihitung secara manual: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-13">  Lief </h3><br><p>  Perpustakaan LIEF memungkinkan Anda untuk memeriksa keberadaan "trailer" dan menambahkannya.  Menggunakan LIEF, semuanya terlihat cukup ringkas: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  Void Elf (ELF dari awal) </h2><br><p>  Di Internet Anda dapat menemukan proyek untuk membuat file ELF "secara manual" - tanpa menggunakan kompiler dan tautan di bawah nama umum "ELF dari awal": </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elf dari</a> artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elf_from_scratch</a> cabang dalam repositori perpustakaan LIEF </li></ul><br><p>  Keakraban dengan proyek-proyek ini memiliki efek menguntungkan pada penyerapan format ELF. </p><br><h2 id="samyy-malenkiy-elf">  Peri terkecil </h2><br><p>  Eksperimen menarik dengan meminimalkan ukuran peri dijelaskan dalam artikel: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Whirlwind tentang Membuat Executables ELF yang Sangat Berlebihan untuk Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tutorial Whirlwind tentang Membuat Executables ELF yang Cukup Buruk untuk Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Program minimalis dalam format ELF</a> </li></ul><br><p>  Secara singkat, elf loader di OS tidak menggunakan semua bidang header dan tabel segmen, dan beberapa kode yang dapat dieksekusi minimal dapat ditempatkan langsung dalam struktur header ELF (kode diambil dari artikel pertama): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Merakit dan mendapatkan ELF ukuran ... <strong>45 byte</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Pola peri </h2><br><p>  Untuk membuat peri menggunakan perpustakaan LIEF, Anda dapat mengambil langkah-langkah berikut (lihat resep "wadah-Elf"): </p><br><ul><li>  ambil file ELF sederhana sebagai templat; </li><li>  ganti isi bagian, tambahkan bagian baru; </li><li>  konfigurasikan parameter yang diperlukan (titik masuk, bendera). </li></ul><br><h1 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h1><br><p>  Menambah artikel, kami menemukan bahwa itu adalah sesuatu seperti ode ke perpustakaan LIEF.  Tapi ini tidak direncanakan - saya ingin menunjukkan cara bekerja dengan file ELF menggunakan alat yang berbeda. </p><br><p>  Tentunya ada atau membutuhkan skrip yang tidak disebutkan di sini - tulis tentang ini di komentar. </p><br><h1 id="ssylki-i-literatura">  Referensi dan literatur </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi format ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi format lain di perpustakaan Oracle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan ELF menggunakan radare2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Perpustakaan LIEF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh perpustakaan LIEF</a> </li><li>  Buku "ANALISIS BINARY PRAKTIS", Dennis Andriesse </li><li>  Belajar Analisis Biner Linux, oleh Ryan "elfmaster" O'Neill </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460247/">https://habr.com/ru/post/id460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460231/index.html">OpenGear - Mengurangi Waktu Henti Bisnis Menggunakan Server Konsol dengan Manajemen Out-of-Band</a></li>
<li><a href="../id460233/index.html">Game Cities: Skylines ternyata Turing-complete: kami membuat penambah 4-bit</a></li>
<li><a href="../id460237/index.html">Scammers EBay (satu cerita curang)</a></li>
<li><a href="../id460239/index.html">Cara mendapatkan NextGen Firewall sendiri di rumah benar-benar gratis</a></li>
<li><a href="../id460241/index.html">Neraka atau air tinggi: sejarah literatur sains populer Rusia</a></li>
<li><a href="../id460249/index.html">Solusi tugas dengan pwnable.kr 07 - input. Memahami pwntools</a></li>
<li><a href="../id460251/index.html">Kebodohan Buatan: bot yang tidak membantu saya</a></li>
<li><a href="../id460253/index.html">10 alasan untuk menjadikan keterampilan Anda sebagai asisten suara</a></li>
<li><a href="../id460255/index.html">Backdoor di Node.js: mengapa, mengapa, dan cara kerjanya</a></li>
<li><a href="../id460257/index.html">Halo Dunia! Perendaman dalam di Terminal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>