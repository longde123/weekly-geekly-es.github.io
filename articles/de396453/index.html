<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📝 👨🏽‍⚕️ 🏜️ Matte mit einem Pferd und einem Elefanten. Entscheidungsgrundlage 🤟🏼 🤵🏽 ✋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Willst du einen Anfänger Schachspieler rätseln? 
 Bitten Sie ihn, mit einem Pferd und einem Elefanten Schachmatt zu setzen. 
 
 Möchten Sie einen Prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matte mit einem Pferd und einem Elefanten. Entscheidungsgrundlage</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/396453/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Willst du einen Anfänger Schachspieler rätseln? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitten Sie ihn, mit einem Pferd und einem Elefanten Schachmatt zu setzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möchten Sie einen Programmieranfänger rätseln? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitten Sie ihn, die Matte mit einem Pferd und einem Elefanten zu berechnen. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/552/4b2/6d8/5524b26d81625b9ae809054ed010ee1d.jpg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schachprobleme regen die Fantasie des Programmierers an, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
weshalb </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ich </font><font style="vertical-align: inherit;">für die praktische Demonstration der Kombinatorik </font><font style="vertical-align: inherit;">das schwierigste Schachproblem aus dem Zyklus „Schachmatt zum einsamen König“ ausgewählt habe.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zielsetzung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ziel des Projekts ist es, eine Lösungsbasis zu schaffen, dh eine Liste der richtigen Bewegungen für alle möglichen Positionen des weißen Königs, des Elefanten, des Pferdes und des schwarzen Königs auf dem Schachbrett. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Veröffentlichung werde ich Ihnen erzählen, wie ich dieses Problem gelöst habe, mit welchen Schwierigkeiten ich konfrontiert war und was am Ende passiert ist. Verwendete Technologien: C #, JavaScript, PHP, HTML, CSS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als sehr mittelmäßiger Schachspieler habe ich nie gelernt, wie man schnell mit einem Pferd und einem Elefanten schachmatt setzt. Deshalb habe ich mich entschlossen, diesen Mangel mit meinen Programmierkenntnissen auszugleichen, alle möglichen Positionen zu sortieren und für jede den richtigen Zug zu finden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor ich mindestens eine Codezeile schrieb, schlüpfte ich in einen „napoleonischen“ Plan, wie ich es mehrere Wochen lang machen würde. </font><font style="vertical-align: inherit;">Ich wollte dieses Problem unbedingt von Anfang an lösen, indem ich alle matten Kombinationen sortierte. </font><font style="vertical-align: inherit;">Und dann einen Schritt zurück, bis alle möglichen Optionen ausgeschöpft sind.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie viele Möglichkeiten gibt es?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf einem Schachbrett befinden sich 64 Zellen. </font><font style="vertical-align: inherit;">Wir haben vier Figuren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzahl der möglichen Kombinationen beträgt 64 * 64 * 64 * 64 = 16.777.216. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können nur einen weißbrüstigen Elefanten zurücklassen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzahl der Optionen wird halbiert: 64 * 32 * 64 * 64 = 8.388.608. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So viele Positionen werden in unserer Datenbank mit Lösungen enthalten sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich gibt es noch weniger Kombinationen: Zwei Teile können nicht auf einem Feld stehen, Könige können nicht auf benachbarten Feldern stehen, der schwarze König kann nicht unter dem Scheck stehen und so weiter. </font><font style="vertical-align: inherit;">Mit Blick auf die Zukunft werde ich sagen, dass die Datenbank der Lösungen 5.609.790 Kombinationen umfasst. Das Array wird zu 67% gefüllt sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Algorithmus zu vereinfachen und den Zugriff auf die Datenbankdaten zu beschleunigen, habe ich beschlossen, keine Zeit damit zu verschwenden und ein vierdimensionales Array für alle Kombinationen zu erstellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende Struktur ist zum Speichern jeder Kombination definiert:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Combo<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKing;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteBishop;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord whiteKnight;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord blackKing;<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Inneren wird eine andere Koordinatenstruktur verwendet, um die Koordinaten der Figur aufzuzeichnen, wobei der Index von 0 bis 63 berechnet werden kann, sowie mit einem überladenen Vergleichsoperator.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coord<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//    0  7 ( a  h)</span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> y; <span class="hljs-comment"><span class="hljs-comment">//    0  7</span></span><font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y * <span class="hljs-number"><span class="hljs-number">8</span></span>; }
            <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { x = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> % <span class="hljs-number"><span class="hljs-number">8</span></span>); <font></font>
                  y = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>); }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (Coord a, Coord b)<font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.x == b.x &amp;&amp; a.y == b.y;<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Struktur erwies sich als sehr praktisch, um als Argument an verschiedene Hilfsfunktionen übergeben zu werden, zum Beispiel:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheck</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckmate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  </span></span>
    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isCheckByBishop</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Combo combo</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     </span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Ergebnis der Entscheidungsgrundlage dieser Struktur aufzuzeichnen, reicht es jedoch nicht aus, ... </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiße Box</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ziel unseres Programms wird es sein, eine „weiße Box“ zu erstellen, in der alle Positionen, in denen der „Zug weiß ist“ und für die bekannt ist, welcher Zug ausgeführt werden soll und durch wie viele Züge er garantiert schachmatt gesetzt wird, addiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein wesentlicher Bestandteil der „White Box“ ist die folgende Struktur:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WhitesMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves;     <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveFrom; <span class="hljs-comment"><span class="hljs-comment">//   - </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coord moveTo;   <span class="hljs-comment"><span class="hljs-comment">// </span></span><font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste Weg, eine „weiße Box“ zu organisieren, besteht darin, eine vierdimensionale Matrix zu öffnen. </font><font style="vertical-align: inherit;">Jede Dimension dieser Matrix entspricht der möglichen Position jeder Figur:</font></font><br>
<br>
<pre><code class="cs hljs">    WhitesMove [ , , , ] box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WhitesMove [<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>];
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Dimension ist die Koordinate des weißen Königs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Dimension ist die Koordinate des weißen Elefanten / 2. Die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dritte Dimension ist die Koordinate des weißen Pferdes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die vierte Dimension ist die Koordinate des schwarzen Königs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptsache ist, ihre Reihenfolge nicht zu verwechseln :) Das Array wird zu 33% entladen sein, aber für die Verarbeitung sehr praktisch. </font><font style="vertical-align: inherit;">In diesem Array werden 8.388.608 Einträge gespeichert, um Kombinationen zu lösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens, bevor ich anfing, alle Suchalgorithmen zu schreiben, habe ich ein leeres Projekt erstellt und diese vierdimensionale Matrix initialisiert, um sicherzustellen, dass genügend Speicher vorhanden ist und es nicht erforderlich ist, etwas Zusätzliches zu erfinden. </font><font style="vertical-align: inherit;">Anscheinend wirkte sich die Erfahrung mit der Teilnahme an Informatik-Olympiaden des letzten Jahrtausends, bei denen die Größe der Struktur 64 Kilobyte nicht überschreiten konnte, auf Turbo Pascal 7.0 aus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idee des Algorithmus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beschreiben Sie kurz die Hauptidee zur Lösung dieses Problems. </font><font style="vertical-align: inherit;">Es basiert auf einem Breitensuchalgorithmus, der etwas geändert werden musste, da zwei Personen Schach spielen und nacheinander Züge ausgeführt werden. </font><font style="vertical-align: inherit;">Daher benötigen wir anstelle einer Zeile zwei - "schwarz" und "weiß".</font></font><br>
<br>
<pre><code class="cs hljs">    Queue&lt;BlacksMove&gt; blackQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;BlacksMove&gt;();<font></font>
    Queue&lt;WhitesMove&gt; whiteQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;WhitesMove&gt;();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Struktur von WhitesMove haben wir uns bereits getroffen. </font><font style="vertical-align: inherit;">Die Struktur von BlacksMove ist etwas einfacher, da der letzte Zug von Black nicht darin gespeichert werden muss.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BlacksMove<font></font>
    {<font></font>
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Combo combo;
        <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> moves; <font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst platzieren wir in der „schwarzen Linie“ alle matten Positionen, an denen die Bewegung schwarz ist. </font><font style="vertical-align: inherit;">Dann machen wir von jeder solchen Position aus einen umgekehrten Zug für Weiß und bilden eine „weiße Linie“ - eine Liste von Positionen, an denen sich Weiß bewegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Schritte müssen wiederholt werden, bis alle möglichen Kombinationen erschöpft sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptalgorithmus in Form von Pseudocode:</font></font><br>
<br>
<pre><code class="cs hljs">       <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
         <font></font>
         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      <font></font>
      {<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                    <font></font>
                      <font></font>
                           <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span>
                             <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
           <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
                 <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
                      <font></font>
                        <font></font>
                      <span class="hljs-string"><span class="hljs-string">" "</span></span>
                         <span class="hljs-string"><span class="hljs-string">" "</span></span><font></font>
<font></font>
      }  <span class="hljs-string"><span class="hljs-string">" "</span></span>  <font></font>
<font></font>
       <span class="hljs-string"><span class="hljs-string">" "</span></span>   
</code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matte Position</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen der Basis für die richtigen Züge beginnt mit der Suche nach allen Mattkombinationen. </font><font style="vertical-align: inherit;">Die Verwendung von Enumeratoren ermöglichte es, diesen Prozess recht effektiv zu beschreiben.</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Combo combo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllCheckmates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>))</span></span><font></font>
    {<font></font>
        BlacksMove checkmate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlacksMove { combo = combo, moves = <span class="hljs-number"><span class="hljs-number">0</span></span> };<font></font>
        blackQueue.Enqueue(checkmate);<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt 232 matte Positionen gefunden. </font><font style="vertical-align: inherit;">Ich möchte Sie daran erinnern, dass wir uns nur auf einen Weißfeldelefanten beschränkt haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige von ihnen sind ziemlich exotisch, nicht existent und „kooperativ“. In diesem Moment kletterte der schwarze König selbst unter die Matte. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/cb8/72f/c4e/cb872fc4e552449343b0bb9ad2e80303.png" alt="Mat.  Was war der Schritt von Weiß?"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schachspieler sind sich bewusst, dass eine Matte mit einem Pferd und einem Elefanten auf einem weißen Feld in einer weißen Ecke platziert werden muss. </font><font style="vertical-align: inherit;">In der schwarzen Ecke ist Schachmatt nur möglich, wenn Schwarz mitspielt. </font><font style="vertical-align: inherit;">Ich habe am Anfang des Artikels speziell ein Foto mit einem solchen Pseudo-Automaten gepostet, um die Aufmerksamkeit echter Schachspieler zu erregen :)</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matte in einem Zug</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Schritt ist das Umkehren von Weiß. </font><font style="vertical-align: inherit;">Das heißt, für jede gefundene matte Position müssen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle möglichen weißen Bewegungen zurückgehen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie mache ich einen Rückwärtsgang? </font><font style="vertical-align: inherit;">Da in unseren Positionen keine Erfassung vorgesehen ist, ist der Algorithmus recht einfach - machen Sie eine Bewegung von Weiß, wonach der schwarze König nicht mehr überprüft wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle auf diese Weise gefundenen Positionen können bereits in das „weiße Kästchen“ eingefügt werden. Dies zeigt an, dass sich eine Bewegung vor der Matte befindet und welche Art von Bewegung dies tun soll. </font><font style="vertical-align: inherit;">Unterwegs setzen wir die Kombinationen in die „schwarze Linie“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht dieser Teil des Algorithmus aus:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (blackQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
        BlacksMove black = blackQueue.Dequeue();<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
            </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//     </span></span></span><span class="hljs-function">
            </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!isCheck(white.combo</span></span></span><span class="hljs-function">))
                </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//      " "</span></span></span><span class="hljs-function">
                </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!whiteBox.Exists(white.combo</span></span></span><span class="hljs-function">))</span></span><font></font>
                {<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteBox.Put (white);<font></font>
                    <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                    whiteQueue.Enqueue(white);<font></font>
                }<font></font>
    }<font></font>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übrigens über den Ertrag</font></font></b><div class="spoiler_text">   yield-      , ,         :<br>
<br>
<pre><code class="cs hljs">        <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;WhitesMove&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BlacksMove black</span></span></span><span class="hljs-function">)</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteBishopMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">WhitesMove white </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllWhiteKnightMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black</span></span></span><span class="hljs-function">))
                </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return white</span></span>;<font></font>
        }<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt wurden 920 solcher Positionen gefunden, hier sind die interessantesten: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pferdebewegung </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/a3c/5e9/e2a/a3c5e9e2a6de27f57d40720cf3caa044.png" alt="Ritter 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/b30/477/955/b3047795519e369386b6d4c98582310f.png" alt="Ritterzug 2"> <img src="https://habrastorage.org/getpro/geektimes/post_images/8aa/d2b/728/8aad2b72884640ec4fe9469efa89088d.png" alt="Ritter 3"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: Elefantenbewegung </font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af8/447/b26/af8447b26f2c45bd93595887f84f4a65.png" alt="Elefantenbewegung 1"> <img src="https://habrastorage.org/getpro/geektimes/post_images/cdf/b7b/735/cdfb7b7359a3e69f93aa8b8b67651206.png" alt="Elefantenzug 2"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
: Königsbewegung:</font></font><br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/689/946/f2e/689946f2eb8e8d5eac9d0cc8d2a3834b.png" alt="König bewegen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matte in anderthalb Zügen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der nächste Schritt ist das Umkehren von Schwarz. Mit diesem Algorithmus habe ich die längste Zeit verbracht, viele Fehler wurden gemacht, bevor alles richtig funktionierte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf den ersten Blick ist alles ähnlich wie in der vorherigen Version: Für jede Position von der „weißen Linie“ müssen alle möglichen Bewegungen des schwarzen Königs aussortiert werden. Und fügen Sie alle gefundenen Kombinationen zur „schwarzen Linie“ hinzu - schließlich handelt es sich um einen Schachmatt in anderthalb Zügen, von dem aus Sie dann wieder einen umgekehrten Zug für Weiß ausführen können - es gibt einen Schachmatt in zwei Zügen - und fahren Sie fort, bis alle Optionen überprüft wurden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das war der Fehler. Mit jedem möglichen Zug bekommt Schwarz in anderthalb Zügen einen „kooperativen“ Schachmatt, aber in Wirklichkeit wird der König nicht unbedingt unter den Schachmatt gehen. Dmitry Grin hat mich auf diesen Fehler hingewiesen, der an allen meinen Webinaren zur Erstellung dieses Programms teilgenommen hat, für die ich ihm separat danke. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der richtige Algorithmus lautet wie folgt: Für jede Position N nach der Rückwärtsbewegung des schwarzen Königs müssen Sie alle möglichen direkten Bewegungen durchlaufen, um sicherzustellen, dass alle zu vertrauten Positionen aus der „weißen Box“ führen, dh zur Matte. Und erst nach dieser Position kann N zur „schwarzen Linie“ hinzugefügt werden. Und wenn der schwarze König von Position N „abrutschen“ kann, überspringen wir diese Option. Sie wird sich bei nachfolgenden Iterationen treffen, wenn es bekanntere Positionen geben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sieht dieser Teil des Algorithmus aus:</font></font><br>
<br>
<pre><code class="cs hljs">    <span class="hljs-comment"><span class="hljs-comment">//  " "  </span></span>
    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (whiteQueue.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)<font></font>
    {<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N  " "</span></span><font></font>
        WhitesMove white = whiteQueue.Dequeue();<font></font>
        Combo whiteFigures = white.combo;<font></font>
        <span class="hljs-comment"><span class="hljs-comment">//   N      </span></span>
        <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">BlacksMove black </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllBlackBackMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">white</span></span></span><span class="hljs-function">))</span></span><font></font>
        {<font></font>
            <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> solved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;
            <span class="hljs-comment"><span class="hljs-comment">//      </span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">Coord blackKing </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AllKingMoves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">black.combo.blackKing</span></span></span><span class="hljs-function">))</span></span><font></font>
            {<font></font>
                whiteFigures.blackKing = blackKing; <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCheck(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//    </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;
                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (box.Exists(whiteFigures)) <span class="hljs-comment"><span class="hljs-comment">//   </span></span>
                    <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;<font></font>
                solved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ""</span></span>
                <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;<font></font>
            }<font></font>
            <span class="hljs-comment"><span class="hljs-comment">//       </span></span>
            <span class="hljs-comment"><span class="hljs-comment">//     " "</span></span>
            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solved)
                <span class="hljs-comment"><span class="hljs-comment">//    " "</span></span><font></font>
                blackQueue.Enqueue(black);<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Insgesamt wurden 156 Kombinationen von „Matteinhalb Zügen“ gefunden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf halbem Weg iterativ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beschriebenen Algorithmen zum Erstellen eines Halbpasses müssen geloopt werden. </font><font style="vertical-align: inherit;">Aus der „schwarzen Linie“ bilden wir die „weiße Linie“ und dann umgekehrt - aus der „weißen“ Linie bilden wir die „schwarze Linie“. </font><font style="vertical-align: inherit;">Und so weiter, bis alle neuen Positionen erschöpft sind. </font><font style="vertical-align: inherit;">Das „weiße Kästchen“ wird in der Phase der Bildung der „weißen Linie“ ausgefüllt, da es die Positionen platziert, an denen sich Weiß bewegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der vorgefertigte Algorithmus zum Auflisten aller Optionen funktionierte irgendwo in 12 Minuten und blieb bei Schritt 33 stehen. </font><font style="vertical-align: inherit;">So viele maximale Bewegungen sind erforderlich, um den schwarzen König aus jeder Position mit einem Pferd und einem Elefanten zu paaren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens gab es nicht so viele solcher „schwierigsten“ Positionen, nur 156, hier ist eine davon:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/af4/481/e7c/af4481e7cfe9f5d9e5787d4f287238f6.png" alt="Matte in 33 Zügen"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mata wird nicht sein!</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele Positionen, in denen der schwarze König auch nach dem Zug von Weiß einen Ritter oder Bischof essen und ein Unentschieden erzielen kann. </font><font style="vertical-align: inherit;">Es gibt auch Pattoptionen. </font><font style="vertical-align: inherit;">Hier sind einige der interessantesten Artikel.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/b87/90d/11f/b8790d11ff993e53cb6620167448e7fb.png" alt="Kein Kumpel"> <img src="https://habrastorage.org/getpro/geektimes/post_images/885/786/cad/885786cad2d99e49c3d176a83217bda4.png" alt="Kein Kumpel"><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/09c/f2c/cf2/09cf2ccf2d1855e834a1e2e38e0205e2.png" alt="Kein Kumpel"> <img src="https://habrastorage.org/getpro/geektimes/post_images/6ef/659/f74/6ef659f744134d6e4c993c56dd71a213.png" alt="Kein Kumpel"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So speichern Sie eine Lösungsdatenbank</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie speichere ich die gefundene Lösungsbasis? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste und falscheste Weg ist die Verwendung der Serialisierung. Das serialisierte vierdimensionale Array der Struktur benötigte 1,7 Gigabyte (!) Speicherplatz. Der Serialisierungsprozess dauerte ungefähr sechs Minuten, die Deserialisierung dauerte ungefähr das gleiche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Option ist natürlich nicht geeignet. Darüber hinaus ist es in der Praxis nicht erforderlich, das gesamte vierdimensionale Array zu verwenden. Für eine bestimmte Werbebuchung wird nur ein Eintrag benötigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eureka! Um Platz zu sparen, können Sie die Speicherkoordinaten der Figuren für jede Kombination nicht mehr speichern. Wenn wir ein vierdimensionales Array haben, wird die Position jeder Figur auf der Tafel eindeutig durch ihren Index im Array bestimmt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde beschlossen, die gesamte Datenbank der Lösungen in einer Datei zu speichern - als linearer Scan eines vierdimensionalen Arrays. Für jede mögliche Position wird die Adresse berechnet, an der die richtige Antwort aufgezeichnet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie kann man die Antwort, die wir brauchen, so kompakt wie möglich aufzeichnen? Die Position der Figuren muss nicht gespeichert werden, daher bleiben nur drei Zahlen übrig - wie viele Züge auf die Matte, was und wohin. Auf diese Weise wird der richtige Schritt für Weiß eindeutig festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 Bit Wie viele Züge auf die Matte gehen, ist eine ganze Zahl von 0 bis 33,2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bit. Welche Figur geht - drei mögliche Optionen, ein König, ein Elefant oder ein Pferd. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 Bit Wohin das Stück geht - der Feldindex auf der Tafel liegt zwischen 0 und 63. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jeden Entscheidungsdatensatz reichen also zwei Bytes aus: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 Byte - wie viele Bewegungen auf die Matte oder 0, wenn die Position unbekannt ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 Bytes - FFNNNNNN</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FF - Nummer der zu gehenden Figur (1 - König, 2 - Elefant, 3 - Pferd) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NNNNNN - Zellkoordinate - wohin (von 0 bis 63). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösungsdatenbankdatei benötigt also 64 * 32 * 64 * 64 Wörter = genau 16 Megabyte. </font><font style="vertical-align: inherit;">Die Position der Figuren wird durch die Koordinaten jedes Wortes im ersten Byte festgelegt - die Anzahl der Bewegungen auf der Matte (oder 0, wenn es keine Lösung gibt), die zweite Bewegung speichert die richtige Bewegung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wäre möglich, die Dateigröße um die Hälfte zu reduzieren, wenn Sie die Anzahl der Züge nicht auf der Matte gespeichert hätten, aber es wäre nicht interessant, so zu spielen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinaten des schwarzquadratischen weißen Elefanten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist Zeit, für die Optimierung zu bezahlen. </font><font style="vertical-align: inherit;">Für Kombinationen mit einem „Schwarz-Weiß“ -Elefanten muss ein Algorithmus zur Neuberechnung der Koordinaten implementiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies wurde wie folgt durchgeführt. </font><font style="vertical-align: inherit;">Wenn die Koordinate des Elefanten auf ein schwarzes Feld fällt, müssen die Koordinaten aller Figuren auf dem Brett "umgedreht" werden. </font><font style="vertical-align: inherit;">In diesem Fall bleibt die Y-Koordinate unverändert und X ändert sich zu 7-X. </font><font style="vertical-align: inherit;">Eine visuelle Demonstration eines Koordinatenwechsels, siehe Abbildung. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/geektimes/post_images/1cb/019/1f7/1cb0191f7642a5b963437278ed9ca783.png" alt="Koordinaten-Flip"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Elefant auf einem weißen Käfig steht, müssen Sie zuerst die Koordinaten aller Figuren "umdrehen". </font><font style="vertical-align: inherit;">Suchen Sie dann nach einer Position in der Datenbank der Lösungen. </font><font style="vertical-align: inherit;">Und noch einmal "drehen" Sie die Koordinate der korrekten Bewegung, die von dort gelesen wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisierung der Lösungsbasis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit ist das Problem gelöst! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Datenbank der Lösungen wurde erstellt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie kann man das demonstrieren? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der naheliegendste Weg ist die Verwendung von Webtechnologien, sodass Sie nur einen Link zu einem funktionierenden Beispiel geben können. Nach meiner "Programmierformel </font><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">wurde bereits der Fotokurs " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nano-Schach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">erstellt </font><font style="vertical-align: inherit;">, bei dem unter Verwendung der Technologien HTML, CSS, JavaScript und PHP ein interaktives Schachbrett zum Spielen ohne Regeln für zwei Personen erstellt wurde. Dieses Skript wurde als Grundlage genommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich ließ nur vier Teile übrig, entfernte die Möglichkeit der Erfassung, fügte PHP-Funktionen hinzu, um die richtigen Bewegungen von der Lösungsbasis zu lesen, und „hauchte Leben“ durch JavaScript. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der Seite </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.videosharp.info/chess können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie mit der Datenbank der Lösungen experimentieren.</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/geektimes/post_images/9fb/3ce/7bc/9fb3ce7bc6645d2c96536c2a19c663a2.png" alt="Interaktive Matte mit Pferd und Elefant"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für jede Position werden Bewegungen sowohl für Weiß als auch für Schwarz berechnet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Weiß - der beste Zug, der zum Schachmatt führt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Schwarz - wie viele Züge auf die Matte für einen möglichen Zug. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können jede Bewegung der Figuren mit der Maus ausführen, nicht unbedingt nach den Regeln. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Skript berechnet die Option für jede Position oder schreibt, dass es keine Optionen gibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist interessant zu spielen, die vorgeschlagenen Züge auszuführen oder die Stücke nach eigenem Ermessen zu bewegen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine großartige, interessante Arbeit wurde geleistet, um das Schachproblem zu lösen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie dies auf diese Weise wiederholen möchten, können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Erstellen dieses Programms von Grund auf bis zum Ergebnis mit detaillierten Erklärungen und unabhängigen Aufgaben </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">ansehen</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viel Erfolg!</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de396453/">https://habr.com/ru/post/de396453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de396441/index.html">Italien kann seine Olivenbäume aufgrund des Misstrauens gegenüber Wissenschaftlern verlieren</a></li>
<li><a href="../de396443/index.html">"Zion Wise Men" wurde ein weiterer Grund, Wikipedia zu blockieren</a></li>
<li><a href="../de396445/index.html">Клоны овечки Долли помогают доказывать безопасность SCNT-клонирования</a></li>
<li><a href="../de396447/index.html">Preise für die populäre Elektronik der Vergangenheit im heutigen Geld: 1970er Jahre</a></li>
<li><a href="../de396451/index.html">Verbrechen und Bestrafungen des letzten Monats</a></li>
<li><a href="../de396455/index.html">Computerausrüstung der CMEA-Länder. Zweiter Teil: Tschechoslowakei</a></li>
<li><a href="../de396457/index.html">APEIGAMING in Zahlen. Einen Monat nach dem Start (Video)</a></li>
<li><a href="../de396459/index.html">Überprüfung der Gaming-Systemeinheit ASUS ROG GT51CA</a></li>
<li><a href="../de396461/index.html">Blockchain-Sicherheitstechnologien</a></li>
<li><a href="../de396467/index.html">Есть ли у тёмной материи практическое применение?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>