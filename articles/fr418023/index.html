<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😤 👨🏾‍🚒 👩🏽‍🏭 Les pointeurs en C sont plus abstraits que vous ne le pensez 👩🏿‍🚒 🐐 🤧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le pointeur fait référence à une cellule de mémoire, et déréférencer un pointeur signifie lire la valeur de la cellule spécifiée. La valeur du pointeu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les pointeurs en C sont plus abstraits que vous ne le pensez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  Le pointeur <i>fait référence</i> à une cellule de mémoire, et <i>déréférencer un</i> pointeur signifie lire la valeur de la cellule spécifiée.  La valeur du pointeur lui-même est l'adresse de la cellule mémoire.  La norme de langage C ne spécifie pas la forme de représentation des adresses mémoire.  Il s'agit d'un point très important, car différentes architectures peuvent utiliser différents modèles d'adressage.  La plupart des architectures modernes utilisent un espace d'adressage linéaire ou similaire.  Cependant, même cette question n'est pas spécifiée strictement, car les adresses peuvent être physiques ou virtuelles.  Certaines architectures utilisent une représentation non numérique du tout.  Ainsi, Symbolics Lisp Machine fonctionne avec des tuples de la forme <i>(objet, offset)</i> comme adresses. <br><a name="habracut"></a><table><tbody><tr><td>  Quelque temps plus tard, après la publication de la traduction sur Habré, l'auteur a apporté d'importantes modifications au texte de l'article.  Mettre à jour une traduction sur Habré n'est pas une bonne idée, car certains commentaires perdront leur sens ou sembleront déplacés.  Je ne veux pas publier le texte en tant que nouvel article.  Par conséquent, nous venons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mettre</a> à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jour la traduction de l'article</a> sur viva64.com, et ici nous avons tout laissé tel quel.  Si vous êtes un nouveau lecteur, je vous suggère de lire une traduction plus récente sur notre site en cliquant sur le lien ci-dessus. </td></tr></tbody></table><br>  La norme ne précise pas la forme de présentation des pointeurs, mais stipule - dans une plus ou moins grande mesure - les opérations avec eux.  Ci-dessous, nous considérons ces opérations et les caractéristiques de leur définition dans la norme.  Commençons par l'exemple suivant: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Si nous compilons ce code GCC avec le niveau d'optimisation 1 et exécutons le programme sous Linux x86-64, il affichera ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Notez que les pointeurs <i>p</i> et <i>q</i> font référence à la même adresse.  Cependant, le résultat de l'expression <i>p == q</i> est <i>faux</i> , et cela à première vue semble étrange.  Les deux pointeurs vers la même adresse ne devraient-ils pas être égaux? <br><br>  Voici comment la norme C définit le résultat de la vérification de l'égalité de deux pointeurs: <br><table><tbody><tr><td>  <b>C11 § 6.5.9 paragraphe 6</b> <br><br>  Deux pointeurs sont égaux si et seulement si les deux sont nuls, soit pointent vers le même objet (y compris un pointeur vers l'objet et le premier sous-objet dans l'objet) ou une fonction, soit pointent vers la position après le dernier élément du tableau, ou un pointeur fait référence à la position après le dernier élément du tableau, et l'autre fait référence au début d'un autre tableau suivant immédiatement le premier dans le même espace d'adressage. </td></tr></tbody></table><br>  Tout d'abord, la question se pose: qu'est-ce qu'un «objet <i>»</i> ?  Puisque nous parlons du langage C, il est évident qu'ici les objets n'ont rien à voir avec les objets dans les langages OOP comme C ++.  Dans la norme C, ce concept n'est pas complètement défini: <br><table><tbody><tr><td>  <b>C11 § 3.15</b> <br><br>  Un objet est une zone de stockage d'exécution dont le contenu peut être utilisé pour représenter des valeurs <br><br>  REMARQUE Lorsqu'il est mentionné, un objet peut être considéré comme ayant un type spécifique;  voir 6.3.2.1. </td></tr></tbody></table><br>  Faisons les choses correctement.  Une variable entière 16 bits est un ensemble de données en mémoire qui peut représenter des valeurs entières 16 bits.  Par conséquent, une telle variable est un objet.  Est-ce que deux pointeurs seront égaux si l'un d'eux fait référence au premier octet d'un entier donné et le second au deuxième octet du même nombre?  Le comité de normalisation linguistique, bien sûr, ne le voulait pas du tout.  Mais ici, il convient de noter qu'à cet égard, il n'a pas d'explications claires, et nous sommes obligés de deviner ce que l'on voulait vraiment dire. <br><br><h3>  Quand le compilateur se met en travers </h3><br>  Revenons à notre premier exemple.  Le pointeur <i>p est</i> obtenu à partir de l'objet <i>a</i> , et le pointeur <i>q</i> est à partir de l'objet <i>b</i> .  Dans le second cas, l'arithmétique d'adresse est utilisée, qui est définie comme suit pour les opérateurs plus et moins: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 clause 7</b> <br><br>  Lorsqu'il est utilisé avec ces opérateurs, un pointeur sur un objet qui n'est pas un élément du tableau se comporte comme un pointeur sur le début d'un tableau d'une longueur d'un élément, dont le type correspond au type de l'objet d'origine. </td></tr></tbody></table><br>  Étant donné que tout pointeur vers un objet qui n'est pas un tableau devient en <i>fait</i> un pointeur vers un tableau d'une longueur d'un élément, la norme définit l'arithmétique des adresses uniquement pour les pointeurs vers les tableaux - c'est le point 8. Nous nous intéressons à la partie suivante: <br><table><tbody><tr><td>  <b>C11 § 6.5.6 clause 8</b> <br><br>  Si une expression entière est ajoutée ou soustraite du pointeur, le pointeur résultant est du même type que le pointeur d'origine.  Si le pointeur source fait référence à un élément de tableau et que le tableau est de longueur suffisante, la source et les éléments résultants sont séparés les uns des autres de sorte que la différence entre leurs indices soit égale à la valeur de l'expression entière.  En d'autres termes, si l'expression <i>P</i> pointe vers le ième élément du tableau, les expressions <i>(P) + N</i> (ou son équivalent <i>N + (P)</i> ) et <i>(P) -N</i> (où <i>N</i> a la valeur n) indiquent respectivement (i + n) e et (i - n) e éléments du tableau, à condition qu'ils existent.  De plus, si l'expression <i>P</i> pointe vers le dernier élément du tableau, alors l'expression <i>(P) +1</i> indique la position après le dernier élément du tableau, et si l'expression <i>Q</i> indique la position après le dernier élément du tableau, alors l'expression <i>(Q) -1</i> indique le dernier élément tableau.  Si la source et les pointeurs résultants font référence à des éléments du même tableau ou à la position après le dernier élément du tableau, le débordement est exclu;  sinon, le comportement n'est pas défini.  Si le pointeur résultant fait référence à la position après le dernier élément du tableau, l'opérateur unaire <i>*</i> ne peut pas lui être appliqué. </td></tr></tbody></table><br>  Il s'ensuit que le résultat de l'expression <i>&amp; b + 1</i> devrait certainement être une adresse, et donc <i>p</i> et <i>q</i> sont des pointeurs valides.  Permettez-moi de vous rappeler comment l'égalité de deux pointeurs dans la norme est définie: " <i>Deux pointeurs sont égaux si et seulement si [...] un pointeur se réfère à la position après le dernier élément du tableau, et l'autre au début d'un autre tableau immédiatement après le premier du même espace d'adressage "</i> (C11 § 6.5.9, clause 6).  C'est exactement ce que nous observons dans notre exemple.  Le pointeur q fait référence à la position après l'objet b, immédiatement suivie par l'objet a, auquel le pointeur p fait référence.  Alors, y a-t-il un bug dans GCC?  Cette contradiction a été décrite en 2014 comme le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bug # 61502</a> , mais les développeurs de GCC ne le considèrent pas comme un bug et ne vont donc pas le corriger. <br><br>  Un problème similaire a été rencontré en 2016 par les programmeurs Linux.  Considérez le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Les symboles <i>_start</i> et <i>_end</i> spécifient les limites de la zone mémoire.  Puisqu'ils sont transférés vers un fichier externe, le compilateur ne sait pas comment les tableaux sont réellement situés en mémoire.  Pour cette raison, il doit être prudent ici et partir de l'hypothèse qu'ils se succèdent dans l'espace d'adressage.  Cependant, GCC compile la condition de boucle afin qu'elle soit toujours vraie, ce qui rend la boucle infinie.  Ce problème est décrit ici dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur LKML</a> - un fragment de code similaire y est utilisé.  Il semble que dans ce cas, les auteurs de GCC aient néanmoins pris en compte les commentaires et changé le comportement du compilateur.  Au moins, je n'ai pas pu reproduire cette erreur dans GCC version 7.3.1 sous Linux x86_64. <br><br><h3>  Solution - dans le rapport de bogue n ° 260? </h3><br>  Notre cas peut clarifier le rapport de bogue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 260</a> .  Il s'agit plutôt de valeurs incertaines, mais vous pouvez y trouver un commentaire curieux du comité: <br><br>  <i>Les implémentations du compilateur [...] peuvent également distinguer les pointeurs obtenus à partir d'objets différents, même si ces pointeurs ont le même ensemble de bits.</i> <br><br>  Si nous prenons ce commentaire à la lettre, alors il est logique que le résultat de l'expression <i>p == q</i> soit «faux», car <i>p</i> et <i>q sont</i> obtenus à partir d'objets différents qui ne sont connectés d'aucune façon.  Il semble que nous nous rapprochions de la vérité - ou non?  Jusqu'à présent, nous avons traité des opérateurs d'égalité, mais qu'en est-il des opérateurs de relation? <br><br><h3>  Le dernier indice est en relation avec les opérateurs? </h3><br>  La définition des opérateurs de relation <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> et <i>&gt; =</i> dans le contexte des comparaisons de pointeurs contient une pensée curieuse: <br><table><tbody><tr><td>  <b>C11 § 6.5.8 paragraphe 5</b> <br><br>  Le résultat de la comparaison de deux pointeurs dépend de la position relative des objets indiqués dans l'espace d'adressage.  Si deux pointeurs vers des types d'objet font référence au même objet, ou les deux font référence à la position après le dernier élément du même tableau, ces pointeurs sont égaux.  Si les objets indiqués sont membres du même objet composite, les pointeurs vers les membres de la structure déclarés plus tard sont plus que les pointeurs vers les membres déclarés plus tôt, et les pointeurs vers les éléments d'un tableau avec des indices plus élevés sont plus que les pointeurs vers les éléments du même tableau avec des indices inférieurs.  Tous les pointeurs vers les membres d'une même association sont égaux.  Si l'expression <i>P</i> pointe vers un élément du tableau et que l'expression <i>Q</i> pointe vers le dernier élément du même tableau, alors la valeur de l'expression de pointeur <i>Q + 1 est</i> supérieure à la valeur de l'expression <i>P.</i>  Dans tous les autres cas, le comportement n'est pas défini. </td></tr></tbody></table><br>  Selon cette définition, le résultat de la comparaison des pointeurs n'est déterminé que si les pointeurs sont obtenus à partir <i>du même</i> objet.  Nous montrons cela avec deux exemples. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Ici, les pointeurs <i>p</i> et <i>q</i> font référence à deux objets différents qui ne sont pas interconnectés.  Par conséquent, le résultat de leur comparaison n'est pas défini.  Mais dans l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  les pointeurs <i>p</i> et <i>q se</i> réfèrent au même objet et sont donc interconnectés.  Ainsi, ils peuvent être comparés - à moins que <i>malloc</i> ne renvoie une valeur nulle. <br><br><h3>  Résumé </h3><br>  La norme C11 ne décrit pas correctement les comparaisons de pointeurs.  Le point le plus problématique que nous avons rencontré était le paragraphe 6 § 6.5.9, où il est explicitement autorisé de comparer deux pointeurs qui font référence à deux tableaux différents.  Cela contredit le commentaire du rapport de bogue n ° 260.  Cependant, nous parlons là de significations indéfinies, et je ne voudrais pas construire mon raisonnement sur la seule base de ce commentaire et l'interpréter dans un autre contexte.  Lors de la comparaison de pointeurs, les opérateurs de relation sont définis légèrement différemment des opérateurs d'égalité - à savoir, les opérateurs de relation ne sont définis que si les deux pointeurs sont obtenus à partir <i>du même</i> objet. <br><br>  Si nous ignorons le texte de la norme et demandons s'il est possible de comparer deux pointeurs obtenus à partir de deux objets différents, alors dans tous les cas la réponse sera très probablement «non».  L'exemple au début de l'article montre un problème théorique.  Étant donné que les variables <i>a</i> et <i>b</i> ont des durées de stockage automatique, nos hypothèses sur leur placement en mémoire ne seront pas fiables.  Dans certains cas, nous pouvons le deviner, mais il est évident qu'un tel code ne peut pas être porté en toute sécurité, et vous ne pouvez découvrir la signification du programme qu'en compilant et en exécutant ou en désassemblant le code, ce qui contredit tout paradigme de programmation sérieux. <br><br>  Cependant, en général, je ne suis pas satisfait du libellé de la norme C11, et comme plusieurs personnes ont déjà rencontré ce problème, la question demeure: pourquoi ne pas formuler plus clairement les règles? <br><br><h3>  Addition <br>  Pointe vers la position après le dernier élément du tableau </h3><br>  En ce qui concerne la règle de comparaison et d'adressage de l'arithmétique des pointeurs à la position après le dernier élément du tableau, vous pouvez souvent y trouver des exceptions.  Supposons que la norme ne permette pas de comparer deux pointeurs obtenus à partir <i>du même</i> tableau, même si au moins l'un d'eux fait référence à la position au-delà de la fin du tableau.  Ensuite, le code suivant ne fonctionnerait pas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  En utilisant une boucle, nous parcourons tout le tableau <i>x</i> , composé de 64 éléments, c'est-à-dire  le corps de la boucle doit s'exécuter exactement 64 fois.  Mais en fait, la condition est vérifiée 65 fois - une fois de plus que le nombre d'éléments dans le tableau.  Dans les 64 premières itérations, le pointeur <i>i se</i> réfère toujours à l'intérieur du tableau <i>x</i> , tandis que l'expression <i>&amp; x [num]</i> indique toujours la position après le dernier élément du tableau.  À la 65e itération, le pointeur <i>i</i> fera également référence à la position au-delà de la fin du tableau <i>x</i> , à cause de laquelle la condition de boucle devient fausse.  Il s'agit d'un moyen pratique de contourner l'ensemble du tableau et il repose sur une exception à la règle d'incertitude de comportement lors de la comparaison de ces pointeurs.  Notez que la norme décrit uniquement le comportement lors de la comparaison de pointeurs;  le déréférencement est une question distincte. <br><br>  Est-il possible de changer notre exemple afin qu'aucun pointeur ne fasse référence à la position après le dernier élément du tableau <i>x</i> ?  C'est possible, mais ce sera plus difficile.  Nous devrons changer la condition de la boucle et interdire l'incrément de la variable <i>i</i> à la dernière itération. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Ce code est plein de subtilités techniques, qui agitent ce qui détourne de la tâche principale.  De plus, une branche supplémentaire est apparue dans le corps de la boucle.  Je trouve donc raisonnable que la norme autorise des exceptions lors de la comparaison de pointeurs de position après le dernier élément d'un tableau. <br><br>  <b><i>PVS-Studio Team Note</i></b> <br><br>  <i>Lors du développement de l'analyseur de code PVS-Studio, nous devons parfois faire face à des problèmes subtils afin de rendre les diagnostics plus précis ou de donner des consultations détaillées à nos clients.</i>  <i>Cet article nous a paru intéressant, car il touche à des questions sur lesquelles nous ne nous sentons pas pleinement confiants.</i>  <i>Par conséquent, nous avons demandé à l'auteur de publier sa traduction.</i>  <i>Nous espérons que davantage de programmeurs C et C ++ apprendront à la connaître et comprendront que ce n'est pas si simple et que lorsque l'analyseur affiche soudainement un message étrange, vous ne devriez pas vous précipiter pour le considérer comme un faux positif :).</i> <br><br>  <i>L'article a d'abord été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>publié</i></a> en anglais sur stefansf.de.</i>  <i>Les traductions sont publiées avec la permission de l'auteur.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418023/">https://habr.com/ru/post/fr418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418009/index.html">Node.js et rendu de serveur dans Airbnb</a></li>
<li><a href="../fr418011/index.html">Pages uniques et référencement. Secrets d'optimisation</a></li>
<li><a href="../fr418013/index.html">Intel Core i7-8086K (partie 3)</a></li>
<li><a href="../fr418015/index.html">Nouveau Vasyuki. Développement innovant de Moscou jusqu'en 2100</a></li>
<li><a href="../fr418017/index.html">Analyse du comportement du cheval de Troie Pegasus sur le réseau</a></li>
<li><a href="../fr418025/index.html">Le livre «Learning Java EE. Programmation moderne pour les grandes entreprises "</a></li>
<li><a href="../fr418027/index.html">Microservice Blitz</a></li>
<li><a href="../fr418029/index.html">ReactOS 0.4.9: les ennemis devront chercher de nouveaux arguments</a></li>
<li><a href="../fr418031/index.html">Empilement de masse des modèles ML en production: réel ou non?</a></li>
<li><a href="../fr418035/index.html">Présentation de Timeline chez Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>