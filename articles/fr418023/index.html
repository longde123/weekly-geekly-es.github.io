<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ üë®üèæ‚Äçüöí üë©üèΩ‚Äçüè≠ Les pointeurs en C sont plus abstraits que vous ne le pensez üë©üèø‚Äçüöí üêê ü§ß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le pointeur fait r√©f√©rence √† une cellule de m√©moire, et d√©r√©f√©rencer un pointeur signifie lire la valeur de la cellule sp√©cifi√©e. La valeur du pointeu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les pointeurs en C sont plus abstraits que vous ne le pensez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418023/">  Le pointeur <i>fait r√©f√©rence</i> √† une cellule de m√©moire, et <i>d√©r√©f√©rencer un</i> pointeur signifie lire la valeur de la cellule sp√©cifi√©e.  La valeur du pointeur lui-m√™me est l'adresse de la cellule m√©moire.  La norme de langage C ne sp√©cifie pas la forme de repr√©sentation des adresses m√©moire.  Il s'agit d'un point tr√®s important, car diff√©rentes architectures peuvent utiliser diff√©rents mod√®les d'adressage.  La plupart des architectures modernes utilisent un espace d'adressage lin√©aire ou similaire.  Cependant, m√™me cette question n'est pas sp√©cifi√©e strictement, car les adresses peuvent √™tre physiques ou virtuelles.  Certaines architectures utilisent une repr√©sentation non num√©rique du tout.  Ainsi, Symbolics Lisp Machine fonctionne avec des tuples de la forme <i>(objet, offset)</i> comme adresses. <br><a name="habracut"></a><table><tbody><tr><td>  Quelque temps plus tard, apr√®s la publication de la traduction sur Habr√©, l'auteur a apport√© d'importantes modifications au texte de l'article.  Mettre √† jour une traduction sur Habr√© n'est pas une bonne id√©e, car certains commentaires perdront leur sens ou sembleront d√©plac√©s.  Je ne veux pas publier le texte en tant que nouvel article.  Par cons√©quent, nous venons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mettre</a> √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jour la traduction de l'article</a> sur viva64.com, et ici nous avons tout laiss√© tel quel.  Si vous √™tes un nouveau lecteur, je vous sugg√®re de lire une traduction plus r√©cente sur notre site en cliquant sur le lien ci-dessus. </td></tr></tbody></table><br>  La norme ne pr√©cise pas la forme de pr√©sentation des pointeurs, mais stipule - dans une plus ou moins grande mesure - les op√©rations avec eux.  Ci-dessous, nous consid√©rons ces op√©rations et les caract√©ristiques de leur d√©finition dans la norme.  Commen√ßons par l'exemple suivant: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int main(void) { int a, b; int *p = &amp;a; int *q = &amp;b + 1; printf("%p %p %d\n", (void *)p, (void *)q, p == q); return 0; }</span></span></span></span></code> </pre> <br>  Si nous compilons ce code GCC avec le niveau d'optimisation 1 et ex√©cutons le programme sous Linux x86-64, il affichera ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0x7fff4a35b19c</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Notez que les pointeurs <i>p</i> et <i>q</i> font r√©f√©rence √† la m√™me adresse.  Cependant, le r√©sultat de l'expression <i>p == q</i> est <i>faux</i> , et cela √† premi√®re vue semble √©trange.  Les deux pointeurs vers la m√™me adresse ne devraient-ils pas √™tre √©gaux? <br><br>  Voici comment la norme C d√©finit le r√©sultat de la v√©rification de l'√©galit√© de deux pointeurs: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.9 paragraphe 6</b> <br><br>  Deux pointeurs sont √©gaux si et seulement si les deux sont nuls, soit pointent vers le m√™me objet (y compris un pointeur vers l'objet et le premier sous-objet dans l'objet) ou une fonction, soit pointent vers la position apr√®s le dernier √©l√©ment du tableau, ou un pointeur fait r√©f√©rence √† la position apr√®s le dernier √©l√©ment du tableau, et l'autre fait r√©f√©rence au d√©but d'un autre tableau suivant imm√©diatement le premier dans le m√™me espace d'adressage. </td></tr></tbody></table><br>  Tout d'abord, la question se pose: qu'est-ce qu'un ¬´objet <i>¬ª</i> ?  Puisque nous parlons du langage C, il est √©vident qu'ici les objets n'ont rien √† voir avec les objets dans les langages OOP comme C ++.  Dans la norme C, ce concept n'est pas compl√®tement d√©fini: <br><table><tbody><tr><td>  <b>C11 ¬ß 3.15</b> <br><br>  Un objet est une zone de stockage d'ex√©cution dont le contenu peut √™tre utilis√© pour repr√©senter des valeurs <br><br>  REMARQUE Lorsqu'il est mentionn√©, un objet peut √™tre consid√©r√© comme ayant un type sp√©cifique;  voir 6.3.2.1. </td></tr></tbody></table><br>  Faisons les choses correctement.  Une variable enti√®re 16 bits est un ensemble de donn√©es en m√©moire qui peut repr√©senter des valeurs enti√®res 16 bits.  Par cons√©quent, une telle variable est un objet.  Est-ce que deux pointeurs seront √©gaux si l'un d'eux fait r√©f√©rence au premier octet d'un entier donn√© et le second au deuxi√®me octet du m√™me nombre?  Le comit√© de normalisation linguistique, bien s√ªr, ne le voulait pas du tout.  Mais ici, il convient de noter qu'√† cet √©gard, il n'a pas d'explications claires, et nous sommes oblig√©s de deviner ce que l'on voulait vraiment dire. <br><br><h3>  Quand le compilateur se met en travers </h3><br>  Revenons √† notre premier exemple.  Le pointeur <i>p est</i> obtenu √† partir de l'objet <i>a</i> , et le pointeur <i>q</i> est √† partir de l'objet <i>b</i> .  Dans le second cas, l'arithm√©tique d'adresse est utilis√©e, qui est d√©finie comme suit pour les op√©rateurs plus et moins: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 clause 7</b> <br><br>  Lorsqu'il est utilis√© avec ces op√©rateurs, un pointeur sur un objet qui n'est pas un √©l√©ment du tableau se comporte comme un pointeur sur le d√©but d'un tableau d'une longueur d'un √©l√©ment, dont le type correspond au type de l'objet d'origine. </td></tr></tbody></table><br>  √âtant donn√© que tout pointeur vers un objet qui n'est pas un tableau devient en <i>fait</i> un pointeur vers un tableau d'une longueur d'un √©l√©ment, la norme d√©finit l'arithm√©tique des adresses uniquement pour les pointeurs vers les tableaux - c'est le point 8. Nous nous int√©ressons √† la partie suivante: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.6 clause 8</b> <br><br>  Si une expression enti√®re est ajout√©e ou soustraite du pointeur, le pointeur r√©sultant est du m√™me type que le pointeur d'origine.  Si le pointeur source fait r√©f√©rence √† un √©l√©ment de tableau et que le tableau est de longueur suffisante, la source et les √©l√©ments r√©sultants sont s√©par√©s les uns des autres de sorte que la diff√©rence entre leurs indices soit √©gale √† la valeur de l'expression enti√®re.  En d'autres termes, si l'expression <i>P</i> pointe vers le i√®me √©l√©ment du tableau, les expressions <i>(P) + N</i> (ou son √©quivalent <i>N + (P)</i> ) et <i>(P) -N</i> (o√π <i>N</i> a la valeur n) indiquent respectivement (i + n) e et (i - n) e √©l√©ments du tableau, √† condition qu'ils existent.  De plus, si l'expression <i>P</i> pointe vers le dernier √©l√©ment du tableau, alors l'expression <i>(P) +1</i> indique la position apr√®s le dernier √©l√©ment du tableau, et si l'expression <i>Q</i> indique la position apr√®s le dernier √©l√©ment du tableau, alors l'expression <i>(Q) -1</i> indique le dernier √©l√©ment tableau.  Si la source et les pointeurs r√©sultants font r√©f√©rence √† des √©l√©ments du m√™me tableau ou √† la position apr√®s le dernier √©l√©ment du tableau, le d√©bordement est exclu;  sinon, le comportement n'est pas d√©fini.  Si le pointeur r√©sultant fait r√©f√©rence √† la position apr√®s le dernier √©l√©ment du tableau, l'op√©rateur unaire <i>*</i> ne peut pas lui √™tre appliqu√©. </td></tr></tbody></table><br>  Il s'ensuit que le r√©sultat de l'expression <i>&amp; b + 1</i> devrait certainement √™tre une adresse, et donc <i>p</i> et <i>q</i> sont des pointeurs valides.  Permettez-moi de vous rappeler comment l'√©galit√© de deux pointeurs dans la norme est d√©finie: " <i>Deux pointeurs sont √©gaux si et seulement si [...] un pointeur se r√©f√®re √† la position apr√®s le dernier √©l√©ment du tableau, et l'autre au d√©but d'un autre tableau imm√©diatement apr√®s le premier du m√™me espace d'adressage "</i> (C11 ¬ß 6.5.9, clause 6).  C'est exactement ce que nous observons dans notre exemple.  Le pointeur q fait r√©f√©rence √† la position apr√®s l'objet b, imm√©diatement suivie par l'objet a, auquel le pointeur p fait r√©f√©rence.  Alors, y a-t-il un bug dans GCC?  Cette contradiction a √©t√© d√©crite en 2014 comme le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bug # 61502</a> , mais les d√©veloppeurs de GCC ne le consid√®rent pas comme un bug et ne vont donc pas le corriger. <br><br>  Un probl√®me similaire a √©t√© rencontr√© en 2016 par les programmeurs Linux.  Consid√©rez le code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _start[]; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _end[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = _start; i != _end; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } }</code> </pre> <br>  Les symboles <i>_start</i> et <i>_end</i> sp√©cifient les limites de la zone m√©moire.  Puisqu'ils sont transf√©r√©s vers un fichier externe, le compilateur ne sait pas comment les tableaux sont r√©ellement situ√©s en m√©moire.  Pour cette raison, il doit √™tre prudent ici et partir de l'hypoth√®se qu'ils se succ√®dent dans l'espace d'adressage.  Cependant, GCC compile la condition de boucle afin qu'elle soit toujours vraie, ce qui rend la boucle infinie.  Ce probl√®me est d√©crit ici dans cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur LKML</a> - un fragment de code similaire y est utilis√©.  Il semble que dans ce cas, les auteurs de GCC aient n√©anmoins pris en compte les commentaires et chang√© le comportement du compilateur.  Au moins, je n'ai pas pu reproduire cette erreur dans GCC version 7.3.1 sous Linux x86_64. <br><br><h3>  Solution - dans le rapport de bogue n ¬∞ 260? </h3><br>  Notre cas peut clarifier le rapport de bogue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="># 260</a> .  Il s'agit plut√¥t de valeurs incertaines, mais vous pouvez y trouver un commentaire curieux du comit√©: <br><br>  <i>Les impl√©mentations du compilateur [...] peuvent √©galement distinguer les pointeurs obtenus √† partir d'objets diff√©rents, m√™me si ces pointeurs ont le m√™me ensemble de bits.</i> <br><br>  Si nous prenons ce commentaire √† la lettre, alors il est logique que le r√©sultat de l'expression <i>p == q</i> soit ¬´faux¬ª, car <i>p</i> et <i>q sont</i> obtenus √† partir d'objets diff√©rents qui ne sont connect√©s d'aucune fa√ßon.  Il semble que nous nous rapprochions de la v√©rit√© - ou non?  Jusqu'√† pr√©sent, nous avons trait√© des op√©rateurs d'√©galit√©, mais qu'en est-il des op√©rateurs de relation? <br><br><h3>  Le dernier indice est en relation avec les op√©rateurs? </h3><br>  La d√©finition des op√©rateurs de relation <i>&lt;</i> , <i>&lt;=</i> , <i>&gt;</i> et <i>&gt; =</i> dans le contexte des comparaisons de pointeurs contient une pens√©e curieuse: <br><table><tbody><tr><td>  <b>C11 ¬ß 6.5.8 paragraphe 5</b> <br><br>  Le r√©sultat de la comparaison de deux pointeurs d√©pend de la position relative des objets indiqu√©s dans l'espace d'adressage.  Si deux pointeurs vers des types d'objet font r√©f√©rence au m√™me objet, ou les deux font r√©f√©rence √† la position apr√®s le dernier √©l√©ment du m√™me tableau, ces pointeurs sont √©gaux.  Si les objets indiqu√©s sont membres du m√™me objet composite, les pointeurs vers les membres de la structure d√©clar√©s plus tard sont plus que les pointeurs vers les membres d√©clar√©s plus t√¥t, et les pointeurs vers les √©l√©ments d'un tableau avec des indices plus √©lev√©s sont plus que les pointeurs vers les √©l√©ments du m√™me tableau avec des indices inf√©rieurs.  Tous les pointeurs vers les membres d'une m√™me association sont √©gaux.  Si l'expression <i>P</i> pointe vers un √©l√©ment du tableau et que l'expression <i>Q</i> pointe vers le dernier √©l√©ment du m√™me tableau, alors la valeur de l'expression de pointeur <i>Q + 1 est</i> sup√©rieure √† la valeur de l'expression <i>P.</i>  Dans tous les autres cas, le comportement n'est pas d√©fini. </td></tr></tbody></table><br>  Selon cette d√©finition, le r√©sultat de la comparaison des pointeurs n'est d√©termin√© que si les pointeurs sont obtenus √† partir <i>du m√™me</i> objet.  Nous montrons cela avec deux exemples. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) <span class="hljs-comment"><span class="hljs-comment">//   foo();</span></span></code> </pre> <br>  Ici, les pointeurs <i>p</i> et <i>q</i> font r√©f√©rence √† deux objets diff√©rents qui ne sont pas interconnect√©s.  Par cons√©quent, le r√©sultat de leur comparaison n'est pas d√©fini.  Mais dans l'exemple suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *q = p + <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p &lt; q) foo();</code> </pre> <br>  les pointeurs <i>p</i> et <i>q se</i> r√©f√®rent au m√™me objet et sont donc interconnect√©s.  Ainsi, ils peuvent √™tre compar√©s - √† moins que <i>malloc</i> ne renvoie une valeur nulle. <br><br><h3>  R√©sum√© </h3><br>  La norme C11 ne d√©crit pas correctement les comparaisons de pointeurs.  Le point le plus probl√©matique que nous avons rencontr√© √©tait le paragraphe 6 ¬ß 6.5.9, o√π il est explicitement autoris√© de comparer deux pointeurs qui font r√©f√©rence √† deux tableaux diff√©rents.  Cela contredit le commentaire du rapport de bogue n ¬∞ 260.  Cependant, nous parlons l√† de significations ind√©finies, et je ne voudrais pas construire mon raisonnement sur la seule base de ce commentaire et l'interpr√©ter dans un autre contexte.  Lors de la comparaison de pointeurs, les op√©rateurs de relation sont d√©finis l√©g√®rement diff√©remment des op√©rateurs d'√©galit√© - √† savoir, les op√©rateurs de relation ne sont d√©finis que si les deux pointeurs sont obtenus √† partir <i>du m√™me</i> objet. <br><br>  Si nous ignorons le texte de la norme et demandons s'il est possible de comparer deux pointeurs obtenus √† partir de deux objets diff√©rents, alors dans tous les cas la r√©ponse sera tr√®s probablement ¬´non¬ª.  L'exemple au d√©but de l'article montre un probl√®me th√©orique.  √âtant donn√© que les variables <i>a</i> et <i>b</i> ont des dur√©es de stockage automatique, nos hypoth√®ses sur leur placement en m√©moire ne seront pas fiables.  Dans certains cas, nous pouvons le deviner, mais il est √©vident qu'un tel code ne peut pas √™tre port√© en toute s√©curit√©, et vous ne pouvez d√©couvrir la signification du programme qu'en compilant et en ex√©cutant ou en d√©sassemblant le code, ce qui contredit tout paradigme de programmation s√©rieux. <br><br>  Cependant, en g√©n√©ral, je ne suis pas satisfait du libell√© de la norme C11, et comme plusieurs personnes ont d√©j√† rencontr√© ce probl√®me, la question demeure: pourquoi ne pas formuler plus clairement les r√®gles? <br><br><h3>  Addition <br>  Pointe vers la position apr√®s le dernier √©l√©ment du tableau </h3><br>  En ce qui concerne la r√®gle de comparaison et d'adressage de l'arithm√©tique des pointeurs √† la position apr√®s le dernier √©l√©ment du tableau, vous pouvez souvent y trouver des exceptions.  Supposons que la norme ne permette pas de comparer deux pointeurs obtenus √† partir <i>du m√™me</i> tableau, m√™me si au moins l'un d'eux fait r√©f√©rence √† la position au-del√† de la fin du tableau.  Ensuite, le code suivant ne fonctionnerait pas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt; &amp;x[num]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  En utilisant une boucle, nous parcourons tout le tableau <i>x</i> , compos√© de 64 √©l√©ments, c'est-√†-dire  le corps de la boucle doit s'ex√©cuter exactement 64 fois.  Mais en fait, la condition est v√©rifi√©e 65 fois - une fois de plus que le nombre d'√©l√©ments dans le tableau.  Dans les 64 premi√®res it√©rations, le pointeur <i>i se</i> r√©f√®re toujours √† l'int√©rieur du tableau <i>x</i> , tandis que l'expression <i>&amp; x [num]</i> indique toujours la position apr√®s le dernier √©l√©ment du tableau.  √Ä la 65e it√©ration, le pointeur <i>i</i> fera √©galement r√©f√©rence √† la position au-del√† de la fin du tableau <i>x</i> , √† cause de laquelle la condition de boucle devient fausse.  Il s'agit d'un moyen pratique de contourner l'ensemble du tableau et il repose sur une exception √† la r√®gle d'incertitude de comportement lors de la comparaison de ces pointeurs.  Notez que la norme d√©crit uniquement le comportement lors de la comparaison de pointeurs;  le d√©r√©f√©rencement est une question distincte. <br><br>  Est-il possible de changer notre exemple afin qu'aucun pointeur ne fasse r√©f√©rence √† la position apr√®s le dernier √©l√©ment du tableau <i>x</i> ?  C'est possible, mais ce sera plus difficile.  Nous devrons changer la condition de la boucle et interdire l'incr√©ment de la variable <i>i</i> √† la derni√®re it√©ration. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[num]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = x; i &lt;= &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]; ++i) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == &amp;x[num<span class="hljs-number"><span class="hljs-number">-1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Ce code est plein de subtilit√©s techniques, qui agitent ce qui d√©tourne de la t√¢che principale.  De plus, une branche suppl√©mentaire est apparue dans le corps de la boucle.  Je trouve donc raisonnable que la norme autorise des exceptions lors de la comparaison de pointeurs de position apr√®s le dernier √©l√©ment d'un tableau. <br><br>  <b><i>PVS-Studio Team Note</i></b> <br><br>  <i>Lors du d√©veloppement de l'analyseur de code PVS-Studio, nous devons parfois faire face √† des probl√®mes subtils afin de rendre les diagnostics plus pr√©cis ou de donner des consultations d√©taill√©es √† nos clients.</i>  <i>Cet article nous a paru int√©ressant, car il touche √† des questions sur lesquelles nous ne nous sentons pas pleinement confiants.</i>  <i>Par cons√©quent, nous avons demand√© √† l'auteur de publier sa traduction.</i>  <i>Nous esp√©rons que davantage de programmeurs C et C ++ apprendront √† la conna√Ætre et comprendront que ce n'est pas si simple et que lorsque l'analyseur affiche soudainement un message √©trange, vous ne devriez pas vous pr√©cipiter pour le consid√©rer comme un faux positif :).</i> <br><br>  <i>L'article a d'abord √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>publi√©</i></a> en anglais sur stefansf.de.</i>  <i>Les traductions sont publi√©es avec la permission de l'auteur.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418023/">https://habr.com/ru/post/fr418023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418009/index.html">Node.js et rendu de serveur dans Airbnb</a></li>
<li><a href="../fr418011/index.html">Pages uniques et r√©f√©rencement. Secrets d'optimisation</a></li>
<li><a href="../fr418013/index.html">Intel Core i7-8086K (partie 3)</a></li>
<li><a href="../fr418015/index.html">Nouveau Vasyuki. D√©veloppement innovant de Moscou jusqu'en 2100</a></li>
<li><a href="../fr418017/index.html">Analyse du comportement du cheval de Troie Pegasus sur le r√©seau</a></li>
<li><a href="../fr418025/index.html">Le livre ¬´Learning Java EE. Programmation moderne pour les grandes entreprises "</a></li>
<li><a href="../fr418027/index.html">Microservice Blitz</a></li>
<li><a href="../fr418029/index.html">ReactOS 0.4.9: les ennemis devront chercher de nouveaux arguments</a></li>
<li><a href="../fr418031/index.html">Empilement de masse des mod√®les ML en production: r√©el ou non?</a></li>
<li><a href="../fr418035/index.html">Pr√©sentation de Timeline chez Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>