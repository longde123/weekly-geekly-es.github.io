<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍼 ☠️ 🥛 تفاصيل GraphQL: ماذا وكيف ولماذا 🧝🏽 🔜 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GraphQL الآن ، دون مبالغة ، هذه هي آخر زقزقة في وضع تقنية المعلومات. وإذا كنت لا تعرف بعد نوع التقنية المستخدمة ، وكيفية استخدامها ، ولماذا قد تكون مف...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تفاصيل GraphQL: ماذا وكيف ولماذا</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/445268/" style=";text-align:right;direction:rtl">  GraphQL الآن ، دون مبالغة ، هذه هي آخر زقزقة في وضع تقنية المعلومات.  وإذا كنت لا تعرف بعد نوع التقنية المستخدمة ، وكيفية استخدامها ، ولماذا قد تكون مفيدة لك ، فإن المقالة التي ننشرها اليوم مكتوبة من أجلك.  سنقوم هنا باستعراض أساسيات GraphQL باستخدام مثال لتطبيق مخطط البيانات لواجهة برمجة التطبيقات لشركة الفشار.  على وجه الخصوص ، دعنا نتحدث عن أنواع البيانات والاستعلامات والطفرات. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/c7/oq/a1/c7oqa1w2b00akzatd2womwb_daw.png"></a> <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">ما هو GraphQL؟</font> </h2><br>  GraphQL هي لغة استعلام تستخدمها تطبيقات العميل للعمل مع البيانات.  يرتبط GraphQL بمفهوم مثل "المخطط" - وهذا ما يسمح لك بتنظيم إنشاء وقراءة وتحديث وحذف البيانات في التطبيق الخاص بك (أي ، لدينا أربع وظائف أساسية تستخدم عند العمل مع مستودعات البيانات ، والتي يشار إليها عادةً بالاختصار CRUD - إنشاء ، قراءة ، تحديث ، حذف). <br><br>  قيل أعلاه أن GraphQL يستخدم للعمل مع البيانات في "تطبيقك" وليس "في قاعدة البيانات الخاصة بك".  الحقيقة هي أن GraphQL هو نظام مستقل عن مصادر البيانات ، أي أنه لا يهم أين يتم تنظيمه لتنظيم عمله. <br><br>  إذا نظرت ، دون معرفة أي شيء عن GraphQL ، باسم هذه التقنية ، فقد يبدو أننا نواجه شيئًا معقدًا ومربكًا للغاية.  اسم التكنولوجيا لديه كلمة "الرسم البياني".  هل هذا يعني أنه من أجل إتقانها ، عليك أن تتعلم كيفية العمل مع قواعد بيانات الرسم البياني؟  وحقيقة أن الاسم يحتوي على "QL" (والتي يمكن أن تعني "لغة الاستعلام" ، أي "لغة الاستعلام") ، هل هذا يعني أن أولئك الذين يريدون استخدام GraphQL سيتعين عليهم تعلم لغة برمجة جديدة تمامًا؟ <br><br>  هذه المخاوف ليست مبررة تماما.  من أجل طمأنتك - هذه هي الحقيقة القاسية حول هذه التقنية: إنها مجرد طلبات <code>GET</code> أو <code>POST</code> .  بينما تقدم GraphQL ، بشكل عام ، بعض المفاهيم الجديدة المتعلقة بتنظيم البيانات والتفاعل معها ، تعتمد الآليات الداخلية لهذه التكنولوجيا على طلبات HTTP القديمة الجيدة. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">إعادة التفكير في تقنية REST</font> </h2><br>  المرونة هي ما يميز تقنية GraphQL عن تقنية REST المعروفة.  عند استخدام REST ، إذا تم تنفيذ كل شيء بشكل صحيح ، فعادة ما يتم إنشاء نقاط النهاية مع مراعاة خصائص نوع بيانات مورد أو تطبيق معين. <br><br>  على سبيل المثال ، عند تنفيذ طلب <code>GET</code> النهاية <code>/api/v1/flavors</code> من المتوقع أن يرسل ردًا يبدو كالتالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[ {  "id": 1,   "name": "The Lazy Person's Movie Theater",   "description": "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }, {   "id": 2,   "name": "What's Wrong With You Caramel",   "description": "You're a crazy person that likes sweet popcorn. Congratulations." }, {   "id": 3,   "name": "Gnarly Chili Lime",   "description": "The kind of popcorn you make when you need a good smack in the face."} ]</code> </pre> <br>  لا يوجد خطأ كارثي في ​​هذه الإجابة ، ولكن دعونا نفكر في واجهة المستخدم ، أو بالأحرى ، كيف نعتزم استهلاك هذه البيانات. <br><br>  إذا كنا نريد عرض قائمة بسيطة في الواجهة التي تحتوي فقط على أسماء أنواع الفشار المتاحة (وأي شيء آخر) ، فقد تبدو هذه القائمة مثل القائمة الموضحة أدناه. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a89/0fd/c56/a890fdc56389815233584327e76011c1.png"></div><br>  <i><font color="#999999">قائمة أنواع الفشار</font></i> <br><br>  يمكن أن نرى أننا هنا في وضع صعب.  قد نقرر عدم استخدام حقل <code>description</code> ، لكن هل سنجلس ونتظاهر أننا لم نرسل هذا الحقل إلى العميل؟  ماذا يمكن أن نفعل؟  وعندما يسألوننا بعد بضعة أشهر عن سبب بطء التطبيق بالنسبة للمستخدمين ، علينا فقط أن نسمح للرجل ولم يعد يجتمع مع إدارة الشركة التي صنعنا هذا التطبيق من أجلها. <br><br>  في الواقع ، حقيقة أن الخادم يرسل بيانات غير ضرورية استجابة لطلب العميل ليست خطأنا بالكامل.  REST هي عبارة عن آلية للحصول على البيانات يمكن مقارنتها بمطعم يسأل فيه النادل الزائر: "ماذا تريد؟" ، ولا يهتم بشكل خاص برغباته ، يقول له: "سأحضر لك ما لدينا" . <br><br>  إذا وضعنا النكات جانباً ، فإن ذلك قد يؤدي إلى حدوث مشكلات في التطبيقات الحقيقية.  على سبيل المثال ، يمكننا عرض معلومات إضافية متنوعة حول كل نوع من أنواع الفشار ، مثل معلومات الأسعار أو معلومات حول الشركة المصنعة أو المعلومات الغذائية ("Vegan Popcorn!").  في الوقت نفسه ، فإن نقاط النهاية REST غير المرنة تجعل من الصعب للغاية الحصول على بيانات محددة حول أنواع معينة من الفشار ، مما يؤدي إلى تحميل عالي بشكل غير معقول على الأنظمة وإلى حقيقة أن الحلول الناتجة أبعد ما تكون عن تلك التي قد يفخر بها المطورون. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">كيف تحسن تقنية GraphQL ما هي تقنية REST المستخدمة في</font> </h2><br>  قد يبدو التحليل السطحي للحالة الموصوفة أعلاه أننا مجرد مشكلة بسيطة.  "ما الخطأ في إرسال البيانات غير الضرورية للعميل؟"  لفهم المدى الذي يمكن أن تكون عليه "البيانات غير الضرورية" مشكلة كبيرة ، تذكر أن GraphQL تم تطويره بواسطة Facebook.  هذه الشركة لديها لخدمة ملايين الطلبات في الثانية الواحدة. <br><br>  ماذا يعني هذا؟  وحقيقة أنه مع مثل هذه المجلدات كل شيء يذكر. <br><br>  GraphQL ، إذا واصلنا التشبيه مع مطعم ، فبدلاً من "نقل" الزائر "ما" ، يجلب بالضبط ما يأمر الزائر. <br><br>  يمكننا الحصول على استجابة من GraphQL التي تركز على السياق الذي يتم فيه استخدام البيانات.  في هذه الحالة ، لا نحتاج إلى إضافة نقاط وصول "لمرة واحدة" إلى النظام ، أو تنفيذ العديد من الطلبات أو كتابة هياكل شرطية متعددة الطوابق. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">كيف يعمل GraphQL؟</font> </h2><br>  كما قلنا من قبل ، تعتمد GraphQL على طلبات <code>GET</code> أو <code>POST</code> البسيطة لنقل البيانات إلى العميل واستلامها منها.  إذا نظرنا إلى هذه الفكرة بمزيد من التفصيل ، اتضح أن هناك نوعين من الاستعلامات في GraphQL.  يشتمل النوع الأول على طلبات لقراءة البيانات ، والتي في مصطلحات GraphQL تُسمى ببساطة الاستعلامات وتشير إلى الحرف R (القراءة ، القراءة) من اختصار CRUD.  استعلامات النوع الثاني هي طلبات تعديل البيانات ، والتي تسمى الطفرات في GraphQL.  إنها تتعلق بمربعات المحور C و U و D في اختصار CRUD ، أي أنها تستخدمها لإنشاء السجلات وإنشائها وتحديثها وحذفها. <br><br>  يتم إرسال جميع هذه الطلبات والطفرات إلى عنوان URL لخادم GraphQL ، والذي قد يبدو ، على سبيل المثال ، <code>https://myapp.com/graphql</code> ، في شكل طلبات <code>GET</code> أو <code>POST</code> .  سنتحدث أكثر عن هذا أدناه. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">استفسارات GraphQL</font> </h2><br>  استعلامات GraphQL هي كيانات تمثل طلبًا للخادم لتلقي بيانات معينة.  على سبيل المثال ، لدينا واجهة مستخدم معينة نريد تعبئتها بالبيانات.  لهذه البيانات ، ننتقل إلى الخادم ، تنفيذ الطلب.  عند استخدام واجهات برمجة تطبيقات REST التقليدية ، يأخذ طلبنا شكل طلب GET.  عند العمل مع GraphQL ، يتم استخدام بناء جملة استعلام جديد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  هل هذا جسون؟  أو كائن جافا سكريبت؟  لا أحد ولا الآخر.  كما قلنا من قبل ، باسم تقنية GraphQL ، تعني آخر حرفين ، QL ، "لغة الاستعلام" ، أي لغة الاستعلام.  هذه ، حرفيًا ، لغة جديدة لكتابة طلبات البيانات.  كل هذا يبدو وكأنه وصف لشيء معقد إلى حد ما ، ولكن في الواقع لا يوجد شيء معقد هنا.  دعنا نحلل الاستعلام أعلاه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ //    ,   . }</code> </pre> <br>  تبدأ جميع الطلبات بـ "طلب الجذر" ، ويطلق على الحقل ما تحتاج إلى الحصول عليه أثناء تنفيذ الطلب.  من أجل إنقاذ نفسك من الارتباك ، من الأفضل استدعاء هذه الكيانات "حقول الاستعلام في المخطط".  إذا بدا هذا الاسم غير مفهوم بالنسبة لك - انتظر قليلاً - أدناه سنتحدث أكثر عن المخطط.  نحن هنا ، في الاستعلام الجذر ، نطلب حقل <code>flavors</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   //  ,        flavor. } }</code> </pre> <br>  عند طلب حقل معين ، يجب أن نشير أيضًا إلى الحقول المتداخلة التي يجب تلقيها لكل كائن يأتي استجابة للطلب (حتى إذا كان من المتوقع أن يأتي كائن واحد فقط استجابة للطلب). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   name } }</code> </pre> <br>  ماذا ستكون النتيجة؟  بعد أن نرسل مثل هذا الطلب إلى خادم GraphQL ، سوف نحصل على إجابة أنيقة جيدة التنظيم مثل ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "data": {   "flavors": [     { "name": "The Lazy Person's Movie Theater" },     { "name": "What's Wrong With You Caramel" },     { "name": "Gnarly Chili Lime" }   ] } }</code> </pre> <br>  يرجى ملاحظة أنه لا يوجد شيء لا لزوم له.  لجعلها أكثر وضوحًا ، إليك طلب آخر يتم تنفيذه للحصول على البيانات في صفحة أخرى من التطبيق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   id   name   description } }</code> </pre> <br>  استجابة لهذا الطلب ، حصلنا على ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" },     { "id": 2, "name": "What's Wrong With You Caramel", description: "You're a crazy person that likes sweet popcorn. Congratulations." },     { "id": 3, "name": "Gnarly Chili Lime", description: "A friend told me this would taste good. It didn't. It burned my kernels. I haven't had the heart to tell him." }   ] } }</code> </pre> <br>  كما ترون ، GraphQL هي تقنية قوية للغاية.  ننتقل إلى نفس نقطة النهاية ، وتتوافق إجابات الطلبات تمامًا مع ما هو مطلوب لملء الصفحة التي يتم تنفيذ هذه الطلبات منها. <br><br>  إذا كنا بحاجة إلى الحصول على كائن <code>flavor</code> واحد فقط ، فيمكننا الاستفادة من حقيقة أن GraphQL يمكن أن يعمل مع الوسائط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors(id: "1") {   id   name   description } }</code> </pre> <br>  نحن هنا نضع بصرامة المعرف <code>id</code> للكائن في الكود ، المعلومات التي نحتاجها ، لكن في مثل هذه الحالات يمكننا استخدام المعرفات الديناميكية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">query getFlavor($id: ID) { flavors(id: $id) {   id   name   description } }</code> </pre> <br>  هنا ، في السطر الأول ، نعطي الطلب اسمًا (يتم اختيار الاسم بشكل تعسفي ، ويمكن استبدال <code>getFlavor</code> بشيء مثل <code>pizza</code> ، وسيظل الطلب قيد التشغيل) ونعلن عن المتغيرات التي يتوقعها الطلب.  في هذه الحالة ، من المفترض أن يتم تمرير <code>id</code> ( <code>id</code> ) <code>ID</code> نوع العدد القياسي إلى الطلب (سنتحدث عن الأنواع أدناه). <br><br>  بغض النظر عما إذا كان <code>id</code> استخدام <code>id</code> ثابت أو ديناميكي عند تنفيذ طلب ما ، إليك ما ستبدو عليه الاستجابة لطلب مماثل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "data": {   "flavors": [     { "id": 1, "name": "The Lazy Person's Movie Theater", description: "That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!" }   ] } }</code> </pre> <br>  كما ترون ، يتم ترتيب كل شيء مريح للغاية.  ربما تبدأ بالتفكير في استخدام GraphQL في مشروعك الخاص.  وعلى الرغم من أن ما تحدثنا عنه بالفعل يبدو رائعًا ، إلا أن جمال GraphQL يظهر حقًا حيث يعمل مع الحقول المتداخلة.  لنفترض أنه يوجد في مخططنا حقل آخر يسمى <code>nutrition</code> يحتوي على معلومات حول القيمة الغذائية لأنواع مختلفة من الفشار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories     fat     sodium   } } }</code> </pre> <br>  قد يبدو أنه في مستودع البيانات الخاص بنا ، سيحتوي كل كائن <code>flavor</code> على كائن <code>nutrition</code> متداخل.  ولكن هذا ليس صحيحا تماما.  باستخدام GraphQL ، يمكنك دمج المكالمات مع مصادر البيانات المستقلة ، ولكن ذات الصلة في استعلام واحد ، والذي يسمح لك بتلقي الإجابات التي توفر الراحة في العمل مع البيانات المضمنة دون الحاجة إلى إلغاء تجزئة قاعدة البيانات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ "data": {   "flavors": [     {       "id": 1,       "name": "The Lazy Person's Movie Theater",       "nutrition": {         "calories": 500,         "fat": 12,         "sodium": 1000       }     },     ...   ] } }</code> </pre> <br>  هذا يمكن أن يزيد بشكل كبير من إنتاجية المبرمج وسرعة النظام. <br><br>  حتى الآن ، تحدثنا عن طلبات القراءة.  ماذا عن طلبات تحديث البيانات؟  هل استخدامها يعطينا نفس الراحة؟ <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">طفرات GraphQL</font> </h2><br>  أثناء تحميل استعلامات GraphQL البيانات ، تكون الطفرات مسؤولة عن إجراء تغييرات على البيانات.  يمكن استخدام الطفرات في شكل آلية RPC (استدعاء الإجراء عن بُعد) الأساسية لحل المهام المختلفة ، مثل إرسال بيانات المستخدم إلى واجهة برمجة تطبيقات لجهة خارجية. <br><br>  عند وصف الطفرات ، يتم استخدام بناء جملة يشبه الذي استخدمناه عند إنشاء الاستعلامات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">mutation updateFlavor($id: ID!, $name: String, $description: String) { updateFlavor(id: $id, name: $name, description: $description) {   id   name   description } }</code> </pre> <br>  نعلن هنا طفرة <code>updateFlavor</code> ، مع تحديد بعض المتغيرات - <code>id</code> <code>name</code> <code>description</code> .  بالتصرف وفقًا لنفس المخطط المستخدم لوصف الاستعلامات ، نقوم "بإعداد" حقول متغيرة (طفرة الجذر) باستخدام الكلمة الأساسية <code>mutation</code> ، متبوعةً باسم يصف الطفرة ، ومجموعة من المتغيرات اللازمة لتشكيل طلب تغيير البيانات المقابل. <br><br>  تتضمن هذه المتغيرات ما نحاول تغييره ، أو ما هي الطفرة التي نرغب في إحداثها.  يرجى أيضًا ملاحظة أنه بعد الطفرة ، يمكننا طلب إعادة بعض الحقول. <br><br>  في هذه الحالة ، نحتاج إلى الحصول على حقول <code>id</code> <code>name</code> <code>description</code> بعد تغيير السجل.  يمكن أن يكون هذا مفيدًا عند تطوير شيء مثل الواجهات المتفائلة ، مما يلغي الحاجة إلى تلبية طلب لتلقي البيانات التي تم تغييرها بعد تغييرها. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">تصميم مخطط وتوصيله بخادم GraphQL</font> </h2><br>  حتى الآن ، تحدثنا عن كيفية عمل GraphQL على العميل ، وكيفية تنفيذ الاستعلامات.  الآن دعونا نتحدث عن كيفية الاستجابة لهذه الطلبات. <br><br><h3 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">خادم raphGraphQL</font> </h3><br>  لتنفيذ استعلام GraphQL ، تحتاج إلى خادم GraphQL يمكنك إرسال هذا الاستعلام إليه.  خادم GraphQL هو خادم HTTP عادي (إذا كنت تكتب في جافا سكريبت ، فيمكن أن يكون خادمًا تم إنشاؤه باستخدام Express أو Hapi) ، مرفق به مخطط GraphQL. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">import express from 'express' import graphqlHTTP from 'express-graphql' import schema from './schema' const app = express() app.use('/graphql', graphqlHTTP({ schema: schema, graphiql: true })) app.listen(4000)</code> </pre> <br>  من خلال "الانضمام" إلى مخطط ما ، فإننا نعني آلية لتمرير الطلبات الواردة من العميل عبر المخطط وإرجاع الإجابات إليه.  يشبه مرشح الهواء الذي يدخل الهواء من خلاله الغرفة. <br><br>  ترتبط عملية "التصفية" بالطلبات أو الطفرات التي يرسلها العميل إلى الخادم.  يتم حل كل من الاستعلامات والطفرات باستخدام الدالات المتعلقة بالحقول المحددة في استعلام الجذر أو في طفرة الجذر في المخطط. <br><br>  ما سبق هو إطار عمل لخادم HTTP تم إنشاؤه باستخدام مكتبة Express JavaScript.  باستخدام وظيفة <code>graphqlHTTP</code> من <code>express-graphql</code> من Facebook ، "نرفق" المخطط (من المفترض أنه موصوف في ملف منفصل) <code>express-graphql</code> الخادم على المنفذ 4000. وهذا يعني أن العملاء الذين يتحدثون عن الاستخدام المحلي لهذا الخادم ، سيكونون قادرين على إرسال الطلبات عبر العنوان <code>http://localhost:4000/graphql</code> . <br><br><h3 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">types أنواع البيانات والمحللات</font> </h3><br>  لضمان تشغيل خادم GraphQL ، يلزمك إعداد المخطط وإرفاقه به. <br><br>  تذكر أننا تحدثنا عن الإعلان عن الحقول في استعلام الجذر أو في طفرة الجذر أعلاه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">import gql from 'graphql-tag' import mongodb from '/path/to/mongodb' //  -  . ,  `mongodb`     MongoDB. const schema = { typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     id: ID     name: String     description: String     nutrition: Nutrition   }   type Query {     flavors(id: ID): [Flavor]   }   type Mutation {     updateFlavor(id: ID!, name: String, description: String): Flavor   } `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {       // ,  args  ,  { id: '1' }       return mongodb.collection('flavors').find(args).toArray()     },   },   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(args)       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   },   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, }, } export default schema</code> </pre> <br>  يتكون تعريف الحقول في مخطط GraphQL من جزأين - من تعريفات النوع ( <code>typeDefs</code> ) <code>typeDefs</code> .  يحتوي <code>typeDefs</code> على تعريفات للبيانات المستخدمة في التطبيق.  على سبيل المثال ، تحدثنا سابقًا عن طلب للحصول على قائمة كائنات <code>flavor</code> من الخادم.  لتقديم طلب مماثل لخادمنا ، يلزمك تنفيذ الخطوات الثلاث التالية: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  أخبر المخطط كيف تبدو بيانات كائن <code>flavor</code> (في المثال أعلاه ، يبدو كإعلان من <code>type Flavor</code> ). </li><li style=";text-align:right;direction:rtl">  قم بتعريف الحقل في الحقل الجذر <code>type Query</code> (هذه هي خاصية <code>flavors</code> الخاصة بقيمة <code>type Query</code> ). </li><li style=";text-align:right;direction:rtl">  قم بتعريف دالة أداة التعرف على الكائنات في <code>type Query</code> <code>resolvers.Query</code> مكتوبة وفقًا للحقول المعلنة في مجال الجذر <code>type Query</code> . </li></ol><br>  الآن دعنا ننتبه إلى <code>typeDefs</code> .  هنا نقدم معلومات المخطط حول شكل بياناتنا.  بمعنى آخر ، فإننا نخبر GraphQL عن الخصائص المختلفة التي قد تكون موجودة في كيانات من النوع المقابل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">type Flavor { id: ID name: String description: String nutrition: Nutrition }</code> </pre> <br>  يشير إعلان <code>type Flavor</code> إلى أن كائن <code>flavor</code> قد يحتوي على حقل <code>id</code> النوع ، وحقل <code>name</code> النوع <code>String</code> ، وحقل <code>description</code> للنوع <code>String</code> وحقل <code>Nutrition</code> للنوع <code>Nutrition</code> . <br><br>  في حالة <code>nutrition</code> نستخدم هنا اسم نوع مختلف معلن في <code>typeDefs</code> .  هنا ، يصف بناء <code>type Nutrition</code> شكل البيانات الغذائية للفشار. <br><br>  انتبه إلى حقيقة أننا هنا ، كما في بداية هذه المادة ، نتحدث عن "تطبيق" وليس عن "قاعدة بيانات".  في المثال أعلاه ، من المفترض أن لدينا قاعدة بيانات ، لكن البيانات في التطبيق يمكن أن تأتي من أي مصدر.  يمكن أن يكون واجهة برمجة تطبيقات لجهة خارجية أو ملف ثابت. <br><br>  تمامًا كما فعلنا في إعلان <code>type Flavor</code> ، فإننا نحدد هنا أسماء الحقول التي سيتم تضمينها في كائنات <code>nutrition</code> ، باستخدام ما يسمى في GraphQL أنواع البيانات العددية ، باعتبارها أنواع بيانات لهذه الحقول (الخصائص).  في وقت كتابة هذا التقرير ، كان GraphQL يدعم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">5 أنواع من البيانات العددية المدمجة</a> : <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>Int</code> : وقع عدد صحيح 32 بت. </li><li style=";text-align:right;direction:rtl">  <code>Float</code> : رقم <code>Float</code> مزدوج الدقة مع علامة. </li><li style=";text-align:right;direction:rtl">  <code>String</code> : سلسلة من الأحرف المشفرة في UTF-8. </li><li style=";text-align:right;direction:rtl">  <code>Boolean</code> : منطقية <code>true</code> أو <code>false</code> . </li><li style=";text-align:right;direction:rtl">  <code>ID</code> : <code>ID</code> فريد يستخدم غالبًا لتحميل الكائنات أو كمفتاح في ذاكرة التخزين المؤقت.  <code>ID</code> تسلسل لقيم <code>ID</code> النوع بالطريقة نفسها التي يتم بها استخدام السلاسل ، ومع ذلك ، يتم التأكيد على الإشارة إلى أن نوع <code>ID</code> له قيمة من خلال حقيقة أن هذه القيمة لا تهدف إلى إظهارها للناس ، ولكن للاستخدام في البرامج. </li></ul><br>  بالإضافة إلى هذه الأنواع العددية ، يمكننا أيضًا تعيين خصائص لأنواع نعرّفها بأنفسنا.  هذا هو بالضبط ما قمنا به من خلال تعيين خاصية <code>nutrition</code> الموصوفة في <code>type Flavor</code> ، نوع <code>Nutrition</code> build. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">type Query { flavors(id: ID): [Flavor] }</code> </pre> <br>  في بناء <code>type Query</code> ، الذي يصف نوع الجذر الخاص بالاستعلام ("استعلام الجذر" الذي تحدثنا عنه سابقًا) ، نعلن اسم الحقل الذي يمكن طلبه.  بإعلان هذا الحقل ، نقوم بالإضافة إلى نوع البيانات التي نتوقع إرجاعها ، بتحديد الوسائط التي قد تأتي في الطلب. <br><br>  في هذا المثال ، نتوقع استلامًا محتملًا للوسيطة <code>id</code> نوع العدد.  استجابة لمثل هذا الطلب ، من المتوقع ظهور مجموعة من الكائنات التي يشبه الجهاز جهاز من نوع <code>Flavor</code> . <br><br><h3 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">izer توصيل أداة التعرف على الاستعلام</font> </h3><br> ,    <code>type Query</code>    <code>field</code> ,    ,   -. <br><br>  —  ,  GraphQL,   , «».      <code>resolvers</code> ,     <code>Query</code> ,   ,      <code>flavors</code> ,   .        <code>flavors</code> ,     <code>type Query</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">typeDefs: gql`…`, resolvers: { Query: {   flavors: (parent, args) =&gt; {     // ,  args    { id: '1' }     return mongodb.collection('flavors').find(args).toArray()   }, }, … },</code> </pre> <br>  -   .  <code>parent</code> —   ,   ,  <code>args</code>      ,   .      <code>context</code> ,      .       «»  ( —        ,       ). <br><br>     ,    ,   .   GraphQL « »          . , ,      . <br><br>  GraphQL      ,      ,    .    JSON-,  JSON-,  (  GraphQL   ). <br><br>    -   <code>flavors</code>   MongoDB,  <code>args</code> (    )   <code>.find()</code>   ,        ,   . <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍    </font> </h3><br>     -,   GraphQL,  , ,   ,      <code>nutrition</code> .   ,  ,   <code>Nutrition</code> , ,   ,      ,   <code>flavor</code> .      ,       /  . <br><br>    GraphQL  ,  <code>type Flavor</code>      <code>nutrition</code>   <code>type Nutrition</code> ,          .  ,    ,      <code>flavor</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">typeDefs: gql`   type Nutrition {     flavorId: ID     calories: Int     fat: Int     sodium: Int   }   type Flavor {     […]     nutrition: Nutrition   }   type Query {…}   type Mutation {…} `, resolvers: {   Query: {     flavors: (parent, args) =&gt; {…},   },   Mutation: {…},   Flavor: {     nutrition: (parent) =&gt; {       return mongodb.collection('nutrition').findOne({         flavorId: parent.id,       })     }   }, },</code> </pre> <br>      <code>resolvers</code>  ,   ,      <code>Query</code> , <code>Mutation</code>  <code>Flavor</code> .   ,      <code>typeDefs</code> . <br><br>     <code>Flavors</code> ,  ,   <code>nutrition</code>     -.       ,        <code>Flavor</code> .  ,   : « ,     <code>nutrition</code>     ,  <code>type Flavor</code> ». <br><br>         MongoDB,      ,     <code>parent</code> ,  -. ,     <code>parent</code> ,   ,    ,   <code>flavors</code> . ,      <code>flavor</code> ,    : <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ flavors {   id   name   nutrition {     calories   } } }</code> </pre> <br>   <code>flavor</code> ,   <code>flavors</code> ,     <code>nutrition</code> ,        <code>parent</code> .     ,  ,  ,    MongoDB,   <code>parent.id</code> ,    <code>id</code>  <code>flavor</code> ,       . <br><br>  <code>parent.id</code>      ,     <code>nutrition</code>   <code>flavorId</code> ,     <code>flavor</code> . <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍ </font> </h3><br> ,      ,     .   ,          .      <code>type Mutation</code> ,   ,       <code>updateFlavor</code> ,  ,   . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">type Mutation { updateFlavor(id: ID!, name: String, description: String): Flavor }</code> </pre> <br>     : « ,   <code>updateFlavor</code>  <code>id</code>  <code>ID</code> ( , <code>!</code> ,  GraphQL  ,    ), <code>name</code>  <code>String</code>  <code>description</code>  <code>String</code> ».  ,         ,     <code>Flavor</code> (  — ,    <code>id</code> , <code>name</code> , <code>description</code> , , , <code>nutrition</code> ). <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">{ typeDefs: gql`…`, resolvers: {   Mutation: {     updateFlavor: (parent, args) =&gt; {       // ,  args    { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }       //  .       mongodb.collection('flavors').update(         { id: args.id },         {           $set: {             ...args,           },         },       )       //  flavor  .       return mongodb.collection('flavors').findOne(args.id)     },   }, }, }</code> </pre> <br>  -   <code>updateFlavor</code>    ,      :       ,    ,   — ,      <code>flavor</code> . <br><br>    ,               ,       <code>flavor</code>     .   ? <br><br>   ,          ,        .     ,     <code>flavor</code> ,     . <br><br>      <code>args</code> ? , . ,          ,   ,      100%   ,         .       ,    ,  ,     ,      ,    . <br><br><h2 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">    GraphQL?</font> </h2><br>  ,      ,    ,     ,   , GraphQL-API. <br><br>        ,     GraphQL      ,      .  ,         .        ,    .  , ,   ,   GraphQL      REST      .  ,   ,           ,     GraphQL. <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍    ,   </font> </h3><br>     ,       HTTP-,  ,      ,   ,   —  .       GraphQL       ,  ,    ,     ,     (            ). <br><br>        ,  ,     ( —         ),  GraphQL      . <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍    ,    ,       </font> </h3><br>  ,       ,    « ».      , ,   ,   .        .   GraphQL         . <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍     ,       </font> </h3><br>          REST API,          :  ,    . ,      -,   iOS  Android,   API  .    ,  , ,   , «   »    . <br><br>    ,   ,   ,   HTTP,              API (, ,   ). <br><br><h3 style=";text-align:right;direction:rtl"> <font color="#3AC1EF">▍   GraphQL —   ?        REST API    GraphQL?</font> </h3><br> , .   . ,  ,   GraphQL     .       GraphQL,     .       ,      ,      ,           .     ,      ,     . <br><br> ,  GraphQL  ,  ,      ,  .    GraphQL    ,      Apollo  Relay,       . <br><br> GraphQL — ,  ,   .   <code>graphql</code> (     <code>express-graphql</code> ,    ) —      .  ,   GraphQL      -  .      ,     -,   ,  ,     ,    . <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">النتائج</font> </h2><br>   ,   GraphQL    ,           . GraphQL      ,    , ,  .  , ,       ,        ,       GraphQL. <br><br> ,       : GraphQL   .              GraphQL  . ,     GraphQL,      ,  , ,  ,  ,  ,  . <br><br>  —   ,  GraphQL — ,   ,   .  GraphQL       ,   .    ,  GraphQL —  ,  , ,  .           .  ,       ,      ,   ,     ,      ,      GraphQL. <br><br>  <b>أعزائي القراء!</b>        GraphQL —     ,         . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar445268/">https://habr.com/ru/post/ar445268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar445258/index.html">كيفية حذف بياناتك بأمان من هاتفك الذكي بنظام Android قبل بيعها</a></li>
<li><a href="../ar445260/index.html">هل ستتعرف الروبوتات على نفسها حقًا؟ يتحرك العلماء في هذا الاتجاه.</a></li>
<li><a href="../ar445262/index.html">GeekUniversity يفتح التوظيف في قسم البيانات الضخمة في التحليلات</a></li>
<li><a href="../ar445264/index.html">التحميل المسبق ، الجلب المسبق والعلامات الأخرى</a></li>
<li><a href="../ar445266/index.html">سوف GeekBrains جنبا إلى جنب مع Rostelecom إجراء إنترنت الأشياء هاكاثون</a></li>
<li><a href="../ar445270/index.html">[إشارة مرجعية] باش للمبتدئين: 21 أمر مفيد</a></li>
<li><a href="../ar445272/index.html">JavaScript هي أفضل لغة برمجة للمبتدئين. هل هو أم لا؟</a></li>
<li><a href="../ar445274/index.html">عندما يكون "Zoë"! == "Zoë" ، أو لماذا تحتاج إلى تطبيع سلاسل Unicode</a></li>
<li><a href="../ar445276/index.html">دليل UseEffect الكامل</a></li>
<li><a href="../ar445278/index.html">كيفية إنشاء لعبة إذا لم تكن فنانًا أبدًا</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>