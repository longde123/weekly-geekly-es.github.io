<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙄 💃🏽 👩🏽 Leitfaden zur automatischen Prüfung intelligenter Verträge. Teil 1: Vorbereitung auf ein Audit 👩‍🍳 👨🏼‍🏫 🍨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Unser Unternehmen befasst sich mit der Sicherheitsüberprüfung intelligenter Verträge, und das Problem der Verwendung automatisierter To...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leitfaden zur automatischen Prüfung intelligenter Verträge. Teil 1: Vorbereitung auf ein Audit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438336/"><h2 id="vvedenie">  Einführung </h2><br><p>  Unser Unternehmen befasst sich mit der Sicherheitsüberprüfung intelligenter Verträge, und das Problem der Verwendung automatisierter Tools ist sehr akut.  Wie viel können sie helfen, verdächtige Orte zu identifizieren, welche sollten verwendet werden, was können sie tun und was sind die Besonderheiten der Arbeit in diesem Bereich?  Diese und verwandte Themen sind Gegenstand dieses Artikels.  Und das Material wird Versuche sein, mit Hilfe der interessantesten Vertreter und Rezepte für die Einführung dieser äußerst bunten und äußerst interessanten Software mit echten Verträgen zu arbeiten.  Zuerst wollte ich einen Artikel machen, aber nach einiger Zeit wurde die Informationsmenge zu groß, und so wurde beschlossen, eine Reihe von Artikeln zu erstellen, einen für jeden Autoanalysator.  Die Liste, aus der wir die Werkzeuge entnehmen, wird zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier vorgestellt</a> . Wenn jedoch beim Schreiben andere interessante Werkzeuge auftauchen, werde ich sie gerne beschreiben und testen. </p><a name="habracut"></a><br><p> Ich muss sagen, dass die Prüfungsaufgaben äußerst interessant waren, weil  Bisher haben Entwickler den wirtschaftlichen Aspekten von Algorithmen und der internen Optimierung nicht viel Aufmerksamkeit geschenkt.  Bei der Prüfung intelligenter Verträge wurden mehrere interessante Angriffsmethoden hinzugefügt, die bei der Suche nach Fehlern berücksichtigt werden müssen.  Wie sich herausstellte, erschienen auch viele Tools für automatische Tests: statische Analysatoren, Bytecode-Analysatoren, Fuzzers, Parser und viele andere gute Software. </p><br><p>  Der Zweck des Artikels: die Verbreitung von sicherem Vertragscode zu fördern und Entwicklern zu ermöglichen, dumme Fehler, die oft am ärgerlichsten sind, schnell und einfach zu beseitigen.  Wenn das Protokoll selbst absolut zuverlässig ist und ein ernstes Problem löst, kann das Vorhandensein eines dummen Fehlers, der in der Testphase vergessen wurde, die Lebensdauer des Projekts ernsthaft ruinieren.  Lassen Sie uns daher lernen, mindestens Werkzeuge zu verwenden, mit denen „wenig Blut“ bekannte Probleme beseitigen kann. </p><br><p>  Mit Blick auf die Zukunft muss ich sagen, dass die häufigsten kritischen Fehler, auf die wir bei Audits gestoßen sind, immer noch logische Implementierungsprobleme sind und keine typischen Schwachstellen wie Zugriffsrechte, ganzzahliger Überlauf oder Wiedereintritt.  Eine umfassende Prüfung von Lösungen ist ohne erfahrene Entwickler nicht möglich, die in der Lage sind, die Logik von Verträgen auf hoher Ebene, ihren Lebenszyklus, Aspekte des tatsächlichen Betriebs und der Einhaltung der Aufgabe sowie nicht nur typische Angriffsmuster zu prüfen.  Es ist eine Logik auf hoher Ebene, die häufig zu kritischen Fehlern führt. </p><br><p>  Aber Warnungen, typische Löcher und Fehler, die aus Unachtsamkeit herausgelassen wurden und nicht übersehen werden sollten, sind das Schicksal automatischer Analysegeräte. Sie sollten diese Aufgaben besser bewältigen als Menschen.  Es ist diese These, die getestet wird. </p><br><h2 id="osobennosti-audita-koda-smart-kontraktov">  Merkmale der intelligenten Prüfung des Vertragscodes </h2><br><p>  Die intelligente Prüfung von Vertragscodes ist ein eher spezifischer Bereich.  Trotz seiner geringen Größe ist der Ethereum Smart Contract ein vollwertiges Programm, das komplexe Zweige, Schleifen und Entscheidungsbäume organisieren und sogar scheinbar einfache Transaktionen automatisieren kann, bei denen bei jedem Schritt alle möglichen Zweige durchdacht werden müssen.  Unter diesem Gesichtspunkt ist die Blockchain-Entwicklung äußerst einfach, sehr ressourcenintensiv und erinnert stark an die Entwicklung von System- und eingebetteter Software in C / C ++ - und Assembler-Sprachen.  Aus diesem Grund freuen wir uns, in Interviews die Entwickler von Low-Level-Algorithmen, den Netzwerkstapel, hoch ausgelastete Dienste und alle zu sehen, die sich mit Low-Level-Optimierung und Code-Auditing befasst haben. </p><br><p>  Aus Sicht des Entwicklers ist Solidity auch ziemlich spezifisch, obwohl es von fast jedem Programmierer und in den ersten Schritten leicht zu lesen ist und äußerst einfach erscheint.  Solidity-Code ist ziemlich einfach zu lesen und jedem Entwickler bekannt, der sich mit C / C ++ - Syntax und OOP wie JavaScript auskennt. </p><br><p>  Hier ist die Einfachheit des Codes der Schlüssel zum Überleben, nichts Schweres funktioniert, daher wird das gesamte Arsenal der Entwicklung auf niedriger Ebene in der Arbeit verwendet - Algorithmen, die eine effiziente Nutzung von Ressourcen ermöglichen, Speicherplatz sparen: Merkle-Bäume, Bloom-Filter, „faules“ Laden von Ressourcen, Abrollen von Schleifen, manuelle Speicherbereinigung und vieles mehr. <br>  Eine kleine Menge Quellcode und daraus resultierenden Bytecode. </p><br><p>  Ein separater Smart-Vertrag ist in Bezug auf das Bytecode-Volumen begrenzt, jedes Byte kostet eine bestimmte Menge Gas und das Maximum ist von oben begrenzt, sodass Sie (im Moment) etwa 10 KB in die Blockchain schieben können. Es funktioniert nicht mehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein guter Artikel darüber, wie viel ein Vertrag kostet und wie viel Gas kostet</a> .  Daher kann nicht viel geschoben werden.  Wenn Sie übertreiben, sind mehrere tausend Zeilen „durchschnittlicher“ Code das Maximum.  Mehrere Dutzend Methoden, die fehlende Aggregation und die allgemein komplexe Logik sind äußerst charakteristisch für Verträge.  Für alles, was nicht passt, müssen Sie den Code in separaten Bibliotheken auswählen, um das Verfahren zum Hochladen in das Netzwerk zu ändern und zu verkomplizieren.  Solidity-Entwickler können gerne eine Menge Code in einen Vertrag einbinden, müssen jedoch einfach ihre Vertragssysteme korrekt anordnen, indem sie separate Klassenbibliotheken mit eigenem Speicher erstellen.  Und es ist praktisch, solche separaten "Klassen" in separate Dateien zu zerlegen. Daher ist das Lesen des Code der Verträge ziemlich gut, alles ist von Anfang an gut strukturiert - sonst funktioniert es einfach nicht.  Als Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empfehle</a> ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, sich anzusehen, wie ERC721 in Openzeppelin-Solidität hergestellt wird</a> . </p><br><h3 id="gaz-gaz-gaz">  Gas, Gas, Gas </h3><br><p>  Gas führt eine zusätzliche Logikschicht in die Ausführung des Vertragscodes ein, die eine Prüfung erfordert.  Darüber hinaus kann im Gegensatz zum herkömmlichen Code derselbe Codeabschnitt unterschiedliche Gasmengen verbrauchen.  Eine Tabelle mit EVM-Opcodes und ihren Kosten ist hilfreich, um die Gasbeschränkungen zu verstehen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist sie</a> . </p><br><p>  Um zu demonstrieren, warum Sie viel Zeit für die Bewertung von Gas aufwenden müssen, betrachten Sie diesen Pseudocode (natürlich unrealistisch; es ist eine schlechte Idee, in der Schleife mit Äther zu feuern): </p><br><pre><code class="plaintext hljs">//          function fixSomeAccountAction(uint _actionId) public onlyValidator { // … events[msg.sender].push(_actionId); } //   ,           function receivePaymentForSavedActions() { // ... for (uint256 i = 0; i &lt; events[msg.sender].length; i++) { //  actionId   uint actionId = events[msg.sender][i]; //      action uint payment = getPriceByEventId(actionId); if (payment &gt; 0) { paymentAccumulators[msg.sender] += payment; } emit LogEventPaymentForAction(msg.sender, actionId, payment); // … // delete “events[msg.sender][i]” from array } }</code> </pre> <br><p>  Tatsache ist, dass der Zyklus im Vertrag Ereignisse [msg.sender] .length mal ausgeführt wird und jede Iteration ein Eintrag in der Blockchain ist (transfer () und emit ()).  Wenn die Länge des Arrays klein ist, erfüllt der Zyklus sein Zehnfaches und verteilt die Zahlung für jede Aktion.  Wenn das Ereignis-Array [msg.sender] jedoch groß ist, gibt es viele Iterationen und das verbrauchte Gas läuft in die fest codierte maximale Gasgrenze (~ 8.000.000).  Die Transaktion wird abgebrochen und funktioniert jetzt nie mehr, da es keine Möglichkeit gibt, die Länge des Ereignis-Arrays [msg.sender] im Vertrag zu verringern.  Wenn der Zyklus nicht nur einen Einheitswert berechnet, sondern in die Blockchain schreibt (z. B. werden einige Gebühren gezahlt, Zahlungen für Aktionen), ist die zulässige Anzahl von Iterationen erheblich begrenzt.  Überzeugen Sie sich selbst - Limit: 8.000.000, Aufzeichnung eines neuen 256-Bit-Werts: 20.000.  Sie können Metadaten nur für ein paar Hundert von 256-Bit-Adressen mit einigen Metadaten speichern oder aktualisieren. Ein weiterer unterhaltsamer Teil ist das Schreiben eines neuen Werts: 20.000 und eines Updates eines vorhandenen Werts: 5.000, also auch mit genau der gleichen Umgebung Ihres Vertrags, wenn Sie eine Übertragung durchführen Token an eine Adresse, die bereits Token enthält, geben Sie viermal weniger Benzin (5.000 gegenüber 20.000) für einen Datensatz aus. </p><br><p>  Seien Sie daher nicht überrascht, dass das Thema Gas in intelligenten Verträgen so eng mit der Sicherheit von Verträgen zusammenhängt, da sich die Situation, in der Gelder aus praktischer Sicht dauerhaft im Vertrag stecken, kaum von der Situation unterscheidet, in der sie gestohlen wurden.  Die Tatsache, dass der ADD-Befehl 3 Gas und SSTORE (Einsparung in den Speicher) kostet: 20 000, bedeutet, dass die teuerste Ressource in der Blockchain die Speicherung ist, und die Aufgaben der Optimierung des Vertragscodes haben viel mit den Aufgaben der Entwicklung auf niedriger Ebene in C und ASM für Embedded gemeinsam Systeme, bei denen Speicher ebenfalls eine sehr begrenzte Ressource ist. </p><br><h3 id="prekrasnyy-blokcheyn">  Schöne Blockchain </h3><br><p>  Dies ist ein sehr positiver Absatz darüber, warum die Blockchain aus Sicherheitsgründen nur für den Prüfer so gut ist.  Der Determinismus der Ausführung des Vertragscodes ist der Schlüssel zum erfolgreichen Debuggen und Wiedergeben von Fehlern und Schwachstellen.  Technisch gesehen kann jeder Aufruf des Vertragscodes auf jeder Plattform mit einer gewissen Genauigkeit reproduziert werden. Dadurch können die Tests überall ausgeführt werden und sind äußerst einfach zu unterstützen. Die Untersuchung von Vorfällen ist zuverlässig und unbestreitbar.  Jetzt wissen wir immer, wer wann welche Funktion aufgerufen wurde, mit welchen Parametern, welcher Code sie verarbeitete und was das Ergebnis war.  All dies ist vollständig bestimmt, d.h.  spielt überall, auch in JS auf einer Webseite.  Wenn wir über Ethereum sprechen, ist jeder Testfall extrem einfach in praktischem JavaScript zu schreiben, einschließlich Fuzzing-Parametern, und funktioniert überall dort, wo es Node.js gibt. </p><br><p>  All diese schönen Wörter sollten die Entwickler jedoch nicht entspannen, da, wie oben erwähnt, die schwerwiegendsten Fehler logisch sind und für sie der Determinismus der Ausführung eine orthogonale Eigenschaft ist. </p><br><h2 id="okruzhenie-dlya-sborki-kontrakta">  Die Umgebung für die Montage des Vertrages </h2><br><p>  Um den Artikel zu schreiben, habe ich einen alten experimentellen Vertrag für die Buchung eines Hauses vom Smartz-Designer abgeschlossen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/smartzplatform/constructor-eth-booking</a> .  Mit dem Vertrag können Sie eine Aufzeichnung des Objekts (Apartment oder Hotelzimmer) erstellen, den Preis und die Liefertermine festlegen. Danach wartet der Vertrag auf die Zahlung und legt bei Erhalt den Buchungsvorgang fest, wobei das Guthaben auf dem Restbetrag verbleibt, bis der Gast das Zimmer betritt und wird die Eingabe nicht bestätigen.  Zu diesem Zeitpunkt erhält der Eigentümer des Zimmers die Zahlung.  Der Vertrag ist im Wesentlichen eine Zustandsmaschine, deren Zustände und Übergänge in Booking.sol eingesehen werden können.  Wir haben es ziemlich schnell gemacht, es während des Entwicklungsprozesses geändert und es nicht geschafft, eine große Anzahl von Tests durchzuführen. Es ist weit entfernt von einer neuen Version des Compilers und mehr oder weniger umfangreicher interner Logik.  Schauen wir uns also an, wie die Analysatoren damit umgehen, welche Fehler sie finden, und fügen wir bei Bedarf unsere eigenen hinzu. </p><br><h3 id="rabota-s-raznymi-versiyami-solc">  Arbeiten Sie mit verschiedenen Versionen von solc </h3><br><p>  Verschiedene Analysatoren müssen auf unterschiedliche Weise verwendet werden - einige werden vom Docker aus gestartet, andere verwenden vorgefertigten kompilierten Bytecode, und der Prüfer selbst muss sich nicht mit einem Paar befassen, sondern mit Dutzenden früher Verträge mit verschiedenen Versionen des Compilers.  Daher müssen Sie in der Lage sein, verschiedene Versionen von <code>solc</code> sowohl im Host-System als auch im Docker-Image und im Trüffel unterschiedlich zu " <code>solc</code> ", damit ich Ihnen diese wenigen schmutzigen Hack-Optionen geben kann: </p><br><p>  1 Weg: Innentrüffel </p><br><p>  Dafür werden keine Tricks benötigt, weil  Ab Trüffelversion 5.0.0 können Sie die Compilerversion wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Diff</a> direkt in truffle.js angeben. </p><br><p>  Jetzt lädt truffle den erforderlichen Compiler herunter und führt ihn aus.  Vielen Dank an das Team dafür, Solidity ist eine junge Sprache, es gibt gravierende Änderungen in der Sprache und der Wechsel von Version zu Version für den Auditor ist inakzeptabel. Auf diese Weise können Sie neue Fehler einführen und alte maskieren. </p><br><p>  Methode 2: Ersetzen von / usr / bin / solc im Docker-Container des Analysators <br>  Wenn der Analysator in Form einer Docker-Datei verteilt ist, können Sie ihn beim Zusammenstellen eines Docker-Images ersetzen, indem Sie der Docker-Datei eine Zeile hinzufügen, die die gewünschte Version <code>solc</code> direkt aus dem Image erhält, die sie aus dem Netzwerk abruft und / usr / bin / solc ersetzt: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.19 /usr/bin/solc /usr/bin</code> </pre> <br><p>  3 Wege: Ersetzen von / usr / bin / solc </p><br><p>  Der schmutzigste Weg in der Stirn, wenn es überhaupt keinen Ausweg gibt, können Sie die Binärdatei / usr / bin / solc durch ein Skript wie dieses ersetzen (vergessen Sie nicht, die Originaldatei zu speichern): </p><br><pre> <code class="plaintext hljs">#!/bin/bash # run Solidity compiler of given version, pass all parameters # you can run “SOLC_DOCKER_VERSION=0.4.20 solc --version” SOLC_DOCKER_VERSION="${SOLC_DOCKER_VERSION:-0.4.24}" docker run \ --entrypoint "" \ --tmpfs /tmp \ -v $(pwd):/project \ -v $(pwd)/node_modules:/project/node_modules \ -w /project \ ethereum/solc:$SOLC_DOCKER_VERSION \ /usr/bin/solc \ "$@"</code> </pre> <br><p>  Es lädt das Docker-Image mit der richtigen Version von <code>solc</code> herunter und <code>solc</code> , wechselt in das aktuelle Verzeichnis und führt <code>/usr/bin/solc</code> mit den übergebenen Parametern aus.  Kein sehr guter Weg, aber vielleicht passt er für einige Aufgaben zu Ihnen. </p><br><h3 id="flattening-code">  Code reduzieren </h3><br><p>  Lassen Sie uns nun die Quelle herausfinden.  Theoretisch sollten Autoanalysatoren (insbesondere für die Analyse statischer Quellen) theoretisch einen Vertrag sammeln, alle Abhängigkeiten aufrufen, alles zu einem Monolithen kombinieren und analysieren.  Aber wie ich bereits sagte, können Änderungen von Version zu Version schwerwiegend sein, und ich bin ständig auf die Notwendigkeit gestoßen, ein zusätzliches Verzeichnis in das Docker zu legen, es innerhalb des Pfads zu konfigurieren und all dies, damit die erforderlichen Importe korrekt abgerufen werden.  Einige Analysatoren verstehen alles, der zweite ist daher keine universelle Option. Um nicht unter dem Verwerfen zusätzlicher Verzeichnisse zu leiden, ist es für Analysatoren, die eine einzelne Datei essen, bequemer, alles in einer Datei zusammenzuführen und nur zu analysieren. </p><br><p>  Verwenden Sie dazu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalen Trüffelabflacher</a> . </p><br><p>  Dies ist ein Standard-npm-Modul, es wird sehr einfach verwendet: </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/trailofbits/slither</a> <br>  Wenn Sie das Reduzieren irgendwie anpassen müssen, können Sie beispielsweise Ihr eigenes Reduzieren schreiben, bevor wir die Python-basierte Option verwendet haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mixbytes/solidity-flattener</a> </p><br><h2 id="nachnem-analiz">  Beginnen wir mit der Analyse. </h2><br><p>  Am Beispiel desselben alten Mannes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/smartzplatform/constructor-eth-booking setzen wir</a> die Analyse fort.  Der Vertrag gibt die alte Version des Compilers "0.4.20" an, und ich habe absichtlich den alten Vertrag verwendet, um Probleme mit dem Compiler zu lösen.  Die Situation wird durch die Tatsache verschlimmert, dass ein Autoanalysator, der beispielsweise Bytecode studiert, von dieser Version von solc abhängen kann, und hier können Unterschiede in den Versionen die Ergebnisse stark beeinflussen oder sogar alles kaputt machen.  Selbst wenn Sie mit den neuesten Versionen alles koscher machen, können Sie dennoch auf einen Analysator stoßen, der auf die vorherige Version des Compilers abgestimmt wurde. <br>  Tests kompilieren und ausführen </p><br><p>  Um zu beginnen, ziehen Sie einfach das Projekt aus dem Github und versuchen Sie es zu kompilieren .: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/smartzplatform/constructor-eth-booking.git cd constructor-eth-booking npm install truffle compile</code> </pre> <br><p>  Sicher haben Sie Probleme mit der Compiler-Version.  Auch Autoanalysatoren haben diese Probleme. Verwenden Sie daher alle Mittel, um den 0.4.20-Compiler abzurufen und das Projekt zu erstellen.  Ich habe gerade die erforderliche Version des Compilers in truffle.js registriert und alles wurde wie oben beschrieben zusammengestellt. </p><br><p>  Auch laufen </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  Wie im Abschnitt über das Abflachen angegeben, handelt es sich um <code>contracts/flattened.sol</code> Abflachen. <code>contracts/flattened.sol</code> wir zur Analyse an verschiedene Analysegeräte weitergeben <br>  Fazit zur Einleitung </p><br><p>  Nachdem Sie nun abgeflacht haben und <code>solc</code> einer beliebigen Version verwenden können, können Sie mit der Analyse beginnen.  Ich werde die Probleme beim Ausführen von Trüffeln und Tests weglassen. Es gibt eine Menge Dokumentation zu diesem Thema. Verstehen Sie es selbst.  Natürlich müssen die Tests erfolgreich ausgeführt werden.  Um die Logik zu überprüfen, muss der Prüfer häufig seine eigenen Tests hinzufügen, potenziell undichte Stellen überprüfen, z. B. die Vertragsfunktionalität an den Grenzen von Arrays überprüfen, alle Variablen mit Tests abdecken, auch diejenigen, die ausschließlich zur Datenspeicherung bestimmt sind usw.  Es gibt viele Empfehlungen, außerdem ist dies nur das Produkt, das unser Unternehmen auf den Markt bringt. Das Studium der Logik ist also eine rein menschliche Aufgabe. </p><br><p>  Wir werden Analysatoren durchgehen, die aus unserer Sicht interessant sind, versuchen, unseren Vertrag in sie zu integrieren, und wir werden Schwachstellen künstlich einführen, um zu bewerten, wie die automatischen Analysatoren auf sie reagieren werden.  Der nächste Artikel ist dem Slither-Analysator gewidmet, und im Allgemeinen sieht der Aktionsplan ungefähr wie folgt aus: </p><br><p>  Teil 1. Einführung.  Zusammenstellung, Abflachung, Versionen von Solidity (dieser Artikel) <br>  Teil 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slither</a> <br>  Teil 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mithril</a> <br>  Teil 4. Mantikor <br>  Teil 5. Echidna <br>  Teil 6. Unbekanntes Werkzeug 1 <br>  Teil 7. Unbekanntes Werkzeug 2 </p><br><p>  Dieser Satz von Analysatoren wurde erhalten, weil es für den Prüfer wichtig ist, verschiedene Arten von Analysen verwenden zu können - statische und dynamische, und sie erfordern völlig unterschiedliche Ansätze.  Unsere Aufgabe ist es zu lernen, wie man die grundlegenden Werkzeuge in jeder Art von Analyse verwendet und welche man wann verwendet. </p><br><p>  Möglicherweise erscheinen im Verlauf einer detaillierten Studie neue Kandidaten zur Prüfung, oder die Reihenfolge der Artikel ändert sich. Bleiben Sie also auf dem Laufenden.  Um zum nächsten Teil zu gelangen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klicken Sie hier.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438336/">https://habr.com/ru/post/de438336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438326/index.html">5G in Russland: Warum wird es benötigt, wie viel kostet es und wann wird es erscheinen? Kurz zur Hauptsache</a></li>
<li><a href="../de438328/index.html">Wie hoch ist die Gehaltsblase für Programmierer?</a></li>
<li><a href="../de438330/index.html">Adams State University. Wie man Websites hackt. Teil 1</a></li>
<li><a href="../de438332/index.html">Adams State University. Wie man Websites hackt. Teil 2</a></li>
<li><a href="../de438334/index.html">Übergang zu 3D: Der Einfluss von Chiparchitektur und Aufzeichnungsalgorithmen auf die Lebensdauer von SSDs</a></li>
<li><a href="../de438338/index.html">Leitfaden zur automatischen Prüfung intelligenter Verträge. Teil 2: Rutschen</a></li>
<li><a href="../de438340/index.html">Medien: iCloud hat möglicherweise ein Datenleck, das Apple zu verbergen versuchte</a></li>
<li><a href="../de438342/index.html">Warum betrügt freundliche KI in Ghost Recon Wildlands</a></li>
<li><a href="../de438346/index.html">Wie machen sie das? Übersicht über Kryptowährungs-Anonymisierungstechnologien</a></li>
<li><a href="../de438348/index.html">Wie man lernt, mit 9 Jahren selbständig zu programmieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>