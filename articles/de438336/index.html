<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÑ üíÉüèΩ üë©üèΩ Leitfaden zur automatischen Pr√ºfung intelligenter Vertr√§ge. Teil 1: Vorbereitung auf ein Audit üë©‚Äçüç≥ üë®üèº‚Äçüè´ üç®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Unser Unternehmen befasst sich mit der Sicherheits√ºberpr√ºfung intelligenter Vertr√§ge, und das Problem der Verwendung automatisierter To...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leitfaden zur automatischen Pr√ºfung intelligenter Vertr√§ge. Teil 1: Vorbereitung auf ein Audit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438336/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Unser Unternehmen befasst sich mit der Sicherheits√ºberpr√ºfung intelligenter Vertr√§ge, und das Problem der Verwendung automatisierter Tools ist sehr akut.  Wie viel k√∂nnen sie helfen, verd√§chtige Orte zu identifizieren, welche sollten verwendet werden, was k√∂nnen sie tun und was sind die Besonderheiten der Arbeit in diesem Bereich?  Diese und verwandte Themen sind Gegenstand dieses Artikels.  Und das Material wird Versuche sein, mit Hilfe der interessantesten Vertreter und Rezepte f√ºr die Einf√ºhrung dieser √§u√üerst bunten und √§u√üerst interessanten Software mit echten Vertr√§gen zu arbeiten.  Zuerst wollte ich einen Artikel machen, aber nach einiger Zeit wurde die Informationsmenge zu gro√ü, und so wurde beschlossen, eine Reihe von Artikeln zu erstellen, einen f√ºr jeden Autoanalysator.  Die Liste, aus der wir die Werkzeuge entnehmen, wird zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier vorgestellt</a> . Wenn jedoch beim Schreiben andere interessante Werkzeuge auftauchen, werde ich sie gerne beschreiben und testen. </p><a name="habracut"></a><br><p> Ich muss sagen, dass die Pr√ºfungsaufgaben √§u√üerst interessant waren, weil  Bisher haben Entwickler den wirtschaftlichen Aspekten von Algorithmen und der internen Optimierung nicht viel Aufmerksamkeit geschenkt.  Bei der Pr√ºfung intelligenter Vertr√§ge wurden mehrere interessante Angriffsmethoden hinzugef√ºgt, die bei der Suche nach Fehlern ber√ºcksichtigt werden m√ºssen.  Wie sich herausstellte, erschienen auch viele Tools f√ºr automatische Tests: statische Analysatoren, Bytecode-Analysatoren, Fuzzers, Parser und viele andere gute Software. </p><br><p>  Der Zweck des Artikels: die Verbreitung von sicherem Vertragscode zu f√∂rdern und Entwicklern zu erm√∂glichen, dumme Fehler, die oft am √§rgerlichsten sind, schnell und einfach zu beseitigen.  Wenn das Protokoll selbst absolut zuverl√§ssig ist und ein ernstes Problem l√∂st, kann das Vorhandensein eines dummen Fehlers, der in der Testphase vergessen wurde, die Lebensdauer des Projekts ernsthaft ruinieren.  Lassen Sie uns daher lernen, mindestens Werkzeuge zu verwenden, mit denen ‚Äûwenig Blut‚Äú bekannte Probleme beseitigen kann. </p><br><p>  Mit Blick auf die Zukunft muss ich sagen, dass die h√§ufigsten kritischen Fehler, auf die wir bei Audits gesto√üen sind, immer noch logische Implementierungsprobleme sind und keine typischen Schwachstellen wie Zugriffsrechte, ganzzahliger √úberlauf oder Wiedereintritt.  Eine umfassende Pr√ºfung von L√∂sungen ist ohne erfahrene Entwickler nicht m√∂glich, die in der Lage sind, die Logik von Vertr√§gen auf hoher Ebene, ihren Lebenszyklus, Aspekte des tats√§chlichen Betriebs und der Einhaltung der Aufgabe sowie nicht nur typische Angriffsmuster zu pr√ºfen.  Es ist eine Logik auf hoher Ebene, die h√§ufig zu kritischen Fehlern f√ºhrt. </p><br><p>  Aber Warnungen, typische L√∂cher und Fehler, die aus Unachtsamkeit herausgelassen wurden und nicht √ºbersehen werden sollten, sind das Schicksal automatischer Analyseger√§te. Sie sollten diese Aufgaben besser bew√§ltigen als Menschen.  Es ist diese These, die getestet wird. </p><br><h2 id="osobennosti-audita-koda-smart-kontraktov">  Merkmale der intelligenten Pr√ºfung des Vertragscodes </h2><br><p>  Die intelligente Pr√ºfung von Vertragscodes ist ein eher spezifischer Bereich.  Trotz seiner geringen Gr√∂√üe ist der Ethereum Smart Contract ein vollwertiges Programm, das komplexe Zweige, Schleifen und Entscheidungsb√§ume organisieren und sogar scheinbar einfache Transaktionen automatisieren kann, bei denen bei jedem Schritt alle m√∂glichen Zweige durchdacht werden m√ºssen.  Unter diesem Gesichtspunkt ist die Blockchain-Entwicklung √§u√üerst einfach, sehr ressourcenintensiv und erinnert stark an die Entwicklung von System- und eingebetteter Software in C / C ++ - und Assembler-Sprachen.  Aus diesem Grund freuen wir uns, in Interviews die Entwickler von Low-Level-Algorithmen, den Netzwerkstapel, hoch ausgelastete Dienste und alle zu sehen, die sich mit Low-Level-Optimierung und Code-Auditing befasst haben. </p><br><p>  Aus Sicht des Entwicklers ist Solidity auch ziemlich spezifisch, obwohl es von fast jedem Programmierer und in den ersten Schritten leicht zu lesen ist und √§u√üerst einfach erscheint.  Solidity-Code ist ziemlich einfach zu lesen und jedem Entwickler bekannt, der sich mit C / C ++ - Syntax und OOP wie JavaScript auskennt. </p><br><p>  Hier ist die Einfachheit des Codes der Schl√ºssel zum √úberleben, nichts Schweres funktioniert, daher wird das gesamte Arsenal der Entwicklung auf niedriger Ebene in der Arbeit verwendet - Algorithmen, die eine effiziente Nutzung von Ressourcen erm√∂glichen, Speicherplatz sparen: Merkle-B√§ume, Bloom-Filter, ‚Äûfaules‚Äú Laden von Ressourcen, Abrollen von Schleifen, manuelle Speicherbereinigung und vieles mehr. <br>  Eine kleine Menge Quellcode und daraus resultierenden Bytecode. </p><br><p>  Ein separater Smart-Vertrag ist in Bezug auf das Bytecode-Volumen begrenzt, jedes Byte kostet eine bestimmte Menge Gas und das Maximum ist von oben begrenzt, sodass Sie (im Moment) etwa 10 KB in die Blockchain schieben k√∂nnen. Es funktioniert nicht mehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein guter Artikel dar√ºber, wie viel ein Vertrag kostet und wie viel Gas kostet</a> .  Daher kann nicht viel geschoben werden.  Wenn Sie √ºbertreiben, sind mehrere tausend Zeilen ‚Äûdurchschnittlicher‚Äú Code das Maximum.  Mehrere Dutzend Methoden, die fehlende Aggregation und die allgemein komplexe Logik sind √§u√üerst charakteristisch f√ºr Vertr√§ge.  F√ºr alles, was nicht passt, m√ºssen Sie den Code in separaten Bibliotheken ausw√§hlen, um das Verfahren zum Hochladen in das Netzwerk zu √§ndern und zu verkomplizieren.  Solidity-Entwickler k√∂nnen gerne eine Menge Code in einen Vertrag einbinden, m√ºssen jedoch einfach ihre Vertragssysteme korrekt anordnen, indem sie separate Klassenbibliotheken mit eigenem Speicher erstellen.  Und es ist praktisch, solche separaten "Klassen" in separate Dateien zu zerlegen. Daher ist das Lesen des Code der Vertr√§ge ziemlich gut, alles ist von Anfang an gut strukturiert - sonst funktioniert es einfach nicht.  Als Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">empfehle</a> ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, sich anzusehen, wie ERC721 in Openzeppelin-Solidit√§t hergestellt wird</a> . </p><br><h3 id="gaz-gaz-gaz">  Gas, Gas, Gas </h3><br><p>  Gas f√ºhrt eine zus√§tzliche Logikschicht in die Ausf√ºhrung des Vertragscodes ein, die eine Pr√ºfung erfordert.  Dar√ºber hinaus kann im Gegensatz zum herk√∂mmlichen Code derselbe Codeabschnitt unterschiedliche Gasmengen verbrauchen.  Eine Tabelle mit EVM-Opcodes und ihren Kosten ist hilfreich, um die Gasbeschr√§nkungen zu verstehen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist sie</a> . </p><br><p>  Um zu demonstrieren, warum Sie viel Zeit f√ºr die Bewertung von Gas aufwenden m√ºssen, betrachten Sie diesen Pseudocode (nat√ºrlich unrealistisch; es ist eine schlechte Idee, in der Schleife mit √Ñther zu feuern): </p><br><pre><code class="plaintext hljs">//          function fixSomeAccountAction(uint _actionId) public onlyValidator { // ‚Ä¶ events[msg.sender].push(_actionId); } //   ,           function receivePaymentForSavedActions() { // ... for (uint256 i = 0; i &lt; events[msg.sender].length; i++) { //  actionId   uint actionId = events[msg.sender][i]; //      action uint payment = getPriceByEventId(actionId); if (payment &gt; 0) { paymentAccumulators[msg.sender] += payment; } emit LogEventPaymentForAction(msg.sender, actionId, payment); // ‚Ä¶ // delete ‚Äúevents[msg.sender][i]‚Äù from array } }</code> </pre> <br><p>  Tatsache ist, dass der Zyklus im Vertrag Ereignisse [msg.sender] .length mal ausgef√ºhrt wird und jede Iteration ein Eintrag in der Blockchain ist (transfer () und emit ()).  Wenn die L√§nge des Arrays klein ist, erf√ºllt der Zyklus sein Zehnfaches und verteilt die Zahlung f√ºr jede Aktion.  Wenn das Ereignis-Array [msg.sender] jedoch gro√ü ist, gibt es viele Iterationen und das verbrauchte Gas l√§uft in die fest codierte maximale Gasgrenze (~ 8.000.000).  Die Transaktion wird abgebrochen und funktioniert jetzt nie mehr, da es keine M√∂glichkeit gibt, die L√§nge des Ereignis-Arrays [msg.sender] im Vertrag zu verringern.  Wenn der Zyklus nicht nur einen Einheitswert berechnet, sondern in die Blockchain schreibt (z. B. werden einige Geb√ºhren gezahlt, Zahlungen f√ºr Aktionen), ist die zul√§ssige Anzahl von Iterationen erheblich begrenzt.  √úberzeugen Sie sich selbst - Limit: 8.000.000, Aufzeichnung eines neuen 256-Bit-Werts: 20.000.  Sie k√∂nnen Metadaten nur f√ºr ein paar Hundert von 256-Bit-Adressen mit einigen Metadaten speichern oder aktualisieren. Ein weiterer unterhaltsamer Teil ist das Schreiben eines neuen Werts: 20.000 und eines Updates eines vorhandenen Werts: 5.000, also auch mit genau der gleichen Umgebung Ihres Vertrags, wenn Sie eine √úbertragung durchf√ºhren Token an eine Adresse, die bereits Token enth√§lt, geben Sie viermal weniger Benzin (5.000 gegen√ºber 20.000) f√ºr einen Datensatz aus. </p><br><p>  Seien Sie daher nicht √ºberrascht, dass das Thema Gas in intelligenten Vertr√§gen so eng mit der Sicherheit von Vertr√§gen zusammenh√§ngt, da sich die Situation, in der Gelder aus praktischer Sicht dauerhaft im Vertrag stecken, kaum von der Situation unterscheidet, in der sie gestohlen wurden.  Die Tatsache, dass der ADD-Befehl 3 Gas und SSTORE (Einsparung in den Speicher) kostet: 20 000, bedeutet, dass die teuerste Ressource in der Blockchain die Speicherung ist, und die Aufgaben der Optimierung des Vertragscodes haben viel mit den Aufgaben der Entwicklung auf niedriger Ebene in C und ASM f√ºr Embedded gemeinsam Systeme, bei denen Speicher ebenfalls eine sehr begrenzte Ressource ist. </p><br><h3 id="prekrasnyy-blokcheyn">  Sch√∂ne Blockchain </h3><br><p>  Dies ist ein sehr positiver Absatz dar√ºber, warum die Blockchain aus Sicherheitsgr√ºnden nur f√ºr den Pr√ºfer so gut ist.  Der Determinismus der Ausf√ºhrung des Vertragscodes ist der Schl√ºssel zum erfolgreichen Debuggen und Wiedergeben von Fehlern und Schwachstellen.  Technisch gesehen kann jeder Aufruf des Vertragscodes auf jeder Plattform mit einer gewissen Genauigkeit reproduziert werden. Dadurch k√∂nnen die Tests √ºberall ausgef√ºhrt werden und sind √§u√üerst einfach zu unterst√ºtzen. Die Untersuchung von Vorf√§llen ist zuverl√§ssig und unbestreitbar.  Jetzt wissen wir immer, wer wann welche Funktion aufgerufen wurde, mit welchen Parametern, welcher Code sie verarbeitete und was das Ergebnis war.  All dies ist vollst√§ndig bestimmt, d.h.  spielt √ºberall, auch in JS auf einer Webseite.  Wenn wir √ºber Ethereum sprechen, ist jeder Testfall extrem einfach in praktischem JavaScript zu schreiben, einschlie√ülich Fuzzing-Parametern, und funktioniert √ºberall dort, wo es Node.js gibt. </p><br><p>  All diese sch√∂nen W√∂rter sollten die Entwickler jedoch nicht entspannen, da, wie oben erw√§hnt, die schwerwiegendsten Fehler logisch sind und f√ºr sie der Determinismus der Ausf√ºhrung eine orthogonale Eigenschaft ist. </p><br><h2 id="okruzhenie-dlya-sborki-kontrakta">  Die Umgebung f√ºr die Montage des Vertrages </h2><br><p>  Um den Artikel zu schreiben, habe ich einen alten experimentellen Vertrag f√ºr die Buchung eines Hauses vom Smartz-Designer abgeschlossen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/smartzplatform/constructor-eth-booking</a> .  Mit dem Vertrag k√∂nnen Sie eine Aufzeichnung des Objekts (Apartment oder Hotelzimmer) erstellen, den Preis und die Liefertermine festlegen. Danach wartet der Vertrag auf die Zahlung und legt bei Erhalt den Buchungsvorgang fest, wobei das Guthaben auf dem Restbetrag verbleibt, bis der Gast das Zimmer betritt und wird die Eingabe nicht best√§tigen.  Zu diesem Zeitpunkt erh√§lt der Eigent√ºmer des Zimmers die Zahlung.  Der Vertrag ist im Wesentlichen eine Zustandsmaschine, deren Zust√§nde und √úberg√§nge in Booking.sol eingesehen werden k√∂nnen.  Wir haben es ziemlich schnell gemacht, es w√§hrend des Entwicklungsprozesses ge√§ndert und es nicht geschafft, eine gro√üe Anzahl von Tests durchzuf√ºhren. Es ist weit entfernt von einer neuen Version des Compilers und mehr oder weniger umfangreicher interner Logik.  Schauen wir uns also an, wie die Analysatoren damit umgehen, welche Fehler sie finden, und f√ºgen wir bei Bedarf unsere eigenen hinzu. </p><br><h3 id="rabota-s-raznymi-versiyami-solc">  Arbeiten Sie mit verschiedenen Versionen von solc </h3><br><p>  Verschiedene Analysatoren m√ºssen auf unterschiedliche Weise verwendet werden - einige werden vom Docker aus gestartet, andere verwenden vorgefertigten kompilierten Bytecode, und der Pr√ºfer selbst muss sich nicht mit einem Paar befassen, sondern mit Dutzenden fr√ºher Vertr√§ge mit verschiedenen Versionen des Compilers.  Daher m√ºssen Sie in der Lage sein, verschiedene Versionen von <code>solc</code> sowohl im Host-System als auch im Docker-Image und im Tr√ºffel unterschiedlich zu " <code>solc</code> ", damit ich Ihnen diese wenigen schmutzigen Hack-Optionen geben kann: </p><br><p>  1 Weg: Innentr√ºffel </p><br><p>  Daf√ºr werden keine Tricks ben√∂tigt, weil  Ab Tr√ºffelversion 5.0.0 k√∂nnen Sie die Compilerversion wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Diff</a> direkt in truffle.js angeben. </p><br><p>  Jetzt l√§dt truffle den erforderlichen Compiler herunter und f√ºhrt ihn aus.  Vielen Dank an das Team daf√ºr, Solidity ist eine junge Sprache, es gibt gravierende √Ñnderungen in der Sprache und der Wechsel von Version zu Version f√ºr den Auditor ist inakzeptabel. Auf diese Weise k√∂nnen Sie neue Fehler einf√ºhren und alte maskieren. </p><br><p>  Methode 2: Ersetzen von / usr / bin / solc im Docker-Container des Analysators <br>  Wenn der Analysator in Form einer Docker-Datei verteilt ist, k√∂nnen Sie ihn beim Zusammenstellen eines Docker-Images ersetzen, indem Sie der Docker-Datei eine Zeile hinzuf√ºgen, die die gew√ºnschte Version <code>solc</code> direkt aus dem Image erh√§lt, die sie aus dem Netzwerk abruft und / usr / bin / solc ersetzt: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.19 /usr/bin/solc /usr/bin</code> </pre> <br><p>  3 Wege: Ersetzen von / usr / bin / solc </p><br><p>  Der schmutzigste Weg in der Stirn, wenn es √ºberhaupt keinen Ausweg gibt, k√∂nnen Sie die Bin√§rdatei / usr / bin / solc durch ein Skript wie dieses ersetzen (vergessen Sie nicht, die Originaldatei zu speichern): </p><br><pre> <code class="plaintext hljs">#!/bin/bash # run Solidity compiler of given version, pass all parameters # you can run ‚ÄúSOLC_DOCKER_VERSION=0.4.20 solc --version‚Äù SOLC_DOCKER_VERSION="${SOLC_DOCKER_VERSION:-0.4.24}" docker run \ --entrypoint "" \ --tmpfs /tmp \ -v $(pwd):/project \ -v $(pwd)/node_modules:/project/node_modules \ -w /project \ ethereum/solc:$SOLC_DOCKER_VERSION \ /usr/bin/solc \ "$@"</code> </pre> <br><p>  Es l√§dt das Docker-Image mit der richtigen Version von <code>solc</code> herunter und <code>solc</code> , wechselt in das aktuelle Verzeichnis und f√ºhrt <code>/usr/bin/solc</code> mit den √ºbergebenen Parametern aus.  Kein sehr guter Weg, aber vielleicht passt er f√ºr einige Aufgaben zu Ihnen. </p><br><h3 id="flattening-code">  Code reduzieren </h3><br><p>  Lassen Sie uns nun die Quelle herausfinden.  Theoretisch sollten Autoanalysatoren (insbesondere f√ºr die Analyse statischer Quellen) theoretisch einen Vertrag sammeln, alle Abh√§ngigkeiten aufrufen, alles zu einem Monolithen kombinieren und analysieren.  Aber wie ich bereits sagte, k√∂nnen √Ñnderungen von Version zu Version schwerwiegend sein, und ich bin st√§ndig auf die Notwendigkeit gesto√üen, ein zus√§tzliches Verzeichnis in das Docker zu legen, es innerhalb des Pfads zu konfigurieren und all dies, damit die erforderlichen Importe korrekt abgerufen werden.  Einige Analysatoren verstehen alles, der zweite ist daher keine universelle Option. Um nicht unter dem Verwerfen zus√§tzlicher Verzeichnisse zu leiden, ist es f√ºr Analysatoren, die eine einzelne Datei essen, bequemer, alles in einer Datei zusammenzuf√ºhren und nur zu analysieren. </p><br><p>  Verwenden Sie dazu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normalen Tr√ºffelabflacher</a> . </p><br><p>  Dies ist ein Standard-npm-Modul, es wird sehr einfach verwendet: </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/trailofbits/slither</a> <br>  Wenn Sie das Reduzieren irgendwie anpassen m√ºssen, k√∂nnen Sie beispielsweise Ihr eigenes Reduzieren schreiben, bevor wir die Python-basierte Option verwendet haben: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mixbytes/solidity-flattener</a> </p><br><h2 id="nachnem-analiz">  Beginnen wir mit der Analyse. </h2><br><p>  Am Beispiel desselben alten Mannes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/smartzplatform/constructor-eth-booking setzen wir</a> die Analyse fort.  Der Vertrag gibt die alte Version des Compilers "0.4.20" an, und ich habe absichtlich den alten Vertrag verwendet, um Probleme mit dem Compiler zu l√∂sen.  Die Situation wird durch die Tatsache verschlimmert, dass ein Autoanalysator, der beispielsweise Bytecode studiert, von dieser Version von solc abh√§ngen kann, und hier k√∂nnen Unterschiede in den Versionen die Ergebnisse stark beeinflussen oder sogar alles kaputt machen.  Selbst wenn Sie mit den neuesten Versionen alles koscher machen, k√∂nnen Sie dennoch auf einen Analysator sto√üen, der auf die vorherige Version des Compilers abgestimmt wurde. <br>  Tests kompilieren und ausf√ºhren </p><br><p>  Um zu beginnen, ziehen Sie einfach das Projekt aus dem Github und versuchen Sie es zu kompilieren .: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/smartzplatform/constructor-eth-booking.git cd constructor-eth-booking npm install truffle compile</code> </pre> <br><p>  Sicher haben Sie Probleme mit der Compiler-Version.  Auch Autoanalysatoren haben diese Probleme. Verwenden Sie daher alle Mittel, um den 0.4.20-Compiler abzurufen und das Projekt zu erstellen.  Ich habe gerade die erforderliche Version des Compilers in truffle.js registriert und alles wurde wie oben beschrieben zusammengestellt. </p><br><p>  Auch laufen </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  Wie im Abschnitt √ºber das Abflachen angegeben, handelt es sich um <code>contracts/flattened.sol</code> Abflachen. <code>contracts/flattened.sol</code> wir zur Analyse an verschiedene Analyseger√§te weitergeben <br>  Fazit zur Einleitung </p><br><p>  Nachdem Sie nun abgeflacht haben und <code>solc</code> einer beliebigen Version verwenden k√∂nnen, k√∂nnen Sie mit der Analyse beginnen.  Ich werde die Probleme beim Ausf√ºhren von Tr√ºffeln und Tests weglassen. Es gibt eine Menge Dokumentation zu diesem Thema. Verstehen Sie es selbst.  Nat√ºrlich m√ºssen die Tests erfolgreich ausgef√ºhrt werden.  Um die Logik zu √ºberpr√ºfen, muss der Pr√ºfer h√§ufig seine eigenen Tests hinzuf√ºgen, potenziell undichte Stellen √ºberpr√ºfen, z. B. die Vertragsfunktionalit√§t an den Grenzen von Arrays √ºberpr√ºfen, alle Variablen mit Tests abdecken, auch diejenigen, die ausschlie√ülich zur Datenspeicherung bestimmt sind usw.  Es gibt viele Empfehlungen, au√üerdem ist dies nur das Produkt, das unser Unternehmen auf den Markt bringt. Das Studium der Logik ist also eine rein menschliche Aufgabe. </p><br><p>  Wir werden Analysatoren durchgehen, die aus unserer Sicht interessant sind, versuchen, unseren Vertrag in sie zu integrieren, und wir werden Schwachstellen k√ºnstlich einf√ºhren, um zu bewerten, wie die automatischen Analysatoren auf sie reagieren werden.  Der n√§chste Artikel ist dem Slither-Analysator gewidmet, und im Allgemeinen sieht der Aktionsplan ungef√§hr wie folgt aus: </p><br><p>  Teil 1. Einf√ºhrung.  Zusammenstellung, Abflachung, Versionen von Solidity (dieser Artikel) <br>  Teil 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slither</a> <br>  Teil 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mithril</a> <br>  Teil 4. Mantikor <br>  Teil 5. Echidna <br>  Teil 6. Unbekanntes Werkzeug 1 <br>  Teil 7. Unbekanntes Werkzeug 2 </p><br><p>  Dieser Satz von Analysatoren wurde erhalten, weil es f√ºr den Pr√ºfer wichtig ist, verschiedene Arten von Analysen verwenden zu k√∂nnen - statische und dynamische, und sie erfordern v√∂llig unterschiedliche Ans√§tze.  Unsere Aufgabe ist es zu lernen, wie man die grundlegenden Werkzeuge in jeder Art von Analyse verwendet und welche man wann verwendet. </p><br><p>  M√∂glicherweise erscheinen im Verlauf einer detaillierten Studie neue Kandidaten zur Pr√ºfung, oder die Reihenfolge der Artikel √§ndert sich. Bleiben Sie also auf dem Laufenden.  Um zum n√§chsten Teil zu gelangen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klicken Sie hier.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438336/">https://habr.com/ru/post/de438336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438326/index.html">5G in Russland: Warum wird es ben√∂tigt, wie viel kostet es und wann wird es erscheinen? Kurz zur Hauptsache</a></li>
<li><a href="../de438328/index.html">Wie hoch ist die Gehaltsblase f√ºr Programmierer?</a></li>
<li><a href="../de438330/index.html">Adams State University. Wie man Websites hackt. Teil 1</a></li>
<li><a href="../de438332/index.html">Adams State University. Wie man Websites hackt. Teil 2</a></li>
<li><a href="../de438334/index.html">√úbergang zu 3D: Der Einfluss von Chiparchitektur und Aufzeichnungsalgorithmen auf die Lebensdauer von SSDs</a></li>
<li><a href="../de438338/index.html">Leitfaden zur automatischen Pr√ºfung intelligenter Vertr√§ge. Teil 2: Rutschen</a></li>
<li><a href="../de438340/index.html">Medien: iCloud hat m√∂glicherweise ein Datenleck, das Apple zu verbergen versuchte</a></li>
<li><a href="../de438342/index.html">Warum betr√ºgt freundliche KI in Ghost Recon Wildlands</a></li>
<li><a href="../de438346/index.html">Wie machen sie das? √úbersicht √ºber Kryptow√§hrungs-Anonymisierungstechnologien</a></li>
<li><a href="../de438348/index.html">Wie man lernt, mit 9 Jahren selbst√§ndig zu programmieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>