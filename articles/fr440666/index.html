<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌆 🎖️ 👩🏻‍🎨 Classification des dessins manuscrits. Signaler dans Yandex 💲 👐🏼 👩🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques mois, nos collègues de Google ont organisé un concours à Kaggle pour créer un classificateur pour les images reçues dans le jeu acclam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classification des dessins manuscrits. Signaler dans Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/440666/">  Il y a quelques mois, nos collègues de Google ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisé</a> un concours à Kaggle pour créer un classificateur pour les images reçues dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeu</a> acclamé "Quick, Draw!".  L'équipe, à laquelle Roman Vlasov, développeur Yandex a participé, a pris la quatrième place du concours.  Lors de la session de formation en machine-learning de janvier, Roman a partagé les idées de son équipe, la mise en œuvre finale du classificateur et les pratiques intéressantes de ses rivaux. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HO8ymjF-UTw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Bonjour à tous!  Je m'appelle Roma Vlasov, aujourd'hui je vais vous parler de Quick, Draw!  Défi de reconnaissance de Doodle. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/hw/xb/vc/hwxbvcwdjtsmvlzi9q9zly8khwe.jpeg"><br><br>  Il y avait cinq personnes dans notre équipe.  Je l'ai rejointe juste avant la date limite de fusion.  Nous n'avons pas eu de chance, nous étions un peu secoués, mais nous étions à l'abri de l'argent, et ils étaient de la position d'or.  Et nous avons pris une honorable quatrième place. <br><br>  (Pendant le concours, les équipes se sont observées dans la notation, qui a été formée en fonction des résultats indiqués sur une partie de l'ensemble de données proposé. La notation finale, à son tour, a été formée sur l'autre partie de l'ensemble de données. Ceci est fait pour que les participants au concours n'adaptent pas leurs algorithmes à des données spécifiques. Par conséquent, lors des finales, lors du basculement entre les classements, les positions sont un peu "sheikap" (de l'anglais shake up - à shuffle): sur d'autres données et le résultat peut être différent. L'équipe de Roman était première dans le top trois.  AU Troika - est de l'argent, zone de classement de l'argent, puisque seuls les trois premiers emplacements invoquaient prix Après que l'équipe « secousse apa » était déjà à la quatrième place de la même manière l'autre équipe a perdu la victoire, la position de l'or -... Ed) .. <br><br><img src="https://habrastorage.org/webt/4x/zs/9d/4xzs9dipspiteybhjdudb9kdj7g.jpeg"><br><br>  La compétition était également importante car Yevgeny Babakhnin a reçu pour lui des grands-maîtres, Ivan Sosin - des maîtres, Roman Solovyov est resté un grand maître, Alex Parinov a reçu un maître, je suis devenu un expert, et maintenant je suis déjà un maître. <br><br><img src="https://habrastorage.org/webt/fy/-v/gv/fy-vgvzvgssn2kmnn3slpjajo5a.jpeg"><br><br>  Qu'est-ce que c'est Quick, Draw?  Il s'agit d'un service de Google.  Google visait à vulgariser l'IA et, avec ce service, voulait montrer comment fonctionnent les réseaux de neurones.  Vous allez là-bas, cliquez sur Dessiner, et une nouvelle page apparaît où l'on vous dit: dessinez un zigzag, vous avez 20 secondes pour le faire.  Vous essayez de dessiner un zigzag en 20 secondes, comme ici, par exemple.  Si tout fonctionne pour vous, le réseau dit que c'est un zigzag et vous continuez.  Il n'y a que six images de ce type. <br><br>  Si le réseau de Google ne pouvait pas reconnaître ce que vous avez dessiné, une croix a été placée sur la tâche.  Plus tard, je vous dirai ce que cela signifiera à l'avenir, que le dessin soit reconnu par le réseau ou non. <br><br>  Ce service a rassemblé un nombre assez important d'utilisateurs, et toutes les photos que les utilisateurs ont dessinées ont été enregistrées. <br><br><img src="https://habrastorage.org/webt/ni/kl/on/niklonrxxlfht_gy0u4yzg3k5og.jpeg"><br><br>  Il a été possible de collecter près de 50 millions de photos.  À partir de cela, la date du train et des tests pour notre compétition a été formée.  Soit dit en passant, la quantité de données dans le test et le nombre de classes ne sont pas en vain en gras.  J'en parlerai un peu plus tard. <br><br>  Le format des données était le suivant.  Ce ne sont pas seulement des images RVB, mais, en gros, le journal de tout ce que l'utilisateur a fait.  Word est notre cible, countrycode est d'où vient le doodle, l'horodatage est le temps.  L'étiquette reconnue indique simplement si le réseau de Google a reconnu l'image ou non.  Et le dessin lui-même est une séquence, une approximation de la courbe que l'utilisateur dessine avec des points.  Et les horaires.  Il s'agit du temps écoulé depuis le début du dessin de l'image. <br><br><img src="https://habrastorage.org/webt/xw/_y/zw/xw_yzwjp5d8osd1ejay6gcncywu.jpeg"><br><br>  Les données ont été présentées sous deux formats.  Il s'agit du premier format et le second est simplifié.  Ils ont scié les horaires à partir de là et ont rapproché cet ensemble de points avec un plus petit ensemble de points.  Pour ce faire, ils ont utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme Douglas-Pecker</a> .  Vous disposez d'un large ensemble de points qui se rapproche simplement d'une ligne droite, mais vous pouvez réellement approximer cette ligne avec seulement deux points.  C'est l'idée de l'algorithme. <br><br>  Les données ont été réparties comme suit.  Tout est uniforme, mais il y a des valeurs aberrantes.  Lorsque nous avons résolu le problème, nous ne l'avons pas examiné.  L'essentiel est qu'il n'y avait pas de classes vraiment peu nombreuses, nous n'avions pas à faire d'échantillonneurs pondérés et de suréchantillonnage des données. <br><br><img src="https://habrastorage.org/webt/cp/_z/8y/cp_z8ydmx3m7gaptzpm9pvfglvu.jpeg"><br><br>  À quoi ressemblaient les photos?  Il s'agit de la classe d'aéronef et des exemples d'elle sont étiquetés reconnus et non reconnus.  Leur rapport était de 1 à 9. Comme vous pouvez le voir, les données sont assez bruyantes.  Je dirais que c'est un avion.  Si vous regardez non reconnu, dans la plupart des cas, c'est juste du bruit.  Quelqu'un a même essayé d'écrire «avion», mais apparemment en français. <br><br>  La plupart des participants ont simplement pris des grilles, rendu les données de cette séquence de lignes sous forme d'images RVB et les ont jetées dans le réseau.  J'ai peint à peu près de la même manière: j'ai pris une palette de couleurs, j'ai peint la première ligne avec une couleur, qui était au début de cette palette, la dernière, avec une autre, qui était à la fin de la palette, et entre elles partout interpolées sur cette palette.  Soit dit en passant, cela a donné un meilleur résultat que si vous dessiniez comme sur la toute première diapositive - juste en noir. <br><br>  D'autres membres de l'équipe, comme Ivan Sosin, ont essayé des approches légèrement différentes du dessin.  Avec un canal, il a simplement dessiné une image grise, avec un autre canal, il a dessiné chaque trait avec un dégradé du début à la fin, de 32 à 255, et le troisième canal a dessiné un dégradé dans tous les traits de 32 à 255. <br><br>  Une autre chose intéressante est qu'Alex Parinov a jeté des informations dans le réseau via countrycode. <br><br><img src="https://habrastorage.org/webt/wm/z0/iw/wmz0iw6jp4sxzqm2z3zqtafkhbo.jpeg"><br><br>  La métrique utilisée dans la compétition est la précision moyenne moyenne.  Quelle est l'essence de cette métrique pour la compétition?  Vous pouvez donner trois prédicteurs, et si ces trois prédicteurs ne sont pas corrects, alors vous obtenez 0. S'il y en a un correct, alors son ordre est pris en compte.  Et le résultat pour la cible sera considéré comme 1, divisé par l'ordre de votre prédiction.  Par exemple, vous avez fait trois prédictions, et la première est la bonne, alors vous divisez 1 par 1 et obtenez 1. Si le prédicteur est correct et son ordre est 2, puis 1 divisez par 2, vous obtenez 0,5.  Eh bien, etc. <br><br><img src="https://habrastorage.org/webt/ar/fm/7k/arfm7knnnynq6iekr-ykcnxvdr8.jpeg"><br><br>  Avec le prétraitement des données - comment dessiner des images, etc. - nous avons décidé un peu.  Quelles architectures avons-nous utilisées?  Nous avons essayé d'utiliser des architectures audacieuses telles que PNASNet, SENet, et des architectures déjà classiques comme SE-Res-NeXt, elles entrent de plus en plus dans de nouvelles compétitions.  Il y avait aussi ResNet et DenseNet. <br><br><img src="https://habrastorage.org/webt/rr/4p/ku/rr4pkuestkfvwxz4l-7absymotq.jpeg"><br><br><img src="https://habrastorage.org/webt/yz/4z/9_/yz4z9_fybssrwzh3recxexbrkbg.jpeg"><br><br><img src="https://habrastorage.org/webt/hw/eg/p9/hwegp98dpudcisrhvfbqx-92648.jpeg"><br><br>  Comment avons-nous enseigné cela?  Tous les modèles que nous avons pris, nous nous sommes pré-formés sur imagenet.  Bien qu'il y ait beaucoup de données, 50 millions d'images, mais quand même, si vous prenez un réseau pré-formé sur imagenet, cela a donné un meilleur résultat que si vous le formiez à partir de zéro. <br><br>  Quelles techniques de formation avons-nous utilisées?  Il s'agit d'un recuit de coût avec des redémarrages à chaud, j'en parlerai un peu plus tard.  C'est une technique que j'utilise dans la quasi-totalité de mes dernières compétitions, et avec elles ça se passe plutôt bien pour entraîner les filets, pour atteindre un bon minimum. <br><br><img src="https://habrastorage.org/webt/9v/ch/ht/9vchht1fyo2sahp7bbxv7nnks3a.jpeg"><br><br>  Ensuite, réduisez le taux d'apprentissage sur le Plateau.  Vous commencez à former le réseau, définissez un taux d'apprentissage spécifique, puis apprenez-le, puis votre perte converge progressivement vers une valeur spécifique.  Vous vérifiez cela, par exemple, sur dix époques, la perte n'a pas changé.  Vous réduisez votre taux d'apprentissage d'une certaine valeur et continuez à apprendre.  Il baisse encore un peu, converge à un certain minimum, et encore une fois vous réduisez le taux d'apprentissage, et ainsi de suite, jusqu'à ce que votre réseau converge enfin. <br><br>  Autre technique intéressante: ne pas diminuer le taux d'apprentissage, augmenter la taille du lot.  Il existe un article du même nom.  Lorsque vous formez le réseau, vous n'avez pas à diminuer le taux d'apprentissage, vous pouvez simplement augmenter la taille du lot. <br><br>  Cette technique a d'ailleurs été utilisée par Alex Parinov.  Il a commencé avec un lot égal à 408, et lorsque le réseau est arrivé à un plateau, il a simplement doublé la taille du lot, etc. <br><br>  En fait, je ne me souviens pas de la valeur atteinte par la taille du lot, mais il est intéressant de noter que des équipes de Kaggle ont utilisé la même technique, leur taille de lot était d'environ 10 000. Soit dit en passant, les cadres modernes d'apprentissage en profondeur, tels que PyTorch, par exemple, vous permet de le faire très simplement.  Vous générez votre lot et le soumettez au réseau non tel quel, dans son intégralité, mais vous le divisez en morceaux afin qu'il tienne dans votre carte vidéo, comptez les dégradés et après avoir calculé le gradient pour l'ensemble du lot, vous mettez à jour les échelles. <br><br>  Soit dit en passant, de grandes tailles de lot sont encore arrivées dans ce concours, car les données étaient assez bruyantes, et une grande taille de lot vous a aidé à approximer plus précisément le gradient. <br><br>  Le pseudo-tamponnage a également été utilisé; pour la plupart, il a été utilisé par Roman Soloviev.  Il a échantillonné quelque part dans la moitié des données du test, et sur de tels lots, il a formé la grille. <br><br>  La taille des images a joué un rôle, mais le fait est que vous avez beaucoup de données, vous devez vous entraîner longtemps et si votre taille d'image est assez grande, vous vous entraînerez très longtemps.  Mais cela n'a pas apporté beaucoup dans la qualité de votre classificateur final, donc cela valait la peine d'utiliser un compromis.  Et ils n'ont essayé que des photos de très petite taille. <br><br>  Comment tout cela a-t-il appris?  Au début, des photos de petite taille ont été prises, plusieurs époques ont été exécutées dessus, cela a rapidement pris du temps.  Ensuite, de grandes images ont été données, le réseau a appris, puis encore plus, encore plus pour ne pas l'entraîner à partir de zéro et ne pas passer beaucoup de temps. <br><br>  À propos des optimiseurs.  Nous avons utilisé SGD et Adam.  De cette façon, il était possible d'obtenir un seul modèle, ce qui donnait une vitesse de 0,941-0,946 sur un classement public, ce qui est plutôt bien. <br><br>  Si vous assemblez des modèles d'une manière ou d'une autre, vous obtenez quelque part 0,951.  Si vous appliquez une autre technique, vous obtiendrez la vitesse finale sur le plateau public 0.954, comme nous l'avons reçu.  Mais plus à ce sujet plus tard.  Ensuite, je vais vous dire comment nous avons assemblé les modèles et comment une telle vitesse finale a été atteinte. <br><br>  Ensuite, je voudrais parler du recuit de Cosing avec redémarrage à chaud ou de la descente de gradient stochastique avec redémarrage à chaud.  En gros, en principe, vous pouvez coller n'importe quel optimiseur, mais le résultat est le suivant: si vous ne formez qu'un seul réseau et qu'il converge progressivement vers un minimum, alors tout va bien, vous obtiendrez un réseau, il fait certaines erreurs, mais vous pouvez lui apprendre un peu différemment.  Vous définissez un taux d'apprentissage initial et le réduisez progressivement en fonction de cette formule.  Vous le sous-estimez, votre réseau atteint un certain minimum, puis vous économisez des poids, et définissez à nouveau le taux d'apprentissage, qui était au début de la formation, de ce minimum, montez quelque part, et sous-estimez à nouveau votre taux d'apprentissage. <br><br>  Ainsi, vous pouvez visiter plusieurs creux à la fois, dans lesquels vous aurez la perte plus ou moins la même chose.  Mais le fait est que les réseaux avec ces poids donneront des erreurs différentes sur votre date.  En les faisant la moyenne, vous obtiendrez une certaine approximation, et votre vitesse sera plus élevée. <br><br><img src="https://habrastorage.org/webt/ra/5d/mz/ra5dmzx9mcelguiqckvaihllrkc.jpeg"><br><br>  À propos de la façon dont nous avons assemblé nos modèles.  Au début de la présentation, j'ai dit de faire attention à la quantité de données dans le test et au nombre de classes.  Si vous ajoutez 1 au nombre de cibles dans l'ensemble de test et divisez par le nombre de classes, vous obtenez le nombre 330, et il a été écrit à ce sujet dans le forum - que les classes dans le test sont équilibrées.  Cela pourrait être utilisé. <br><br>  Sur cette base, Roman Solovyov a inventé la métrique, nous l'avons appelée le score proxy, qui correspondait assez bien au classement.  L'essentiel est: vous faites une prédiction, prenez le top 1 de vos prédictions et comptez le nombre d'objets pour chaque classe.  Soustrayez 330 de chaque valeur et ajoutez les valeurs absolues résultantes. <br><br>  De telles valeurs se sont avérées.  Cela nous a aidés à ne pas faire un classement des tests, mais à valider localement et sélectionner des coefficients pour nos ensembles. <br><br>  Avec l'ensemble, vous pourriez obtenir une telle vitesse.  Que faire d'autre?  Supposons que vous ayez utilisé les informations selon lesquelles les classes de votre test sont équilibrées. <br><br>  L'équilibrage était différent.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple de l'un d'eux</a> est l'équilibre entre les gars qui ont remporté la première place. <br><br>  Qu'avons-nous fait?  Notre équilibrage était assez simple, il a été proposé par Evgeny Babakhnin.  Nous avons d'abord trié nos prédictions par top-1 et sélectionné des candidats - afin que le nombre de classes ne dépasse pas 330. Mais pour certaines classes, il s'avère qu'il y a moins de prédictions que 330. D'accord, trions par top-2 et top 3, et aussi choisir des candidats. <br><br>  En quoi notre équilibrage différait-il de l'équilibre en premier lieu?  Ils ont utilisé une approche itérative, pris la classe la plus populaire et réduit les probabilités pour cette classe d'un petit nombre - jusqu'à ce que cette classe ne devienne pas la plus populaire.  Ils ont suivi le cours suivant le plus populaire.  Donc plus loin et plus bas jusqu'à ce que le nombre de toutes les classes devienne égal. <br><br>  Tout le monde a utilisé une approche plus ou moins une pour former les réseaux, mais tout le monde n'a pas utilisé l'équilibrage.  En utilisant l'équilibrage, vous pourriez aller dans l'or, et si vous étiez chanceux, puis dans mani. <br><br>  Comment prétraiter une date?  Tout le monde a prétraité la date plus-moins de la même manière - a fait des fonctionnalités artisanales, a essayé d'encoder des timings avec des traits de couleur différents, etc. C'est exactement ce qu'a dit Alexey Nozdrin-Plotnitsky, qui a pris la 8ème place. <br><br><img src="https://habrastorage.org/webt/lq/jg/yb/lqjgybopsgcacrtnubcet3jub9e.jpeg"><br><br>  Il a fait différemment.  Il a dit que toutes ces fonctionnalités artisanales ne fonctionnent pas, vous n'avez pas besoin de le faire, votre réseau doit apprendre tout cela vous-même.  Et à la place, il est venu avec des modules d'apprentissage qui ont fait le prétraitement de vos données.  Il y a jeté les données source sans prétraitement - les coordonnées des points et des timings. <br><br>  De plus, il a pris la différence dans les coordonnées et l'a moyennée sur les timings.  Et il a obtenu une matrice assez longue.  Il a utilisé la convolution 1D plusieurs fois pour obtenir une matrice 64xn, où n est le nombre total de points, et 64 est fait afin d'alimenter la matrice résultante en une couche d'un réseau convolutionnel qui accepte 64 canaux. il s'est avéré être une matrice 64xn, puis il a fallu composer un tenseur d'une certaine taille pour que le nombre de canaux soit de 64. Il a normalisé tous les points X, Y dans la plage de 0 à 32 pour faire un tenseur de taille 32x32.  Je ne sais pas pourquoi il voulait du 32x32, c'est arrivé.  Et dans cette coordonnée, il a mis un fragment de cette matrice de taille 64xn.  Ainsi, il a simplement reçu le tenseur 32x32x64, qui pourrait être mis plus loin dans votre réseau neuronal convolutionnel.  J'ai tout. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440666/">https://habr.com/ru/post/fr440666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440654/index.html">Apprendre Python: module argparse</a></li>
<li><a href="../fr440656/index.html">Conteneurisation professionnelle des applications Node.js à l'aide de Docker</a></li>
<li><a href="../fr440658/index.html">Exploration de Docker, partie 4: réduction de la taille des images et accélération de leur assemblage</a></li>
<li><a href="../fr440660/index.html">Learning Docker, Partie 5: Commandes</a></li>
<li><a href="../fr440662/index.html">Tutoriel React Partie 18: La sixième phase de travail sur une application TODO</a></li>
<li><a href="../fr440670/index.html">La Banque centrale a publié des recommandations sur la protection cryptographique d'EBS</a></li>
<li><a href="../fr440672/index.html">Méthodes de rationalité et tapis de prière du Maghreb</a></li>
<li><a href="../fr440674/index.html">Utilisation de diagrammes de dispersion pour visualiser les données</a></li>
<li><a href="../fr440676/index.html">Le jour où Dodo IS s'est arrêté. Script synchrone</a></li>
<li><a href="../fr440678/index.html">Routeur CNC de bricolage. Sciences humaines pour les sciences humaines. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>