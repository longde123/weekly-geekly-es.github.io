<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥔 👃🏾 👩🏾‍💻 Framework GUI - par thread 😙 🐠 😳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations, collègues! 

 Il y a quelques mois, j'ai commencé à regarder Golang dans le but de l'utiliser pour des applications de bureau. J'ai aimé ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Framework GUI - par thread</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427429/">  Salutations, collègues! <br><br>  Il y a quelques mois, j'ai commencé à regarder Golang dans le but de l'utiliser pour des applications de bureau.  J'ai aimé la langue, le volume et le sujet des paquets écrits pour cela, mais la situation avec l'interface graphique n'est pas si rose.  Je ne m'attarderai pas sur les détails maintenant, il suffira de dire qu'après avoir lu quelques critiques et un rapide aperçu des packages GUI existants, j'ai décidé d'écrire le mien, d'autant plus que j'ai de l'expérience avec cela. <br><br>  Ma première pensée a été de suivre le chemin déjà bien tracé: écrire un ensemble de fonctions correspondantes en C, ou plutôt en adapter une déjà prête - ce que j'ai écrit pour Harbor et C ++, le lier à l'aide de cgo (API C pour Golang) et emballage convivial.  J'ai même commencé à le faire, j'ai reçu la première fenêtre, mais comme j'imaginais combien de travail restait à faire, séparément pour Windows, séparément pour Linux, un travail purement technique, puisque je l'avais déjà parcouru, mon enthousiasme s'était quelque peu calmé. <br><br>  Et puis une autre idée est venue. <a name="habracut"></a><br><br>  J'ai déjà une bibliothèque GUI, HwGUI for Harbor, qui est assez fonctionnelle, multi-plateforme, que j'utilise régulièrement pour mes applications.  Tout ce dont j'ai besoin y est déjà implémenté.  Pourquoi ne pas écrire sur sa base un programme qui fonctionne comme une sorte de serveur GUI.  Après avoir démarré ce serveur, il écoutera silencieusement un port spécifique et, après avoir reçu une connexion de mon programme Golang, il créera des fenêtres, des widgets en réponse à ses demandes, les manipulera et fournira des commentaires lorsque des événements de widgets apparaissent - en un mot, implémenter une interface graphique pour cela.  Tous les détails de bas niveau de l'implémentation GUI sont déjà dans la bibliothèque, pour Windows - via des appels directs à WinAPI, pour Linux / Unix et, probablement, macOs - via GTK.  De plus, je n'ai pas l'intention de créer un serveur au sens plein du terme, il n'acceptera pas les connexions de différents programmes - cela introduirait des difficultés supplémentaires inutiles.  Pour chaque instance du programme Golang, une instance distincte du serveur GUI sera lancée, ce qui simplifie encore la tâche.  En général, le programme se composera donc de deux processus, dont l'un exécute la tâche principale, l'autre est responsable de l'interface. <br><br>  Le package correspondant pour Go doit inclure la procédure Init, qui démarre le serveur GUI et le joint, ainsi qu'un ensemble de structures, méthodes, fonctions pour créer des fenêtres et des widgets et les manipuler.  Le contenu principal de toutes ces fonctions est d'envoyer des messages d'un certain format (basé sur JSON) au serveur et d'en recevoir des messages.  La communication est prise en charge à l'aide de deux ports TCP / IP, l'un est responsable de l'envoi des demandes au serveur, l'autre est responsable de la réception des signaux du serveur pour le traitement des événements (cliquer sur un bouton, fermer une fenêtre, etc.).  La tâche est relativement simple, le package lui-même est petit.  Pas besoin d'utiliser cgo, pas besoin de se lier à des bibliothèques tierces, tout le code en pur Go.  Le fichier exécutable du programme lui-même et le fichier exécutable du serveur GUI sont tous. <br><br>  Le choix de Harbor + HwGUI pour l'implémentation du serveur GUI pour moi est principalement dû au fait que ce sont mes outils «natifs», la solution la plus simple et la plus rapide.  Mais c'est un bon choix à d'autres points de vue.  Voici, à mon avis, les principaux avantages: <br><br><ul><li>  multiplateforme «dans la boîte»; </li><li>  ce qu'on appelle l'aspect et la convivialité natifs, car sous Windows, il s'agit exclusivement d'appels WinAPI, sous Linux / Unix - GTK;  combien le GTK «natif» pour macOs je ne sais vraiment pas; </li><li>  la possibilité d'utiliser Harbor comme langage de script intégré, des fragments de code pour l'exécution peuvent être transférés au serveur - des gestionnaires d'événements, par exemple, qui peuvent décharger le programme principal de certains détails d'implémentation.  De plus, Harbor est bon pour beaucoup de choses, pour travailler avec dbf et certaines bases de données, par exemple; </li><li>  mise en œuvre de l'impression; </li><li>  la possibilité d'utiliser des formulaires d'écran créés par le concepteur (utilitaire HwGUI).  Ces formulaires sont stockés au format XML et peuvent être utilisés sans modification dans n'importe quel système d'exploitation dans lequel le serveur fonctionne; </li><li>  la possibilité d'utiliser des formulaires de rapport créés par le même concepteur pour l'impression (également en XML). </li></ul><br>  Bref, j'ai commencé à le faire et une partie importante du travail est déjà terminée.  Les deux projets, GuiServer et le framework GUI externe de Golang sont sur Github, tous les liens sont à la fin de l'article.  Voici quelques captures d'écran.  Rien de spécial, juste des tests. <br><br>  Il s'agit d'une simple boîte de dialogue: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hg/h9/mf/hgh9mfnyucglzqk2ewbsfpjfpxo.png"></div><br>  Et cela se fait sur la base d'un exemple tiré du livre de Kernigan et Donovan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/o-/la/sao-lanfo07b3lpgqvsxxpsvr_m.png"></div><br>  Désormais, l'objectif principal des projets est de faire en sorte que ce joli couple, External et GuiServer, puisse faire tout ce que HwGUI peut faire.  Eh bien, dans le processus de création de vraies applications à l'aide d'Externe, il sera clair ce qui est le plus nécessaire. <br><br>  Cela pourrait être la fin, j'ai reporté la description du paquet Golang pour une autre fois.  Mais l'essentiel de cet article ne fait que commencer.  Après tout, la méthode décrite pour implémenter un framework GUI avec le même serveur GUI peut être utilisée pour d'autres langues.  C, Python, Java, ..., même Perl et PHP (et pourquoi pas?) - voir le titre de l'article.  Coûts minimaux - et une solution graphique assez fonctionnelle est prête.  La chose la plus difficile pour chaque langue spécifique n'est pas la mise en place d'un échange avec le serveur, mais que cette solution s'inscrit organiquement dans son paradigme, dans sa logique interne.  Si quelqu'un veut créer un tel cadre pour sa langue, j'essaierai de fournir toute l'assistance possible pour obtenir les informations nécessaires et, éventuellement, pour ajouter certaines fonctionnalités au serveur GUI. <br><br>  En parallèle avec le package Golang, j'ai fait un analogue pour Harbor, principalement à des fins de vérification / débogage.  Il est peu probable que je fasse un framework pour Perl, mais pour C ou C ++ c'est très probable.  Et voici pourquoi: après tout, il existe une autre fonctionnalité intéressante liée à l'utilisation d'un serveur GUI, il peut être exécuté sur un autre ordinateur.  Le programme principal s'exécute sur un ordinateur et son interface sur un autre.  Immédiatement vu ici sont des options pour utiliser ce cas: <br><br><ul><li>  le programme principal s'exécute sur un serveur Linux / Unix sur lequel le shell graphique n'est pas installé du tout; </li><li>  le programme principal s'exécute sur l'ordinateur de quelqu'un d'autre (avec un comptable conditionnel dans votre entreprise) et vous, sans interférer avec lui, le gérez par vous-même; </li><li>  le programme principal s'exécute sur un smartphone, et vous creusez dans ses entrailles à partir d'un ordinateur normal; </li><li>  le programme principal s'exécute sur le contrôleur, sur certains Arduino, Raspberry ou leurs homologues, où il peut n'y avoir aucun moniteur normal.  Connectez-vous avec votre ordinateur portable - et c'est parti. </li></ul><br>  Eh bien, pour cette dernière option, un framework C pour un serveur GUI serait probablement utile, je pense que cette possibilité est très prometteuse. <br><br>  Et enfin, les liens: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/alkresin/guiserver</a> - GuiServer sur Github <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/alkresin/external</a> - Externe (package Go) sur Github <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.kresin.ru/guisrv.html</a> - la page <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GuiServer</a> sur mon site, ici vous pouvez télécharger des binaires prêts à l'emploi <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/post/198618</a> - mon article sur Harbour est ici sur Habré <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en.wikipedia.org/wiki/Harbor</a> - Harbour sur Wikipédia <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.kresin.ru/harbour.html</a> - page Harbour sur mon site Web <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.kresin.ru/hwgui.html</a> - la page HwGUI sur mon site Web <br><br>  PS: Il est clair que peu de gens installeront Harbour et HwGUI pour construire GuiServer à partir des sources, donc je poste régulièrement les binaires collectés sur la page GuiServer sur mon site - pour Windows, Debian 8 32 bits, Ubuntu 18.04 64 bits.  Je peux assembler pour Fedora, mais sous macOs - hélas, je ne l'ai pas à distance de marche. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427429/">https://habr.com/ru/post/fr427429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427417/index.html">Avec de l'humour sur des disquettes de 8 pouces (dans les années 70, il n'y en avait que)</a></li>
<li><a href="../fr427419/index.html">Que faire lorsque le processeur n'a rien à faire?</a></li>
<li><a href="../fr427421/index.html">Comment les sites de généalogie facilitent la capture des tueurs</a></li>
<li><a href="../fr427423/index.html">City2Share: voitures électriques et autonomes dans les pôles logistiques de Munich</a></li>
<li><a href="../fr427427/index.html">Comment ils arrivent à l'informatique: à propos des stagiaires et des joons (résultat du sondage «My Circle»)</a></li>
<li><a href="../fr427431/index.html">Fonctionnement d'Android, partie 4</a></li>
<li><a href="../fr427433/index.html">Équilibrage du trafic dans les réseaux IP de l'opérateur</a></li>
<li><a href="../fr427435/index.html">STM32H7 - réglage de l'horloge sans HAL</a></li>
<li><a href="../fr427437/index.html">Configuration des serveurs liés: serveur sql ms et teradata</a></li>
<li><a href="../fr427439/index.html">Toute la vérité sur RTOS. Article # 16. Signaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>