<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ë üó∫Ô∏è üò™ Windows Notification Facility: a superf√≠cie de ataque n√£o documentada ‚ôíÔ∏è ‚óºÔ∏è üßô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Abaixo do corte, est√° uma tradu√ß√£o da apresenta√ß√£o "O mecanismo de notifica√ß√£o do Windows: a superf√≠cie de ataque ao kernel mais indocumentada ainda",...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Windows Notification Facility: a superf√≠cie de ataque n√£o documentada</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459626/"><p>  Abaixo do corte, est√° uma tradu√ß√£o da <strong>apresenta√ß√£o</strong> "O mecanismo de notifica√ß√£o do Windows: a superf√≠cie de ataque ao kernel mais indocumentada ainda", apresentada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alex Ionescu</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gabrielle Viala</a> na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confer√™ncia BlackHat 2018</a> . <br><img src="https://habrastorage.org/webt/ja/q7/pl/jaq7plcphybdtfljwzxxdryln8q.png"><img src="https://habrastorage.org/webt/fi/sw/fe/fiswfev1j4ndustfitqdyvruxis.jpeg"></p><br><div class="spoiler"> <b class="spoiler_title">O que ser√° discutido na publica√ß√£o</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© o Windows Notification Facility (WNF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Por que o WNF apareceu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nomes de estados WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chamadas do sistema para trabalhar com o WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de modo de usu√°rio de alto n√≠vel (ntdll)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de alto n√≠vel no n√≠vel do kernel (Ex)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Utilit√°rios de an√°lise WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Superf√≠cie de ataque WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nomes de estado WNF interessantes e sens√≠veis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inje√ß√£o de processo usando WNF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instru√ß√µes para pesquisas adicionais</a> </li></ul></div></div><a name="habracut"></a><br><a name="what"></a><br><h3 id="chto-takoe-windows-notification-facility-wnf">  O que √© o Windows Notification Facility (WNF) </h3><br><p>  O Windows Notification Facility √© um mecanismo de notifica√ß√£o (dispon√≠vel no kernel e no modo de usu√°rio), baseado em um modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publicador-assinante</a> ( <em>pubsub</em> , Publisher / Subscriber).  O mecanismo foi adicionado no Windows 8: em parte para resolver algumas limita√ß√µes de design de longa data no sistema operacional, mas tamb√©m serviu de base para a implementa√ß√£o de notifica√ß√µes push semelhantes ao iOS / Android. </p><br><p>  Sua principal caracter√≠stica √© que √© um modelo <em>cego</em> (principalmente sem registro) que permite assinatura e publica√ß√£o desordenadas.  Isso implica que um consumidor pode assinar uma notifica√ß√£o antes mesmo de ela ser publicada por sua fonte.  E que quem gera os eventos n√£o precisa "registrar" o aviso antecipadamente. </p><br><p>  Al√©m disso, o mecanismo suporta: </p><br><ul><li>  notifica√ß√µes permanentes e tempor√°rias </li><li>  monotonamente aumentando identificadores √∫nicos </li><li>  buffer de carga √∫til (at√© 4 kilobytes) para cada evento </li><li>  modelo de notifica√ß√£o de conjunto de encadeamentos com serializa√ß√£o baseada em grupo </li><li>  um modelo de seguran√ßa baseado em escopo que implementa descritores de seguran√ßa por meio do mecanismo <abbr title="Lista de controle de acesso discricion√°rio">DACL</abbr> / <abbr title="Lista de controle de acesso do sistema">SACL</abbr> padr√£o </li></ul><br><a name="why"></a><br><h3 id="pochemu-poyavilsya-wnf">  Por que o WNF apareceu </h3><br><p>  Considere um exemplo can√¥nico: existe um driver que deseja saber que um volume com acesso de leitura e grava√ß√£o foi conectado.  Para notific√°-lo disso, o Autochk (um an√°logo do <abbr title="verifica√ß√£o de consist√™ncia do sistema de arquivos">fsck</abbr> no Windows) relata um evento chamado VolumesSafeForWriteAccess.  Mas, para relatar um evento, voc√™ deve primeiro criar o pr√≥prio objeto de evento. </p><br><p>  Tamb√©m precisamos saber que o Autochk j√° est√° trabalhando no volume, mas ainda n√£o sinalizou o evento que estamos aguardando.  Solu√ß√£o ruim: sente-se em loop com sleep (), verificando a presen√ßa de um evento e quando o evento √© criado - aguarde. </p><br><p>  Mas depois de sair do aplicativo Windows, todos os seus descritores est√£o fechados.  E quando o objeto n√£o possui descritores, √© destru√≠do.  Ent√£o, quem ir√° realizar este evento? </p><br><p>  Sem o WNF, a solu√ß√£o √© o kernel do SO gerar um evento antes do carregamento de qualquer driver e o Autochk abri-lo como um consumidor faria, mas, em vez de esperar, deve sinalizar esse evento. </p><br><a name="state_name"></a><br><h3 id="imena-sostoyaniy-state-names-wnf">  Nomes de estados WNF </h3><br><p>  No mundo WNF, um nome de estado √© um n√∫mero de 64 bits.  Mas h√° um truque - na verdade, √© uma estrutura codificada.  O nome do estado possui uma <em>vers√£o</em> , <em>uma vida √∫til</em> , um <em>escopo</em> , um <em>sinalizador de persist√™ncia de dados</em> e um <em>n√∫mero de s√©rie exclusivo</em> . </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WNF_STATE_NAME_INTERNAL</span></span></span><span class="hljs-class"> {</span></span> ULONG64 Version:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 NameLifetime:<span class="hljs-number"><span class="hljs-number">2</span></span>; ULONG64 DataScope:<span class="hljs-number"><span class="hljs-number">4</span></span>; ULONG64 PermanentData:<span class="hljs-number"><span class="hljs-number">1</span></span>; ULONG64 Unique:<span class="hljs-number"><span class="hljs-number">53</span></span>; } WNF_STATE_NAME_INTERNAL, *PWNF_STATE_NAME_INTERNAL;</code> </pre> <br><p>  Mas esses dados estar√£o dispon√≠veis apenas se formos pr√≥-XOR um n√∫mero de 64 bits com uma constante m√°gica: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WNF_STATE_KEY 0x41C64E6DA3BC0074</span></span></code> </pre> <br><a name="lifetime"></a><br><h4 id="vremya-zhizni-lifetime-imeni-sostoyaniya">  Tempo de vida do nome do estado </h4><br><p>  O nome do estado WNF pode ser (WNF_STATE_NAME_LIFETIME): </p><br><ul><li>  bem conhecido </li><li>  permanente </li><li>  persistente </li><li>  tempor√°rio </li></ul><br><p>  Os tr√™s primeiros est√£o associados √†s chaves correspondentes no registro, onde as informa√ß√µes de status ser√£o armazenadas: </p><br><ul><li>  nomes conhecidos vivem em HKLM \ SYSTEM \ CurrentControlSet \ Control \ Notifications </li><li>  nomes persistentes est√£o em HKLM \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Notifications </li><li>  nomes persistentes est√£o em HKLM \ SOFTWARE \ Microsoft \ Windows \ CurrentVersion \ VolatileNotifications </li></ul><br><p>  Nomes conhecidos t√™m sua pr√≥pria peculiaridade: eles n√£o podem ser registrados.  Esse nome j√° deve ser apresentado no registro no momento da inicializa√ß√£o do sistema.  Nomes persistentes e persistentes requerem o privil√©gio SeCreatePermanentPrivilege inclu√≠do (como outros objetos globais) para cri√°-los.  Os nomes persistentes ficam fora do processo do registrador, enquanto os nomes persistentes sobrevivem √† reinicializa√ß√£o do sistema. </p><br><a name="scope"></a><br><h4 id="oblast-vidimosti-scope-dannyh">  Escopo de dados </h4><br><p>  O escopo de dados define o primeiro limite de seguran√ßa em torno do nome do status do WNF; determina quem o v√™ e tem acesso a ele.  O escopo do nome do estado pode ser: </p><br><ul><li>  o sistema </li><li>  o carro </li><li>  sess√£o de usu√°rio </li><li>  o usu√°rio </li><li>  o processo </li></ul><br><p>  Al√©m de fornecer limites de seguran√ßa, os escopos WNF podem ser usados ‚Äã‚Äãpara fornecer diferentes inst√¢ncias de dados para o mesmo nome.  O kernel (como em outros mecanismos de seguran√ßa) ignora as verifica√ß√µes de acesso ao estado.  O privil√©gio do TCB permite acesso de √¢mbito cruzado aos nomes de estado do WNF. </p><br><p>  O escopo "sistema" e o escopo "m√°quina" s√£o escopos globais.  Eles n√£o t√™m seus pr√≥prios identificadores (eles usam cont√™ineres globais diferentes).  O escopo da sess√£o do usu√°rio usa o identificador da sess√£o (ID da sess√£o) como o ID.  O escopo de um usu√°rio espec√≠fico usa o SID desse usu√°rio como um identificador.  O endere√ßo do objeto EPROCESS √© o identificador do escopo do processo. </p><br><a name="sequence"></a><br><h4 id="poryadkovye-nomera-sequence-numbers">  N√∫meros de sequ√™ncia </h4><br><p>  Para garantir a exclusividade, cada nome de estado possui um n√∫mero de sequ√™ncia exclusivo de 51 bits.  Os nomes conhecidos incluem uma etiqueta de fam√≠lia de 4 caracteres em seu n√∫mero de s√©rie e os 21 bits restantes s√£o usados ‚Äã‚Äãcomo um identificador exclusivo.  Nomes permanentes armazenam seu n√∫mero incremental com o valor do registro "SequenceNumber".  Nomes persistentes e tempor√°rios usam um contador de incremento comum, localizado em uma vari√°vel global.  Esses dados s√£o armazenados e processados ‚Äã‚Äãseparadamente para cada cont√™iner (por silo) e est√£o dispon√≠veis em PspHostSiloGlobals-&gt; WnfSiloState. </p><br><p>  Dentro da Microsoft, cada nome WNF possui um identificador "amig√°vel" usado no c√≥digo, √†s vezes √© armazenado no espa√ßo para nome global com o mesmo nome.  Por exemplo, o s√≠mbolo nt! WNF_BOOT_DIRTY_SHUTDOWN, que possui o valor 0x1589012fa3bc0875.  Ap√≥s o XOR com a constante m√°gica <abbr title="0x41C64E6DA3BC0074">WNF_STATE_KEY</abbr> , obtemos o valor 0x544f4f4200000801, que pode ser interpretado em bits como: </p><br><pre> <code class="plaintext hljs">BOOT1, Well-Known Lifetime, System Scope, Version 1</code> </pre> <br><a name="syscall"></a><br><h3 id="sistemnye-vyzovy-dlya-raboty-s-wnf">  Chamadas do sistema para trabalhar com o WNF </h3><br><p>  As chamadas de sistema do kernel permitem registrar e excluir nomes de estado do WNF, publicar e receber dados do nome do estado do WNF e tamb√©m receber v√°rias notifica√ß√µes do WNF. </p><br><a name="register"></a><br><h4 id="registraciya-imeni-sostoyaniya-wnf">  Nome do status do registro WNF </h4><br><p>  Com exce√ß√£o dos nomes conhecidos (como mencionado anteriormente), o nome do status do WNF pode ser registrado enquanto o sistema operacional est√° em execu√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwCreateWnfStateName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Out_ PWNF_STATE_NAME StateName, _In_ WNF_STATE_NAME_LIFETIME NameLifetime, _In_ WNF_DATA_SCOPE DataScope, _In_ BOOLEAN PersistData, _In_opt_ PCWNF_TYPE_ID TypeId, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//      _In_ ULONG MaximumStateSize, //   4-  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor // **  );</span></span></span></span></span></span></code> </pre> <br><p>  H√° uma chamada de sistema sim√©trica ZwDeleteWnfStateName com a qual voc√™ pode excluir o nome do estado registrado (novamente, exceto os conhecidos). </p><br><a name="publishing"></a><br><h4 id="publikaciya-dannyh-sostoyaniya-wnf">  Publicar dados de status do WNF </h4><br><p>  Para definir ou alterar os dados do nome de status do WNF, voc√™ pode usar a chamada de sistema ZwUpdateWnfStateData: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwUpdateWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_reads_bytes_opt_(Length) </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* Buffer, _In_opt_ ULONG Length, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   ,   MaximumSize,    _In_opt_ PCWNF_TYPE_ID TypeId, //      _In_opt_ const PVOID ExplicitScope, //  , SID ,  (ID)  _In_ WNF_CHANGE_STAMP MatchingChangeStamp, //     _In_ LOGICAL CheckStamp //         );</span></span></span></span></span></span></code> </pre> <br><p>  H√° uma chamada de sistema sim√©trica ZwDeleteWnfStateData para excluir (limpar) os dados do nome do estado WNF. </p><br><a name="consuming"></a><br><h4 id="poluchenie-dannyh-sostoyaniya-wnf">  Obtendo dados de status do WNF </h4><br><p>  Para solicitar os dados do nome de status do WNF, a seguinte chamada do sistema pode ser usada (a maioria dos par√¢metros √© semelhante √† fun√ß√£o Atualizar): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZwQueryWnfStateData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ PCWNF_STATE_NAME StateName, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VOID* ExplicitScope, _Out_ PWNF_CHANGE_STAMP ChangeStamp, _Out_writes_bytes_to_opt_(*BufferSize, *BufferSize) PVOID Buffer, _Inout_ PULONG BufferSize </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//   0,      );</span></span></span></span></span></span></code> </pre> <br><p>  A verdadeira for√ßa reside no fato de que as fun√ß√µes da API Update e Query na verdade n√£o exigem um nome de estado WNF <u>registrado</u> .  E se o nome n√£o for tempor√°rio (e o c√≥digo de chamada tiver privil√©gios suficientes), uma inst√¢ncia do nome poder√° ser registrada em tempo real! </p><br><a name="notifications"></a><br><h4 id="uvedomleniya-wnf">  Notifica√ß√µes WNF </h4><br><p>  At√© agora, assumimos que o consumidor sabe quando chamar a fun√ß√£o de aquisi√ß√£o de dados.  Mas tamb√©m h√° <em>bloqueio de leitura</em> , que funciona usando um sistema de notifica√ß√£o (mais pr√≥ximo do verdadeiro modelo de publicador-assinante). </p><br><p>  Primeiro, o processo deve registrar o evento chamando a fun√ß√£o ZwSetWnfProcessNotificationEvent.  Em seguida, voc√™ precisa chamar a fun√ß√£o ZwSubscribeWnfStateChange, especificando uma m√°scara de evento para obter o identificador de assinatura na sa√≠da.  Eventos podem ser de dois tipos: </p><br><ul><li>  Notifica√ß√µes de dados: <br><ul><li>  0x01 - apar√™ncia dos dados </li><li>  0x10 - destrui√ß√£o de nome </li></ul></li><li>  Metanotifica√ß√µes <br><ul><li>  0x02 - apar√™ncia de um assinante que recebe notifica√ß√µes de dados (Assinante de dados) </li><li>  0x04 - apar√™ncia de um assinante que recebe meta notifica√ß√µes (Meta Subscriber) </li><li>  0x08 - a apar√™ncia de um assinante que recebe notifica√ß√µes de dados e meta-notifica√ß√µes (Assinante Gen√©rico) </li></ul></li></ul><br><p>  Ent√£o voc√™ precisa aguardar o evento que foi gravado.  E toda vez que o evento se tornar um sinal, voc√™ precisar√° chamar a fun√ß√£o ZwGetCompleteWnfStateSubscription, que retorna WNF_DELIVERY_DESCRIPTOR. </p><br><p>  Mas essas fun√ß√µes de API de baixo n√≠vel t√™m um problema (obrigado a Gabi por investig√°-lo): cada processo pode ter apenas um evento registrado. </p><br><a name="rtl"></a><br><h3 id="vysokourovnevoe-api-polzovatelskogo-rezhima-ntdll">  API de modo de usu√°rio de alto n√≠vel (ntdll) </h3><br><p>  Quando se trata de notifica√ß√µes, as coisas ficam complicadas, ent√£o a camada rtl do ntdll.dll fornece uma interface mais simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlSubscribeWnfStateChangeNotification</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _Outptr_ PWNF_USER_SUBSCRIPTION* Subscription, _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_ PWNF_USER_CALLBACK Callback, _In_opt_ PVOID CallbackContext, _In_opt_ PCWNF_TYPE_ID TypeId, _In_opt_ ULONG SerializationGroup, _In_opt_ ULONG Unknown )</span></span></span></span>;</code> </pre> <br><p>  De fato, n√£o h√° necessidade de chamar os servi√ßos do sistema diretamente: basta usar uma √∫nica fila de eventos controlada pelo ntdll.dll. </p><br><p>  Nos bastidores, o conte√∫do de WNF_DELIVERY_DESCRIPTOR √© convertido em par√¢metros de retorno de chamada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NTSTATUS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PWNF_USER_CALLBACK)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _In_ WNF_STATE_NAME StateName, _In_ WNF_CHANGE_STAMP ChangeStamp, _In_opt_ PWNF_TYPE_ID TypeId, _In_opt_ PVOID CallbackContext, _In_ PVOID Buffer, _In_ ULONG BufferSize)</span></span></span></span>;</code> </pre> <br><p>  Para cada nova assinatura, √© feita uma entrada, que √© colocada na lista apontada pela vari√°vel global RtlpWnfProcessSubscriptions.  A lista √© criada em um dos campos WNF_NAME_SUBSCRIPTION, do tipo LIST_ENTRY.  Cada um dos WNF_NAME_SUBSCRIPTION, por sua vez, possui outro campo LIST_ENTRY para organizar uma lista de WNF_USER_SUBSCRIPTION com retorno de chamada e contexto. </p><br><a name="kernel"></a><br><h3 id="vysokourovnevoe-api-urovnya-yadra-ex">  API de alto n√≠vel no n√≠vel do kernel (Ex) </h3><br><p>  O WNF tamb√©m fornece fun√ß√µes quase id√™nticas para o c√≥digo do modo kernel (que pode ser usado a partir do driver): atrav√©s de chamadas de sistema exportadas e atrav√©s de fun√ß√µes de API de alto n√≠vel no tempo de execu√ß√£o (camada Ex). </p><br><p>  A fun√ß√£o ExSubscribeWnfStateChange aceita o nome do estado, m√°scaras de tipo e o endere√ßo da fun√ß√£o de retorno de chamada + contexto como uma entrada e retorna um descritor de assinatura.  As fun√ß√µes de retorno de chamada recebem o nome do destino, m√°scara de evento, r√≥tulo de altera√ß√£o, mas n√£o o buffer ou seu tamanho. </p><br><p>  A fun√ß√£o ExQueryWnfStateData, com base no descritor de assinatura passado, l√™ os dados de status atuais.  De fato, cada retorno de chamada acaba chamando a fun√ß√£o ExQueryWnfStateData para obter os dados associados √† notifica√ß√£o. </p><br><p>  Para assinaturas no modo kernel e no modo usu√°rio, o WNF (para rastrear assinaturas) cria uma inst√¢ncia da estrutura WNF_SUBSCRIPTION.  Mas, no modo de usu√°rio, alguns campos n√£o ser√£o preenchidos, por exemplo, retorno de chamada e contexto, porque, no modo de usu√°rio, os endere√ßos dos manipuladores s√£o armazenados e processados ‚Äã‚Äãpelo ntdll.dll. </p><br><a name="data"></a><br><h3 id="struktury-dannyh-wnf">  Estruturas de dados WNF </h3><br><p><img src="https://habrastorage.org/webt/sj/wk/ne/sjwknenp1z89s3xldzz5jlvzidi.jpeg"><br>  <u><em>De um tradutor</em></u> : consulte a pr√≥xima se√ß√£o. </p><br><a name="analyze"></a><br><h3 id="utility-analiza-wnf">  Utilit√°rios de an√°lise WNF </h3><br><p>  <u><em>De um tradutor</em></u> : aqui vale lembrar novamente que a apresenta√ß√£o foi conduzida n√£o apenas por Alex, mas tamb√©m por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gabrielle Viala</a> .  Em particular, sua autoria pertence ao m√≥dulo WnfCom descrito abaixo.  Al√©m disso, Gabrielle descreveu as estruturas internas do WNF em detalhes suficientes (veja a ilustra√ß√£o na se√ß√£o anterior).  Infelizmente, a maioria de seus slides est√° ausente no pdf da apresenta√ß√£o (indicado como original) ou indicado exclusivamente por t√≠tulos.  Mas: </p><br><ul><li>  Esta √© uma excelente ocasi√£o para assistir a uma grava√ß√£o de seu desempenho conjunto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instala√ß√£o de Notifica√ß√£o do Windows: Descascando a Cebola da Superf√≠cie de Ataque de Kernel Mais N√£o Documentada At√©</a> o momento (in√≠cio de Gabrielle ~ 19: 27).  L√° (al√©m das estruturas de dados), haver√° uma hist√≥ria sobre como eles corrigiram a extens√£o do depurador! Wnf (spoiler - usando o m√©todo descrito em The NT Insider - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corrigindo extens√µes quebradas do depurador</a> ) </li><li>  Gabrielle tem um bom artigo separado (detalhado, n√£o como uma apresenta√ß√£o) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jogando com o Windows Notification Facility (WNF)</a> , que tamb√©m √© altamente recomendado para leitura para todos os interessados. </li></ul><br><p>  <u><em>E do tradutor</em></u> : se algu√©m quiser complementar a tradu√ß√£o atual com o conte√∫do dos slides de Gabrielle ou expandir a tradu√ß√£o de taquigrafia de qualquer parte do v√≠deo do discurso - seja bem-vindo.  Para facilitar a adi√ß√£o / altera√ß√£o de grandes blocos, posso publicar a fonte de tradu√ß√£o no github (ou outro servidor de controle de vers√£o). </p><br><a name="wnfcom"></a><br><h4 id="wnfcom">  Wnfcom </h4><br><p>  O WnfCom √© um m√≥dulo python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo fonte do github</a> ) que mostra interoperabilidade atrav√©s do WNF.  Principais recursos: </p><br><ul><li>  permite ler / gravar dados de inst√¢ncias de inst√¢ncia existentes </li><li>  permite criar nomes de estado tempor√°rios (como <em>servidor</em> ) </li><li>  permite obter uma inst√¢ncia de um objeto do lado do <em>cliente</em> que processar√° notifica√ß√µes sobre a altera√ß√£o de uma inst√¢ncia espec√≠fica de um nome </li></ul><br><p>  Exemplo de uso: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfserver = Wnfcom() &gt;&gt;&gt; wnfserver.CreateServer() [SERVER] StateNamecreated: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945 &gt;&gt;&gt; wnfserver.Write(<span class="hljs-string"><span class="hljs-string">b"potatosoup"</span></span>) Encoded Name: <span class="hljs-number"><span class="hljs-number">41</span></span>c64e6da5559945, Clear Name: <span class="hljs-number"><span class="hljs-number">6e99931</span></span> Version: <span class="hljs-number"><span class="hljs-number">1</span></span>, Permanent: No, Scope: Machine, Lifetime: Temporary, Unique: <span class="hljs-number"><span class="hljs-number">56627</span></span> State update: <span class="hljs-number"><span class="hljs-number">11</span></span> bytes written</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> wnfcomimport Wnfcom &gt;&gt;&gt; wnfclient = Wnfcom() &gt;&gt;&gt; wnfclient.SetStateName(<span class="hljs-string"><span class="hljs-string">"41c64e6da5559945"</span></span>) &gt;&gt;&gt; wnfclient.Listen() [CLIENT] Event registered: <span class="hljs-number"><span class="hljs-number">440</span></span> [CLIENT] Timestamp: <span class="hljs-number"><span class="hljs-number">0x1</span></span> Size: <span class="hljs-number"><span class="hljs-number">0xb</span></span> Data:<span class="hljs-number"><span class="hljs-number">00000000</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>F <span class="hljs-number"><span class="hljs-number">75</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> potato soup</code> </pre> <br><a name="wnfdump"></a><br><h4 id="wnfdump">  Wnfdump </h4><br><p>  WnfDump √© um utilit√°rio de linha de comando escrito em C. O arquivo execut√°vel pode ser encontrado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/ionescu007/wnfun</a> selecionando o subdiret√≥rio da profundidade de bits necess√°ria.  O utilit√°rio pode ser usado para procurar informa√ß√µes sobre nomes de estado do WNF: </p><br><ul><li>  -d ( <u>D</u> ump) Despeja todos os nomes de estado WNF usando uma enumera√ß√£o baseada em registro.  Pode ser complementado com op√ß√µes: <br><ul><li>  -v ( <u>V</u> erbose) Uma sa√≠da detalhada que inclui um dump hexadecimal de dados do estado WNF; </li><li>  -s ( <u>S</u> ecurity) Descritores de seguran√ßa - sequ√™ncias de permiss√µes SDDL para o nome do status do WNF. </li></ul></li><li>  -b (For√ßa bruta) Enumera√ß√£o direta de nomes de estado tempor√°rios do WNF (mais sobre isso abaixo) </li><li>  -i (Informa√ß√£o) Exibe informa√ß√µes sobre um √∫nico nome de estado WNF especificado </li><li>  -r (Leia) Leia dados do nome do status WNF especificado </li><li>  -w ( <u>W</u> rite) Grava dados no nome do status WNF especificado </li><li>  -n (Notifica√ß√£o) Registre um assinante de notifica√ß√£o para o nome de status WNF especificado (a seguir, ser√° um caso de uso mais espec√≠fico com o Edge) </li></ul><br><a name="surface"></a><br><h3 id="poverhnost-ataki-na-wnf">  Superf√≠cie de ataque WNF </h3><br><p>  Esta se√ß√£o (mais precisamente, suas subse√ß√µes) discutir√° poss√≠veis ataques e dados sens√≠veis interessantes do WNF. </p><br><a name="disclosure"></a><br><h4 id="raskrytie-privelegirovannyh-dannyh">  Divulga√ß√£o Privilegiada de Dados </h4><br><p>  Lendo os milhares de nomes de estados WNF existentes no sistema, v√°rios podem ser observados, cujos dados parecem muito interessantes.  Entre eles estavam alguns cujos dados s√£o suspeitamente semelhantes a ponteiros ou outros dados privilegiados. </p><br><p>  Depois de jogar em v√°rias m√°quinas, em alguns casos foi poss√≠vel encontrar v√°rias informa√ß√µes privilegiadas que foram divulgadas al√©m dos limites de privil√©gios.  Os relat√≥rios de erros / vulnerabilidades foram enviados ao MSRC em julho, mas foram corrigidos em novembro (ap√≥s a apresenta√ß√£o).  Por exemplo: 4 kilobytes de pilha vazaram atrav√©s do evento WNF_AUDC *! </p><br><p>  Os principais problemas s√£o os mesmos que vimos em estudos anteriores de j00ro, taviso e outros.  Certos nomes de estado WNF cont√™m estruturas de dados codificadas com v√°rios problemas de preenchimento e / ou alinhamento.  Em alguns casos, vazamentos de mem√≥ria n√£o inicializados. <br>  <u><em>Do tradutor</em></u> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o da parte introdut√≥ria do documento Detecting Kernel Memory Disclosure with Emulation x86 and Taint Tracking de Mateusz Jurczyk aka j00ro</a> . </p><br><a name="discovering"></a><br><h4 id="obnaruzhenie-imen-sostoyaniy-i-razresheniy">  Descoberta de nomes e permiss√µes de estado </h4><br><p>  A primeira abordagem foi descobrir todos os nomes de estado poss√≠veis que pudessem ser manipulados maliciosamente.  Para nomes conhecidos, permanentes e persistentes, a enumera√ß√£o √© poss√≠vel enumerando as chaves do Registro.  Em seguida, os valores encontrados podem ser comparados com identificadores amig√°veis ‚Äã‚Äã(existem v√°rios lugares onde voc√™ pode encontr√°-los :)) </p><br><p>  Depois, tamb√©m podemos examinar o descritor de seguran√ßa no registro (esta √© a primeira coisa no buffer de dados).  O descritor de seguran√ßa n√£o √© can√¥nico: ele n√£o possui um propriet√°rio e um grupo, portanto, tecnicamente, n√£o √© v√°lido.  Mas n√£o h√° problema em substituir um propriet√°rio e um grupo falsos para <em>corrigir</em> o descritor de seguran√ßa. </p><br><a name="temporary"></a><br><h4 id="obnaruzhenie-vremennyh-imen-sostoyaniy-i-ih-razresheniy">  Detec√ß√£o de nomes de estado tempor√°rios e suas permiss√µes </h4><br><p>  Mas com nomes tempor√°rios, os truques descritos acima n√£o funcionar√£o: eles n√£o est√£o no registro.  E apenas o kernel armazena estruturas de dados para eles (! Wnf) na mem√≥ria.  Mas nomes tempor√°rios n√£o s√£o t√£o dif√≠ceis de for√ßar: </p><br><ul><li>  Vers√£o sempre importa 1 </li><li>  A vida sempre importa WnfTemporaryStateName </li><li>  O sinalizador permanente √© sempre limpo (o nome do estado tempor√°rio n√£o pode ter dados permanentes) </li><li>  O escopo (escopo) pode assumir um dos 4 valores </li></ul><br><p>  Sim, mas o n√∫mero de sequ√™ncia restante √© de 51 bits!  De fato ... mas n√£o esque√ßa que os n√∫meros de s√©rie est√£o crescendo monotonamente.  E para nomes tempor√°rios, a sequ√™ncia √© redefinida para 0 em cada inicializa√ß√£o.  Convencionalmente, voc√™ pode obter uma janela de um milh√£o de n√∫meros de s√©rie: em um loop, verifique a exist√™ncia de cada nome (come√ßando em 0) chamando ZwQueryWnfStateNameInformation com a classe de informa√ß√µes solicitadas WnfInfoStateNameExist (dado que o erro de acesso tamb√©m indica a exist√™ncia de um nome).  Se n√£o existir outro milh√£o de nomes, voc√™ poder√° interromper a pesquisa. </p><br><p>  Descritores de seguran√ßa de nomes tempor√°rios (como outros dados de nomes tempor√°rios) s√£o armazenados no kernel.  Portanto, a √∫nica maneira de solicit√°-las √© a extens√£o! Wnf ao depurar o modo kernel.  Mas n√≥s podemos: </p><br><ul><li>  Fa√ßa uma conclus√£o sobre permiss√µes de leitura ao tentar ler dados. </li><li>  Concluir que a grava√ß√£o √© permitida tentando gravar dados.  Mas vale a pena considerar que uma grava√ß√£o bem-sucedida de at√© 0 bytes destr√≥i os dados que o consumidor real ainda n√£o conseguiu obter.  E, novamente, h√° um truque: podemos aplicar o carimbo de altera√ß√£o apropriado.  Estamos tentando escrever com o r√≥tulo 0xFFFFFFFF: o r√≥tulo √© verificado ap√≥s a verifica√ß√£o de acesso; portanto, o valor do erro resulta em um vazamento da permiss√£o de grava√ß√£o. </li></ul><br><p>  Isso n√£o nos fornece um descritor de seguran√ßa completo, mas executando o c√≥digo com privil√©gios diferentes, podemos ter uma id√©ia das restri√ß√µes para diferentes contas do sistema (IL baixo / Usu√°rio / Admin / SISTEMA). </p><br><a name="subscribers"></a><br><h4 id="perechislenie-podpischikov">  Listando assinantes </h4><br><p>  Na estrutura WNF_PROCESS_CONTEXT, um dos campos √© o cabe√ßalho da lista (LIST_ENTRY) de todas as assinaturas desse processo.  Cada assinatura √© uma inst√¢ncia separada do WNF_SUBSCRIPTION. </p><br><p>  Os assinantes no modo kernel pertencem principalmente ao processo do sistema.  Podemos usar o comando! List debugger para despejar manipuladores e seus par√¢metros registrados no processo do sistema WNF_SUBSCRIPTION.  Vale ressaltar que, em alguns casos, √© usado um agregador de eventos (CEA.SYS), que oculta os endere√ßos de retorno de chamada reais em sua estrutura de contexto. </p><br><p>  Podemos repetir essa abordagem para processos no modo usu√°rio, mas o endere√ßo de retorno de chamada ser√° NULL, pois s√£o assinantes no modo usu√°rio.  Portanto, precisamos ingressar no espa√ßo do usu√°rio do processo, obter a tabela RtlpWnfProcessSubscriptions e despejar a lista de inst√¢ncias WNF_USER_SUBSCRIPTION, cada uma das quais j√° cont√©m o endere√ßo de retorno de chamada.  Infelizmente, esse caractere √© est√°tico, o que significa que n√£o est√° em caracteres abertos, mas pode ser encontrado desmontando.  E novamente, vale a pena prestar aten√ß√£o (por analogia com o modo de kernel CEA.SYS) que muitos dos manipuladores de modo de usu√°rio usam o agregador de eventos (EventAggregation.dll), que armazena o retorno de chamada em seu contexto. </p><br><a name="sensitive"></a><br><h3 id="interesnye-i-chuvstvitelnye-imena-sostoyaniy-wnf">  Nomes de estado WNF interessantes e sens√≠veis </h3><br><p>  Esta se√ß√£o fornecer√° alguns exemplos interessantes de como alguns nomes de estado do WNF revelam informa√ß√µes do sistema. </p><br><a name="system_state"></a><br><h4 id="opredelenie-sostoyaniya-sistemy-i-povedeniya-polzovatelya-s-pomoschyu-wnf">  Determinando o status do sistema e o comportamento do usu√°rio usando o WNF </h4><br><p>  Alguns identificadores WNF podem ser usados ‚Äã‚Äãpara obter informa√ß√µes sobre o estado da m√°quina que lhe interessa: </p><br><ul><li>  WNF_WIFI_CONNECTION_STATUS - Status sem fio </li><li>  WNF_BLTH_BLUETOOTH_STATUS - da mesma forma, mas para Bluetooth (tamb√©m WNF_TETH_TETHERING_STATE) </li><li>  WNF_UBPM_POWER_SOURCE - mostra a fonte de energia (bateria ou adaptador de energia) </li><li>  WNF_SEB_BATTERY_LEVEL - cont√©m o n√≠vel da bateria </li><li>  WNF_CELL_ * - no Windows Phone cont√©m informa√ß√µes sobre: ‚Äã‚Äãrede, n√∫mero, intensidade do sinal, EDGE ou 3G, ... </li></ul><br><p>   WNF         : </p><br><ul><li> WNF_AUDC_CAPTURE/RENDER ‚Äî   ( PID),   /  </li><li> WNF_TKBN_TOUCH_EVENT ‚Äî    ,       </li><li> WNF_SEB_USER_PRESENT/WNF_SEB_USER_PRESENCE_CHANGED ‚Äî    Windows </li></ul><br><a name="avoiding"></a><br><h4 id="alternativy-standartnym-api-uvedomleniy">   API  </h4><br><p>   ,        API  ,  API , ,      /.     WNF     . ,  ,   WNF      . </p><br><p> : WNF_SHEL_(DESKTOP)_APPLICATION_(STARTED/TERMINATED)      modern- (   ,   )  DCOM,       Win32.      ‚Äî       ShellExecute:    Explorer,   cmd.exe, ... </p><br><p>   ,  WNF    API  ,      : </p><br><ul><li> WNF_SHEL_LOCKSCREEN_ACTIVE ‚Äî     </li><li> WNF_EDGE_LAST_NAVIGATED_HOST ‚Äî   URL,    ( )  Edge </li></ul><br><div class="spoiler"> <b class="spoiler_title">   :      Edge</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6x/mw/uh/6xmwuhsm2ngnwcg6kpp5htsoxby.gif"></p></div></div><br><a name="effect"></a><br><h4 id="vozdeystvie-na-sistemu-s-ispolzovaniem-wnf">      WNF </h4><br><p>    WNF,        . : WNF_FSRL_OPLOCK_BREAK ‚Äî ,    (/),  PID'    ! </p><br><p>       WNF     ,       . : WNF_SHEL_DDC_(WNS/SMS)_COMMAND ‚Äì   4 ,         . </p><br><p>  ,     WNF,      . : WNF_CERT_FLUSH_CACHE_TRIGGER (  ), WNF_BOOT_MEMORY_PARTITIONS_RESTORE, WNF_RTDS_RPC_INTERFACE_TRIGGER_CHANGED, ... </p><br><a name="inject"></a><br><h3 id="vnedrenie-v-process-s-ispolzovaniem-wnf">      WNF </h3><br><p>          : </p><br><ul><li> WriteProcessMemory ‚Äî    </li><li>   ( ) ‚Äî               </li><li>   (Atom) ‚Äî            </li><li>    ‚Äî  ,   WM_COPYDATA  DDE,       </li><li> GUI  ‚Äî    (   )  ,       </li></ul><br><p>  WNF         : </p><br><ul><li>       WNF,      (,        ) </li><li>      Rtl/ZwQueryWnfStateData    WNF </li></ul><br><p>  ,            : </p><br><ul><li> <abbr title="Asynchronous Procedure Call">APC</abbr> s </li><li>       (Remote Threads) </li><li>         (Changing Thread Context) </li><li>  " <em>window long</em> " ‚Äî  ,     ,      </li></ul><br><p>        WNF_USER_SUBSCRIPTION   (     WNF_NAME_SUBSCRIPTION,    RtlpWnfProcessSubscriptions).      ( <abbr title="Control Flow Guard">CFG</abbr> ),         ( 5  6    ). </p><br><p>       ,      :    , ,   ,     -. </p><br><a name="future"></a><br><h3 id="napravleniya-dlya-dalneyshih-issledovaniy">     </h3><br><p>    WNF   SEB_,       ( <u>S</u> ystem <u>E</u> vents <u>B</u> roker). SystemEventsBrokerServer.dll  SystemEventsBrokerClient.dll   API  . ,      SEB     SEB,     . </p><br><p>            CEA.SYS  EventAggregation.dll.    "  " (Event Aggregation Library),     ,      :     ,      ,   WNF             ,         .        WNF,     .        . </p><br><hr><br><p> <u><em> </em></u> :              . </p><br><hr><br><a name="before"></a><br><h3 id="do-prezentacii">   </h3><br><p>   ,   Windows Notification Facility     Alex'  Gabrielle.    ( )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">redp</a> . </p><br><p><img src="https://habrastorage.org/webt/kv/jx/xp/kvjxxppelx9k4zjkqbweh8ukkre.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   WNF</a> (  )   <em>    </em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wincheck</a> .  ,      Gabrielle Viala  ,       redp,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://redplait.blogspot.com/search/label/wnf</a> . </p><br><a name="after"></a><br><h3 id="posle-prezentacii">   </h3><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PoC</a> (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> github</a> )   explorer (  ‚Äî  notepad). <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modexp</a>         :   Callback  WNF_USER_SUBSCRIPTION.      : </p><br><ul><li>    explorer.exe </li><li>    WNF_USER_SUBSCRIPTION </li><li>    RWX-     ,  WriteProcessMemory (,     VirtualAllocEx + WriteProcessMemory) </li><li>     WNF_USER_SUBSCRIPTION (    WriteProcessMemory) </li><li>  ntdll!NtUpdateWnfStateData(...)   ,        </li><li>     WNF_USER_SUBSCRIPTION     </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459626/">https://habr.com/ru/post/pt459626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459616/index.html">MIPT abre o primeiro programa avan√ßado de mestrado da R√∫ssia em Ci√™ncia da Computa√ß√£o e Engenharia de Software</a></li>
<li><a href="../pt459618/index.html">Alguns recursos pouco conhecidos de composi√ß√£o de encaixe</a></li>
<li><a href="../pt459620/index.html">TDDx2, BDD, DDD, FDD, MDD e PDD, ou o que voc√™ quiser saber sobre Desenvolvimento Orientado</a></li>
<li><a href="../pt459622/index.html">Como os jogos para Sega Saturn foram escritos em 1995</a></li>
<li><a href="../pt459624/index.html">Drones militares</a></li>
<li><a href="../pt459628/index.html">A Open Invention Network possui mais de tr√™s mil licenciados - o que significa para software de c√≥digo aberto</a></li>
<li><a href="../pt459630/index.html">Tic Tac Toe Parte 2: Desfazer / Refazer sem estado</a></li>
<li><a href="../pt459638/index.html">Criando uma base global de conhecimento sobre baterias</a></li>
<li><a href="../pt459640/index.html">Documentos como c√≥digo. Parte 1: automatize a atualiza√ß√£o</a></li>
<li><a href="../pt459642/index.html">Acesso seguro para registrar campos em C ++ sem sacrificar a efici√™ncia (usando o CortexM como exemplo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>