<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¶ ‚≠ïÔ∏è üëö Cron sur Linux: historique, utilisation et appareil üë©üèø‚Äçü§ù‚Äçüë®üèæ ‚ÜîÔ∏è üçΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le classique a √©crit que les happy hours ne sont pas observ√©s. Dans ces temps fous, il n'y avait ni programmeurs ni Unix, mais de nos jours les progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron sur Linux: historique, utilisation et appareil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  Le classique a √©crit que les happy hours ne sont pas observ√©s.  Dans ces temps fous, il n'y avait ni programmeurs ni Unix, mais de nos jours les programmeurs le savent tr√®s bien: au lieu d'eux, cron suivra le temps. </p><br><p>  Les utilitaires de ligne de commande sont √† la fois une faiblesse et une routine.  sed, awk, wc, cut et d'autres anciens programmes sont ex√©cut√©s quotidiennement par des scripts sur nos serveurs.  Beaucoup d'entre eux sont con√ßus comme des t√¢ches pour cron, un planificateur des ann√©es 70. </p><br><p>  Pendant longtemps, j'ai utilis√© cron superficiellement, sans entrer dans les d√©tails, mais une fois, ayant rencontr√© une erreur lors de l'ex√©cution du script, j'ai d√©cid√© de le comprendre √† fond.  Cet article est donc apparu, lors de l'√©criture dont j'ai pris connaissance avec POSIX crontab, les principales variantes de cron dans les distributions Linux populaires et le p√©riph√©rique de certaines d'entre elles. </p><br><p>  Utiliser Linux et ex√©cuter des t√¢ches dans cron?  Int√©ress√© par l'architecture d'application du syst√®me Unix?  Alors nous sommes en route! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Origine des esp√®ces</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Best-seller - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cron sur Debian et Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cronie sur Red Hat, Fedora et CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cronie dans SLES et openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dispositif cron Vixie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Postface</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Origine des esp√®ces </h1><br><p>  L'ex√©cution p√©riodique de programmes utilisateur ou syst√®me est un besoin √©vident pour tous les syst√®mes d'exploitation.  Par cons√©quent, le besoin de services qui permettent une planification et une ex√©cution centralis√©es des t√¢ches, les programmeurs ont r√©alis√© depuis tr√®s longtemps. </p><br><p> Les syst√®mes d'exploitation de type Unix ont leur pedigree de la version 7 Unix, d√©velopp√© dans les ann√©es 1970 par Bell Labs, y compris le c√©l√®bre Ken Thompson.  Avec la version 7 Unix, cron, un service pour l'ex√©cution r√©guli√®re des t√¢ches de superutilisateur, a √©galement √©t√© fourni. </p><br><p>  Un cron moderne typique est un programme simple, mais l'algorithme de la version originale √©tait encore plus simple: le service se r√©veillait une fois par minute, lisait la plaque des t√¢ches √† partir d'un seul fichier (/ etc / lib / crontab) et ex√©cutait les t√¢ches qui devaient √™tre effectu√©es pour le superutilisateur √† la minute courante . </p><br><p>  Par la suite, des options avanc√©es pour un service simple et utile sont venues avec tous les syst√®mes d'exploitation de type Unix. </p><br><p>  Des descriptions g√©n√©ralis√©es du format crontab et des principes de base de l'utilitaire en 1992 ont √©t√© incluses dans la norme principale des syst√®mes d'exploitation de type Unix - POSIX - et ainsi le cron de la norme de facto est devenu la norme de jure. </p><br><p>  En 1987, Paul Vixie, apr√®s avoir interrog√© les utilisateurs d'Unix pour des suggestions de cron, a publi√© une autre version du d√©mon qui corrige certains des probl√®mes du cron traditionnel et √©tend la syntaxe des fichiers de table. </p><br><p>  Par la troisi√®me version, Vixie cron a commenc√© √† r√©pondre aux exigences de POSIX, en plus, le programme avait une licence lib√©rale, ou plut√¥t il n'y avait pas de licence du tout, sauf pour les souhaits dans README: l'auteur ne donne aucune garantie, vous ne pouvez pas supprimer le nom de l'auteur, et vous ne pouvez vendre le programme qu'avec code source.  Ces exigences se sont av√©r√©es compatibles avec les principes du logiciel libre, qui gagnait en popularit√© au cours de ces ann√©es, de sorte que certaines des principales distributions Linux apparues au d√©but des ann√©es 90 ont pris Vixie cron comme syst√®me et le d√©veloppent toujours. </p><br><p>  En particulier, Red Hat et SUSE d√©veloppent la fourchette cron-cronie Vixie, tandis que Debian et Ubuntu utilisent la cron Vixie originale avec de nombreux correctifs. </p><br><p>  Tout d'abord, familiarisons-nous avec l'utilitaire crontab d√©fini par l'utilisateur d√©crit dans POSIX, apr√®s quoi nous analyserons les extensions de syntaxe pr√©sent√©es dans Vixie cron et l'utilisation des variations de Vixie cron dans les distributions Linux populaires.  Et enfin, la cerise sur le g√¢teau est une analyse du p√©riph√©rique d√©mon cron. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Si le cron d'origine a toujours fonctionn√© pour le superutilisateur, les planificateurs modernes s'occupent souvent des t√¢ches des utilisateurs ordinaires, ce qui est plus s√ªr et plus pratique. </p><br><p>  Les cron sont livr√©s avec un ensemble de deux programmes: le d√©mon cron en cours d'ex√©cution et l'utilitaire crontab disponibles pour les utilisateurs.  Ce dernier vous permet de modifier les tables de t√¢ches sp√©cifiques √† chaque utilisateur du syst√®me, tandis que le d√©mon d√©marre les t√¢ches √† partir des tables utilisateur et syst√®me. </p><br><p>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">standard POSIX</a> ne d√©crit pas le comportement du d√©mon, et seul le programme utilisateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crontab</a> est formalis√©.  L'existence de m√©canismes de lancement des t√¢ches utilisateur, bien s√ªr, est implicite, mais n'est pas d√©crite en d√©tail. </p><br><p>  Il y a quatre choses que vous pouvez faire avec l'utilitaire crontab: modifier la table des t√¢ches utilisateur dans l'√©diteur, charger la table √† partir du fichier, afficher la table des t√¢ches actuelle et effacer la table des t√¢ches.  Exemples de l'utilitaire crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Lors de l'appel de <code>crontab -e</code> , l'√©diteur sp√©cifi√© dans la <code>EDITOR</code> environnement <code>EDITOR</code> standard sera utilis√©. </p><br><p>  Les t√¢ches elles-m√™mes sont d√©crites dans le format suivant: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Les cinq premiers champs d'enregistrement: minutes [1..60], heures [0..23], jours du mois [1..31], mois [1..12], jours de la semaine [0..6], o√π 0 - dimanche.  Le dernier, sixi√®me champ, est une cha√Æne qui sera ex√©cut√©e par l'interpr√©teur de commandes standard. </p><br><p>  Dans les cinq premiers champs, les valeurs peuvent √™tre r√©pertori√©es avec une virgule: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Ou par un tiret: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  L'acc√®s des utilisateurs √† la planification des t√¢ches est r√©glement√© dans les fichiers POSIX cron.allow et cron.deny qui r√©pertorient respectivement les utilisateurs ayant acc√®s √† crontab et les utilisateurs n'ayant pas acc√®s au programme.  La norme ne r√©glemente pas l'emplacement de ces fichiers. </p><br><p>  Les programmes en cours d'ex√©cution, conform√©ment √† la norme, doivent recevoir au moins quatre variables d'environnement: </p><br><ol><li>  HOME est le r√©pertoire personnel de l'utilisateur. </li><li>  LOGNAME - connexion utilisateur. </li><li>  PATH est le chemin par lequel trouver les utilitaires syst√®me standard. </li><li>  SHELL est le chemin vers le shell utilis√©. </li></ol><br><p>  Il est √† noter que POSIX ne dit rien sur la provenance des valeurs de ces variables. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Best-seller - Vixie cron 3.0pl1 </h1><br><p>  L'anc√™tre commun des variantes cron populaires est Vixie cron 3.0pl1, pr√©sent√© sur la liste de diffusion comp.sources.unix de 1992.  Nous examinerons plus en d√©tail les principales caract√©ristiques de cette version. </p><br><p>  Vixie cron est disponible en deux programmes (cron et crontab).  Comme d'habitude, le d√©mon est responsable de la lecture et du d√©marrage des t√¢ches √† partir de la table des t√¢ches syst√®me et des tables des t√¢ches des utilisateurs individuels, et l'utilitaire crontab est responsable de la modification des tables utilisateur. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Table des t√¢ches et fichiers de configuration </h3><br><p>  La table des t√¢ches du superutilisateur se trouve dans / etc / crontab.  La syntaxe de la table syst√®me correspond √† la syntaxe de Vixie cron, ajust√©e du fait que la sixi√®me colonne indique le nom de l'utilisateur pour le compte duquel la t√¢che est lanc√©e: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  Les tables de t√¢ches utilisateur courantes se trouvent dans / var / cron / tabs / username et utilisent une syntaxe commune.  Lorsque l'utilitaire crontab est lanc√©, ces fichiers sont modifi√©s au nom de l'utilisateur. </p><br><p>  Les listes d'utilisateurs ayant acc√®s √† crontab sont g√©r√©es dans les fichiers / var / cron / allow et / var / cron / deny, o√π il suffit d'ajouter le nom d'utilisateur sur une ligne distincte. </p><br><h3 id="rasshirennyy-sintaksis">  Syntaxe √©tendue </h3><br><p>  Par rapport √† la crontab POSIX, la solution de Paul Vixie contient plusieurs modifications tr√®s utiles √† la syntaxe de la table des t√¢ches utilitaires. </p><br><p>  Une nouvelle syntaxe de table est devenue disponible: par exemple, vous pouvez sp√©cifier des jours de la semaine ou des mois par nom (Lun, Mar, etc.): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Vous pouvez sp√©cifier l'√©tape √† travers laquelle les t√¢ches sont lanc√©es: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Les √©tapes et les intervalles peuvent √™tre m√©lang√©s: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Des alternatives intuitives √† la syntaxe r√©guli√®re sont prises en charge (red√©marrage, annuel, annuel, mensuel, hebdomadaire, quotidien, minuit, horaire): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Environnement d'ex√©cution des t√¢ches </h3><br><p>  Vixie cron vous permet de changer l'environnement des applications en cours d'ex√©cution. </p><br><p>  Les variables d'environnement USER, LOGNAME et HOME ne sont pas seulement fournies par le d√©mon, mais sont extraites du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier passwd</a> .  La variable PATH obtient la valeur "/ usr / bin: / bin" et SHELL obtient la valeur "/ bin / sh".  Les valeurs de toutes les variables sauf LOGNAME peuvent √™tre modifi√©es dans les tables utilisateur. </p><br><p>  Certaines variables d'environnement (principalement SHELL et HOME) sont utilis√©es par cron lui-m√™me pour ex√©cuter la t√¢che.  Voici √† quoi ressemble bash au lieu du sh standard pour ex√©cuter des t√¢ches personnalis√©es: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  En fin de compte, toutes les variables d'environnement d√©finies dans le tableau (utilis√©es par cron ou n√©cessaires au processus) seront transf√©r√©es vers la t√¢che en cours d'ex√©cution. </p><br><p>  L'utilitaire crontab utilise l'√©diteur sp√©cifi√© dans la variable d'environnement VISUAL ou EDITOR pour modifier des fichiers.  Si ces variables ne sont pas d√©finies dans l'environnement o√π crontab a √©t√© lanc√©, alors "/ usr / ucb / vi" est utilis√© (ucb est probablement l'Universit√© de Californie, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  cron sur Debian et Ubuntu </h1><br><p>  Debian et les d√©veloppeurs de d√©riv√©s ont publi√© une version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hautement modifi√©e</a> de Vixie cron version 3.0pl1.  Il n'y a aucune diff√©rence dans la syntaxe des fichiers de table; pour les utilisateurs, il s'agit du m√™me cron Vixie.  Nouvelles fonctionnalit√©s les plus importantes: prise en charge de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syslog</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SELinux</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PAM</a> . </p><br><p>  Parmi les changements moins visibles, mais tangibles - l'emplacement des fichiers de configuration et des tables de t√¢ches. </p><br><p>  Les tables utilisateur dans Debian sont situ√©es dans le r√©pertoire / var / spool / cron / crontabs, la table syst√®me est toujours l√† dans / etc / crontab.  Les tables de t√¢ches sp√©cifiques √† Debian sont plac√©es dans /etc/cron.d, d'o√π le d√©mon cron les lit automatiquement.  Le contr√¥le d'acc√®s des utilisateurs est r√©glement√© par les fichiers /etc/cron.allow et /etc/cron.deny. </p><br><p>  Le shell / bin / sh par d√©faut est toujours utilis√© comme shell par d√©faut. Debian agit comme un petit shell de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de bord</a> compatible POSIX lanc√© sans lire aucune configuration (en mode non interactif). </p><br><p>  Cron lui-m√™me dans les derni√®res versions de Debian est lanc√© via systemd, et la configuration de lancement peut √™tre consult√©e dans /lib/systemd/system/cron.service.  Il n'y a rien de sp√©cial dans la configuration du service; toute gestion plus fine des t√¢ches peut se faire via des variables d'environnement d√©clar√©es directement dans la crontab de chaque utilisateur. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie sur RedHat, Fedora et CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cronie</a> - fork de Vixie cron version 4.1.  Comme dans Debian, la syntaxe n'a pas chang√©, mais la prise en charge de PAM et SELinux, travaillant dans un cluster, le suivi des fichiers √† l'aide d'inotify et d'autres fonctionnalit√©s ont √©t√© ajout√©es. </p><br><p>  La configuration par d√©faut est aux endroits habituels: la table syst√®me est dans / etc / crontab, les packages mettent leurs tables dans /etc/cron.d, les tables utilisateur sont dans / var / spool / cron / crontabs. </p><br><p>  Le d√©mon s'ex√©cute sous systemd, la configuration du service est /lib/systemd/system/crond.service. </p><br><p>  Au d√©marrage, les distributions de type Red Hat utilisent / bin / sh par d√©faut, dont le r√¥le est bash standard.  Il convient de noter que lors de l'ex√©cution de t√¢ches cron via / bin / sh, le shell bash d√©marre en mode compatible POSIX et ne lit aucune configuration suppl√©mentaire lorsqu'il fonctionne en mode non interactif. </p><br><h1 id="cronie-v-sles-i-opensuse">  cronie dans SLES et openSUSE </h1><br><p>  La distribution SLES allemande et son d√©riv√© openSUSE utilisent le m√™me cronie.  Le d√©mon s'ex√©cute ici √©galement sous systemd, la configuration du service se trouve dans /usr/lib/systemd/system/cron.service.  Configuration: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  Comme / bin / sh agit de la m√™me mani√®re, lanc√© en mode non interactif compatible POSIX. </p><br><h1 id="ustroystvo-vixie-cron">  Dispositif cron Vixie </h1><br><p>  Les descendants modernes de cron n'ont pas chang√© radicalement par rapport au cron Vixie, mais ils ont n√©anmoins acquis de nouvelles capacit√©s qui ne sont pas n√©cessaires pour comprendre les principes du programme.  Beaucoup de ces extensions sont d√©sordonn√©es et confondent le code.  Le code source original de cron par Paul Vixie est un plaisir √† lire. </p><br><p>  Par cons√©quent, j'ai d√©cid√© d'analyser le p√©riph√©rique cron en utilisant l'exemple d'un programme commun pour les deux branches du d√©veloppement cron - Vixie cron 3.0pl1.  Je vais simplifier les exemples en supprimant les ifdefs qui compliquent la lecture et en omettant les d√©tails secondaires. </p><br><p>  Le travail du d√©mon peut √™tre divis√© en plusieurs √©tapes: </p><br><ol><li>  Initialisation du programme. </li><li>  Collectez et mettez √† jour la liste des t√¢ches √† ex√©cuter. </li><li>  L'op√©ration principale de boucle cron. </li><li>  Lancement de la t√¢che. </li></ol><br><p>  Trions-les dans l'ordre. </p><br><h3 id="inicializaciya">  Initialisation </h3><br><p>  Une fois lanc√©, apr√®s avoir v√©rifi√© les arguments du processus, cron installe les gestionnaires de signaux SIGCHLD et SIGHUP.  Le premier enregistre la fin du processus enfant, le second ferme le descripteur de fichier du fichier journal: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  Le d√©mon cron du syst√®me fonctionne toujours seul, uniquement en tant que superutilisateur et √† partir du r√©pertoire principal cron.  Les appels suivants cr√©ent un verrou de fichier avec le PID du processus d√©mon, assurez-vous que l'utilisateur est correct et changez le r√©pertoire en cours en celui principal: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  Le chemin par d√©faut est d√©fini, qui sera utilis√© lors du d√©marrage des processus: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Ensuite, le processus est ¬´diabolis√©¬ª: il cr√©e une copie enfant du processus en appelant fork et une nouvelle session dans le processus enfant (en appelant setsid).  Il n'y a plus besoin du processus parent - et il termine le travail: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  La fin du processus parent lib√®re le verrou sur le fichier de verrouillage.  De plus, vous devez mettre √† jour le PID dans le fichier pour l'enfant.  Apr√®s cela, la base de donn√©es des t√¢ches est remplie: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  Plus de cron passe au cycle de travail principal.  Mais avant cela, jetez un ≈ìil au chargement de la liste des t√¢ches. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Collecte et mise √† jour de la liste des t√¢ches </h3><br><p>  La fonction load_database est responsable du chargement de la liste des t√¢ches.  Il v√©rifie la crontab du syst√®me principal et le r√©pertoire avec les fichiers utilisateur.  Si les fichiers et le r√©pertoire n'ont pas chang√©, la liste des t√¢ches n'est pas relue.  Sinon, une nouvelle liste de t√¢ches commence √† se former. </p><br><p>  T√©l√©chargement d'un fichier syst√®me avec des noms de fichiers et de tables sp√©ciaux: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Chargement des tables utilisateur dans une boucle: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Ensuite, l'ancienne base de donn√©es est remplac√©e par une nouvelle. </p><br><p>  Dans les exemples ci-dessus, l'appel de la fonction process_crontab garantit que l'utilisateur existe qui correspond au nom du fichier de table (sauf s'il s'agit du superutilisateur), puis appelle load_user.  Ce dernier lit d√©j√† le fichier lui-m√™me ligne par ligne: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Ici, soit la variable d'environnement (lignes de la forme VAR = valeur) est d√©finie par les fonctions load_env / env_set, soit la description de la t√¢che (* * * * * / path / to / exec) est lue par la fonction load_entry. </p><br><p>  L'entit√© d'entr√©e renvoy√©e par load_entry est notre t√¢che plac√©e dans la liste g√©n√©rale des t√¢ches.  Dans la fonction elle-m√™me, une longue analyse du format de l'heure est effectu√©e, mais nous nous int√©ressons davantage √† la formation des variables d'environnement et des param√®tres de lancement des t√¢ches: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  Le cycle principal fonctionne √©galement avec la liste actuelle des t√¢ches. </p><br><h3 id="glavnyy-cikl">  Cycle principal </h3><br><p>  Le cron original de la version 7 Unix fonctionnait tout simplement: dans un cycle, j'ai relu la configuration, ex√©cut√© les t√¢ches de la minute actuelle en tant que superutilisateur et dormi jusqu'√† ce que la minute suivante commence.  Cette approche simple sur des machines plus anciennes n√©cessitait trop de ressources. </p><br><p>  Une version alternative a √©t√© propos√©e dans SysV, dans laquelle le d√©mon s'est endormi soit jusqu'√† la minute suivante, pour laquelle la t√¢che a √©t√© d√©finie, soit pendant 30 minutes.  Les ressources pour relire la configuration et v√©rifier les t√¢ches dans ce mode √©taient moins consomm√©es, mais il √©tait devenu g√™nant de mettre √† jour rapidement la liste des t√¢ches. </p><br><p>  Vixie cron a recommenc√© √† v√©rifier les listes de t√¢ches une fois par minute, car √† la fin des ann√©es 80, les ressources sur les machines Unix standard √©taient devenues beaucoup plus importantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  La fonction cron_sleep, qui appelle les fonctions job_runqueue (√©num√©ration et d√©but des t√¢ches) et do_command (d√©but de chaque t√¢che individuelle), est directement impliqu√©e dans l'ex√©cution des t√¢ches.  La derni√®re fonction doit √™tre consid√©r√©e plus en d√©tail. </p><br><h3 id="zapusk-zadachi">  Lancement de la t√¢che </h3><br><p>  La fonction do_command est ex√©cut√©e dans un bon style Unix, c'est-√†-dire qu'elle effectue un fork pour l'ex√©cution de t√¢ches asynchrones.  Le processus parent continue de lancer des t√¢ches, le processus enfant pr√©pare le processus de t√¢che: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Il y a beaucoup de logique dans child_process: il prend la sortie standard et les flux d'erreurs sur lui-m√™me, de sorte qu'il peut ensuite √™tre envoy√© par courrier (si la variable d'environnement MAILTO est sp√©cifi√©e dans la table des t√¢ches), et, enfin, il attend que le processus de t√¢che principale se termine. </p><br><p>  Le processus de t√¢che est form√© par un autre fork: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äî    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Ici, en g√©n√©ral, et tout le cron.  J'ai omis certains d√©tails int√©ressants, par exemple, la comptabilit√© des utilisateurs distants, mais j'ai soulign√© l'essentiel. </p><br><h1 id="posleslovie">  Postface </h1><br><p>  Cron est un programme √©tonnamment simple et utile, fabriqu√© dans les meilleures traditions du monde Unix.  Elle ne fait rien de superflu, mais elle fait remarquablement son travail depuis plusieurs d√©cennies.  Apprendre √† conna√Ætre le code de la version fournie avec Ubuntu n'a pas pris plus d'une heure et je me suis beaucoup amus√©!  J'esp√®re que je pourrais le partager avec vous. </p><br><p>  Je ne sais pas pour vous, mais c'est un peu triste pour moi de r√©aliser que la programmation moderne, avec sa tendance √† se compliquer et √† se r√©sumer, a depuis longtemps cess√© d'avoir une telle simplicit√©. </p><br><p>  Il existe de nombreuses alternatives modernes √† cron: systemd-timers vous permet d'organiser des syst√®mes complexes avec des d√©pendances, dans fcron vous pouvez contr√¥ler de mani√®re plus flexible la consommation de ressources par t√¢ches.  Mais personnellement, j'ai toujours eu le crontab le plus simple. </p><br><p>  En un mot, adorez Unix, utilisez des programmes simples et n'oubliez pas de lire du mana pour votre plateforme! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468061/">https://habr.com/ru/post/fr468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468049/index.html">Utilisation de werf pour d√©ployer des graphiques Helm complexes</a></li>
<li><a href="../fr468051/index.html">VDS avec Windows Server sous licence pour 100 roubles: mythe ou r√©alit√©?</a></li>
<li><a href="../fr468053/index.html">Apprentissage automatique pour votre chasse √† plat. Partie 1</a></li>
<li><a href="../fr468057/index.html">D√©veloppement de syst√®me d'exploitation de type Unix - Multit√¢che et appels syst√®me (7)</a></li>
<li><a href="../fr468059/index.html">Ma deuxi√®me semaine avec Haiku: beaucoup de diamants cach√©s et d'agr√©ables surprises, ainsi que quelques probl√®mes</a></li>
<li><a href="../fr468063/index.html">Angulareact</a></li>
<li><a href="../fr468067/index.html">Fonctionnement de la composition alpha</a></li>
<li><a href="../fr468071/index.html">Eduard Medvedev, CTO chez Tungsten Labs: ¬´Nous avons grandi au point o√π la technologie peut causer des dommages consid√©rables¬ª</a></li>
<li><a href="../fr468073/index.html">Andrei Terekhov: "Vous pouvez dire autant que vous le souhaitez que l'Am√©ricain est meilleur, mais notre voiture ne tombe jamais en panne"</a></li>
<li><a href="../fr468075/index.html">L'utilisation des r√©seaux de neurones siamois dans la recherche</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>