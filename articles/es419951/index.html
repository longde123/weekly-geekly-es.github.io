<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò£Ô∏è üòã üöî Experiencia usando WebRTC. Conferencia de Yandex üßí üêí ‚ùì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQu√© es mejor usar al desarrollar software: tecnolog√≠as nativas o web? Holivar sobre este tema no terminar√° pronto, pero pocos argumentar√°n que es √∫ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Experiencia usando WebRTC. Conferencia de Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/419951/">  ¬øQu√© es mejor usar al desarrollar software: tecnolog√≠as nativas o web?  Holivar sobre este tema no terminar√° pronto, pero pocos argumentar√°n que es √∫til duplicar funciones nativas para usar en navegadores o WebView.  Y si antes las aplicaciones para llamadas exist√≠an exclusivamente por separado del navegador, ahora son f√°ciles de implementar en la web.  El desarrollador Grigory Kuznetsov explic√≥ c√≥mo usar la tecnolog√≠a WebRTC para las conexiones P2P. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_Jvdi--GtOg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Como todos saben, en los √∫ltimos a√±os hay muchas aplicaciones basadas en el intercambio directo de datos entre dos navegadores, es decir, P2P.  Estos son todo tipo de mensajer√≠a instant√°nea, chats, marcadores, videoconferencias.  Tambi√©n pueden ser aplicaciones que realizan alg√∫n tipo de computaci√≥n distribuida.  Los l√≠mites de la fantas√≠a no est√°n limitados de ninguna manera. <br><a name="habracut"></a><br>  ¬øC√≥mo hacemos tal tecnolog√≠a?  Imagine que queremos hacer una llamada de un navegador a otro.  E imagine qu√© pasos necesitamos para lograr este objetivo.  En primer lugar, parece que la llamada es nuestra imagen, nuestra voz, imagen, y necesitamos tener acceso a los dispositivos multimedia conectados a la computadora: a la c√°mara y al micr√≥fono.  Despu√©s de obtener acceso, necesita sus dos navegadores, dos clientes, para encontrarse.  Es necesario ayudarlos de alguna manera a conectarse, llegar, transmitir metainformaci√≥n. <br><br>  Cuando llegue, debe comenzar a transferir datos en modo P2P, es decir, para garantizar la transmisi√≥n de flujos de medios.  Tenemos todos los elementos necesarios, estamos listos para implementar nuestra nueva bicicleta genial.  Pero esto es una broma, somos ingenieros y entendemos que es costoso, injustificado y arriesgado.  Por lo tanto, como ingenieros cl√°sicos, primero pensemos en las soluciones que ya existen. <br><br>  En primer lugar, la vieja tecnolog√≠a Adobe Flash que se est√° muriendo.  Ella realmente se est√° muriendo, y Adobe dejar√° de apoyarlo para 2020.  La tecnolog√≠a realmente le permitir√° acceder a sus dispositivos multimedia, en su interior puede implementar todas las mec√°nicas necesarias para ayudar a los navegadores a conectarse, para que comiencen a transmitir informaci√≥n P2P, pero inventar√° su bicicleta nuevamente, porque no hay un est√°ndar √∫nico, un enfoque √∫nico para implementar este m√©todo transferencia de datos <br><br>  Puedes escribir un complemento de navegador.  As√≠ es como funciona Skype para aquellos navegadores que no admiten tecnolog√≠as m√°s modernas.  Tendr√° que implementar su bicicleta, porque no hay un est√°ndar √∫nico, y tambi√©n es malo para los usuarios, ya que el usuario tendr√° que instalar alg√∫n tipo de complemento en su navegador, realizar acciones adicionales.  A los usuarios no les gusta esto y no quieren hacerlo. <br><br>  Y hay tecnolog√≠a WebRTC: Google Hangouts, Facebook Messenger trabajan con ella.  Voximplant lo usa para que pueda hacer sus llamadas.  Analicemos con m√°s detalle.  Esta es una nueva tecnolog√≠a en desarrollo, apareci√≥ en 2011 y contin√∫a desarroll√°ndose.  ¬øQu√© le permite hacer ella?  Obtenga acceso a la c√°mara y al micr√≥fono.  Establezca una conexi√≥n P2P entre dos computadoras, dos navegadores.  Naturalmente, le permite transferir transmisiones de medios en tiempo real.  Adem√°s, le permite transferir informaci√≥n, es decir, cualquier fecha binaria, tambi√©n puede transmitir P2P, puede hacer su propio sistema inform√°tico distribuido. <br><br>  Un punto importante: WebRTC no proporciona a los navegadores una forma de encontrarse.  Podemos generar toda la metainformaci√≥n necesaria sobre nuestros seres queridos, pero ¬øc√≥mo puede un navegador aprender sobre la existencia de otro?  ¬øC√≥mo conectarlos?  Considera un ejemplo. <br><br><img src="https://habrastorage.org/webt/8l/dc/lu/8ldclukfmmhiyusud1ftwkmvmi0.png"><br><br>  Hay dos clientes  El primer cliente quiere hacer una llamada al segundo cliente.  WebRTC le brinda toda la informaci√≥n que necesita para identificarse.  Pero la pregunta sigue siendo c√≥mo encontrar otro navegador, c√≥mo enviar esta metainformaci√≥n, c√≥mo inicializar la llamada.  Esto est√° a merced de los desarrolladores, podemos usar absolutamente cualquier m√©todo, tomar esta metainformaci√≥n, imprimirla en una hoja de papel, enviarla por mensajer√≠a, otra la usar√° y todo funcionar√°. <br><br>  Y podemos encontrar alg√∫n mecanismo de se√±alizaci√≥n.  En este caso, este es un mecanismo de terceros que nos permitir√°, si conocemos a nuestros clientes, garantizar la transferencia entre ellos de la informaci√≥n necesaria para establecer una conexi√≥n. <br><br>  Considere un ejemplo usando un servidor de se√±al.  Hay un servidor de se√±al que mantiene una conexi√≥n constante con nuestros clientes, por ejemplo, a trav√©s de sockets web o usando HTTP.  El primer cliente genera metainformaci√≥n y la env√≠a al servidor de se√±ales mediante sockets web o HTTP.  Tambi√©n env√≠a una parte de la informaci√≥n con la que desea conectarse, por ejemplo, un apodo o alguna otra informaci√≥n. <br><br>  El servidor de se√±ales que usa este identificador determina qu√© cliente necesita redirigir nuestra metainformaci√≥n y la reenv√≠a.  El segundo cliente lo toma, lo usa, se instala, forma una respuesta y, utilizando el mecanismo de se√±alizaci√≥n, lo env√≠a al servidor de se√±al, que a su vez lo transmite al primer cliente.  Por lo tanto, ambos clientes tienen actualmente toda la fecha y metainformaci√≥n necesarias para establecer una conexi√≥n P2P.  Listo <br><br>  Echemos un vistazo m√°s de cerca a lo que intercambian exactamente los clientes; est√°n intercambiando un datagrama SDP, Protocolo de descripci√≥n de sesi√≥n. <br><br><img src="https://habrastorage.org/webt/zl/e-/ok/zle-oknfv3cz36cwgdbt00ldc4q.png"><br><br>  Este es esencialmente un archivo de texto que contiene toda la informaci√≥n necesaria para establecer una conexi√≥n.  Hay informaci√≥n sobre la direcci√≥n IP, sobre los puertos que se usan, sobre qu√© tipo de informaci√≥n se est√° persiguiendo entre clientes, qu√© es: audio, video, qu√© c√≥decs se usan.  Todo lo que necesitamos est√° ah√≠. <br><br>  Presta atenci√≥n a la segunda l√≠nea.  Muestra la direcci√≥n IP del cliente, 192.168.0.15.  Obviamente, esta es la direcci√≥n IP de una computadora que est√° en alguna red local.  Si tenemos dos computadoras, cada una de las cuales est√° en la red local, cada una de las cuales conoce su direcci√≥n IP dentro de esta red, quieren llamar.  ¬øSer√°n capaces de hacer esto con tal datagrama?  Obviamente no, no conocen las direcciones IP externas.  Como ser <br><br><img src="https://habrastorage.org/webt/6j/ol/xu/6jolxumekywnyr1txfh6vdhjk-a.png"><br><br>  Hagamos a un lado y veamos c√≥mo funciona NAT.  En Internet, muchas computadoras est√°n ocultas detr√°s de los enrutadores.  Hay redes locales dentro de las cuales las computadoras conocen sus direcciones, hay un enrutador que tiene una direcci√≥n IP externa y todas estas computadoras se destacan con la direcci√≥n IP de este enrutador.  Cuando un paquete de una computadora en la red local va al enrutador, el enrutador mira a d√≥nde debe reenviarse.  Si se encuentra en otra de esta red local, simplemente la retransmite, y si necesita enviarla al exterior, a Internet, se compila una tabla de enrutamiento. <br><br><img src="https://habrastorage.org/webt/0c/w3/vj/0cw3vj67zemxzrbjwe5cr0bfzvc.png"><br><br>  Completamos la direcci√≥n IP interna de la computadora que desea reenviar el paquete, su puerto, establecer la direcci√≥n IP externa, la direcci√≥n IP del enrutador y tambi√©n hacer un cambio de puerto.  Para que sirve  Imagine que dos computadoras est√°n accediendo al mismo recurso, y necesitamos enrutar correctamente los paquetes de respuesta.  Los identificaremos por puerto, el puerto ser√° √∫nico para cada una de las computadoras, mientras que la direcci√≥n IP externa coincidir√°. <br><br>  ¬øC√≥mo vivir si hay NAT, si las computadoras sobresalen bajo la misma direcci√≥n IP, pero en el interior se conocen entre s√≠? <br><br>  El marco ICE para el establecimiento de conectividad a Internet viene al rescate.  Describe formas de omitir NAT, c√≥mo establecer una conexi√≥n si tenemos NAT. <br><br>  Este marco utiliza el llamado atributo del servidor STUN. <br><br><img src="https://habrastorage.org/webt/59/zv/am/59zvamcoxdislwvhlj3qkn2k_cq.png"><br><br>  Este es un servidor tan especial, en referencia al cual, puede encontrar su direcci√≥n IP externa.  Por lo tanto, en el proceso de establecer una conexi√≥n P2P, cada cliente debe realizar una solicitud a este servidor STUN para averiguar su direcci√≥n IP y generar informaci√≥n adicional, IceCandidate e intercambiar IceCandidate con el mecanismo de se√±alizaci√≥n.  Luego, los clientes se conocer√°n unos a otros con las direcciones IP correctas y podr√°n establecer una conexi√≥n P2P. <br><br>  Sin embargo, hay casos m√°s complicados.  Por ejemplo, cuando la computadora est√° oculta detr√°s del doble NAT.  En este caso, el marco ICE requiere el uso de un servidor TURN. <br><br><img src="https://habrastorage.org/webt/yd/0r/j3/yd0rj3j5touybbu9ji2yxajvu0w.png"><br><br>  Este es un servidor tan especial que convierte una conexi√≥n cliente-cliente, P2P, en una conexi√≥n cliente-servidor-cliente, es decir, act√∫a como un rel√©.  La buena noticia para los desarrolladores es que, independientemente de cu√°l de los tres escenarios se realiz√≥ la conexi√≥n, si estamos en la red local, si necesitamos recurrir a un servidor STUN o TURN, la tecnolog√≠a API ser√° id√©ntica para nosotros.  Simplemente indicamos al principio la configuraci√≥n de los servidores ICE y TURN, indicamos c√≥mo acceder a ellos, y luego la tecnolog√≠a hace todo por nosotros bajo el cap√≥. <br><br><img src="https://habrastorage.org/webt/u5/gm/d3/u5gmd3hsoofg6zt_-gnop6nx0zs.png"><br><br>  Un breve resumen  Para establecer una conexi√≥n, debe seleccionar e implementar alg√∫n tipo de mecanismo de se√±alizaci√≥n, un cierto intermediario que nos ayudar√° a enviar metainformaci√≥n.  WebRTC nos dar√° todo el meta necesario para esto. <br><br>  Tenemos que luchar con NAT, este es nuestro principal enemigo en esta etapa.  Pero para evitarlo, usamos el servidor STUN para averiguar nuestra direcci√≥n IP externa, y usamos el servidor TURN como un rel√©. <br><br>  ¬øQu√© estamos transmitiendo exactamente?  Sobre las transmisiones de medios. <br><br><img src="https://habrastorage.org/webt/qd/5n/sh/qd5nsho7njp_zbptyvvgxzgyeyk.png"><br><br>  Las transmisiones multimedia son canales que contienen pistas dentro de s√≠ mismos.  Las pistas dentro del flujo de medios est√°n sincronizadas.  El audio y el video no divergir√°n, vendr√°n con un solo momento.  Puede hacer cualquier cantidad de pistas dentro de la transmisi√≥n de medios, las pistas se pueden controlar por separado, por ejemplo, puede silenciar el audio, dejando solo una imagen.  Tambi√©n puede transferir cualquier cantidad de transmisiones multimedia, lo que le permite, por ejemplo, implementar una conferencia. <br><br>  ¬øC√≥mo acceder a los medios desde un navegador?  Hablemos de la API. <br><br><img src="https://habrastorage.org/webt/xd/li/lw/xdlilwqq1hvfwsmpzbo2abyu22i.png"><br><br>  Hay un m√©todo getUserMedia que acepta un conjunto de constantes como entrada.  Este es un objeto especial donde usted indica a qu√© dispositivos desea acceder, qu√© c√°mara, qu√© micr√≥fono.  Usted especifica las caracter√≠sticas que desea tener, qu√© resoluci√≥n, y tambi√©n hay dos argumentos: successCallback y errorCallback, que se llama en caso de √©xito o falla.  Las implementaciones de tecnolog√≠a m√°s modernas usan promesas. <br><br>  Tambi√©n hay un m√©todo conveniente enumerateDevices que devuelve una lista de todos los dispositivos multimedia conectados a su computadora, que le brinda la oportunidad de mostr√°rselos al usuario, dibuje alg√∫n tipo de selector para que el usuario elija qu√© c√°mara en particular quiere usar. <br><br><img src="https://habrastorage.org/webt/ga/vp/uo/gavpuolkqqbou4mgkr5nkgyn_ga.png"><br><br>  El objeto central en la API es RTCPeerConnection.  Cuando hacemos la conexi√≥n, tomamos la clase RTCPeerConnection, que devuelve el objeto peerConnection.  Como configuraci√≥n, especificamos un conjunto de servidores ICE, es decir, servidores STUN y TURN, a los que accederemos durante el proceso de instalaci√≥n.  Y hay un evento onicecandidate importante que se dispara cada vez que necesitamos la ayuda de nuestro mecanismo de se√±alizaci√≥n.  Es decir, la tecnolog√≠a WebRTC realiz√≥ una solicitud, por ejemplo, a un servidor STUN, reconocimos nuestra direcci√≥n IP externa, apareci√≥ un nuevo candidato a ICEC y necesitamos reenviarlo utilizando un mecanismo de terceros, el evento fue m√°s dif√≠cil. <br><br><img src="https://habrastorage.org/webt/ou/lu/zp/ouluzpi6ahoovtpo1acf01pblbe.png"><br><br>  Cuando establecemos una conexi√≥n y queremos inicializar la llamada, utilizamos el m√©todo createOffer () para formar el SDP inicial, ofrecer SDP, la misma metainformaci√≥n que debe enviarse al socio. <br><br>  Para establecerlo en PeerConnection, utilizamos el m√©todo setLocalDescription ().  El interlocutor recibe esta informaci√≥n mediante el mecanismo de se√±alizaci√≥n, la establece a s√≠ mismo utilizando el m√©todo setRemoteDescription () y genera una respuesta utilizando el m√©todo createAnswer (), que tambi√©n se env√≠a al primer cliente utilizando el mecanismo de se√±alizaci√≥n. <br><br><img src="https://habrastorage.org/webt/-z/tt/ns/-zttnspmlmdyfjgvn6koame5duw.png"><br><br>  Cuando obtuvimos acceso a los medios, obtuvimos el flujo de medios, lo transferimos a nuestra conexi√≥n P2P utilizando el m√©todo addStream, y nuestro interlocutor se entera de que tiene el evento onaddstream cortado.  Recibir√° nuestra transmisi√≥n y podr√° mostrarla. <br><br><img src="https://habrastorage.org/webt/e5/4m/ot/e54mot_c6nmcg60na7bj-k7kbro.png"><br><br>  Tambi√©n puede trabajar con flujos de datos.  Es muy similar a formar una peerConnection regular, solo especifique RtpDataChannels: true y llame al m√©todo createDataChannel ().  No me detendr√© en esto en detalle, porque dicho trabajo es muy similar a trabajar con sockets web. <br><br>  Algunas palabras sobre seguridad.  WebRTC solo funciona en HTTPS, su sitio debe estar firmado con un certificado.  Las transmisiones multimedia tambi√©n est√°n encriptadas, utilizando DTLS.  La tecnolog√≠a no requiere la instalaci√≥n de nada adicional, sin complementos, y eso es bueno.  Y no funcionar√° para hacer una aplicaci√≥n de software esp√≠a, el sitio no escuchar√° ni esp√≠a al usuario, le mostrar√° al usuario un aviso especial, le solicitar√° acceso y lo recibir√° solo si el usuario permite el acceso a dispositivos de audio y medios. <br><br><img src="https://habrastorage.org/webt/4d/pf/mp/4dpfmps0b2axjq2kyrshvgf-xaa.png"><br><br>  En cuanto a la compatibilidad con el navegador, IE permanece y permanece rojo.  A fines del a√±o pasado, se agreg√≥ el soporte de Safari, es decir, todos los navegadores modernos ya pueden trabajar con esta tecnolog√≠a y podemos usarla de manera segura. <br><br>  Quiero compartir un conjunto de todo tipo de utilidades que lo ayudar√°n si desea trabajar con WebRTC.  Esto es principalmente un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adaptador</a> .  Las tecnolog√≠as est√°n en constante evoluci√≥n, y hay una diferencia en las API del navegador.  La biblioteca de adaptadores elimina esta diferencia y facilita el trabajo.  Una biblioteca conveniente para trabajar con flujos de datos es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Peerjs</a> .  Tambi√©n puede ver las implementaciones de c√≥digo abierto de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servidores</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STUN</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TURN</a> .  Hay un gran conjunto de tutoriales, ejemplos y art√≠culos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina impresionante-webrtc</a> , lo recomiendo encarecidamente. <br><br>  La √∫ltima herramienta √∫til para la depuraci√≥n es webrtc-internals.  Durante el desarrollo, puede escribir un comando especial en la barra de direcciones; por ejemplo, en el navegador Chrome, este es Chrome: // webrtc-internals.  Ver√° una p√°gina con toda la informaci√≥n sobre su conexi√≥n WebRTC actual.  Habr√° secuencias de llamadas en los m√©todos y todos los datagramas intercambiados entre navegadores y gr√°ficos que de alguna manera caracterizan su conexi√≥n.  En general, habr√° toda la informaci√≥n que se necesitar√° durante la depuraci√≥n y el desarrollo.  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es419951/">https://habr.com/ru/post/es419951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es419941/index.html">Recorrido fotogr√°fico por la oficina de Audiomania: primera parte</a></li>
<li><a href="../es419943/index.html">Lo que le√≠mos en julio: c√≥mo encontrar tiempo para leer, cinco libros para el liderazgo del equipo y algunos art√≠culos nuevos</a></li>
<li><a href="../es419945/index.html">C√≥mo prepararse para una entrevista en Google y no pasarla. Dos veces</a></li>
<li><a href="../es419947/index.html">Con√©ctese a PiZeroW con Raspbian Stretch Lite, sin adaptadores adicionales y un monitor</a></li>
<li><a href="../es419949/index.html">¬øQu√© c√≥decs de video (no) usan los navegadores para las videollamadas?</a></li>
<li><a href="../es419953/index.html">Estoy escribiendo un libro sobre la primera "nuestra" startup que conquist√≥ el mundo: ayuda</a></li>
<li><a href="../es419955/index.html">Caracter√≠sticas del b√∫fer FIFO UART en ESP32</a></li>
<li><a href="../es419961/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 265 (6 de agosto - 12 de agosto)</a></li>
<li><a href="../es419963/index.html">Hacemos un controlador "inteligente" para el aire acondicionado en el ESP8266</a></li>
<li><a href="../es419965/index.html">Caracter√≠sticas de configuraci√≥n del conmutador ExtremeXOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>