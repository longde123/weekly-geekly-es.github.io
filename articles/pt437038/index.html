<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèæ üçß üïß Tradu√ß√£o de Benjamin API Winterberg Stream API Guide üÉè üë®üèΩ‚Äçü§ù‚Äçüë®üèº üë®üèº‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo " Tutorial do Java 8 Stream ". 

 Este tutorial, baseado em exemplos de c√≥digo, fornece uma vis√£o gera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tradu√ß√£o de Benjamin API Winterberg Stream API Guide</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tutorial do Java 8 Stream</a> ". <br><br>  Este tutorial, baseado em exemplos de c√≥digo, fornece uma vis√£o geral abrangente dos fluxos no Java 8. Quando introduzi a API do Stream pela primeira vez, fiquei intrigado com o nome porque √© muito consoante com o InputStream e OutputStream do pacote java.io;  No entanto, os encadeamentos no Java 8 s√£o algo completamente diferente. <a name="habracut"></a>  Threads s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√¥nadas</a> que desempenham um papel importante no desenvolvimento de programa√ß√£o funcional em Java. <br><blockquote>  Na programa√ß√£o funcional, uma m√¥nada √© uma estrutura que representa um c√°lculo na forma de uma cadeia de etapas sucessivas.  O tipo e a estrutura da m√¥nada determinam a cadeia de opera√ß√µes, no nosso caso, uma sequ√™ncia de m√©todos com fun√ß√µes internas de um determinado tipo. </blockquote>  Este tutorial ensinar√° como trabalhar com fluxos e mostrar√° como lidar com os v√°rios m√©todos dispon√≠veis na API de fluxo.  Analisaremos a ordem das opera√ß√µes e veremos como a sequ√™ncia de m√©todos na cadeia afeta o desempenho.  Conhe√ßa <code>flatMap</code> m√©todos avan√ßados da API de fluxo, como <code>reduce</code> , <code>collect</code> e <code>flatMap</code> .  No final do manual, prestaremos aten√ß√£o ao trabalho paralelo com fluxos. <br><br>  Se voc√™ n√£o se sentir √† vontade para trabalhar com express√µes lambda, interfaces funcionais e m√©todos de refer√™ncia, ser√° √∫til que voc√™ se familiarize com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu guia de inova√ß√µes em Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o</a> em Habr√©) e depois retorne ao estudo de fluxos. <br><br><h3>  Como os threads funcionam </h3><br>  Um fluxo representa uma sequ√™ncia de elementos e fornece v√°rios m√©todos para executar c√°lculos nesses elementos: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Os m√©todos de fluxo s√£o <i>intermedi√°rios</i> (intermedi√°rios) e <i>terminais</i> (terminais).  M√©todos intermedi√°rios retornam um fluxo, o que permite que muitos desses m√©todos sejam chamados seq√ºencialmente.  Os m√©todos de terminal n√£o retornam um valor (nulo) ou retornam um resultado de um tipo diferente de um fluxo.  No exemplo acima, os <code>sorted</code> <code>filter</code> , <code>map</code> e <code>sorted</code> s√£o intermedi√°rios e <code>forEach</code> s√£o terminais.  Para obter uma lista completa dos m√©todos de fluxo dispon√≠veis, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> .  Essa cadeia de opera√ß√µes de fluxo tamb√©m √© conhecida como um pipeline de opera√ß√£o. <br><br>  A maioria dos m√©todos da API de fluxo aceita como par√¢metros express√µes lambda, uma interface funcional que descreve o comportamento espec√≠fico do m√©todo.  A maioria deles deve ser simultaneamente n√£o interferente e ap√°trida.  O que isso significa? <br><br>  Um m√©todo n√£o interfere se n√£o modificar os dados subjacentes subjacentes ao fluxo.  Por exemplo, no exemplo acima, nenhuma express√£o lambda modifica a matriz da lista myList. <br><br>  Um m√©todo √© sem estado se a ordem em que a opera√ß√£o √© executada for especificada.  Por exemplo, nem uma √∫nica express√£o lambda do exemplo depende de vari√°veis ‚Äã‚Äãmut√°veis ‚Äã‚Äãou estados de espa√ßo externo que podem mudar no tempo de execu√ß√£o. <br><br><h3>  Diferentes tipos de threads </h3><br>  Os fluxos podem ser criados a partir de v√°rios dados de origem, principalmente de cole√ß√µes.  Listas e conjuntos suportam os novos m√©todos <code>stream()</code> e <code>parllelStream()</code> para criar fluxos sequenciais e paralelos.  Threads paralelos s√£o capazes de trabalhar no modo multithread (em v√°rios threads) e ser√£o discutidos no final do manual.  Enquanto isso, considere threads sequenciais: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Aqui, chamar o m√©todo <code>stream()</code> em uma lista retorna um objeto de fluxo normal. <br>  No entanto, para trabalhar com um fluxo, n√£o √© necess√°rio criar uma cole√ß√£o: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Basta usar <code>Stream.of()</code> para criar um fluxo a partir de v√°rias refer√™ncias a objetos. <br><br>  Al√©m dos fluxos de objetos regulares, o Java 8 possui tipos especiais de fluxos para trabalhar com tipos primitivos: int, long, double.  Como voc√™ pode imaginar, esse √© <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  Os fluxos IntStream podem substituir os <code>IntStream.range()</code> regulares para (;;) usando <code>IntStream.range()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Todos esses fluxos para trabalhar com tipos primitivos funcionam como fluxos regulares de objetos, exceto pelo seguinte: <br><br><ul><li>  Fluxos primitivos usam express√µes lambda especiais.  Por exemplo, IntFunction em vez de Function ou IntPredicate em vez de Predicate. </li><li>  Fluxos primitivos suportam m√©todos terminais adicionais: <code>sum()</code> e <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  √Äs vezes, √© √∫til transformar um fluxo de objetos em um fluxo de primitivas ou vice-versa.  Para esse prop√≥sito, os fluxos de objetos suportam m√©todos especiais: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Os fluxos de primitivos podem ser convertidos em fluxos de objetos chamando <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  No exemplo a seguir, um fluxo de n√∫meros de ponto flutuante √© mapeado para um fluxo de n√∫meros inteiros e, em seguida, mapeado para um fluxo de objetos: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Ordem de execu√ß√£o </h3><br>  Agora que aprendemos como criar v√°rios fluxos e como trabalhar com eles, vamos nos aprofundar e considerar como as opera√ß√µes de streaming ficam sob o cap√¥. <br><br>  Uma caracter√≠stica importante dos m√©todos intermedi√°rios √© a <i>pregui√ßa</i> .  N√£o h√° m√©todo terminal neste exemplo: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Quando esse trecho de c√≥digo √© executado, nada ser√° gerado no console.  E tudo porque os m√©todos intermedi√°rios s√£o executados apenas se houver um m√©todo terminal.  Vamos expandir o exemplo adicionando o m√©todo de terminal <code>forEach</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  A execu√ß√£o desse fragmento de c√≥digo leva √† sa√≠da para o console do seguinte resultado: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  A ordem em que os resultados s√£o organizados pode surpreender.  Pode-se esperar ingenuamente que os m√©todos sejam executados "horizontalmente": um ap√≥s o outro para todos os elementos do fluxo.  No entanto, o elemento se move ao longo da cadeia "verticalmente".  Primeiro, a primeira linha de ‚Äúd2‚Äù passa pelo m√©todo de <code>filter</code> , depois pelo <code>forEach</code> e somente ent√£o, depois de passar o primeiro elemento por toda a cadeia de m√©todos, o pr√≥ximo elemento come√ßa a ser processado. <br><br>  Dado esse comportamento, voc√™ pode reduzir o n√∫mero real de opera√ß√µes: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  O m√©todo <code>anyMatch</code> retornar√° <i>true</i> assim que o predicado for aplicado ao elemento recebido.  Nesse caso, este √© o segundo elemento da sequ√™ncia - "A2".  Consequentemente, devido √† execu√ß√£o ‚Äúvertical‚Äù da cadeia de encadeamentos, o <code>map</code> ser√° chamado apenas duas vezes.  Assim, em vez de exibir todos os elementos do fluxo, o <code>map</code> ser√° chamado o menor n√∫mero de vezes poss√≠vel. <br><br><h3>  Por que a sequ√™ncia √© importante </h3><br>  O exemplo a seguir consiste em dois m√©todos intermedi√°rios <code>map</code> e <code>filter</code> e um m√©todo terminal <code>forEach</code> .  Considere como esses m√©todos s√£o executados: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  √â f√°cil adivinhar que os m√©todos de <code>map</code> e <code>filter</code> s√£o chamados 5 vezes em tempo de execu√ß√£o - uma vez para cada elemento da cole√ß√£o de origem, enquanto o <code>forEach</code> √© chamado apenas uma vez - para o elemento que passou no filtro. <br><br>  Voc√™ pode reduzir significativamente o n√∫mero de opera√ß√µes alterando a ordem das chamadas de m√©todo colocando o <code>filter</code> em primeiro lugar: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Agora o mapa √© chamado apenas uma vez.  Com um grande n√∫mero de elementos de entrada, observaremos um aumento not√°vel na produtividade.  Lembre-se disso ao compor cadeias de m√©todos complexos. <br><br>  Expandimos o exemplo acima adicionando uma opera√ß√£o de classifica√ß√£o adicional - o m√©todo classificado: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  A classifica√ß√£o √© um tipo especial de opera√ß√£o intermedi√°ria.  Essa √© a chamada opera√ß√£o com estado, porque para classificar uma cole√ß√£o, seu estado deve ser levado em considera√ß√£o durante toda a opera√ß√£o. <br><br>  Como resultado da execu√ß√£o desse c√≥digo, obtemos a seguinte sa√≠da no console: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Primeiro, a cole√ß√£o inteira √© classificada.  Em outras palavras, o m√©todo <code>sorted</code> √© executado horizontalmente.  Nesse caso, <code>sorted</code> √© chamado 8 vezes para v√°rias combina√ß√µes dos elementos na cole√ß√£o de entrada. <br><br>  Mais uma vez, otimizamos a execu√ß√£o desse c√≥digo alterando a ordem das chamadas de m√©todo na cadeia: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  Neste exemplo, <code>sorted</code> n√£o √© chamado.  <code>filter</code> reduz a cole√ß√£o de entrada para um elemento.  No caso de grandes dados de entrada, o desempenho ser√° beneficiado significativamente. <br><br><h3>  Reutilizar fluxos </h3><br>  No Java 8, os encadeamentos n√£o podem ser reutilizados.  Depois de chamar qualquer m√©todo de terminal, o encadeamento termina: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Chamar <code>noneMatch</code> ap√≥s <code>anyMatch</code> em um encadeamento resulta na seguinte exce√ß√£o: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Para superar essa limita√ß√£o, um novo encadeamento deve ser criado para cada m√©todo de terminal. <br><br>  Por exemplo, voc√™ pode criar um <i>fornecedor</i> para um novo construtor de encadeamentos no qual todos os m√©todos intermedi√°rios ser√£o instalados: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Cada chamada para o m√©todo <code>get</code> cria um novo encadeamento no qual voc√™ pode chamar com seguran√ßa o m√©todo de terminal desejado. <br><br><h3>  M√©todos avan√ßados </h3><br>  Threads suportam um grande n√∫mero de m√©todos diferentes.  J√° nos familiarizamos com os m√©todos mais importantes.  Para se familiarizar com o resto, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> .  E agora mergulhe ainda mais em m√©todos mais complexos: <code>collect</code> , <code>flatMap</code> e <code>reduce</code> . <br><br>  A maioria dos exemplos de c√≥digo nesta se√ß√£o se refere ao seguinte snippet de c√≥digo para demonstrar a opera√ß√£o: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Coletar </h4><br>  <code>Collect</code> m√©todo de terminal muito √∫til, usado para converter elementos de fluxo em um resultado de um tipo diferente, por exemplo, Lista, Conjunto ou Mapa. <br><br>  <code>Collect</code> aceita um <code>Collector</code> que cont√©m quatro m√©todos diferentes: um fornecedor.  acumulador, combinador, finalizador.  √Ä primeira vista, isso parece muito complicado, mas o Java 8 suporta v√°rios coletores internos por meio da classe <code>Collectors</code> , onde os m√©todos mais usados ‚Äã‚Äãs√£o implementados. <br><br>  Caso popular: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Como voc√™ pode ver, a cria√ß√£o de uma lista de itens de fluxo √© muito simples.  N√£o precisa de uma lista, mas muito?  Use <code>Collectors.toSet()</code> . <br><br>  No exemplo a seguir, as pessoas s√£o agrupadas por idade: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Os colecionadores s√£o incrivelmente diversos.  Voc√™ tamb√©m pode agregar os elementos da cole√ß√£o, por exemplo, determinar a idade m√©dia: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Para obter estat√≠sticas mais abrangentes, usamos um coletor de resumo que retorna um objeto especial com informa√ß√µes: valores m√≠nimos, m√°ximos e m√©dios, a soma dos valores e o n√∫mero de elementos: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  O exemplo a seguir combina todos os nomes em uma linha: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  O coletor de conex√£o aceita um separador, bem como um prefixo e sufixo opcional. <br><br>  Para converter os elementos de um fluxo em uma exibi√ß√£o, voc√™ deve determinar como as chaves e os valores devem ser exibidos.  Lembre-se de que as chaves no mapeamento devem ser exclusivas.  Caso contr√°rio, obteremos uma <code>IllegalStateException</code> .  Opcionalmente, voc√™ pode adicionar uma fun√ß√£o de mesclagem para ignorar a exce√ß√£o: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  Ent√£o, nos familiarizamos com alguns dos mais poderosos coletores internos.  Vamos tentar construir o seu pr√≥prio.  Queremos converter todos os elementos do fluxo em uma √∫nica linha, que consiste em nomes em mai√∫sculas separados por uma barra vertical |.  Para fazer isso, crie um novo coletor usando <code>Collector.of()</code> .  Precisamos dos quatro componentes de nosso coletor: fornecedor, bateria, conector, finalizador. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Como as strings em Java s√£o imut√°veis, precisamos de uma classe auxiliar como <code>StringJoiner</code> que permita que o coletor construa uma string para n√≥s.  Na primeira etapa, o provedor constr√≥i um <code>StringJoiner</code> com um delimitador atribu√≠do.  Bateria √© usada para adicionar cada nome ao <code>StringJoiner</code> . <br><br>  O conector sabe como conectar dois <code>StringJoiner</code> em um.  E, no final, o finalizador constr√≥i a sequ√™ncia desejada de <code>StringJoiner</code> s. <br><br><h4>  Flatmap </h4><br>  Ent√£o, aprendemos como transformar objetos de fluxo em outros tipos de objetos usando o m√©todo <code>map</code> .  <code>Map</code> √© um tipo de m√©todo limitado, pois cada objeto pode ser mapeado para apenas um outro objeto.  Mas e se voc√™ quiser mapear um objeto para muitos outros, ou n√£o exibi-lo?  √â aqui que o m√©todo <code>flatMap</code> ajuda.  <code>FlatMap</code> transforma cada objeto de fluxo em um fluxo de outros objetos.  O conte√∫do desses encadeamentos √© empacotado no fluxo retornado do m√©todo <code>flatMap</code> . <br><br>  Para analisar o <code>flatMap</code> em a√ß√£o, vamos criar uma hierarquia de tipos adequada para um exemplo: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Vamos criar alguns objetos: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Agora temos uma lista de tr√™s <i>foo</i> , cada um dos quais cont√©m tr√™s <i>barras</i> . <br><br>  <code>FlatMap</code> aceita uma fun√ß√£o que deve retornar um fluxo de objetos.  Assim, para acessar os objetos de <i>barra</i> de cada <i>foo</i> , basta encontrar a fun√ß√£o apropriada: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Assim, transformamos com sucesso um fluxo de tr√™s objetos <i>foo</i> em um fluxo de 9 objetos de <i>barra</i> . <br><br>  Por fim, todo o c√≥digo acima pode ser reduzido a um simples pipeline de opera√ß√µes: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> tamb√©m <code>FlatMap</code> dispon√≠vel na classe <code>Optional</code> introduzida no Java 8. O <code>FlatMap</code> da classe <code>Optional</code> retorna um objeto opcional de outra classe.  Isso pode ser usado para evitar <code>null</code> verifica√ß√µes <code>null</code> . <br><br>  Imagine uma estrutura hier√°rquica como esta: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Para obter a string aninhada <i>foo</i> de um objeto externo, voc√™ precisa adicionar v√°rias verifica√ß√µes <code>null</code> para evitar uma <code>NullPointException</code> : <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  O mesmo pode ser alcan√ßado usando o flatMap da classe Opcional: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Cada chamada para <code>flatMap</code> retorna um wrapper <code>Optional</code> para o objeto desejado, se presente, ou para <code>null</code> se o objeto estiver ausente. <br><br><h4>  Reduzir </h4><br>  A opera√ß√£o de simplifica√ß√£o combina todos os elementos de um fluxo em um √∫nico resultado.  O Java 8 suporta tr√™s tipos diferentes de m√©todos de redu√ß√£o. <br><br>  O primeiro reduz o fluxo de elementos para um √∫nico elemento de fluxo.  Usamos este m√©todo para determinar o elemento com a maior idade: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  O m√©todo de <code>reduce</code> assume uma fun√ß√£o acumulativa com um <i>operador bin√°rio</i> (BinaryOperator).  Aqui <code>reduce</code> √© uma <i>bi-fun√ß√£o</i> (BiFunction), na qual os dois argumentos pertencem ao mesmo tipo.  No nosso caso, para o tipo <i>Pessoa</i> .  Uma bi-fun√ß√£o √© quase a mesma que uma <code></code> , mas s√£o necess√°rios 2 argumentos.  No nosso exemplo, a fun√ß√£o compara a idade de duas pessoas e retorna um elemento com uma idade maior. <br><br>  A pr√≥xima forma do m√©todo de <code>reduce</code> leva um valor inicial e uma bateria com um operador bin√°rio.  Este m√©todo pode ser usado para criar um novo item.  N√≥s temos - <i>Pessoa</i> com nome e idade, consistindo na adi√ß√£o de todos os nomes e na soma dos anos vividos: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  O terceiro m√©todo de <code>reduce</code> utiliza tr√™s par√¢metros: o valor inicial, o acumulador com uma bi-fun√ß√£o e uma fun√ß√£o combinada, como um operador bin√°rio.  Como o valor inicial do tipo n√£o se limita ao tipo Pessoa, voc√™ pode usar a redu√ß√£o para determinar o total de anos de vida de cada pessoa: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Como voc√™ pode ver, obtivemos o resultado 76, mas o que realmente acontece sob o cap√¥? <br><br>  Expandimos o fragmento de c√≥digo acima com a sa√≠da do texto para a depura√ß√£o: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Como voc√™ pode ver, a fun√ß√£o acumuladora realiza todo o trabalho.  Ele √© chamado pela primeira vez com um valor inicial de 0 e a primeira pessoa m√°x.  Nas pr√≥ximas tr√™s etapas, a soma aumenta constantemente pela idade da pessoa desde a √∫ltima etapa at√© atingir a idade total de 76 anos. <br><br>  Ent√£o, o que vem a seguir?  O combinador nunca √© chamado?  Considere a execu√ß√£o paralela deste segmento: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Com a execu√ß√£o paralela, obtemos uma sa√≠da do console completamente diferente.  Agora o combinador est√° realmente sendo chamado.    ,     ,  -. <br><br>         . <br><br><h3>   </h3><br>              .     <code>ForkJoinPool</code>      <code>ForkJoinPool.commonPool()</code> .       5   ‚Äî         . <br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>             3 .           JVM: <br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br>    <code>parallelStream()</code>     .      <code>parallel()</code>      . <br><br>       ,         (thread)  <code>System.out</code> : <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br>         ,   (thread)       (stream): <br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br>  ,          (threads)  <code>ForkJoinPool</code> .    ,          (thread). <br><br>      <code>sort</code> : <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br>       : <br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br> ,  <code>sort</code>       <i>main</i> .           <code>sort</code>  Stream API     <code>Arrays</code> ,   Java 8, ‚Äî <code>Arrays.parallelSort()</code> .    ,        ,   ‚Äî      : <br><blockquote>       ‚Äú‚Äù,      Arrays.sort. </blockquote>      <code>reduce</code>   .   ,          . ,   : <br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br>   ,   :   ,  ,    : <br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br>  ,               .   ,          ( ),      . <br><br>  ,         <code>ForkJoinPool</code> ,     JVM.              ,     (threads),      . <br><br><h3>    </h3><br>       Java 8 .           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .         ,     ,         (Martin Fowler) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Collection Pipelines</a> . <br><br>      JavaScript,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Stream.js</a> ‚Äî JavaScript  Java 8 Streams API. ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java 8 Tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java 8 Nashorn Tutorial</a> . <br><br> ,        ,      .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  GitHub</a> .   ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437038/">https://habr.com/ru/post/pt437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437026/index.html">Google na Fran√ßa multado em 50 milh√µes de euros por GDPR por uso indevido de dados pessoais</a></li>
<li><a href="../pt437030/index.html">Automa√ß√£o da infraestrutura de um escrit√≥rio de luxo: como fica</a></li>
<li><a href="../pt437032/index.html">Instru√ß√µes de instala√ß√£o do NGINX ModSecurity</a></li>
<li><a href="../pt437034/index.html">Assobios universais: Revis√£o do Dongle USB Snom A230 e A210</a></li>
<li><a href="../pt437036/index.html">SAPUI5 para manequins parte 2: Um exerc√≠cio completo passo a passo</a></li>
<li><a href="../pt437040/index.html">Na R√∫ssia, come√ßou a testar a interface neural dom√©stica "Neurochat"</a></li>
<li><a href="../pt437044/index.html">Como derrotar o drag√£o: reescreva seu programa no Golang</a></li>
<li><a href="../pt437050/index.html">O livro "Python. Curso expresso. 3rd ed.</a></li>
<li><a href="../pt437052/index.html">N√£o deixe de aprender: um especialista em TI da universidade precisa</a></li>
<li><a href="../pt437054/index.html">Novos processadores Intel de 9¬™ gera√ß√£o: Core menos GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>