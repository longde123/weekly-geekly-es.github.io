<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üôç üß£ Intelligente String-Verarbeitungsalgorithmen in ClickHouse üî¶ üå≠ üôéüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ClickHouse st√∂√üt st√§ndig auf Zeichenfolgenverarbeitungsaufgaben. Zum Beispiel das Suchen, Berechnen der Eigenschaften von UTF-8-Zeichenfolgen oder etw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intelligente String-Verarbeitungsalgorithmen in ClickHouse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/466183/"><p>  ClickHouse st√∂√üt st√§ndig auf Zeichenfolgenverarbeitungsaufgaben.  Zum Beispiel das Suchen, Berechnen der Eigenschaften von UTF-8-Zeichenfolgen oder etwas Exotischeres, unabh√§ngig davon, ob es sich um eine Suche mit Gro√ü- und Kleinschreibung oder eine Suche mit komprimierten Daten handelt. </p><br><p> Angefangen hat alles damit, dass die ClickHouse-Entwicklungsleiterin Lyosha Milovidov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">o6CuFl2Q</a> an der Fakult√§t f√ºr Informatik der Higher School of Economics zu uns kam und eine Vielzahl von Themen f√ºr Hausarbeiten und Diplome anbot.  Als ich ‚ÄûSmart String Processing Algorithms in ClickHouse‚Äú sah (ich, eine Person, die sich f√ºr verschiedene Algorithmen interessiert, einschlie√ülich experimenteller), habe ich sofort Pl√§ne aufgestellt, wie man das coolste Diplom macht.  Meine Freude und mein Ausdruck k√∂nnen wie folgt beschrieben werden: </p><br><p><img src="https://habrastorage.org/webt/av/4d/2g/av4d2gj_pplevfljaomiqsnccda.jpeg"></p><br><a name="habracut"></a><br><h2 id="clickhouse">  Clickhouse </h2><br><p>  ClickHouse hat die Organisation der Datenspeicherung im Speicher sorgf√§ltig durchdacht - in Spalten.  Am Ende jeder Spalte befindet sich ein Abstand von 15 Bytes zum sicheren Lesen eines 16-Byte-Registers.  Beispielsweise speichert ColumnString nullterminierte Zeichenfolgen zusammen mit Offsets.  Es ist sehr bequem, mit solchen Arrays zu arbeiten. </p><br><p><img src="https://habrastorage.org/webt/w4/go/yp/w4goypgrxiigdp5tpdy3eyao2bu.png"><br></p><br><p>  Es gibt auch ColumnFixedString, ColumnConst und LowCardinality, aber wir werden heute nicht so ausf√ºhrlich dar√ºber sprechen.  Der Hauptpunkt an dieser Stelle ist, dass das Design des sicheren Lesens der Schw√§nze in Ordnung ist und die Lokalit√§t der Daten auch bei der Verarbeitung eine Rolle spielt. </p><br><h2 id="poisk-po-podstrokam">  Teilstring-Suche </h2><br><p>  H√∂chstwahrscheinlich kennen Sie viele verschiedene Algorithmen zum Finden eines Teilstrings in einem String.  Wir werden √ºber diejenigen sprechen, die in ClickHouse verwendet werden.  Zuerst stellen wir einige Definitionen vor: </p><br><ol><li>  Heuhaufen - die Linie, in die wir schauen;  typischerweise wird die L√§nge mit <em>n bezeichnet</em> . </li><li>  Nadel - die Zeichenfolge oder der regul√§re Ausdruck, nach dem wir suchen;  Die L√§nge wird mit <em>m bezeichnet</em> . </li></ol><br><p>  Nachdem ich eine gro√üe Anzahl von Algorithmen studiert habe, kann ich sagen, dass es 2 (maximal 3) Arten von Teilstring-Suchalgorithmen gibt.  Das erste ist die Erstellung von Suffixstrukturen in der einen oder anderen Form.  Der zweite Typ sind Algorithmen, die auf einem Speichervergleich basieren.  Es gibt auch den Rabin-Karp-Algorithmus, der Hashes verwendet, aber in seiner Art ziemlich einzigartig ist.  Der schnellste Algorithmus existiert nicht, alles h√§ngt von der Gr√∂√üe des Alphabets, der L√§nge der Nadel, dem Heuhaufen und der H√§ufigkeit des Auftretens ab. </p><br><p>  Lesen Sie hier mehr √ºber verschiedene Algorithmen.  Und hier sind die beliebtesten Algorithmen: </p><br><ol><li>  Knut - Morris - Pratt, </li><li>  Boyer - Moore, </li><li>  Boyer - Moore - Horspool, </li><li>  Rabin - Karpfen, </li><li>  Doppelseitig (wird in glibc als "memmem" bezeichnet), </li><li>  BNDM </li></ol><br><p>  Die Liste geht weiter.  Wir bei ClickHouse haben ehrlich alles versucht, aber am Ende haben wir uns f√ºr eine au√üergew√∂hnlichere Version entschieden. </p><br><h4 id="algoritm-volnickogo">  Volnitsky-Algorithmus </h4><br><p>  Der Algorithmus wurde Ende 2010 im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog des</a> Programmierers Leonid Volnitsky ver√∂ffentlicht.  Es √§hnelt etwas dem Boyer-Moore-Horspool-Algorithmus, nur eine verbesserte Version. </p><br><p>  Wenn <em>m &lt;4 ist</em> , wird der Standardsuchalgorithmus verwendet.  Speichern Sie alle Bigrams-Nadeln (2 aufeinanderfolgende Bytes) vom Ende in einer Hash-Tabelle mit offener Adressierung der Gr√∂√üe <em>| Sigma |</em>  <em><sup>2</sup></em> Elemente (in der Praxis sind dies 2 <sup>16</sup> Elemente), wobei die Offsets dieses Bigrams die Werte und das Bigram selbst gleichzeitig der Hash und der Index sind.  Die Ausgangsposition befindet sich ab Beginn des Heuhaufens auf Position <em>m - 2</em> .  Wir folgen dem Heuhaufen mit Schritt <em>m - 1</em> , betrachten das n√§chste Bigram von dieser Position im Heuhaufen und betrachten alle Werte des Bigrams in der Hash-Tabelle.  Dann werden wir zwei Speicherst√ºcke mit dem √ºblichen Vergleichsalgorithmus vergleichen.  Der verbleibende Schwanz wird von demselben Algorithmus verarbeitet. </p><br><p>  Schritt <em>m - 1 wird so</em> gew√§hlt, dass bei Auftreten einer Nadel im Heuhaufen das Bigram dieses Eintrags definitiv ber√ºcksichtigt wird, wodurch sichergestellt wird, dass die Position des Eintrags im Heuhaufen zur√ºckgegeben wird.  Das erste Auftreten wird durch die Tatsache garantiert, dass wir der Hash-Tabelle per Bigram Indizes vom Ende hinzuf√ºgen.  Dies bedeutet, dass wir, wenn wir von links nach rechts gehen, zuerst die Bigramme vom Ende der Zeile betrachten (vielleicht zun√§chst v√∂llig unn√∂tige Bigramme), dann n√§her am Anfang. </p><br><p> Betrachten Sie ein Beispiel.  Lassen Sie den Heuhaufen <code>abacabaac</code> und Nadel gleich <code>aaca</code> .  Die Hash-Tabelle lautet <code>{aa : 0, ac : 1, ca : 2}</code> . </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Wir sehen das Bigram <code>ac</code> .  In Nadel ist es, wir ersetzen in Gleichheit: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  Nicht √ºbereinstimmend.  Nachdem <code>ac</code> keine Eintr√§ge in der Hash-Tabelle enth√§lt, fahren wir mit Schritt 3 fort: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Es gibt keine Bigrams in der Hash-Tabelle. </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca ^ -   </code> </pre> <br><p>  Es gibt ein Bigram <code>ca</code> in der Nadel, wir schauen uns den Versatz an und finden den Eintrag: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 abacabaaca aaca</code> </pre> <br><p>  Der Algorithmus hat viele Vorteile.  Erstens m√ºssen Sie keinen Speicher auf dem Heap zuweisen, und 64 KB auf dem Stapel sind jetzt nicht mehr transzendent.  Zweitens ist 2 <sup>16</sup> eine ausgezeichnete Zahl, um Modulo f√ºr den Prozessor zu nehmen;  Dies sind nur Movzwl-Anweisungen (oder, wie wir scherzen, ‚ÄûMovsvl‚Äú) und die Familie. </p><br><p>  Im Durchschnitt erwies sich dieser Algorithmus als der beste.  Wir haben die Daten von Yandex.Metrica √ºbernommen, die Anfragen sind fast real.  Eine Stream-Geschwindigkeit, mehr ist besser, KMP: Knut-Morris-Pratt-Algorithmus, BM: Boyer-Moore, BMH: Boyer-Moore-Horspool. </p><br><p><img src="https://habrastorage.org/webt/wp/vn/v2/wpvnv2eqrbhhvqvryaqmdjc9igy.png"><br></p><br><p>  Um nicht unbegr√ºndet zu sein, kann der Algorithmus quadratische Zeit arbeiten: </p><br><p><img src="https://habrastorage.org/webt/oi/3x/dh/oi3xdhxe7awdlsqxxui2lyqvxjc.png"><br></p><br><p>  Es wird in der <code>position(Column, ConstNeedle)</code> und dient auch als Optimierung f√ºr die Suche nach regul√§ren Ausdr√ºcken. </p><br><h2 id="poisk-po-regulyarnym-vyrazheniyam">  Suche nach regul√§ren Ausdr√ºcken </h2><br><p>  Wir zeigen Ihnen, wie ClickHouse die Suche nach regul√§ren Ausdr√ºcken optimiert.  Viele regul√§re Ausdr√ºcke enthalten einen Teilstring, der sich im Heuhaufen befinden muss.  Um keine Finite-State-Maschine zu erstellen und dagegen zu pr√ºfen, werden wir solche Teilzeichenfolgen isolieren. </p><br><p>  Dies zu tun ist ganz einfach: Alle √∂ffnenden Klammern erh√∂hen den Verschachtelungsgrad, alle schlie√üenden Klammern verringern sich;  Es gibt auch Zeichen, die f√ºr regul√§re Ausdr√ºcke spezifisch sind (z. B. '.', '*', '?', '\ w' usw.).  Wir m√ºssen alle Teilzeichenfolgen auf Stufe 0 bringen. Betrachten Sie ein Beispiel: <br><img src="https://habrastorage.org/webt/2x/uk/uo/2xukuompabpmnrjpk-muwg1yydi.png"><br></p><br><p>  Wir teilen es in die Teilzeichenfolgen auf, die sich aus dem regul√§ren Ausdruck im Heuhaufen befinden m√ºssen. Danach w√§hlen wir die maximale L√§nge aus, suchen nach Kandidaten und √ºberpr√ºfen dies mit der √ºblichen regul√§ren Ausdrucks-Engine RE2.  Im obigen Bild gibt es einen regul√§ren Ausdruck, der von der √ºblichen RE2-Engine mit 736 MB / s verarbeitet wird, Hyperscan (etwas sp√§ter) erreicht 1,6 GB / s und wir verwalten 1,69 GB / s pro Kern zusammen mit der Dekomprimierung LZ4.  Im Allgemeinen ist eine solche Optimierung an der Oberfl√§che und beschleunigt die Suche nach regul√§ren Ausdr√ºcken erheblich, wird jedoch h√§ufig nicht in Tools implementiert, was mich sehr √ºberrascht. </p><br><p>  Das Schl√ºsselwort LIKE wird ebenfalls mit diesem Algorithmus optimiert. Erst nach LIKE kann ein sehr vereinfachter regul√§rer Ausdruck %%%%% (beliebige Teilzeichenfolge) und <code>_</code> (beliebiges Zeichen) durchlaufen. </p><br><p>  Leider unterliegen nicht alle regul√§ren Ausdr√ºcke solchen Optimierungen. Beispielsweise ist es bei <code>yandex|google</code> unm√∂glich, <code>yandex|google</code> , die im Heuhaufen vorkommen m√ºssen, explizit zu extrahieren.  Deshalb haben wir eine v√∂llig andere L√∂sung gefunden. </p><br><h2 id="poisk-po-mnogim-podstrokam">  Suchen Sie nach vielen Teilzeichenfolgen </h2><br><p>  Das Problem ist, dass es viel Nadel gibt, und ich m√∂chte verstehen, ob mindestens eine davon im Heuhaufen enthalten ist.  Es gibt ziemlich klassische Methoden f√ºr eine solche Suche, zum Beispiel den Aho-Korasik-Algorithmus.  Aber er war nicht zu schnell f√ºr unsere Aufgabe.  Wir werden etwas sp√§ter dar√ºber sprechen. </p><br><p><del>  Lesha </del>  ClickHouse liebt nicht standardisierte L√∂sungen, daher haben wir uns entschlossen, etwas anderes auszuprobieren und m√∂glicherweise selbst einen neuen Suchalgorithmus zu entwickeln.  Und sie taten es. </p><br><p>  Wir haben uns den Volnitsky-Algorithmus angesehen und ihn so modifiziert, dass er nach vielen Teilzeichenfolgen gleichzeitig sucht.  Dazu m√ºssen Sie nur die Bigrams aller Zeilen hinzuf√ºgen und den Zeilenindex in der Hash-Tabelle speichern.  Der Schritt wird aus mindestens allen Nadell√§ngen minus 1 ausgew√§hlt, um erneut die Eigenschaft zu gew√§hrleisten, dass bei einem Auftreten das Bigram angezeigt wird.  Die Hash-Tabelle w√§chst auf 128 KB (Zeilen, die l√§nger als 255 sind, werden vom Standardalgorithmus verarbeitet, wir werden nicht mehr als 256 Nadeln ber√ºcksichtigen).  Ich bin sehr faul, daher hier ein Beispiel aus der Pr√§sentation (von links nach rechts von oben nach unten gelesen): </p><br><p><img src="https://habrastorage.org/webt/ak/no/hq/aknohqtvebtx-c_ijmza8af0emm.png"><br></p><br><p><img src="https://habrastorage.org/webt/x6/cm/z4/x6cmz4d3i5qy5i3tfj1ngbssewc.png"><br></p><br><p>  Wir begannen zu untersuchen, wie sich ein solcher Algorithmus im Vergleich zu anderen verh√§lt (Zeilen werden aus realen Daten entnommen).  Und f√ºr eine kleine Anzahl von Zeilen macht er alles (die Geschwindigkeit zusammen mit dem Entladen wird angezeigt - ungef√§hr 2,5 GB / s). </p><br><p><img src="https://habrastorage.org/webt/nl/t_/pt/nlt_pt077xl7n-cya0qb6eh67re.png"><br></p><br><p>  Dann wurde es interessant.  Zum Beispiel verlieren wir mit einer gro√üen Anzahl √§hnlicher Bigrams gegen einige Konkurrenten.  Es ist verst√§ndlich - wir beginnen, viele Erinnerungsst√ºcke zu vergleichen und zu verschlechtern. </p><br><p><img src="https://habrastorage.org/webt/n8/wm/uz/n8wmuzm_vcepo4olqcse1e7gwqy.png"><br></p><br><p>  Sie k√∂nnen nicht viel beschleunigen, wenn die Mindestl√§nge der Nadel gro√ü genug ist.  Offensichtlich haben wir mehr M√∂glichkeiten, ganze Heuhaufenst√ºcke zu √ºberspringen, ohne etwas daf√ºr zu bezahlen. </p><br><p><img src="https://habrastorage.org/webt/zg/z1/ej/zgz1ejecxev4-j-oz3m6egxydt0.png"><br></p><br><p>  Der Kipppunkt beginnt irgendwo in den Zeilen 13-15.  Ungef√§hr 97% der Anfragen, die ich im Cluster gesehen habe, waren weniger als 15 Zeilen: </p><br><p><img src="https://habrastorage.org/webt/x-/6j/od/x-6jodqalhriam_byxewdzoxzhs.png"><br></p><br><p>  Nun, ein sehr be√§ngstigendes Bild - 41 Zeilen, viele sich wiederholende Bigramme: </p><br><p><img src="https://habrastorage.org/webt/yx/ez/da/yxezdam_2poycdgttd9nnsyjjqy.png"><br></p><br><p>  Infolgedessen haben wir in ClickHouse (19.5) die folgenden Funktionen durch diesen Algorithmus implementiert: </p><br><p>  - <code>multiSearchAny(h, [n_1, ..., n_k])</code> - 1, wenn sich mindestens eine der Nadeln im Heuhaufen befindet. <br>  - <code>multiSearchFirstPosition(h, [n_1, ..., n_k])</code> - die Position ganz links beim Eintritt in den Heuhaufen (von eins) oder 0, wenn nicht gefunden. <br>  - <code>multiSearchFirstIndex(h, [n_1, ..., n_k])</code> - der Nadelindex ganz links, der im Heuhaufen gefunden wurde;  0 wenn nicht gefunden. <br>  - <code>multiSearchAllPositions(h, [n_1, ..., n_k])</code> - Alle ersten Positionen aller Nadeln geben ein Array zur√ºck. </p><br><p>  Die Suffixe sind -UTF8 (wir normalisieren nicht), -CaseInsensitive (f√ºgen Sie 4 Bigrams mit unterschiedlicher Gro√ü- / Kleinschreibung hinzu), -CaseInsensitiveUTF8 (es gibt eine Bedingung, dass Gro√ü- und Kleinbuchstaben die gleiche Anzahl von Bytes haben m√ºssen).  Siehe die Implementierung <a href="">hier</a> . </p><br><p>  Danach fragten wir uns, ob wir mit vielen regul√§ren Ausdr√ºcken etwas √Ñhnliches machen k√∂nnten.  Und sie fanden eine L√∂sung, die bereits in Benchmarks verw√∂hnt war. </p><br><h2 id="poisk-po-mnogim-regulyarnym-vyrazheniyam">  Suche nach vielen regul√§ren Ausdr√ºcken </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hyperscan</a> ist eine Bibliothek von Intel, die sofort nach vielen regul√§ren Ausdr√ºcken sucht.  Es verwendet Heuristiken, um Unterw√∂rter von regul√§ren Ausdr√ºcken zu isolieren, √ºber die wir geschrieben haben, und viele SIMDs, um nach dem Glushkov-Automaten zu suchen (der Algorithmus scheint Teddy zu hei√üen). </p><br><p>  Im Allgemeinen steht alles in der besten Tradition, das Maximum aus der Suche nach regul√§ren Ausdr√ºcken herauszuholen.  Die Bibliothek macht wirklich das, was in ihren Funktionen deklariert ist. </p><br><p><img src="https://habrastorage.org/webt/of/xl/dd/ofxlddsnj92zghvsducv9e9jktu.png"><br></p><br><p>  Gl√ºcklicherweise konnte ich in meinem Entwicklungsmonat bei ClickHouse die 12-j√§hrige Entwicklung einer anst√§ndigen Klasse von Abfragen √ºberholen, und ich bin sehr zufrieden damit. </p><br><p>  In Yandex wird die Hyperscan-Bibliothek auch in Antispam verwendet.  Den Bewertungen nach zu urteilen, verarbeitet sie ruhig Tausende von regul√§ren Ausdr√ºcken und sucht schnell nach ihnen. </p><br><p>  Die Bibliothek hat mehrere Nachteile.  Die erste ist die nicht dokumentierte Menge an verbrauchtem Speicher und eine seltsame Eigenschaft, dass der Heuhaufen weniger als 2 <sup>32</sup> Bytes betragen muss.  Das zweite - Sie k√∂nnen die ersten Positionen nicht kostenlos zur√ºckgeben, die Nadelindizes ganz links usw. Und das dritte Minus - es gibt einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler</a> aus heiterem Himmel.  Daher haben wir bei ClickHouse die folgenden Funktionen mit Hyperscan implementiert: </p><br><p>  - <code>multiMatchAny(h, [n_1, ..., n_k])</code> - 1, wenn mindestens eine der Nadeln einen Heuhaufen gefunden hat. <br>  - <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> - Jeder Index der Nadel, der <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> Heuhaufen <code>multiMatchAnyIndex(h, [n_1, ..., n_k])</code> . </p><br><p>  Wir sind interessiert, aber wie k√∂nnen Sie nicht genau, sondern ungef√§hr suchen?  Und kam mit mehreren L√∂sungen. </p><br><h2 id="priblizhyonnyy-poisk">  Ungef√§hre Suche </h2><br><p>  Der Standard bei der ungef√§hren Suche ist der Levenshtein-Abstand - die Mindestanzahl von Zeichen, die ersetzt, hinzugef√ºgt und entfernt werden k√∂nnen, um eine Zeichenfolge b der L√§nge n aus einer Zeichenfolge a der L√§nge m zu erhalten.  Leider funktioniert der naive dynamische Programmieralgorithmus f√ºr <em>O (mn)</em> ;  Die besten K√∂pfe von ShAD k√∂nnen dies in <em>O (mn / log max (n, m))</em> tun.  man kann sich leicht <em>O ((n + m) ‚ãÖ alpha) vorstellen</em> , wobei <em>alpha</em> die Antwort ist;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Wissenschaft</a> kann dies f√ºr <em>O ((alpha - | n - m |) min (m, n, alpha) + m + n)</em> (der Algorithmus ist einfach, zumindest im ShAD lesen) oder, wenn etwas klarer, f√ºr <em>O (alpha ^ 2 + m</em> ) tun <em>+ n)</em> .  Es gibt immer noch ein Minus: Es ist h√∂chstwahrscheinlich unm√∂glich, die quadratische Zeit im schlimmsten Fall polynomiell loszuwerden - Peter Indik hat einen sehr m√§chtigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> dar√ºber geschrieben. </p><br><p>  Es gibt eine √úbung: Stellen Sie sich vor, Sie zahlen f√ºr das Ersetzen eines Charakters in der Levenshtein-Distanz eine Geldstrafe von nicht zwei, sondern zwei;  √úberlegen Sie sich dann einen Algorithmus f√ºr <em>O ((n + m) log (n + m))</em> . </p><br><p>  Es funktioniert immer noch nicht, zu lang und zu teuer.  Mit Hilfe dieser Entfernung haben wir jedoch Tippfehler in den Abfragen erkannt. </p><br><p><img src="https://habrastorage.org/webt/ok/b8/gg/okb8ggb8vwkzft3ggzdipy29pja.png"><br></p><br><p>  Neben der Levenshtein-Distanz gibt es eine Hamming-Distanz.  Auch bei ihm ist alles ziemlich schlecht, aber ein bisschen besser als bei der Levenshtein-Distanz.  Das Entfernen von Zeichen wird nicht ber√ºcksichtigt, sondern nur f√ºr zwei Zeilen gleicher L√§nge die Anzahl der Zeichen ber√ºcksichtigt, in denen sie sich unterscheiden.  Wenn wir also den Abstand f√ºr Zeichenfolgen mit der L√§nge m &lt;n verwenden, dann nur bei der Suche nach den n√§chsten Teilzeichenfolgen. </p><br><p>  Wie berechnet man ein solches Array von Diskrepanzen (ein Array d von n - m + 1 Elementen, wobei d [i] die Anzahl der verschiedenen Zeichen im i-ten vom Beginn der √úberlagerung ist) f√ºr <em>O (| Sigma | (n + m) log (n + m) )</em> ?  Machen Sie zuerst <em>| Sigma |</em>  Bitmasken, die angeben, ob dieses Symbol dem betrachteten entspricht.  Als n√§chstes berechnen wir die Antwort f√ºr jede der Sigma-Masken und f√ºgen hinzu - wir erhalten die urspr√ºngliche Antwort. </p><br><p>  Betrachten Sie ein Beispiel.  <code>abba</code> , Teilzeichenfolge <code>ba</code> , bin√§res Alphabet.  Wir erhalten 2 Masken <code>1001, 01</code> und <code>0110, 10</code> . </p><br><pre> <code class="plaintext hljs">   a 1001 01 - 0  01 - 0  01 - 1 </code> </pre> <br><pre> <code class="plaintext hljs">   b 0110 10 - 0  10 - 1  10 - 1 </code> </pre> <br><p>  Wir bekommen das Array [0, 1, 2] - das ist fast die richtige Antwort.  Beachten Sie jedoch, dass f√ºr jeden Buchstaben die Anzahl der √úbereinstimmungen nur das Skalarprodukt einer festen Bin√§rnadel und aller Heuhaufen-Teilzeichenfolgen ist.  Und daf√ºr gibt es nat√ºrlich eine schnelle Fourier-Transformation! </p><br><p>  F√ºr diejenigen, die es nicht wissen: Die FFT kann zwei Polynome von Grad <em>m &lt;n</em> in einer Zeit <em>O (n log n)</em> multiplizieren, vorausgesetzt, die Arbeit mit den Koeffizienten wird pro Zeiteinheit durchgef√ºhrt.  Faltungen sind skalaren Produkten sehr √§hnlich.  Es reicht aus, die Koeffizienten des ersten Polynoms zu duplizieren und das zweite zu erweitern und mit der erforderlichen Anzahl von Nullen zu erg√§nzen. Dann erhalten wir alle Skalarprodukte einer Bin√§rzeichenfolge und alle Teilzeichenfolgen der anderen in <em>O (n log n)</em> - eine Art Magie!  Aber glauben Sie mir, das ist absolut real, und manchmal tun es die Leute. </p><br><p>  Aber nicht in ClickHouse.  F√ºr uns arbeiten wir mit | Sigma |  = 30 ist bereits gro√ü, und die FFT ist nicht der angenehmste praktische Algorithmus f√ºr den Prozessor oder, wie sie bei gew√∂hnlichen Menschen sagen, "die Konstante ist gro√ü". </p><br><p>  Aus diesem Grund haben wir uns f√ºr andere Metriken entschieden.  Wir sind zur Bioinformatik gekommen, wo die Leute den n-Gramm-Abstand verwenden.  Tats√§chlich nehmen wir alle n-Gramm Heuhaufen und Nadel, betrachten 2 Multisets mit diesen n-Gramm.  Dann nehmen wir die symmetrische Differenz und dividieren durch die Summe der Kardinalit√§ten zweier Multisets mit n-Gramm.  Wir erhalten eine Zahl von 0 bis 1 - je n√§her an 0, desto √§hnlicher sind die Linien.  Betrachten Sie ein Beispiel mit <em>n = 4</em> : </p><br><pre> <code class="plaintext hljs">abcda ‚Üí {abcd, bcda}; Size = 2 bcdab ‚Üí {bcda, cdab}; Size = 2         . |{abcd, cdab}| / (2 + 2) = 0.5</code> </pre> <br><p>  Infolgedessen haben wir einen Abstand von 4 Gramm festgelegt und eine Reihe von Ideen von SSE dort festgehalten. Au√üerdem haben wir die Implementierung f√ºr Doppelbyte-crc32-Hashes leicht geschw√§cht. </p><br><p><img src="https://habrastorage.org/webt/ad/36/uk/ad36ukzmrspftbjxxwbc3djljv4.png"><br></p><br><p>  √úberpr√ºfen Sie die <a href="">Implementierung</a> .  Achtung: Sehr √ºberzeugender und optimierter Code f√ºr Compiler. </p><br><p>  Ich rate Ihnen besonders, auf den <a href="">schmutzigen Hack</a> zu achten, um Kleinbuchstaben f√ºr ASCII- und russische Codepunkte zu setzen. </p><br><p>  - <code>ngramDistance(haystack, needle)</code> - gibt eine Zahl von 0 bis 1 zur√ºck;  Je n√§her an 0, desto mehr Linien sind einander √§hnlich. <br>  - -UTF8, -CaseInsensitive, -CaseInsensitiveUTF8 (Dirty Hack f√ºr Russen und ASCII). </p><br><p>  Hyperscan steht auch nicht still - es verf√ºgt √ºber Funktionen f√ºr die ungef√§hre Suche: Sie k√∂nnen nach Linien suchen, die wie regul√§re Ausdr√ºcke aussehen, indem Sie Levenshteins konstanten Abstand angeben.  Es wird ein <em>Abstand + 1-</em> Automat erstellt, der durch L√∂schen, Ersetzen oder Einf√ºgen eines Zeichens, was ‚Äûgut‚Äú bedeutet, miteinander verbunden wird. Anschlie√üend wird der √ºbliche Algorithmus zum √úberpr√ºfen, ob ein Automat eine bestimmte Zeile akzeptiert, angewendet.  In ClickHouse haben wir sie unter folgenden Namen implementiert: </p><br><p>  - <code>multiFuzzyMatchAny(haystack, distance, [n_1, ..., n_k])</code> - √§hnlich wie multiMatchAny, nur mit Entfernung. <br>  - <code>multiFuzzyMatchAnyIndex(haystack, distance, [n_1, ..., n_k])</code> - √§hnlich wie multiMatchAnyIndex, nur mit Entfernung. </p><br><p>  Mit zunehmender <em>Entfernung</em> beginnt sich <em>die</em> Geschwindigkeit stark zu verschlechtern, bleibt aber immer noch auf einem recht anst√§ndigen Niveau. </p><br><p>  Beenden Sie die Suche und beginnen Sie mit der Verarbeitung von UTF-8-Zeichenfolgen.  Es gab auch viele interessante Dinge. </p><br><h2 id="obrabotka-utf-8-strok">  UTF-8-Zeilenverarbeitung </h2><br><p>  Ich gebe zu, dass es schwierig war, die Obergrenze f√ºr naive Implementierungen in UTF-8-codierten Zeichenfolgen zu durchbrechen.  Es war besonders schwierig, SIMD zu schrauben.  Ich werde einige Ideen dazu teilen. </p><br><p>  Erinnern Sie sich daran, wie eine g√ºltige UTF-8-Sequenz aussieht: </p><br><p><img src="https://habrastorage.org/webt/iu/xn/zu/iuxnzucrcetohvgsxb7ozohxwws.png"><br></p><br><p>  Versuchen wir, die L√§nge des Codepunkts durch das erste Byte zu berechnen.  Hier beginnt etwas Magie.  Wieder schreiben wir ein paar Eigenschaften: </p><br><p>  - Beginnend bei 0xC <em>und bei 0xD</em> haben 2 Bytes <br>  - 0xC2 = 11 <u>0</u> 00010 <br>  - 0xDF = 11 <u>0</u> 11111 <br>  - 0xE0 = 111 <u>0</u> 0000 <br>  - 0xF4 = 1111 <u>0</u> 100, es gibt nichts weiter als 0xF4, aber wenn es 0xF8 g√§be, w√ºrde es eine andere Geschichte geben <br>  - Beantworten Sie 7 abz√ºglich der Position der ersten Null vom Ende, wenn es sich nicht um ein ASCII-Zeichen handelt </p><br><p>  Wir berechnen die L√§nge: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seqLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> UInt8 first_octet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_octet &lt; <span class="hljs-number"><span class="hljs-number">0x80</span></span>u) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first_zero = bitScanReverse(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;UInt8&gt;(~first_octet)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> - first_zero; }</code> </pre> <br><p>  Gl√ºcklicherweise haben wir Anweisungen auf Lager, die die Anzahl der Nullbits berechnen k√∂nnen, beginnend mit den wichtigsten. </p><br><pre> <code class="cpp hljs">f = __builtin_clz(val) <span class="hljs-comment"><span class="hljs-comment">// (bsrl,     ) f(2) = 30, f(8) = 28, f(7) = 29</span></span></code> </pre> <br><p>  BitScanReverse berechnen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitScanReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> - __builtin_clz(x); }</code> </pre> <br><p>  Versuchen wir, die L√§nge eines UTF-8-Strings anhand von Codepunkten √ºber SIMD zu berechnen.  Betrachten Sie dazu jedes Byte als vorzeichenbehaftete Nummer und beachten Sie die folgenden Eigenschaften: </p><br><p>  - 0xBF = -65 <br>  - 0x80 = -128 <br>  - 0xC2 = -62 <br>  - 0x7F = 127 <br>  - Alle ersten Bytes sind in [0xC2, 0x7F] <br>  - Alle nicht ersten Bytes befinden sich in [0x80, 0xBF] </p><br><p>  Der Algorithmus ist recht einfach.  Vergleichen Sie jedes Byte mit -65 und f√ºgen Sie eines hinzu, wenn es gr√∂√üer als diese Zahl ist.  Wenn wir SIMD verwenden m√∂chten, ist dies die √ºbliche Last von 16 Bytes aus dem Eingabestream.  Dann gibt es einen Byte-Vergleich, der im Falle eines positiven Ergebnisses das Byte 0xFF ergibt, und im Falle eines negativen - 0x00.  Dann der <code>pmovmskb</code> , der die hohen Bits jedes Bytes des Registers sammelt.  <code>popcnt</code> die Anzahl der Unterstriche erh√∂ht, verwenden wir den intrinsischen <code>popcnt</code> f√ºr den <code>popcnt</code> SSE4.  Das Schema dieses Algorithmus kann anhand eines Beispiels veranschaulicht werden: </p><br><p><img src="https://habrastorage.org/webt/gn/mh/q5/gnmhq5lwynwpkdmqe2k3xsowxfs.png"><br></p><br><p>  Es stellt sich heraus, dass zusammen mit der Dekomprimierung die Verarbeitung pro Kern ungef√§hr 1,5 GB / s betr√§gt. </p><br><p>  Die Funktionen hei√üen: </p><br><p>  - <code>lengthUTF8(string)</code> - <code>lengthUTF8(string)</code> die L√§nge eines korrekt codierten UTF-8-Strings zur√ºck. Etwas wird als ung√ºltig angesehen. Eine Ausnahme wird nicht ausgel√∂st. </p><br><p>  Wir sind noch weiter gegangen, weil wir mit UTF-8-String-Verarbeitung noch mehr Funktionen wollten.  √úberpr√ºfen Sie beispielsweise die G√ºltigkeit und wandeln Sie sie in einen g√ºltigen UTF-8-Ausdruck um. </p><br><p>  Um die G√ºltigkeit zu √ºberpr√ºfen, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/cyb70289/utf8/ verwendet</a> , angepasst f√ºr ClickHouse (hat gerade die Verarbeitung der Schw√§nze ge√§ndert) und eine Geschwindigkeit von 1,22 GB / s im Vergleich zu 900 MB / s f√ºr den naiven Algorithmus erhalten .  Ich werde den Algorithmus selbst nicht beschreiben, er ist f√ºr die Wahrnehmung ziemlich kompliziert. </p><br><p>  - <code>isValidUTF8(string)</code> - gibt 1 zur√ºck, wenn die Zeichenfolge korrekt mit UTF-8 codiert ist, andernfalls 0. <br>  - <code>toValidUTF8(string)</code> - <code>toValidUTF8(string)</code> ung√ºltige UTF-8-Zeichen durch das Zeichen   (U + FFFD).  Alle aufeinanderfolgenden ung√ºltigen Zeichen werden zu einem Ersatzzeichen zusammengefasst.  Keine Raketenwissenschaft. </p><br><p>  Im Allgemeinen ist es in UTF-8-Leitungen aufgrund des nicht so angenehmen statischen Schemas immer schwierig, etwas zu finden, das gut optimiert ist. </p><br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  Ich m√∂chte Sie daran erinnern, dass dies meine These war.  Nat√ºrlich habe ich sie f√ºr 10/10 verteidigt.  Wir sind bereits mit ihr nach Highload ++ Siberia gefahren (obwohl es mir so schien, als w√§re sie f√ºr niemanden von Interesse).  Sehen Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation an</a> .  Mir hat gefallen, dass der praktische Teil der Arbeit zu vielen interessanten Forschungsarbeiten gef√ºhrt hat.  Und hier ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diplom</a> selbst.  Es hat viele Tippfehler, weil niemand es gelesen hat.  :) :) </p><br><p>  Im Rahmen der Vorbereitung des Diploms habe ich eine Reihe √§hnlicher Arbeiten durchgef√ºhrt (Links f√ºhren zu Poolanfragen): </p><br><p>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2-mal optimierte Concat-Funktion</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das einfachste Python-Format f√ºr Anfragen erstellt</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschleunigtes LZ4 um 4%</a> ; <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich habe auf SIMD f√ºr ARM und PPC64LE gro√üartige Arbeit geleistet</a> . <br>  - Und er beriet einige Studenten des FCS mit Diplomen in ClickHouse. </p><br><p>  Am Ende stellte sich heraus, dass nach meiner Erfahrung <del>  Jeden Monat versuchte Lesha mich zu singen </del>  ClickHouse ist das angenehmste System zum Schreiben von Hochleistungscode mit Dokumentation, Kommentaren, hervorragender Unterst√ºtzung f√ºr Entwickler und Entwickler.  ClickHouse ist wirklich gro√üartig.  Sind Sie es leid, JSON-Formate zu √§ndern?  Kommen Sie nach Lesha und fragen Sie nach einer Aufgabe jeder Stufe - er wird sie f√ºr Sie bereitstellen, und √ºber das Wochenende werden Sie gro√üe Freude daran haben, Code zu schreiben. </p><br><p>  Aber bei all den Errungenschaften von ClickHouse und seinem Design geht es wahrscheinlich nicht um sie.  Nicht prim√§r in ihnen. </p><br><p>  Ich habe 4 Jahre Grundstudium an der FCS absolviert. Im Juni habe ich die HSE mit Auszeichnung abgeschlossen und anderthalb Jahre in einem gro√üartigen Team in Yandex gearbeitet, nachdem ich gut gepumpt war.  Die ganze Zeit ohne totale Erfahrung <del>  und Eisen </del>  Nichts in der Post geschrieben h√§tte funktioniert.  FCN ist sehr cool, wenn man das Maximum daraus zieht.  Vielen Dank an Vana Puzyrevsky <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ivan_puzyrevskiy</a> , Ignat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Kolesnichenko</a> , Gleb Evstropov und Max Babenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">maxim_babenko</a> f√ºr das Treffen in meinem lustigen Abenteuer auf dem FCN.  Und auch danke an alle Lehrer, die mir etwas beigebracht haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466183/">https://habr.com/ru/post/de466183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466165/index.html">Wie k√ºnstliche Intelligenz bei der Verwaltung von Projekten hilft</a></li>
<li><a href="../de466169/index.html">Sonderangebot f√ºr berufst√§tige Studenten von JetBrains</a></li>
<li><a href="../de466171/index.html">F√ºnf Gr√ºnde f√ºr JUG.EKB</a></li>
<li><a href="../de466179/index.html">fform: React & JSONSchema - maximale Flexibilit√§t</a></li>
<li><a href="../de466181/index.html">Python von C (C API)</a></li>
<li><a href="../de466187/index.html">Visual Logic Editor f√ºr Unity3d. Teil 2</a></li>
<li><a href="../de466191/index.html">Die Hauptsache im Kampf um die Netzneutralit√§t in den USA ist die Chronologie der Ereignisse und der aktuelle Stand der Dinge</a></li>
<li><a href="../de466193/index.html">Benutzerdefinierter MailChimp-Auto-Feed aus RSS-Feed</a></li>
<li><a href="../de466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../de466197/index.html">PVS-Studio 7.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>