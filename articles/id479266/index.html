<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 👐🏻 🧦 Analisis beban CPU yang dihasilkan oleh masing-masing komponen JavaScript 🤚🏽 👩‍🚀 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita bicara sedikit tentang bagaimana mengamati berapa banyak sumber daya CPU yang dikonsumsi oleh kode JavaScript aplikasi. Pada saat yang sama,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis beban CPU yang dihasilkan oleh masing-masing komponen JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/479266/">  Mari kita bicara sedikit tentang bagaimana mengamati berapa banyak sumber daya CPU yang dikonsumsi oleh kode JavaScript aplikasi.  Pada saat yang sama, saya mengusulkan untuk membangun percakapan kami di sekitar komponen - blok bangunan dasar aplikasi.  Dengan pendekatan ini, segala upaya untuk meningkatkan produktivitas (atau upaya untuk menemukan penyebab pelambatan program) dapat difokuskan pada (mudah-mudahan) fragmen kecil proyek yang mandiri.  Pada saat yang sama, saya berasumsi bahwa aplikasi front-end Anda, seperti banyak proyek modern lainnya, dibuat dengan merakit fragmen kecil dari antarmuka yang cocok untuk penggunaan berulang.  Jika tidak demikian, maka alasan kami dapat diterapkan ke aplikasi lain, tetapi Anda harus menemukan cara Anda sendiri untuk membagi kode skala besar Anda menjadi fragmen dan Anda perlu memikirkan cara menganalisis fragmen ini. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/479266/"><img src="https://habrastorage.org/webt/cx/wv/2y/cxwv2ylp34aq6hzys-fss3azza0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mengapa ini dibutuhkan?</font> </h2><br>  Mengapa mengukur konsumsi CPU dengan JavaScript?  Faktanya adalah bahwa hari ini, kinerja aplikasi paling sering dikaitkan dengan kemampuan prosesor.  Izinkan saya mengutip kata-kata Steve Soders dan Pat Minan dengan bebas dari wawancara yang saya ambil untuk <a href="https://podcast.perfplanet.com/">Planet Performance Podcast</a> .  Keduanya mengatakan bahwa kinerja aplikasi tidak lagi terbatas pada kemampuan jaringan atau latensi jaringan.  Jaringan semakin cepat dan semakin cepat.  Para pengembang, di samping itu, belajar untuk mengompres respons teks server menggunakan GZIP (atau, lebih tepatnya, menggunakan brotli) dan menemukan cara untuk mengoptimalkan gambar.  Semuanya sangat sederhana. <br><br>  Hambatan kinerja aplikasi modern adalah prosesor.  Ini terutama berlaku di lingkungan seluler.  Dan pada saat yang sama, harapan kami tentang kemampuan interaktif aplikasi web modern telah berkembang.  Kami berharap antarmuka aplikasi tersebut akan bekerja dengan sangat cepat dan lancar.  Dan semua ini membutuhkan lebih banyak kode JavaScript.  Selain itu, kita harus ingat bahwa 1 MB gambar tidak sama dengan 1 MB JavaScript.  Gambar diunduh secara progresif, dan aplikasi saat ini memecahkan masalah lain.  Tetapi kode JavaScript sering berupa sumber daya seperti itu, yang tanpanya aplikasi menjadi tidak berfungsi.  Untuk memastikan berfungsinya aplikasi modern, diperlukan sejumlah besar kode JS, yang, sebelum benar-benar berfungsi, harus diuraikan dan dijalankan.  Dan ini adalah tugas yang sangat bergantung pada kemampuan prosesor. <br><br><h2>  <font color="#3AC1EF">Indikator kinerja</font> </h2><br>  Kami akan menggunakan indikator kecepatan fragmen kode seperti jumlah instruksi prosesor yang diperlukan untuk memprosesnya.  Ini akan memungkinkan kami untuk memisahkan pengukuran dari sifat-sifat komputer tertentu dan dari keadaan di mana ia berada pada saat pengukuran.  Metrik berbasis waktu (seperti TTI) memiliki terlalu banyak "noise".  Mereka tergantung pada keadaan koneksi jaringan, serta pada hal lain yang terjadi pada komputer pada saat pengukuran.  Sebagai contoh, beberapa skrip yang dieksekusi saat memuat halaman yang diselidiki, atau virus yang sibuk dengan sesuatu di proses latar belakang, dapat mempengaruhi indikator kinerja temporal.  Hal yang sama dapat dikatakan tentang ekstensi browser, yang dapat menghabiskan banyak sumber daya sistem dan memperlambat halaman.  Ketika menghitung jumlah instruksi prosesor, di sisi lain, waktu tidak menjadi masalah.  Indikator-indikator seperti itu, seperti yang akan segera Anda lihat, benar-benar stabil. <br><br><h2>  <font color="#3AC1EF">Ide</font> </h2><br>  Inilah ide yang melatarbelakangi pekerjaan kami: kami perlu membuat "laboratorium" tempat kode akan diluncurkan dan diperiksa ketika ada perubahan.  Yang saya maksud dengan "laboratorium" adalah komputer biasa, mungkin komputer yang sering Anda gunakan.  Sistem kontrol versi memberi kami kait yang dapat digunakan untuk mencegat peristiwa tertentu dan melakukan pemeriksaan tertentu.  Tentu saja, pengukuran di "laboratorium" dapat dilakukan setelah melakukan.  Tetapi Anda mungkin tahu bahwa perubahan pada kode yang telah mencapai tahap komit akan dibuat lebih lambat dari pada kode yang sedang ditulis (jika ada).  Hal yang sama berlaku untuk memperbaiki kode beta produk, dan memperbaiki kode yang masuk ke produksi. <br><br>  Kami membutuhkan setiap kali kode diubah, kinerjanya dibandingkan sebelum dan setelah perubahan dibuat.  Dalam melakukannya, kami berusaha untuk menyelidiki komponen secara terpisah.  Sebagai hasilnya, kita akan dapat dengan jelas melihat masalah dan dapat mengetahui dengan tepat di mana mereka muncul. <br><br>  Hal yang baik adalah bahwa studi seperti itu dapat dilakukan di browser nyata, menggunakan, misalnya, Dalang.  Ini adalah alat yang memungkinkan Anda untuk mengontrol browser tanpa antarmuka pengguna dari Node.js. <br><br><h2>  <font color="#3AC1EF">Cari kode untuk penelitian</font> </h2><br>  Untuk menemukan kode studi, kita dapat merujuk ke panduan gaya apa pun, atau ke sistem desain apa pun.  Secara umum, kami senang dengan apa pun yang memberikan contoh singkat dan terisolasi dari penggunaan komponen. <br><br>  Apa itu "panduan gaya"?  Ini biasanya merupakan aplikasi web yang menunjukkan semua komponen atau "blok bangunan" elemen antarmuka pengguna yang tersedia untuk pengembang.  Ini bisa berupa pustaka tertentu dari komponen pihak ketiga, atau sesuatu yang dibuat oleh upaya Anda sendiri. <br><br>  Saat mencari proyek-proyek semacam itu di Internet, saya menemukan <a href="https://twitter.com/toggleModal/status/1189913353902276608">utas</a> diskusi baru-baru ini di Twitter yang berbicara tentang perpustakaan komponen React yang relatif baru.  Saya melihat beberapa perpustakaan yang disebutkan di sana. <br><br>  Tidak mengherankan, perpustakaan modern berkualitas tinggi disediakan dengan dokumentasi yang mencakup contoh kode kerja.  Berikut adalah beberapa komponen perpustakaan dan <code>Button</code> diimplementasikan dengan cara mereka.  Dokumentasi untuk perpustakaan ini berisi contoh penggunaan komponen ini.  Kita berbicara tentang perpustakaan Chakra dan perpustakaan Semantic UI React. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/95d/a0c/64c95da0c7b84620135e33e377c47bd2.png"></div><br>  <i><font color="#999999">Dokumentasi Komponen Tombol</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d3/b45/093/7d3b45093ae1f8c6d99e174ca389a9e0.png"></div><br>  <i><font color="#999999">Tombol Semantic UI React Documentation</font></i> <br><br>  Inilah yang kita butuhkan.  Ini adalah contoh kode yang dapat kita periksa untuk konsumsi sumber daya prosesor mereka.  Contoh serupa dapat ditemukan di isi dokumentasi, atau dalam kode komentar yang ditulis dengan gaya JSDoc.  Mungkin, jika Anda beruntung, Anda akan menemukan contoh seperti itu, yang dirancang sebagai file terpisah, katakanlah, dalam bentuk file tes unit.  Tentunya akan begitu.  Bagaimanapun, kita semua menulis unit test.  Benar? <br><br><h2>  <font color="#3AC1EF">File</font> </h2><br>  Bayangkan, demi menunjukkan metode analisis kinerja yang dijelaskan, bahwa ada komponen <code>Button</code> di perpustakaan yang sedang kita pelajari, kode yang ada di file <code>Button.js</code> . File dengan unit test <code>Button-test.js</code> dilampirkan ke file ini, serta file dengan contoh penggunaan komponen - <code>Button-example.js</code> .  Kita perlu membuat semacam halaman pengujian, di lingkungan di mana kode tes dapat dijalankan.  Sesuatu seperti <code>test.html</code> . <br><br><h2>  <font color="#3AC1EF">Komponen</font> </h2><br>  Berikut adalah komponen <code>Button</code> sederhana.  Saya menggunakan Bereaksi di sini, tetapi komponen Anda dapat ditulis menggunakan teknologi apa pun yang nyaman untuk Anda. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span>  props.href    ? &lt;a {...props} className="Button"/&gt;    : &lt;button {...props} className="Button"/&gt; export default Button;</code> </pre> <br><h2>  <font color="#3AC1EF">Contoh</font> </h2><br>  Dan ini adalah contoh penggunaan komponen <code>Button</code> .  Seperti yang Anda lihat, dalam hal ini ada dua opsi komponen yang menggunakan properti berbeda. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> alert('ouch')}&gt;    Click me  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>,  &lt;Button href=<span class="hljs-string"><span class="hljs-string">"https://reactjs.com"</span></span>&gt;    Follow me  &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Button&gt;, ]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Tes</font> </h2><br>  Berikut adalah halaman <code>test.html</code> yang dapat memuat komponen apa pun.  Perhatikan pemanggilan metode ke objek <code>performance</code> .  Dengan bantuan mereka, kami, atas permintaan kami, menulis ke file log kinerja Chrome.  Kami akan segera menggunakan catatan ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> examples =  <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(location.hash + <span class="hljs-string"><span class="hljs-string">'-example.js'</span></span>); examples.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">example</span></span></span><span class="hljs-function"> =&gt;</span></span>  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>);  ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{example}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, where);  performance.mark(<span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>);  performance.measure(    <span class="hljs-string"><span class="hljs-string">'my mark'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark start'</span></span>, <span class="hljs-string"><span class="hljs-string">'my mark end'</span></span>); );</code> </pre> <br><h2>  <font color="#3AC1EF">Pelari ujian</font> </h2><br>  Untuk memuat halaman pengujian di Chrome, kita dapat menggunakan perpustakaan <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> Node.js, yang memberi kita akses ke API untuk mengelola browser.  Anda dapat menggunakan perpustakaan ini di sistem operasi apa pun.  Ini memiliki salinan Chrome sendiri, tetapi juga dapat digunakan untuk bekerja dengan instance Chrome atau Chromium dari berbagai versi yang sudah ada di komputer pengembang.  Chrome dapat diluncurkan sehingga jendelanya tidak terlihat.  Pengujian dilakukan secara otomatis, sementara pengembang tidak perlu melihat jendela browser.  Chrome dapat diluncurkan dalam mode normal.  Ini berguna untuk keperluan debugging. <br><br>  Berikut ini contoh skrip Node.js yang dijalankan dari baris perintah yang memuat halaman pengujian dan menulis data ke file log kinerja.  Segala sesuatu yang terjadi di browser antara <code>tracing.start()</code> dan <code>end()</code> perintah ditulis (saya ingin mencatat, dengan sangat rinci) ke file <code>trace.json</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pup.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.start({<span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'trace.json'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'test.html#Button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.tracing.stop(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.close();</code> </pre> <br>  Pengembang dapat mengelola "detail" data kinerja dengan menentukan "kategori" penelusuran.  Anda dapat melihat daftar kategori yang tersedia jika Anda membuka Chrome di <code>chrome://tracing</code> , klik <code>Record</code> dan buka bagian <code>Edit categories</code> di jendela yang muncul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/047/a3e/51e047a3e5a8b6980192bc6eb6c3047a.png"></div><br>  <i><font color="#999999">Mengkonfigurasi komposisi data yang ditulis ke log kinerja</font></i> <br><br><h2>  <font color="#3AC1EF">Hasil</font> </h2><br>  Setelah halaman pengujian diperiksa menggunakan Puppeteer, Anda dapat menganalisis hasil pengukuran kinerja dengan membuka browser di <code>chrome://tracing</code> dan mengunduh file <code>trace.json</code> baru direkam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/13b/47c/63c13b47c6bf063822716d5cf13d2830.png"></div><br>  <i><font color="#999999">Trace.json visualisasi</font></i> <br><br>  Di sini Anda dapat melihat hasil memanggil metode <code>performance.measure('my mark')</code> .  Panggilan <code>trace.json</code> <code>measure()</code> hanya untuk keperluan debugging, jika pengembang ingin membuka file <code>trace.json</code> dan melihatnya.  Segala sesuatu yang terjadi dengan halaman terlampir di blok <code>my mark</code> . <br><br>  Berikut ini <code>trace.json</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/9ac/4a4/b769ac4a4abd96771a74255a12a4522c.png"></div><br>  <i><font color="#999999">Fragmen file trace.json</font></i> <br><br>  Untuk mengetahui apa yang kita butuhkan, cukup dengan mengurangkan indikator jumlah instruksi prosesor ( <code>ticount</code> ) dari <code>Start</code> marker dari indikator <code>End</code> marker yang sama.  Ini memungkinkan Anda mengetahui berapa banyak instruksi prosesor yang diperlukan untuk menampilkan komponen di browser.  Ini adalah nomor yang sama yang dapat Anda gunakan untuk mencari tahu apakah suatu komponen menjadi lebih cepat atau lebih lambat. <br><br><h2>  <font color="#3AC1EF">Iblis ada dalam perinciannya</font> </h2><br>  Sekarang kami hanya mengukur indikator yang mengkarakterisasi output pertama ke halaman komponen tunggal.  Dan tidak lebih.  Sangat penting untuk mengukur indikator yang terkait dengan jumlah kode terkecil yang dapat dieksekusi.  Ini memungkinkan Anda mengurangi tingkat "noise".  Iblis ada dalam perinciannya.  Semakin kecil kinerja yang diukur, semakin baik.  Setelah pengukuran, perlu untuk menghapus dari hasil yang diperoleh apa yang di luar pengaruh pengembang.  Misalnya, data yang terkait dengan operasi pengumpulan sampah.  Komponen tidak mengontrol operasi seperti itu.  Jika dijalankan, ini berarti bahwa browser, dalam proses rendering komponen, memutuskan untuk meluncurkannya sendiri.  Akibatnya, sumber daya prosesor yang pergi ke pengumpulan sampah harus dihapus dari hasil akhir. <br><br>  Blok data yang terkait dengan pengumpulan sampah ("blok data" ini lebih tepat disebut "peristiwa") disebut <code>V8.GCScavenger</code> .  <code>tidelta</code> nya harus dikurangi dari jumlah instruksi prosesor yang masuk ke rendering komponen.  <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">Berikut adalah</a> dokumentasi untuk melacak peristiwa.  Benar, ini sudah usang, dan tidak mengandung informasi tentang indikator yang kita butuhkan: <br><br><ul><li>  <code>tidelta</code> - jumlah instruksi prosesor yang diperlukan untuk memproses suatu peristiwa. </li><li>  <code>ticount</code> - jumlah instruksi untuk memulai acara. </li></ul><br>  Anda harus sangat berhati-hati tentang apa yang kami ukur.  Browser adalah entitas yang sangat cerdas.  Mereka mengoptimalkan kode yang berjalan lebih dari sekali.  Pada grafik berikutnya, Anda dapat melihat jumlah instruksi prosesor yang diperlukan untuk menampilkan komponen tertentu.  Operasi rendering pertama membutuhkan sumber daya terbanyak.  Operasi selanjutnya membuat beban yang jauh lebih rendah pada prosesor.  Ini harus diingat ketika menganalisis kinerja kode. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/880/329/857/880329857fe02edf503db2e4bff07380.png"></div><br>  <i><font color="#999999">10 operasi rendering dari komponen yang sama</font></i> <br><br>  Berikut ini detail lainnya: jika komponen melakukan beberapa operasi asinkron (misalnya, menggunakan <code>setTimeout()</code> atau <code>fetch()</code> ), maka beban pada sistem yang dibuat oleh kode asinkron tidak diperhitungkan.  Mungkin itu baik.  Mungkin itu buruk.  Jika Anda sedang menyelidiki kinerja komponen tersebut, pertimbangkan studi terpisah tentang kode asinkron. <br><br><h2>  <font color="#3AC1EF">Sinyal kuat</font> </h2><br>  Jika Anda mengambil pendekatan yang bertanggung jawab untuk menyelesaikan masalah apa yang sebenarnya diukur, Anda bisa mendapatkan sinyal yang benar-benar stabil yang mencerminkan dampak pada kinerja setiap perubahan.  Saya suka kelancaran garis-garis pada grafik berikutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/905/b1b/58b/905b1b58bd6e5fdbb34f4e0b0dedaebd.png"></div><br>  <i><font color="#999999">Hasil pengukuran yang stabil</font></i> <br><br>  Grafik bawah menunjukkan hasil pengukuran 10 operasi rendering elemen <code>&lt;span&gt;</code> sederhana di Bereaksi.  Tidak ada lagi yang termasuk dalam hasil ini.  Ternyata operasi ini membutuhkan dari 2,15 hingga 2,2 juta instruksi prosesor.  Jika Anda membungkus <code>&lt;span&gt;</code> dalam <code>&lt;p&gt;</code> , maka untuk menghasilkan desain seperti itu Anda membutuhkan sekitar 2,3 juta instruksi.  Tingkat akurasi ini mengejutkan saya.  Jika pengembang dapat melihat perbedaan kinerja yang muncul ketika satu elemen <code>&lt;p&gt;</code> ditambahkan ke halaman, ini berarti pengembang memiliki alat yang sangat kuat di tangan mereka. <br><br>  Bagaimana tepatnya mewakili pengukuran keakuratan terserah pengembang.  Jika dia tidak membutuhkan keakuratan seperti itu, dia selalu dapat mengukur kinerja rendering dari fragmen yang lebih besar. <br><br><h2>  <font color="#3AC1EF">Informasi kinerja tambahan</font> </h2><br>  Sekarang pengembang memiliki sistem untuk menemukan indikator numerik yang sangat akurat mengkarakterisasi kinerja fragmen kode terkecil, pengembang dapat menggunakan sistem ini untuk menyelesaikan berbagai masalah.  Jadi, menggunakan <code>performance.mark()</code> Anda dapat menulis informasi berguna tambahan untuk <code>trace.json</code> .  Anda dapat memberi tahu anggota tim pengembangan apa yang terjadi dan apa yang menyebabkan peningkatan jumlah instruksi prosesor yang diperlukan untuk menjalankan beberapa kode.  Anda dapat memasukkan informasi laporan kinerja tentang jumlah node DOM, atau tentang jumlah operasi penulisan dalam DOM yang dilakukan oleh React.  Bahkan, di sini Anda dapat menampilkan informasi tentang banyak hal.  Anda dapat menghitung jumlah perhitungan ulang tata letak halaman.  Menggunakan Puppeteer Anda dapat mengambil tangkapan layar halaman dan membandingkan tampilan antarmuka sebelum dan sesudah membuat perubahan.  Terkadang peningkatan jumlah instruksi prosesor yang diperlukan untuk menampilkan halaman terlihat benar-benar tidak mengejutkan.  Misalnya, jika 10 tombol dan 12 bidang untuk mengedit dan memformat teks ditambahkan ke versi halaman yang baru. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Apakah mungkin bagi semua orang yang dibahas di sini untuk menggunakannya hari ini?  Ya kamu bisa.  Untuk melakukan ini, Anda perlu Chrome versi 78 atau lebih tinggi.  Jika <code>trace.json</code> memiliki <code>tidelta</code> dan <code>tidelta</code> , maka di atas tersedia untuk Anda.  Versi sebelumnya dari Chrome tidak. <br><br>  Sayangnya, informasi tentang jumlah instruksi prosesor tidak dapat diperoleh pada platform Mac.  Saya belum mencoba Windows, jadi saya tidak bisa mengatakan apa-apa tentang OS ini.  Secara umum - teman-teman kita adalah Unix dan Linux. <br><br>  Perlu dicatat bahwa agar browser dapat memberikan informasi tentang instruksi prosesor, Anda perlu menggunakan beberapa flag - ini adalah <code>--no-sandbox</code> dan <code>--enable-thread-instruction-count</code> .  Berikut ini cara meneruskannya ke browser yang diluncurkan oleh Puppeteer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({  <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [    <span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>,    <span class="hljs-string"><span class="hljs-string">'--enable-thread-instruction-count'</span></span>,  ]});</code> </pre> <br>  Semoga sekarang Anda dapat membawa analisis kinerja aplikasi web Anda ke tingkat selanjutnya. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda berencana untuk menggunakan metodologi untuk menganalisis kinerja proyek web yang disajikan di sini? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub"><img src="https://habrastorage.org/webt/yx/3g/bv/yx3gbv0xlht1gyjfwlg2z_kgylo.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479266/">https://habr.com/ru/post/id479266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479252/index.html">Daftar Pemahaman vs Peta</a></li>
<li><a href="../id479256/index.html">Di bangun dari Astrotracker di Two Evenings - My Experience</a></li>
<li><a href="../id479258/index.html">IGF 2019. Apakah Internet berantakan?</a></li>
<li><a href="../id479262/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 392 (2 - 8 Desember 2019)</a></li>
<li><a href="../id479264/index.html">Warna Bulan dan Matahari dari ruang angkasa dalam hal RGB dan suhu warna</a></li>
<li><a href="../id479268/index.html">Pendengar Acara dan Pekerja Web</a></li>
<li><a href="../id479270/index.html">Apa yang baru dapat Anda harapkan dari Node.js pada tahun 2020?</a></li>
<li><a href="../id479272/index.html">[bookmark] 9 alat yang meningkatkan produktivitas pengembang web</a></li>
<li><a href="../id479274/index.html">10 Trik Python untuk Diketahui</a></li>
<li><a href="../id479276/index.html">Tiga Metode Pandas yang Mungkin Tidak Anda Ketahui</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>