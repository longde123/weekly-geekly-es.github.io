<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏾 👨‍🎓 💪 Gestion élégante des erreurs JavaScript avec la monade Either 🐕 😀 👩🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parlons un peu de la façon dont nous traitons les erreurs. En JavaScript, nous avons une fonction de langage intégrée pour travailler avec des excepti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion élégante des erreurs JavaScript avec la monade Either</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457098/"> Parlons un peu de la façon dont nous traitons les erreurs.  En JavaScript, nous avons une fonction de langage intégrée pour travailler avec des exceptions.  Nous enfermons le code problématique dans la construction <code>try...catch</code> .  Cela vous permet de spécifier un chemin d'exécution normal dans la section <code>try</code> , puis de traiter toutes les exceptions dans la section <code>catch</code> .  Pas une mauvaise option.  Cela vous permet de vous concentrer sur la tâche en cours sans penser à toutes les erreurs possibles.  Certainement mieux que de colmater votre code avec des ifs sans fin. <br><br>  Sans <code>try...catch</code> il est difficile de vérifier les résultats de chaque appel de fonction pour des valeurs inattendues.  Ceci est une conception utile.  Mais elle a certains problèmes.  Et ce n'est pas le seul moyen de gérer les erreurs.  Dans cet article, nous verrons comment utiliser la <b>monade Either</b> comme alternative pour <code>try...catch</code> . <br><br>  Avant de poursuivre, je note quelques points.  L'article suppose que vous connaissez déjà la composition des fonctions et le curry.  Et un avertissement.  Si vous n'avez jamais rencontré de monades auparavant, elles peuvent sembler vraiment ... étranges.  Travailler avec de tels outils nécessite un changement de mentalité.  Au début, cela peut être difficile. <br><br>  Ne vous inquiétez pas si vous êtes immédiatement confus.  Tout le monde l'a.  À la fin de l'article, j'ai énuméré quelques liens qui pourraient vous aider.  N'abandonnez pas.  Ces choses s'enivrent dès qu'elles pénètrent dans le cerveau. <br><a name="habracut"></a><br><h1>  Exemple de problème </h1><br>  Avant de discuter des problèmes des exceptions, voyons pourquoi elles existent et pourquoi <code>try...catch</code> blocs <code>try...catch</code> sont apparus.  Pour ce faire, regardons un problème que j'ai essayé de rendre au moins partiellement réaliste.  Imaginez que nous écrivons une fonction pour afficher une liste de notifications.  Nous avons déjà réussi (d'une manière ou d'une autre) à renvoyer des données du serveur.  Mais pour une raison quelconque, les ingénieurs du backend ont décidé de l'envoyer au format CSV, pas JSON.  Les données brutes peuvent ressembler à ceci: <br><br><pre>  horodatage, contenu, visualisé, href
 2018-10-27T05: 33: 34 + 00: 00, @ madhatter vous a invité au thé, non lu, https: //example.com/invite/tea/3801
 2018-10-26T13: 47: 12 + 00: 00, @ queenofhearts vous a mentionné dans la discussion sur le 'Tournoi de Croquet', consulté, https: //example.com/discussions/croquet/1168
 2018-10-25T03: 50: 08 + 00: 00, @ cheshirecat vous a envoyé un sourire, non lu, https: //example.com/interactions/grin/88 </pre><br>  Nous voulons l'afficher en HTML.  Cela pourrait ressembler à ceci: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MessageList"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/invite/tea/3801"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@madhatter invited you to tea<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-27T05:33:34+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>27 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/discussions/croquet/1168"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@queenofhearts mentioned you in 'Croquet Tournament' discussion<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-26T13:47:12+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>26 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/interactions/grin/88"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@cheshirecat sent you a grin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-25T03:50:08+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>25 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Pour simplifier la tâche, concentrez-vous simplement sur le traitement de chaque ligne de données CSV pour l'instant.  Commençons par quelques fonctions simples pour le traitement des chaînes.  Le premier divise la chaîne de texte en champs: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> row.split(<span class="hljs-string"><span class="hljs-string">'","'</span></span>); }</code> </pre> <br>  La fonction est ici simplifiée car il s'agit de matériel pédagogique.  Nous traitons la gestion des erreurs, pas l'analyse CSV.  Si l'un des messages contient une virgule, tout cela sera terriblement faux.  Veuillez ne jamais utiliser ce code pour analyser de vraies données CSV.  Si vous avez déjà dû analyser des données CSV, utilisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque d'analyse CSV bien testée</a> . <br><br>  Après avoir fractionné les données, nous voulons créer un objet.  Et pour que chaque nom de propriété corresponde aux en-têtes CSV.  Supposons que nous ayons déjà en quelque sorte analysé la barre de titre (plus à ce sujet plus tard).  Nous sommes arrivés à un point où quelque chose peut mal tourner.  Nous avons eu une erreur de traitement.  Nous lançons une erreur si la longueur de la chaîne ne correspond pas à la barre de titre.  ( <code>_.zipObject</code> est <a href="">une fonction lodash</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (headerFields.length !== fieldData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.zipObject(headerFields, fieldData); }</code> </pre> <br>  Après cela, ajoutez une date lisible par l'homme à l'objet afin de l'afficher dans notre modèle.  Cela s'est avéré un peu bavard, car JavaScript n'a pas une prise en charge intégrée parfaite pour le formatage de la date.  Et encore une fois, nous sommes confrontés à des problèmes potentiels.  Si une date non valide est rencontrée, notre fonction génère une erreur. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {datestr, ...messageObj}; }</code> </pre> <br>  Enfin, prenez l'objet et passez-le dans <a href="">la fonction modèle</a> pour obtenir la chaîne HTML. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowToMessage = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Message Message--&lt;%= viewed %&gt;"&gt; &lt;a href="&lt;%= href %&gt;" class="Message-link"&gt;&lt;%= content %&gt;&lt;/a&gt; &lt;time datetime="&lt;%= datestamp %&gt;"&gt;&lt;%= datestr %&gt;&lt;/time&gt; &lt;li&gt;`</span></span>);</code> </pre> <br>  Il serait également intéressant d'imprimer une erreur si elle se rencontrait: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showError = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Error"&gt;&lt;%= message %&gt;&lt;/li&gt;`</span></span>);</code> </pre> <br>  Lorsque tout est en place, vous pouvez créer une fonction pour traiter chaque ligne. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(e); } }</code> </pre> <br>  La fonction est donc prête.  Examinons de plus près comment il gère les exceptions. <br><br><h1>  Exceptions: la bonne partie </h1><br>  Alors, qu'est-ce qui est bon d' <code>try...catch</code> ?  Il convient de noter que dans l'exemple ci-dessus, l'une des étapes du bloc <code>try</code> peut provoquer une erreur.  Dans <code>zipRow()</code> et <code>addDateStr()</code> nous lançons intentionnellement des erreurs.  Et si un problème survient, attrapez simplement l'erreur et affichez n'importe quel message sur la page.  Sans ce mécanisme, le code devient vraiment moche.  Voici à quoi cela pourrait ressembler.  Supposons que les fonctions ne génèrent pas d'erreurs, mais renvoient <code>null</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowWithoutExceptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Encountered a row with an unexpected number of items'</span></span>)); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unable to parse date in row object'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Comme vous pouvez le voir, un grand nombre de modèles <code>if</code> .  Le code est plus détaillé.  Et il est difficile de suivre la logique de base.  De plus, <code>null</code> ne nous dit pas grand-chose.  Nous ne savons pas vraiment pourquoi l’appel de fonction précédent a échoué.  Nous devons deviner.  Nous créons un message d'erreur et appelons <code>showError()</code> .  Un tel code est plus sale et plus déroutant. <br><br>  Regardez à nouveau la version de gestion des exceptions.  Il sépare clairement le chemin d'accès réussi du programme et le code de gestion des exceptions.  La branche <code>try</code> est un bon moyen, et la branche <code>catch</code> est une erreur.  Toute gestion des exceptions se produit en un seul endroit.  Et les fonctions individuelles peuvent signaler pourquoi elles ont échoué.  Dans l'ensemble, cela semble assez doux.  Je pense que la majorité considère que le premier exemple est tout à fait approprié.  Pourquoi une approche différente? <br><br><h1>  Problèmes de gestion des exceptions, essayez ... catch </h1><br>  Cette approche vous permet d'ignorer ces erreurs gênantes.  Malheureusement, <code>try...catch</code> fait trop bien son travail.  Vous jetez simplement une exception et passez à autre chose.  Nous pouvons l'attraper plus tard.  Et tout le monde a l'intention de toujours mettre de tels blocs, vraiment.  Mais il n'est pas toujours évident où l'erreur va plus loin.  Et le bloc est trop facile à oublier.  Et avant de vous en rendre compte, votre application se bloque. <br><br>  De plus, des exceptions polluent le code.  Nous ne discuterons pas en détail de la pureté fonctionnelle ici.  Mais regardons un petit aspect de la pureté fonctionnelle: la transparence référentielle.  Une fonction transparente de lien renvoie toujours le même résultat pour une entrée particulière.  Mais pour les fonctions avec des exceptions, nous ne pouvons pas dire cela.  Ils peuvent lever une exception à tout moment au lieu de renvoyer une valeur.  Cela complique la logique.  Mais que faire si vous trouvez une option gagnant-gagnant - une façon propre de gérer les erreurs? <br><br><h1>  Nous trouvons une alternative </h1><br>  Les fonctions pures renvoient toujours une valeur (même si cette valeur est manquante).  Par conséquent, notre code de gestion des erreurs doit supposer que nous renvoyons toujours une valeur.  Donc, comme première tentative, que dois-je faire si, en cas d'échec, nous renvoyons un objet Error?  Autrement dit, partout où nous commettons une erreur, nous renvoyons un tel objet.  Cela pourrait ressembler à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowReturningErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObj); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObjWithDate); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Ce n'est pas une mise à niveau spéciale sans exception.  Mais c’est mieux.  Nous avons transféré la responsabilité des messages d'erreur aux fonctions individuelles.  Mais nous avons toujours tous ces ifs.  Ce serait bien d'encapsuler le modèle d'une manière ou d'une autre.  En d'autres termes, si nous savons que nous avons un bogue, ne vous inquiétez pas du reste du code. <br><br><h1>  Polymorphisme </h1><br>  Comment faire  C'est un problème difficile.  Mais il peut être résolu à l'aide de la magie du <i>polymorphisme</i> .  Si vous n'avez jamais rencontré de polymorphisme auparavant, ne vous inquiétez pas.  En substance, il s'agit de «fournir une interface unique pour des entités de types différents» (Straustrup, B. «Glossaire C ++ de Björn Straustrup»).  En JavaScript, cela signifie que nous créons des objets avec les mêmes méthodes et signatures nommées.  Mais un comportement différent.  Un exemple classique est la journalisation des applications.  Nous pouvons envoyer nos magazines à différents endroits en fonction de l'environnement dans lequel nous nous trouvons.  Et si nous créons deux objets enregistreurs, par exemple? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> consoleLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'This is the console logger, logging:'</span></span>, msg); } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ajaxLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'https://example.com/logger'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: msg}); } };</code> </pre> <br>  Les deux objets définissent une fonction de journal qui attend un paramètre de chaîne unique.  Mais ils se comportent différemment.  La beauté est que nous pouvons écrire du code qui appelle <code>.log()</code> , quel que soit l'objet qu'il utilise.  Il peut s'agir de <code>consoleLogger</code> ou <code>ajaxLogger</code> .  Tout fonctionne quand même.  Par exemple, le code ci-dessous fonctionnera aussi bien avec n'importe quel objet: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger, message</span></span></span><span class="hljs-function">) </span></span>{ logger.log(message); }</code> </pre> <br>  Un autre exemple est la méthode <code>.toString()</code> pour tous les objets JS.  Nous pouvons écrire la méthode <code>.toString()</code> pour n'importe quelle classe que nous créons.  Ensuite, vous pouvez créer deux classes qui implémentent la méthode <code>.toString()</code> différemment.  Nous les nommerons <code>Left</code> et <code>Right</code> (un peu plus tard j'expliquerai les noms). <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Left(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Créez maintenant une fonction qui appelle <code>.toString()</code> sur ces deux objets: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } trace(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ⦘ Left(Hello world) trace(new Right('Hello world')); // ⦘ Right(Hello world);</span></span></code> </pre> <br>  Code pas exceptionnel, je sais.  Mais le fait est que nous avons deux types de comportement différents qui utilisent la même interface.  C'est du polymorphisme.  Mais faites attention à quelque chose d'intéressant.  Combien de déclarations if avons-nous utilisées?  Zéro  Pas un seul.  Nous avons créé deux types de comportement différents sans une seule instruction if.  Peut-être que quelque chose comme ça peut être utilisé pour gérer les erreurs ... <br><br><h1>  Gauche et droite </h1><br>  Revenons à notre problème.  Il est nécessaire de déterminer le chemin d'accès réussi et non réussi pour notre code.  Sur un bon chemin, nous continuons simplement à exécuter calmement le code jusqu'à ce qu'une erreur se produise ou que nous le terminions.  Si nous nous trouvons sur la mauvaise voie, nous n'essaierons plus d'exécuter le code.  Nous pourrions nommer ces chemins Happy et Sad, mais essayez de suivre les conventions de dénomination utilisées par d'autres langages de programmation et bibliothèques.  Alors, appelons le mauvais chemin à gauche, et le succès - à droite. <br><br>  Créons une méthode qui exécute la fonction si nous sommes sur un bon chemin, mais ignorons-la sur un mauvais: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path. Do nothing } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Quelque chose comme ça: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); leftHello.runFunctionOnlyOnHappyPath(trace); <span class="hljs-comment"><span class="hljs-comment">// does nothing rightHello.runFunctionOnlyOnHappyPath(trace); // ⦘ Hello world // ￩ "Hello world"</span></span></code> </pre> <br><h4>  Diffusion </h4><br>  Nous approchons de quelque chose d'utile, mais pas encore tout à fait.  Notre méthode <code>.runFunctionOnlyOnHappyPath()</code> renvoie la propriété <code>_val</code> .  Tout va bien, mais trop gênant si nous voulons exécuter plus d'une fonction.  Pourquoi?  Parce que nous ne savons plus si nous sommes sur la bonne ou la mauvaise voie.  Les informations disparaissent dès que nous prenons la valeur en dehors de Gauche et Droite.  Donc, ce que nous pouvons faire, c'est retourner le chemin gauche ou droit avec le nouveau <code>_val</code> intérieur.  Et nous raccourcirons le nom, puisque nous sommes ici.  Ce que nous faisons, c'est traduire une fonction du monde des valeurs simples au monde de gauche et de droite.  Par conséquent, nous appelons la méthode <code>map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Nous insérons cette méthode et utilisons Left ou Right dans la syntaxe libre: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloToGreetings = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Hello/</span></span>, <span class="hljs-string"><span class="hljs-string">'Greetings,'</span></span>); leftHello.map(helloToGreetings).map(trace); <span class="hljs-comment"><span class="hljs-comment">// Doesn't print any thing to the console // ￩ Left(Hello world) rightHello.map(helloToGreetings).map(trace); // ⦘ Greetings, world // ￩ Right(Greetings, world)</span></span></code> </pre> <br>  Nous avons créé deux voies d'exécution.  Nous pouvons placer les données sur un chemin réussi en appelant <code>new Right()</code> , ou sur un chemin échoué en appelant <code>new Left()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36a/2ee/cf6/36a2eecf61c554e388c5723b0b5cbd02.svg"><br>  <i><font color="gray">Chaque classe représente un chemin: réussi ou échoué.</font></i>  <i><font color="gray">J'ai volé cette métaphore de chemin de fer à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scott Vlaschina</a></font></i> <br><br>  Si la <code>map</code> fonctionné sur un bon chemin, suivez-la et traitez les données.  Si nous échouons, rien ne se passera.  Continuez simplement à transmettre la valeur.  Si, par exemple, nous plaçons Error sur ce chemin infructueux, nous obtiendrions quelque chose de très similaire pour <code>try…catch</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17c/3e6/09d/17c3e609d306efc1bee111077456b9ab.svg"><br>  <i><font color="gray">Utilisez <code>.map()</code> pour vous déplacer le long du chemin</font></i> <br><br>  Au fur et à mesure que vous progressez, il devient un peu difficile tout le temps d'écrire Gauche ou Droite, appelons donc cette combinaison simplement Soit («soit»).  Soit à gauche, soit à droite. <br><br><h4>  Raccourcis pour créer l'un ou l'autre des objets </h4><br>  Donc, l'étape suivante consiste à réécrire nos exemples de fonctions afin qu'elles renvoient Soit.  Gauche pour l'erreur ou Droite pour la valeur.  Mais avant de faire cela, amusez-vous.  Écrivons quelques raccourcis.  La première est une méthode statique appelée <code>.of()</code> .  Il retourne juste une nouvelle gauche ou droite.  Le code peut ressembler à ceci: <br><br><pre> <code class="javascript hljs">Left.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(x); }; Right.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(x); };</code> </pre> <br>  Honnêtement, même <code>Left.of()</code> et <code>Right.of()</code> fastidieux à écrire.  Je penche donc vers des étiquettes encore plus courtes à <code>left()</code> et à <code>right()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Left.of(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Right.of(x); }</code> </pre> <br>  Avec ces raccourcis, nous commençons à réécrire les fonctions de l'application: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right({datestr, ...messageObj}); }</code> </pre> <br>  Les fonctions modifiées ne sont pas si différentes des anciennes.  Nous enveloppons simplement la valeur de retour à gauche ou à droite, selon qu'il y a une erreur. <br><br>  Après cela, nous pouvons commencer à traiter la fonction principale qui traite une ligne.  Pour commencer, placez la chaîne dans Soit avec <code>right()</code> , puis traduisez <code>splitFields</code> pour la diviser: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-comment"><span class="hljs-comment">// … }</span></span></code> </pre> <br>  Cela fonctionne très bien, mais le problème se produit si vous essayez de faire de même avec <code>zipRow()</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow <span class="hljs-comment"><span class="hljs-comment">/* wait. this isn't right */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Le fait est que <code>zipRow()</code> attend deux paramètres.  Mais les fonctions que nous transmettons à <code>.map()</code> n'obtiennent qu'une seule valeur de la propriété <code>._val</code> .  La situation peut être corrigée en utilisant la version <code>zipRow()</code> de <code>zipRow()</code> .  Cela pourrait ressembler à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRowWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); }; }</code> </pre> <br>  Ce petit changement simplifie la conversion de <code>zipRow</code> , donc cela fonctionnera bien avec <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)); <span class="hljs-comment"><span class="hljs-comment">// ... But now we have another problem ... }</span></span></code> </pre> <br><h4>  Rejoignez </h4><br>  L'utilisation de <code>.map()</code> pour exécuter <code>splitFields()</code> est très bien, car <code>.splitFields()</code> ne renvoie aucun des deux.  Mais lorsque vous devez exécuter <code>zipRow()</code> , un problème survient car il renvoie Soit.  Donc, lorsque vous utilisez <code>.map()</code> nous <code>.map()</code> par courir dans Soit dans Soit.  Si nous allons plus loin, <code>.map()</code> bloqués jusqu'à ce que nous exécutions <code>.map()</code> intérieur de <code>.map()</code> .  Ça ne marchera pas non plus.  Nous avons besoin d'un moyen de combiner ces deux éléments imbriqués.  <code>.join()</code> donc une nouvelle méthode, que nous appellerons <code>.join()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Nous pouvons désormais «déballer» nos actifs: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)).join(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.map(addDateStr).join(); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Chaîne </h4><br>  Nous avons parcouru un long chemin.  Mais vous devez vous souvenir de l'appel <code>.join()</code> tout le temps, ce qui est ennuyeux.  Cependant, nous avons un modèle d'appel consécutif commun <code>.map()</code> et <code>.join()</code> , alors créons une méthode d'accès rapide pour cela.  Appelons-le <code>chain()</code> , car il lie les fonctions qui renvoient Left ou Right. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } chain() { // Boring sad path, // do nothing. return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } chain(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Revenant à l'analogie ferroviaire, <code>.chain()</code> commute les rails si nous rencontrons une erreur.  Cependant, il est plus facile de le montrer sur le diagramme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bc/279/530/1bc2795304c211004070da858179fcfc.svg"><br>  <i><font color="gray">Si une erreur se produit, la méthode .chain () vous permet de basculer vers le chemin de gauche.</font></i>  <i><font color="gray">Veuillez noter que les commutateurs ne fonctionnent que dans un sens.</font></i> <br><br>  Le code est devenu un peu plus propre: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Faites quelque chose avec des valeurs </h4><br>  La refactorisation de la fonction <code>processRow()</code> est presque terminée.  Mais que se passe-t-il lorsque nous retournons la valeur?  En fin de compte, nous voulons prendre différentes mesures en fonction du type de situation que nous avons: gauche ou droite.  Par conséquent, nous allons écrire une fonction qui prendra les mesures appropriées: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leftFunc, rightFunc, e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) ? leftFunc(e._val) : rightFunc(e._val); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai triché et utilisé les valeurs internes des objets Gauche ou Droite. </font><font style="vertical-align: inherit;">Mais faites comme si vous ne l'aviez pas remarqué. </font><font style="vertical-align: inherit;">Nous pouvons maintenant compléter notre fonction:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et si nous nous sentons particulièrement intelligents, nous pouvons à nouveau utiliser la syntaxe gratuite: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = right(row) .map(splitFields) .chain(zipRow(headerFields)) .chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux versions sont assez jolies. </font><font style="vertical-align: inherit;">Pas de dessins </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Et aucune instruction if dans la fonction de niveau supérieur. </font><font style="vertical-align: inherit;">S'il y a un problème avec une ligne particulière, nous affichons simplement un message d'erreur à la fin. </font><font style="vertical-align: inherit;">Et notez que </font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous mentionnons Gauche ou Droite la seule fois au tout début lorsque nous appelons </font></font><code>right()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le reste ne sont que des </font><font style="vertical-align: inherit;">méthodes utilisées </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>.chain()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour la prochaine fonction.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ap et ascenseur </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ça a l'air bien, mais il reste à considérer un dernier scénario. </font><font style="vertical-align: inherit;">En suivant notre exemple, voyons comment il est possible de traiter toutes les données CSV, et pas seulement chaque ligne individuellement. </font><font style="vertical-align: inherit;">Nous aurons besoin d'une fonction auxiliaire (helper) ou de trois:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitCSVToRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// There should always be a header row... so if there's no // newline character, something is wrong. return (csvData.indexOf('\n') &lt; 0) ? left('No header row found in CSV data') : right(csvData.split('\n')); } function processRows(headerFields, dataRows) { // Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); } function showMessages(messages) { return `&lt;ul class="Messages"&gt;${messages.join('\n')}&lt;/ul&gt;`; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc un assistant qui divise CSV en lignes. </font><font style="vertical-align: inherit;">Et nous revenons à l'option avec Soit. </font><font style="vertical-align: inherit;">Vous pouvez maintenant utiliser </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">certaines fonctions lodash pour extraire la barre de titre des lignes de données. </font><font style="vertical-align: inherit;">Mais on se retrouve dans une situation intéressante ...</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// What's next? }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons des champs d'en-tête et des lignes de données prêts à être affichés avec </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aussi </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enveloppé dans l'un ou l'autre. </font><font style="vertical-align: inherit;">Nous avons besoin d'un moyen de convertir </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en une fonction qui fonctionne avec Soit. </font><font style="vertical-align: inherit;">Pour commencer, nous effectuons le curry </font></font><code>processRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowsWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dataRows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); }; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, tout est prêt pour l'expérience. Nous avons </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui est Soit, enroulé autour d'un tableau. Que se passera-t-il si nous le prenons </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et l'appelons </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// How will we pass headerFields and dataRows to // processRows() ? const funcInEither = headerFields.map(processRows); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec .map (), une fonction externe est appelée ici </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais pas une fonction interne. </font><font style="vertical-align: inherit;">En d'autres termes, </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie une fonction. </font><font style="vertical-align: inherit;">Et depuis </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous récupérons toujours Either. </font><font style="vertical-align: inherit;">Ainsi, le résultat est une fonction dans Either, qui est appelée </font></font><code>funcInEither</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il prend un tableau de chaînes et renvoie un tableau d'autres chaînes. </font><font style="vertical-align: inherit;">Nous devons en quelque sorte prendre cette fonction et l'appeler avec une valeur à l'intérieur </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez une autre méthode à nos classes Left et Right. </font><font style="vertical-align: inherit;">Nous l'appellerons </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conformément à la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">norme</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme d'habitude, la méthode ne fait rien sur la piste de gauche:</font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Left (the sad path) ap() { return this; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et pour la classe Right, on attend un autre Soit avec une fonction: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Right (the happy path) ap(otherEither) { const functionToRun = otherEither._val; return this.map(functionToRun); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant remplir notre fonction principale: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> funcInEither = headerFields.map(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = dataRows.ap(funcInEither); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'essence de la méthode est </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immédiatement un peu comprise (les spécifications de Fantasy Land la confondent, mais dans la plupart des autres langues, la méthode est utilisée dans l'autre sens). Si vous le décrivez plus facilement, vous dites: «J'ai une fonction qui prend généralement deux valeurs simples. Je veux en faire une fonction qui prend deux Soit. " Si disponible, </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons écrire une fonction qui fera exactement cela. Appelons-le </font></font><code>liftA2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, encore une fois conformément au nom standard. Elle prend une fonction simple qui attend deux arguments et la «soulève» pour qu'elle fonctionne avec des «applicatifs». (ce sont des objets qui contiennent à la fois une méthode </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et une méthode </font></font><code>.of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Ainsi, liftA2 est l'abréviation de «ascenseur applicatif, deux paramètres». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fonction </font></font><code>liftA2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pourrait donc ressembler à ceci:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runApplicativeFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.ap(a.map(func)); }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notre fonction de niveau supérieur l'utilisera comme suit: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processRowsA = liftA2(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = processRowsA(headerFields, dataRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code sur CodePen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  Non?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est tout? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous vous demandez peut-être quoi de mieux que de simples exceptions? </font><font style="vertical-align: inherit;">Ne me semble-t-il pas que c'est une manière trop compliquée de résoudre un problème simple? </font><font style="vertical-align: inherit;">Voyons d'abord pourquoi nous aimons les exceptions. </font><font style="vertical-align: inherit;">S'il n'y avait pas d'exceptions, vous auriez à écrire un grand nombre d'instructions if partout. </font><font style="vertical-align: inherit;">Nous écrirons toujours du code selon le principe "si ce dernier fonctionne, continuez, sinon traitez l'erreur." </font><font style="vertical-align: inherit;">Et nous devons gérer ces erreurs tout au long du code. </font><font style="vertical-align: inherit;">Cela rend difficile de comprendre ce qui se passe. </font><font style="vertical-align: inherit;">Les exceptions vous permettent de quitter le programme en cas de problème. </font><font style="vertical-align: inherit;">Par conséquent, vous n'avez pas besoin d'écrire tous ces ifs. </font><font style="vertical-align: inherit;">Vous pouvez vous concentrer sur un chemin d'exécution réussi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a un hic. Les exceptions cachent trop. Lorsque vous lève une exception, vous transférez le problème de gestion des erreurs vers une autre fonction. Il est trop facile d'ignorer une exception qui apparaîtra au plus haut niveau. Le bon côté de Soit est qu'il vous permet de sauter du flux de programme principal, comme avec une exception. Et cela fonctionne honnêtement. Vous obtenez soit à droite ou à gauche. Vous ne pouvez pas prétendre que l'option gauche est impossible. En fin de compte, vous devez retirer la valeur avec un appel comme </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais que cela ressemble à une sorte de complexité. Mais regardez le code que nous avons écrit (pas les classes, mais les fonctions qui les utilisent). Il n'y a pas beaucoup de code de gestion des exceptions. Il est presque absent, à l'exception d'un appel </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la fin </font></font><code>csvToMessages()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voilà le point. </font><font style="vertical-align: inherit;">Avec Soit, vous avez une gestion des erreurs propre qui ne peut pas être accidentellement oubliée. </font><font style="vertical-align: inherit;">Sans l'un ou l'autre, tamponnez le code et ajoutez du rembourrage partout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne signifie pas que vous ne devez jamais l'utiliser </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Parfois, c'est le bon outil, et c'est normal. </font><font style="vertical-align: inherit;">Mais ce n'est pas le seul outil. </font><font style="vertical-align: inherit;">Soit vous donne des avantages que vous n'avez pas </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alors donnez une chance à cette monade. </font><font style="vertical-align: inherit;">Même si c'est difficile au début, je pense que vous l'aimerez. </font><font style="vertical-align: inherit;">Veuillez ne pas utiliser l'implémentation de cet article. </font><font style="vertical-align: inherit;">Essayez l'une des célèbres bibliothèques telles que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sanctuary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folktale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ils sont mieux servis. </font><font style="vertical-align: inherit;">Et ici, pour plus de simplicité, j'ai raté quelque chose.</font></font><br><br><blockquote><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ressources supplémentaires </font></font></h1><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">       </a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Fantasy Land</a> <br></li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    JavaScript: Either</a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> <br></li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  JavaScript: </a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457098/">https://habr.com/ru/post/fr457098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457086/index.html">Motif architectural "Builder" dans l'univers de "Swift" et "iOS" / "macOS"</a></li>
<li><a href="../fr457090/index.html">Lits de sécurité: JWT</a></li>
<li><a href="../fr457092/index.html">Nous étudions MITRE ATT & CK. Matrices mobiles: accès aux appareils. Partie 5</a></li>
<li><a href="../fr457094/index.html">Complément Excel qui facilite la définition de filtres lorsque vous travaillez avec des cubes (VBA)</a></li>
<li><a href="../fr457096/index.html">Nous libérons nos mains de plusieurs analystes: API Livy pour l'automatisation des tâches bancaires typiques</a></li>
<li><a href="../fr457100/index.html">AWS Lambda - Théorie, connaissance</a></li>
<li><a href="../fr457102/index.html">Fichiers QVD - contenu, partie 3</a></li>
<li><a href="../fr457106/index.html">La guerre américaine par appel robotique - qui gagne et pourquoi</a></li>
<li><a href="../fr457108/index.html">WWDC19: Premiers pas avec le plan de test pour XCTest</a></li>
<li><a href="../fr457110/index.html">Tests unitaires de modèles d'injection C ++ et simulés à l'aide de traits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>