<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê§ üßôüèø üßôüèæ Mein "Wow, das wusste ich nicht!" Momente mit Scherz üñäÔ∏è üïµÔ∏è üìµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Der JavaScript Developer- Kurs beginnt diesen Donnerstag. In diesem Zusammenhang haben wir beschlossen, die √úbersetzung eines andere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mein "Wow, das wusste ich nicht!" Momente mit Scherz</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457616/">  Hallo allerseits!  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript Developer-</a> Kurs beginnt diesen Donnerstag.  In diesem Zusammenhang haben wir beschlossen, die √úbersetzung eines anderen interessanten Materials zu teilen.  Gute Lekt√ºre. <br><br><img src="https://habrastorage.org/webt/nj/it/db/njitdbm66p75yhokzwoeudcnti8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scherz war</a> schon immer mein unverzichtbares Werkzeug f√ºr Unit-Tests.  Es ist so zuverl√§ssig, dass ich anfange zu denken, dass ich es immer zu wenig genutzt habe.  Obwohl die Tests funktionierten, habe ich sie im Laufe der Zeit hier und da √ºberarbeitet, weil ich nicht wusste, dass Jest das kann.  Dies ist jedes Mal ein neuer Code, wenn ich die Jest-Dokumentation √ºberpr√ºfe. <a name="habracut"></a><br><br>  Also werde ich einige meiner Lieblings-Jest-Tricks teilen, die einige von Ihnen vielleicht bereits kennen, weil Sie die Dokumentation gelesen haben und mich nicht m√∂gen (schade), aber ich hoffe, dies hilft denen, die es gerade schnell durchlaufen haben ! <br><br>  √úbrigens verwende ich Jest v24.8.0 als Referenzmaterial. Seien Sie also vorsichtig, einige Dinge funktionieren m√∂glicherweise nicht mit der Version von Jest, die Sie derzeit verwenden.  Au√üerdem stellen die Beispiele nicht den tats√§chlichen Testcode dar, dies ist nur eine Demonstration. <br><br><h2>  # 1  .toBe vs .toEqual </h2><br>  Alle diese Aussagen sahen f√ºr mich zun√§chst normal aus: <br><br><pre><code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toEqual(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Basierend auf der Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chai</a> f√ºr Gleichheitserkl√§rungen (to.equal) ist dies nur nat√ºrlich.  Tats√§chlich wird sich Jest nicht beschweren, und diese Aussagen werden wie gewohnt weitergegeben. <br><br>  Jest hat jedoch .toBe und .toEqual.  Die erste dient dazu, die Gleichheit mit <a href="">Object.is zu gew√§hrleisten</a> , und die zweite dient dazu, einen umfassenden Vergleich von Objekten und Arrays zu erm√∂glichen.  .toEqual hat einen Fallback bei der Verwendung von <a href="">Object.is,</a> wenn sich herausstellt, dass Sie keinen umfassenden Vergleich ben√∂tigen, z. B. das Festlegen von Gleichheiten f√ºr primitive Werte, was erkl√§rt, warum das vorherige Beispiel sehr gut gelaufen ist. <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toBe(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toBe(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Auf diese Weise k√∂nnen Sie alle <code>if-else</code> in <code>.toEqual</code> mit <code>.toBe</code> wenn Sie bereits wissen, welche Werte Sie testen. <br>  Ein h√§ufiger Fehler ist, dass Sie <code>.toBe</code> , um die Gleichheit primitiver Werte zu behaupten. <br><br><pre> <code class="javascript hljs">expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toBe([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Wenn Sie sich den <a href="">Quellcode</a> ansehen, wenn .toBe abst√ºrzt, wird versucht, festzustellen, ob Sie diesen Fehler wirklich gemacht haben, <a href="">indem Sie die von</a> .toEqual verwendete <a href="">Funktion</a> aufrufen.  Dies kann ein Engpass bei der Optimierung Ihres Tests sein. <br><br>  Wenn Sie sicher sind, dass Sie primitive Werte verwenden, kann Ihr Code zu Optimierungszwecken als solcher neu organisiert werden: <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.is(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Weitere Details in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br><h2>  # 2  Besser geeignete Vergleiche </h2><br>  Technisch gesehen k√∂nnen Sie <code>.toBe</code> , um beliebige Werte zu validieren.  Mit Jest k√∂nnen Sie bestimmte Vergleichstools speziell verwenden, um Ihren Test besser lesbar (und in einigen F√§llen k√ºrzer) zu machen. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// expect([1,2,3].length).toBe(3) // expect([1,2,3]).toHaveLength(3) const canBeUndefined = foo() // expect(typeof canBeUndefined !== 'undefined').toBe(true) // expect(typeof canBeUndefined).not.toBe('undefined') // expect(canBeUndefined).not.toBe(undefined) // expect(canBeUndefined).toBeDefined() class Foo { constructor(param) { this.param = param } // expect(new Foo('bar') instanceof Foo).toBe(true) // expect(new Foo('bar')).toBeInstanceOf(Foo)</span></span></code> </pre> <br>  Dies sind nur einige von denen, die ich aus der langen Liste der Jest-Compiler in der Dokumentation ausgew√§hlt habe. Sie k√∂nnen sich den Rest selbst ansehen. <br><br><h2>  # 3  Schnappschuss-Test an Elementen ohne Benutzeroberfl√§che </h2><br>  M√∂glicherweise haben Sie von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshot-Tests in Jest geh√∂rt</a> , mit denen Sie √Ñnderungen an den Elementen Ihrer Benutzeroberfl√§che nachverfolgen k√∂nnen.  Das Testen mit Schnappsch√ºssen ist jedoch nicht darauf beschr√§nkt. <br><br>  Betrachten Sie dieses Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">0</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">1000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">1</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">5000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">2</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ...etc</span></span></code> </pre> <br>  Es w√§re anstrengend, wenn Sie immer mehr Mitarbeiter beanspruchen w√ºrden.  Wenn sich herausstellt, dass f√ºr jeden Mitarbeiter mehr Anspr√ºche erforderlich sind, multiplizieren Sie die Anzahl der neuen Anspr√ºche mit der Anzahl der Mitarbeiter, und Sie erhalten eine Vorstellung. <br>  Mit Snapshot-Tests kann dies einfach so durchgef√ºhrt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees).toMatchSnapshot()</code> </pre> <br>  Wann immer Regressionen auftreten, wissen Sie genau, welcher Baum im Knoten nicht mit dem Bild √ºbereinstimmt. <br><br>  Bequemlichkeit hat jedoch ihren Preis: Diese Methode ist fehleranf√§lliger.  Es besteht die M√∂glichkeit, dass Sie nicht wissen, dass das Bild tats√§chlich falsch ist, und dass Sie es am Ende trotzdem aufnehmen werden.  √úberpr√ºfen Sie Ihren Schnappschuss also so, als w√§re er Ihr eigener Genehmigungscode (weil er es ist). <br><br>  Nat√ºrlich ist das Testen nicht auf Schnappsch√ºsse beschr√§nkt.  Lesen Sie die vollst√§ndige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br><h2>  # 4  beschreiben.jeder und test.jeder </h2><br>  Haben Sie jemals einen √§hnlichen Test geschrieben? <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'When I am a supervisor'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-supervisor'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>) }) }) describe(<span class="hljs-string"><span class="hljs-string">'When I am a manager'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a manager badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-manager'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a manager level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'manager'</span></span>) }) })</code> </pre> <br>  Das ist eint√∂nig und routinem√§√üig, oder?  Stellen Sie sich vor, Sie tun dies in vielen F√§llen. <br>  Mit <code>description.each</code> und <code>test.each</code> Sie den Code wie folgt komprimieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> levels = [[<span class="hljs-string"><span class="hljs-string">'manager'</span></span>], [<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privileges = [[<span class="hljs-string"><span class="hljs-string">'badges'</span></span>, <span class="hljs-string"><span class="hljs-string">'toContain'</span></span>, <span class="hljs-string"><span class="hljs-string">'badge-'</span></span>], [<span class="hljs-string"><span class="hljs-string">'level'</span></span>, <span class="hljs-string"><span class="hljs-string">'toBe'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]] describe.each(levels)(<span class="hljs-string"><span class="hljs-string">'When I am a %s'</span></span>, (level) =&gt; { test.each(privileges)(<span class="hljs-string"><span class="hljs-string">`I should have a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string"> %s`</span></span>, (kind, assert, prefix) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ level }) expect(employee[kind])[assert](<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre> <br>  Ich muss dies jedoch noch in meinem eigenen Test verwenden, da ich es vorziehe, dass mein Test detailliert ist, aber ich dachte nur, dass es ein interessanter Trick w√§re. <br><br>  Weitere Details zu den Argumenten finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> (Spoiler: Die Tabellensyntax ist wirklich cool). <br><br><h2>  # 5  Einzelne Nachahmung globaler Funktionen </h2><br>  Irgendwann m√ºssen Sie etwas testen, das von globalen Funktionen in einem bestimmten Testfall abh√§ngt.  Zum Beispiel eine Funktion, die mithilfe des Date-Javascript-Objekts Informationen zum aktuellen Datum empf√§ngt, oder eine Bibliothek, die darauf angewiesen ist.  Die Schwierigkeit besteht darin, dass Sie beim aktuellen Datum nie die richtige Aussage treffen k√∂nnen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } expect(foo()).toBe(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now()) <span class="hljs-comment"><span class="hljs-comment">// This would throw occasionally: // expect(received).toBe(expected) // Object.is equality // // Expected: 1558881400838 // Received: 1558881400837</span></span></code> </pre> <br><br>  Am Ende m√ºssten Sie das globale Date-Objekt neu definieren, damit es konsistent und verwaltbar ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Dies wird jedoch als schlechte Praxis angesehen, da die Neudefinition zwischen den Tests beibehalten wird.  Sie werden dies nicht bemerken, wenn es keinen anderen Test gibt, der auf Date.now basiert, aber es wird auch auslaufen. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // ??? })</span></span></code> </pre><br>  Ich habe es immer ‚Äûgeknackt‚Äú, damit es nicht ausl√§uft: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oriDateNow = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Date.now = oriDateNow }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Es gibt jedoch einen viel besseren und weniger hackenden Weg, dies zu tun: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() jest.spyOn(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-string"><span class="hljs-string">'now'</span></span>).mockImplementationOnce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Somit folgt <code>jest.spyOn</code> dem globalen Date-Objekt und ahmt die Implementierung der now-Funktion f√ºr nur einen Aufruf nach.  Dadurch bleibt Date.now f√ºr den Rest der Tests intakt. <br><br>  Es gibt definitiv mehr Informationen √ºber Stubs in Jest.  Weitere Informationen finden Sie in der vollst√§ndigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Dieser Artikel wird lang genug, also denke ich, das ist alles f√ºr jetzt.  Dies betrifft nur einen kleinen Teil der Funktionen von Jest, und ich hebe nur meine Favoriten hervor.  Wenn Sie andere interessante Fakten haben, lassen Sie es mich wissen. <br><br>  Wenn Sie Jest h√§ufig verwendet haben, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Majestic an</a> , eine GUI-freie GUI f√ºr Jest, eine wirklich gute Alternative zur langweiligen Terminalausgabe.  Ich bin mir nicht sicher, ob der Autor in dev.to ist, aber dennoch Respekt f√ºr diese Person. <br><br>  Wie immer vielen Dank f√ºr Ihre Aufmerksamkeit! <br><br>  Das ist alles.  Wir sehen uns auf dem Kurs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457616/">https://habr.com/ru/post/de457616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457606/index.html">Alan Kay: Was kann man als das Erstaunlichste bezeichnen, was Computer m√∂glich gemacht haben?</a></li>
<li><a href="../de457608/index.html">So visualisieren Sie Daten zu einer √ºberzeugenden Geschichte</a></li>
<li><a href="../de457610/index.html">Evil Parcel Schwachstellenanalyse</a></li>
<li><a href="../de457612/index.html">Wie kann die LZ4-Dekomprimierung in ClickHouse beschleunigt werden?</a></li>
<li><a href="../de457614/index.html">Geheimnisse der Arbeitssuche im Ausland bei einem praktizierenden Headhunter</a></li>
<li><a href="../de457618/index.html">Ein moderner Full-Stack-Entwickler sein</a></li>
<li><a href="../de457622/index.html">Qt-Leistung messen</a></li>
<li><a href="../de457624/index.html">Wie wir die alte H√ºtte zerbrochen und an ihrer Stelle einen Wolkenkratzer gebaut haben</a></li>
<li><a href="../de457626/index.html">√úberarbeitung der Benutzerzugriffsebenen mithilfe von Power BI am Beispiel von Bitrix CMS (BUS)</a></li>
<li><a href="../de457628/index.html">Effektives P2M-Programm- und Projektmanagement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>