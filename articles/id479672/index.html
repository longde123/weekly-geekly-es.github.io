<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘´ğŸ½ ğŸ‘©ğŸ»â€ğŸš’ ğŸ‘— BISA sniffer ğŸ™ ğŸ¦‘ ğŸº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bus BISA sendiri sudah banyak digunakan di mana, saya tertarik penggunaannya di mobil, meskipun area ini tidak bisa dibatasi. Terutama beberapa tahun ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BISA sniffer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479672/"><img src="https://habrastorage.org/webt/xr/pc/l1/xrpcl1nludukziojbjxlsuqxgaa.png" align="left">  Bus BISA sendiri sudah banyak digunakan di mana, saya tertarik penggunaannya di mobil, meskipun area ini tidak bisa dibatasi.  Terutama beberapa tahun yang lalu kesempatan ini muncul.  Saya melihat spesifikasi umum - sepertinya tidak ada yang rumit.  Saya melihat program yang ditemukan di Internet - dan saya tidak suka, masing-masing tidak memiliki sesuatu yang tampaknya perlu bagi saya pada waktu itu.  Saya akan menemukan kembali sepeda saya.  Saya membuat sniffer CAN saya lebih jauh di bawah luka. <br><a name="habracut"></a><br><h2>  BISA bus </h2><br>  Menjabarkan detail teknis bus CAN adalah bagian dari dokumentasi.  Dalam artikel ini, cukup untuk mengetahuinya: <br><br><ul><li>  memiliki koneksi fisik dua kawat </li><li>  ada berbagai kecepatan data </li><li>  keripik siap pakai dan bahkan papan siap pakai dengan komponen yang disolder sudah tersedia untuk koneksi </li></ul><br>  Setelah membolak-balik halaman satu toko online terkenal dari Kerajaan Tengah, saya memesan beberapa opsi berbeda untuk perisai dan pergi untuk mempelajari fitur-fitur sinyal listrik di dalam mobil.  Mobil eksperimental adalah LADA Kalina Cross dengan mesin ke 127 dan ITELMA M74.5 CAN unit kontrol elektronik. <br><br>  Saya terhubung ke konektor diagnostik OBD (pin 6 dan 14) dan melihat osiloskop yang ada di sana.  Setelah memutar kunci kontak, paket dengan amplitudo hingga 2,5 V mulai berjalan. Saya berhenti di osiloskop dan melihat ke paket. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/zv/qy/khzvqyvzr478w0czmr_otgc9ars.jpeg"></div><br>  Bit mulai dan berhenti terlihat, beberapa data dalam paket.  Pada saat itu saya sudah tahu bahwa kecepatan transfer data diharapkan 500 kbit / s, sebagai yang paling sering untuk bus CAN motor.  Durasi paket sekitar 230 Î¼s dan sebelum paket ada jeda yang agak besar dalam transmisi data.  Saya skala waktu dan melihat tiga paket dan jeda di antara mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/2z/js/ox2zjs6yvmfvfvtvw9zmklvidrw.jpeg"></div><br>  Jika kita menambahkan durasi transfer data dan jeda antar paket, ternyata transfer satu bagian data membutuhkan waktu sekitar 1 ms. <br><br>  Mengapa saya menyimpulkan semua ini?  Dan pertanyaannya adalah murni praktis: apakah ada kecepatan port serial yang cukup untuk mentransfer semua data?  Dan berdasarkan apa yang kita lihat, kita dapat menyimpulkan bahwa kecepatan 500 kbit / s berkembang di dalam paket, yang memakan waktu sekitar seperempat dari waktu transmisi.  Jadi tingkat transfer rata-rata akan empat kali lebih rendah.  Pada saat itu, saya masih belum memiliki tes kecepatan antarmuka serial Arduino, dan melihat ke depan saya dapat mengatakan bahwa bahkan dengan konverter Serial ke USB CH340 yang paling umum, kecepatan 2 Mbps bekerja dengan stabil. <br><br><h2>  BISA pemindai di Arduino </h2><br>  Perisai pertama yang tiba untuk Arduino UNO klasik.  Ya, harganya jauh lebih mahal daripada rekan-rekannya yang lebih kecil, tetapi ia memiliki semua yang Anda butuhkan dan bahkan dua tombol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4x/cr/fd/4xcrfd8lgpvb32iclqrayod83nu.jpeg"></div><br>  Dengan dia saya memulai semua percobaan.  Rakitan sirkuit sederhana dengan perisai ini dan layar dua garis kristal cair.  Tujuannya adalah untuk menampilkan setidaknya beberapa data di layar.  Saya memilah-milah berbagai perpustakaan untuk bekerja dengan bus CAN di Arduino (Saya akan langsung mengatakan bahwa perpustakaan yang benar dan berfungsi disebut CAN-BUS Shield oleh Seeed Studio dengan file header mcp_can.h), mengubah resonator kuarsa pada pelindung 16 MHz (aslinya 8 MHz) - tidak ada data. <br><br>  Dua sirkuit mikro dipasang pada pelindung: pengendali bus CAN MCP2515 dan pengemudi bus CAN TJA1050.  Setelah membaca dokumentasi dan berbagai forum, saya memutuskan untuk mengubah TJA1050 menjadi driver yang lebih kanonik MCP2551 dan data muncul.  Mungkin TJA1050 pada awalnya rusak, karena sangat sulit untuk membuat kesalahan dengan menghubungkannya dengan dua kabel, di samping itu, saya menggunakan konektor OBD dan DB9 untuk koneksi. <br><br>  Dalam beberapa jam, sebuah pemindai CAN sederhana dapat ditulis, yang menampilkan jumlah paket yang ditangkap, ID-nya, dan hingga 8 byte data untuk paket ini pada LCD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/cm/e7/eocme7jad_kkhb1wpyqyurjirom.jpeg"></div><br>  Di sinilah tombol pada perisai berguna, yang saya gunakan untuk beralih di antara jumlah paket yang ditampilkan. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang tombol</b> <div class="spoiler_text">  Secara umum, tombol-tombol ini berguna untuk banyak hal.  Bersama mereka saya mulai menguji kontrol beberapa perangkat mobil. <br></div></div><br>  Awalnya sudah dimulai, kita harus beralih ke implementasi yang lebih menarik. <br><br><h2>  BISA sniffer di Arduino </h2><br>  Tugasnya cukup sederhana: <br><br><ul><li>  menerima paket dari CAN bus </li><li>  kami menempatkan data yang diterima dalam struktur kami </li><li>  mengirim struktur melalui port serial </li></ul><br>  Saya tidak melihat masalah dengan dua tugas pertama.  Perpustakaan menyediakan interupsi ketika menerima paket data berikutnya dan fungsi yang mudah untuk menerima data.  Tetapi saya memutuskan untuk mengirim data ke komputer melalui pustaka CyberLib, yang menghilangkan beberapa overhead dari seluruh platform Arduino, yang dengannya Anda dapat sedikit membongkar prosesor untuk memproses data.  Kemudian, perpustakaan ini harus ditinggalkan. <br><br>  Agar data dikirim dengan benar untuk diproses di sisi komputer, awalan empat byte 0xAA55AA55 dimasukkan ke dalam aliran sebelum setiap bagian data berikutnya (untuk beberapa alasan, byte ini diingat untuk dua byte terakhir dari sektor boot DOS, hanya saja urutannya berbeda).  Logikanya adalah ini: <br><br><ul><li>  komputer membaca seluruh aliran dari port serial dan menemukan urutan awalan yang diinginkan 0xAA55AA55 di dalamnya </li><li>  segera setelah awalan akan ada 4 byte pengenal paket </li><li>  selanjutnya panjang data paket ini, ia mengontrol panjang seluruh paket </li><li>  hingga 8 byte data </li></ul><br>  Mengenai hal ini, bagian perangkat lunak dalam Arduino, pada waktu itu, selesai.  Kemudian secara signifikan direnovasi, tetapi konsep umum tidak berubah. <br><br>  Saya juga menulis sebuah generator paket data sederhana untuk debugging untuk di-debug di rumah - ia hanya mengirim paket-paket dengan data acak ke port serial, yang memungkinkan Anda untuk men-debug aplikasi pada komputer Anda dalam kondisi yang nyaman. <br><br>  Sekitar waktu yang sama, komponen yang lebih kecil dari perisai Arduino Nano dan Mini CAN tiba. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/rj/2n/knrj2nbgse4ch__x9h-43vc7qeo.jpeg"></div><br>  Saya merancang kasing kecil, mencetaknya dan meletakkan semua komponen di dalamnya. <br><br><div style="text-align:center;"> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/bm/2p/rc/bm2prc7jdp1ofibuawzorlkuggy.jpeg"></a> </div><br>  Di luar, ada konektor OBD di satu sisi dan Mini USB di sisi lain.  Di dalam ada saklar untuk resistor penghentian. <br><br><h2>  BISA sniffer di PC menggunakan wxWidgets </h2><br>  Saya membuat sketsa konsep sederhana program di C #, yang menampilkan data yang diterima di Grid.  Dan dia pergi untuk memeriksa di dalam mobil.  Saya hanya tidak menggunakan laptop saya, karena baterainya telah memerintahkan saya untuk hidup lama dan digunakan sebagai komputer stasioner, tetapi saya mengambil netbook dengan prosesor yang sangat lemah.  Apa yang saya lihat ... saya tidak melihat apa-apa.  Kedua core 100% dimuat, antarmuka aplikasi tidak merespons.  Tetapi di komputer saya, yang masih jauh lebih cepat daripada netbook, dengan generator paket acak aplikasi bekerja dengan baik dan menampilkan data.  Dari sini, saya menyimpulkan bahwa platform .NET pada komputer yang lemah tidak akan berfungsi untuk saya, karena saya bisa men-debug di lapangan pada saat itu hanya dengan netbook itu. <br><br>  Sebelumnya, saya menggunakan perpustakaan wxWidgets di beberapa proyek dan saya hanya punya pengalaman yang menyenangkan tentang itu.  Ini ringan, tidak perlu membawa berbagai pustaka dengannya, dan bahkan lintas platform, yang memberi harapan bahwa bagian antarmuka kode dapat ditransfer tanpa perubahan signifikan ke platform lain.  Di akhir artikel akan ada tautan ke program yang dikompilasi, jika tidak ada keinginan untuk repot dengan semua ini. <br><br><div class="spoiler">  <b class="spoiler_title">Cara menginstal dan mengkompilasi wxWidgets untuk Visual Studio</b> <div class="spoiler_text">  <b>Instalasi dan kompilasi</b> <br>  1. Unduh Windows Installer <a href="https://www.wxwidgets.org/downloads/" rel="nofollow">wxWidgets</a> dan instal, misalnya, di folder C: \ wxWidgets <br><br>  2. Buat variabel lingkungan: <br>  WXWIN = C: \ wxWidgets <br><br>  3. Jalankan prompt perintah Visual Studio dan buka direktori: <br>  % WXWIN% \ build \ msw <br><br>  4. Ketik dua perintah untuk dikompilasi: <br>  nmake / f makefile.vc BUILD = debug RUNTIME_LIBS = statis <br>  nmake / f makefile.vc BUILD = lepaskan RUNTIME_LIBS = statis <br><br>  <b>Menyiapkan proyek di Visual Studio</b> <br>  1. Dalam Visual Studio, buat Proyek Win32, dengan proyek Empty parameter. <br><br>  2. Dalam properti proyek untuk Semua konfigurasi, tentukan jalur di bagian direktori VC ++: <br>  Sertakan Direktori: <br>  $ (WXWIN) \ termasuk <br>  $ (WXWIN) \ termasuk \ msvc <br><br>  Direktori Perpustakaan: <br>  $ (WXWIN) \ lib \ vc_lib <br><br>  3. Di bagian C / C ++ - Pembuatan Kode, ubah: <br>  Perpustakaan Runtime untuk Debug: / konfigurasi MTd <br>  Perpustakaan Runtime untuk mengkonfigurasi Rilis: / MT <br><br>  4. Di bagian Umum, ubah: <br>  Set Karakter: Gunakan Set Karakter Unicode <br><br>  5. Untuk menambahkan ikon ke file exe, Anda perlu menambahkan file sumber daya dengan konten berikut: <br>  #sertakan "wx \ msw \ wx.rc" <br>  ikon wxicon app_icon.ico <br><br>  6. Selain itu, jika Anda perlu menggunakan UAC, di bagian Linker - Manifest File: <br>  Level Eksekusi UAC: membutuhkanAdministrator <br></div></div><br>  Prototipe pertama yang diimplementasikan dalam C ++ dan wxWidgets menunjukkan bahwa bahkan netbook berupaya menampilkan data dalam sebuah tabel, dan saya mulai mengembangkan apa yang telah saya rencanakan. <br><br>  Secara arsitektur, program ini terdiri dari dua aliran: antarmuka dan alur kerja dengan port serial.  Tidak ada algoritma yang sangat menarik yang diterapkan.  Kode ini banyak dikomentari dan harus cukup mudah.  Tautan ke sumbernya ada di akhir artikel. <br><br>  Hal pertama yang dilakukan adalah pewarnaan sel data dalam tabel sesuai dengan batasan memperoleh data ini.  Sudah di prototipe pertama, melihat 17 baris data yang terus berubah nilai, saya menyadari bahwa perlu untuk entah bagaimana membedakan antara data baru dan data yang tidak berubah atau jarang berubah.  Dia membuat pewarnaan dalam dua tahap: <br><br><ul><li>  data pertama kali disorot dalam latar belakang sel hijau </li><li>  data yang datang berulang kali dan selanjutnya disorot dengan latar belakang merah, yang secara bertahap memudar menjadi putih jika data ini tidak berubah lagi </li></ul><br>  Segera menjadi jelas sel mana yang tidak digunakan sama sekali, mana yang berisi sinyal penghitung.  Pencarian untuk nilai variabel yang menarik sangat disederhanakan.  Selanjutnya, semua gambar dianimasikan.  Jika animasi tidak berfungsi dalam artikel (pada beberapa browser seluler) - klik pada gambar untuk membuka versi lengkap animasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/uy/tt/ksuytt2hifbv5ft8qr2kq27ybrc.gif"></div><br><br>  Lalu saya ingin tetap memeriksa apakah port serial mengatasi aliran data.  Untuk melakukan ini, di sisi Arduino, saya menambahkan penghitung untuk jumlah paket yang diterima dan penghitung byte dalam paket.  Penghitung ini dikirim ke komputer dalam sebuah paket dengan pengenal 0x000.  Setelah menerima data ini, program tidak menampilkannya dalam tabel, tetapi menampilkannya di bidang informasi terpisah di bagian atas.  Hasilnya bahkan cukup menyenangkan.  Rata-rata, hingga 750 paket / detik diterima pada kecepatan hingga 9,5 kB / detik, dan di sinilah di wilayah ini hingga 80 kbit / detik, yang sangat memungkinkan untuk port serial.  Namun demikian, pertukaran data dikonfigurasi secara default pada 500 kbps, biarlah stoknya lebih baik. <br><br>  Menambahkan kemampuan untuk menulis data ke log muncul setelah saya menghubungkan adaptor diagnostik ELM327 secara paralel dengan antarmuka OBD dan menghubungkannya ke telepon, mencoba membaca berbagai data.  Data berjalan sangat cepat sehingga tidak mungkin untuk melihatnya.  Setelah mencatat semua ini dalam jurnal, Anda dapat dengan tenang duduk dan melihat data yang dikirimkan.  Untuk melakukan ini, bahkan data teks ASCII dapat ditulis ke log.  Anda juga dapat memilih jenis file, pembatas karakter dan mengkonfigurasi filter paket dengan mengklik pengenal paket yang ditentukan dalam tabel dan mengklik tombol "Tambahkan ID untuk menyaring" (secara default, semua data ditulis) jika semua data ditulis berlebihan. <br><br>  Saat itulah realisasi datang bahwa semua aplikasi telepon yang melakukan semua jenis "diagnostik" melalui bundel ELM327 dan telepon tidak berkomunikasi langsung dengan bus CAN kendaraan.  Mereka hanya menggunakan fungsi diagnostik OBD melalui bus CAN dengan mengakses CAN ID 0x7E0.  Biasanya ini adalah alamat pengendali motor (ECU), jawaban darinya datang dalam paket dengan pengenal 0x7E8.  Tetapi semua paket data lainnya disebut Vendor Specific dan tidak ada produsen yang akan membukanya (walaupun ada contoh: <a href="https://habr.com/ru/post/165929/">Ford merilis SDK untuk mobilnya</a> ). <br><br>  Melanjutkan mempelajari apa yang sedang ditransmisikan dalam paket-paket ini, saya datang dengan ide lain: ketika saya mengklik sel di tabel, di jendela program di sebelah kanan, menampilkan nilai biner dan desimal dari byte ini, serta mengambil byte berikutnya dan menambahkan kata.  Selanjutnya, gandakan kata ini dengan koefisien tertentu dan dapatkan hasil desimal.  Kedengarannya tidak terlalu jelas, tetapi sehubungan dengan apa yang telah dilakukan: kecepatan mesin datang dalam paket CAN ID 0x180, dalam dua byte pertama.  Dua byte ini memberikan kata tertentu yang sebanding dengan belokan.  Jika arti kata ini dibagi 8, maka momentum saat ini diperoleh.  Oleh karena itu, faktor 0,125 ditunjukkan, sebagai kebalikan dari 8. Selanjutnya, kata ini divisualisasikan dalam grafik dengan penyesuaian dinamis dalam amplitudo.  Pada prinsipnya, pengali dapat dicari dalam urutan terbalik: Saya menemukan sel yang sangat mirip dengan kecepatan mesin atau sesuatu yang lain sesuai jadwal, setelah itu pengali disesuaikan untuk mendapatkan nilai nyata. <br><br><div style="text-align:center;"> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/6b/qi/zq/6bqizqt20bcvmk352hikydeeg1s.gif"></a> </div><br>  Nah, representasi biner memungkinkan Anda untuk mencari berbagai indikator bit.  Misalnya, pencarian indikator indikator arah direduksi menjadi menyalakannya dan mengamati sel mana yang mulai berubah, dalam contoh di bawah ini adalah CAN ID 0x481 byte 2. Setelah itu, mengklik pada sel menampilkan nilai biner di bidang yang sesuai, di mana pengalihan dua yang lebih rendah sudah terlihat bit (kiri, kanan, dan jika bersama - alarm). <br><br><div style="text-align:center;"> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/g8/gk/hx/g8gkhx7xxaf5kevdhelzbqom6p0.gif"></a> </div><br>  Dan akhirnya, saya perlu mengirim beberapa data kontrol ke bus CAN dan melihat reaksi terhadap perintah-perintah ini.  Kode ditambahkan ke program Arduino yang menerima data dari komputer dan transfer ke bus CAN.  Pada tahap ini CyberLib harus ditinggalkan, karena tidak memiliki dukungan untuk mengganggu penerimaan data dalam buffer port serial.  Dalam program di komputer, saya menambahkan beberapa bidang teks di mana Anda dapat memasukkan berbagai parameter dan tabel untuk melihat respons aktuator.  Contoh di bawah ini menunjukkan perintah kontrol mengaktifkan / menonaktifkan kecepatan pertama kipas pendingin (0x0A) dan mengaktifkan / menonaktifkan kopling AC (0x0B). <br><br> <a href="" rel="nofollow"><img src="https://habrastorage.org/webt/ha/ba/kv/habakvdaggg7tw0z0ak9kdz2wd4.gif"></a> <br><br><h2>  Ringkasan </h2><br>  Hampir tidak ada tempat untuk menemukan dekripsi lengkap dari data pabrikan, terutama yang resmi.  Dalam kasus terbaik, ini akan menjadi penelitian orang lain dalam rangka implementasi beberapa fungsi tambahan.  BISA sniffer dapat membantu Anda menemukan data ini.  Saya dapat menemukan sekitar 40 parameter mobil yang berbeda dan demi percobaan, berdasarkan data yang diterima, saya membuat kendali sendiri atas kipas pendingin. <br><br><ul><li>  <a href="https://github.com/KruFFT/CAN-Sniffer" rel="nofollow">CAN bus sniffer (sisi Arduino)</a> </li><li>  <a href="https://github.com/KruFFT/wxCAN-Sniffer" rel="nofollow">wxCAN bus sniffer (sisi PC)</a> </li><li>  <a href="https://cloud.mail.ru/public/Frr7/2ruf1DyDP" rel="nofollow">sniffer bus wxCAN (dapat dieksekusi Windows)</a> </li></ul><br>  Saya berharap semua ini bermanfaat tidak hanya bagi saya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479672/">https://habr.com/ru/post/id479672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479660/index.html">3. Analisis malware menggunakan forensik Check Point. Ponsel sandblast</a></li>
<li><a href="../id479662/index.html">Bagaimana Yandex mengajarkan kecerdasan buatan untuk menemukan kesalahan dalam berita</a></li>
<li><a href="../id479664/index.html">Bagaimana kubernet dikelola dan OpenShift berhasil berfungsi di IBM Cloud. Bagian 1 - Arsitektur dan Keamanan</a></li>
<li><a href="../id479666/index.html">Golang: Apa yang menjadi Spesialis Go bergantung pada lautan spesialisasi IT?</a></li>
<li><a href="../id479668/index.html">QA untuk pemula: bagaimana cara menguji roket atau pesawat?</a></li>
<li><a href="../id479676/index.html">ExtJS 7 dan Spring Boot 2. Bagaimana cara membangun SPA yang berinteraksi dengan API Anda dan plugin ReactJS eksternal?</a></li>
<li><a href="../id479678/index.html">Tinjauan aktivitas virus untuk perangkat seluler pada November 2019</a></li>
<li><a href="../id479680/index.html">Cara membuat sel kanker lebih mudah menyerap obat</a></li>
<li><a href="../id479682/index.html">Laporan Penggunaan Kontainer Sysdig 2019: Kubernet Baru dan Detail Keamanan</a></li>
<li><a href="../id479684/index.html">Cara mengumpulkan kunci frekuensi rendah untuk SEO: 4 cara non-sepele</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>