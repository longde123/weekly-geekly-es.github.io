<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¶ üöµüèø üéâ Post-Mortem-Debugging auf Cortex-M üç™ üèÑ üèÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Post-Mortem-Debugging auf Cortex-M 



 Hintergrund: 


 Ich habe k√ºrzlich an der Entwicklung eines f√ºr mich untypischen Ger√§ts aus der Klasse der Unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Post-Mortem-Debugging auf Cortex-M</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452704/"><h1 id="post-mortem-otladka-na-cortex-m">  Post-Mortem-Debugging auf Cortex-M </h1><br><p><img src="https://habrastorage.org/webt/ya/rn/fd/yarnfd_zlonid-bdujxzbnikuuu.png"></p><br><h2 id="predystoriya">  Hintergrund: </h2><br><p>  Ich habe k√ºrzlich an der Entwicklung eines f√ºr mich untypischen Ger√§ts aus der Klasse der Unterhaltungselektronik teilgenommen.  Es scheint nichts Kompliziertes zu sein, eine Box, die manchmal den Ruhemodus verlassen, sich beim Server melden und wieder einschlafen sollte. </p><br><p>  Die Praxis hat schnell gezeigt, dass der Debugger bei der Arbeit mit einem Mikrocontroller, der st√§ndig in den Tiefschlafmodus wechselt oder die Stromversorgung abschaltet, nicht viel hilft.  Grunds√§tzlich, weil die Box im Testmodus ohne Debugger und ohne mich in der N√§he war und <em>manchmal</em> fehlerhaft war.  Ungef√§hr alle paar Tage. </p><br><p>  Der Debugging-UART wurde an die D√ºsen geschraubt, in die ich Protokolle auszugeben begann.  Es wurde einfacher, einige der Probleme wurden gel√∂st.  Aber dann passierte eine Behauptung und alles passierte. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">In meinem Fall sieht das Makro f√ºr die Zusicherung ungef√§hr so ‚Äã‚Äãaus:</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USER_ASSERT( statement ) \ do \ { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(! (statement) ) \ { \ DEBUG_PRINTF_ERROR( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assertion on line %d in file %s!\n"</span></span></span><span class="hljs-meta">, \ __LINE__, __FILE__ ); \ \ __disable_irq(); \ while(1) \ { \ __BKPT(0xAB); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(0) \ break; \ } \ } \ } while(0)</span></span></code> </pre> <br><p>  <code>__BKPT(0xAB)</code> ist ein Software-Haltepunkt.  Wenn beim Debuggen eine Best√§tigung erfolgt, stoppt der Debugger nur an der Problemzeile. Dies ist sehr praktisch. </p></div></div><br><p>  Bei einigen Zusicherungen ist sofort klar, was sie verursacht hat - da das Protokoll den Dateinamen und die Zeilennummer anzeigt, an denen die Zusicherung gearbeitet hat. </p><br><p>  Der Behauptung zufolge war jedoch nur klar, dass das Array √ºberlief - genauer gesagt, ein provisorischer Wrapper √ºber dem Array, der den Ausweg √ºberpr√ºft.  Aus diesem Grund waren im Protokoll nur der Dateiname ‚Äûsuper_array.h‚Äú und die darin enthaltene Zeilennummer sichtbar.  Und welches spezifische Array ist nicht klar.  Von den umliegenden Protokollen ist es ebenfalls unklar. </p><br><p>  Nat√ºrlich k√∂nnte man einfach in die Kugel bei√üen und Ihren Code lesen, aber ich war zu faul, und dann w√ºrde der Artikel nicht funktionieren. </p><br><p>  Da ich in uVision Keil 5 mit dem armcc-Compiler schreibe, wurde weiterer Code nur darunter √ºberpr√ºft.  Ich habe auch C ++ 11 verwendet, weil es bereits 2019 auf dem Hof ‚Äã‚Äãist, es ist schon Zeit. </p><br><h2 id="stacktrace">  Stacktrace </h2><br><p>  Das erste, was mir in den Sinn kommt, ist nat√ºrlich, verdammt noch mal, denn wenn eine Zusicherung auf einem normalen Desktop-Computer erfolgt, wird eine Stapelverfolgung an die Konsole ausgegeben, beispielsweise auf KDPV.  Anhand der Stapelverfolgung k√∂nnen Sie normalerweise nachvollziehen, welche Reihenfolge der Aufrufe zu dem Fehler gef√ºhrt hat. <br>  Okay, ich brauche auch einen Stealth-Track.  Wie macht man das? </p><br><h3 id="mozhet-byt-esli-brosit-isklyuchenie-on-sam-vyvedetsya">  Wenn Sie eine Ausnahme ausl√∂sen, wird er m√∂glicherweise abgeleitet? </h3><br><p>  Wir l√∂sen eine Ausnahme aus und fangen sie nicht ab. Wir sehen die Ausgabe von "SIGABRT" und den Aufruf von <code>_sys_exit</code> .  Keine Fahrt, na gut, nicht wirklich, und ich wollte wirklich Ausnahmen zulassen. </p><br><h3 id="poguglit-kak-eto-drugie-lyudi-delayut">  Googeln, wie andere es machen. </h3><br><p>  Alle Methoden sind plattformspezifisch (nicht allzu √ºberraschend), f√ºr gcc unter POSIX gibt es <code>backtrace()</code> und <code>execinfo.h</code> .  F√ºr Cale war nichts verst√§ndlich.  Wir lassen eine gemeine Tr√§ne fallen.  Sie m√ºssen mit Ihren H√§nden auf den Stapel klettern. </p><br><h3 id="lezem-v-stek-rukami">  Wir klettern mit unseren H√§nden in den Stapel </h3><br><p>  Theoretisch ist alles ganz einfach. </p><br><ol><li>  Die R√ºcksprungadresse der aktuellen Funktion befindet sich im LR-Register, die Adresse der aktuellen Oberseite des Stapels (im Sinne des letzten Elements im Stapel) befindet sich im SP-Register, die Adresse des aktuellen Befehls befindet sich im PC-Register. </li><li>  Irgendwie finden wir die Gr√∂√üe des Stapelrahmens f√ºr die aktuelle Funktion, gehen in einem solchen Abstand entlang des Stapels, finden dort die R√ºcksprungadresse f√ºr die vorherige Funktion und wiederholen sie, bis wir den Stapel bis zum Ende durchlaufen. </li><li>  Irgendwie stimmen wir die Absenderadressen mit den Zeilennummern in Dateien mit dem Quellcode √ºberein. </li></ol><br><h4 id="okey-dlya-nachala--kak-uznat-razmer-stekovogo-kadra">  Ok, f√ºr den Anfang - woher wei√ü ich die Gr√∂√üe des Stapelrahmens? </h4><br><p>  Standardm√§√üig werden die Optionen - anscheinend √ºberhaupt nichts - vom Compiler einfach in den "Prolog" und "Epilog" jeder Funktion fest codiert, in Befehle, die einen Teil des Stapels f√ºr den Frame zuweisen und freigeben. <br>  Gl√ºcklicherweise hat armcc die Option <code>--use_frame_pointer</code> , die das R11-Register unter dem Frame Pointer <code>--use_frame_pointer</code> - d. H.  Zeiger auf den Stapelrahmen der vorherigen Funktion.  Gro√üartig, jetzt k√∂nnen Sie durch alle Stapelrahmen gehen. </p><br><h4 id="teper--kak-sopostavit-adresa-vozvratov-so-strokami-v-faylah-s-ishodnikami">  Nun - wie werden R√ºcksprungadressen mit Zeichenfolgen in Quelldateien abgeglichen? </h4><br><p>  Verdammt, auf keinen Fall wieder.  Debugging-Informationen werden nicht in den Mikrocontroller geflasht (was nicht √ºberraschend ist, da er anst√§ndige Pl√§tze einnimmt).  Kann Cale sie immer noch dazu bringen, dort zu blinken? Ich wei√ü nicht, ich konnte es nicht finden. </p><br><p>  Wir seufzen.  Daher funktioniert ein ehrlicher Stackrace - so dass Funktionsnamen und Zeilennummern sofort zur Debug-Ausgabe ausgegeben werden - nicht.  Sie k√∂nnen die Adressen jedoch anzeigen und dann auf dem Computer mit Funktionen und Zeilennummern vergleichen, da das Projekt noch Debugging-Informationen enth√§lt. </p><br><p>  Aber es sieht sehr traurig aus, weil Sie die .map-Datei analysieren m√ºssen, die die Adressbereiche angibt, die jede Funktion belegt.  Analysieren Sie dann Dateien mit zerlegtem Code separat, um eine bestimmte Zeile zu finden.  Es besteht ein scharfer Wunsch zu punkten. </p><br><p>  <code>--use_frame_pointer</code> die Dokumentation f√ºr die Option <code>--use_frame_pointer</code> genau <code>--use_frame_pointer</code> k√∂nnen <code>--use_frame_pointer</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Seite</a> <code>--use_frame_pointer</code> , die besagt, dass diese Option zu zuf√§lligen Abst√ºrzen in HardFault f√ºhren kann.  Hmm. <br>  Okay, denk weiter nach. </p><br><h3 id="a-kak-eto-delaet-otladchik">  Wie macht der Debugger das? </h3><br><p>  Aber der Debugger zeigt den Aufrufstapel auch ohne <code>frame pointer'a</code> irgendwie an.  Nun, es ist klar, wie die IDE alle Debug-Informationen zur Hand hat und es f√ºr sie einfach ist, die Adressen und Namen von Funktionen zu vergleichen.  Hm. </p><br><p>  Gleichzeitig hat dasselbe Visual Studio so etwas - Minidump -, wenn die abgest√ºrzte Anwendung eine kleine Datei generiert, die Sie dann dem Studio zuf√ºhren und den Status der Anwendung zum Zeitpunkt des Absturzes wiederherstellen.  Und Sie k√∂nnen alle Variablen ber√ºcksichtigen und bequem auf dem Stapel laufen.  Hm schon wieder. </p><br><p>  Aber es ist ziemlich einfach.  Ich brauche nur <del>  reibe jeden Tag eine dicke sowjetische Fortsetzung in das Ges√§√ü </del>  F√ºllen Sie den Stapel mit den Werten, die zum Zeitpunkt des Sturzes vorhanden waren, und stellen Sie anscheinend den Status der Register wieder her.  Und das ist alles, wie es scheint? </p><br><p>  Teilen Sie diese Idee erneut in Unteraufgaben auf. </p><br><ol><li>  Auf dem Mikrocontroller m√ºssen Sie den Stapel durchlaufen. Dazu m√ºssen Sie den aktuellen SP-Wert und die Adresse des Stapelanfangs abrufen. </li><li>  Auf dem Mikrocontroller m√ºssen Sie die Werte der Register anzeigen. </li><li>  In der IDE m√ºssen Sie irgendwie alle Werte aus dem "Minidump" zur√ºck auf den Stapel schieben.  Und die Werte der Register auch. </li></ol><br><h4 id="kak-poluchit-tekuschee-znachenie-sp">  Wie erhalte ich den aktuellen Wert von SP? </h4><br><p>  Am besten keine H√§nde auf dem Monteur pl√ºndern.  In Cale gibt es gl√ºcklicherweise eine spezielle Funktion (intrinsisch) - <code>__current_sp()</code> .  Gcc wird nicht funktionieren, aber ich muss nicht. </p><br><p>  Wie erhalte ich die Adresse des Stapelanfangs?  Da ich mein Skript zum Schutz vor √úberlauf verwende (wor√ºber ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier geschrieben habe</a> ), befindet sich mein Stack in einem separaten Linker-Bereich, den ich <code>REGION_STACK</code> genannt <code>REGION_STACK</code> . <br>  Dies bedeutet, dass seine Adresse beim Linker unter Verwendung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seltsamer Variablen mit Dollar in den Namen gefunden werden kann</a> . </p><br><p>  Durch Versuch und Irrtum w√§hlen wir den gew√ºnschten Namen aus - <code>Image$$REGION_STACK$$ZI$$Limit</code> , √ºberpr√ºfen Sie, es funktioniert. </p><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rung</b> <div class="spoiler_text"><p>  Dies ist ein magisches Symbol, das in der Verkn√ºpfungsphase erstellt wird. Genau genommen ist es keine Konstante der Kompilierungsphase. <br>  Um es zu verwenden, ben√∂tigen Sie eine Dereferenzierung: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Image$$REGION_STACK$$ZI$$Limit; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MemPointer = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *; <span class="hljs-comment"><span class="hljs-comment">//   ,   static const auto stack_upper_address = (MemPointer) &amp;( Image$$REGION_STACK$$ZI$$Limit );</span></span></code> </pre> </div></div><br><p>  Wenn Sie keine Lust haben, k√∂nnen Sie die Gr√∂√üe des Stapels einfach fest codieren, da er sich nur sehr selten √§ndert.  Im schlimmsten Fall sehen wir im Call-Stack-Fenster nicht alle Calls, sondern einen Stub. </p><br><h4 id="kak-vyvesti-znacheniya-registrov">  Wie werden Registerwerte angezeigt? </h4><br><p>  Zuerst dachte ich, dass es notwendig sei, alle Allzweckregister im Allgemeinen anzuzeigen. Ich fing an, mich mit dem Assembler zu besch√§ftigen, erkannte aber schnell, dass dies keinen Sinn ergeben w√ºrde.  Immerhin wird die Ausgabe des Minidumps durch eine spezielle Funktion f√ºr mich erfolgen, es macht keinen Sinn, Registerwerte in ihrem Kontext zu verwenden. </p><br><p>  Wir brauchen wirklich nur das Link Register (LR), in dem die R√ºcksprungadresse der aktuellen Funktion SP gespeichert ist, mit dem wir uns bereits befasst haben, und den Programmz√§hler (PC), in dem die Adresse des aktuellen Befehls gespeichert ist. </p><br><p>  Wieder konnte ich keine Option finden, die mit jedem Compiler funktionieren w√ºrde, aber es gibt wieder intrinsische Funktionen f√ºr Cale: <code>__return_address()</code> f√ºr LR und <code>__current_pc()</code> f√ºr PC. <br>  Gro√üartig.  Es bleibt, alle Werte aus dem Minidump zur√ºck auf den Stapel und die Werte der Register in die Register zu schieben. </p><br><h4 id="kak-zagruzit-minidamp-v-pamyat">  Wie lade ich einen Minidump in den Speicher? </h4><br><p>  Zuerst wollte ich den Befehl LOAD debugger verwenden, mit dem Sie Werte aus einer .hex- oder .bin-Datei in den Speicher laden k√∂nnen, stellte jedoch schnell fest, dass LOAD aus irgendeinem Grund keine Werte in den RAM l√§dt. <br>  Und ich w√§re immer noch nicht in der Lage, die Register mit diesem Befehl zu vervollst√§ndigen. </p><br><p>  Okay, es w√ºrde immer noch zu viele Gesten erfordern, Text in Bin konvertieren, Bin in Hex konvertieren ... </p><br><p>  Gl√ºcklicherweise hat Cale einen Simulator, und f√ºr den Simulator k√∂nnen Sie Skripte in einer elenden C-√§hnlichen Sprache schreiben.  Und in dieser Sprache gibt es die M√∂glichkeit, in Erinnerung zu schreiben!  <code>_WDWORD</code> gibt es spezielle Funktionen wie <code>_WDWORD</code> und <code>_WBYTE</code> .  Wir sammeln alle Ideen auf einem Haufen und erhalten einen solchen Code. </p><br><div class="spoiler">  <b class="spoiler_title">Alle Code:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USER_ASSERT( statement ) \ do \ { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(! (statement) ) \ { \ DEBUG_PRINTF_ERROR( </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assertion on line %d in file %s!\n"</span></span></span><span class="hljs-meta">, \ __LINE__, __FILE__ ); \ \ print_minidump(); \ __disable_irq(); \ while(1) \ { \ __BKPT(0xAB); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(0) \ break; \ } \ } \ } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   ,    //   ,         scatter- extern unsigned int Image$$REGION_STACK$$ZI$$Limit; void print_minidump() { //   - armcc  arm-clang #if __CC_ARM || ( (__ARMCC_VERSION) &amp;&amp; (__ARMCC_VERSION &gt;= 6010050)) using MemPointer = const uint32_t *; //   ,   static const auto stack_upper_address = (MemPointer) &amp;(Image$$REGION_STACK$$ZI$$Limit ); //      , ..      //  SP  stack_upper_address auto LR = __return_address(); auto PC = __current_pc(); auto SP = __current_sp(); auto i = 0; DEBUG_PRINTF("\nCopy the following function for simulator to .ini-file, \n" "start fresh debug session in simulator and call __load_minidump() from command window.\n" "You should be able to see the call stack in CallStack window\n\n"); DEBUG_PRINTF("func void __load_minidump() {\n "); for( MemPointer stack = (MemPointer)SP; stack &lt;= stack_upper_address; stack++ ) { DEBUG_PRINTF("_WDWORD (0x%p, 0x%08x); ", stack, *stack ); //         if( i == 1 ) { DEBUG_PRINTF("\n "); i=0; } else { i++; } } DEBUG_PRINTF("\n LR = 0x%08x;", LR ); DEBUG_PRINTF("\n PC = 0x%08x;", PC ); DEBUG_PRINTF("\n SP = 0x%08x;", SP ); DEBUG_PRINTF("\n}\n"); #endif }</span></span></span></span></code> </pre></div></div><br><p>  Um den Minidump zu laden, m√ºssen wir eine INI-Datei erstellen, die Funktion <code>__load_minidump</code> in sie kopieren, diese Datei zum Autorun hinzuf√ºgen - <code>Project -&gt; Options for Target -&gt; Debug</code> Debuggen und diese INI-Datei im Abschnitt ‚ÄûInitialisierungsdatei‚Äú im Abschnitt ‚ÄûSimulator verwenden‚Äú schreiben. </p><br><p>  Jetzt gehen wir einfach zum Debuggen auf dem Simulator und rufen, ohne mit dem Debuggen zu beginnen, die Funktion <code>__load_minidump()</code> im Befehlsfenster auf. <br>  Und voila, wir teleportieren uns zur Funktion <code>print_minidump</code> in der Zeile, in der der PC gespeichert wurde.  Im Fenster Callstack + Locals sehen Sie den Call Stack. </p><br><div class="spoiler">  <b class="spoiler_title">Hinweis:</b> <div class="spoiler_text"><p>  Die Funktion wird am Anfang speziell mit zwei Unterstrichen benannt. Wenn der Name der Funktion oder Variablen im Simulationsskript versehentlich mit dem Namen im Projektcode √ºbereinstimmt, kann Cale ihn nicht aufrufen.  Der C ++ - Standard verbietet die Verwendung von Namen mit zwei Unterstrichen am Anfang, sodass die Wahrscheinlichkeit, dass Namen √ºbereinstimmen, verringert wird. </p></div></div><br><p>  Im Prinzip ist das alles.  Soweit ich √ºberpr√ºfen konnte, funktioniert der Minidump sowohl f√ºr regul√§re Funktionen als auch f√ºr Interrupt-Handler.  Ob es f√ºr alle Arten von Perversionen mit <code>setjmp/longjmp</code> oder <code>alloca</code> - ich wei√ü es nicht, weil ich keine Perversionen √ºbe. </p><br><p>  Ich bin ziemlich zufrieden mit dem, was passiert ist;  kleiner Code, Overhead - leicht geschwollenes Makro zum Durchsetzen.  In diesem Fall fiel die langweilige Arbeit beim Parsen des Stapels auf die Schultern der IDE, zu der er geh√∂rt. </p><br><p>  Dann habe ich ein bisschen gegoogelt und eine √§hnliche Sache f√ºr gcc und gdb gefunden - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CrashCatcher</a> . </p><br><p>  Ich verstehe, dass ich nichts Neues erfunden habe, aber ich konnte kein fertiges Rezept finden, das zu einem √§hnlichen Ergebnis f√ºhrte.  Ich w√§re dankbar, wenn sie mir sagen w√ºrden, was besser gemacht werden k√∂nnte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452704/">https://habr.com/ru/post/de452704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452692/index.html">Der Autor des rePalm-Projekts hat Palm OS von Grund auf neu geschrieben und plant, es in eine Smart-Watch-Plattform umzuwandeln</a></li>
<li><a href="../de452696/index.html">So starten Sie Mikrozahlungen in Ihrer Anwendung</a></li>
<li><a href="../de452698/index.html">Zwei in einem: Touristendaten und Tickets f√ºr kulturelle Veranstaltungen waren √∂ffentlich verf√ºgbar</a></li>
<li><a href="../de452700/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 460 (05/07/2019 - 05/05/2019)</a></li>
<li><a href="../de452702/index.html">Tests auf Code und Code f√ºr Tests</a></li>
<li><a href="../de452706/index.html">1983 wurde dieser Computer von Bella Labs der erste Gro√ümeister.</a></li>
<li><a href="../de452712/index.html">Wie wir versucht haben, in einem Team zu arbeiten und was dabei herauskam</a></li>
<li><a href="../de452714/index.html">Achten Sie auf Nummer 5: Zusammenfassung der Artikel zu Produktdenken, Verhaltenspsychologie und Produktivit√§t</a></li>
<li><a href="../de452716/index.html">Auf der Suche nach einem optimalen Einsatzort der Humanressourcen</a></li>
<li><a href="../de452718/index.html">PsyGuide: Aufmerksamkeitsdefizit. # 0001/1001</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>