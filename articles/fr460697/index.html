<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úîÔ∏è üå∞ ü§æüèª Police la plus petite possible üë®üèΩ‚Äçüöí üë®üèø‚Äçü§ù‚Äçüë®üèº üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="T√¢che: en utilisant le moins de ressources possible, rendez un texte significatif. 


- Quelle taille peut avoir une police lisible? 
- Combien de m√©m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Police la plus petite possible</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p>  T√¢che: en utilisant le moins de ressources possible, rendez un texte significatif. </p><br><ul><li>  Quelle taille peut avoir une police lisible? </li><li>  Combien de m√©moire faut-il pour le stocker? </li><li>  Combien de code faut-il pour l'utiliser? </li></ul><br><p>  Voyons voir ce que nous obtenons.  Spoiler </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Introduction aux bitmaps </h2><br><p> Les ordinateurs pr√©sentent les bitmaps sous forme de bitmaps.  Il ne s'agit pas du format <code>.bmp</code> , mais d'un moyen de stocker des pixels en m√©moire.  Pour comprendre ce qui se passe, nous devons apprendre quelque chose de cette fa√ßon. </p><br><h3 id="sloi">  Couches </h3><br><p>  Une image contient g√©n√©ralement plusieurs <em>couches</em> superpos√©es.  Ils correspondent le plus souvent aux coordonn√©es de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">espace colorim√©trique RVB</a> .  Une couche pour le <em>rouge</em> , une pour le <em>vert</em> et une pour le <em>bleu</em> .  Si le format d'image prend en charge la transparence, un quatri√®me calque est cr√©√© pour lui, g√©n√©ralement appel√© <em>alpha</em> .  En gros, une image couleur est de trois (ou quatre, s'il y a un canal alpha) en noir et blanc, situ√©es l'une au-dessus de l'autre. </p><br><ul><li>  Le RVB n'est pas le seul espace colorim√©trique;  Le format JPEG, par exemple, utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YUV</a> .  Mais dans cet article, nous n'aurons pas besoin du reste des espaces colorim√©triques, nous ne les consid√©rons donc pas. </li></ul><br><p>  Un ensemble de couches peut √™tre repr√©sent√© en m√©moire de deux mani√®res.  Soit ils sont stock√©s s√©par√©ment, soit les valeurs de diff√©rentes couches sont entrelac√©es.  Dans ce dernier cas, les couches sont appel√©es <em>canaux</em> , et c'est ainsi que la plupart des formats modernes fonctionnent. </p><br><p>  Supposons que nous ayons un dessin 4x4 contenant trois couches: <em>R</em> pour le rouge, <em>G</em> pour le vert et <em>B</em> pour la composante bleue de chacun des pixels.  Il peut √™tre repr√©sent√© comme ceci: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  Les trois couches sont stock√©es s√©par√©ment.  Le format alternatif est diff√©rent: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  chaque triple de caract√®res correspond <strong>exactement √†</strong> un pixel </li><li>  les valeurs dans le triple sont dans l'ordre <em>RVB</em> .  Parfois, un ordre diff√©rent peut √™tre utilis√© (par exemple, <em>BGR</em> ), mais celui-ci est le plus courant. </li></ul><br><p>  Par souci de simplicit√©, j'ai dispos√© les pixels sous la forme d'une matrice √† deux dimensions, car il est plus clair o√π tel ou tel triple est dans l'image.  Mais en fait, la m√©moire de l'ordinateur n'est pas bidimensionnelle, mais unidimensionnelle, donc l'image 4x4 sera stock√©e comme ceci: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  L'abr√©viation <em>bpp</em> fait r√©f√©rence au nombre de bits ou d'octets par pixel (bits / octets par pixel).  Vous avez peut-√™tre vu <code>24bpp</code> ou 3 <code>3bpp</code> .  Ces deux caract√©ristiques signifient la m√™me chose - <strong>24 <em>bits</em> par pixel</strong> ou <strong>3 <em>octets</em> par pixel</strong> .  Puisqu'il y a toujours 8 bits dans un octet, vous pouvez deviner par la valeur de laquelle des unit√©s en question. </p><br><h3 id="predstavlenie-v-pamyati">  Repr√©sentation de la m√©moire </h3><br><p>  <code>24bpp</code> , alias <code>3bpp</code> - le format le plus courant pour stocker des fleurs.  Voici √† quoi ressemble un <strong>pixel</strong> dans l'ordre <em>RVB</em> au niveau des bits individuels. </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  Un octet pour <em>R</em> , un pour <em>G</em> et un pour <em>B</em> , totalisant trois octets. </li><li>  Chacun d'eux contient une valeur de 0 √† 255. </li></ul><br><p>  Donc, si le pixel donn√© a la couleur suivante: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Ensuite, <code>255</code> stock√©s dans le premier octet, <code>80</code> dans le second et <code>100</code> dans le troisi√®me. </p><br><p>  Le plus souvent, ces valeurs sont repr√©sent√©es en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hexad√©cimal</a> .  Dites <code>#ff5064</code> .  C'est beaucoup plus pratique et compact: <code>R = 0xff</code> (c'est-√†-dire <code>R=255</code> en d√©cimal), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  La repr√©sentation hexad√©cimale a une propri√©t√© utile.  √âtant donn√© que chaque octet de couleur est repr√©sent√© par deux caract√®res, chaque caract√®re code <strong>exactement</strong> un demi-octet ou quatre bits.  Au fait, 4 bits sont appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grignotage</a> . </li></ul><br><h3 id="shirina-stroki">  Largeur de ligne </h3><br><p>  Lorsque les pixels se succ√®dent et contiennent chacun plusieurs canaux, les donn√©es sont facilement confondues.  On ne sait pas quand une ligne se termine et la suivante commence, donc, pour interpr√©ter un fichier avec un bitmap, vous devez conna√Ætre la taille de l'image et <em>bpp</em> .  Dans notre cas, l'image a une largeur de <code>w = 4</code> pixels et chacun de ces pixels contient 3 octets, donc la cha√Æne est cod√©e avec 12 octets (dans le cas g√©n√©ral <code>w*bpp</code> ). </p><br><ul><li>  Une cha√Æne n'est pas toujours cod√©e avec exactement <code>w*bpp</code> octets;  Souvent, des pixels ¬´cach√©s¬ª y sont ajout√©s pour amener la largeur de l'image √† une certaine taille.  Par exemple, la mise √† l'√©chelle des images est plus rapide et plus pratique lorsque leur taille en pixels est √©gale √† une puissance de deux.  Par cons√©quent, le fichier peut contenir (accessible √† l'utilisateur) une image de 120x120 pixels, mais √™tre stock√© sous la forme d'une image de 128x128.  Lorsqu'une image est affich√©e √† l'√©cran, ces pixels sont ignor√©s.  Cependant, nous n'avons pas besoin de les conna√Ætre. </li></ul><br><p>  La coordonn√©e de tout pixel <code>(x, y)</code> dans la repr√©sentation unidimensionnelle est <code>(y * w + x) * bpp</code> .  Ceci, en g√©n√©ral, est √©vident: <code>y</code> est le num√©ro de ligne, chaque ligne contient <code>w</code> pixels, donc <code>y * w</code> est le d√©but de la ligne souhait√©e, et <code>+x</code> nous am√®ne au <code>x</code> souhait√© en son sein.  Et comme les coordonn√©es ne sont pas en octets, mais en pixels, tout cela est multipli√© par la taille du pixel <code>bpp</code> , en l'occurrence en octets.  √âtant donn√© que le pixel a une taille non nulle, vous devez lire exactement les octets <code>bpp</code> , √† partir des coordonn√©es re√ßues, et nous aurons une repr√©sentation compl√®te du pixel souhait√©. </p><br><h2 id="atlas-shrifta">  Atlas des polices </h2><br><p>  En fait, les moniteurs existants n'affichent pas un pixel dans son ensemble, mais trois sous-pixels - rouge, bleu et vert.  Si vous regardez le moniteur sous grossissement, vous verrez quelque chose comme ceci: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  Dessin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikip√©dia</a> </li></ul><br><p>  Nous nous int√©ressons √† l'√©cran LCD, car c'est probablement √† partir d'un tel moniteur que vous lisez ce texte.  Bien s√ªr, il y a des √©cueils: </p><br><ul><li>  Toutes les matrices n'utilisent pas exactement cet ordre de sous-pixels, parfois BGR. </li><li>  Si vous tournez le moniteur (par exemple, regardez le t√©l√©phone en orientation paysage), le motif pivotera √©galement et la police cessera de fonctionner. </li><li>  Diff√©rentes orientations de matrice et la disposition des sous-pixels n√©cessiteront de retravailler la police elle-m√™me. </li><li>  En particulier, il ne fonctionne pas sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crans AMOLED</a> qui utilisent la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disposition PenTile</a> .  Ces √©crans sont le plus souvent utilis√©s dans les appareils mobiles. </li></ul><br><p>  L'utilisation de hacks de sous-pixels pour augmenter la r√©solution est appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu de sous-pixels</a> .  Vous pouvez lire sur son utilisation en typographie, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Heureusement pour nous, Matt Sarnov a d√©j√† compris en utilisant le rendu sous-pixel pour cr√©er une petite police <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">millitext</a> .  Manuellement, il a cr√©√© cette petite image: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Ce qui, si vous regardez attentivement le moniteur, ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  Et le voici, multipli√© par 12 par programme: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Sur la base de son travail, j'ai cr√©√© un atlas de polices dans lequel chaque caract√®re correspond √† une colonne de <code>1x5</code> pixels.  L'ordre des caract√®res est le suivant: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  Le m√™me atlas a √©t√© multipli√© par 12: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  Avec 36 caract√®res utilis√©s, exactement <code>365</code> pixels sont <code>365</code> .  Si nous supposons que chaque pixel occupe 3 octets, nous avons besoin de <code>36*5*3 = 540</code> octets pour stocker l'image enti√®re (environ par <em>.: Dans l'original, une s√©rie confuse de modifications sur le canal alpha, la suppression des m√©tadonn√©es, etc.). n. Dans la traduction, je l'ai omis et n'utilise que la version finale du fichier</em> ).  Un fichier PNG pass√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pngcrush</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optipng</a> prend encore moins: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  Mais vous pouvez atteindre une taille encore plus petite si vous utilisez une approche l√©g√®rement diff√©rente </p><br><h1 id="szhatie">  La compression </h1><br><p>  Le lecteur attentif a pu remarquer que l'atlas n'utilise que 7 couleurs: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Palette </h2><br><p>  Dans de telles situations, il est souvent plus facile de cr√©er une palette.  Ensuite, pour chaque pixel, vous pouvez stocker non pas trois octets de couleur, mais uniquement le num√©ro de couleur dans la palette.  Dans notre cas, 3 bits ( <code>7 &lt; 2^3</code> ) suffiront pour choisir parmi 7 couleurs.  Si nous attribuons une valeur √† trois bits √† chaque pixel, alors l'ensemble de l'atlas tiendra en <em>68 octets</em> . </p><br><ul><li>  Le lecteur, vers√© dans la compression de donn√©es, peut r√©pondre qu'en g√©n√©ral, il existe des ¬´bits fractionnaires¬ª et dans notre cas <strong>2,875 bits par pixel</strong> suffisent.  Cette densit√© peut √™tre obtenue en utilisant la magie noire, connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codage arithm√©tique</a> .  Nous ne le ferons pas, car le codage arithm√©tique est une chose compliqu√©e, et 68 octets, c'est d√©j√† un peu. </li></ul><br><h2 id="vyravnivanie">  Alignement </h2><br><p>  Le codage √† trois bits pr√©sente un s√©rieux inconv√©nient.  Les pixels ne peuvent pas √™tre r√©partis uniform√©ment sur des octets 8 bits, ce qui est important car les octets sont la plus petite zone de m√©moire adressable.  Disons que nous voulons √©conomiser trois pixels: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  Si chacun prend 3 bits, il faudra alors 2 octets pour les stocker ( <code>-</code> indique les bits inutilis√©s): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  Surtout, le pixel <strong>C</strong> ne laisse pas seulement un tas d'espace vide;  il est <em>d√©chir√©</em> entre deux octets.  Lorsque nous commen√ßons √† ajouter les pixels suivants, ils peuvent √™tre positionn√©s arbitrairement par rapport aux limites d'octets.  La solution la plus simple serait d'utiliser un quartet par pixel, car 8 est parfaitement divis√© par 4 et vous permet de placer exactement deux pixels dans chaque octet.  Mais cela augmentera la taille de l'atlas d'un tiers, de <strong>68 octets</strong> √† <strong>90 octets</strong> . </p><br><ul><li>  En fait, le fichier peut √™tre encore plus petit en utilisant le codage palindrome, le codage d'intervalle et d'autres techniques de compression.  Comme le codage arithm√©tique, nous reportons ces techniques au prochain article. </li></ul><br><h2 id="bitovyy-bufer">  Tampon de bits </h2><br><p>  Heureusement, il n'y a rien de fondamentalement impossible √† travailler avec des valeurs 3 bits.  Il vous suffit de surveiller la position √† l'int√©rieur de l'octet que nous √©crivons ou lisons en ce moment.  La classe simple suivante convertit un flux de donn√©es 3 bits en un tableau d'octets. </p><br><ul><li>  Pour des raisons de lisibilit√©, le code est √©crit en JS, mais la m√™me m√©thode est g√©n√©ralis√©e √† d'autres langages. </li><li>  Ordre utilis√© de l'octet bas au haut ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  T√©l√©chargeons et encodons le fichier atlas: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  Comme pr√©vu, l'atlas contient <strong>68 octets</strong> , ce qui est 6 fois plus petit que le fichier PNG. </p><br><p>  ( <em>piste approximative: l'auteur est un peu malhonn√™te: il n'a pas enregistr√© la palette et la taille de l'image, ce qui, selon mes estimations, n√©cessitera 23 octets avec une taille de palette fixe et augmentera la taille de l'image √† 91 octets</em> ) </p><br><p>  Convertissons maintenant l'image en cha√Æne afin de pouvoir la coller dans le code source.  En substance, la m√©thode <code>to_string</code> cela: elle repr√©sente le contenu de chaque octet sous la forme d'un nombre hexad√©cimal. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  Mais la cha√Æne r√©sultante est encore assez longue, car nous nous sommes limit√©s √† un alphabet de 16 caract√®res.  Vous pouvez le remplacer par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base64</a> , dans lequel il y a quatre fois plus de caract√®res. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  En base64, l'atlas ressemble √† ceci: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  Cette ligne peut √™tre cod√©e en dur sur le module JS et utilis√©e pour pixelliser le texte. </p><br><h1 id="rasterizaciya">  Rast√©risation </h1><br><p>  Pour √©conomiser de la m√©moire, une seule lettre sera d√©cod√©e √† la fois. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  La fonction de <code>decode</code> prend un caract√®re en entr√©e et renvoie la colonne correspondante dans l'image source.  Ce qui est impressionnant ici, c'est qu'il ne faut que <strong>5 octets de</strong> m√©moire pour d√©coder un seul caract√®re, plus <strong>~ 1,875</strong> octets pour lire la partie souhait√©e du tableau, c'est-√†-dire  une moyenne de <strong>6.875</strong> par lettre.  Si vous ajoutez <strong>68 octets</strong> pour stocker le tableau et <strong>36 octets</strong> pour stocker l'alphabet, il s'av√®re que <em>th√©oriquement,</em> vous pouvez rendre le texte avec 128 octets de RAM. </p><br><ul><li>  Ceci est possible si vous r√©√©crivez le code en C ou en assembleur.  Dans le contexte de la surcharge JS, il s'agit d'une √©conomie sur les correspondances. </li></ul><br><p>  Il ne reste plus qu'√† rassembler ces colonnes en un seul ensemble et √† renvoyer une image avec du texte. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  Ce sera la police la plus petite possible. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  Ajoutez un petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">imagemagick</a> pour obtenir l'image dans un format lisible: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  Et voici le r√©sultat final: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  Il est √©galement augment√© de 12 fois: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  Elle a √©t√© prise √† partir d'une macro de moniteur mal calibr√©e: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  Et enfin, c'est mieux sur le moniteur: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460697/">https://habr.com/ru/post/fr460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460675/index.html">Extraction de donn√©es d'apprentissage automatique</a></li>
<li><a href="../fr460683/index.html">Projecteur d'√©v√©nements Laravel et concept de g√©n√©ration d'√©v√©nements</a></li>
<li><a href="../fr460685/index.html">Nous distribuons des fichiers √† partir de Google Drive en utilisant nginx</a></li>
<li><a href="../fr460687/index.html">A quoi ressemblent les canettes de l'int√©rieur</a></li>
<li><a href="../fr460695/index.html">Qu'est-ce que DAA et comment ce syst√®me aide-t-il les drones?</a></li>
<li><a href="../fr460699/index.html">Habr Weekly # 10 / Super services et passeport √©lectronique, smartphones et russes, ¬´gadgets espions¬ª, la vie sans satellites</a></li>
<li><a href="../fr460701/index.html">Cours "Start in Data Science": la premi√®re √©tape de l'utilisation des donn√©es</a></li>
<li><a href="../fr460703/index.html">Blue Ocean of Opportunity: de z√©ro √† 400 mille interviews vid√©o</a></li>
<li><a href="../fr460707/index.html">Est-il temps pour les d√©veloppeurs de jeux de cesser d'√©couter leurs fans?</a></li>
<li><a href="../fr460709/index.html">R√©flexions sur Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>