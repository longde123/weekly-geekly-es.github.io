<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèæ üå∞ üÜï Pruebas puras en PHP y PHPUnit üÜî üöæ üíÜüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay muchas herramientas en el ecosistema de PHP que proporcionan pruebas de PHP convenientes. Uno de los m√°s famosos es PHPUnit , que es casi un sin√≥n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas puras en PHP y PHPUnit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/485124/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/3y/zg/jx3yzg2jnznn0kwnk6oe6ikvlzw.jpeg" width="400"></div><br>  Hay muchas herramientas en el ecosistema de PHP que proporcionan pruebas de PHP convenientes.  Uno de los m√°s famosos es <a href="https://github.com/sebastianbergmann/phpunit">PHPUnit</a> , que es casi un sin√≥nimo de prueba en este lenguaje.  Sin embargo, no se escribe mucho sobre buenos m√©todos de prueba.  Hay muchas opciones sobre por qu√© y cu√°ndo escribir pruebas, qu√© tipo de pruebas, etc.  Pero para ser sincero, <b>no tiene sentido escribir un examen si no puede leerlo m√°s tarde</b> . <br><br>  Las pruebas son un tipo especial de documentaci√≥n.  Como <a href="https://thephp.website/en/issue/real-life-tdd-php/">escrib√≠ sobre TDD en PHP anteriormente</a> , la prueba siempre (o al menos deber√≠a) decir claramente cu√°l es la tarea de un c√≥digo en particular. <br><br>  Si una prueba no puede expresar esta idea, entonces la prueba es mala. <br><br>  He preparado un conjunto de t√©cnicas que ayudar√°n a los desarrolladores de PHP a escribir pruebas buenas, legibles y √∫tiles. <br><a name="habracut"></a><br><h2>  Comencemos con lo b√°sico </h2><br>  Hay un conjunto de t√©cnicas est√°ndar que muchos siguen sin ninguna pregunta.  Mencionar√© muchos de ellos e intentar√© explicar por qu√© son necesarios. <br><br><h3>  1. Las pruebas no deben contener operaciones de entrada-salida </h3><br>  <b>La raz√≥n principal</b> : las operaciones de E / S son lentas y poco confiables. <br><br>  <b>Lento</b> : incluso si tiene el mejor hardware del mundo, la E / S seguir√° siendo m√°s lenta que los accesos de memoria.  Las pruebas siempre deben funcionar r√°pido, de lo contrario las personas las realizar√°n muy raramente. <br><br>  <b>No confiable</b> : algunos archivos, binarios, sockets, carpetas y registros DNS pueden no estar disponibles en algunas m√°quinas en las que est√° probando.  Cuanto m√°s conf√≠e en las pruebas de E / S, m√°s vinculadas estar√°n sus pruebas a la infraestructura. <br><br>  Qu√© operaciones se relacionan con E / S: <br><br><ul><li>  Lectura y escritura de archivos. <br></li><li>  Llamadas de red. <br></li><li> Llamadas a procesos externos (usando <code>exec</code> , <code>proc_open</code> , etc.). <br></li></ul><br>  Hay situaciones en las que la presencia de operaciones de entrada-salida le permite escribir pruebas m√°s r√°pido.  Pero tenga cuidado: compruebe que tales operaciones funcionan de la misma manera en sus m√°quinas para el desarrollo, el ensamblaje y la implementaci√≥n, de lo contrario puede tener serios problemas. <br><br>  A√≠sle las pruebas para que no necesiten operaciones de E / S: a continuaci√≥n proporcion√© una soluci√≥n arquitect√≥nica que evita que las pruebas realicen operaciones de E / S al compartir la responsabilidad entre las interfaces. <br><br>  Un ejemplo: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPeople</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ $rawPeople = file_get_contents( <span class="hljs-string"><span class="hljs-string">'people.json'</span></span> ) ?? <span class="hljs-string"><span class="hljs-string">'[]'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode( $rawPeople, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); }</code> </pre><br>  Cuando comience a probar con este m√©todo, se crear√° un archivo local y, de vez en cuando, se crear√°n instant√°neas: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGetPeopleReturnsPeopleList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $people = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;peopleService -&gt;getPeople(); <span class="hljs-comment"><span class="hljs-comment">// assert it contains people }</span></span></code> </pre> <br>  Para hacer esto, necesitamos establecer requisitos previos para ejecutar pruebas.  A primera vista, todo parece razonable, pero de hecho es terrible. <br><br>  Omitir una prueba debido al hecho de que no se cumplen los requisitos previos no garantiza la calidad de nuestro software.  ¬°Esto solo ocultar√° errores! <br><br>  <b>Arreglamos la situaci√≥n</b> : aislamos las operaciones de E / S cambiando la responsabilidad a la interfaz. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// extract the fetching // logic to a specialized // interface interface PeopleProvider { public function getPeople(): array; } // create a concrete implementation class JsonFilePeopleProvider implements PeopleProvider { private const PEOPLE_JSON = 'people.json'; public function getPeople(): array { $rawPeople = file_get_contents( self::PEOPLE_JSON ) ?? '[]'; return json_decode( $rawPeople, true ); } } class PeopleService { // inject via __construct() private PeopleProvider $peopleProvider; public function getPeople(): array { return $this-&gt;peopleProvider -&gt;getPeople(); } }</span></span></code> </pre> <br>  Ahora s√© que <code>JsonFilePeopleProvider</code> usar√° E / S en cualquier caso. <br><br>  En lugar de <code>file_get_contents()</code> puede usar una capa de abstracci√≥n como <a href="https://flysystem.thephpleague.com/docs/adapter/local/">el sistema de archivos Flysystem</a> , para lo cual es f√°cil hacer stubs. <br><br>  ¬øY entonces por qu√© necesitamos <code>PeopleService</code> ?  Buena pregunta  Para esto, se necesitan pruebas: para desafiar la arquitectura y eliminar el c√≥digo in√∫til. <br><br><h3>  2. Las pruebas deben ser conscientes y significativas. </h3><br>  <b>La raz√≥n principal</b> : las pruebas son una forma de documentaci√≥n.  Mant√©ngalos claros, concisos y legibles. <br><br>  <b>Claridad y brevedad</b> : sin desorden, sin mil l√≠neas de trozos, sin secuencias de declaraciones. <br><br>  <b>Legibilidad</b> : las pruebas deben contar una historia.  La estructura "dado, cu√°ndo, entonces" es excelente para esto. <br><br>  Caracter√≠sticas de una prueba buena y legible: <br><br><ul><li>  Contiene solo las llamadas necesarias al m√©todo de <code>assert</code> (preferiblemente uno). <br></li><li>  √âl explica muy claramente lo que deber√≠a suceder en determinadas condiciones. <br></li><li>  Prueba solo una rama de la ejecuci√≥n del m√©todo. <br></li><li>  √âl no hace un trozo para todo el universo por el bien de cualquier declaraci√≥n. <br></li></ul><br>  Es importante tener en cuenta que si su implementaci√≥n contiene expresiones condicionales, operadores de transici√≥n o bucles, todos deber√≠an estar expl√≠citamente cubiertos por las pruebas.  Por ejemplo, para que las respuestas tempranas siempre contengan una prueba. <br><br>  Repito: no es una cuesti√≥n de cobertura, sino de documentaci√≥n. <br><br>  Aqu√≠ hay un ejemplo de una prueba confusa: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $noWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals( <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, $noWings-&gt;canFly() ); $singleWing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( !$singleWing-&gt;canFly() ); $twoWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $twoWings-&gt;canFly() ); }</code> </pre> <br>  Adaptemos el formato "dado cu√°ndo, entonces" y veamos qu√© sucede: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $person = $this-&gt;givenAPersonHasNoWings(); // Then $this-&gt;assertEquals( false, $person-&gt;canFly() ); // Further cases... } private function givenAPersonHasNoWings(): Person { return new Person(0); }</span></span></code> </pre> <br>  Al igual que la secci√≥n "Dado", "cu√°ndo" y "entonces" se pueden transferir a m√©todos privados.  Esto har√° que su prueba sea m√°s legible. <br><br>  <code>assertEquals</code> desastre sin sentido.  La persona que lee esto debe rastrear la declaraci√≥n para entender lo que significa. <br><br>  El uso de declaraciones espec√≠ficas har√° que su prueba sea mucho m√°s legible.  <code>assertTrue()</code> deber√≠a recibir una variable booleana, no una expresi√≥n como <code>canFly() !== true</code> . <br><br>  En el ejemplo anterior, reemplazamos <code>assertEquals</code> entre <code>false</code> y <code>$person-&gt;canFly()</code> con un simple <code>assertFalse</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $person = $this-&gt;givenAPersonHasNoWings(); $this-&gt;assertFalse( $person-&gt;canFly() ); // Further cases...</span></span></code> </pre> <br>  ¬°Ahora todo est√° muy claro!  Si una persona no tiene alas, ¬°no debe poder volar!  Leer como un poema <br><br>  Ahora, la secci√≥n "Casos adicionales", que aparece dos veces en nuestro texto, es una clara indicaci√≥n de que la prueba hace demasiadas declaraciones.  El m√©todo <code>testCanFly()</code> es completamente in√∫til. <br><br>  Mejoremos la prueba nuevamente: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsFalsyWhenPersonHasNoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasNoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertFalse( $person-&gt;canFly() ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsTruthyWhenPersonHasTwoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasTwoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $person-&gt;canFly() ); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br>  Incluso podemos cambiar el nombre del m√©todo de prueba para que coincida con el escenario real, por ejemplo, en <code>testPersonCantFlyWithoutWings</code> , pero de <code>testPersonCantFlyWithoutWings</code> todo me conviene. <br><br><h3>  3. La prueba no debe depender de otras pruebas. </h3><br>  <b>La raz√≥n principal</b> : las pruebas deben ejecutarse y ejecutarse con √©xito en cualquier orden. <br><br>  No veo razones suficientes para crear interconexiones entre pruebas.  Recientemente me pidieron que hiciera una prueba de funci√≥n de inicio de sesi√≥n, la dar√© aqu√≠ como un buen ejemplo. <br><br>  La prueba debe: <br><br><ul><li>  Genere un token JWT para iniciar sesi√≥n. <br></li><li>  Ejecute la funci√≥n de inicio de sesi√≥n. <br></li><li>  Aprobar el cambio de estado. <br></li></ul><br>  Fue as√≠: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGenerateJWTToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... $token $this-&gt;token = $token; } // @depends testGenerateJWTToken public function testExecuteAnAmazingFeature(): void { // Execute using $this-&gt;token } // @depends testExecuteAnAmazingFeature public function testStateIsBlah(): void { // Poll for state changes on // Logged-in interface }</span></span></code> </pre> <br>  Esto es malo por varias razones: <br><br><ul><li>  PHPUnit no puede garantizar este orden de ejecuci√≥n. <br></li><li>  Las pruebas deben poder ejecutarse de forma independiente. <br></li><li>  Las pruebas paralelas pueden fallar al azar. <br></li></ul><br>  La forma m√°s f√°cil de evitar esto es usar el esquema dado, cu√°ndo y luego.  Entonces, las pruebas ser√°n m√°s reflexivas, contar√°n una historia, demostrando claramente sus dependencias, explicando la funci√≥n que se est√° probando. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAmazingFeatureChangesState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $token = $this-&gt;givenImAuthenticated(); // When $this-&gt;whenIExecuteMyAmazingFeature( $token ); $newState = $this-&gt;pollStateFromInterface( $token ); // Then $this-&gt;assertEquals( 'my-state', $newState ); }</span></span></code> </pre> <br>  Tambi√©n necesitamos agregar pruebas para autenticaci√≥n, etc. Esta estructura es tan buena que <a href="https://behat.org/en/latest/quick_start.html">Behat se usa por defecto</a> . <br><br><h3>  4. Implemente siempre las dependencias. </h3><br>  <b>La raz√≥n principal</b> : un tono muy malo: para crear un trozo para el estado global.  La imposibilidad de crear ap√©ndices para dependencias no permite probar la funci√≥n. <br><br>  Consejo √∫til: <b>Olv√≠date de las clases con estado est√°tico y las instancias singleton</b> .  Si su clase depende de algo, h√°galo para que pueda implementarse. <br><br>  Aqu√≠ hay un triste ejemplo: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureToggle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Id $feature )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ $cookieName = $feature-&gt;getCookieName(); <span class="hljs-comment"><span class="hljs-comment">// Early return if cookie // override is present if (Cookies::exists( $cookieName )) { return Cookies::get( $cookieName ); } // Evaluate feature toggle... } }</span></span></code> </pre> <br>  ¬øC√≥mo puedo probar esta respuesta temprana? <br><br>  Eso es correcto  De ninguna manera <br><br>  Para probarlo, debemos comprender el comportamiento de la clase <code>Cookies</code> y asegurarnos de que podemos reproducir todo el entorno asociado con √©l, lo que da como resultado ciertas respuestas. <br><br>  No hagas esto. <br><br>  La situaci√≥n se puede corregir si implementa una instancia de <code>Cookies</code> como una dependencia.  La prueba se ver√° as√≠: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Test class... private Cookies $cookieMock; private FeatureToggle $service; // Preparing our service and dependencies public function setUp(): void { $this-&gt;cookieMock = $this-&gt;prophesize( Cookies::class ); $this-&gt;service = new FeatureToggle( $this-&gt;cookieMock-&gt;reveal() ); } public function testIsActiveIsOverriddenByCookies(): void { // Given $feature = $this-&gt;givenFeatureXExists(); // When $this-&gt;whenCookieOverridesFeatureWithTrue( $feature ); // Then $this-&gt;assertTrue( $this-&gt;service-&gt;isActive($feature) ); // additionally we can assert // no other methods were called } private function givenFeatureXExists(): Id { // ... return $feature; } private function whenCookieOverridesFeatureWithTrue( Id $feature ): void { $cookieName = $feature-&gt;getCookieName(); $this-&gt;cookieMock-&gt;exists($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); $this-&gt;cookieMock-&gt;get($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); }</span></span></code> </pre> <br>  Lo mismo ocurre con los singletones.  Entonces, si desea hacer que un objeto sea √∫nico, configure correctamente su inyector de dependencia, en lugar de usar el patr√≥n (anti) singleton.  De lo contrario, escribir√° m√©todos que son √∫tiles solo para casos como <code>reset()</code> o <code>setInstance()</code> .  En mi opini√≥n, esto es una locura. <br><br>  ¬°Es completamente normal cambiar la arquitectura para facilitar las pruebas!  Y crear m√©todos para facilitar las pruebas no es normal. <br><br><h3>  5. Nunca pruebe m√©todos protegidos / privados </h3><br>  <b>La raz√≥n principal</b> : afectan la forma en que probamos las funciones al determinar la firma del comportamiento: en esta condici√≥n, cuando ingreso A, espero obtener B. <b>Los m√©todos privados / protegidos no son parte de las firmas de funciones</b> . <br><br>  Ni siquiera quiero mostrar una forma de "probar" m√©todos privados, pero dar√© una pista: solo puedes hacerlo usando la API de <a href="https://www.php.net/manual/en/book.reflection.php">reflexi√≥n</a> . <br><br>  ¬°Siempre cast√≠gate de alguna manera cuando pienses en usar la reflexi√≥n para probar m√©todos privados!  Malo, mal desarrollador! <br><br>  Por definici√≥n, los m√©todos privados solo se llaman internamente.  Es decir, no est√°n disponibles p√∫blicamente.  Esto significa que solo los m√©todos p√∫blicos de la misma clase pueden llamar a dichos m√©todos. <br><br>  <b>Si prob√≥ todos sus m√©todos p√∫blicos, tambi√©n prob√≥ todos los m√©todos privados / protegidos</b> .  Si este no es el caso, elimine libremente los m√©todos privados / protegidos; nadie los usa de todos modos. <br><br><h2>  Consejos avanzados </h2><br>  Espero que a√∫n no est√©s aburrido.  A√∫n as√≠, tuve que hablar sobre lo b√°sico.  Ahora compartir√© mi opini√≥n sobre c√≥mo escribir pruebas y decisiones limpias que afecten mi proceso de desarrollo. <br><br>  Lo m√°s importante que no olvido al escribir pruebas: <br><br><ul><li>  Estudio. <br></li><li>  Comentarios r√°pidos <br></li><li>  Documentaci√≥n <br></li><li>  Refactorizaci√≥n <br></li><li>  Dise√±o durante las pruebas. <br></li></ul><br><h3>  1. Pruebas al principio, no al final </h3><br>  <b>Valores</b> : estudio, retroalimentaci√≥n r√°pida, documentaci√≥n, refactorizaci√≥n, dise√±o durante las pruebas. <br><br>  Esta es la base de todo.  El aspecto m√°s importante, que incluye todos los valores enumerados.  Cuando escribe pruebas por adelantado, esto le ayuda a comprender primero c√≥mo debe estructurarse el esquema "dado, cu√°ndo, entonces".  Al hacerlo, primero documenta y, lo que es m√°s importante, recuerda y establece sus requisitos como los aspectos m√°s importantes. <br><br>  ¬øEs extra√±o escuchar sobre escribir pruebas antes de la implementaci√≥n?  E imagine lo extra√±o que es implementar algo, y al probar para descubrir, todas sus expresiones "dado cu√°ndo, entonces" no tienen sentido. <br><br>  Adem√°s, este enfoque verificar√° sus expectativas cada dos segundos.  Obtiene comentarios lo m√°s r√°pido posible.  No importa cu√°n grande o peque√±a se vea la caracter√≠stica. <br><br>  Las pruebas ecol√≥gicas son un √°rea ideal para la refactorizaci√≥n.  La idea principal: sin pruebas, sin refactorizaci√≥n.  Refactorizar sin pruebas es simplemente peligroso. <br><br>  Finalmente, estableciendo la estructura "dado cu√°ndo, entonces", se volver√° obvio para usted qu√© interfaces deben tener sus m√©todos y c√≥mo deben comportarse.  Mantener la prueba limpia tambi√©n lo obligar√° a tomar constantemente decisiones arquitect√≥nicas diferentes.  Esto lo obligar√° a crear f√°bricas, interfaces, interrumpir la herencia, etc. ¬°Y s√≠, las pruebas ser√°n m√°s f√°ciles! <br><br>  Si sus pruebas son documentos en vivo que explican c√≥mo funciona la aplicaci√≥n, es imprescindible que lo dejen claro. <br><br><h3>  2. Mejor sin pruebas que con malas pruebas </h3><br>  <b>Valores</b> : estudio, documentaci√≥n, refactorizaci√≥n. <br><br>  Muchos desarrolladores piensan en las pruebas de esta manera: escribir√© una funci√≥n, conducir√© el marco de prueba hasta que las pruebas cubran un cierto n√∫mero de l√≠neas nuevas y las env√≠e a la operaci√≥n. <br><br>  Me parece que debe prestar m√°s atenci√≥n a la situaci√≥n cuando un nuevo desarrollador comienza a trabajar con esta funci√≥n.  <b>¬øQu√© le dir√°n las pruebas a esta persona?</b> <br><br>  Las pruebas a menudo son confusas si los nombres no son lo suficientemente detallados.  ¬øQu√© es m√°s claro: <code>testCanFly</code> o <code>testCanFlyReturnsFalseWhenPersonHasNoWings</code> ? <br><br>  Si sus pruebas son solo un c√≥digo desordenado que hace que el marco cubra m√°s l√≠neas, con ejemplos que no tienen sentido, entonces es hora de detenerse y pensar si escribir estas pruebas en absoluto. <br><br>  Incluso tonter√≠as como asignar <code>$a</code> y <code>$b</code> variables, o asignar nombres que no est√°n relacionados con un uso espec√≠fico. <br><br>  <b>Recuerde</b> : sus pruebas son documentos en vivo que intentan explicar c√≥mo debe comportarse su aplicaci√≥n.  <code>assertFalse($a-&gt;canFly())</code> no documenta mucho.  Y <code>assertFalse($personWithNoWings-&gt;canFly())</code> ya es bastante. <br><br><h3>  3. Ejecute pruebas intrusivamente </h3><br>  <b>Valores</b> : estudio, retroalimentaci√≥n r√°pida, refactorizaci√≥n. <br><br>  Antes de comenzar a trabajar en funciones, ejecute las pruebas.  Si fallan antes de que empiece a trabajar, lo sabr√° <i>antes de</i> escribir el c√≥digo, y no tendr√° que pasar unos minutos preciosos depurando pruebas rotas que ni siquiera le importaban. <br><br>  Despu√©s de guardar el archivo, ejecute las pruebas.  Cuanto antes descubra que algo se ha roto, m√°s r√°pido lo arreglar√° y seguir√° adelante.  Si la interrupci√≥n del flujo de trabajo para resolver un problema le parece improductivo, imagine que m√°s adelante tendr√° que retroceder muchos pasos si no conoce el problema. <br><br>  Despu√©s de conversar con colegas durante cinco minutos o verificar las notificaciones de Github, ejecute las pruebas.  Si se sonrojaron, entonces sabes d√≥nde lo dejaste.  Si las pruebas son verdes, puede continuar trabajando. <br>  Despu√©s de cualquier refactorizaci√≥n, incluso nombres de variables, ejecute las pruebas. <br><br>  En serio, ejecuta las malditas pruebas.  Tan a menudo como presiona el bot√≥n Guardar. <br>  <a href="https://github.com/spatie/phpunit-watcher">PHPUnit Watcher</a> puede hacer esto por usted e incluso enviar notificaciones. <br><br><h3>  4. Grandes pruebas: gran responsabilidad </h3><br>  <b>Valores</b> : estudio, refactorizaci√≥n, dise√±o durante las pruebas. <br><br>  Idealmente, cada clase deber√≠a tener una prueba.  Esta prueba debe abarcar todos los m√©todos p√∫blicos de esta clase, as√≠ como todas las expresiones condicionales o operadores de transici√≥n ... <br><br>  Puedes tomar algo como esto: <br><br><ul><li>  Una clase = un caso de prueba. <br></li><li>  Un m√©todo = una o m√°s pruebas. <br></li><li>  Una rama alternativa (if / switch / try-catch / exception) = una prueba. <br></li></ul><br>  Entonces, para este c√≥digo simple, necesitar√° cuatro pruebas: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// class Person public function eatSlice(Pizza $pizza): void { // test exception if ([] === $pizza-&gt;slices()) { throw new LogicException('...'); } // test exception if (true === $this-&gt;isFull()) { throw new LogicException('...'); } // test default path (slices = 1) $slices = 1; // test alternative path (slices = 2) if (true === $this-&gt;isVeryHungry()) { $slices = 2; } $pizza-&gt;removeSlices($slices); }</span></span></code> </pre> <br>  Cuantos m√°s m√©todos p√∫blicos tenga, m√°s pruebas se necesitar√°n. <br><br>  A nadie le gusta leer documentaci√≥n larga.  Dado que sus pruebas tambi√©n son documentos, el tama√±o peque√±o y la importancia solo aumentar√°n su calidad y utilidad. <br><br>  Tambi√©n es una se√±al importante de que su clase est√° acumulando responsabilidad y es hora de refactorizarla transfiriendo una serie de funciones a otras clases o redise√±ando el sistema. <br><br><h3>  5. Apoyar un conjunto de pruebas para resolver problemas de regresi√≥n </h3><br>  <b>Valores</b> : estudio, documentaci√≥n, retroalimentaci√≥n r√°pida. <br><br>  Considere la funci√≥n: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromDb((int) $id); }</code> </pre> <br>  Usted piensa que alguien est√° transmitiendo "10", pero en realidad se est√° transmitiendo "10 pl√°tanos".  Es decir, vienen dos valores, pero uno es superfluo.  Tienes un error <br><br>  ¬øQu√© vas a hacer primero?  ¬°Escribe una prueba que marcar√° ese comportamiento como err√≥neo! <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByIdAcceptsOnlyNumericIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(InvalidArgumentException::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectExceptionMessage( <span class="hljs-string"><span class="hljs-string">'Only numeric IDs are allowed.'</span></span> ); findById(<span class="hljs-string"><span class="hljs-string">"10 bananas"</span></span>); }</code> </pre> <br>  Por supuesto, las pruebas no transmiten nada.  Pero ahora sabes lo que hay que hacer para que transmitan.  Corrija el error, haga las pruebas verdes, implemente la aplicaci√≥n y sea feliz. <br><br>  Mantenga esta prueba con usted.  Siempre que sea posible, en un conjunto de pruebas dise√±adas para resolver problemas de regresi√≥n. <br><br>  Eso es todo!  Comentarios r√°pidos, correcciones de errores, documentaci√≥n, c√≥digo resistente a la regresi√≥n y felicidad. <br><br><h2>  Palabra final </h2><br>  Gran parte de lo anterior es solo mi opini√≥n personal, desarrollada durante mi carrera.  Esto no significa que el consejo sea verdadero o falso, es solo una opini√≥n. </div></div><p>Source: <a href="https://habr.com/ru/post/485124/">https://habr.com/ru/post/485124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485108/index.html">Estad√≠sticas de especialistas certificados de PMI en Rusia el 10/01/2020</a></li>
<li><a href="../485110/index.html">Mi experiencia de trabajo remoto efectivo</a></li>
<li><a href="../485118/index.html">C√≥digo limpio de Robert Martin. Resumen ¬øC√≥mo escribir un c√≥digo claro y hermoso?</a></li>
<li><a href="../485120/index.html">Agregue una API JSON muy r√°pida a nuestra aplicaci√≥n.</a></li>
<li><a href="../485122/index.html">El t√≠tulo "Leer art√≠culos para usted". Octubre - diciembre 2019</a></li>
<li><a href="../485126/index.html">Mu-mu, woof-woof, quack-quack: evoluci√≥n de la comunicaci√≥n ac√∫stica</a></li>
<li><a href="../485128/index.html">Ahorre en licencias Mikrotik CHR</a></li>
<li><a href="../485132/index.html">√önete al Festival de juegos independientes de Google Play</a></li>
<li><a href="../485136/index.html">Rastreo y monitoreo de Istio: microservicios y el principio de incertidumbre</a></li>
<li><a href="../485138/index.html">Localizaci√≥n de aplicaciones: c√≥mo hicimos amigos traducci√≥n y desarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>