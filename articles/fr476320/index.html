<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍💼 👨🏼‍🏭 👩🏻‍🤝‍👨🏾 Gestion d'équipes en cours de livraison d'une nouvelle version d'application à Kubernetes 🌽 🚣🏿 😛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans notre pratique, nous sommes souvent confrontés à la tâche d'adapter les applications clientes pour qu'elles s'exécutent sur Kubernetes. Lors de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion d'équipes en cours de livraison d'une nouvelle version d'application à Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476320/"><img src="https://habrastorage.org/webt/bl/a1/wq/bla1wqhxnafiftfwcg0s3vsyvxe.png"><br><br>  Dans notre pratique, nous sommes souvent confrontés à la tâche d'adapter les applications clientes pour qu'elles s'exécutent sur Kubernetes.  Lors de la réalisation de ces travaux, un certain nombre de problèmes typiques se posent.  Nous avons récemment couvert l'un d'eux dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fichiers locaux lors du transfert d'une application vers Kubernetes</a> , et l'autre, déjà connecté aux processus CI / CD, sera décrit dans cet article. <br><br><h2>  Commandes arbitraires avec Helm et werf </h2><br>  Une application n'est pas seulement une logique métier et des données, mais également un ensemble de commandes arbitraires qui doivent être exécutées pour une mise à jour réussie.  Il peut s'agir, par exemple, de migrations de bases de données, de «serveurs» pour la disponibilité de ressources externes, de certains transcodeurs ou décompresseurs, de bureaux d'enregistrement dans la découverte de services externe - vous pouvez effectuer différentes tâches sur différents projets. <br><br>  Que propose Kubernetes pour résoudre ces problèmes? <a name="habracut"></a>  Kubernetes est bon pour exécuter des conteneurs en tant que pods, la solution standard consiste donc à exécuter une commande à partir d'une image.  Pour cela, Kubernetes a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>primitive de travail</b></a> qui vous permet d'exécuter le pod avec des conteneurs d'application et surveille l'achèvement de ce pod. <br><br>  <b>Helm</b> va un peu plus loin et suggère de lancer Job à différentes étapes du processus de déploiement.  Nous parlons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hooks Helm</a> avec lesquels vous pouvez exécuter Job avant ou après la mise à jour des manifestes de ressources.  D'après notre expérience, il s'agit d'une excellente fonctionnalité de Helm qui peut être utilisée pour résoudre des tâches de déploiement. <br><br>  Cependant, il est impossible d'obtenir des informations à jour sur l'état des objets lors du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>déploiement</b></a> dans Helm, nous utilisons donc l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>werf</b></a> , qui permet de surveiller l'état des ressources pendant le déploiement directement à partir du système CI et, en cas d'échec, de diagnostiquer rapidement une panne. <br><br>  Il s'est avéré que ces fonctionnalités utiles Helm et werf sont parfois mutuellement exclusives, mais il y a toujours une issue.  Examinez comment vous pouvez surveiller l'état des ressources et exécuter des commandes arbitraires sur l'exemple des migrations. <cut></cut><br><br><h2>  Exécution des migrations avant la publication </h2><br>  La mise à jour du schéma de données fait partie intégrante de la sortie de toute application de base de données.  Le déploiement standard pour les applications qui appliquent des migrations en exécutant une commande distincte implique les étapes suivantes: <br><br><ol><li>  mise à jour de la base de code; </li><li>  début de la migration; </li><li>  basculer le trafic vers la nouvelle version de l'application. </li></ol><br>  Au sein de Kubernetes, le processus devrait être le même, mais adapté à nos besoins: <br><br><ol><li>  lancer un conteneur avec un nouveau code, qui peut contenir un nouvel ensemble de migrations; </li><li>  démarrer le processus d'application des migrations, après avoir fait cela avant de mettre à jour la version de l'application. </li></ol><br>  Envisagez l'option lorsque <b>la base de données de l'application est déjà en cours d'exécution</b> et que nous n'avons pas besoin de la déployer dans le cadre de la version qui déploie l'application.  Deux crochets conviennent pour appliquer les migrations: <br><br><ul><li>  <code>pre-install</code> - cela fonctionne sur la première version Helm de l'application après avoir traité tous les modèles, mais avant de créer des ressources dans Kubernetes; </li><li>  <code>pre-upgrade</code> - fonctionne lors de la mise à jour de la version Helm et s'exécute, comme la <code>pre-install</code> , après le traitement des modèles, mais avant de créer des ressources dans Kubernetes. </li></ul><br>  Exemple de travail utilisant Helm et les deux crochets mentionnés: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ .Chart.Name }}-apply-migrations annotations: "helm.sh/hook": pre-install,pre-upgrade spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ .Chart.Name }}-apply-migrations spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>Remarque</b> : le modèle YAML ci-dessus a été créé en tenant compte des spécificités de werf.</i>  <i>Pour l'adapter à un Casque "propre", il suffit:</i> <br><br><ul><li>  <i>remplacer <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> vers l'image de conteneur dont vous avez besoin;</i> </li><li>  <i>supprimez la ligne <code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code> , qui est spécifié dans la clé <code>env</code> .</i> </li></ul><br>  Ainsi, ce modèle Helm devra être ajouté au <code>.helm/templates</code> , qui contient déjà le reste des ressources de publication.  Lorsque <code>werf deploy --stages-storage :local</code> appelé, tous les modèles seront traités en premier, puis ils seront chargés dans le cluster Kubernetes. <br><br><h2>  Démarrage des migrations pendant le processus de publication </h2><br>  L'option ci-dessus implique l'utilisation de migrations pour le cas où la base de données est déjà en cours d'exécution.  Mais que se passe-t-il si nous devons déployer la revue de branche pour l'application et que la <b>base de données est déployée avec l'application</b> en une seule version? <br><br>  <i><b>NB</b> : Vous pouvez rencontrer un problème similaire lors du déploiement dans l'environnement de production si vous utilisez Service avec un point de terminaison qui contient l'adresse IP de la base de données pour se connecter à la base de données.</i> <br><br>  Dans ce cas, les crochets de <code>pre-install</code> et de <code>pre-upgrade</code> ne nous conviennent pas, car l'application essaiera d'appliquer des migrations à la base de données qui <i>n'existe pas encore</i> .  Ainsi, il est nécessaire d'effectuer des migrations <i>après</i> la sortie. <br><br>  Lorsque vous utilisez Helm, une telle tâche est réalisable, car elle <i>ne surveille pas l'</i> état des applications.  Après le chargement des ressources dans Kubernetes, les hooks de publication se déclenchent <i>toujours</i> : <br><br><ul><li>  <code>post-install</code> - après le chargement de toutes les ressources dans K8 à la première version; </li><li>  <code>post-upgrade</code> - après la mise à jour de toutes les ressources dans K8 lors de la mise à jour de la version. </li></ul><br>  Cependant, comme nous l'avons mentionné ci-dessus, <b>werf dispose d'un système de suivi des ressources</b> lors de la sortie.  Je m'attarderai un peu plus sur ce point: <br><br><ul><li>  Pour le suivi, werf utilise les capacités de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">kubedog</a> , dont nous avons déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé</a> dans le blog. </li><li>  Cette fonctionnalité de werf nous permet de déterminer de manière unique l'état de la publication et d'afficher des informations sur la réussite ou l'échec du déploiement dans l'interface du système CI / CD. </li><li>  Sans recevoir ces informations, on ne peut parler d'aucune automatisation du processus de publication, car la création réussie de ressources dans le cluster Kubernetes n'est qu'une des étapes.  Par exemple, l'application peut ne pas démarrer en raison d'une configuration incorrecte ou d'un problème de réseau, mais pour voir cela après la <code>helm upgrade</code> , vous devrez effectuer des étapes supplémentaires. </li></ul><br>  Revenons maintenant à l'application des migrations sur les post-hooks de Helm.  Les problèmes rencontrés: <br><br><ul><li>  De nombreuses applications avant de lancer d'une manière ou d'une autre vérifient l'état du circuit dans la base de données.  Par conséquent, sans nouvelles migrations, l'application peut ne pas démarrer. </li><li>  Étant donné que werf, par défaut, garantit que tous les objets sont à l'état <code>Ready</code> , les hooks de publication ne fonctionneront pas et les migrations échoueront. </li><li>  Les objets de suivi peuvent être désactivés via des annotations supplémentaires, mais il est alors impossible d'obtenir des informations fiables sur les résultats du déploiement. </li></ul><br>  En conséquence, nous sommes arrivés à ce qui suit: <br><br><ul><li>  Les travaux sont créés avant les ressources principales, <b>il n'est donc pas nécessaire d'utiliser des crochets Helm pour les migrations</b> . </li><li>  Cependant, un travail avec migrations doit être exécuté sur chaque déploiement.  Pour que cela se produise, <b>Job doit avoir un nom unique</b> (aléatoire): dans ce cas, pour Helm, c'est à chaque fois un nouvel objet dans la version, qui sera créé dans Kubernetes. </li><li>  Avec un tel lancement, cela n'a aucun sens de craindre que Job s'accumule avec les migrations, car tous auront des noms uniques et le Job précédent est supprimé avec une nouvelle version. </li><li>  <b>Un travail avec des migrations doit avoir un conteneur init</b> qui vérifie la disponibilité de la base de données - sinon nous obtenons un déploiement abandonné (le travail tombera sur le conteneur init). </li></ul><br>  La configuration résultante ressemble à ceci: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>NB</b> : à strictement parler, les conteneurs init pour vérifier la disponibilité de la base de données sont de toute façon mieux utilisés.</i> <br><br><h2>  Un exemple de modèle universel pour toutes les opérations de déploiement </h2><br>  Cependant, les opérations qui doivent être effectuées pendant la version peuvent être plus que le lancement des migrations déjà mentionnées.  Vous pouvez contrôler l'ordre d'exécution de Job non seulement via les types de crochets, mais également en <b>attribuant un poids à chacun d'eux</b> - via l'annotation <code>helm.sh/hook-weight</code> .  Les crochets sont triés par poids dans l'ordre croissant et, si le poids est le même, par nom de ressource. <br><br>  Avec un grand nombre de tâches, il est pratique de créer un modèle universel pour les <code>values.yaml</code> et de placer la configuration dans <code>values.yaml</code> .  Ce dernier peut ressembler à ceci: <br><br><pre> <code class="plaintext hljs">deploy_jobs: - name: migrate command: '["/usr/bin/php7.2", "artisan", "migrate", "--force"]' activeDeadlineSeconds: 120 when: production: 'pre-install,pre-upgrade' staging: 'pre-install,pre-upgrade' _default: '' - name: cache-clear command: '["/usr/bin/php7.2", "artisan", "responsecache:clear"]' activeDeadlineSeconds: 60 when: _default: 'post-install,post-upgrade'</code> </pre> <br>  ... et le modèle lui-même est comme ceci: <br><br><pre> <code class="plaintext hljs">{{- range $index, $job := .Values.deploy_jobs }} --- apiVersion: batch/v1 kind: Job metadata: name: {{ $.Chart.Name }}-{{ $job.name }} annotations: "helm.sh/hook": {{ pluck $.Values.global.env $job.when | first | default $job.when._default }} "helm.sh/hook-weight": "1{{ $index }}" spec: activeDeadlineSeconds: {{ $job.activeDeadlineSeconds }} backoffLimit: 0 template: metadata: name: {{ $.Chart.Name }}-{{ $job.name }} spec: imagePullSecrets: - name: {{ required "$.Values.registry.secret_name required" $.Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: {{ $job.command }} {{ tuple "backend" $ | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" $ | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never {{- end }}</code> </pre> <br>  Cette approche vous permet d'ajouter rapidement de nouvelles commandes au processus de publication et rend la liste des commandes exécutables plus visuelle. <br><br><h2>  Conclusion </h2><br>  L'article fournit des exemples de modèles qui vous permettent de décrire les opérations courantes que vous devez effectuer lors du lancement d'une nouvelle version de l'application.  Bien qu'ils soient le résultat de l'expérience dans la mise en œuvre de processus CI / CD dans des dizaines de projets, nous n'insistons pas sur le fait qu'il n'y a qu'une seule bonne solution pour toutes les tâches.  Si les exemples décrits dans l'article ne couvrent pas les besoins de votre projet, nous serons heureux de voir des situations dans les commentaires qui pourraient aider à compléter ce matériel. <br><br>  Commentaire des développeurs de werf: <br><blockquote>  <i>À l'avenir, werf prévoit d'introduire des étapes de déploiement des ressources configurables par l'utilisateur.</i>  <i>À l'aide de telles étapes, il sera possible de décrire les deux cas et pas seulement.</i> </blockquote><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de werf pour déployer des graphiques Helm complexes</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Assemblage et déploiement du même type de microservices avec werf et GitLab CI</a> "; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusion à 3 voies dans werf: déploiement dans Kubernetes avec Helm« sous stéroïdes »</a> »; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trucs et astuces Kubernetes: accélérer le bootstrap des grandes bases de données.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476320/">https://habr.com/ru/post/fr476320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476308/index.html">Les 5 meilleures pratiques de développement logiciel à suivre en 2020</a></li>
<li><a href="../fr476310/index.html">CRM visage humain</a></li>
<li><a href="../fr476312/index.html">React ou Angular ou Vue.js - que choisir?</a></li>
<li><a href="../fr476316/index.html">Vue Storefront: Remplissez les données dans ES</a></li>
<li><a href="../fr476318/index.html">Nous attaquons complètement Joker 2019: comment s'est passée la plus grande conférence Java en Russie</a></li>
<li><a href="../fr476322/index.html">Schémas de distribution clés avec un centre de confiance: Schémas Giraud et Bloma</a></li>
<li><a href="../fr476324/index.html">Sommaire d'octobre sur la gestion des produits</a></li>
<li><a href="../fr476328/index.html">Starlink est une grosse affaire</a></li>
<li><a href="../fr476330/index.html">Pourquoi ai-je quitté Saint-Pétersbourg pour Penza</a></li>
<li><a href="../fr476332/index.html">Améliorer l'informatique quantique avec l'apprentissage automatique classique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>