<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 🔀 🔶 Wie man baut und baut 🕧 🍟 🧗🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 


 Nachdem wir uns an zahlreichen Stellen in der Javascript-Entwicklung mit Situationen getroffen hatten, in denen es notwendig war, Wert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man baut und baut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya">  Hintergrund </h2><br><p>  Nachdem wir uns an zahlreichen Stellen in der Javascript-Entwicklung mit Situationen getroffen hatten, in denen es notwendig war, Werte zu validieren, wurde klar, dass es notwendig war, dieses Problem irgendwie zu lösen.  Zu diesem Zweck wurde folgende Aufgabe gestellt: <br>  Entwickeln Sie eine Bibliothek, die Folgendes ermöglicht: </p><br><ul><li>  <strong>Datentypen</strong> validieren; </li><li>  <strong>Standardwerte</strong> anstelle ungültiger Felder oder Elemente <strong>festlegen</strong> ; </li><li>  <strong>ungültige Teile eines</strong> Objekts oder Arrays <strong>löschen</strong> ; </li><li>  Erhalten Sie <strong>eine Fehlermeldung</strong> </li></ul><br><p>  Die Basis davon wird sein: </p><br><ul><li>  Leicht zu lernen </li><li>  Lesbarkeit des empfangenen Codes. </li><li>  Einfache Codeänderung </li></ul><br><p>  Um diese Ziele zu erreichen, wurde eine Validierungsbibliothek für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Quartett">Quartette</a> entwickelt. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Grundlegende Validierungsbausteine </h2><br><p>  Das Herzstück der meisten Systeme, die für eine Vielzahl von Aufgaben ausgelegt sind, sind die einfachsten <strong>Elemente</strong> : Aktionen, Daten und Algorithmen.  Sowie Methoden ihrer <strong>Zusammensetzung</strong> - um aus einfachen Elementen etwas Komplizierteres zusammenzusetzen, um komplexere Probleme zu lösen. </p><br><h3 id="validator">  Validator </h3><br><p> Die Quartettbibliothek basiert auf dem Konzept eines <strong>Validators</strong> .  Die Validatoren in dieser Bibliothek sind Funktionen der folgenden Form </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  In dieser Definition gibt es mehrere Dinge, die genauer beschrieben werden sollten: </p><br><p>  <strong><code>function(...): boolean</code></strong> Wert - sagt, dass der Validator - das Ergebnis der Validierung berechnet und das Ergebnis der Validierung ein boolescher Wert ist - <strong>wahr</strong> oder <strong>falsch</strong> , jeweils <strong>gültig</strong> oder <strong>ungültig</strong> </p><br><p>  <strong><code>value: any</code></strong> - gibt an, dass der Validator - das Ergebnis der Validierung eines <strong>Werts berechnet</strong> , bei dem es sich um einen beliebigen Javascript-Wert handeln kann.  Der Validator weist den <strong>validierten Wert</strong> entweder gültig oder ungültig zu. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - gibt an, dass sich der validierte Wert in verschiedenen Kontexten befinden kann, je nachdem, auf welcher Verschachtelungsebene der Wert liegt.  Lassen Sie es uns anhand von Beispielen zeigen </p><br><p>  Beispielwert <strong>ohne Kontext</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Beispielwert <b>in einem Array-Kontext</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Beispielwert <b>im Kontext eines Objekts</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  Da Strukturen in einem Objekt eine größere Verschachtelung aufweisen können, ist es sinnvoll, über eine <b>Vielzahl von Kontexten</b> zu sprechen </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  Usw. </p><br><div class="spoiler">  <b class="spoiler_title">Über die Ähnlichkeit mit Array-Methoden</b> <div class="spoiler_text"><p>  Diese Definition eines Validators sollte Sie an die Definition von Funktionen erinnern, die als Argument an Array-Methoden übergeben werden, z. B.: <strong>Map, Filter, einige, alle</strong> usw. </p><br><ul><li>  Das erste Argument für diese Funktionen ist <strong>ein Array-Element.</strong> </li><li>  Das zweite Argument ist der <strong>Index des Elements.</strong> </li><li>  Das dritte Argument ist <strong>das Array selbst.</strong> </li></ul><br><p>  Der Validator ist in diesem Fall eine allgemeinere Funktion - er verwendet nicht nur den Index des Elements im Array und des Arrays, sondern auch den Index des Arrays - in seinem übergeordneten und seinem übergeordneten Element und so weiter. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  Was sollen wir ein Haus bauen? </h3><br><p>  Die oben beschriebenen Steine ​​heben sich nicht von anderen <em>"Steinlösungen" ab</em> , die am <em>"Strand"</em> der Javascript-Krücke liegen.  Lassen Sie uns deshalb etwas Kohärenteres und Interessanteres daraus machen.  Dafür haben wir eine <strong>Komposition</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  Wie baue ich einen Wolkenkratzer für die Objektvalidierung? </h3><br><p>  Stimmen Sie zu, es wäre zweckmäßig, Objekte so zu validieren, dass die Beschreibung der Validierung mit der Beschreibung des Objekts übereinstimmt.  Hierfür verwenden wir die <strong>Objektzusammensetzung von Validatoren</strong> .  Es sieht so aus: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  Wie Sie sehen können, können wir aus verschiedenen für bestimmte Felder definierten Validierungsbausteinen einen Objektvalidator zusammenstellen - ein "kleines Gebäude", das immer noch ziemlich überfüllt ist - aber besser als ohne.  Dazu verwenden wir den Composer of Validators <code>v</code> .  <strong>Jedes Mal, wenn das Objektliteral <code>v</code> anstelle des Validators erfüllt wird, wird es als Objektzusammensetzung betrachtet und in seinen Feldern in einen Objektvalidator umgewandelt.</strong> </p><br><p>  Manchmal können wir <strong>nicht alle Felder beschreiben</strong> .  Wenn ein Objekt beispielsweise ein Datenwörterbuch ist: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  Wie kann man Baulösungen wiederverwenden? </h3><br><p>  Wie wir oben gesehen haben, müssen einfache Validatoren wiederverwendet werden.  In diesen Beispielen mussten wir den "String Type Validator" bereits zweimal verwenden. </p><br><p>  Um den Datensatz zu verkürzen und seine Lesbarkeit zu verbessern, verwendet die Quartettbibliothek Stringsynonyme von Validatoren.  <strong>Immer wenn ein Validator-Komponist an der Stelle, an der sich der Validator befinden sollte, auf eine Zeichenfolge stößt, durchsucht er das Wörterbuch nach seinem Validator und verwendet ihn</strong> . </p><br><p>  Standardmäßig sind die gängigsten Validatoren bereits in der Bibliothek definiert. </p><br><p>  Betrachten Sie die folgenden Beispiele: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  und viele andere in der <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Dokumentation">Dokumentation beschrieben</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Jeder Bogen hat seine eigene Art von Ziegeln? </h3><br><p>  Der Validator Composer (Funktion <code>v</code> ) ist ebenfalls eine Validator Factory.  In dem Sinne, dass es viele nützliche Methoden enthält, die zurückkehren </p><br><ul><li>  Funktionsprüfer </li><li>  Werte, die der Komponist als Schemata zum Erstellen von Validatoren wahrnimmt </li></ul><br><p>  Schauen wir uns zum Beispiel die Array-Validierung an: Meistens besteht sie darin, den Typ des Arrays und alle seine Elemente zu überprüfen.  Wir werden hierfür die Methode <code>v.arrayOf(elementValidator)</code> verwenden.  Nehmen Sie zum Beispiel ein Array von Punkten mit Namen. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Da ein Array von Punkten ein Array von Objekten ist, ist es sinnvoll, die Objektzusammensetzung zu verwenden, um die Elemente des Arrays zu validieren. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p>  Erstellen Sie nun mit der Factory-Methode <code>v.arrayOf</code> einen Validator für das gesamte Array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Mal sehen, wie dieser Validator funktioniert: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  Dies ist nur eine der Factory-Methoden, von denen jede in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Dokumentation">Dokumentation beschrieben ist.</a> </p><br><p>  Wie Sie oben gesehen haben, ist <code>v.rest</code> auch eine Factory-Methode, die eine Objektzusammensetzung zurückgibt, die alle Felder überprüft, die nicht in der Objektzusammensetzung angegeben sind.  Das heißt, es kann mit dem <code>spread-operator</code> in eine andere Objektzusammensetzung eingebettet <code>spread-operator</code> . </p><br><p>  Nennen wir als Beispiel die Verwendung mehrerer von ihnen: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  Sein oder Nichtsein? </h3><br><p>  Es kommt häufig vor, dass gültige Daten verschiedene Formen annehmen, zum Beispiel: </p><br><ul><li>  <code>id</code> kann eine Zahl oder eine Zeichenfolge sein. </li><li>  Das Punktobjekt kann je nach Dimension einige Koordinaten enthalten oder nicht. </li><li>  Und viele andere Fälle. </li></ul><br><p>  Um die Validierung von Varianten zu organisieren, wird ein separater Kompositionstyp bereitgestellt - Variantenkomposition.  Es wird durch eine Reihe von Validatoren möglicher Optionen dargestellt.  Ein Objekt gilt als gültig, wenn mindestens einer der Validatoren seine Gültigkeit meldet. </p><br><p>  Betrachten Sie ein Beispiel mit der Bezeichnervalidierung: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Beispiel für die Punktvalidierung: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  <strong>Wenn ein Komponist ein Array sieht, betrachtet er es als eine Zusammensetzung der Validatorelemente dieses Arrays, sodass die Berechnung der Validierung stoppt und der Wert als gültig erkannt wird, wenn einer von ihnen den Wert für gültig hält.</strong> </p><br><p>  Wie wir sehen, betrachtet der Komponist nicht nur die Validatorfunktion als Validator, sondern auch alles, was zu einer Validatorfunktion führen kann. </p><br><table><thead><tr><th>  Validatortyp </th><th>  Beispiel </th><th>  Wie vom Komponisten wahrgenommen </th></tr></thead><tbody><tr><td>  Validierungsfunktion </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  habe gerade die notwendigen Werte aufgerufen </td></tr><tr><td>  Objektzusammensetzung </td><td> <code>{ a: 'number' }</code> </td> <td>  Erstellt eine Validierungsfunktion für ein Objekt basierend auf den angegebenen Feldvalidatoren </td></tr><tr><td>  Variantenzusammensetzung </td><td> <code>['number', 'string']</code> </td> <td>  Erstellt eine Validierungsfunktion, um einen Wert mit mindestens einer der Optionen zu validieren </td></tr><tr><td>  Factory Method Call-Ergebnisse </td><td> <code>v.enum('male', 'female')</code> </td> <td>  Die meisten Factory-Methoden geben Validierungsfunktionen zurück (mit Ausnahme von <code>v.rest</code> , das die Objektzusammensetzung zurückgibt), sodass sie wie reguläre Validierungsfunktionen behandelt werden </td></tr></tbody></table><br><p>  Alle diese Validatoroptionen sind gültig und können überall im Schema verwendet werden, wo sich der Validator befinden sollte. </p><br><p>  Infolgedessen sieht das Arbeitsschema immer so aus: <code>v(schema)</code> gibt eine Validierungsfunktion zurück.  Als nächstes wird diese Validierungsfunktion für bestimmte Werte aufgerufen: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Haben Sie auf der Baustelle Unfälle gehabt? </h2><br><p>  <em>- Noch nicht, keiner</em> <br>  <em>- Sie werden!</em> </p><br><p>  Es kommt vor, dass die Daten ungültig sind und wir in der Lage sein müssen, die Ursache für die Ungültigkeit zu ermitteln. </p><br><p>  Hierfür bietet die Quartettbibliothek einen <em>Erklärungsmechanismus</em> .  Es besteht darin, dass der Validator, ob intern oder extern, die Gültigkeit der verifizierten Daten <em>feststellt</em> , eine <em>Erläuterung</em> senden muss. </p><br><p>  Für diese Zwecke wird das zweite Argument des Komponisten der Validatoren <code>v</code> .  Es fügt den Nebeneffekt hinzu, dass bei ungültigen Daten eine <em>Erläuterung</em> an das Array <code>v.explanation</code> . </p><br><p>  Lassen Sie uns beispielsweise ein Array validieren und die Anzahl aller ungültigen Elemente und ihren Wert herausfinden: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  Wie Sie sehen können, hängt die Wahl der Erklärung von der Aufgabe ab.  Manchmal ist es gar nicht nötig. </p><br><p>  Manchmal müssen wir etwas mit ungültigen Feldern tun.  In solchen Fällen ist es sinnvoll, den Namen des ungültigen Feldes als <em>Erklärung zu verwenden</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  Mit diesem Erklärungsmechanismus können Sie jedes Verhalten implementieren, das mit den Validierungsergebnissen verbunden ist. </p><br><p>  Eine Erklärung kann alles sein: </p><br><ul><li>  ein Objekt, das die erforderlichen Informationen enthält; </li><li>  Funktion, die den Fehler korrigiert.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  Name des ungültigen Feldes oder Index des ungültigen Elements; </li><li>  Fehlercode </li><li>  und das alles reicht für deine Fantasie. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  Was tun, wenn keine Dinge gebaut werden? </h2><br><p>  Das Korrigieren von Validierungsfehlern ist keine seltene Aufgabe.  Zu diesem Zweck verwendet die Bibliothek Validatoren mit einem Nebeneffekt, der sich an den Ort des Fehlers und dessen Behebung erinnert. </p><br><ul><li>  <code>v.default(validator, value)</code> - <code>v.default(validator, value)</code> einen Validator zurück, der sich an einen ungültigen Wert erinnert, und legt zum Zeitpunkt des Aufrufs von <code>v.fix</code> den Standardwert fest </li><li>  <code>v.filter(validator)</code> - <code>v.filter(validator)</code> einen Validator zurück, der sich an einen ungültigen Wert erinnert, und entfernt diesen Wert zum Zeitpunkt des Aufrufs von <code>v.fix</code> vom übergeordneten Wert </li><li>  <code>v.addFix(validator, fixFunc)</code> - gibt einen Validator zurück, der sich an einen ungültigen Wert erinnert, und ruft zum Zeitpunkt des Aufrufs von <code>v.fix</code> fixFunc mit Parametern (value, {key, parent}, ...) auf.  <code>fixFunc</code> - muss einen der Partner mutieren - um den Wert zu ändern </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  Aufgaben sind immer noch nützlich </h3><br><p>  In dieser Bibliothek gibt es auch Dienstprogrammmethoden für Validierungsaktionen: </p><br><table><thead><tr><th>  Methode </th><th>  Ergebnis </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  Wenn ungültig, wird ein TypeError mit der angegebenen Nachricht ausgelöst. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Gibt ein neues Array (oder Wörterbuchobjekt) ohne ungültige Elemente (Felder) zurück. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Gibt ein neues Objekt ohne ungültige Felder gemäß dem angegebenen Objektvalidator zurück. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Gibt den Wert zurück, wenn er gültig ist, andernfalls wird er durch den angegebenen Standardwert ersetzt. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>v.example</code></a> </td> <td>  Überprüft, ob die angegebenen Werte zum Schema passen.  Wenn sie nicht passen, wird ein Fehler ausgegeben.  Dient als Dokumentation und Schaltungstest </td></tr></tbody></table><br><h2 id="rezultaty">  Ergebnisse </h2><br><p>  Die Aufgaben wurden folgendermaßen gelöst: </p><br><table><thead><tr><th>  Herausforderung </th><th>  Lösung </th></tr></thead><tbody><tr><td>  Datentypüberprüfung </td><td>  Standardmäßig benannte Validatoren. </td></tr><tr><td>  Standardwerte </td><td> <code>v.default</code> </td> </tr><tr><td>  Ungültige Teile entfernen </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> und <code>v.omitInvalidProps</code> . </td></tr><tr><td>  Leicht zu lernen </td><td>  Einfache Validatoren, einfache Möglichkeiten, sie zu komplexen Validatoren zusammenzusetzen. </td></tr><tr><td>  Lesbarkeit des Codes </td><td>  Eines der Ziele der Bibliothek war es, die Validierungsschemata selbst zu vergleichen </td></tr><tr><td>  validierte Objekte. </td></tr><tr><td>  Einfache Änderung </td><td>  Wenn Sie die Elemente von Kompositionen beherrschen und Ihre eigenen Validierungsfunktionen verwenden, ist das Ändern des Codes ganz einfach. </td></tr><tr><td>  Fehlermeldung </td><td>  Erläuterung in Form einer Fehlermeldung.  Oder Fehlercodeberechnung basierend auf Erklärungen. </td></tr></tbody></table><br><h2 id="posleslovie">  Nachwort </h2><br><p>  Diese Lösung wurde entwickelt, um schnell und bequem Validierungsfunktionen mit der Möglichkeit zu erstellen, benutzerdefinierte Validierungsfunktionen einzubetten.  Daher sind Korrekturen, Kritik und Verbesserungsmöglichkeiten von Personen, die diesen Artikel lesen, willkommen.  Vielen Dank für Ihre Aufmerksamkeit. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429916/">https://habr.com/ru/post/de429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429904/index.html">Lustige und traurige Geschichten über die Entwicklung von Computerspielen</a></li>
<li><a href="../de429908/index.html">Wie man Coroutinen in Lebensmitteln verwendet und nachts ruhig schläft</a></li>
<li><a href="../de429910/index.html">AppsConf steigt</a></li>
<li><a href="../de429912/index.html">Bibliotheksentwicklung: von der API bis zur Veröffentlichung</a></li>
<li><a href="../de429914/index.html">OpenSceneGraph: Szenendiagramm und intelligente Zeiger</a></li>
<li><a href="../de429918/index.html">Virtuelle Welt Intel. Teil 2: SMP</a></li>
<li><a href="../de429920/index.html">Tragikomödie in NaN-Acts: Wie wir ein Spiel auf JS gemacht und auf Steam veröffentlicht haben</a></li>
<li><a href="../de429922/index.html">Wie man aus einem einfachen Projekt eine langfristige Konstruktion macht oder alles Unnötige abschneidet</a></li>
<li><a href="../de429928/index.html">Alles, was Sie über Stress und starke Emotionen wissen müssen</a></li>
<li><a href="../de429930/index.html">Splunk Einfache Fehlerbehebung bei Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>