<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗑️ 🈲 🕵🏽 Tanya Jawab JavaScript 🧑🏽‍🤝‍🧑🏼 👧🏿 🐭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, SmartSpate memutuskan untuk mengumpulkan pertanyaan tentang JavaScript dan menjawabnya. Materi, terjemahan yang kami terbitkan, berisi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tanya Jawab JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/436454/">  Baru-baru ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SmartSpate</a> memutuskan untuk mengumpulkan pertanyaan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript</a> dan menjawabnya.  Materi, terjemahan yang kami terbitkan, berisi lebih dari dua lusin pertanyaan tentang JavaScript dan jawabannya.  Rentang topik yang dibahas di sini cukup luas.  Secara khusus, ini adalah fitur bahasa, masalah yang dihadapi oleh programmer saat menulis kode JS, bekerja di browser dan di Node.js. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/d8e/a96/0ab/d8ea960ab0540026291d5d0f5cf83712.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 1.</font>  <font color="#3AC1EF">Warisan prototipe</font> </h2><br>  Saya terbiasa dengan kelas "klasik", tetapi memutuskan untuk belajar JavaScript.  Saya memiliki masalah dalam memahami model prototipe.  Jika memungkinkan, jelaskan, dalam bentuk templat, kemampuan untuk membuat "kelas" dalam JavaScript, beri tahu kami tentang metode dan properti kelas yang tertutup dan terbuka.  Saya mengerti bahwa banyak yang telah ditulis tentang ini, dan bahwa dalam JavaScript, metode dan properti objek, secara default, tersedia untuk umum, tetapi saya ingin memahami semua ini dengan benar.  Bagaimana cara kerja pewarisan prototipe dalam JavaScript? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Warisan klasik sangat mengingatkan bagaimana orang mewarisi gen leluhur mereka.  Orang memiliki beberapa kemampuan dasar yang umum, seperti berjalan dan berbicara.  Selain itu, setiap orang memiliki beberapa kekhasan.  Orang tidak dapat mengubah apa yang disebut "kelas" mereka, tetapi mereka dapat mengubah "properti" mereka sendiri dalam batas-batas tertentu.  Pada saat yang sama, kakek nenek, ibu dan ayah tidak dapat mempengaruhi gen anak-anak atau cucu-cucu dalam proses kehidupan mereka.  Jadi semuanya diatur di Bumi, tetapi mari kita bayangkan planet lain tempat mekanisme pewarisan bekerja dengan cara khusus.  Katakanlah, beberapa organisme yang mampu bermutasi menggunakan mekanisme "pewarisan telepati" di sana.  Ini diungkapkan dalam kenyataan bahwa mereka dapat mengubah informasi genetik keturunan mereka sendiri dalam proses kehidupan mereka. <br><br>  Perhatikan contoh warisan di planet aneh ini.  Objek Bapa mewarisi gen dari objek Kakek, dan objek Putra mewarisi informasi genetik dari Bapa.  Setiap penghuni planet ini dapat dengan bebas bermutasi dan mengubah gen keturunan mereka.  Misalnya, di "Kakek" kulit memiliki warna hijau.  Tanda ini diwarisi oleh "Bapa" dan "Anak".  Tiba-tiba, "Kakek" memutuskan bahwa dia lelah menjadi hijau.  Sekarang dia ingin menjadi biru dan mengubah warna kulitnya (dalam hal JS - mengubah prototipe kelasnya), "secara telepati" meneruskan mutasi ini kepada "Ayah" dan "Putera".  Setelah itu, "Ayah", percaya bahwa "Kakek" telah selamat dari pikiran, memutuskan untuk mengubah gennya sehingga ia berubah menjadi hijau lagi (yaitu, ia mengubah prototipe sendiri).  Perubahan-perubahan ini "secara telepati" ditransmisikan ke "Anak."  Akibatnya, baik "Ayah" dan "Anak" memiliki kulit hijau lagi.  Pada saat yang sama, "Kakek" masih berwarna biru.  Sekarang, tidak peduli apa yang dia lakukan dengan warnanya, itu tidak akan mempengaruhi orang lain.  Dan semua ini disebabkan oleh fakta bahwa "Bapa" secara eksplisit mengatur warna kulitnya dalam "prototipe" -nya, dan "Anak" mewarisi warna ini.  Kemudian "Anak" berpikir seperti ini: "Aku akan menjadi hitam.  Dan biarkan keturunan saya mewarisi warna dari ayah saya. "  Untuk melakukan ini, ia mengubah hartanya sendiri (dan bukan properti prototipe-nya) sedemikian rupa sehingga hartanya akan mempengaruhi warnanya, tetapi tidak akan mempengaruhi keturunannya.  Kami menyatakan semua ini dalam bentuk kode: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Grandfather = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-comment"><span class="hljs-comment">//  Grandfather Grandfather.prototype.color = 'green'; var Father = function () {}; //  Father Father.prototype = new Grandfather (); //  - ,        var Son = function () {}; //  Son Son.prototype = new Father (); // Son   Father var u = new Grandfather (); //   Grandfather var f = new Father (); //   Father var s = new Son (); //   Son //     console.log ([u.color, f.color, s.color]); // ["green", "green", "green"] //  Grandfather        Grandfather.prototype.color = 'blue'; console.log ([u.color, f.color, s.color]); // ["blue", "blue", "blue"] //  Father      -   ,     Father.prototype.color = 'green'; //      : // Grandfather.prototype.color = 'green'; console.log ([u.color, f.color, s.color]); // ["blue", "green", "green"] // ,        Grandfather     color,      Grandfather.prototype.color = 'blue'; console.log ([u.color, f.color, s.color]); // ["blue", "green", "green"] //  Son,  ,       Grandfather,    s.color = 'black'; //        console.log ([u.color, f.color, s.color]); // ["blue", "green", "black"] var SonsSon = function () {}; //  SonsSon -   Son SonsSon.prototype = new Son (); //  var ss = new SonsSon (); //   SonsSon //         console.log ([u.color, f.color, s.color, ss.color]); // ["blue", "green", "black", "green"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan nomor 2.</font>  <font color="#3AC1EF">Buat Objek</font> </h2><br>  Jika Anda membuat instance objek baru menggunakan kata kunci <code>new</code> , lalu bagaimana Anda bisa melindungi diri dari kesalahan?  Beginilah biasanya saya bekerja: <br><br><ol><li>  Saya selalu membangun fungsi konstruktor sehingga mereka mulai dengan huruf kapital. </li><li>  Saya memverifikasi kebenaran operasi menggunakan <code>this instanceof Function_Name</code> (saya mencoba untuk tidak menggunakan konstruk dari tipe <code>this instanceof arguments.callee</code> karena alasan kinerja). </li><li>  Pendekatan ini mirip dengan yang sebelumnya, tetapi perbandingannya dibuat dengan <code>window</code> , karena saya tidak suka membuat kode nama-nama entitas dan tidak perlu menulis kode untuk lingkungan selain browser. </li></ol><br>  Apa model paling nyaman untuk membuat objek? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Cara terbaik, baik secara ideologis maupun berdasarkan keakraban metode ini, untuk membuat objek menggunakan kata kunci <code>new</code> .  Dalam hal ini, fungsi konstruktor harus diberi nama yang dimulai dengan huruf kapital. <br><br>  Saya lebih suka berpegang pada aturan dan tidak melakukan pemeriksaan tambahan <code>this</code> pada konstruktor.  Jika konstruktor dipanggil tanpa yang <code>new</code> dan pekerjaan dimulai dalam lingkup global, ini dapat dibandingkan dengan "penipuan diri sendiri".  Pada saat yang sama, saya sama sekali tidak menyarankan Anda menangani situasi di perancang tempat mereka dipanggil tanpa kata kunci <code>new</code> .  Misalnya, mungkin terlihat seperti ini: jika konstruktor dipanggil tanpa yang <code>new</code> , maka, bagaimanapun, objek baru dibuat dan dikembalikan.  Pendekatan ini secara ideologis salah dan mengarah pada kesalahan. <br>  Berikut ini contoh bekerja dengan konstruktor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Obj = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pew = <span class="hljs-number"><span class="hljs-number">100</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//  let o = new Obj(); o.pew++; console.log(o.pew); //101 // .   Obj (); // TypeError: this is undefined</span></span></code> </pre> <br>  Lebih baik tidak menggunakan kata kunci <code>new</code> untuk metode pabrik dan untuk kasus-kasus ketika tidak diperlukan konstruktor, ketika akan lebih mudah untuk membuat objek menggunakan objek literal.  Katakanlah kode konstruktor yang ditunjukkan pada contoh berikut secara eksplisit berlebihan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    . var Obj = function () {    if (! (this instanceof Obj)) {        return new Obj ();    }    this.pew = 100; };</span></span></code> </pre> <br>  Jika, bahkan untuk membuat objek kecil, Anda masih memerlukan konstruktor, lebih baik melakukannya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Obj = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pew = <span class="hljs-number"><span class="hljs-number">100</span></span>; };</code> </pre> <br>  Di sini, seperti yang ditunjukkan di atas, karena kenyataan bahwa konstruktor bekerja dalam mode ketat, kesalahan akan terjadi ketika memanggilnya tanpa yang <code>new</code> . <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 3.</font>  <font color="#3AC1EF">Intersepsi klik mouse</font> </h2><br>  Bagaimana, menggunakan JavaScript, untuk mengetahui tombol mouse mana yang diklik? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Mengklik tombol mouse menghasilkan peristiwa <code>mousedown</code> dan <code>mousedown</code> .  Dalam hal ini, peristiwa <code>click</code> hanya dihasilkan oleh tombol kiri mouse.  Dalam pengendali event, Anda perlu memeriksa kode yang terletak di properti <code>event.button</code> untuk mengetahui tombol mana yang ditekan (0 - kiri, 1 - tengah, 2 - kanan).  Namun, di IE semuanya terlihat sedikit berbeda.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> button = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById (<span class="hljs-string"><span class="hljs-string">'button'</span></span>),              <span class="hljs-comment"><span class="hljs-comment">// 0 1 2    buttonMap = ['Left', 'Middle', 'Right'],    handler = function (event) {        event = event || window.event;        alert (buttonMap [event.button] + 'id:' + event.button);    }; if (button.addEventListener) {     button.addEventListener ('mousedown', handler, false); } else {     // IE 0 1 2 3 4     buttonMap = ['???', 'Left', 'Right', '???', 'Middle'];     button.attachEvent ('onmousedown', handler); }</span></span></code> </pre> <br>  Pustaka jQuery mempertimbangkan fitur IE ini, jadi ketika menggunakannya di browser apa pun, cukup periksa nilai <code>event.which</code> properti alih-alih mengacaukan <code>event.button</code> : <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).mousedown(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   alert([<span class="hljs-string"><span class="hljs-string">'Left'</span></span>, <span class="hljs-string"><span class="hljs-string">'Middle'</span></span>, <span class="hljs-string"><span class="hljs-string">'Right'</span></span>][event.which]); });</code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan nomor 4.</font>  <font color="#3AC1EF">Intersepsi penekanan tombol pada tombol keyboard</font> </h2><br>  Apakah mungkin untuk mencegat, melalui JavaScript, menekan tombol panah (khususnya, menekan tombol Turun dan Atas), sehingga, setelah mengkliknya, browser tidak akan menggulir halaman?  Jika ini memungkinkan, lalu apa saja fitur penerapan ini di berbagai browser?  Misalkan halaman ditampilkan pada halaman yang tidak sepenuhnya sesuai pada layar.  Bergerak melalui sel-sel tabel ini harus diatur menggunakan tombol panah, dan diperlukan bahwa browser tidak menggulir halaman ketika Anda mengklik tombol tersebut. <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Untuk mengimplementasikan sesuatu seperti ini, pertama-tama, Anda perlu menonaktifkan respons sistem standar untuk mengendalikan tindakan.  Misalnya, tombol panah dan roda mouse menggulir halaman, mengklik kanan pada halaman menampilkan menu konteks, ketika Anda mengklik tombol <code>submit</code> , fungsi <code>form.submit()</code> , ketika Anda mengklik bidang input, itu mendapat fokus input, ketika Anda mengklik pada tautan, browser memuat halaman yang dituju. <br><br>  Ini dapat dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan berbagai cara</a> .  Misalnya, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"keydown"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//  -   if([37, 38, 39, 40].indexOf(e.keyCode) &gt; -1) {       e.preventDefault();   } }, false);</span></span></code> </pre> <br>  Halaman setelah itu biasanya tidak akan merespon penekanan tombol panah. <br>  Satu hal penting yang perlu diperhatikan di sini.  Metode <code>preventDefault()</code> sebelum tindakan default dilakukan.  Misalnya, jika Anda mengklik bidang untuk mencegahnya mendapatkan fokus input, Anda perlu menggantung penangan yang sesuai pada suatu peristiwa yang ada di rantai peristiwa sebelum tindakan default.  Dalam kasus kami, ini adalah acara <code>mousedown</code> : <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'input'</span></span>).bind (<span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   event.preventDefault();   <span class="hljs-comment"><span class="hljs-comment">//    return false; });</span></span></code> </pre> <br>  Saat Anda mengklik bidang input, peristiwa berikut terjadi - dalam urutan yang ditampilkan di sini: <br><br><ol><li> <code>mousedown</code> </li> <li>  <code>focus</code> (sebelum ini, objek lain yang kehilangan fokus akan memicu kejadian <code>blur</code> ) </li><li> <code>mouseup</code> </li> <li> <code>click</code> </li> </ol><br>  Jika Anda mencoba untuk mencegah elemen dari mendapatkan fokus input, maka menggunakan event handler untuk ini dimulai dengan handler event <code>focus</code> tidak akan membantu kami. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 5.</font>  <font color="#3AC1EF">Hentikan animasi GIF dan kunci ESC</font> </h2><br>  Bagaimana cara mengatasi masalah menghentikan animasi GIF saat menekan tombol ESC? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Di sini Anda dapat menggunakan pendekatan yang sama dengan yang kami pertimbangkan di atas.  Di beberapa browser, menekan tombol ESC menghentikan animasi GIF dan pemuatan halaman.  Ini adalah perilaku standar mereka, dan untuk mencegah mereka berperilaku dengan cara ini, metode event <code>preventDefault()</code> berguna bagi kita, seperti sebelumnya.  Kode kunci ESC adalah 27. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 6.</font>  <font color="#3AC1EF">Kurung di IIFE</font> </h2><br>  Bagaimana konstruk kedua kurung digunakan ketika menyatakan Ekspresi Fungsi Segera Diminta (IIFE)? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Kurung dalam situasi ini memungkinkan parser untuk memahami bahwa ada fungsi di depannya yang perlu dilakukan.  Tapi dia juga perlu memahami apa tanda kurung ini - operator pengelompokan, atau konstruksi yang menunjukkan perlunya memanggil fungsi.  Misalnya, jika kita menggunakan dua tanda kurung seperti yang ditunjukkan di bawah ini, kita akan <code>SyntaxError</code> kesalahan <code>SyntaxError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }()</span></span></code> </pre> <br>  Ini disebabkan oleh fakta bahwa fungsi tersebut tidak memiliki nama (Anda harus menentukan namanya dalam deklarasi fungsi). <br><br>  Mari kita coba menulis ulang kode ini, memberi nama fungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }()</span></span></code> </pre> <br>  Sekarang fungsi memiliki nama, konstruksi ini, secara teoritis, akan terlihat sangat normal dari sudut pandang sistem.  Tetapi kesalahan tidak hilang, meskipun sekarang ada hubungannya dengan operator pengelompokan, di dalamnya tidak ada ekspresi.  Perhatikan bahwa dalam kasus ini, pernyataan pengelompokan diikuti oleh operator pengelompokan, dan bukan urutan tanda kurung yang memberi tahu sistem bahwa fungsi yang mendahuluinya harus dipanggil. <br><br>  Seringkali IIFE dirancang sebagai berikut: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//  })()</span></span></code> </pre> <br>  Tetapi ada beberapa cara lain, yang intinya adalah untuk menunjukkan kepada parser bahwa sebelum itu hanya ekspresi fungsional yang perlu dieksekusi: <br><br><pre> <code class="javascript hljs">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  }(); +function () { //  }(); [function() { //  }()]; var a = function () { //  }();</span></span></code> </pre> <br>  IIFE banyak digunakan dalam pemrograman JavaScript.  Misalnya, konstruksi ini digunakan di jQuery.  Dengan bantuannya, Anda dapat membuat penutupan.  Faktanya, kita berbicara tentang fakta bahwa, dengan menggunakan IIFE, programmer dapat mengeksekusi beberapa kode dalam lingkup lokal.  Ini membantu melindungi ruang lingkup global dari polusi, dan memungkinkan untuk mengoptimalkan akses ke variabel global.  Desain seperti itu diperkecil dengan baik. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 7.</font>  <font color="#3AC1EF">Passing code sebagai tanggapan terhadap permintaan</font> </h2><br>  Server, dalam proses interaksi AJAX dengan klien, di tubuh respons, mengirimkan klien sebuah <code>alert ('Boom !!!');</code>  .  Klien menerima respons dan mengeksekusi kode ini menggunakan fungsi <code>eval()</code> .  Apa itu namanya?  Bagaimanapun, apa yang terkandung dalam respons server bukanlah JSON, bukan XML, dan bukan HTML.  Apa yang dapat Anda katakan tentang eksekusi pada klien dari kode yang berasal dari server dalam bentuk tubuh tanggapan terhadap permintaan tertentu? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Bahkan, tidak ada nama khusus untuk skema semacam itu untuk interaksi client-server.  Dan ini adalah skema interaksi sistem yang sangat tidak dianjurkan.  Ini sama buruknya dengan menyimpan kode PHP dalam database dan kemudian mengeksekusinya menggunakan metode bahasa yang sesuai.  Bahkan jika kita tidak mempertimbangkan pertimbangan ideologis, kita dapat mengatakan bahwa arsitektur seperti itu sangat tidak fleksibel, oleh karena itu, jika proyek di mana ia digunakan, akan diperlukan, ketika berkembang, untuk mengubah sesuatu, ini tidak akan mudah.  Di sini kita melihat contoh arsitektur sistem yang buruk ketika data dicampur dengan elemen kode dan antarmuka.  Untuk mengubah sesuatu dalam sistem seperti itu, pertama-tama Anda perlu memahami seluk-beluk arsitekturnya yang rumit, dan kemudian, setelah melakukan perubahan, sekali lagi “membingungkan” segalanya.  Saya tidak berbicara tentang penggunaan kembali kode. <br><br>  Untuk menyederhanakan dukungan kode, Anda perlu berusaha untuk pemisahan bagian sistem yang paling mungkin dan untuk mengurangi jumlah saling ketergantungan bagian-bagian ini.  Untuk memastikan konektivitas yang lemah dari bagian-bagian sistem, yaitu, untuk memastikan bahwa sebuah fragmen aplikasi dapat diekstraksi dari itu, atau, dengan kompleksitas paling sedikit, digantikan oleh yang lain, Anda dapat menggunakan mekanisme acara atau solusi arsitektur khusus, seperti MVC. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 8.</font>  <font color="#3AC1EF">Melakukan operasi berat di utas utama</font> </h2><br>  Bagaimana cara mengatur pelaksanaan perintah intensif sumber daya tertentu dalam JavaScript dan tidak "menangguhkan" seluruh skrip? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  JavaScript adalah bahasa utas tunggal.  Kode halaman web dieksekusi di utas yang sama dan transformasi DOM tree dilakukan.  Ada juga timer.  Setiap kali Anda melakukan beberapa operasi yang menghabiskan sumber daya (siklus, panggilan ke fungsi "berat"), ini menyebabkan perlambatan pada antarmuka pengguna atau bahkan ke pemblokiran lengkapnya.  Jika operasi yang dilakukan tidak memiliki beban yang sangat besar pada sistem, maka dampaknya pada antarmuka akan sangat kecil sehingga pengguna tidak akan menyadarinya.  Untuk membuat komputasi yang berat di luar utas utama, konsep pekerja web diperkenalkan dalam JavaScript. <br><br>  Jika penggunaan pekerja tidak memungkinkan, maka Anda perlu mengoptimalkan siklus dan fungsi "berat".  Dalam buku “JavaScript.  Optimalisasi Kinerja ”Nicholas Zakas mengatakan bahwa pengguna tidak akan melihat apa pun jika aliran antarmuka pengguna diblokir untuk 100 ms atau kurang. <br><br>  Dari ide ini, kita dapat menyimpulkan bahwa perhitungan intensif sumber daya dapat dibagi menjadi beberapa fragmen, yang implementasinya membutuhkan maksimum 100 ms, setelah itu utas utama harus dibebaskan. <br><br>  Berikut ini contoh kode dari buku di atas: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timedProcessArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, process, callback</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> todo = items.concat();   <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(function () {       var start = +new Date();       do {           process(todo.shift());       } while (todo.length &gt; 0 &amp;&amp; (+new Date() - start &lt; 50));       if (todo.length &gt; 0){           setTimeout(arguments.callee, 25);       } else {           callback(items);       }   }, 25); } function saveDocument(id) {   var tasks = [openDocument, writeText, closeDocument, updateUI];   timedProcessArray(tasks, [id], function(){       alert("Save completed!");   }); }</span></span></code> </pre> <br>  Fungsi <code>timedProcessArray()</code> memblokir utas utama selama 25 ms, melakukan urutan tindakan, lalu melepaskannya selama 25 ms, setelah itu proses ini diulang. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 9.</font>  <font color="#3AC1EF">Tentang mengubah ukuran jendela browser</font> </h2><br>  Bisakah saya mengetahui bahwa pengguna telah selesai mengubah ukuran jendela browser? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Tidak ada acara khusus yang memungkinkan Anda untuk mengetahuinya.  Tetapi Anda bisa mengetahui apakah pengguna mengubah ukuran jendela menggunakan acara <code>onresize</code> .  Namun metode ini tidak terlalu akurat. <br><br>  Berikut adalah konsep kode untuk menyelesaikan masalah ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> time = <span class="hljs-number"><span class="hljs-number">0</span></span>,   timerId,   TIME_ADMISSION = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 0.1  function onresizeend () {   console.log('onresizeend'); }; function resizeWatcher () {   if (+new Date - time &gt;= TIME_ADMISSION) {       onresizeend();       if (timerId) {           window.clearInterval(timerId);           timerId = null;       }   } }; $(window).resize(function () {   if (!timerId) {       timerId = window.setInterval(resizeWatcher, 25);   }   time = +new Date; });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan nomor 10.</font>  <font color="#3AC1EF">Membuka jendela dan tab browser baru</font> </h2><br>  Bagaimana, menggunakan metode <code>window.open()</code> , untuk membuka jendela browser baru, dan bukan tab baru? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Bagaimana tepatnya metode <code>window.open()</code> berperilaku tergantung pada browser.  Opera selalu membuka tab baru (meskipun terlihat seperti windows), Safari selalu membuka windows (meskipun perilaku ini dapat diubah).  Perilaku Chrome, Firefox, dan Internet Explorer dapat dikontrol. <br><br>  Jadi, jika parameter tambahan (posisi jendela <code>window.open()</code> diteruskan ke metode <code>window.open()</code> , jendela baru akan dibuka: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(<span class="hljs-string"><span class="hljs-string">'http://www.google.com'</span></span>, <span class="hljs-string"><span class="hljs-string">'_blank'</span></span>, <span class="hljs-string"><span class="hljs-string">'toolbar=0,location=0,menubar=0'</span></span>);</code> </pre> <br>  Jika hanya tautan yang diteruskan ke metode ini, maka tab browser baru akan dibuka: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(<span class="hljs-string"><span class="hljs-string">'http://www.google.com'</span></span>);</code> </pre> <br>  Seringkali Anda perlu membuka tab browser baru.  Mungkin ada masalah dengan ini di browser Safari.  Secara default (tergantung pada pengaturan), browser, ketika <code>window.open()</code> dipanggil, membuka jendela baru.  Tetapi jika Anda mengklik tautan, sambil menekan tombol <code>Ctrl + Shift/Meta + Shift</code> , tab baru akan terbuka (terlepas dari pengaturan).  Dalam contoh berikut, kami akan mensimulasikan acara <code>click</code> yang muncul ketika tombol <code>Ctrl + Shift/Meta + Shift</code> ditekan: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safariOpenWindowInNewTab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> event = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createEvent (<span class="hljs-string"><span class="hljs-string">'MouseEvents'</span></span>),        mac = (navigator.userAgent.indexOf (<span class="hljs-string"><span class="hljs-string">'Macintosh'</span></span>)&gt; = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  Ctrl + Shift + LeftClick / Meta + Shift + LeftClick ()    //       event.initMouseEvent (        / * type * / "click",        / * canBubble * / true        / * cancelable * / true,        / * view * / window,        / * detail * / 0,        / * screenX, screenY, clientX, clientY * / 0, 0, 0, 0,        / * ctrlKey * /! mac,        / * altKey * / false,        / * shiftKey * / true        / * metaKey * / mac,        / * button * / 0,        / * relatedTarget * / null    ); //     ,   ,         $ ('&lt;a/&gt;', {'href': href, 'target': '_blank'}) [0] .dispatchEvent (event); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan No. 11.</font>  <font color="#3AC1EF">Menyalin objek dalam</font> </h2><br>  Bagaimana cara mengatur secara efektif penyalinan objek dalam? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Jika objek yang salinannya ingin Anda buat (sebut saja <code>oldObject</code> ) tidak berubah, maka itu akan paling efektif untuk melakukan ini melalui prototipe (ini dilakukan dengan sangat cepat): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}   F.prototype = o;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> F(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObject = object(oldObject);</code> </pre> <br>  Jika Anda perlu benar-benar melakukan operasi kloning objek, maka cara tercepat akan secara rekursif, mengoptimalkan proses ini, melalui propertinya.  Mungkin ini adalah algoritma tercepat untuk membuat salinan objek yang dalam: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cloner = {   <span class="hljs-attr"><span class="hljs-attr">_clone</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_clone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> out = [];           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = obj.length; i &lt; len; i++) {               <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj[i];               out[i] = (value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">"object"</span></span>) ? _clone(value) : value;           }       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {           <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> out = {};           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) {               <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.hasOwnProperty(key)) {                   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = obj[key];                   out[key] = (value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">"object"</span></span>) ? _clone(value) : value;               }           }       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out;   }, <span class="hljs-attr"><span class="hljs-attr">clone</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">it</span></span></span><span class="hljs-function">) </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._clone({       <span class="hljs-attr"><span class="hljs-attr">it</span></span>: it       }).it;   } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newObject = cloner.clone(oldObject);</code> </pre> <br>  Jika Anda menggunakan jQuery, maka Anda dapat menggunakan konstruk berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var newObject = jQuery.extend ({}, oldObject); //   var newObject = jQuery.extend (true, {}, oldObject);</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan nomor 12.</font>  <font color="#3AC1EF">Penghancur JavaScript</font> </h2><br>  Bagaimana cara membuat sesuatu seperti destruktor dalam JavaScript?  Bagaimana mengelola siklus hidup benda? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Dalam JavaScript, sebuah objek akan dihapus dari memori setelah referensi terakhir untuk itu menghilang: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = {<span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-string"><span class="hljs-string">'z'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = a; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> az; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> a; <span class="hljs-comment"><span class="hljs-comment">//    a console.log (b, c); // ,  ,   </span></span></code> </pre> <br>  Menggunakan sesuatu seperti "destruktor" dalam JavaScript hanya menghasilkan membersihkan konten objek, tetapi tidak menghapusnya dari memori. <br><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 13.</font>  <font color="#3AC1EF">Pemrosesan data biner</font> </h2><br>  Apakah mungkin untuk memproses data biner dalam JavaScript?  Dan jika demikian, bagaimana? <br><br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Jika Anda perlu bekerja dengan data biner dalam aplikasi JavaScript, Anda dapat mencoba menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binary Parser</a> .  Tapi kodenya adalah neraka.  Dalam ES6 + ada saran mengenai tipe <code>StructType</code> (ini sama dengan yang disajikan dalam C ++ oleh tipe komposit ke <code>struct</code> diberikan).  Tipe data ini diperlukan untuk menyederhanakan bekerja dengan data biner.  Bekerja dengannya mungkin terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2D = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: uint32, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: uint32 }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">r</span></span>: uint8, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: uint8, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: uint8 }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Pixel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructType({ <span class="hljs-attr"><span class="hljs-attr">point</span></span>: Point2D, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: Color }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triangle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayType(Pixel, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Triangle([{ <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">255</span></span> } },                     { <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } },                     { <span class="hljs-attr"><span class="hljs-attr">point</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: { <span class="hljs-attr"><span class="hljs-attr">r</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">128</span></span> } }]);</code> </pre> <br><h2>  <font color="#3AC1EF">Pertanyaan nomor 14.</font>  <font color="#3AC1EF">Mengubah variabel dalam satu fungsi dari fungsi lainnya</font> </h2><br>  Bagaimana cara mengubah variabel yang terletak di satu fungsi dari fungsi lain? <br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Di sini Anda dapat menerapkan beberapa pendekatan: <br><br><ol><li>  Anda dapat menggunakan tautan ke konteks fungsi yang menarik bagi kami (fungsi <code>primer()</code> dalam contoh berikut) dalam fungsi <code>smth()</code> . <br></li><li>  Anda bisa melewatkan fungsi yang dibuat dalam konteks fungsi <code>primer()</code> ke fungsi <code>smth()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> primer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, c, d, e = {}; smth (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{        a = <span class="hljs-number"><span class="hljs-number">1</span></span>;        b = <span class="hljs-number"><span class="hljs-number">2</span></span>;        c = <span class="hljs-number"><span class="hljs-number">3</span></span>;        d = <span class="hljs-number"><span class="hljs-number">4</span></span>;    }, e); alert ([a, b, c, d, e.pewpew]); }, smth = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback, e</span></span></span><span class="hljs-function">) </span></span>{    callback ();    e.pewpew = <span class="hljs-string"><span class="hljs-string">"pewpew"</span></span>; }; primer ();</code> </pre> </li><li>  Sebelumnya (sebelum Firefox 3.6), Anda bisa masuk ke konteks menggunakan properti <code>__parent__</code> , tetapi sudah di Firefox 4 fitur ini dihapus. </li></ol><br><h2>  <font color="#3AC1EF">Pertanyaan nomor 15.</font>  <font color="#3AC1EF">Bekerja dengan fungsi</font> </h2><br>  Beri tahu kami bagaimana fungsi dapat dipanggil dalam JavaScript. <br><h3>  <font color="#3AC1EF">▍ Jawab</font> </h3><br>  Saya kira tidak perlu berbicara tentang cara memanggil fungsi, metode dan konstruktor selama bekerja normal dengan mereka.  Mari kita bicara tentang cara menggunakan metode <code>call()</code> dan <code>apply()</code> . <br><br><h4>  Menggunakan panggilan () untuk mengonfigurasi konstruktor suatu objek </h4><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function extend (newObj, oldObj) {   function F () {};   F.prototype = oldObj.prototype;   newObj.prototype = new F ();   return newObj }; var Obj = function () {   this.obj_var = 100; }; Obj.prototype.obj_proto_var = 101; var NewObj = function () {   Obj.call (this); //   Obj     obj_var   this.new_obj_var = 102; }; extend (NewObj, Obj) NewObj.prototype.new_obj_proto_var = 103; new NewObj (); // {new_obj_proto_var: 103, new_obj_var: 102, obj_proto_var: 101, obj_var: 100}</span></span></code> </pre> <br><h4>  Konversi objek mirip array ke array </h4><br>  Objek mirip array mirip dengan array JavaScript, tetapi sebenarnya tidak.  Secara khusus, ini dinyatakan dalam kenyataan bahwa objek tersebut tidak memiliki metode array biasa.  Di antara objek tersebut, misalnya, objek <code>arguments</code> fungsi tradisional dan hasil metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">getElementsByTagName ()</a> dapat dicatat. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// document.getElementsByTagName ("div")  ,   ,    , ,  ,        document.getElementsByTagName ("div"). forEach (function (elem) {    // ... }); // TypeError: document.getElementsByTagName ("div"). forEach is not a function //    Array.prototype.slice.call(document.getElementsByTagName("div")).forEach (function (elem) {   // OK }); //        console.log(Array.prototype.slice.call ('pewpew')) // ["p", "e", "w", "p", "e", "w"] //  IE8   </span></span></code> </pre> <br><h4>  Membuat objek pembungkus </h4><br>  Teknik ini menggunakan <code>call()</code> dan <code>apply()</code> memungkinkan Anda untuk membuat objek pembungkus. ,    - <code>foo()</code> ,    <code>bar()</code>       . <br><br>        : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>)} <span class="hljs-comment"><span class="hljs-comment">// foo (context, arg1, arg2, ...) function foo () {    var context = arguments [0];    var args = Array.prototype.slice.call (arguments, 1); //     bar    bar.apply (context, args); }</span></span></code> </pre> <br>       <code>Function.call.apply()</code>    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.call.apply(bar, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }</code> </pre> <br> ,   <code>Function.call.apply()</code> , ,  <code>foo()</code> ,  <code>bar</code> . <br><br><h2> <font color="#3AC1EF"> №16.    </font> </h2><br>   ,     ,  ? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>  . ,   Firefox  3.6,       <code>__parent__</code> ,     . <br><br><h2> <font color="#3AC1EF"> №17.    </font> </h2><br>   ,        ,     ,    <code>eval()</code>    ? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>      ,       .     ,     : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1:  eval() (function () {    "use strict";    var globalObject = (0, eval) ("this"); //  :)    return globalObject; } ()); // 2:    (function (global) {    // ... } (window)); // 3:      (function () {    return this; } ()); // 4:            ,       . //  -    "use strict"; (function (global) {    // global }) (this);</span></span></code> </pre> <br><h2> <font color="#3AC1EF"> №18.  </font> </h2><br>  ,  JavaScript,    ,    ? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>    JavaScript   - « ».     .          . ,    : <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'#smth'</span></span>).click(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSmthClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth) {       <span class="hljs-comment"><span class="hljs-comment">//         event.handlerFunction = onSmthClick;       event.handlerContext = this;       //         //  otherObjectSetSomeEvent   event.handlerFunction          otherObjectSetSomeEvent(event);   } else {       //  -    } });</span></span></code> </pre> <br>   —    ,     .      ,    2 : <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'#smth'</span></span>). click (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler1</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth) {       <span class="hljs-comment"><span class="hljs-comment">//         leftObjectSetSomeEvent(event, function handler2 (e) {           //  -   e       });   } else {       //  -    } }); function leftObjectSetSomeEvent(event, callback) {   callback (event);   //    }</span></span></code> </pre> <br><h2> <font color="#3AC1EF"> №19.    </font> </h2><br>   JavaScript       ?  —  ,     . <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>     <code>click</code>   «»    DOM.         (,      ,     ). <br><br><pre> <code class="plaintext hljs">// jQuery $(window).bind ('click', function (e) {   console.log ('Clicked on', e.target); }); //       $('#pewpew').delegate ('*', 'click', function(e) {   console.log('Clicked on', e.target); }); //     $('#pewpew').delegate('.pewpew', 'click', function (e) {   console.log ('Clicked on element with .pewpew class name'); });</code> </pre> <br><h2> <font color="#3AC1EF"> №20. XHR-</font> </h2><br>   XHR-   jQuery? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>  ,    - : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xhr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, u, c, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest) onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   readyState ^ <span class="hljs-number"><span class="hljs-number">4</span></span> || c(x.target) }, open(m, u), send() }</code> </pre> <br>  - : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xhr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m, u, c, x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.XMLHttpRequest || ActiveXObject)(<span class="hljs-string"><span class="hljs-string">"Microsoft.XMLHTTP"</span></span>)) onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{   readyState ^ <span class="hljs-number"><span class="hljs-number">4</span></span> || c(x) }, open(m, u), send() }</code> </pre> <br>    : <br><br><pre> <code class="javascript hljs">xhr(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, <span class="hljs-string"><span class="hljs-string">'//google.com/favicon.ico'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xhr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(xhr) });</code> </pre> <br><h2> <font color="#3AC1EF"> №21.   -</font> </h2><br>        (reflow)   (repaint)    -? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br><ol><li>     <code>requestAnimationFrame()</code> ,     ,   <code>setInterval()</code>  <code>setTimeout()</code> .    ,  ,         , ,   ,     . ,    JavaScript-     CSS-   SVG-.  ,     ,      ,     ,       , , .    ,  ,    . </li><li>       float- (      ). </li><li>      DOM.  ,   ,  ,    DOM    (         ). </li><li>       —      .            (  , ,  ).  Berikut ini sebuah contoh: <br><br><pre> <code class="plaintext hljs">//      element.style.left = "150px;"; // ... element.style.color = "green"; //  ,   ,    element.setAttribute ('style', 'color: green; left: 150px');</code> </pre> </li><li>           (        ). <br></li><li>      —   ( <code>style.display = "none"</code> ).        ,     . <br></li></ol><br>    ,   -,          .  ,  ,   ,       ,      . <br><br><ol><li>   . </li><li>    DOM- (  —   ). </li><li>       <code>Document.querySelectorAll()</code>   <code>firstElementChild</code> . </li><li>   ,   <code>document.getElementsByTagName()</code>     ( ,       DOM,  ). </li></ol><br><h2> <font color="#3AC1EF"> №22.     Node.js</font> </h2><br>     Node.js,   ,        ? <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>     ,              (     PHP  Apache).         ,       ,      .  Node.js                —    .  ,        ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster</a> .         (master)  - (worker).    ,          . <br><br><h2> <font color="#3AC1EF"> №23.  runInNewContext()  Node.js</font> </h2><br>     <code>runInNewContext()</code>  Node.js. <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>        .     ,    (   Node.js- Nodester).   -    ,       <code>runInNewContext()</code> . ,      «»,       .       «»    ,  ,  <code>runInNewContext()</code>       . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>         JavaScript    . ,    - ,   . <br><br>  <b>Pembaca yang budiman!</b>  , -  ,    ,      JavaScript   ,     ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436454/">https://habr.com/ru/post/id436454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436442/index.html">Satu kepala baik, dan dua lebih baik, atau memasangkan pemrograman dalam aksi</a></li>
<li><a href="../id436444/index.html">Penyebaran aplikasi monolitik yang tak terlihat dalam produksi di AWS. Pengalaman pribadi</a></li>
<li><a href="../id436448/index.html">Tinjau 27 "monitor IPS Acer HA270bid: untuk perbaikan diri</a></li>
<li><a href="../id436450/index.html">Terpencil dan terkendali, kebebasan dan pemerintahan. Percakapan dengan Staply</a></li>
<li><a href="../id436452/index.html">7 area pengembangan Linux pada 2019</a></li>
<li><a href="../id436456/index.html">Buat efek distribusi warna di Unity</a></li>
<li><a href="../id436458/index.html">Kemajuan dan sensasi dalam penelitian ai</a></li>
<li><a href="../id436460/index.html">Pilihan teknologi, arsitektur, dan desain dalam proyek perangkat lunak - tanpa uang tunai</a></li>
<li><a href="../id436464/index.html">2. Periksa Log Analisis Titik: SmartEvent</a></li>
<li><a href="../id436466/index.html">Elektron: mengembangkan aplikasi desktop menggunakan HTML, CSS dan JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>