<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüëß üê∫ üí≤ Saubere, schnelle Architektur als Alternative zu VIPER üë∏üèª üóØÔ∏è üé†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Im Moment gibt es viele Artikel √ºber VIPER - saubere Architektur, von denen verschiedene Variationen zu einer Zeit f√ºr iOS-Projekte popul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saubere, schnelle Architektur als Alternative zu VIPER</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415725/"><h3>  Einf√ºhrung </h3><br>  Im Moment gibt es viele Artikel √ºber VIPER - saubere Architektur, von denen verschiedene Variationen zu einer Zeit f√ºr iOS-Projekte popul√§r wurden.  Wenn Sie mit Viper nicht vertraut sind, k√∂nnen Sie es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. <br><br>  Ich m√∂chte √ºber die VIPER-Alternative - Clean Swift - sprechen.  Clean Swift sieht auf den ersten Blick wie VIPER aus, die Unterschiede werden jedoch sichtbar, nachdem das Prinzip der Interaktion zwischen Modulen untersucht wurde.  In VIPER basiert die Interaktion auf Presenter, √ºbertr√§gt Benutzeranforderungen zur Verarbeitung an den Interactor und formatiert die von ihm empfangenen Daten zur Anzeige auf dem View Controller zur√ºck: <br><br><img src="https://habrastorage.org/webt/au/kr/v_/aukrv_2zvl2ikjare8odlwup--k.png" alt="Bild"><br><a name="habracut"></a><br>  In Clean Swift sind die Hauptmodule wie in VIPER View Controller, Interactor und Presenter. <br><br><img src="https://habrastorage.org/webt/ll/ud/y0/lludy0ydjgy6domer_ayleohrp4.png" alt="Bild"><br><br>  Die Wechselwirkung zwischen ihnen erfolgt in Zyklen.  Die Daten√ºbertragung basiert auf Protokollen (√§hnlich wie bei VIPER), mit denen zuk√ºnftige √Ñnderungen an einer der Systemkomponenten einfach durch eine andere ersetzt werden k√∂nnen.  Der Interaktionsprozess sieht im Allgemeinen folgenderma√üen aus: Der Benutzer klickt auf die Schaltfl√§che, View Controller erstellt ein Objekt mit einer Beschreibung und sendet es an Interactor.  Interactor wiederum implementiert ein bestimmtes Szenario gem√§√ü der Gesch√§ftslogik, erstellt ein Ergebnisobjekt und √ºbergibt es an Presenter.  Presenter bildet ein Objekt mit Daten, die f√ºr die Anzeige f√ºr den Benutzer formatiert sind, und sendet sie an den View Controller.  Schauen wir uns jedes Clean Swift-Modul genauer an. <br><br><h3>  Ansicht (View Controller) </h3><br>  View Controller f√ºhrt wie in VIPER alle VIew-Konfigurationen durch, sei es Farb-, UILabel- oder Layout-Schriftarteneinstellungen.  Daher implementiert jeder UIViewController in dieser Architektur ein Eingabeprotokoll zum Anzeigen von Daten oder zum Reagieren auf Benutzeraktionen. <br><br><h3>  Interactractor </h3><br>  Interactor enth√§lt die gesamte Gesch√§ftslogik.  Es akzeptiert Benutzeraktionen von der Steuerung, wobei Parameter (z. B. ge√§nderter Text des Eingabefelds, Dr√ºcken einer Taste) im Eingabeprotokoll definiert sind.  Nach dem Ausarbeiten der Logik muss Interactor bei Bedarf die Daten f√ºr die Vorbereitung an den Presenter √ºbertragen, bevor sie im ViewController angezeigt werden.  Interactor akzeptiert jedoch nur Anforderungen aus View als Eingabe, im Gegensatz zu VIPER, wo diese Anforderungen √ºber Presenter gesendet werden. <br><br><h3>  Moderator </h3><br>  Der Pr√§sentator verarbeitet die Daten zur Anzeige f√ºr den Benutzer.  Das Ergebnis in diesem Fall ist das Eingabeprotokoll des ViewControllers. Hier k√∂nnen Sie beispielsweise das Textformat √§ndern, den Farbwert von enum in rgb √ºbersetzen usw. <br><br><h3>  Arbeiter </h3><br>  Um Interactor nicht unn√∂tig zu komplizieren und Details der Gesch√§ftslogik nicht zu duplizieren, k√∂nnen Sie ein zus√§tzliches Worker-Element verwenden.  In einfachen Modulen wird es nicht immer ben√∂tigt, aber in ausreichend geladenen Modulen k√∂nnen Sie einige Aufgaben aus Interactor entfernen.  Beispielsweise kann die Logik der Interaktion mit der Datenbank im Worker erstellt werden, insbesondere wenn dieselben Datenbankabfragen in verschiedenen Modulen verwendet werden k√∂nnen. <br><br><h3>  Router </h3><br>  Der Router ist f√ºr die √úbertragung von Daten zu anderen Modulen und die √úberg√§nge zwischen diesen verantwortlich.  Er hat eine Verbindung zum Controller, da Controller unter iOS leider unter anderem historisch f√ºr √úberg√§nge verantwortlich sind.  Die Verwendung von segue kann die Initialisierung von √úberg√§ngen vereinfachen, indem die Router-Methoden von Prepare for segue aufgerufen werden, da Router wei√ü, wie Daten √ºbertragen werden, und dies ohne zus√§tzlichen Schleifencode von Interactor / Presenter.  Die Daten√ºbertragung erfolgt √ºber die Data Warehouse-Protokolle jedes in Interactor implementierten Moduls.  Diese Protokolle schr√§nken auch den Zugriff auf interne Moduldaten vom Router aus ein. <br><br><h3>  Modelle </h3><br>  Modelle ist eine Beschreibung von Datenstrukturen zum √úbertragen von Daten zwischen Modulen.  Jede Implementierung der Gesch√§ftslogikfunktion hat eine eigene Beschreibung der Modelle. <br><br><ul><li>  Anfrage - um eine Anfrage vom Controller an den Interaktor zu senden. </li><li>  Antwort - Die Antwort des Interaktors auf die √úbermittlung von Daten an den Pr√§sentator. </li><li>  ViewModel - zur Daten√ºbertragung in einer Form, die zur Anzeige in der Steuerung bereit ist. </li></ul><br><h3>  Implementierungsbeispiel </h3><br>  Schauen wir uns diese Architektur anhand eines einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiels</a> genauer an.  Sie werden von der ContactsBook-Anwendung in einer vereinfachten, aber v√∂llig ausreichenden Form bereitgestellt, um das Wesentliche der Architekturform zu verstehen.  Die Anwendung enth√§lt eine Liste von Kontakten sowie das Hinzuf√ºgen und Bearbeiten von Kontakten. <br><br>  Ein Beispiel f√ºr ein Eingabeprotokoll: <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContactListDisplayLogic</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> }</code> </pre> <br>  Jeder Controller enth√§lt einen Verweis auf ein Objekt, das das Interactor-Eingabeprotokoll implementiert <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interactor: <span class="hljs-type"><span class="hljs-type">ContactListBusinessLogic?</span></span></code> </pre> <br>  sowie zum Router-Objekt, das die Logik der Daten√ºbertragung und des Modulwechsels implementieren soll: <br><br><pre> <code class="hljs objectivec">var router: (<span class="hljs-built_in"><span class="hljs-built_in">NSObjectProtocol</span></span> &amp; ContactListRoutingLogic &amp; ContactListDataPassing)?</code> </pre> <br>  Sie k√∂nnen die Modulkonfiguration in einer separaten privaten Methode implementieren: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">ContactListInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">ContactListPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">ContactListRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor }</code> </pre> <br>  oder erstellen Sie einen Configurator-Singleton, um diesen Code vom Controller zu entfernen (f√ºr diejenigen, die der Meinung sind, dass der Controller nicht an der Konfiguration beteiligt sein sollte) und sich nicht mit dem Zugriff auf Teile des Moduls im Controller zu verf√ºhren.  Nach Ansicht von Onkel Bob und im klassischen VIPER gibt es keine Konfiguratorklasse.  Die Verwendung des Konfigurators f√ºr das Modul zum Hinzuf√ºgen von Kontakten sieht folgenderma√üen aus: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromNib() <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>.sharedInstance.configure(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Der Konfiguratorcode enth√§lt die einzige Konfigurationsmethode, die mit der Setup-Methode in der Steuerung absolut identisch ist: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddContactConfigurator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedInstance = <span class="hljs-type"><span class="hljs-type">AddContactConfigurator</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control: AddContactViewController)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = control <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interactor = <span class="hljs-type"><span class="hljs-type">AddContactInteractor</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">AddContactPresenter</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = <span class="hljs-type"><span class="hljs-type">AddContactRouter</span></span>() viewController.interactor = interactor viewController.router = router interactor.presenter = presenter presenter.viewController = viewController router.viewController = viewController router.dataStore = interactor } }</code> </pre> <br>  Ein weiterer sehr wichtiger Punkt bei der Implementierung des Controllers ist der Code in der Standardvorbereitungsmethode: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scene = segue.identifier { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selector = <span class="hljs-type"><span class="hljs-type">NSSelectorFromString</span></span>(<span class="hljs-string"><span class="hljs-string">"routeTo\(scene)WithSegue:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> router = router, router.responds(to: selector) { router.perform(selector, with: segue) } } }</code> </pre> <br>  Ein aufmerksamer Leser bemerkte h√∂chstwahrscheinlich, dass der Router auch zur Implementierung von NSObjectProtocol erforderlich ist.  Dies geschieht, damit wir die Standardmethoden dieses Protokolls f√ºr das Routing verwenden k√∂nnen, wenn Segues verwendet werden.  Um diese einfache Umleitung zu unterst√ºtzen, sollte die Benennung der Segue-ID mit den Endungen der Routermethodennamen √ºbereinstimmen.  Um beispielsweise einen Kontakt anzuzeigen, gibt es einen Abschnitt, der an die Auswahl einer Zelle mit einem Kontakt gebunden ist.  Die Kennung lautet "ViewContact". Hier ist die entsprechende Methode in Router: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeToViewContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(segue: UIStoryboardSegue?)</span></span></span></span></code> </pre> <br>  Die Anforderung, Daten f√ºr Interactor anzuzeigen, sieht ebenfalls sehr einfach aus: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> func fetchContacts() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>() interactor?.showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) }</code> </pre> <br>  Fahren wir mit Interactor fort.  Interactor implementiert das ContactListDataStore-Protokoll, das f√ºr das Speichern / Zugreifen auf Daten verantwortlich ist.  In unserem Fall ist dies nur eine Reihe von Kontakten, die nur durch die Getter-Methode begrenzt werden, um dem Router die Unzul√§ssigkeit zu zeigen, ihn von anderen Modulen zu √§ndern.  Ein Protokoll, das die Gesch√§ftslogik f√ºr unsere Liste implementiert, lautet wie folgt: <br><br><pre> <code class="hljs vbscript">func showContacts(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contacts = worker.getContacts() self.contacts = contacts <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">response</span></span> = ContactList.ShowContacts.<span class="hljs-built_in"><span class="hljs-built_in">Response</span></span>(contacts: contacts) presenter?.presentContacts(<span class="hljs-built_in"><span class="hljs-built_in">response</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">response</span></span>) }</code> </pre> <br>  Es empf√§ngt Kontaktdaten von ContactListWorker.  In diesem Fall ist der Mitarbeiter daf√ºr verantwortlich, wie die Daten heruntergeladen werden.  Er kann sich an Dienste von Drittanbietern wenden, die beispielsweise entscheiden, Daten aus dem Cache zu entnehmen oder aus dem Netzwerk herunterzuladen.  Nach dem Empfang der Daten sendet Interactor eine Antwort an den Pr√§sentator, um die Anzeige vorzubereiten. Dieser Interactor enth√§lt einen Link zum Pr√§sentator: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter: <span class="hljs-type"><span class="hljs-type">ContactListPresentationLogic?</span></span></code> </pre> <br>  Presenter implementiert nur ein Protokoll - ContactListPresentationLogic. In unserem Fall √§ndert es einfach zwangsweise den Fall des Vor- und Nachnamens des Kontakts, bildet das DisplayedContact-Pr√§sentationsmodell aus dem Datenmodell und √ºbergibt dieses zur Anzeige an den Controller: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ContactList.ShowContacts.Response)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapped = response.contacts.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">ContactList</span></span> .<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span> .<span class="hljs-type"><span class="hljs-type">ViewModel</span></span> .<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>(firstName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.firstName.uppercaseFirst, lastName: $<span class="hljs-number"><span class="hljs-number">0</span></span>.lastName.uppercaseFirst) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel = <span class="hljs-type"><span class="hljs-type">ContactList</span></span>.<span class="hljs-type"><span class="hljs-type">ShowContacts</span></span>.<span class="hljs-type"><span class="hljs-type">ViewModel</span></span>(displayedContacts: mapped) viewController?.displayContacts(viewModel: viewModel) }</code> </pre> <br>  Danach endet der Zyklus und der Controller zeigt die Daten an, wobei die ContactListDisplayLogic-Protokollmethode implementiert wird: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayContacts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: ContactList.ShowContacts.ViewModel)</span></span></span></span> { displayedContacts = viewModel.displayedContacts tableView.reloadData() }</code> </pre> <br>  So sehen die Modelle zur Anzeige von Kontakten aus: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShowContacts</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contacts: [<span class="hljs-type"><span class="hljs-type">Contact</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisplayedContact</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastName: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fullName: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displayedContacts: [<span class="hljs-type"><span class="hljs-type">DisplayedContact</span></span>] } }</code> </pre> <br>  In diesem Fall enth√§lt die Anforderung keine Daten, da dies nur eine allgemeine Kontaktliste ist. Wenn beispielsweise der Listenbildschirm einen Filter enthalten w√ºrde, k√∂nnte der Filtertyp in diese Anforderung aufgenommen werden.  Das Intrecator-Antwortmodell enth√§lt die gew√ºnschte Kontaktliste. ViewModel enth√§lt auch ein Array von Daten, die zur Anzeige bereit sind - DisplayedContact. <br><br><h3>  Warum Swift reinigen? </h3><br>  Betrachten Sie die Vor- und Nachteile dieser Architektur.  Erstens verf√ºgt Clean Swift √ºber Codevorlagen, die das Erstellen eines Moduls erleichtern.  Diese Vorlagen k√∂nnen f√ºr viele Architekturen geschrieben werden, aber wenn sie sofort einsatzbereit sind, sparen Sie mindestens mehrere Stunden Zeit. <br><br>  Zweitens ist diese Architektur wie VIPER gut getestet, Beispiele f√ºr Tests sind im Projekt verf√ºgbar.  Da das Modul, mit dem die Interaktion stattfindet, leicht durch einen Stub ersetzt werden kann, k√∂nnen Sie dies durch Festlegen der Funktionalit√§t jedes Moduls mithilfe von Protokollen ohne Kopfschmerzen implementieren.  Wenn wir gleichzeitig die Gesch√§ftslogik und die entsprechenden Tests (Interactor, Interactor-Tests) erstellen, passt dies gut zum TDD-Prinzip.  Aufgrund der Tatsache, dass die Ausgabe und Eingabe jedes Logikfalls durch das Protokoll definiert wird, reicht es aus, zuerst einen Test zu schreiben, der sein Verhalten bestimmt, und dann die Logik der Methode direkt zu implementieren. <br><br>  Drittens implementiert Clean Swift (im Gegensatz zu VIPER) einen unidirektionalen Fluss der Datenverarbeitung und Entscheidungsfindung.  Es wird immer nur ein Zyklus ausgef√ºhrt - Ansicht - Interaktor - Pr√§sentator - Ansicht, was auch das Refactoring vereinfacht, da h√§ufig weniger Entit√§ten ge√§ndert werden m√ºssen.  Aus diesem Grund k√∂nnen Projekte mit Logik, die sich h√§ufig √§ndert oder erg√§nzt wird, mithilfe der Clean Swift-Methode bequemer umgestaltet werden.  Mit Clean Swift trennen Sie Entit√§ten auf zwei Arten: <br><br><ol><li>  Isolieren Sie Komponenten, indem Sie Eingabe- und Ausgabeprotokolle deklarieren </li><li>  Isolieren Sie Features, indem Sie Strukturen verwenden und Daten in separaten Anforderungen / Antworten / UI-Modellen kapseln.  Jedes Feature hat seine eigene Logik und wird im Rahmen eines Prozesses gesteuert, ohne sich in einem Modul mit anderen Features zu √ºberschneiden. </li></ol><br>  Clean Swift sollte nicht in kleinen Projekten ohne langfristige Perspektive oder in Prototypenprojekten verwendet werden.  Beispielsweise ist es zu teuer, eine Anwendung f√ºr den Zeitplan einer Entwicklerkonferenz unter Verwendung dieser Architektur zu implementieren.  Langfristige Projekte, Projekte mit viel Gesch√§ftslogik, passen dagegen gut in den Rahmen dieser Architektur.  Es ist sehr praktisch, Clean Swift zu verwenden, wenn das Projekt f√ºr zwei Plattformen implementiert ist - Mac OS und iOS, oder es ist geplant, es in Zukunft zu portieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415725/">https://habr.com/ru/post/de415725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415713/index.html">Aspektorientierte PHP-Programmierung</a></li>
<li><a href="../de415715/index.html">Die Geschichte des Zusammenbruchs und der wundersamen Rettung des Schimmels in KOMPAS-3D</a></li>
<li><a href="../de415717/index.html">Kann ich eine Lichtpistole f√ºr den LCD-Bildschirm herstellen? Kickstarter sammelt bereits Geld</a></li>
<li><a href="../de415721/index.html">Warum ben√∂tigt der Flaggschiff-Prozessor Top-Speicher? Testen des HyperX Fury DDR4-3466-Kits</a></li>
<li><a href="../de415723/index.html">Von Designern bis zur QS-Abteilung oder gibt es ein Leben nach der Fabrik</a></li>
<li><a href="../de415727/index.html">Eingebettet in die Dynamik des Kundenstamms: Kohortenanalyse und Flussanalyse</a></li>
<li><a href="../de415729/index.html">Einige Statistiken - Ubuntu-Entwickler haben zuerst Desktop-Telemetrie ver√∂ffentlicht</a></li>
<li><a href="../de415731/index.html">Bewertung Xiaomi Redmi Note 5 - Mid-Budget-Phablet mit Anspruch auf Originalit√§t</a></li>
<li><a href="../de415733/index.html">Information: Roskomsvoboda und seine Geschichte</a></li>
<li><a href="../de415735/index.html">Hardware-Codierung eines Videostreams auf einer Logitech C920-Kamera und Senden an ROS √ºber WLAN mit einer Verz√∂gerung von weniger als 0,2 Sekunden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>