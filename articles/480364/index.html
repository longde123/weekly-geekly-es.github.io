<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèë üßúüèø üåä Metaf√≠sica de la inyecci√≥n de dependencia üè≥Ô∏è ü•ì üë©üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La inyecci√≥n de dependencia es una t√©cnica de uso com√∫n en la programaci√≥n orientada a objetos dise√±ada para reducir la conectividad de componentes. C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metaf√≠sica de la inyecci√≥n de dependencia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480364/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/ha/dz/bphadz2idyr738uoocd_ykof4zm.png" alt="imagen"></div><br><br>  La inyecci√≥n de dependencia es una t√©cnica de uso com√∫n en la programaci√≥n orientada a objetos dise√±ada para reducir la conectividad de componentes.  Cuando se usa correctamente, adem√°s de lograr este objetivo, puede aportar cualidades verdaderamente m√°gicas a sus aplicaciones.  Como cualquier magia, esta t√©cnica se percibe como un conjunto de hechizos, y no como un tratado cient√≠fico riguroso.  Esto lleva a una mala interpretaci√≥n de los fen√≥menos y, como consecuencia, al mal uso de los artefactos.  En el material de mi autor, sugiero que el lector paso a paso, breve y esencialmente, siga el camino l√≥gico desde los fundamentos apropiados del dise√±o orientado a objetos hasta la magia de la inyecci√≥n autom√°tica de dependencia. <br><a name="habracut"></a><br>  El material se basa en el desarrollo del <a href="https://github.com/cylon-v/hypo" rel="nofollow">contenedor Hypo IoC</a> , que mencion√© en un <a href="https://habr.com/ru/post/474504/">art√≠culo anterior</a> .  En los ejemplos de c√≥digo en miniatura, usar√© Ruby como uno de los lenguajes orientados a objetos m√°s concisos para escribir ejemplos cortos.  Esto no deber√≠a causar problemas para que los desarrolladores en otros idiomas lo entiendan. <br><br><h2>  Nivel 1: Principio de inversi√≥n de dependencia </h2><br>  Los desarrolladores en el paradigma orientado a objetos se enfrentan a diario con la creaci√≥n de objetos, que, a su vez, pueden depender de otros objetos.  Esto lleva a un gr√°fico de dependencia.  Supongamos que estamos tratando con un modelo de objetos de la forma: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/b7/vy/ihb7vyogm2d5rt-ugz_udhskzpy.png" alt="imagen"></div><br>  - alg√∫n servicio de facturaci√≥n (InvoiceProcessor) y un servicio de notificaci√≥n (NotificationService).  El servicio de procesamiento de facturas env√≠a notificaciones cuando se cumplen ciertas condiciones, sacaremos esta l√≥gica del alcance.  En principio, este modelo ya es bueno porque los componentes individuales son responsables de diferentes responsabilidades.  El problema radica en c√≥mo implementamos estas dependencias.  Un error com√∫n es inicializar una dependencia donde se usa esta dependencia: <br><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#      notificationService = NotificationService.new notificationService.notify(invoice.owner) end end</span></span></span></span></code> </pre> <br>  Esto es un error en vista del hecho de que obtenemos una alta conectividad de objetos l√≥gicamente independientes (High Coupling).  Esto lleva a una violaci√≥n del Principio de Responsabilidad √önica: un objeto dependiente, adem√°s de sus responsabilidades inmediatas, debe inicializar sus dependencias;  y tambi√©n "conocer" la interfaz del constructor de dependencias, lo que dar√° lugar a una raz√≥n adicional para el cambio ( <a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="nofollow">"raz√≥n para cambiar", R. Martin</a> ).  Es m√°s correcto pasar este tipo de dependencia, inicializada fuera del objeto dependiente: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notify</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoiceProcessor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Este enfoque es consistente con el Principio de Inversi√≥n de Dependencia.  Ahora estamos transfiriendo un objeto con una interfaz de env√≠o de mensajes; ya no es necesario que el servicio de facturaci√≥n "sepa" c√≥mo construir el objeto del servicio de notificaci√≥n.  Al escribir pruebas unitarias para un servicio de procesamiento de facturas, el desarrollador no tiene que preguntarse c√≥mo reemplazar la implementaci√≥n de la interfaz del servicio de notificaciones con un c√≥digo auxiliar.  En idiomas con escritura din√°mica, como Ruby, puede sustituir cualquier objeto que cumpla con el m√©todo de notificaci√≥n;  con la escritura est√°tica, como C # / Java, puede usar la interfaz INotificationService, para lo cual es f√°cil crear un Mock.  ¬°El tema de la inversi√≥n de dependencia fue revelado en detalle por Alexander Byndyu <a href="https://blog.byndyu.ru/2009/12/blog-post.html" rel="nofollow">en un art√≠culo</a> que recientemente celebr√≥ su d√©cimo aniversario! <br><br><h2>  Nivel 2: registro de objetos relacionados </h2><br>  Usar el principio de inversi√≥n de dependencia no parece una pr√°ctica complicada.  Pero con el tiempo, debido a un aumento en el n√∫mero de objetos y relaciones, aparecen nuevos desaf√≠os.  NotificationService puede ser utilizado por otros servicios que no sean InvoiceProcessor.  Adem√°s, √©l mismo puede depender de otros servicios, que, a su vez, dependen de terceros, etc.  Adem√°s, algunos componentes no siempre se pueden usar en una sola copia.  La tarea principal es encontrar la respuesta a la pregunta: "¬øcu√°ndo crear dependencias?". <br>  Para resolver este problema, puede intentar crear una soluci√≥n basada en una matriz asociativa de dependencias.  Un ejemplo de interfaz de su trabajo podr√≠a verse as√≠: <br><br><pre> <code class="ruby hljs">registry.add(InvoiceProcessor) .depends_on(NotificationService) registry.add(NotificationService) .depends_on(ServiceX) invoiceProcessor = registry.resolve(InvoiceProcessor) invoiceProcessor.process(invoice)</code> </pre><br>  No es dif√≠cil de implementar en la pr√°ctica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/bj/v4/rdbjv49agcxw3fhhask4uv5ysew.png" alt="imagen"></div><br>  Cada vez que se llama a container.resolve (), nos dirigiremos a la f√°brica, que crear√° instancias de dependencia, evitando recursivamente el gr√°fico de dependencia descrito en el registro.  En el caso de `container.resolve (InvoiceProcessor)`, se ejecutar√° lo siguiente: <br><br><ol><li>  factory.resolve (InvoiceProcessor): la f√°brica solicita las dependencias de InvoiceProcessor en el registro, recibe un NotificationService, que tambi√©n debe ensamblarse. </li><li>  factory.resolve (NotificationService): la f√°brica solicita las dependencias de NotificationService en el registro, recibe ServiceX, que tambi√©n debe ensamblarse. </li><li>  factory.resolve (ServiceX): no tiene dependencias, crea, regresa a lo largo de la pila de llamadas al paso 1, obtiene un objeto ensamblado de tipo InvoiceProcessor. </li></ol><br>  Cada componente puede depender de varios otros, por lo que la pregunta obvia es "¬øc√≥mo hacer coincidir correctamente los par√°metros del dise√±ador con las instancias de dependencia resultantes?".  Un ejemplo: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">paymentService</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># ... end end</span></span></span></span></code> </pre><br>  En idiomas con escritura est√°tica, el tipo de par√°metro puede servir como selector: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(notificationService: NotificationService, paymentService: PaymentService) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Dentro de Ruby, puede usar la convenci√≥n: solo use el nombre del tipo en el formato snake_case, este ser√° el nombre del par√°metro esperado. <br><br><h2>  Nivel 3: gesti√≥n de dependencia de por vida </h2><br>  Ya tenemos una buena soluci√≥n de gesti√≥n de dependencias.  Su √∫nica limitaci√≥n es la necesidad de crear una nueva instancia de la dependencia con cada llamada.  Pero, ¬øqu√© pasa si no podemos crear m√°s de una instancia de un componente?  Por ejemplo, un grupo de conexiones a la base de datos.  ¬øProfundizar m√°s y si necesitamos proporcionar una vida controlada de dependencias?  Por ejemplo, cierre la conexi√≥n a la base de datos despu√©s de completar la solicitud HTTP. <br>  Se hace evidente que el candidato para el reemplazo en la soluci√≥n original es InstanceFactory.  Cuadro actualizado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/ed/xl/hfedxlxxnqjmm22oevtbwqrle2k.png" alt="imagen"></div><br>  Y la soluci√≥n l√≥gica es utilizar un conjunto de estrategias ( <a href="https://refactoring.guru/ru/design-patterns/strategy" rel="nofollow">Estrategia, GoF</a> ) para obtener instancias de componentes.  Ahora no siempre creamos nuevas instancias cuando llamamos a Container :: resolve, por lo que es apropiado cambiar el nombre de Factory a Resolver.  Tenga en cuenta que el m√©todo Container :: register tiene un nuevo par√°metro: life_time (curso de la vida).  Este par√°metro es opcional; de forma predeterminada, su valor es "transitorio" (transitorio), que corresponde al comportamiento implementado previamente.  La estrategia singleton tambi√©n es obvia: con su uso solo se crea una instancia del componente, que se devolver√° cada vez. <br>  El alcance es una estrategia un poco m√°s compleja.  En lugar de "caminos transitorios" y "solitarios", a menudo se requiere usar algo intermedio: un componente que existe a lo largo de la vida de otro componente.  Un ejemplo similar puede ser un objeto de solicitud de aplicaci√≥n web, que es el contexto de la existencia de objetos tales como, por ejemplo, par√°metros HTTP, conexi√≥n de base de datos, agregados de modelos.  A lo largo de la vida de la solicitud, recopilamos y usamos estas dependencias, y despu√©s de su destrucci√≥n, esperamos que todas ellas tambi√©n sean destruidas.  Para implementar dicha funcionalidad, ser√° necesario desarrollar una estructura de objeto cerrada bastante compleja: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vd/97/hh/vd97hhi_p41keoxph7ku9sdxrdm.png" alt="imagen"></div><br>  El diagrama muestra un fragmento que refleja los cambios en las clases Component y LifetimeStrategy en el contexto de la implementaci√≥n de la vida √∫til de Scoped.  El resultado fue una especie de "doble puente" (similar a la plantilla <a href="https://refactoring.guru/ru/design-patterns/bridge" rel="nofollow">Bridge, GoF</a> ).  Utilizando las complejidades de las t√©cnicas de herencia y agregaci√≥n, Component se convierte en el n√∫cleo del contenedor.  Por cierto, el diagrama tiene herencia m√∫ltiple.  Donde el lenguaje de programaci√≥n y la conciencia lo permitan, puede dejarlo as√≠.  En Ruby utilizo impurezas, en otros idiomas puedes reemplazar la herencia con otro puente: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/dj/h7/ridjh7shgaolxp_mxujgvkueta4.png" alt="imagen"></div><br>  El diagrama de secuencia muestra el ciclo de vida del componente de sesi√≥n, que est√° vinculado a la vida √∫til del componente de solicitud: <br><br><img src="https://habrastorage.org/webt/-c/im/bt/-cimbtr3sktosriryzoyrtqxht4.png" alt="imagen"><br><br>  Como puede ver en el diagrama, en un momento determinado, cuando el componente de solicitud completa su misi√≥n, se llama al m√©todo de liberaci√≥n, que inicia el proceso de destrucci√≥n del alcance. <br><br><h2>  Nivel 4: Inyecci√≥n de dependencia </h2><br>  Hasta ahora, habl√© sobre c√≥mo determinar el registro de dependencias, y luego c√≥mo crear y destruir componentes de acuerdo con el gr√°fico de las relaciones formadas.  ¬øY para qu√© sirve?  Supongamos que usamos esto como parte de Ruby on Rails: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceRepository</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">]) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  El c√≥digo que se escribir√° de esta manera no ser√° m√°s legible, comprobable o flexible.  No podemos "forzar" a Rails a inyectar dependencias de controlador a trav√©s de su constructor, esto no lo proporciona el marco.  Pero, por ejemplo, en ASP.NET MVC esto se implementa en un nivel b√°sico.  Para aprovechar al m√°ximo el mecanismo de resoluci√≥n autom√°tica de dependencias, debe implementar la t√©cnica de Inversi√≥n de control (IoC, inversi√≥n de control).  Este es un enfoque en el que la responsabilidad de resolver dependencias va m√°s all√° del alcance del c√≥digo de la aplicaci√≥n y recae en el marco.  Considera un ejemplo. <br>  Imagine que estamos dise√±ando algo como Rails desde cero.  Implementamos el siguiente esquema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/bg/bh/y1bgbh_27yevoryv4ntb58nej9w.png" alt="imagen"></div><br>  La aplicaci√≥n recibe la solicitud, el enrutador recupera los par√°metros e indica al controlador apropiado que procese esta solicitud.  Tal esquema copia condicionalmente el comportamiento de un marco web t√≠pico con solo una peque√±a diferencia: el contenedor de IoC est√° involucrado en la creaci√≥n e implementaci√≥n de dependencias.  Pero aqu√≠ surge la pregunta, ¬ød√≥nde se crea el contenedor?  Para cubrir tantos objetos de la aplicaci√≥n futura como sea posible, nuestro marco debe crear un contenedor en la etapa inicial de su operaci√≥n.  Obviamente, no hay un lugar m√°s adecuado que la aplicaci√≥n de creaci√≥n de aplicaciones.  Tambi√©n es el lugar m√°s adecuado para configurar todas las dependencias: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   - ,      . def initialize </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = Container.new </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Controller) .using_lifetime(:transient) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(InvoiceService) .using_lifetime(:singleton) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Router) .using_lifetime(:singleton) #  end #     -     , #      . def call(env) router = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.resolve(Router) router.handle(env.path, env.method, env.params) end end</span></span></span></span></code> </pre><br>  Cualquier aplicaci√≥n tiene un punto de entrada, por ejemplo, el m√©todo principal.  En este ejemplo, el punto de entrada es el m√©todo de llamada.  El objetivo de este m√©todo es llamar al enrutador para procesar las solicitudes entrantes.  El punto de entrada debe ser el √∫nico lugar para llamar al contenedor directamente; desde ese momento, el contenedor debe dejarse de lado, toda la magia posterior debe ocurrir "debajo del cap√≥".  La implementaci√≥n del controlador dentro de dicha arquitectura realmente parece inusual.  A pesar de que no lo instanciamos expl√≠citamente, tiene un constructor con par√°metros: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   . #    . def initialize(invoice_service) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service = invoice_service end def create_invoice(params) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service.create(params) end end</span></span></span></span></code> </pre><br>  El entorno "comprende" c√≥mo crear instancias de controlador.  Esto es posible gracias al mecanismo de inyecci√≥n de dependencia proporcionado por el contenedor IoC integrado en el coraz√≥n de la aplicaci√≥n web.  En el constructor del controlador, ahora puede enumerar todo lo que se requiere para su funcionamiento.  Lo principal es que los componentes correspondientes est√°n registrados en el contenedor.  Ahora pasemos a la implementaci√≥n del enrutador: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#         -  #      #     . def initialize(controller) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = controller end def handle(path, method, params) #  ""- if path == '/invoices' &amp;&amp; method == 'POST' </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.create(params) end end end</span></span></span></span></code> </pre><br>  Tenga en cuenta que el enrutador depende del controlador.  Si recordamos la configuraci√≥n de dependencia, entonces Controller es un componente de corta duraci√≥n y Router es un solitario constante.  ¬øC√≥mo puede ser esto?  La respuesta es que los componentes no son instancias de las clases correspondientes, como se ve externamente.  De hecho, estos son objetos proxy ( <a href="https://refactoring.guru/ru/design-patterns/proxy" rel="nofollow">Proxy, GoF</a> ) con la instancia del m√©todo de f√°brica ( <a href="https://refactoring.guru/ru/design-patterns/factory-method" rel="nofollow">M√©todo de f√°brica, GoF</a> );  devuelven una instancia del componente de acuerdo con la estrategia asignada.  Como el controlador est√° registrado como "transitorio", el enrutador siempre se ocupar√° de su nueva instancia cuando se acceda a √©l.  El diagrama de secuencia muestra un mecanismo aproximado de trabajo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/ng/1y/tlng1yrikuvxkenacsx-gy0x7mu.png" alt="imagen"></div><br>  Es decir  Adem√°s de la gesti√≥n de dependencias, un buen marco basado en un contenedor de IoC tambi√©n se responsabiliza de la gesti√≥n correcta de la vida √∫til de los componentes. <br><br><h2>  Conclusi√≥n </h2><br>  La t√©cnica de inyecci√≥n de dependencia puede tener una implementaci√≥n interna bastante sofisticada.  Este es el precio de transferir la complejidad de implementar aplicaciones flexibles al n√∫cleo del marco.  El usuario de dichos marcos no puede preocuparse por los aspectos puramente t√©cnicos, sino dedicar m√°s tiempo al desarrollo c√≥modo de la l√≥gica empresarial de los programas de aplicaci√≥n.  Usando una implementaci√≥n DI de alta calidad, un programador de aplicaciones inicialmente escribe c√≥digo comprobable y bien soportado.  Un buen ejemplo de la implementaci√≥n de la inyecci√≥n de dependencia es el marco <a href="https://github.com/cylon-v/dandy" rel="nofollow">Dandy</a> descrito en mi art√≠culo anterior <a href="https://habr.com/ru/post/474504/">Orthodox Backend</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480364/">https://habr.com/ru/post/480364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480350/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 326 (del 9 al 15 de diciembre)</a></li>
<li><a href="../480352/index.html">El genetista de Harvard desarrolla la aplicaci√≥n de dataci√≥n de an√°lisis de ADN prototipo</a></li>
<li><a href="../480356/index.html">Consejos √∫tiles de Python que no has conocido</a></li>
<li><a href="../480358/index.html">El precio oculto de las bibliotecas CSS-in-JS en las aplicaciones React</a></li>
<li><a href="../480362/index.html">Aventuras del hexafluoruro de uranio empobrecido alem√°n en Rusia. Parte 1. Historia y tecnolog√≠as de enriquecimiento.</a></li>
<li><a href="../480368/index.html">Captura de p√©rdidas de memoria en C / C ++</a></li>
<li><a href="../480370/index.html">Conferencia DEFCON 19. Los jefes adoran Excel, los hackers tambi√©n</a></li>
<li><a href="../480374/index.html">DogBot de React Robotics persigue la revoluci√≥n en la industria de la construcci√≥n</a></li>
<li><a href="../480376/index.html">Desde juegos de computadora hasta mensajes secretos: discuta los huevos de Pascua en lanzamientos de vinilo</a></li>
<li><a href="../480378/index.html">14 proyectos de c√≥digo abierto para bombear habilidades de ciencia de datos (f√°cil, normal, dif√≠cil)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>