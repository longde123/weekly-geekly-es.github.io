<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚úàÔ∏è üçñ ‚ò£Ô∏è Kreuzreplikation zwischen PostgreSQL und MySQL üë®üèΩ‚Äçüíª üëÇüèø üì∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich werde die Kreuzreplikation zwischen PostgreSQL und MySQL sowie die Methoden zum Einrichten der Kreuzreplikation zwischen diesen beiden Datenbankse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kreuzreplikation zwischen PostgreSQL und MySQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/467313/"><p><img src="https://habrastorage.org/webt/ze/m9/h6/zem9h6cpvow7junwu4saxpddvpa.jpeg"></p><br><p>  Ich werde die Kreuzreplikation zwischen PostgreSQL und MySQL sowie die Methoden zum Einrichten der Kreuzreplikation zwischen diesen beiden Datenbankservern skizzieren.  In der Regel werden replikations√ºbergreifende Datenbanken als homogen bezeichnet. Dies ist eine bequeme Methode, um von einem relationalen Datenbankserver auf einen anderen zu wechseln. </p><br><p>  PostgreSQL- und MySQL-Datenbanken gelten als relational, bieten jedoch mit zus√§tzlichen Erweiterungen NoSQL-Funktionen.  Hier werden wir die Replikation zwischen PostgreSQL und MySQL im Hinblick auf relationales DBMS diskutieren. </p><br><p>  Wir werden nicht die gesamte innere K√ºche beschreiben, sondern nur die Grundprinzipien, damit Sie eine Vorstellung davon bekommen, wie die Replikation zwischen Datenbankservern konfiguriert wird, welche Vorteile, Einschr√§nkungen und Anwendungsf√§lle es gibt. </p><a name="habracut"></a><br><p>  In der Regel wird die Replikation zwischen zwei identischen Datenbankservern entweder im Bin√§rmodus oder √ºber Anforderungen zwischen dem Masterknoten (Herausgeber, Master oder Aktiv) und dem Slave (Abonnent, anstehend oder passiv) durchgef√ºhrt.  Der Zweck der Replikation besteht darin, eine Echtzeitkopie der Master-Datenbank auf der Slave-Seite bereitzustellen.  In diesem Fall werden Daten vom Master zum Slave √ºbertragen, dh von aktiv zu passiv, da die Replikation nur in eine Richtung erfolgt.  Sie k√∂nnen jedoch die Replikation zwischen zwei Datenbanken in beide Richtungen konfigurieren, sodass in der Aktiv-Aktiv-Konfiguration Daten vom Slave zum Master √ºbertragen werden.  All dies, einschlie√ülich der kaskadierenden Replikation, m√∂glicherweise zwischen zwei oder mehr identischen Datenbankservern. Die Aktiv-Aktiv- oder Aktiv-Passiv-Konfiguration h√§ngt von der Notwendigkeit, der Verf√ºgbarkeit solcher Funktionen in der Erstkonfiguration oder der Verwendung externer Konfigurationsl√∂sungen und vorhandenen Kompromissen ab. . </p><br><p> Die beschriebene Konfiguration ist zwischen verschiedenen Datenbankservern m√∂glich.  Der Server kann so konfiguriert werden, dass er replizierte Daten von einem anderen Datenbankserver empf√§ngt und dennoch Snapshots der replizierten Daten in Echtzeit speichert.  MySQL und PostgreSQL bieten die meisten dieser Konfigurationen einzeln oder mit Erweiterungen von Drittanbietern an, einschlie√ülich bin√§rer Protokollmethoden, Festplattensperren sowie auf Anweisungen und Zeichenfolgen basierenden Methoden. </p><br><p>  F√ºr eine einzelne Migration von einem Datenbankserver auf einen anderen ist eine Kreuzreplikation zwischen MySQL und PostgreSQL erforderlich.  Diese Datenbanken verwenden unterschiedliche Protokolle, sodass sie nicht direkt verbunden werden k√∂nnen.  Um den Datenaustausch einzurichten, k√∂nnen Sie ein externes Open Source-Tool verwenden, z. B. pg_chameleon. </p><br><h3 id="chto-takoe-pg_chameleon">  Was ist pg_chameleon? </h3><br><p>  pg_chameleon ist ein Replikationssystem von MySQL nach PostgreSQL in Python 3. Es verwendet die Open-Source-Bibliothek mysql-replication, ebenfalls in Python.  Zeichenfolgenbilder werden aus MySQL-Tabellen extrahiert und als JSONB-Objekte in der PostgreSQL-Datenbank gespeichert. Anschlie√üend werden sie mit der Funktion pl / pgsql entschl√ºsselt und in der PostgreSQL-Datenbank wiedergegeben. </p><br><h3 id="vozmozhnosti-pg_chameleon">  Pg_chameleon-Funktionen </h3><br><p>  Mehrere MySQL-Schemas aus demselben Cluster k√∂nnen mit einer Eins-zu-Viele-Konfiguration auf dieselbe PostgreSQL-Zieldatenbank repliziert werden <br>  Die Namen der Quell- und Zielschemata k√∂nnen nicht √ºbereinstimmen. <br>  Replikationsdaten k√∂nnen von einem kaskadierten MySQL-Replikat abgerufen werden. <br>  Tabellen, die keine Fehler replizieren oder generieren k√∂nnen, werden ausgeschlossen. <br>  Jede Replikationsfunktion wird von D√§monen gesteuert. <br>  Steuerung √ºber Parameter und Konfigurationsdateien basierend auf YAML. </p><br><h3 id="primer">  Beispiel </h3><br><div class="scrollable-table"><table><thead><tr><th>  Host </th><th>  vm1 </th><th>  vm2 </th></tr></thead><tbody><tr><td>  <strong>Betriebssystemversion</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.5 x86_64 </td></tr><tr><td>  <strong>DB Server Version</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>DB-Port</strong> </td><td>  3306 </td><td>  5433 </td></tr><tr><td>  <strong>IP-Adresse</strong> </td><td>  192.168.56.102 </td><td>  192.168.56.106 </td></tr></tbody></table></div><br><p>  Bereiten Sie zun√§chst alle erforderlichen Komponenten f√ºr die Installation von pg_chameleon vor.  In diesem Beispiel wird Python 3.6.8 installiert, das eine virtuelle Umgebung erstellt und aktiviert. </p><br><pre><code class="plaintext hljs">$&gt; wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz $&gt; tar -xJf Python-3.6.8.tar.xz $&gt; cd Python-3.6.8 $&gt; ./configure --enable-optimizations $&gt; make altinstall</code> </pre> <br><p>  Nach der erfolgreichen Installation von Python3.6 m√ºssen Sie die anderen Anforderungen erf√ºllen, z. B. eine virtuelle Umgebung erstellen und aktivieren.  Dar√ºber hinaus wird das Pip-Modul auf die neueste Version aktualisiert und zur Installation von pg_chameleon verwendet.  In den folgenden Befehlen wird pg_chameleon 2.0.9 absichtlich installiert, obwohl die neueste Version 2.0.10 ist.  Dies ist erforderlich, um neue Fehler in der aktualisierten Version zu vermeiden. </p><br><pre> <code class="plaintext hljs">$&gt; python3.6 -m venv venv $&gt; source venv/bin/activate (venv) $&gt; pip install pip --upgrade (venv) $&gt; pip install pg_chameleon==2.0.9</code> </pre> <br><p>  Dann rufen wir pg_chameleon (Chameleon ist ein Befehl) mit dem Argument set_configuration_files auf, um pg_chameleon zu aktivieren und Standardverzeichnisse und Konfigurationsdateien zu erstellen. </p><br><pre> <code class="plaintext hljs">(venv) $&gt; chameleon set_configuration_files creating directory /root/.pg_chameleon creating directory /root/.pg_chameleon/configuration/ creating directory /root/.pg_chameleon/logs/ creating directory /root/.pg_chameleon/pid/ copying configuration example in /root/.pg_chameleon/configuration//config-example.yml</code> </pre> <br><p>  Jetzt erstellen wir eine Kopie von config-example.yml als default.yml, damit es zur Standardkonfigurationsdatei wird.  Eine Beispielkonfigurationsdatei f√ºr dieses Beispiel ist unten dargestellt. </p><br><pre> <code class="plaintext hljs">$&gt; cat default.yml --- #global settings pid_dir: '~/.pg_chameleon/pid/' log_dir: '~/.pg_chameleon/logs/' log_dest: file log_level: info log_days_keep: 10 rollbar_key: '' rollbar_env: '' # type_override allows the user to override the default type conversion into a different one. type_override: "tinyint(1)": override_to: boolean override_tables: - "*" #postgres destination connection pg_conn: host: "192.168.56.106" port: "5433" user: "usr_replica" password: "pass123" database: "db_replica" charset: "utf8" sources: mysql: db_conn: host: "192.168.56.102" port: "3306" user: "usr_replica" password: "pass123" charset: 'utf8' connect_timeout: 10 schema_mappings: world_x: pgworld_x limit_tables: # - delphis_mediterranea.foo skip_tables: # - delphis_mediterranea.bar grant_select_to: - usr_readonly lock_timeout: "120s" my_server_id: 100 replica_batch_size: 10000 replay_max_rows: 10000 batch_retention: '1 day' copy_max_memory: "300M" copy_mode: 'file' out_dir: /tmp sleep_loop: 1 on_error_replay: continue on_error_read: continue auto_maintenance: "disabled" gtid_enable: No type: mysql skip_events: insert: - delphis_mediterranea.foo #skips inserts on the table delphis_mediterranea.foo delete: - delphis_mediterranea #skips deletes on schema delphis_mediterranea update:</code> </pre> <br><p>  Die Konfigurationsdatei in diesem Beispiel ist eine Beispieldatei mit pg_chameleon mit geringf√ºgigen √Ñnderungen je nach Quell- und Zielumgebung. Im Folgenden finden Sie eine √úbersicht √ºber die verschiedenen Abschnitte der Konfigurationsdatei. </p><br><p>  In der Konfigurationsdatei default.yml gibt es einen Abschnitt mit globalen Einstellungen, in dem Sie Einstellungen wie den Speicherort der Sperrdatei, den Speicherort der Protokolle, den Speicherzeitraum der Protokolle usw. steuern k√∂nnen. Der n√§chste Abschnitt ist der Abschnitt zum √úberschreiben von Typen, in dem der Satz angegeben wird Regeln zum √úberschreiben von Typen w√§hrend der Replikation.  Das Standardbeispiel verwendet eine Typ-Neudefinitionsregel, die tinyint (1) in einen booleschen Wert konvertiert.  Im n√§chsten Abschnitt geben wir die Details zum Herstellen einer Verbindung zur Zieldatenbank an.  In unserem Fall ist dies eine PostgreSQL-Datenbank mit der Bezeichnung pg_conn.  Im letzten Abschnitt geben wir die Quelldaten an, dh die Verbindungsparameter der Quellendatenbank, das Zuordnungsschema der Quell- und Zieldatenbanken, die zu √ºberspringenden Tabellen, das Zeitlimit, den Speicher und die Paketgr√∂√üe.  Beachten Sie, dass "Quellen" im Plural angegeben ist. Das hei√üt, wir k√∂nnen mehrere Quellendatenbanken f√ºr dasselbe Ziel hinzuf√ºgen, um die Viele-zu-Eins-Konfiguration zu konfigurieren. </p><br><p>  Die world_x-Datenbank im Beispiel enth√§lt 4 Tabellen mit Zeilen, die die MySQL-Community f√ºr das Beispiel anbietet.  Es kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Die Beispieldatenbank besteht aus tar und einem komprimierten Archiv mit Anweisungen zum Erstellen und Importieren von Zeichenfolgen. </p><br><p>  In den MySQL- und PostgreSQL-Datenbanken mit dem gleichen Namen usr_replica wird ein spezieller Benutzer erstellt.  In MySQL erh√§lt er zus√§tzliche Rechte zum Lesen aller replizierten Tabellen. </p><br><pre> <code class="plaintext hljs">mysql&gt; CREATE USER usr_replica ; mysql&gt; SET PASSWORD FOR usr_replica='pass123'; mysql&gt; GRANT ALL ON world_x.* TO 'usr_replica'; mysql&gt; GRANT RELOAD ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION CLIENT ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION SLAVE ON *.* to 'usr_replica'; mysql&gt; FLUSH PRIVILEGES;</code> </pre> <br><p>  Auf der PostgreSQL-Seite wird die Datenbank db_replica erstellt, die √Ñnderungen aus der MySQL-Datenbank akzeptiert.  Der Benutzer usr_replica von PostgreSQL wird automatisch als Eigent√ºmer von zwei Schemas pgworld_x und sch_chameleon konfiguriert, die tats√§chlich replizierte Tabellen bzw. Tabellen mit Replikationsverzeichnissen enthalten.  Das Argument create_replica_schema ist f√ºr die automatische Konfiguration verantwortlich, wie Sie unten sehen werden. </p><br><pre> <code class="plaintext hljs">postgres=# CREATE USER usr_replica WITH PASSWORD 'pass123'; CREATE ROLE postgres=# CREATE DATABASE db_replica WITH OWNER usr_replica; CREATE DATABASE</code> </pre> <br><p>  Die MySQL-Datenbank ist mit einigen √Ñnderungen konfiguriert, um sie f√ºr die Replikation vorzubereiten, wie unten gezeigt.  Sie m√ºssen den Datenbankserver neu starten, damit die √Ñnderungen wirksam werden. </p><br><pre> <code class="plaintext hljs">$&gt; vi /etc/my.cnf binlog_format= ROW binlog_row_image=FULL log-bin = mysql-bin server-id = 1</code> </pre> <br><p>  Jetzt ist es wichtig, die Verbindung zu beiden Datenbankservern zu √ºberpr√ºfen, damit beim Ausf√ºhren von pg_chameleon-Befehlen keine Probleme auftreten. </p><br><p>  Auf dem PostgreSQL-Knoten: </p><br><pre> <code class="plaintext hljs">$&gt; mysql -u usr_replica -Ap'admin123' -h 192.168.56.102 -D world_x</code> </pre> <br><p>  Auf dem MySQL-Knoten: </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -h 192.168.56.106 db_replica</code> </pre> <br><p>  Die folgenden drei Befehle pg_chameleon (Chameleon) bereiten die Umgebung vor, f√ºgen die Quelle hinzu und initialisieren das Replikat.  Das Argument create_replica_schema in pg_chameleon erstellt, wie bereits erw√§hnt, das Standardschema (sch_chameleon) und das Replikationsschema (pgworld_x) in der PostgreSQL-Datenbank.  Das Argument add_source f√ºgt der Konfiguration die urspr√ºngliche Datenbank hinzu, indem es die Konfigurationsdatei (default.yml) liest. In unserem Fall ist es mysql, und init_replica initialisiert die Konfiguration basierend auf den Parametern in der Konfigurationsdatei. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon create_replica_schema --debug $&gt; chameleon add_source --config default --source mysql --debug $&gt; chameleon init_replica --config default --source mysql --debug</code> </pre> <br><p>  Die Ausgabe dieser drei Befehle zeigt offensichtlich ihre erfolgreiche Ausf√ºhrung an.  Alle Abst√ºrze oder Syntaxfehler werden in einfachen und √ºbersichtlichen Meldungen mit Tipps zur Fehlerbehebung angezeigt. </p><br><p>  Starten Sie schlie√ülich die Replikation mit start_replica und erhalten Sie eine Erfolgsmeldung. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon start_replica --config default --source mysql output: Starting the replica process for source mysql</code> </pre> <br><p>  Der Replikationsstatus kann mit dem Argument show_status angefordert werden, und Fehler k√∂nnen mit dem Argument show_errors angezeigt werden. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnis.</a> </p><br><p>  Wie bereits erw√§hnt, wird jede Replikationsfunktion von D√§monen gesteuert.  Um sie anzuzeigen, fragen wir die Prozesstabelle mit dem Linux-Befehl ps ab, wie unten gezeigt. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnis.</a> </p><br><p>  Die Replikation wird erst dann als konfiguriert betrachtet, wenn wir sie in Echtzeit testen (siehe unten).  Wir erstellen eine Tabelle, f√ºgen einige Datens√§tze in die MySQL-Datenbank ein und rufen das Argument sync_tables in pg_chameleon auf, um die Daemons zu aktualisieren und die Tabelle mit den Datens√§tzen in der PostgreSQL-Datenbank zu replizieren. </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (n1 int primary key, n2 varchar(10)); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into t1 values (1,'one'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t1 values (2,'two'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">$&gt; chameleon sync_tables --tables world_x.t1 --config default --source mysql Sync tables process for source mysql started.</code> </pre> <br><p>  Um die Testergebnisse zu best√§tigen, fragen wir die Tabelle aus der PostgreSQL-Datenbank ab und zeigen die Zeilen an. </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -d db_replica -c "select * from pgworld_x.t1"; n1 | n2 ----+------- 1 | one 2 | two</code> </pre> <br><p>  Wenn wir die Migration durchf√ºhren, werden die folgenden pg_chameleon-Befehle beendet.  Die Befehle m√ºssen ausgef√ºhrt werden, nachdem sichergestellt wurde, dass die Zeilen aller Zieltabellen repliziert wurden. Das Ergebnis ist eine sauber migrierte PostgreSQL-Datenbank ohne Verweis auf die urspr√ºngliche Datenbank oder das Replikationsschema (sch_chameleon). </p><br><pre> <code class="plaintext hljs">$&gt; chameleon stop_replica --config default --source mysql $&gt; chameleon detach_replica --config default --source mysql --debug</code> </pre> <br><p>  Falls gew√ºnscht, k√∂nnen die folgenden Befehle das urspr√ºngliche Konfigurations- und Replikationsschema entfernen. </p><br><pre> <code class="plaintext hljs">$&gt; chameleon drop_source --config default --source mysql --debug $&gt; chameleon drop_replica_schema --config default --source mysql --debug</code> </pre> <br><h3 id="preimuschestva-pg_chameleon">  Vorteile von pg_chameleon </h3><br><p>  Einfache Einrichtung und Konfiguration. <br>  Bequeme Fehlerbehebung und Erkennung von Anomalien mit eindeutigen Fehlermeldungen. <br>  Sie k√∂nnen der Replikation nach der Initialisierung zus√§tzliche spezielle Tabellen hinzuf√ºgen, ohne den Rest der Konfiguration zu √§ndern. <br>  Sie k√∂nnen mehrere Quelldatenbanken f√ºr ein Ziel konfigurieren. Dies ist sehr praktisch, wenn Sie Daten aus einer oder mehreren MySQL-Datenbanken in einer PostgreSQL-Datenbank kombinieren. <br>  Sie k√∂nnen ausgew√§hlte Tabellen nicht replizieren. </p><br><h3 id="nedostatki-pg_chameleon">  Nachteile von pg_chameleon </h3><br><p>  Wird nur mit MySQL 5.5 und h√∂her als Quelle und PostgreSQL 9.5 und h√∂her als Zieldatenbank unterst√ºtzt. <br>  Jede Tabelle muss einen Prim√§r- oder eindeutigen Schl√ºssel haben, andernfalls werden die Tabellen im Prozess init_replica initialisiert, aber nicht repliziert. <br>  Einwegreplikation - nur von MySQL nach PostgreSQL.  Daher ist es nur f√ºr das Aktiv-Passiv-Schema geeignet. <br>  Nur die MySQL-Datenbank kann die Quelle sein, und die Unterst√ºtzung f√ºr die PostgreSQL-Datenbank ist nur experimentell und mit Einschr√§nkungen (weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). </p><br><h3 id="itogi-po-pg_chameleon">  Pg_chameleon Ergebnisse </h3><br><p>  Die Replikationsmethode in pg_chameleon eignet sich hervorragend f√ºr die Migration einer Datenbank von MySQL nach PostgreSQL.  Ein wesentliches Minus ist, dass die Replikation nur in eine Richtung erfolgt, sodass Datenbankexperten sie wahrscheinlich nicht f√ºr andere Zwecke als f√ºr die Migration verwenden m√∂chten.  Das Problem der Einwegreplikation kann jedoch durch ein anderes Open-Source-Tool gel√∂st werden - SymmetricDS. </p><br><p>  Lesen Sie hier mehr in der offiziellen Dokumentation.  Hilfe in der Kommandozeile finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://pgchameleon.org/documents/usage.html&amp;usg=ALkJrhjpITCCo02McUYxctXbBQWEVK80yQ#">hier</a> . </p><br><h3 id="obzor-symmetricds">  SymmetricDS-√úbersicht </h3><br><p>  SymmetricDS ist ein Open Source-Tool, das jede Datenbank in eine andere g√§ngige Datenbank repliziert: Oracle, MongoDB, PostgreSQL, MySQL, SQL Server, MariaDB, DB2, Sybase, Greenplum, Informix, H2, Firebird und andere Cloud-Datenbankinstanzen Redshift und Azure usw. Verf√ºgbare Funktionen: Synchronisierung von Datenbanken und Dateien, Replikation mehrerer f√ºhrender Datenbanken, gefilterte Synchronisierung, Konvertierung und andere.  Dies ist ein Java-Tool und erfordert eine Standardversion von JRE oder JDK (Version 8.0 oder h√∂her).  Hier k√∂nnen Sie Daten√§nderungen an Triggern in der Quellendatenbank aufzeichnen und in Form von Paketen an die entsprechende Zieldatenbank senden. </p><br><h3 id="vozmozhnosti-symmetricds">  SymmetricDS-Funktionen </h3><br><p>  Das Tool ist plattformunabh√§ngig, dh zwei oder mehr verschiedene Datenbanken k√∂nnen Daten austauschen. <br>  Relationale Datenbanken werden durch Schreiben von Daten√§nderungen synchronisiert, und dateisystembasierte Datenbanken verwenden die Dateisynchronisierung. <br>  Zweiwege-Replikation mit den Push- und Pull-Methoden basierend auf einer Reihe von Regeln. <br>  Die Daten√ºbertragung ist √ºber sichere Netzwerke und Netzwerke mit geringer Bandbreite m√∂glich. <br>  Automatische Wiederherstellung, wenn Knoten nach einem Fehler wieder aufgenommen werden, und automatische Konfliktl√∂sung. <br>  Cloud-kompatible und leistungsstarke Erweiterungs-APIs. </p><br><h3 id="primer-1">  Beispiel </h3><br><p>  SymmetricDS kann auf zwei Arten konfiguriert werden: <br>  Ein Masterknoten (Elternknoten), der die Datenreplikation zwischen zwei Slaveknoten (Kindknoten) zentral koordiniert, und der Datenaustausch zwischen Kindknoten wird nur √ºber den Elternknoten ausgef√ºhrt. <br>  Der aktive Knoten (Knoten 1) kann ohne Zwischenh√§ndler Daten zur Replikation mit einem anderen aktiven Knoten (Knoten 2) austauschen. </p><br><p>  In beiden F√§llen werden Daten per Push und Pull ausgetauscht.  In diesem Beispiel sehen wir uns die Aktiv-Aktiv-Konfiguration an.  Beschreiben Sie die gesamte Architektur zu lange. Lesen Sie daher die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> , um mehr √ºber SymmetricDS zu erfahren. </p><br><p>  Die Installation von SymmetricDS ist sehr einfach: Laden Sie die Open Source-Version der Zip-Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> herunter und extrahieren Sie sie, wo immer Sie m√∂chten.  Die folgende Tabelle enth√§lt Informationen zum Installationsort und zur Version von SymmetricDS in diesem Beispiel sowie zu Datenbankversionen, Linux-Versionen, IP-Adressen und Ports f√ºr beide Knoten. </p><br><div class="scrollable-table"><table><thead><tr><th>  Host </th><th>  vm1 </th><th>  vm2 </th></tr></thead><tbody><tr><td>  <strong>Betriebssystemversion</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.6 x86_64 </td></tr><tr><td>  <strong>DB Server Version</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>DB-Port</strong> </td><td>  3306 </td><td>  5832 </td></tr><tr><td>  <strong>IP-Adresse</strong> </td><td>  192.168.1.107 </td><td>  192.168.1.112 </td></tr><tr><td>  <strong>SymmetricDS-Version</strong> </td><td>  SymmetricDS 3.9 </td><td>  SymmetricDS 3.9 </td></tr><tr><td>  <strong>SymmetricDS-Installationspfad</strong> </td><td>  /usr/local/symmetric-server-3.9.20 </td><td>  /usr/local/symmetric-server-3.9.20 </td></tr><tr><td>  <strong>SymmetricDS-Knotenname</strong> </td><td>  corp-000 </td><td>  store-001 </td></tr></tbody></table></div><br><p>  Hier installieren wir SymmetricDS in /usr/local/symmetric-server-3.9.20, und verschiedene Unterverzeichnisse und Dateien werden genau dort gespeichert.  Wir interessieren uns f√ºr die verschachtelten Verzeichnisse, Beispiele und Engines.  Das Beispielverzeichnis enth√§lt Beispielkonfigurationsdateien mit Host-Eigenschaften sowie Beispiel-SQL-Skripte, um die Demonstration schnell zu starten. </p><br><p>  Im Beispielverzeichnis sehen wir drei Konfigurationsdateien mit Knoteneigenschaften - der Name zeigt die Art des Knotens in einem bestimmten Schema. </p><br><pre> <code class="plaintext hljs">corp-000.properties store-001.properties store-002.properties</code> </pre> <br><p>  SymmetricDS verf√ºgt √ºber alle erforderlichen Konfigurationsdateien f√ºr ein 3-Knoten-Basisschema (Option 1), und dieselben Dateien k√∂nnen f√ºr ein 2-Knoten-Schema verwendet werden (Option 2).  Kopieren Sie die gew√ºnschte Konfigurationsdatei aus dem Beispielverzeichnis in die Engines auf dem VM1-Host.  Es stellt sich so heraus: </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/corp-000.properties engine.name=corp-000 db.driver=com.mysql.jdbc.Driver db.url=jdbc:mysql://192.168.1.107:3306/replica_db?autoReconnect=true&amp;useSSL=false db.user=root db.password=admin123 registration.url= sync.url=http://192.168.1.107:31415/sync/corp-000 group.id=corp external.id=000</code> </pre> <br><p>  Dieser Knoten in der SymmetricDS-Konfiguration hei√üt corp-000, und die Datenbankverbindung wird vom mysql jdbc-Treiber verarbeitet, der die oben angegebene Verbindungszeichenfolge und die Anmeldeinformationen verwendet.  Wir stellen eine Verbindung zur Datenbank replica_db her und Tabellen werden w√§hrend der Erstellung des Schemas erstellt.  sync.url zeigt den Ort der Kommunikation mit dem Knoten f√ºr die Synchronisation. </p><br><p>  Knoten 2 auf dem VM2-Host ist als Speicher-001 konfiguriert, und der Rest ist in der folgenden Datei node.properties angegeben.  Auf dem Knoten store-001 wird die PostgreSQL-Datenbank ausgef√ºhrt, und pgdb_replica ist die Datenbank f√ºr die Replikation.  Mit register.url kann der vm2-Host den vm1-Host kontaktieren und Konfigurationsdetails von ihm abrufen. </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/store-001.properties engine.name=store-001 db.driver=org.postgresql.Driver db.url=jdbc:postgresql://192.168.1.112:5832/pgdb_replica db.user=postgres db.password=admin123 registration.url=http://192.168.1.107:31415/sync/corp-000 group.id=store external.id=001</code> </pre> <br><p>  Das vorgefertigte Beispiel f√ºr SymmetricDS enth√§lt Optionen zum Einrichten der bidirektionalen Replikation zwischen zwei Datenbankservern (zwei Knoten).  Die folgenden Schritte werden auf dem vm1-Host (corp-000) ausgef√ºhrt, wodurch ein Beispielschema mit 4 Tabellen erstellt wird.  Wenn Sie dann create-sym-tables mit dem Befehl symadmin ausf√ºhren, werden Verzeichnistabellen erstellt, in denen Regeln und Replikationsrichtung zwischen Knoten gespeichert werden.  Schlie√ülich werden Beispieldaten in die Tabellen geladen. </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; ./dbimport --engine corp-000 --format XML create_sample.xml vm1$&gt; ./symadmin --engine corp-000 create-sym-tables vm1$&gt; ./dbimport --engine corp-000 insert_sample.sql</code> </pre> <br><p>  In diesem Beispiel werden die Tabellen item und item_selling_price automatisch so konfiguriert, dass sie von corp-000 nach store-001 repliziert werden, und die Verkaufstabellen (sale_transaction und sale_return_line_item) werden automatisch so konfiguriert, dass sie von store-001 nach corp-000 repliziert werden.  Erstellen Sie nun das Schema in der PostgreSQL-Datenbank auf dem vm2-Host (store-001), um es f√ºr den Empfang von Daten von corp-000 vorzubereiten. </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; ./dbimport --engine store-001 --format XML create_sample.xml</code> </pre> <br><p>  Stellen Sie sicher, dass die MySQL-Datenbank auf VM1 Beispieltabellen und SymmetricDS-Verzeichnistabellen enth√§lt.  Beachten Sie, dass die SymmetricDS-Systemtabellen (mit dem Pr√§fix sym_) jetzt nur auf dem corp-000-Host verf√ºgbar sind, da wir dort den Befehl create-sym-tables ausgef√ºhrt haben und die Replikation verwalten.  Und in der Datenbank auf dem Store-001-Knoten gibt es nur 4 Beispieltabellen ohne Daten. </p><br><p>  Das ist alles.  Die Umgebung ist bereit, sym Server-Prozesse auf beiden Knoten auszuf√ºhren, wie unten gezeigt. </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p>  Protokolleintr√§ge werden an die Hintergrundprotokolldatei (symmetric.log) im Protokollordner des Verzeichnisses, in dem SymmetricDS installiert ist, sowie an die Standardausgabe gesendet.  Der Sym-Server kann jetzt auf dem Store-001-Knoten initiiert werden. </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p>  Wenn Sie den Sym-Server-Prozess auf dem VM2-Host ausf√ºhren, werden die SymmetricDS-Katalogtabellen auch in der PostgreSQL-Datenbank erstellt.  Wenn Sie den Sym-Server-Prozess auf beiden Knoten ausf√ºhren, werden diese miteinander koordiniert, um Daten von corp-000 nach store-001 zu replizieren.  Wenn wir nach einigen Sekunden alle 4 Tabellen auf beiden Seiten abfragen, sehen wir, dass die Replikation erfolgreich ist.  Oder Sie k√∂nnen den Bootstrap mit dem folgenden Befehl von corp-000 an store-001 senden. </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin --engine corp-000 reload-node 001</code> </pre> <br><p>  Zu diesem Zeitpunkt wird ein neuer Datensatz in die Elementtabelle in der MySQL-Datenbank auf Host corp-000 (Host: vm1) eingef√ºgt, und Sie k√∂nnen seine Replikation in die PostgreSQL-Datenbank auf Host Store-001 (Host: vm2) √ºberpr√ºfen.  Wir sehen eine Pull-Operation, um Daten von corp-000 nach store-001 zu verschieben. </p><br><pre> <code class="plaintext hljs">mysql&gt; insert into item values ('22000002','Jelly Bean'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">vm2$&gt; psql -p 5832 -U postgres pgdb_replica -c "select * from item" item_id | name ----------+----------- 11000001 | Yummy Gum 22000002 | Jelly Bean (2 rows)</code> </pre> <br><p>  Um eine Push-Operation zum Verschieben von Daten von store-001 nach corp-000 auszuf√ºhren, f√ºgen Sie einen Datensatz in die Tabelle sale_transaction ein und √ºberpr√ºfen Sie, ob die Replikation abgeschlossen ist. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ergebnis.</a> </p><br><p>  Wir sehen eine erfolgreiche Einrichtung der bidirektionalen Replikation von Beispieltabellen zwischen MySQL- und PostgreSQL-Datenbanken.  Gehen Sie wie folgt vor, um die Replikation f√ºr neue Benutzertabellen zu konfigurieren:  Wir erstellen die Tabelle t1 als Beispiel und konfigurieren die Regeln f√ºr ihre Replikation wie folgt.  Daher konfigurieren wir nur die Replikation von corp-000 nach store-001. </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (no integer); Query OK, 0 rows affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_channel (channel_id,create_time,last_update_time) values ('t1',current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger (trigger_id, source_table_name,channel_id, last_update_time, create_time) values ('t1', 't1', 't1', current_timestamp, current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger_router (trigger_id, router_id, Initial_load_order, create_time,last_update_time) values ('t1', 'corp-2-store-1', 1, current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><p>  Anschlie√üend wird die Konfiguration √ºber die √Ñnderung des Schemas informiert, dh √ºber das Hinzuf√ºgen einer neuen Tabelle mithilfe des Befehls symadmin mit dem Argument sync-triggers, mit dem die Trigger neu erstellt werden, damit sie mit den Tabellendefinitionen √ºbereinstimmen.  Das Sendeschema wird ausgef√ºhrt, um die Schema√§nderungen an den Store-001-Knoten zu senden, und die t1-Tabellenreplikation wird konfiguriert. </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin -e corp-000 --node=001 sync-triggers vm1$&gt; ./symadmin send-schema -e corp-000 --node=001 t1</code> </pre> <br><h3 id="preimuschestva-symmetricds">  Vorteile von SymmetricDS </h3><br><p>  Einfache Installation und Konfiguration, einschlie√ülich eines vorgefertigten Satzes von Dateien mit Parametern zum Erstellen einer Schaltung mit drei oder zwei Knoten. <br>  Plattform√ºbergreifende Datenbanken und Plattformunabh√§ngigkeit, einschlie√ülich Server, Laptops und Mobilger√§te. <br>  Replizieren Sie eine Datenbank lokal, in einem WAN oder in der Cloud in eine andere Datenbank. <br>  Die F√§higkeit, optimal mit ein paar Datenbanken oder mehreren Tausend zu arbeiten, um die Replikation zu vereinfachen. <br>  Bezahlte Version mit grafischer Oberfl√§che und hervorragender Unterst√ºtzung. </p><br><h3 id="nedostatki-symmetricds">  SymmetricDS Nachteile </h3><br><p>  Es ist erforderlich, die Regeln und die Replikationsrichtung manuell √ºber die SQL-Anweisungen in der Befehlszeile zu bestimmen, um Verzeichnistabellen zu laden, was unpraktisch ist. <br>  Das Einrichten vieler Tabellen f√ºr die Replikation kann m√ºhsam sein, wenn Sie keine Skripts zum Erstellen von SQL-Anweisungen verwenden, die die Regeln und die Richtung der Replikation definieren. <br>  In die Protokolle werden zu viele Informationen eingegeben, und manchmal m√ºssen Sie die Protokolldatei bereinigen, damit sie nicht zu viel Speicherplatz beansprucht. </p><br><h3 id="itogi-po-symmetricds">  SymmetricDS-Zusammenfassung </h3><br><p>  Mit SymmetricDS k√∂nnen Sie die bidirektionale Replikation zwischen zwei, drei oder sogar mehreren tausend Knoten konfigurieren, um Dateien zu replizieren und zu synchronisieren.  Dies ist ein einzigartiges Tool, das unabh√§ngig viele Aufgaben ausf√ºhrt, z. B. automatische Datenwiederherstellung nach langen Ausfallzeiten auf einem Knoten, sicherer und effizienter Datenaustausch zwischen Knoten √ºber HTTPS, automatisches Konfliktmanagement basierend auf einer Reihe von Regeln usw. SymmetricDS repliziert zwischen beliebigen Datenbanken. Daher kann es f√ºr eine Vielzahl von Szenarien verwendet werden, einschlie√ülich Migration, Aktualisierung, Verteilung, Filterung und Datenkonvertierung √ºber Plattformen hinweg. </p><br><p>  Das Beispiel basiert auf der offiziellen SymmetricDS-Kurzanleitung.  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzerhandbuch werden</a> verschiedene Konzepte zum Konfigurieren der Replikation mit SymmetricDS beschrieben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467313/">https://habr.com/ru/post/de467313/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467295/index.html">Die lang erwartete View Binding in Android</a></li>
<li><a href="../de467299/index.html">Konzepte: Vereinfachung der Implementierung von STD Utility-Klassen</a></li>
<li><a href="../de467301/index.html">Wie KI in Hitman funktioniert (2016)</a></li>
<li><a href="../de467303/index.html">Die Geschichte des j√ºngsten PSB-Programmierers: Der Hackathon wurde zur T√ºr zur Bank</a></li>
<li><a href="../de467305/index.html">Wenn die Stadt schlau ist: das Erlebnis von Megacities</a></li>
<li><a href="../de467317/index.html">Wie SoftBank die Welt verschluckte</a></li>
<li><a href="../de467323/index.html">√úbersicht √ºber die Programmierfunktionen von Qt Creator 4.10 und QBS 1.14 Microcontroller</a></li>
<li><a href="../de467327/index.html">Wie ich im Alter von 35 Jahren Programmierer wurde</a></li>
<li><a href="../de467329/index.html">Die besten Produkte gehen von echten Problemen aus: Gegensprechanlage √ºber zu erledigende Jobs. Teil 1</a></li>
<li><a href="../de467331/index.html">Verkauf + ein wundersch√∂ner Online-Shop auf WordPress f√ºr $ 269 "von Grund auf neu" - unsere Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>