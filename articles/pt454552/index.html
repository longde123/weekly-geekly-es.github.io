<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤µğŸ½ ğŸ§’ğŸ¾ ğŸ™ Docker-compor Como esperar atÃ© que o contÃªiner esteja pronto ğŸŠ ğŸ‘¨â€ğŸ’» ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. IntroduÃ§Ã£o 
 Existem muitos artigos sobre como executar contÃªineres e como escrever o docker-compose.yml . Mas, para mim, por um longo tempo, a per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker-compor Como esperar atÃ© que o contÃªiner esteja pronto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454552/"><h1>  1. IntroduÃ§Ã£o </h1><br>  Existem muitos artigos sobre como executar contÃªineres e como escrever o <b>docker-compose.yml</b> .  Mas, para mim, por um longo tempo, a pergunta nÃ£o ficou clara sobre como proceder corretamente se algum contÃªiner nÃ£o deveria ser iniciado atÃ© que outro contÃªiner esteja pronto para processar suas solicitaÃ§Ãµes ou concluir alguma quantidade de trabalho. <br><a name="habracut"></a><br>  Essa questÃ£o se tornou relevante depois que comeÃ§amos a usar ativamente o <b>docker-compondo</b> , em vez de iniciar estivadores individuais. <br><br><h1>  Para que serve? </h1><br>  De fato, deixe o aplicativo no contÃªiner B depender da disponibilidade do serviÃ§o no contÃªiner A. E na inicializaÃ§Ã£o, o aplicativo no contÃªiner B nÃ£o recebe esse serviÃ§o.  O que deveria fazer? <br><br>  Existem duas opÃ§Ãµes: <br><br><ul><li>  o primeiro Ã© morrer (de preferÃªncia com um cÃ³digo de erro) </li><li>  o segundo Ã© esperar e morrer de qualquer maneira, se o aplicativo no contÃªiner B nÃ£o responder pelo tempo limite alocado </li></ul><br>  ApÃ³s a morte do contÃªiner B, o <b>docker-compose</b> (dependendo da configuraÃ§Ã£o, Ã© claro) o reinicia e o aplicativo no contÃªiner B tenta novamente acessar o serviÃ§o no contÃªiner A. <br><br>  Isso continuarÃ¡ atÃ© que o serviÃ§o no contÃªiner A esteja pronto para responder Ã s solicitaÃ§Ãµes ou atÃ© percebermos que o contÃªiner estÃ¡ sendo sobrecarregado constantemente. <br>  E, de fato, esse Ã© o caminho normal para a arquitetura de vÃ¡rios contÃªineres. <br><br>  Mas, em particular, nos deparamos com uma situaÃ§Ã£o em que o contÃªiner A Ã© inicializado e prepara os dados para o contÃªiner B. O aplicativo no contÃªiner B nÃ£o Ã© capaz de verificar se os dados estÃ£o prontos ou nÃ£o, ele imediatamente comeÃ§a a trabalhar com eles.  Portanto, temos que receber e processar o sinal sobre a disponibilidade de dados por conta prÃ³pria. <br><br>  Eu acho que vocÃª ainda pode dar alguns casos de uso.  Mas o mais importante, vocÃª precisa entender exatamente por que estÃ¡ fazendo isso.  Caso contrÃ¡rio, Ã© melhor usar as ferramentas padrÃ£o <b>de composiÃ§Ã£o do docker</b> . <br><br><h1>  Um pouco de ideologia </h1><br>  Se vocÃª ler atentamente a documentaÃ§Ã£o, tudo estarÃ¡ escrito lÃ¡.  Ou seja, cada <br>  a unidade Ã© independente e deve cuidar para que todos os serviÃ§os com <br>  com o qual ele vai trabalhar, estÃ£o disponÃ­veis para ele. <br><br>  Portanto, a questÃ£o nÃ£o Ã© iniciar ou nÃ£o iniciar o contÃªiner, mas sim <br>  dentro do contÃªiner, verifique a disponibilidade de todos os serviÃ§os necessÃ¡rios e apenas <br>  depois transfira o controle para o aplicativo de contÃªiner. <br><br><h1>  Como Ã© implementado </h1><br>  Para resolver esse problema, a descriÃ§Ã£o da <b>janela de encaixe-composiÃ§Ã£o</b> me ajudou muito, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essa</a> parte dela <br>  e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> sobre o uso adequado do <b>ponto</b> de <b>entrada</b> e do <b>cmd</b> . <br><br>  EntÃ£o, o que precisamos obter: <br><br><ul><li>  hÃ¡ um apÃªndice A que embrulhÃ¡mos no recipiente A </li><li>  ele inicia e comeÃ§a a responder OK na porta 8000 </li><li>  e tambÃ©m hÃ¡ o aplicativo B, que iniciamos a partir do contÃªiner B, mas ele deve comeÃ§ar a funcionar nÃ£o antes que o aplicativo A comece a responder Ã s solicitaÃ§Ãµes na porta 8000 </li></ul><br>  A documentaÃ§Ã£o oficial oferece duas maneiras de resolver esse problema. <br><br>  A primeira Ã© escrever seu prÃ³prio ponto de <b>entrada</b> no contÃªiner, que executarÃ¡ todas as verificaÃ§Ãµes e, em seguida, iniciarÃ¡ o aplicativo de trabalho. <br><br>  O segundo Ã© usar o arquivo em lotes jÃ¡ gravado <b>wait-for-it.sh</b> . <br>  Tentamos nos dois sentidos. <br><br><h2>  Escrevendo seu prÃ³prio ponto de entrada </h2><br>  O que Ã© ponto de <b>entrada</b> ? <br><br>  Este Ã© apenas o arquivo executÃ¡vel que vocÃª especifica ao criar o contÃªiner no <b>Dockerfile</b> no campo <b>ENTRYPOINT</b> .  Esse arquivo, como jÃ¡ mencionado, executa verificaÃ§Ãµes e inicia o aplicativo principal do contÃªiner. <br><br>  EntÃ£o, o que temos: <br><br>  Crie uma pasta de ponto de entrada. <br><br>  Possui duas subpastas - <i>container_A</i> e <i>container_B</i> .  Vamos criar nossos contÃªineres neles. <br><br>  Para o contÃªiner A, vamos usar um servidor http simples em python.  Ele, apÃ³s iniciar, comeÃ§a a responder para obter solicitaÃ§Ãµes na porta 8000. <br><br>  Para tornar nosso experimento mais explÃ­cito, definimos um atraso de 15 segundos antes de iniciar o servidor. <br><br>  Acontece o seguinte <b>arquivo de janela de encaixe para o contÃªiner A</b> : <br><br><pre><code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre> <br>  Para o contÃªiner B, crie o seguinte <b>arquivo de janela de encaixe para o contÃªiner B</b> : <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y curl COPY ./entrypoint.sh /usr/bin/entrypoint.sh ENTRYPOINT [ "entrypoint.sh" ] CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  E coloque nosso executÃ¡vel entrypoint.sh na mesma pasta.  Teremos assim <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash set -e host="conteiner_a" port="8000" cmd="$@" &gt;&amp;2 echo "!!!!!!!! Check conteiner_a for available !!!!!!!!" until curl http://"$host":"$port"; do &gt;&amp;2 echo "Conteiner_A is unavailable - sleeping" sleep 1 done &gt;&amp;2 echo "Conteiner_A is up - executing command" exec $cmd</span></span></code> </pre><br>  O que estÃ¡ acontecendo no contÃªiner B: <br><br><ul><li>  Quando inicia, inicia <b>ENTRYPOINT</b> , ou seja,  lanÃ§a <b>entrypoint.sh</b> </li><li>  <b>entrypoint.sh</b> , usando <b>curl</b> , inicia a porta de pesquisa 8000 para o contÃªiner A. Faz isso atÃ© receber uma resposta de 200 (ou seja, <b>curl</b> nesse caso terminarÃ¡ com um resultado zero e o loop terminarÃ¡) </li><li>  Quando 200 Ã© recebido, o loop termina e o controle passa para o comando especificado na variÃ¡vel <b>$ cmd</b> .  E indica o que indicamos no arquivo docker no campo <b>CMD</b> , ou seja,  <i>eco "!!! Container_A jÃ¡ estÃ¡ disponÃ­vel !!!!!!!!"</i>  Por que isso Ã© assim, estÃ¡ descrito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> acima </li><li>  NÃ³s imprimimos - <i>!!!</i>  <i>Container_A jÃ¡ estÃ¡ disponÃ­vel !!!</i>  <i>e concluir.</i> </li></ul><br>  ComeÃ§aremos tudo com o <b>docker-compose</b> . <br><br>  <b>docker-compose.yml</b> aqui temos o seguinte: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.entrypoint.conteiner_b restart: "no" networks: - waiting_for_conteiner</code> </pre><br>  Aqui, em <b>conteiner_a, nÃ£o Ã©</b> necessÃ¡rio especificar <i>portas: 8000: 8000</i> .  Isso foi feito para poder verificar a operaÃ§Ã£o do servidor http em execuÃ§Ã£o a partir do exterior. <br><br>  AlÃ©m disso, o contÃªiner B nÃ£o reinicia apÃ³s o desligamento. <br><br>  LanÃ§amos: <br><br><pre> <code class="plaintext hljs">docker-compose up â€”-build</code> </pre><br>  Vemos que por 15 segundos hÃ¡ uma mensagem sobre a indisponibilidade do contÃªiner A e, em seguida, <br><br><pre> <code class="plaintext hljs">conteiner_b | Conteiner_A is unavailable - sleeping conteiner_b | % Total % Received % Xferd Average Speed Time Time Time Current conteiner_b | Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; conteiner_b | &lt;html&gt; conteiner_b | &lt;head&gt; conteiner_b | &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; conteiner_b | &lt;title&gt;Directory listing for /&lt;/title&gt; conteiner_b | &lt;/head&gt; conteiner_b | &lt;body&gt; conteiner_b | &lt;h1&gt;Directory listing for /&lt;/h1&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;ul&gt; conteiner_b | &lt;li&gt;&lt;a href=".dockerenv"&gt;.dockerenv&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="bin/"&gt;bin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="boot/"&gt;boot/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="dev/"&gt;dev/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="etc/"&gt;etc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="home/"&gt;home/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib/"&gt;lib/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="lib64/"&gt;lib64/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="media/"&gt;media/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="mnt/"&gt;mnt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="opt/"&gt;opt/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="proc/"&gt;proc/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="root/"&gt;root/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="run/"&gt;run/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sbin/"&gt;sbin/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="srv/"&gt;srv/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="sys/"&gt;sys/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="tmp/"&gt;tmp/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="usr/"&gt;usr/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;li&gt;&lt;a href="var/"&gt;var/&lt;/a&gt;&lt;/li&gt; conteiner_b | &lt;/ul&gt; conteiner_b | &lt;hr&gt; conteiner_b | &lt;/body&gt; conteiner_b | &lt;/html&gt; 100 987 100 987 0 0 98700 0 --:--:-- --:--:-- --:--:-- 107k conteiner_b | Conteiner_A is up - executing command conteiner_b | !!!!!!!! Container_A is available now !!!!!!!!</code> </pre><br>  Temos uma resposta para o seu pedido, imprima <nobr><i>!!!</i></nobr>  <nobr><i>Container_A jÃ¡ estÃ¡ disponÃ­vel !!!!!!!!</i></nobr>  e concluir. <br><br><h2>  Usando wait-for-it.sh </h2><br>  Vale dizer imediatamente que esse caminho nÃ£o funcionou para nÃ³s, conforme descrito na documentaÃ§Ã£o. <br>  Ou seja, sabe-se que, se <b>ENTRYPOINT</b> e <b>CMD forem</b> gravados no <b>Dockerfile</b> , quando o contÃªiner iniciar, o comando de <b>ENTRYPOINT</b> serÃ¡ executado e o conteÃºdo do <b>CMD</b> serÃ¡ passado como parÃ¢metros. <br><br>  TambÃ©m Ã© sabido que <b>ENTRYPOINT</b> e <b>CMD</b> especificados no <b>Dockerfile</b> podem ser redefinidos em <b>docker-compose.yml</b> <br><br>  O <b>formato de</b> inicializaÃ§Ã£o <b>wait-for-it.sh Ã©</b> o seguinte: <br><br><pre> <code class="plaintext hljs">wait-for-it.sh __ -- ___</code> </pre><br>  Em seguida, conforme indicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> , podemos definir um novo <b>ENTRYPOINT</b> no <b>docker-compose.yml</b> e o <b>CMD serÃ¡</b> substituÃ­do no <b>Dockerfile</b> . <br><br>  EntÃ£o, nÃ³s temos: <br><br>  <b>O arquivo do Docker para o contÃªiner A</b> permanece inalterado: <br><br><pre> <code class="plaintext hljs">FROM python:3 EXPOSE 8000 CMD sleep 15 &amp;&amp; python3 -m http.server --cgi</code> </pre><br>  <b>Arquivo Docker para contÃªiner B</b> <br><br><pre> <code class="plaintext hljs">FROM ubuntu:18.04 COPY ./wait-for-it.sh /usr/bin/wait-for-it.sh CMD ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  <b>O Docker-compose.yml</b> fica assim: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" , "-t", "20", "conteiner_a:8000", "--"]</code> </pre><br>  Executamos o comando <b>wait-for-it</b> , esperamos 20 segundos atÃ© que o contÃªiner A ganhe vida e especificamos outro parÃ¢metro <b>â€œ-â€</b> , que deve separar os parÃ¢metros do <b>wait-for-it</b> do programa que serÃ¡ iniciado apÃ³s sua conclusÃ£o. <br><br>  NÃ³s tentamos! <br>  E, infelizmente, nÃ£o recebemos nada. <br><br>  Se verificarmos com quais argumentos executamos o wait-for-it, veremos que apenas o que especificamos no ponto de <b>entrada Ã© passado para ele</b> , o <b>CMD</b> do contÃªiner nÃ£o Ã© anexado. <br><br><h3>  OpÃ§Ã£o de trabalho </h3><br>  EntÃ£o, hÃ¡ apenas uma opÃ§Ã£o.  O que especificamos no <b>CMD</b> no <b>Dockerfile</b> , devemos transferir para o <b>comando</b> no <b>docker-compose.yml</b> . <br><br>  Em seguida, <b>deixe o Dockerfile do</b> contÃªiner B inalterado e o <b>docker-compose.yml</b> ficarÃ¡ assim: <br><br><pre> <code class="plaintext hljs">version: '3' networks: waiting_for_conteiner: services: conteiner_a: build: ./conteiner_A container_name: conteiner_a image: conteiner_a restart: unless-stopped networks: - waiting_for_conteiner ports: - 8000:8000 conteiner_b: build: ./conteiner_B container_name: conteiner_b image: waiting_for_conteiner.wait_for_it.conteiner_b restart: "no" networks: - waiting_for_conteiner entrypoint: ["wait-for-it.sh", "-s" ,"-t", "20", "conteiner_a:8000", "--"] command: ["echo", "!!!!!!!! Container_A is available now !!!!!!!!"]</code> </pre><br>  E nesta versÃ£o, funciona. <br><br>  Em conclusÃ£o, deve-se dizer que, em nossa opiniÃ£o, o caminho certo Ã© o primeiro.  Ã‰ o mais versÃ¡til e permite que vocÃª faÃ§a uma verificaÃ§Ã£o de prontidÃ£o da maneira que for possÃ­vel.  <b>Wait-for-it Ã©</b> apenas um utilitÃ¡rio Ãºtil que vocÃª pode usar separadamente ou incorporando em seu <b>entrypoint.sh</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454552/">https://habr.com/ru/post/pt454552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454536/index.html">Amplificador para o clÃ¡ssico sensor de frequÃªncia cardÃ­aca</a></li>
<li><a href="../pt454538/index.html">Frontend Weekly Digest (27 de maio a 2 de junho de 2019)</a></li>
<li><a href="../pt454540/index.html">O resumo de materiais frescos do mundo do front-end da Ãºltima semana n Â° 367 (27 de maio a 2 de junho de 2019)</a></li>
<li><a href="../pt454542/index.html">Redes de TV a cabo para os menores. Parte 7: Receptores Ã³pticos</a></li>
<li><a href="../pt454546/index.html">Quantos programadores vocÃª precisa para tomar uma xÃ­cara de cafÃ©?</a></li>
<li><a href="../pt454556/index.html">NotÃ­cias do mundo do OpenStreetMap nÂº 462 (21.05.2019-27.05.2019)</a></li>
<li><a href="../pt454558/index.html">PHP Digest No. 157 (20 de maio a 3 de junho de 2019)</a></li>
<li><a href="../pt454562/index.html">Por que o conceito de bytecode nÃ£o Ã© tÃ£o relevante como era antes</a></li>
<li><a href="../pt454568/index.html">A Mozilla classificou a distribuiÃ§Ã£o de pacotes da web assinada digitalmente como "ruim"</a></li>
<li><a href="../pt454570/index.html">Recriar um jogo DOS antigo em C ++ 17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>