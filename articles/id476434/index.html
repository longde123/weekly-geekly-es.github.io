<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📬 🤾🏼 👨🏼‍🎨 Kami menulis driver USB untuk perangkat yang ditinggalkan 👨🏼‍✈️ 🧛🏽 👨‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini di eBay saya menemukan banyak perangkat USB yang menarik (Epiphan VGA2USB LR), yang menerima input VGA dan mengirim video ke USB sebagai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis driver USB untuk perangkat yang ditinggalkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476434/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ko/58/4t/ko584thwb5si-do2bof-snfagjc.jpeg" width="550"></div><br><br>  Baru-baru ini di eBay saya menemukan banyak perangkat USB yang menarik (Epiphan VGA2USB LR), yang menerima input VGA dan mengirim video ke USB sebagai webcam.  Saya sangat senang dengan gagasan bahwa saya tidak perlu repot dengan monitor VGA lagi, dan diberi dukungan yang dinyatakan untuk Linux, saya mengambil kesempatan dan membeli seluruh batch seharga sekitar 20 pound (25 dolar AS). <br><br>  Setelah menerima paket, saya menghubungkan perangkat, tetapi bahkan tidak berpikir untuk muncul dalam sistem sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UVC</a> .  Apa yang salah <br><br>  Saya mempelajari situs web pabrikan dan menemukan bahwa driver khusus diperlukan untuk bekerja.  Bagi saya, ini adalah konsep baru, karena kernel distribusi Linux saya biasanya memiliki driver untuk semua perangkat. <br><a name="habracut"></a><br>  Sayangnya, dukungan driver untuk perangkat ini hanya berakhir di Linux 4.9.  Jadi, tidak ada sistem saya yang akan melihatnya (Debian 10 di Linux 4.19 atau versi terbaru dari LTS Ubuntu di Linux 5.0). <br><br>  Tapi itu bisa diperbaiki, bukan?  Tentu saja, file datang dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket DKMS</a> , yang, sesuai permintaan, mengumpulkan driver dari kode sumber, seperti banyak driver biasa ... <br><br>  Menyedihkan.  Tapi di sini tidak demikian. <br><br>  Di dalam paket itu hanya binari <code>vga2usb.o</code> dikompilasi.  Saya mulai mempelajarinya, bertanya-tanya kerumitan rekayasa balik, dan menemukan beberapa baris yang menarik: <br><br><pre> <code class="bash hljs">$ strings vga2usb.ko | grep <span class="hljs-string"><span class="hljs-string">'v2uco'</span></span> | sort | uniq v2ucom_autofirmware v2ucom_autofirmware_ezusb v2ucom_autofirmware_fpga</code> </pre> <br>  Jadi apakah ini benar-benar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FPGA</a> -on-a-stick?  Bagaimana membuat sesuatu seperti ini berfungsi? <br><br>  Temuan lucu dan sedikit mengganggu lainnya adalah garis dengan parameter kunci pribadi DSA.  Ini membuat saya bertanya-tanya: apa yang bisa ia lindungi di dalam pengemudi? <br><br><pre> <code class="bash hljs">$ strings vga2usb.ko | grep <span class="hljs-string"><span class="hljs-string">'epiphan'</span></span> | sort | uniq epiphan_dsa_G epiphan_dsa_P epiphan_dsa_Q</code> </pre> <br>  Untuk mempelajari driver di lingkungan normalnya, saya mengambil mesin virtual Debian 9 (rilis yang didukung terakhir) dan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KVM USB Passthrough</a> untuk memberikan akses langsung ke perangkat.  Kemudian saya menginstal driver dan memastikan itu berfungsi. <br><br>  Setelah itu, saya ingin melihat seperti apa protokol komunikasi itu.  Saya berharap perangkat akan mengirim bingkai mentah atau hampir mentah, karena itu akan membuatnya lebih mudah untuk menulis driver untuk ruang pengguna. <br><br>  Untuk melakukan ini, saya memuat modul <code>usbmon</code> pada <code>usbmon</code> mesin virtual dan meluncurkan Wireshark untuk menangkap lalu lintas USB ke dan dari perangkat selama startup dan pengambilan video. <br><br><img src="https://habrastorage.org/webt/wo/0l/ux/wo0luxcyjaf5kmnthlsjsseo_o0.png"><br><br>  Saya menemukan bahwa ketika diluncurkan, sejumlah besar paket kecil ditransmisikan ke perangkat sebelum mulai menangkap gambar.  Ini kemungkinan didasarkan pada platform FPGA tanpa penyimpanan data.  Setiap kali setelah terhubung, driver mentransfer firmware dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20191109230917/">bitstream FPGA</a> ke perangkat. <br><br>  Saya yakin dengan membuka salah satu kotak: <br><br><img src="https://habrastorage.org/webt/8d/df/qe/8ddfqe7xzlovfj9bnjwhmyu5due.jpeg"><br><br><div class="scrollable-table"><table><tbody><tr><td colspan="1" rowspan="1"><p>  Merah </p></td><td colspan="1" rowspan="1"><p>  ISL98002CRZ-170 - Berfungsi sebagai ADC untuk Sinyal VGA </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Kuning </p></td><td colspan="1" rowspan="1"><p>  XC6SLX16 - Xilinx Spartan 6 FPGA </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Cyan </p></td><td colspan="1" rowspan="1"><p>  64 MB DDR3 </p></td></tr><tr><td colspan="1" rowspan="1"><p>  Magenta </p></td><td colspan="1" rowspan="1"><p>  CY7C68013A - Pengontrol USB / Ujung Depan </p></td></tr></tbody></table></div><br>  Karena untuk "mengunduh" perangkat, Anda perlu mengirimkannya bitstream / firmware, Anda harus mencarinya di binari yang sudah dikompilasi.  Saya berlari <code>binwalk -x</code> dan mulai mencari beberapa objek yang dikompresi (zlib).  Untuk melakukan ini, saya menulis skrip pencarian urutan hex - dan menetapkan tiga byte dari paket yang dicegat. <br><br><pre> <code class="bash hljs">$ bash scan.sh <span class="hljs-string"><span class="hljs-string">"03 3f 55"</span></span> trying 0.elf trying 30020 trying 30020.zlib trying 30020.zlib.decompressed ... trying 84BB0 trying 84BB0.zlib trying 84BB0.zlib.decompressed trying AA240 trying AA240.zlib trying AA240.zlib.decompressed 000288d0 07 2f 03 3f 55 50 7d 7c 00 00 00 00 00 00 00 00 |./.?UP}|........| trying C6860 trying C6860.zlib</code> </pre> <br>  Setelah membongkar file AA240.zlib, ternyata tidak ada cukup data untuk bitstream lengkap.  Jadi saya memutuskan untuk mengambil firmware dari paket USB. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baik tshark</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tcpdump</a> dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca</a> paket USB dari file pcap, tetapi keduanya menyimpannya hanya sebagian.  Karena setiap utilitas memiliki bagian puzzle yang berbeda, saya menulis sebuah <a href="">program kecil</a> yang menggabungkan output dari kedua program ke dalam struktur go untuk memutar paket kembali ke perangkat. <br><br>  Pada titik ini, saya perhatikan bahwa pengunduhan berlangsung dalam dua tahap: pertama pengontrol USB, dan kemudian FPGA. <br><br>  Saya macet selama beberapa hari: sepertinya seluruh bitstream sedang dimuat, tetapi perangkat tidak mulai, meskipun paket dari driver nyata dan simulasi saya terlihat serupa. <br><br>  Pada akhirnya, saya memecahkan masalah dengan hati-hati memeriksa pcap dengan mempertimbangkan waktu respons untuk setiap paket - dan melihat perbedaan waktu yang besar dalam satu paket tertentu: <br><br><img src="https://habrastorage.org/webt/fm/jr/cl/fmjrcloapr8mljsbnl3ed1qc0p0.png"><br><br>  Ternyata karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan ketik</a> kecil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> rekaman terjadi di area perangkat yang salah.  Ini akan menjadi pelajaran bagi saya cara memasukkan nilai secara manual ... <br><br>  Namun, LED akhirnya berkedip pada perangkat!  Sebuah pencapaian besar! <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://blog.benjojo.co.uk/asset/hwDmbj53li" type="video/mp4"></video></div></div></div><br>  Itu relatif mudah untuk mereplikasi paket yang sama yang memicu transfer data, jadi saya bisa menulis titik akhir USB Bulk dan menyiram data ke disk secara instan! <br><br>  Di sinilah kesulitan sebenarnya dimulai.  Karena setelah analisis ternyata data itu tidak secara eksplisit dikodekan dengan cara apa pun. <br><br>  Untuk memulai, saya menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perf</a> untuk mendapatkan ide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dasar</a> dari jejak stack driver saat runtime: <br><br><img src="https://habrastorage.org/webt/8u/8u/gu/8u8ugu8wikugmk_9pmp9iwdzwig.png"><br><br>  Meskipun saya bisa menangkap fungsi dengan data bingkai, saya tidak bisa memahami pengkodean data itu sendiri. <br><br><img src="https://habrastorage.org/webt/0w/hl/rx/0whlrxmpbisqikichzqziye8ilm.png"><br><br>  Untuk lebih memahami apa yang terjadi di dalam driver sebenarnya, saya bahkan mencoba alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ghidra</a> dari NSA: <br><br><img src="https://habrastorage.org/webt/2k/w-/vk/2kw-vke76xvk_wp1zuultsc_g6m.png"><br><br>  Meskipun Ghidra luar biasa (ketika saya pertama kali menggunakannya bukan IDA Pro), itu masih tidak cukup baik untuk membantu saya memahami driver.  Rekayasa balik membutuhkan jalur yang berbeda. <br><br>  Saya memutuskan untuk mengambil mesin virtual Windows 7 dan melihat driver Windows, tiba-tiba itu akan memunculkan ide.  Dan kemudian saya perhatikan bahwa ada SDK untuk perangkat.  Salah satu alat ternyata sangat menarik: <br><br><pre> <code class="bash hljs">PS&gt; ls Directory: epiphan_sdk-3.30.3.0007\epiphan\bin Mode LastWriteTime Length Name ---- ------------- ------ ---- -a--- 10/26/2019 10:57 AM 528384 frmgrab.dll -a--- 10/27/2019 5:41 PM 1449548 out.aw -a--- 10/26/2019 10:57 AM 245760 v2u.exe -a--- 10/26/2019 10:57 AM 94208 v2u_avi.exe -a--- 10/26/2019 10:57 AM 102400 v2u_dec.exe -a--- 10/26/2019 10:57 AM 106496 v2u_dshow.exe -a--- 10/26/2019 10:57 AM 176128 v2u_ds_decoder.ax -a--- 10/26/2019 10:57 AM 90112 v2u_edid.exe -a--- 10/26/2019 10:57 AM 73728 v2u_kvm.exe -a--- 10/26/2019 10:57 AM 77824 v2u_libdec.dll PS&gt; .\v2u_dec.exe Usage: v2u_dec &lt;number of frames&gt; [format] [compression level] &lt;filename&gt; - sets compression level [1..5], - captures and saves compressed frames to a file v2u_dec x [format] &lt;filename&gt; - decompresses frames from the file to separate BMP files</code> </pre> <br>  Alat ini memungkinkan Anda untuk "mengambil" satu frame, dan pada awalnya tidak dikompresi, sehingga memungkinkan untuk memproses frame nanti pada mesin yang lebih cepat.  Ini hampir sempurna, dan saya meniru urutan paket USB untuk mendapatkan gumpalan yang tidak terkompresi ini.  Jumlah byte terkait dengan kira-kira tiga (RGB) per piksel! <br><br>  Pemrosesan awal gambar-gambar ini (hanya menerima output dan menuliskannya sebagai piksel RGB) memberikan sesuatu yang samar-samar mengingatkan pada gambar nyata yang diterima perangkat melalui VGA: <br><br><img src="https://habrastorage.org/webt/zw/a7/ex/zwa7ext1vs4qdprl7-nv9vzp0-m.png"><br><br>  Setelah debugging di hex editor, ternyata setiap marker diulang setiap 1028 byte.  Agak memalukan berapa banyak waktu yang saya habiskan untuk menulis filter.  Di sisi lain, dalam prosesnya orang dapat menikmati beberapa contoh seni kontemporer. <br><br><img src="https://habrastorage.org/webt/wq/je/ft/wqjeft0hks2k0tc7hfdwf4sm0ti.png"><br><br>  Kemudian saya menyadari bahwa kemiringan dan distorsi gambar disebabkan oleh lompatan dan bungkus piksel pada setiap baris (x = 799 tidak sama dengan x = 800).  Dan akhirnya, saya mendapatkan gambar yang hampir benar, kecuali warnanya: <br><br><img src="https://habrastorage.org/webt/b5/wq/3o/b5wq3ocp1mjzytcefasym6nyuem.png"><br><br>  Pada awalnya, saya pikir masalah kalibrasi adalah karena pengambilan sampel data ketika input VGA macet dalam warna solid.  Untuk koreksi, saya membuat gambar uji baru untuk mengidentifikasi masalah seperti itu.  Kalau dipikir-pikir, saya mengerti bahwa Anda harus menggunakan sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kartu tes Philips PM5544</a> . <br><br><img src="https://habrastorage.org/webt/70/se/ue/70seuem7_dhlhaip_wfjtfzgvs0.png"><br><br>  Saya mengunggah gambar ke laptop, dan menghasilkan gambar VGA seperti itu: <br><br><img src="https://habrastorage.org/webt/nb/k3/yj/nbk3yjxdr_mulhymu7enyvt3xjo.png"><br><br>  Kemudian saya mendapatkan memori beberapa karya lama dalam rendering / shader 3D.  Itu sangat mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema warna YUV</a> . <br><br>  Akibatnya, saya terjun membaca literatur YUV dan ingat bahwa selama rekayasa balik driver kernel resmi, jika saya meletakkan breakpoint pada fungsi yang disebut <code>v2ucom_convertI420toBGR24</code> , maka sistem akan menggantung tanpa kemungkinan pembaruan.  Jadi mungkin inputnya adalah encoding I420 (dari <code>-pix_fmt yuv420p</code> ), dan outputnya adalah RGB? <br><br>  Setelah menggunakan fungsi Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan YCbCrToRGB,</a> gambar tiba-tiba menjadi lebih dekat dengan aslinya. <br><br><img src="https://habrastorage.org/webt/_8/aq/ne/_8aqnetxgrlor_21ezu2ywdqnrq.png"><br><br>  Kami berhasil!  Bahkan pengemudi mentah menghasilkan 7 frame per detik.  Jujur, ini sudah cukup bagi saya, karena saya menggunakan VGA hanya jika terjadi kecelakaan sebagai tampilan cadangan. <br><br>  Jadi, sekarang kita tahu perangkat ini cukup baik untuk menjelaskan algoritma untuk memulai dari awal: <br><br><ol><li>  Anda perlu <a href="">menginisialisasi pengontrol USB</a> .  Dilihat dari jumlah informasi, pada kenyataannya, pengemudi melewati kode untuk mengunduh. <br></li><li>  Ketika Anda selesai memuat USB, perangkat akan memutuskan koneksi dari bus USB dan setelah beberapa saat akan kembali dengan satu titik akhir USB. <br></li><li>  Sekarang Anda dapat <a href="">mengirim bitstream FPGA</a> , satu paket USB 64-byte untuk setiap transfer kontrol. <br></li><li>  Di akhir transfer, indikator pada perangkat akan berkedip hijau.  Pada titik ini, Anda dapat mengirim apa yang tampak seperti urutan parameter (overscan dan properti lainnya). <br></li><li>  Kemudian jalankan <a href="">paket kontrol untuk mendapatkan frame</a> , paket yang ditentukan izinnya.  Jika Anda mengirim permintaan untuk frame 4: 3 ke input layar lebar, ini biasanya akan menyebabkan kerusakan pada frame. </li></ol><br>  Untuk kemudahan penggunaan maksimal, saya menerapkan server web kecil di driver.  Melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MediaRecorder API</a> berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">browser,</a> ia dengan mudah merekam aliran dari layar ke file video. <br><br><img src="https://habrastorage.org/webt/o4/gr/u9/o4gru9m7gywpqz85razdl6ktsd0.png"><br><br>  Mencegah klaim yang tak terhindarkan terhadap kualitas kode eksperimen, saya akan segera katakan: Saya tidak bangga karenanya.  Mungkin, dia dalam kondisi seperti itu, yang cukup bagi saya untuk penggunaan yang dapat diterima. <br><br>  Kode dan build yang sudah jadi untuk Linux dan OSX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada di GitHub</a> . <br><br>  Bahkan jika tidak ada yang memulai program, bagi saya itu adalah perjalanan yang menakjubkan melalui belantara protokol USB, debugging kernel, modul reverse engineering dan format decoding video!  Jika Anda suka hal-hal ini, Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blog lainnya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476434/">https://habr.com/ru/post/id476434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476418/index.html">Startup: 10 takeaways dari 20 pelajaran di Stanford University</a></li>
<li><a href="../id476420/index.html">Mulai gunakan ReactiveX di panah dan Flutter dari awal</a></li>
<li><a href="../id476424/index.html">Kerangka kerja - lebih banyak minus daripada plus</a></li>
<li><a href="../id476428/index.html">Statistik Nginx VTS, Mockify - mock API, Wiremock dan Mockify perbandingan</a></li>
<li><a href="../id476430/index.html">Cara membuat portofolio teknis yang sempurna</a></li>
<li><a href="../id476436/index.html">Laporan dari pertemuan pertama di Rusia tentang pengembang robot tentang Sistem Operasi Robot</a></li>
<li><a href="../id476442/index.html">Berikan ruang atau mikrokontroler seperti pengukur frekuensi</a></li>
<li><a href="../id476444/index.html">Demistifikasi prinsip-prinsip komputasi kuantum</a></li>
<li><a href="../id476446/index.html">Jira Plugins: Beberapa Contoh Penemuan Sepeda yang Berhasil</a></li>
<li><a href="../id476448/index.html">Eksplorasi shader pasir dari game Journey</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>