<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎺 🎰 🙅🏿 Wie wir 2GIS unter CarPlay gestartet haben und uns immer noch entwirren 👩🏽‍🏭 ☦️ 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Vanya, ich schreibe eine 2GIS-Mobilanwendung für iOS. Heute wird es eine Geschichte darüber geben, wie unser Navigator in CarPlay...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir 2GIS unter CarPlay gestartet haben und uns immer noch entwirren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/452638/"><p><img src="https://habrastorage.org/webt/tt/jg/a3/ttjga3qmefdwknrbj1i351exs3m.jpeg"></p><br><p>  Hallo!  Mein Name ist Vanya, ich schreibe eine 2GIS-Mobilanwendung für iOS.  Heute wird es eine Geschichte darüber geben, wie unser Navigator in CarPlay erschien.  Ich werde Ihnen sagen, wie wir mit solchen Dokumentationen und unfertigen Tools ein funktionierendes Produkt erstellt und in den AppStore gestellt haben. </p><a name="habracut"></a><br><h2 id="para-slov-o-carplay">  Ein paar Worte zu CarPlay </h2><br><p><img src="https://habrastorage.org/webt/hq/vu/xw/hqvuxwo3ms1ivfppuaojrfscvh0.jpeg"></p><br><p>  Zunächst ein wenig Material, um einige Aspekte von CarPlay und die Gründe, warum wir bestimmte Entscheidungen getroffen haben, zu verstehen. </p><br><p>  CarPlay ist kein Betriebssystem in einem anderen Betriebssystem, da so viele Artikel darüber schreiben.  Wenn ungefähr, dann ist CarPlay ein Protokoll für die Arbeit mit einer externen Anzeige des Bildschirms der Headunit.  Ton von Autolautsprechern;  Touchscreens, Touchscreens, Unterlegscheiben und andere Eingabegeräte. </p><br><p>  Das heißt, der gesamte ausführbare Code befindet sich direkt in der Hauptanwendung (nicht einmal in einer separaten Erweiterung!). Dies ist sehr cool: Um neue Funktionen zu erhalten, müssen Sie weder das Radio noch den Computer aktualisieren, sondern nur iOS aktualisieren. </p><br><p> Auf der Keynote zur WWDC 2018 hatten wir die Gelegenheit, Navigationsanwendungen für CarPlay zu erstellen, was uns sehr freute.  Unmittelbar nach der Präsentation haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage</a> für die Erlaubnis zur Entwicklung für CarPlay gesendet.  In der Anfrage musste gezeigt werden, dass unsere Anwendung navigationsfähig ist. </p><br><p>  Während wir auf eine Antwort von Apple warteten, gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vortrag,</a> in dem unter Verwendung der Beispielanwendung CountryRoads über die Arbeit mit CarPlay.framework gesprochen wurde.  In der Vorlesung wurde nicht auf die Fallstricke und Feinheiten bei der Arbeit mit CarPlay eingegangen, sondern es wurde erwähnt, dass die Anwendung nach dem Herstellen einer Verbindung zum CarPlay-Radio im Hintergrundmodus arbeitet. </p><br><h2 id="pervaya-palka-v-kolyosa">  Zuerst in die Räder stecken </h2><br><p>  Die Bewerbung im Hintergrund hat uns enttäuscht.  Dafür gab es zwei Gründe: </p><br><ol><li>  Wir arbeiten nicht im Hintergrund.  Einmal diese Einschränkung aus technischen Gründen und zur Energieeinsparung verlassen. </li><li>  Unsere Karte ist in OpenGL geschrieben (ja, veraltet, ja, nicht Metal, das wissen wir alle), und OpenGL im Hintergrund funktioniert nicht.  Im besten Fall erhalten Sie eine schwarze Ansicht und im schlimmsten Fall einen Absturz. </li></ol><br><p>  Es war immer noch möglich, die Arbeit im Hintergrund zu bewältigen, aber die Karte musste definitiv gelöst werden.  Dann kam die Idee, es durch das Standard-MKMapView zu schaffen.  Bis Sie angefangen haben, Steine ​​auf uns zu werfen, um Standard-Apple-Karten zu verwenden, erkläre ich: Wir wollten MKMapView verwenden, aber keine Apple-Karten. </p><br><p>  Tatsache ist, dass MKMapView Kacheln von Drittanbietern laden kann.  Fliesen sind spezielle rechteckige Behälter für Texturen.  Wir haben uns gerade als Servochka herausgestellt, der weiß, wie man Fliesen gibt.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt</a> Implementierungscode auf GitHub. </p><br><h2 id="otvet-ot-apple">  Apple antwortet </h2><br><p> Wir erhielten eine Antwort von Apple, in der wir neben der Erlaubnis zur Entwicklung auch die Dokumentation "für die Elite", den Code der CountryRoads-Beispielanwendung (die in der WWDC-Vorlesung gezeigt wurde) und vor allem den privaten Fähigkeitsschlüssel <code>com.apple.developer.carplay-maps</code> .  Dieser Schlüssel wird in die Berechtigungsdatei mit dem Wert YES geschrieben, damit das System versteht, dass Sie Ereignisse aus CarPlay verarbeiten können, wenn Ihre Anwendung gestartet wird. </p><br><p>  Ohne auf den Sprint mit den ausgewählten Geschichten für die Entwicklung zu warten, stieg ich auf, um Xcode Beta herunterzuladen.  Der erste Versuch, 2GIS zu sammeln, war ein Fehlschlag.  Das CoutryRoads-Beispielanwendungsprojekt konnte jedoch für den Simulator zusammengestellt werden. </p><br><p>  Vor jedem Öffnen des CarPlay-Simulatorfensters musste letzteres über ein solches Fenster angepasst werden: </p><br><p><img src="https://habrastorage.org/webt/3p/xn/rf/3pxnrf5dlvtq7n8qkuovquqgbbi.png"></p><br><p>  Dazu mussten Sie eine Zeile in das Terminal <code>defaults write com.apple.iphonesimulator CarPlayExtraOptions -bool YES</code> </p><br><p>  Aus irgendeinem Grund funktionierte dies nicht - ich musste es auf fast dem kleinsten Simulator mit einer Auflösung von 800 × 480 Punkten und einer × 2-Skala ausführen.  Im Moment funktioniert diese Einstellung und hilft sehr. </p><br><p>  Nachdem ich mein Beispielprojekt erstellt und mit Dokumentation ausgestattet hatte, begann ich zu verstehen, was geschah. <br>  Als erstes wurde mir klar: Navigationsanwendungen für CarPlay bestehen aus Basisansicht und Vorlagenebenen. </p><br><p><img src="https://habrastorage.org/webt/hf/t2/rw/hft2rwp8m2d71popp3tus4dif20.jpeg"></p><br><p>  Basisansicht ist Ihre Karte.  Auf dieser Ebene sollte sich nur eine Karte befinden, keine anderen Ansichten und Steuerelemente. </p><br><p>  Vorlagen sind fast nicht anpassbare obligatorische UI-Elemente zum Anzeigen von Routen, Manövern, Listen aller Art usw. </p><br><h2 id="razrabotka-bety">  Beta-Entwicklung </h2><br><p>  Fahren wir mit dem Schreiben von Code fort.  Als erstes müssen Sie einige erforderliche CPApplicationDelegate-Methoden in die ApplicationDelegate-Datei implementieren. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didDisconnectCarInterfaceController controller: CPInterfaceController, from window: CPWindow )</span></span></span></span> {}</code> </pre> <br><p>  Schauen wir uns die Signatur an: </p><br><p>  Mit UIApplication ist alles klar. <br>  CPWindow ist der Nachfolger von UIWindow, einem Fenster für die externe Anzeige der Headunit des Radios. <br>  CPInterfaceController - so etwas wie ein Analogon von UINavigationController, nur von CarPlay.framework. </p><br><p>  Nun fahren wir direkt mit der Implementierung der Methode fort. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carMapViewController = <span class="hljs-type"><span class="hljs-type">CarMapViewController</span></span>( interfaceController: controller ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigationController = <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>( rootViewController: carMapViewController ) window.rootViewController = navigationController }</code> </pre> <br><p>  In didConnect müssen Sie Code schreiben, der dem in didFinishLaunching verwendeten ähnlich ist.  CarMapViewController ist eine Basisansicht (der Controller ist tatsächlich, aber in Ordnung) gemäß der Dokumentation. </p><br><p>  Hier ist das Bild, das ich endlich bekommen habe: </p><br><p><img src="https://habrastorage.org/webt/vv/l1/xx/vvl1xxebjbdb9ahiuucw1db_rzg.png"></p><br><p>  Irgendwann zu dieser Zeit wurde mir klar, dass das neue Xcode-Neubausystem standardmäßig aktiviert ist und 2GIS dies höchstwahrscheinlich nicht tun wird. </p><br><p>  Ich habe Xcode geöffnet, ein älteres (oder eher stabiles, nennen wir einen Spaten einen Spaten) Build-System installiert und meine Theorie wurde bestätigt: 2GIS wurde zusammengestellt. </p><br><p>  Nachdem ich den gleichen Funktionsschlüssel festgelegt hatte, startete ich 2GIS unter CarPlay und sah keine Protokolle über die Umschaltung der Anwendung in den Hintergrundmodus.  Es wurde noch unverständlicher, weil Apple-Ingenieure aus der Szene über den Hintergrundmodus sprachen, uns aber andererseits eine ContentView von UIAlertView versprachen und UIAlertView infolgedessen veraltet war. </p><br><p>  Nachdem ich beschlossen hatte, dass es so sein sollte, habe ich mich nicht mit MKMapView beschäftigt.  Es würde uns offline berauben und uns dazu bringen, das Rendern der Routen neu zu schreiben. </p><br><h2 id="problema-odnoy-karty">  Einzelkartenproblem </h2><br><p>  Ich hatte keine Zeit, mich über die Nachricht zu freuen, dass CarPlay unsere Karte haben wird, da mich das folgende Problem stellte: Aufgrund der technischen Merkmale kann es nur eine Karte geben. <br>  Eine schnelle Lösung für dieses Problem war, wenn auch nicht sehr elegant. </p><br><p>  Wenn Sie 2GIS auf CarPlay verwenden, ist das Telefon normalerweise gesperrt und liegt irgendwo im Regal.  Daher wird die Karte in diesem Moment am Telefon nicht wirklich benötigt (die Suche wird natürlich nicht schaden).  Als wir das Telefon mit CarPlay verbunden haben, haben wir uns daher entschlossen, die Karte aus der Hauptanwendung zu nehmen und auf dem CarPlay-Bildschirm des Radios anzuzeigen.  Wenn die Verbindung getrennt ist, kehren Sie auf dem Telefon zur Anwendung zurück. </p><br><p>  Ja, es ist eine Lösung für sich selbst, aber es ist schnell, es funktioniert immer noch und es mussten nicht ein paar andere Befehle ausgeführt werden, um MVP zu nieten. </p><br><h2 id="kontroly-na-karte">  Steuerelemente auf der Karte </h2><br><p>  Also haben wir unsere Karte auf dem Radiobildschirm.  Jetzt war es notwendig, die ersten und offensichtlichen Dinge für jede Karte zu tun: Steuerelemente für Zoom, aktuellen Standort und Kartenbewegung. </p><br><p><img src="https://habrastorage.org/webt/c2/ql/u8/c2qlu8wi-sbkh5zizb7mjab-n7w.png"></p><br><p>  Beginnen wir mit dem Zoom und der aktuellen Position, da sich diese Steuerelemente auf der Karte selbst befinden und keine gewöhnliche UIControl sind.  Wie ich oben geschrieben habe, befindet sich nur die Karte in der Basisansicht. </p><br><p>  Um diese Steuerelemente auf der Karte zu platzieren, musste ich erneut in die Dokumentation und die Beispielanwendung gehen.  Dort habe ich über die erste Vorlage gelesen - CPMapTemplate. </p><br><p><img src="https://habrastorage.org/webt/5d/xn/26/5dxn263mlspdif8eqhxgc8wjgmc.png"></p><br><p>  CPMapTemplate - eine transparente Vorlage zum Anzeigen einiger Steuerelemente auf der Karte und analog zur Navigationsleiste.  Es wird wie folgt erstellt und eingerichtet: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapTemplate = <span class="hljs-type"><span class="hljs-type">CPMapTemplate</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.setRootTemplate(mapTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  Als nächstes müssen Sie diese Steuerelemente erstellen und auf die Karte legen. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomInButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomOutButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myLocationButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.mapButtons = [ zoomInButton, zoomOutButton, myLocationButton ]</code> </pre> <br><p>  Das mapButtons-Array erwies sich jedoch als witzig, da unabhängig von der Anzahl der Elemente nur die ersten drei Elemente auf dem Bildschirm angezeigt werden.  Sie erhalten keine Fehler im Protokoll oder in den Zusicherungen. </p><br><p>  Dann habe ich gesehen, wie ich die Karte bewegen kann, und ich habe dies in der Dokumentation gefunden: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Seltsam, dachte ich und musste sehen, wie das in der CountryRoads-Beispielanwendung gemacht wird.  Die Antwort ist über diese Schnittstelle: </p><br><p><img src="https://habrastorage.org/webt/o0/wa/v6/o0wav6ogb8ofbx7-xqxsamjd6g4.png"></p><br><p>  Nicht sehr praktisch, aber auf andere Weise wird die Dokumentation nicht lügen, oder? </p><br><p>  Da der Platz für Steuerelemente auf der Karte abgelaufen war, musste in diesem Analogon der Navigationsleiste eine Schaltfläche erstellt werden, um die Karte in den "Drag" -Modus zu versetzen. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> panButton = <span class="hljs-type"><span class="hljs-type">CPBarButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.leadingNavigationBarButtons = [panButton] <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.trailingNavigationBarButtons = []</code> </pre> <br><p>  Aber auch die Arrays der führenden NavigationBarButtons und der nachfolgendenNavigationBarButtons waren nicht ohne Witz: Wie viele Elemente in ihnen schieben, nehmen sie nur die ersten beiden.  Auch ohne Fehler im Protokoll und Zusicherungen. </p><br><p>  Um den Drag &amp; Drop-Modus für Karten zu aktivieren und zu deaktivieren, müssen Sie Folgendes schreiben: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.showPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.dismissPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><h2 id="postroenie-i-otobrazhenie-marshrutov-na-karte">  Erstellen und Anzeigen von Routen auf einer Karte </h2><br><p>  Als Nächstes begann ich, unsere vorhandene API zum Erstellen von Routen wiederzuverwenden. </p><br><p>  Nur für eine Demo und um zu verstehen, was und wie zu tun ist, habe ich beschlossen, zwei Punkte zu nehmen und eine Route zwischen ihnen zu erstellen.  Punkt A war der Standort des Benutzers und Punkt B war unser Hauptbüro in Nowosibirsk. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice0 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [<span class="hljs-string"><span class="hljs-string">"1  7 "</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice1 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [“<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-string"><span class="hljs-string">"] ) let startItem = MKMapItem(…) let endItem = MKMapItem(…) endItem.name = "</span></span>,  ” <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> trip = <span class="hljs-type"><span class="hljs-type">CPTrip</span></span>( origin: startItem, destination: endItem, routeChoices: [choice0, choice1] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tripPreviewTextConfiguration = <span class="hljs-type"><span class="hljs-type">CPTripPreviewTextConfiguration</span></span>( startButtonTitle: <span class="hljs-string"><span class="hljs-string">" ”, additionalRoutesButtonTitle: “”, overviewButtonTitle: "</span></span><span class="hljs-string"><span class="hljs-string">" ) self.mapTemplate.showTripPreviews( [trip], textConfiguration: tripPreviewTextConfiguration )</span></span></code> </pre> </div></div><br><p>  Auf dem Bildschirm haben wir ein Steuerelement mit einer Beschreibung der Route: </p><br><p><img src="https://habrastorage.org/webt/wi/on/5r/wion5rbc8wx75tqwxzn-x72zsqw.png"></p><br><h2 id="rezhim-navigacii">  Navigationsmodus </h2><br><p>  Routen sind gut, aber das Hauptmerkmal des Navigators ist die Navigation.  Damit es angezeigt wird, müssen Sie Folgendes schreiben: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mapTemplate: CPMapTemplate, startedTrip trip: CPTrip, using routeChoice: CPRouteChoice )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.startNavigationSession(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: trip) }</code> </pre> <br><p>  CPNavigationSession - eine Klasse, mit der Sie einige UI-Elemente anzeigen können, die nur im Navigationsmodus erforderlich sind. </p><br><p>  Um das Manöver anzuzeigen, müssen Sie: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maneuver = <span class="hljs-type"><span class="hljs-type">CPManeuver</span></span>() maneuver.symbolSet = <span class="hljs-type"><span class="hljs-type">CPImageSet</span></span>( lightContentImage: icon, darkContentImage: darkIcon ) maneuver.instructionVariants = [<span class="hljs-string"><span class="hljs-string">". "</span></span>] maneuver.initialTravelEstimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.upcomingManeuvers = [maneuver]</code> </pre> <br><p>  Dann erhalten wir auf dem Bildschirm des Radios Folgendes: </p><br><p><img src="https://habrastorage.org/webt/30/uj/tp/30ujtpqhaaqkgx1oon7mjxpxiq8.png"></p><br><p>  Um das Filmmaterial zum Manövrieren zu aktualisieren, müssen Sie: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> estimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.updateEstimates(estimates, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: maneuver)</code> </pre> <br><h2 id="it-just-works">  Es funktioniert einfach! </h2><br><p>  Als die Grundfunktionalität für den Navigator fertig war, beschloss ich, dieses Handwerk in einer internen Präsentation zu zeigen.  Die Präsentation war ein Erfolg: Jeder hatte die Idee, den Navigator so schnell wie möglich fertigzustellen, zu testen und zu starten. </p><br><p>  Zunächst bestellten wir eine echte Headunit mit CarPlay-Unterstützung.  Und dann, wie sie sagen, begann die Hitze. </p><br><p><img src="https://habrastorage.org/webt/wz/2-/cj/wz2-cjj1rusmnd270gkr5h8tdj0.jpeg" alt="PIONEER AVH-Z500BT"></p><br><h3 id="provision-profiles">  Bereitstellungsprofile </h3><br><p>  Aufgrund des Hinzufügens eines neuen Funktionsschlüssels müssen Profile neu generiert werden.  In der normalen Entwicklung denken wir nicht darüber nach, da Xcode alles selbst erledigt.  Aber nicht bei einem privaten Schlüssel. </p><br><pre> <code class="plaintext hljs">Code Signing Error: Automatic signing is unable to resolve an issue with the "v4ios" target's entitlements. Automatic signing can't add the com.apple.developer.carplay-maps entitlement to your provisioning profile. Switch to manual signing and resolve the issue by downloading a matching provisioning profile from the developer website.</code> </pre> <br><p>  Außerdem wurde unser CI beschädigt, da wir für die lokale Verteilung von Anwendungsversionen ein Unternehmenskonto verwenden, in dem wir keine Erlaubnis zur Entwicklung der Anwendung für CarPlay angefordert haben.  Aber das ist eine ganz andere Geschichte. </p><br><h3 id="debugging">  Debuggen </h3><br><p>  Sie können über Bluetooth oder Lightning eine Verbindung zu CarPlay herstellen.  Die Praxis zeigt, dass die zweite Methode viel beliebter ist.  Unser Bluetooth-Radio wusste nicht wie, daher musste ich während der Entwicklung das Wi-Fi-Debug verwenden.  Wenn Sie es bei Projekten versucht haben, die schwieriger sind als Hallo Welt, dann wissen Sie, was zum Teufel es ist. </p><br><div class="spoiler">  <b class="spoiler_title">Und für diejenigen, die es nicht versucht haben, sage ich:</b> <div class="spoiler_text"><p>  Ich habe die Anwendung per Kabel zum Telefon gesammelt und erst dann, als ich das Telefon über WLAN mit CarPlay verband, auf das Telefon hochgeladen und einige Minuten lang ausgeführt. <br>  Das Kopieren der Anwendung auf das Telefon dauerte ungefähr 3 Minuten, das Starten der Anwendung für ungefähr eine Minute und erst dann, nachdem der Stopp an den Haltepunkten gestartet wurde, nur 15 Sekunden später. </p></div></div><br><p>  Und dann wurde es für mich sehr interessant, warum Apple kein DevKit hergestellt hat (so dass es nach Apple-Art einfach funktioniert und das ist alles).  Es war nicht sehr bequem, einen Prüfstand ohne ihn zu montieren.  Bis jetzt fällt alle paar Wochen etwas ab - man muss sich auf den Bildern merken, worauf man sich einlassen soll.  Es ist gut, dass der Administrator bei der Montage dieses Standes gesagt hat, was und warum. </p><br><h2 id="the-best-framework-we-ever-made">  Der beste Rahmen, den wir je gemacht haben </h2><br><p>  Am Ende, als alles auf einem realen Gerät zusammengebaut wurde, wurde klar, dass das Feature „2GIS for CarPlay“ definitiv sein würde.  Es ist Zeit, Schönheit zu tun. </p><br><h3 id="problemy-s-vyuportom">  Viewport-Probleme </h3><br><p>  Das Kartenansichtsfenster musste so konfiguriert werden, dass Routen in dem Gebiet ohne unnötige Steuerelemente und nicht nur in der Mitte gezeichnet werden.  Kurz gesagt, damit es anders aussieht: </p><br><p><img src="https://habrastorage.org/webt/ns/-k/gw/ns-kgwhubcu9cdqybc4nierpkqe.png"></p><br><p>  Und so: </p><br><p><img src="https://habrastorage.org/webt/tl/sg/i3/tlsgi347mdeagljpg7i8ojxcjxc.png"></p><br><p>  Ich hatte gehofft, eine Art Layout-Leitfaden mit dem aktuell sichtbaren Bereich zu erhalten.  Damit berücksichtigt er die Navigationsleiste, die Ansicht mit der Route und die Steuerelemente auf der Karte.  Tatsächlich habe ich nichts bekommen.  Es ist immer noch unklar, wie das Ansichtsfenster konfiguriert werden soll, daher haben wir einen Hardcode wie: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> routeControlsWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.48</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomControlWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.15</span></span></code> </pre> <br><h3 id="postroenie-proezda-ne-tolko-mezhdu-dvumya-tochkami">  Konstruktion des Durchgangs nicht nur zwischen zwei Punkten </h3><br><p>  In der ersten Version haben wir beschlossen, unseren über CPGridTemplate erstellten Rubrikator zu verwenden: </p><br><p><img src="https://habrastorage.org/webt/co/ri/ec/coriec6zvpz0pg5uy72kontsmc8.png"></p><br><p>  Favoriten und Home / Work über CPListTemplate. </p><br><p><img src="https://habrastorage.org/webt/mh/iu/le/mhiulexz-l0j4snzfhdx8pvx8pa.png"></p><br><p>  Und Tastatursuche über CPSearchTemplate: </p><br><p><img src="https://habrastorage.org/webt/gj/jp/co/gjjpcobjxxf3q_u3gdcoscfclda.png"></p><br><p>  Ich werde den Code über Vorlagen nicht anzeigen, da er einfach ist und die Dokumentation dazu gut geschrieben ist (zumindest über etwas). </p><br><div class="spoiler">  <b class="spoiler_title">Es ist jedoch erwähnenswert, welche Probleme bei der Arbeit mit ihnen entdeckt wurden.</b> <div class="spoiler_text"><p>  CPInterfaceController kann in der Navigation ähnlich wie UIKit.  d.h. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.pushTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.presentTemplate(alertTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  Wenn Sie jedoch versuchen, beispielsweise CPAlertTemplate auszuführen, erhalten Sie in den Protokollen die Bestätigung, dass CPAlertTemplate nur modal dargestellt werden kann. </p><br><p>  Es ist nicht klar, warum Apple die Logik der Tranchen nicht unter der Haube versteckt hat, ohne eine Schnittstelle wie die folgende erstellt zu haben: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.showTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  Es brach auch die Fähigkeit, die Erben von CPTemplate wie Controller in UIKit zu verwenden. </p><br><p>  Wenn Sie beispielsweise versuchen, Ihren Erben auf den Vorlagenstapel zu legen, erhalten Sie Folgendes: </p><br><pre> <code class="plaintext hljs">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Unsupported object &lt;YourAwesomeGridTemplate: 0x60000060dce0&gt; &lt;identifier: 6CAC7E3B-FE70-43FC-A8B1-8FC39334A61D, userInfo: (null)&gt; passed to pushTemplate:animated:. Allowed classes: {( CPListTemplate, CPGridTemplate, CPSearchTemplate, CPMapTemplate )}'</code> </pre> </div></div><br><h3 id="testirovanie-i-bagi">  Tests und Fehler </h3><br><p>  Getestet von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">artemenko-aa</a> .  Einer der ersten Fehler, den er gefunden hat, können wir immer noch nicht beheben. </p><br><p>  Tatsache ist, dass Watchdog uns sporadisch festnagelt, wenn Sie das Telefon vom CarPlay-Radio trennen - ohne den Grund zu erklären.  Selbst wenn Syslogs geöffnet wurden, ist nichts klar.  Wenn Sie also eine Idee haben, wie Sie den Grund beheben oder verstehen können, können Sie dies gerne kommentieren. </p><br><p>  Der nächste Fehler war am selben Ort, aber mit einem besonderen Verhalten.  Ich habe oben geschrieben, dass die didDisconnect-Methode von CPApplicationDelegate aufgerufen wird, wenn das Telefon von CarPlay getrennt wird.  Bei dieser Methode kehren wir die Karte vom Radiobildschirm zurück zur Hauptanwendung zurück.  Stellen Sie sich vor, wie viele Probleme wir bekommen würden, wenn diese Methode nicht mindestens einmal von fünf aufgerufen würde. </p><br><p>  Es wurde deutlich, dass dies ein Problem von iOS und nicht speziell unserer Anwendung ist, da das gesamte System glaubte, dass es mit CarPlay verbunden war. </p><br><p><img src="https://habrastorage.org/webt/nh/3v/tc/nh3vtc2h-zlu5jutajc6-oyoca4.jpeg"></p><br><p>  Ich habe es sogar als Radar gemeldet (wie alle anderen Bugs).  Ich wurde gebeten, Protokolle mit einem solchen Profil zu löschen, aber ich konnte einige Zeit nicht auf die Unterstützung antworten, sodass das Radar geschlossen wurde. </p><br><p>  Da Apple nichts vorhatte, musste das Problem selbst umgangen werden, da es ziemlich oft reproduziert wurde. </p><br><p>  Und dann erinnerte ich mich, dass der Löwenanteil der Verbindungen zu CarPlay über Lightning erfolgt.  Dies bedeutet, dass das Telefon zum Zeitpunkt der Verbindung aufgeladen wird und zum Zeitpunkt der Trennung der Ladevorgang beendet wird.  In diesem Fall können Sie den Akkustatus abonnieren und genau herausfinden, wann das Telefon nicht mehr aufgeladen und von CarPlay getrennt wurde. </p><br><p>  Das Schema ist gebrechlich, aber wir hatten keine Wahl.  Wir sind diesen Weg gegangen und es hat funktioniert! </p><br><p><img src="https://habrastorage.org/webt/ql/1h/j0/ql1hj02fnqottbo5fstubt65pss.jpeg"></p><br><p>  Glücklicherweise wurde diese Krücke längst aus dem Code entfernt: Apple-Entwickler haben alles in einer der iOS-Versionen behoben. </p><br><h2 id="istoriya-dvuh-redzhektov">  Die Geschichte zweier Redakteure </h2><br><p>  <strong>Die erste Weiterleitung</strong> bezog sich auf Metadaten.  Der Text des Editorials besagt, dass unsere Beschreibung (keine Versionshinweise) nicht besagt, dass wir CarPlay unterstützen.  Wie Sie sich vorstellen können, hatten dies weder die Überprüfungsrichtlinie noch Google Maps.  Wir haben uns nicht gestritten (weil es normalerweise länger ist als das Bearbeiten der Metadaten), wir haben die Zeile von den Versionshinweisen in die Beschreibung kopiert und auf eine neue Überprüfung gewartet. </p><br><p>  <strong>Das zweite Redject</strong> geschah aufgrund der Liste der Städte.  2GIS hat eine sehr coole Funktion - den vollständigen Offline-Betriebsmodus.  Diese Funktion hat uns ins Bein geschossen. </p><br><p>  Wenn Sie eine Anwendung ohne etablierte Stadt mit CarPlay verbinden, wird die Karte nicht angezeigt, da nichts angezeigt werden kann.  Und dafür waren wir geplant.  Die Lösung war einfach: eine Warnung ohne Schaltflächen, die besagt, dass Sie die Stadt herunterladen müssen. </p><br><p><img src="https://habrastorage.org/webt/uf/t7/rx/uft7rxuuaqu7ape9ehifdi6r6ki.png"></p><br><h2 id="to-o-chyom-nelzya-govorit">  Worüber Sie nicht sprechen können </h2><br><h3 id="peremeschenie-karty-zhestami">  Bewegung der Gestenkarte </h3><br><p>  Etwa zur gleichen Zeit kam der Navigator unter CarPlay von Google Maps heraus - und dort konnten Sie die Karte mit Gesten über den Bildschirm bewegen.  Private APIs, dachte ich, das ist offensichtlich!  Die Jungs von Google kamen gerade aus einem nahe gelegenen Gebäude und sagten, was sie brauchten.  Immerhin heißt es in der Dokumentation: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Trotzdem habe ich mich entschlossen, mich zu vergewissern und wurde gegoogelt, obwohl es fast sinnlos war, da es keine technischen Artikel über CarPlay Navigation Apps gab.  Es gelang mir jedoch, etwas Nützliches und PLÖTZLICH <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Apple-Website zu finden</a> . </p><br><p>  In den Richtlinien habe ich ein Video gefunden, das besagt, dass die Dokumentation unverschämt lügt.  Das Video zeigt, wie Sie die Karte immer noch mit Gesten ziehen können.  Mir wurde klar, dass ich nichts verstand, und ich musste nur noch CarPlay.framework öffnen und alle .h-Dateien überprüfen. </p><br><p>  Und siehe da!  Ich finde in CPMapTemplate seinen Delegaten CPMapTemplateDelegate, in dem es drei Methoden gibt, die zu schreien scheinen, dass Sie, wenn Sie sie implementieren, die Kontrolle über die Gesten der Karte erhalten können. </p><br><div class="spoiler">  <b class="spoiler_title">3 Methoden</b> <div class="spoiler_text"><p>  / * <em>Wird aufgerufen, wenn eine Schwenkgeste beginnt.</em>  <em>Wird möglicherweise nicht aufgerufen, wenn eine Verbindung zu einigen CarPlay-Systemen besteht.</em> <em><br></em>  /. <br>  optionale öffentliche Funktion mapTemplateDidBeginPanGesture (_ mapTemplate: CPMapTemplate) </p><br><p>  / * <em>Wird aufgerufen, wenn sich eine Schwenkgeste ändert.</em>  <em>Wird möglicherweise nicht aufgerufen, wenn eine Verbindung zu einigen CarPlay-Systemen besteht.</em> <em><br></em>  /. <br>  optionale öffentliche Funktion mapTemplate (_ mapTemplate: CPMapTemplate, didUpdatePanGestureWith Übersetzung Übersetzung: CGPoint, Geschwindigkeit: CGPoint) </p><br><p>  / * <em>Wird aufgerufen, wenn eine Schwenkgeste endet.</em>  <em>Wird möglicherweise nicht aufgerufen, wenn eine Verbindung zu einigen CarPlay-Systemen besteht.</em> <em><br></em>  /. <br>  optional public func mapTemplate (_ mapTemplate: CPMapTemplate, didEndPanGestureWithVelocity Geschwindigkeit: CGPoint <br>  ) </p></div></div><br><p>  Ich habe sie implementiert und die Anwendung auf einem Simulator ausgeführt - nichts hat funktioniert.  Da ich keine Zeit hatte, mich aufzuregen, erkannte ich, dass der Simulator die gleiche Qualität wie die Dokumentation haben kann, und legte ihn auf das Gerät.  Alles begann, das Glück kannte keine Grenzen! </p><br><p>  Unterhaltsame Tatsache: Ein CarPlay-Radio benötigt ein Viertel des Bildschirms, um zu verstehen, dass eine Schwenkgeste begonnen hat.  Ich möchte darauf hinweisen, dass UIPanGestureRecognizer nur 10 Punkte benötigt. </p><br><h3 id="neodinakovost-ui-na-raznyh-magnitolah">  Einheitlichkeit der Benutzeroberfläche auf verschiedenen Radiorecordern </h3><br><p>  Wir haben einen Aufruf zur Unterstützung erhalten: Der Benutzer hat nur einen Sajest, der in der Suche herauskriecht, obwohl es mehr hätte geben können.  Es ist seltsam, dachte ich, denn auf allen Bildschirmen passt nur eine Zeile.  Habe einen Screenshot angefordert: </p><br><p><img src="https://habrastorage.org/webt/_t/k7/u6/_tk7u6wbcv55zig2n-b1dlbm9hu.png"></p><br><p>  Und das ist völlig anders als die CPSearchTemplate-Benutzeroberfläche, die ich oben gezeigt habe.  Und dies muss bei der Entwicklung berücksichtigt werden, obwohl es immer noch unmöglich ist zu verstehen, wie viele Zellen in der Platte unten auf den Bildschirm passen können. </p><br><h3 id="kontrol-ogranicheniya-skorosti">  Geschwindigkeitsbegrenzungssteuerung </h3><br><p>  Wir haben uns die Statistiken angesehen und festgestellt, dass sie den Navigator für CarPlay verwenden, und wir müssen ihn mindestens auf die Ebene des Navigators in der Hauptanwendung bringen.  Zunächst haben wir uns für eine Geschwindigkeitsbegrenzung entschieden.  Natürlich gab es einige Probleme. </p><br><p>  Frage Nummer eins: Wo platzieren? </p><br><p>  Beim erneuten Stöbern in den .h-Dateien in CPWindow fand ich einen merkwürdigen layoutGuide: <br>  var mapButtonSafeAreaLayoutGuide: UILayoutGuide </p><br><p>  Und das stellte sich als das heraus, was wir brauchten.  Unsere Steuerung passt perfekt dazu: </p><br><p><img src="https://habrastorage.org/webt/vo/m7/qw/vom7qwpkpnxqf9a7wk6arc8-gtm.png"></p><br><p><img src="https://habrastorage.org/webt/q7/kq/fh/q7kqfhk7rrtwdzmergpd9yobbz0.png"></p><br><p>  Frage Nummer zwei: Ist das generell legal? </p><br><p>  Tatsache ist, dass sich die Steuerung technisch in der Basisansicht befindet.  Und die Basisansicht gemäß der Dokumentation darf nur eine Karte enthalten: </p><br><pre> <code class="plaintext hljs">The base view is where the map is drawn. The base view must be used exclusively to draw a map, and may not be used to display other UI elements. Instead, navigation apps overlay UI elements such as the navigation bar and map buttons using the provided templates.</code> </pre> <br><p>  Die Rezensenten haben uns jedoch im AppStore vermisst, sodass Steuerelemente, die sich auf die Navigation beziehen, weiterhin integriert werden können. </p><br><h3 id="golosovoy-poisk">  Sprachsuche </h3><br><p><img src="https://habrastorage.org/webt/di/tt/ov/dittovwssqwrbku8rfd7fxpqlqo.png"></p><br><p><img src="https://habrastorage.org/webt/td/co/z-/tdcoz-1fk1-x880os0muqc_2iso.png"></p><br><p>  In guter Weise musste diese Funktion zuerst ausgeführt werden, aber wir haben mehrere Aufgaben aus der technischen Verschuldung angesammelt, die die Implementierung der Sprachsuche für CarPlay verhinderte.  Und diese Aufgabe war nicht so einfach, wie es schien. </p><br><p>  <strong>Das erste Problem: Animationen.</strong>  Tatsache ist, dass es in CPVoiceControlTemplate keine Möglichkeit gibt, Standardanimationen zu erstellen.  Animationen für die Spracherkennung und -suche mussten Frame für Frame aus Bildern gesammelt werden und angeben, wie viel Zeit sie vergangen sind. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">12</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"carplay_searching_\(i)"</span></span>) { images.append(image) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>.animatedImage(with: images, duration: <span class="hljs-number"><span class="hljs-number">0.96</span></span>)</code> </pre> <br><p>  Es sieht, wie Sie vielleicht vermuten, nicht wirklich aus, aber ich möchte die Größe der Anwendung nicht erhöhen. </p><br><p>  <strong>Das zweite Problem: Zugriffe.</strong>  Auf dem Display des Telefons werden Warnungen für den Mikrofonzugriff und die Spracherkennung angezeigt.  Ich musste auf das Radio-Display schreiben, dass der Benutzer das Telefon abheben, die Erlaubnis geben und erst dann den Navigator im Radio verwenden muss.  Sehr bequem! </p><br><h3 id="pravorulnye-avtomobili">  Autos mit Rechtslenkung. </h3><br><p>  Wir erhielten einen Screenshot, in dem die Benutzeroberfläche der gesamten Anwendung auf den Kopf gestellt wurde! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e5c/b97/dc2/e5cb97dc248ebb9ffa0ff46147c290d7.jpg"></p><br><p>  Und natürlich blieb das Karten-Ansichtsfenster so, wie wir es fest codiert hatten, da niemand damit gerechnet hatte, dass es eine separate Einstellung für Autos mit Rechtslenkung gab.  Ich habe nicht herausgefunden, wie ich das richtig umgehen kann, aber ich habe festgestellt, dass unsere Geschwindigkeitsbegrenzungssteuerung, da sie im layoutGuide für Kartensteuerungen liegt, nach links verschoben wurde. </p><br><p>  Ultrafix ließ nicht lange auf sich warten.  Sie haben es grob gemacht, aber es funktioniert. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isLeftWheelCar = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.speedControlViewController.view.frame.origin.x &gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.size.width / <span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich hoffe wirklich, dass es eine richtige Lösung gibt, und ich habe sie einfach nicht gelesen. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles für mich. </font><font style="vertical-align: inherit;">Wenn Sie plötzlich vorhaben, unter CarPlay einen eigenen Navigator zu erstellen, beachten Sie, dass die Dokumentation und das Framework nicht perfekt sind. </font><font style="vertical-align: inherit;">Die Plattform ist völlig neu, niemand weiß etwas und Apple hat es nicht eilig, Wissen zu teilen.</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452638/">https://habr.com/ru/post/de452638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452620/index.html">Ableiten eines Aktionstyps mithilfe von Typescript</a></li>
<li><a href="../de452622/index.html">Einführung in die Genomik für Programmierer</a></li>
<li><a href="../de452624/index.html">Einführung in Spring Boot Actuator</a></li>
<li><a href="../de452628/index.html">Benutzerdefiniertes unteres Blatt: wie es funktionieren sollte</a></li>
<li><a href="../de452630/index.html">Backup, Teil 2: Übersicht und Testen von rsync-basierten Backup-Tools</a></li>
<li><a href="../de452642/index.html">Die Stärke der Menge. Wie Chicago einen Müllroboter entwickelte - einen Flussreiniger</a></li>
<li><a href="../de452644/index.html">DevConf X Web Developer Conference - 21. Juni</a></li>
<li><a href="../de452646/index.html">Was das neuronale Netz auf dem ersten Foto eines Schwarzen Lochs sah</a></li>
<li><a href="../de452648/index.html">PHP: Wie man eine komplexe XML-Datei analysiert und nicht in nativem Code ertrinkt</a></li>
<li><a href="../de452652/index.html">Sicherheitswoche 21: Eine Lücke in WhatsApp, eine neue Sicherheitslücke in Intel-Prozessoren, Zero-Day in Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>