<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏹 👆🏼 👨🏼‍✈️ Analyse de mutation, ou comment tester des tests 👩🏽‍🚀 🔡 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a jamais trop de tests - tout le monde le sait. Les mèmes sur les tests unitaires et d'intégration ne sont plus très amusants. Mais nous ne sav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse de mutation, ou comment tester des tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421141/">  Il n'y a jamais trop de tests - tout le monde le sait.  Les mèmes sur les tests unitaires et d'intégration ne sont plus très amusants.  Mais nous ne savons toujours pas s'il est possible de se fier aux résultats des tests, et quel pourcentage de couverture nous permettra d'éviter les bugs en production.  Si des changements fatals dans les tests de saut de code, sans affecter leur résultat, la solution se suggère alors - vous devez tester les tests! <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  L'approche pour automatiser cette tâche a été le rapport de Mark Langovoy de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a> .  La vidéo et l'article sont courts et les idées fonctionnent très bien - vous devez en prendre note. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-1820HwCJUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>À propos du conférencier:</strong> Mark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Langovoi</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">marklangovoi</a> ) travaille à Yandex dans le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yandex.Tolok</a> .  Il s'agit d'une plateforme de crowdsourcing permettant de baliser rapidement de grandes quantités de données.  Les clients téléchargent des données qui, par exemple, doivent être préparées pour être utilisées dans les algorithmes d'apprentissage automatique, et fixer un prix, et de l'autre côté, les exécuteurs peuvent effectuer des tâches et gagner de l'argent. <br><br>  Pendant son temps libre, Mark développe les Krasnodar Devodar Developer Days, l'une des 19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communautés informatiques</a> dont nous avons invité les militants à Frontend Conf à Moscou. <br><br><h2>  Test <br></h2><br>  Il existe différents types de tests automatisés. <br><img src="https://habrastorage.org/webt/xv/dl/of/xvdlofex2xlqouaertrnrkq804c.png"><br><br>  Lors des <strong>tests unitaires</strong> populaires <strong>,</strong> nous écrivons des tests pour les petites pièces (modules) d'une application.  Ils sont faciles à écrire, mais parfois lors de l'intégration avec d'autres modules, ils peuvent ne pas se comporter exactement comme prévu. <br><br>  Pour éviter cela, nous pouvons écrire <strong>des tests d'intégration</strong> qui testeront ensemble le fonctionnement de nos modules. <br><img src="https://habrastorage.org/webt/ri/6k/gy/ri6kgykpne6mwcobow5wqwhphmq.png"><br><br>  Ils sont un peu plus compliqués, nous allons donc aujourd'hui nous concentrer sur les tests unitaires. <br><br><h2>  Tests unitaires <br></h2><br>  Tout projet qui souhaite au moins une stabilité minimale écrit des tests unitaires. <br><br>  Prenons un exemple. <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ on(callback) { ... } off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = [ ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex) ]; } trigger() { ... } }</code> </pre> <br>  Il existe une classe Signal - il s'agit d'un émetteur d'événements, qui a une méthode on pour s'abonner et une méthode off pour supprimer un abonnement - nous vérifions si le rappel est contenu dans le tableau des abonnés, puis supprimez-le.  Et, bien sûr, il existe une méthode de déclenchement qui appellera les rappels signés. <br><br>  Nous avons un test simple pour cet exemple qui appelle les méthodes on et off, puis le déclencheur, afin de vérifier que le rappel n'a pas été appelé après la désinscription. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'off method should remove listener'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Signal(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasCalled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callback = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { wasCalled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; signal.on(callback); signal.off(callback); signal.trigger(); expect(wasCalled).toBeFalsy(); });</code> </pre><br><h3>  Critères d'évaluation de la qualité <br></h3><br>  Quels sont les critères d'évaluation de la qualité d'un tel test? <br><br>  <strong>La couverture de code</strong> est le critère le plus populaire et le plus connu qui indique le pourcentage de lignes de code exécutées lors du test. <br><img src="https://habrastorage.org/webt/8q/i8/om/8qi8om5vmjpwbthvc31xspmwtcu.png"><br><br>  Vous pouvez avoir une couverture de 70%, 80% ou 90% du code, mais cela signifie-t-il que lorsque vous récupérerez la prochaine version pour la production, tout ira bien ou quelque chose pourrait mal se passer? <br><br>  Revenons à notre exemple. <br><br>  Vendredi soir, vous êtes fatigué, vous terminez la prochaine fonctionnalité.  Et puis vous tombez sur ce code que votre collègue a écrit.  Quelque chose en toi vous semblait compliqué et effrayant. <br><br><pre> <code class="javascript hljs"> ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex)</code> </pre><br>  Vous avez décidé que vous pouvez probablement simplement effacer le tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ ... off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = []; } ... }</code> </pre><br>  Je me suis engagé, monté le projet et envoyé à la production.  Tests réussis - pourquoi pas?  Et il est allé se reposer dans un bar. <br><br><img src="https://habrastorage.org/webt/zv/ds/pb/zvdspbqun8lcjabukmbkna-eivo.png"><br><br>  Mais soudain, tard dans la nuit, un appel a sonné dans le récepteur, que tout tombait, les gens ne pouvaient pas utiliser le produit, et en général, les affaires gaspillaient de l'argent!  Vous brûlez, vous êtes menacé de licenciement. <br><br><img src="https://habrastorage.org/webt/5q/ac/4x/5qac4xp9819iwt9dwwue9rfvan8.png"><br><br>  Comment y faire face?  Que faire des tests?  Comment attraper de telles erreurs stupides primitives?  Qui testera les tests? <br><br>  Bien sûr, vous pouvez embaucher une armée d'ingénieurs QA - laissez-les s'asseoir et applaudissez simplement notre application. <br><br><img src="https://habrastorage.org/webt/5n/7s/rd/5n7srdm7g3tk0iiakgj3oft8zum.png"><br><br>  Ou embauchez l'automatisation de l'assurance qualité.  On peut leur reprocher d'écrire des tests - pourquoi écrire par vous-même s'il y a des personnes spéciales pour cela? <br><br>  Mais en fait, cela coûte cher, alors nous parlerons aujourd'hui d'analyse mutationnelle ou de test mutationnel. <br><br><h2>  Test de mutation <br></h2><br>  C'est un moyen d'automatiser le processus de test de nos tests.  Son but est d'identifier les tests inefficaces et incomplets, c'est-à-dire qu'il s'agit en fait de <strong>tests</strong> . <br><br>  L'idée est de changer des morceaux de code, d'exécuter des tests sur eux, et si les tests ne tombent pas, alors ils sont incomplets. <br><br>  Des modifications sont apportées à l'aide de certaines opérations - <strong>mutateurs</strong> .  Ils remplacent, par exemple, plus par moins, multiplient par division et d'autres opérations similaires.  Les mutateurs peuvent changer des morceaux de code, remplacer des conditions dans while, zéro tableau au lieu d'ajouter un élément au tableau. <br><img src="https://habrastorage.org/webt/mu/xh/nb/muxhnbcmixwyzkp3xwoa5t0zywi.png"><br><br>  À la suite de l'application de mutations au code source, il mute et devient un <strong>mutant</strong> . <br><br>  Les mutants sont divisés en deux catégories: <br><br><ol><li>  <strong>Tué</strong> - ceux dans lesquels nous avons pu identifier les écarts, c'est-à-dire sur lesquels au moins un test est tombé. </li><li>  <strong>Les survivants</strong> sont ceux qui se sont enfuis de nous et ont amené le bogue en production. </li></ol><br>  Pour évaluer la qualité, il existe une métrique <strong>MSI (Mutation Score Indicator)</strong> - le pourcentage de mutants tués et survivants.  Plus la différence entre les tests de couverture de code et MSI est grande, plus le pourcentage de couverture de code reflète la pertinence de nos tests. <br><br>  C'était un peu de théorie, et considérons maintenant comment il peut être utilisé en JavaScript. <br><br><h3>  Solution Javascript <br></h3><br>  Il n'y a qu'un seul outil de test de mutation en développement actif dans JavaScript - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stryker</a> .  Ce nom a été donné à l'instrument en l'honneur du personnage de X-man William Stryker - le créateur de "Weapon X" et un combattant avec tous les mutants. <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  Stryker n'est pas un coureur de test comme Karma ou Jest;  ce n'est pas non plus un cadre de test comme Mocha ou Jasmine.  Il s'agit d'un cadre de test de mutation qui complète votre infrastructure actuelle. <br><br><h3>  Système de plugin <br></h3><br>  Stryker est très flexible, entièrement construit sur un système de plug-in, dont la plupart sont écrits par des développeurs Stryker. <br><img src="https://habrastorage.org/webt/j3/2r/-n/j32r-ns1i8trfuitelgg3y_dpqu.png"><br><br>  Il existe des plugins pour exécuter des tests sur Jest, Karma et Mocha.  Il existe une intégration avec les frameworks Mocha (stryker-mocha-framework) Jasmine (stryker-jasmine) et des ensembles de mutateurs prêts à l'emploi pour JavaScript, TypeScript et même pour Vue: <br><br><ul><li>  stryker-javascript-mutator; </li><li>  stryker-typescript; </li><li>  stryker-vue-mutator. </li></ul><br>  Les mutateurs pour React sont inclus dans le stryker-javascript-mutator.  En plus de cela, vous pouvez toujours écrire vos propres mutateurs. <br><br>  Si vous devez convertir le code avant de l'exécuter, vous pouvez utiliser des plugins pour Webpack, Babel ou TypeScript. <br><img src="https://habrastorage.org/webt/6f/qi/b3/6fqib3tsj-cjmqcnmpiyc45rmc4.png"><br><br>  Tout est mis en place relativement simplement. <br><br><h3>  La configuration <br></h3><br>  La configuration n'est pas difficile: il vous suffit de spécifier dans la configuration JSON quel runner de test (et / ou framework de test et / ou transpiler) vous utilisez, ainsi que d'installer les plugins appropriés depuis npm. <br><br>  L'utilitaire de console simple <strong>stryker-cli</strong> peut faire tout cela pour vous dans un mode question / réponse.  Elle vous demandera ce que vous utilisez et se configurera. <br><br><h3>  Comment ça marche <br></h3><br>  Le cycle de vie est simple et comprend les étapes suivantes: <br><br><ul><li>  Lecture et analyse de la config.  Stryker télécharge la configuration et l'analyse de divers plugins, paramètres, exclusion de fichiers, etc. </li><li>  Téléchargez les plugins en fonction de la configuration. </li><li>  Exécution de tests sur le code source afin de vérifier si les tests sont pertinents en ce moment (du coup ils sont déjà cassés). </li><li>  Si tout va bien, un ensemble de mutants est généré à partir des fichiers que nous avons permis de muter. </li><li>  Exécution de tests sur des mutants. </li></ul><br><img src="https://habrastorage.org/webt/6v/ww/yn/6vwwynfb_hq570upwyur0zrp5fq.png"><br><br>  Ci-dessus est un exemple de démarrage de Stryker: <br><br><ul><li>  Stryker démarre; </li><li>  lit une config; </li><li>  charge les dépendances nécessaires; </li><li>  trouve les fichiers qui muteront; </li><li>  exécute des tests sur le code source; </li><li>  crée 152 mutants; </li><li>  exécute des tests dans 8 threads (dans ce cas, en fonction du nombre de cœurs de processeur). </li></ul><br>  Ce n'est pas un processus rapide, il est donc préférable de le faire sur certains serveurs CI / CD. <br><br>  Après avoir passé tous les tests, Stryker donne un bref rapport sur les fichiers avec le nombre de mutants créés, tués et survivants, ainsi que le pourcentage du rapport des mutants tués aux survivants (MSI) et les mutateurs qui ont été utilisés. <br><br>  Ce sont des problèmes potentiels qui n'étaient pas prévus dans nos tests. <br><br><h3>  Pour résumer <br></h3><br>  <strong>Le test de mutation est utile et intéressant</strong> .  Il peut trouver des problèmes dans les premiers stades du test et sans la participation de personnes.  Cela réduira le temps de validation des demandes d'extraction, par exemple, car les développeurs qualifiés n'auront pas à consacrer de temps à la validation des demandes d'extraction, qui présente déjà des problèmes potentiels.  Ou enregistrez la production si vous décidez de préparer une nouvelle version vendredi soir. <br><br>  Stryker est un outil de test de mutation multithread flexible.  Il se développe activement, mais jusqu'à présent humide, n'a pas encore atteint la version majeure.  Par exemple, lors de la préparation de ce rapport, ses développeurs ont finalement permis dans le plugin Babel de spécifier le fichier de configuration et corrigé l'intégration Jest.  Il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> OpenSource qui peut être aidé à se développer. <br><br><div class="spoiler">  <b class="spoiler_title">FAQ</b> <div class="spoiler_text">  <em>- Comment tester les tests de mutation?</em>  <em>Certes, il y a aussi une erreur.</em>  <em>Dans le premier exemple de test unitaire, la couverture était de 90%.</em>  <em>Il semblerait que tout va bien, mais les caisses ont quand même glissé lorsque tout est tombé et a pris feu.</em>  <em>Par conséquent, pourquoi devrait-on avoir le sentiment que tout va bien après avoir couvert ces tests mutationnels?</em> <br><br>  - Je ne dis pas que le test de mutation est une solution miracle et qu'il guérira tout.  Naturellement, il peut y avoir des cas fous limites ou l'absence d'une sorte de mutateur.  Tout d'abord, les erreurs typiques sont facilement détectées.  Par exemple, vous mettez une vérification sur l'âge, la définissez sur &lt;18 (c'était nécessaire &lt;=), et dans le test, vous oubliez de faire une vérification du cas de la frontière.  Vous avez fait une autre comparaison avec le mutateur, et en conséquence, le test est tombé (ou n'est pas tombé), et vous comprenez que tout est bon ou tout est mauvais.  De telles choses sont rapidement capturées.  C'est un moyen d'ajouter simplement les tests correctement, de trouver les points manquants. <br><br>  <em>- Vous avez souvent une situation de "stupéfait et parti"?</em>  <em>Je pense que ce n'est pas vrai.</em> <br><br>  - Non, mais je pense que dans de nombreux projets, de telles choses existent.  Naturellement, ce n'est pas vrai.  Beaucoup de gens pensent que la couverture du Code permet de tout vérifier, vous pouvez partir en toute sécurité et ne vous inquiétez pas - mais ce n'est pas le cas. <br><br>  <em>- Je dirai tout de suite quel est le problème.</em>  <em>Nous avons beaucoup de toutes sortes de réducteurs et d'autres choses que nous testons mutuellement, et il y en a beaucoup.</em>  <em>Tout cela grandit et il s'avère que pour chaque demande de tirage, un test de mutation est lancé, ce qui prend beaucoup de temps.</em>  <em>Est-il possible de fonctionner uniquement sur ce qui a changé?</em> <br><br>  "Je pense que vous pouvez le configurer vous-même."  Par exemple, du côté du développeur, quand il pousse, valide, vous pouvez créer un plugin à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étapes lint</a> qui n'exécutera que les fichiers qui ont changé.  Sur CI / CD, cela est également possible.  Dans notre cas, le projet est très grand et ancien, et nous pratiquons des tests ponctuels.  On ne vérifie pas tout, car cela prendra une semaine, il y aura des centaines de milliers de mutations.  Je recommanderais de faire des vérifications ponctuelles ou d'organiser moi-même un processus de démarrage sélectif.  Je n'ai pas vu d'outil prêt à l'emploi pour une telle intégration. <br><br>  <em>- L'exhaustivité de toutes les mutations possibles pour un morceau de code particulier est-elle assurée?</em>  <em>Sinon, comment exactement les mutations sont-elles sélectionnées?</em> <br><br>  - Personnellement, je n'ai pas vérifié, mais je n'ai pas rencontré de problème non plus.  Stryker doit générer toutes les mutations possibles sur le même morceau de code. <br><br>  <em>- Je veux poser des questions sur les instantanés.</em>  <em>Mon test unitaire teste à la fois la logique et, y compris la disposition du composant React Snapshot.</em>  <em>Naturellement, si je modifie une conception logique, ma disposition changera là.</em>  <em>C'est un comportement attendu, n'est-ce pas?</em> <br><br>  - Oui, c'est leur sens, que vous mettez à jour manuellement les instantanés. <br><br>  <em>- Donc, vous ignorez en quelque sorte les instantanés dans ce rapport?</em> <br><br>  - Très probablement, les instantanés doivent être mis à jour à l'avance, puis exécuter des tests de mutation, sinon il y aura beaucoup de déchets de Stryker. <br><br>  <em>- Question sur les serveurs CI.</em>  <em>Pour les tests unitaires simples, il existe des rapporteurs, sous GitLab, pour tout ce que vous voulez, qui affichent le pourcentage de tests réussis que vous pouvez configurer, qu'il échoue ou non.</em>  <em>Et Stryker?</em>  <em>Il affiche simplement la tablette dans la console, mais que puis-je faire ensuite?</em> <br><br>  - Ils ont HTML-reporter, vous pouvez créer vos propres journalistes - tout est personnalisable de manière flexible.  Il existe peut-être des outils spécifiques, mais comme nous effectuons toujours des tests de mutation ponctuelle, je n'ai pas trouvé d'intégrations spécifiques avec TeamCity et des outils CI / CD similaires. <br><br>  <em>- Dans quelle mesure les tests de mutation augmentent-ils le support des tests que vous avez en général?</em>  <em>Autrement dit, les tests sont pénibles et les tests doivent être réécrits lorsque le code est réécrit, etc. Parfois, il est plus facile de réécrire le code que les tests.</em>  <em>Et ici, j'ai aussi des tests mutationnels.</em>  <em>Combien coûte-t-il pour une entreprise?</em> <br><br>  - Premièrement, je corrigerai probablement que la réécriture de code pour des raisons de test est incorrecte.  Le code doit être facile à tester.  Quant à ce qui doit être accompli, il est encore important pour l'entreprise que les tests soient aussi complets et efficaces que possible.  S'ils ne sont pas terminés, cela signifie qu'un bogue peut se produire qui entraînera des pertes.  Naturellement, vous ne pouvez tester que les pièces les plus importantes pour l'entreprise. <br><br>  <em>"Pourtant, combien cela coûte plus cher lorsque des tests de mutation apparaissent, que s'ils n'étaient pas là."</em> <br><br>  - C'est autant de mauvais tests maintenant.  Si les tests sont mal écrits maintenant, vous devrez en ajouter beaucoup.  Les tests de mutation trouveront les cas qui ne sont pas couverts par les tests. <br><br>  <em>- Sur la diapositive avec les résultats du contrôle Stryker, il y a beaucoup de vorings, ils sont critiques ou pas critiques.</em>  <em>Comment gérer les faux positifs?</em> <br><br>  - La question subtile est ce qui est considéré comme faux.  J'ai demandé aux gars de notre équipe quelles choses intéressantes leur étaient arrivées.  Il y avait un exemple sur le texte d'erreur.  Stryker a signalé que les tests n'ont pas répondu au changement de texte d'erreur.  Il semble que ce soit un montant, mais mineur. <br><br>  <em>- Vous voyez donc de telles erreurs et sautez celles non critiques en mode manuel?</em> <br><br>  "Nous avons une vérification ponctuelle, alors oui." <br><br>  <em>- J'ai une question pratique.</em>  <em>Lorsque vous avez implémenté cela, quel pourcentage des tests avez-vous échoué?</em> <br><br>  - Nous ne l'avons pas implémenté sur l'ensemble du projet, mais il y a eu des problèmes mineurs sur le nouveau projet.  Par conséquent, je ne peux pas dire les chiffres exacts, mais en général, l'approche a définitivement amélioré la situation. <br></div></div><br><blockquote>  Découvrez d'autres performances frontales tout aussi utiles sur notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne YouTube</a> , tous les rapports thématiques de toutes nos conférences y arrivent progressivement.  Ou abonnez-vous à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">newsletter</a> , et nous vous tiendrons informés de tout nouveau matériel et des nouvelles des futures conférences. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421141/">https://habr.com/ru/post/fr421141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421131/index.html">Vulnérabilité critique des serveurs 1Cloud</a></li>
<li><a href="../fr421133/index.html">LINKa. Clavier en papier. Boutons extra larges</a></li>
<li><a href="../fr421135/index.html">Au / Ni / MgO: transfert de chaleur à l'échelle nanométrique</a></li>
<li><a href="../fr421137/index.html">Fonctionnement de Chrome sans tête</a></li>
<li><a href="../fr421139/index.html">Frontend Conf - prendre soin de l'utilisateur</a></li>
<li><a href="../fr421143/index.html">Aurora Labs S-Titanium Pro Mini Metal 3D Printer</a></li>
<li><a href="../fr421147/index.html">Monstres après les vacances: AMD Threadripper 2990WX 32-Core et 2950X 16-Core</a></li>
<li><a href="../fr421149/index.html">Quelques mots sur les dégradés</a></li>
<li><a href="../fr421153/index.html">CPU 24 cœurs, mais je ne peux pas taper un e-mail (partie 2)</a></li>
<li><a href="../fr421155/index.html">L'impression 3D en 2018: la chose la plus intéressante de l'industrie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>