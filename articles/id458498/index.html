<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✖️ 🙇🏼 👃 Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar. Bagian 2: manajemen negara, perutean 🥠 💑 🙇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian kedua dari terjemahan materi, yang dikhususkan untuk pengembangan aplikasi React skala besar. Di sini kita akan berbi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar. Bagian 2: manajemen negara, perutean</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458498/">  Hari ini kami menerbitkan bagian kedua dari terjemahan materi, yang dikhususkan untuk pengembangan aplikasi React skala besar.  Di sini kita akan berbicara tentang mengelola keadaan aplikasi, perutean, dan pengembangan antarmuka. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/be/rk/zj/berkzjayeeo2ap1yvpeeunb3b6e.png"></a> <br><br>  Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perencanaan, Tindakan, Sumber Data, dan API</a> <br><br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: manajemen negara, perutean</a> <br><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Manajemen status aplikasi, integrasi Redux, routing organisasi</font> </h2><br>  Di sini kita akan berbicara tentang bagaimana Anda dapat memperluas fungsionalitas Redux agar dapat melakukan operasi kompleks dalam aplikasi secara teratur.  Jika mekanisme seperti itu diimplementasikan dengan buruk, mereka dapat melanggar pola yang digunakan dalam merancang repositori. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi generator</a> JavaScript dapat memecahkan banyak masalah yang terkait dengan pemrograman asinkron.  Faktanya adalah bahwa fungsi-fungsi ini dapat dimulai dan dihentikan atas permintaan programmer.  Redux-saga middleware menggunakan konsep ini untuk mengelola aspek aplikasi yang bermasalah.  Secara khusus, kita berbicara tentang memecahkan masalah seperti itu, yang tidak dapat diselesaikan dengan bantuan reduksi, disajikan dalam bentuk fungsi murni. <br><br><h3>  <font color="#3AC1EF">▍Menyelesaikan tugas yang tidak dapat diselesaikan dengan fungsi murni</font> </h3><br>  Pertimbangkan skenario berikut.  Anda ditawari mengerjakan aplikasi yang dirancang untuk perusahaan yang bekerja di pasar real estat.  Klien ingin mendapatkan situs web baru yang lebih baik.  Yang Anda inginkan ada API REST, Anda memiliki tata letak semua halaman yang disiapkan menggunakan Zapier, Anda telah menguraikan rencana aplikasi.  Tapi kemudian masalah besar muncul. <br><br>  Perusahaan klien telah lama menggunakan sistem manajemen konten (CMS) tertentu.  Karyawan perusahaan sangat menyadari sistem ini, sehingga pelanggan tidak ingin beralih ke CMS baru hanya untuk membuatnya lebih mudah untuk menulis posting baru di blog perusahaan.  Selain itu, Anda juga perlu menyalin publikasi yang ada dari blog ke situs baru, dan ini juga dapat menyebabkan masalah. <br><br>  Yang menyenangkan adalah bahwa CMS yang digunakan oleh klien memiliki API yang nyaman di mana Anda dapat mengakses publikasi dari blog.  Tetapi, jika Anda membuat agen untuk bekerja dengan API ini, situasinya diperumit oleh fakta bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ia</a> terletak di server tertentu, di mana data disajikan sama sekali tidak seperti yang Anda butuhkan. <br><br>  Ini adalah contoh masalah, sesuatu yang dapat mencemari kode aplikasi, karena di sini Anda harus memasukkan dalam mekanisme proyek untuk bekerja dengan API baru yang digunakan untuk mengunduh posting blog.  Anda dapat menangani situasi ini dengan redux-saga. <br>  Lihatlah diagram berikut.  Inilah cara aplikasi dan API kami berinteraksi.  Kami mengunduh publikasi di latar belakang menggunakan redux-saga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/2b9/fdf/56e2b9fdfc5ea809c842a39cfed53bfe.jpg"></div><br>  <i><font color="#999999">Diagram Aplikasi Menggunakan Redux dan Penyimpanan redux-saga</font></i> <br><br>  Di sini, komponen mengirimkan tindakan <code>GET.BLOGS</code> .  Aplikasi ini menggunakan redux-saga, jadi permintaan ini akan dicegat.  Setelah itu, fungsi generator akan mengunduh data dari penyimpanan data di latar belakang dan memperbarui status aplikasi yang didukung oleh Redux. <br><br>  Berikut adalah contoh bagaimana fungsi generator untuk memuat publikasi (fungsi tersebut disebut “sagas”) mungkin terlihat dalam situasi yang dijelaskan.  Sagas dapat digunakan dalam skenario lain.  Misalnya, untuk mengatur penyimpanan data pengguna (katakanlah, itu bisa menjadi token), karena ini adalah contoh lain dari tugas yang fungsi murninya tidak cocok. <br><br><pre> <code class="javascript hljs">... function* fetchPosts(action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === WP_POSTS.LIST.REQUESTED) {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(wpGet, {       <span class="hljs-attr"><span class="hljs-attr">model</span></span>: WP_POSTS.MODEL,       <span class="hljs-attr"><span class="hljs-attr">contentType</span></span>: APPLICATION_JSON,       <span class="hljs-attr"><span class="hljs-attr">query</span></span>: action.payload.query,     });     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) {       <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({         <span class="hljs-attr"><span class="hljs-attr">type</span></span>: WP_POSTS.LIST.FAILED,         <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: response.error.response.data.msg,       });       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;         <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({       <span class="hljs-attr"><span class="hljs-attr">type</span></span>: WP_POSTS.LIST.SUCCESS,       <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: {         <span class="hljs-attr"><span class="hljs-attr">posts</span></span>: response.data,         <span class="hljs-attr"><span class="hljs-attr">total</span></span>: response.headers[<span class="hljs-string"><span class="hljs-string">'x-wp-total'</span></span>],         <span class="hljs-attr"><span class="hljs-attr">query</span></span>: action.payload.query,       },       <span class="hljs-attr"><span class="hljs-attr">view</span></span>: action.view,     });   } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {     <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: WP_POSTS.LIST.FAILED, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: e.message });  ...</code> </pre> <br>  Kisah yang disajikan di sini mengharapkan tindakan seperti <code>WP_POSTS.LIST.REQUESTED</code> .  Dengan menerima tindakan seperti itu, ia memuat data dari API.  Dia, setelah menerima data, mengirimkan tindakan lain - <code>WP_POSTS.LIST.SUCCESS</code> .  Pemrosesannya mengarah ke memperbarui repositori menggunakan peredam yang sesuai. <br><br><h3>  <font color="#3AC1EF">▍ Pengenalan reduksi</font> </h3><br>  Saat mengembangkan aplikasi besar, tidak mungkin merencanakan terlebih dahulu perangkat dari semua model yang diperlukan.  Selain itu, seiring dengan meningkatnya ukuran aplikasi, penggunaan teknologi memperkenalkan reduksi membantu menghemat sejumlah besar jam kerja.  Teknik ini memungkinkan pengembang untuk menambahkan reducers baru ke sistem tanpa menulis ulang seluruh repositori. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> yang dirancang untuk membuat repositori Redux yang dinamis.  Namun, saya lebih suka mekanisme memperkenalkan reduksi, karena memberikan pengembang tingkat fleksibilitas tertentu.  Misalnya, aplikasi yang sudah ada dapat dilengkapi dengan mekanisme ini tanpa perlu serius mengatur ulang aplikasi tersebut. <br><br>  Pengenalan reduksi adalah bentuk pemisahan kode.  Komunitas pengembang Bereaksi dengan antusias merangkul teknologi ini.  Saya akan menggunakan potongan kode ini untuk menunjukkan tampilan dan fitur mekanisme implementasi reduksi. <br><br>  Pertama, mari kita lihat integrasinya dengan Redux: <br><br><pre> <code class="javascript hljs">... const withConnect = connect( mapStateToProps, mapDispatchToProps, ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withReducer = injectReducer({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: BLOG_VIEW, <span class="hljs-attr"><span class="hljs-attr">reducer</span></span>: blogReducer, }); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlogPage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{  ... } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> compose( withReducer, withConnect, )(BlogPage);</code> </pre> <br>  Kode ini adalah bagian dari file <code>BlogPage.js</code> yang berisi komponen aplikasi. <br><br>  Di sini kita, dalam perintah ekspor, tidak menggunakan fungsi <code>connect</code> , tetapi fungsi <code>compose</code> .  Ini adalah salah satu fungsi dari pustaka Redux yang memungkinkan Anda membuat beberapa fungsi.  Daftar fungsi yang dilewati untuk <code>compose</code> harus dibaca dari kanan ke kiri atau dari bawah ke atas. <br><br>  Anda dapat belajar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Redux bahwa fungsi <code>compose</code> memungkinkan Anda untuk membuat transformasi fungsi yang sangat bersarang.  Dalam hal ini, programmer dibebaskan dari kebutuhan untuk menggunakan struktur yang sangat panjang.  Konstruksi ini terlihat seperti baris kode yang mewakili panggilan ke beberapa fungsi dengan memberikannya hasil panggilan ke fungsi lain sebagai argumen.  Dokumentasi mencatat bahwa fungsi <code>compose</code> harus digunakan dengan hati-hati. <br><br>  Fungsi paling kanan dalam suatu komposisi dapat mengambil banyak argumen, tetapi hanya satu argumen yang dapat diteruskan ke fungsi yang mengikutinya.  Sebagai hasilnya, dengan memanggil fungsi yang dihasilkan dari menggunakan <code>compose</code> , kita meneruskannya apa yang diperlukan dari fungsi aslinya, yang berada di sebelah kanan semua yang lain.  Itulah sebabnya kami meneruskan fungsi tulis ke fungsi <code>withConnect</code> sebagai parameter terakhir.  Hasilnya, fungsi <code>compose</code> dapat digunakan seperti fungsi <code>connect</code> . <br><br><h3>  <font color="#3AC1EF">▍ Routing dan Redux</font> </h3><br>  Ada sejumlah alat yang digunakan untuk memecahkan masalah perutean dalam aplikasi.  Pada bagian ini, bagaimanapun, kita akan fokus pada perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">react-router-dom</a> .  Kami akan memperluas kemampuannya sehingga dapat bekerja dengan Redux. <br><br>  Paling sering, router Bereaksi digunakan seperti ini: komponen root terlampir dalam tag <code>BrowserRouter</code> , dan wadah anak dibungkus dengan metode <code>withRouter()</code> dan diekspor ( <a href="">berikut adalah</a> contoh). <br><br>  Dengan pendekatan ini, komponen anak menerima, melalui mekanisme <code>props</code> , objek <code>history</code> berisi beberapa properti khusus untuk sesi pengguna saat ini.  Ada beberapa metode dalam objek ini yang dapat digunakan untuk mengontrol navigasi. <br><br>  Opsi perutean ini dapat menyebabkan masalah pada aplikasi besar.  Ini disebabkan oleh fakta bahwa mereka tidak memiliki objek <code>history</code> tersentralisasi.  Selain itu, komponen yang tidak dirender dengan <code>&lt;Route&gt;</code> tidak dapat berfungsi dengan objek <code>history</code> .  Berikut ini contoh menggunakan <code>&lt;Route&gt;</code> : <br><br><pre> <code class="javascript hljs">&lt;Route path=<span class="hljs-string"><span class="hljs-string">"/"</span></span> exact component={HomePage} /&gt;</code> </pre> <br>  Untuk mengatasi masalah ini, kita akan menggunakan pustaka yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terhubung-bereaksi-router</a> , yang akan memungkinkan kita untuk membuat rute menggunakan metode <code>dispatch</code> .  Integrasi perpustakaan ini ke dalam proyek akan memerlukan beberapa modifikasi.  Secara khusus, akan diperlukan untuk membuat peredam baru yang dirancang khusus untuk rute (ini cukup jelas), dan juga untuk menambahkan beberapa mekanisme tambahan ke sistem. <br><br>  Setelah konfigurasi selesai, sistem perutean baru dapat digunakan melalui Redux.  Jadi, navigasi dalam aplikasi dapat diimplementasikan dengan mengirimkan tindakan. <br><br>  Untuk mengambil keuntungan dari kapabilitas pustaka yang terhubung-bereaksi-router dalam komponen, kami cukup memetakan metode <code>dispatch</code> ke repositori, melakukan ini sesuai dengan kebutuhan aplikasi.  Berikut adalah contoh kode yang menunjukkan penggunaan pustaka router reaksi-terkoneksi (agar kode ini dapat berfungsi, Anda perlu seluruh sistem untuk dikonfigurasikan untuk menggunakan router reaksi-terkoneksi). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { push } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'connected-react-router'</span></span> ... const mapDispatchToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch</span></span></span><span class="hljs-function"> =&gt;</span></span> ({  <span class="hljs-attr"><span class="hljs-attr">goTo</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> {    dispatch(push(payload.path));  }, }); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DemoComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{  render() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      &lt;Child        onClick={          (</span></span></span><span class="hljs-function">) =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.goTo({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">`/gallery/`</span></span>});                      <span class="hljs-regexp"><span class="hljs-regexp">/&gt;    } ...</span></span></code> </pre> <br>  Di sini metode <code>goTo</code> mengirim tindakan yang mendorong URL yang diperlukan <code>goTo</code> tumpukan riwayat browser.  Sebelumnya, metode <code>goTo</code> telah <code>goTo</code> ke repositori.  Oleh karena itu, metode ini diteruskan ke <code>DemoComponent</code> di objek <code>props</code> . <br><br><h2>  <font color="#3AC1EF">Antarmuka pengguna yang dinamis dan kebutuhan aplikasi yang berkembang</font> </h2><br>  Seiring waktu, terlepas dari adanya backend yang memadai untuk aplikasi dan bagian klien yang berkualitas tinggi, beberapa elemen antarmuka pengguna mulai mempengaruhi kerja pengguna dengan buruk.  Hal ini disebabkan oleh implementasi komponen yang tidak rasional, yang, pada pandangan pertama, tampak sangat sederhana.  Di bagian ini, kami akan membahas rekomendasi untuk membuat beberapa widget.  Implementasinya yang benar, seiring pertumbuhan aplikasi, menjadi lebih rumit. <br><br><h3>  <font color="#3AC1EF">Loading Pemuatan Malas dan React. Suspense</font> </h3><br>  Bagian terbaik tentang sifat asinkron dari JavaScript adalah memanfaatkan potensi penuh peramban.  Mungkin kebaikan sebenarnya adalah bahwa untuk memulai proses tertentu Anda tidak perlu menunggu penyelesaian tugas sebelumnya.  Namun, pengembang tidak dapat mempengaruhi jaringan dan kecepatan berbagai bahan yang diperlukan untuk berfungsinya situs. <br><br>  Subsistem jaringan biasanya dianggap tidak dapat diandalkan dan rentan kesalahan. <br><br>  Pengembang, dalam upaya membuat aplikasinya setinggi mungkin, dapat dikenakan banyak pemeriksaan dan mencapai keberhasilannya.  Tetapi masih ada beberapa hal, seperti status koneksi jaringan atau waktu respons server, yang tidak dapat dipengaruhi pengembang. <br><br>  Tetapi pencipta perangkat lunak tidak berusaha membenarkan kerja aplikasi yang berkualitas rendah dengan frasa seperti "ini bukan urusan saya."  Mereka menemukan cara menarik untuk menangani masalah jaringan. <br><br>  Di beberapa bagian aplikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">front-end, Anda</a> mungkin perlu menunjukkan beberapa bahan cadangan (seperti memuat lebih cepat dari bahan asli).  Ini akan menyelamatkan pengguna dari merenungkan "berkedut" dari halaman memuat atau, lebih buruk lagi, tentang ikon tersebut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/123/d6a/f47123d6ab6e8e85a0d445742e33031c.png"></div><br>  <i><font color="#999999">Pengguna lebih baik tidak melihat hal seperti ini.</font></i> <br><br>  Teknologi React Suspense memungkinkan Anda untuk mengatasi masalah seperti itu.  Misalnya, ini memungkinkan Anda untuk menampilkan indikator tertentu selama pemuatan data.  Meskipun ini juga bisa dilakukan secara manual dengan mengatur properti <code>isLoaded</code> menjadi <code>true</code> , menggunakan Suspense API membuat kode lebih bersih. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menonton video yang bagus tentang Suspense, di mana Jared Palmer memperkenalkan pemirsa ke teknologi ini dan menunjukkan beberapa fitur-fiturnya menggunakan contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi nyata</a> . <br><br>  Begini cara aplikasi bekerja tanpa menggunakan Suspense. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d49/7bc/734/d497bc7344af043e19445fa8299a35d0.gif"></div><br>  <i><font color="#999999">Aplikasi tempat Suspense tidak digunakan</font></i> <br><br>  Melengkapi komponen dengan dukungan Suspense jauh lebih mudah daripada menggunakan seluruh aplikasi <code>isLoaded</code> .  Mari kita mulai dengan meletakkan wadah <code>App</code> induk di <code>React.StrictMode</code> .  Kami memastikan bahwa di antara modul Bereaksi yang digunakan dalam aplikasi, tidak akan ada yang dianggap usang. <br><br><pre> <code class="javascript hljs">&lt;React.Suspense fallback={&lt;Spinner size=<span class="hljs-string"><span class="hljs-string">"large"</span></span> /&gt;}&gt;  &lt;ArtistDetails id={this.props.id}/&gt;  &lt;ArtistTopTracks /&gt;  &lt;ArtistAlbums id={this.props.id}/&gt; &lt;/React.Suspense&gt;</code> </pre> <br>  Komponen yang dibungkus dengan tag <code>React.Suspense</code> , selama pemuatan konten utama, muat dan tampilkan apa yang ditentukan dalam properti <code>fallback</code> .  Kita harus berusaha untuk memastikan bahwa komponen yang digunakan dalam properti <code>fallback</code> memiliki volume sekecil mungkin dan disusun sesederhana mungkin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/d1c/54e/9b9d1c54ea0a5d7c26ea7e0a7bbdebee.gif"></div><br>  <i><font color="#999999">Aplikasi yang menggunakan Suspense</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Komponen adaptif</font> </h3><br>  Dalam aplikasi front-end yang besar, manifestasi dari pola berulang adalah umum.  Pada saat yang sama, di awal pekerjaan, ini bisa hampir sama sekali tidak terlihat.  Tidak ada yang bisa dilakukan tentang itu, tetapi Anda harus menemukan ini. <br><br>  Misalnya, ada dua model dalam aplikasi.  Salah satunya dimaksudkan untuk deskripsi trek balap, dan yang kedua - untuk deskripsi mobil.  Halaman daftar mobil menggunakan elemen persegi.  Masing-masing berisi gambar dan deskripsi singkat. <br><br>  Daftar jejak menggunakan elemen serupa.  Fitur utama mereka adalah bahwa, selain gambar dan deskripsi trek, mereka juga memiliki bidang kecil yang menunjukkan apakah mungkin bagi para penonton lomba yang berlangsung di trek ini untuk membeli sesuatu untuk dimakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c9/8b3/8ab/6c98b38ab2cf0c2670751908581d26d0.png"></div><br>  <i><font color="#999999">Elemen untuk deskripsi mobil dan elemen untuk deskripsi trek</font></i> <br><br>  Kedua komponen ini sedikit berbeda satu sama lain dalam hal gaya (mereka memiliki warna latar belakang yang berbeda).  Komponen yang menggambarkan rute berisi beberapa informasi tambahan tentang objek dunia nyata yang dijelaskannya, sedangkan komponen yang melambangkan mobil tidak memiliki informasi tersebut.  Contoh ini hanya menunjukkan dua model.  Dalam aplikasi besar, banyak model serupa dapat diketik, hanya berbeda dalam hal-hal kecil. <br><br>  Penciptaan komponen independen yang terpisah untuk masing-masing entitas ini bertentangan dengan akal sehat. <br><br>  Seorang programmer dapat menyelamatkan dirinya dari kebutuhan untuk menulis fragmen kode yang hampir sepenuhnya saling mengulang.  Ini dapat dilakukan melalui pengembangan komponen adaptif.  Mereka, dalam pekerjaan, memperhitungkan lingkungan di mana mereka dimuat.  Pertimbangkan bilah pencarian aplikasi tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/334/4e5/a273344e57f1ea8aa88269f8dad8e7dd.png"></div><br>  <i><font color="#999999">Bilah pencarian</font></i> <br><br>  Ini akan digunakan pada banyak halaman.  Pada saat yang sama, perubahan kecil akan dilakukan pada penampilan dan urutan kerjanya pada halaman yang berbeda.  Misalnya, pada halaman muka proyek, itu akan menjadi sedikit lebih besar dari pada halaman lain.  Untuk mengatasi masalah ini, Anda dapat membuat satu komponen tunggal yang akan ditampilkan sesuai dengan properti yang ditransfer ke sana. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> propTypes = {  <span class="hljs-attr"><span class="hljs-attr">open</span></span>: PropTypes.bool.isRequired,  <span class="hljs-attr"><span class="hljs-attr">setOpen</span></span>: PropTypes.func.isRequired,  <span class="hljs-attr"><span class="hljs-attr">goTo</span></span>: PropTypes.func.isRequired, };</code> </pre> <br>  Dengan menggunakan teknik ini, Anda dapat mengontrol penggunaan kelas HTML saat merender elemen tersebut, yang memungkinkan Anda untuk memengaruhi penampilan mereka. <br><br>  Situasi menarik lainnya di mana komponen adaptif dapat menemukan aplikasi adalah mekanisme untuk memecah material tertentu menjadi beberapa halaman.  Bilah navigasi dapat ada di setiap halaman aplikasi.  Contoh panel ini di setiap halaman akan hampir persis sama dengan di halaman lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/7ee/d8d/c867eed8d85f120940a321d95fc274f2.png"></div><br>  <i><font color="#999999">Panel pagination</font></i> <br><br>  Misalkan aplikasi tertentu membutuhkan panel yang serupa.  Saat mengerjakan aplikasi ini, pengembang mematuhi persyaratan yang diartikulasikan tepat waktu.  Dalam situasi seperti itu, komponen adaptif yang digunakan untuk memecah materi menjadi halaman hanya perlu melewati beberapa properti.  Ini adalah <code>URL</code> dan jumlah elemen per halaman. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Ekosistem Bereaksi telah menjadi sangat dewasa hari ini sehingga tidak mungkin ada orang yang perlu “menciptakan sepeda” pada setiap tahap pengembangan aplikasi.  Meskipun ini berperan di tangan pengembang, itu mengarah pada fakta bahwa menjadi sulit untuk memilih apa yang bekerja dengan baik untuk setiap proyek tertentu. <br><br>  Setiap proyek memiliki keunikan dalam hal cakupan dan fungsinya.  Tidak ada pendekatan tunggal atau aturan universal dalam mengembangkan aplikasi Bereaksi.  Karena itu, sebelum memulai pengembangan, penting untuk merencanakannya dengan benar. <br><br>  Saat merencanakan, sangat mudah untuk memahami alat mana yang secara langsung dibuat untuk proyek dan mana yang jelas tidak cocok untuknya, karena terlalu besar untuknya.  Misalnya, aplikasi yang terdiri dari 2-3 halaman dan melakukan sangat sedikit permintaan ke API tertentu tidak memerlukan penyimpanan data yang serupa dengan yang kita bicarakan.  Saya siap melangkah lebih jauh dalam pertimbangan ini, dan mengatakan bahwa dalam proyek kecil Anda tidak perlu menggunakan Redux. <br>  Pada tahap perencanaan aplikasi, saat menggambar tata letak halaman-halamannya, mudah untuk melihat bahwa banyak komponen serupa digunakan pada halaman-halaman ini.  Jika Anda mencoba menggunakan kembali kode komponen tersebut atau berupaya menulis komponen universal, ini akan membantu menghemat banyak waktu dan upaya. <br><br>  Dan akhirnya, saya ingin mencatat bahwa data adalah inti dari aplikasi apa pun.  Dan Bereaksi aplikasi tidak terkecuali.  Ketika skala aplikasi bertambah, volume data yang diproses bertambah, muncul mekanisme perangkat lunak tambahan untuk bekerja dengannya.  Sesuatu seperti ini, jika aplikasi itu dirancang dengan buruk, dapat dengan mudah "menghancurkan" programmer, mengisinya dengan tugas-tugas yang rumit dan membingungkan.  Jika, dalam proses perencanaan, masalah penggunaan gudang data diputuskan di muka, jika urutan tindakan, reduksi, sag dipikirkan sebelumnya, maka mengerjakan aplikasi akan jauh lebih mudah. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda tahu ada perpustakaan atau metodologi pengembangan yang berkinerja baik saat membuat aplikasi Bereaksi skala besar, silakan bagikan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/b4/fn/f5/b4fnf52x9i3mn80tttdafqtvkfe.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458498/">https://habr.com/ru/post/id458498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458488/index.html">Intisari Ilmu Data (Juli 2019)</a></li>
<li><a href="../id458490/index.html">Pegang erat-erat ke roda kemudi ... Proyek kami untuk memantau kondisi pengemudi</a></li>
<li><a href="../id458492/index.html">“Kami selalu percaya pada kompetisi dan hak untuk memilih pengguna” © Yandex</a></li>
<li><a href="../id458494/index.html">Contoh praktis menggunakan fungsi render Vue: membuat kisi tipografi untuk sistem desain</a></li>
<li><a href="../id458496/index.html">Pedoman praktis untuk mengembangkan aplikasi Bereaksi skala besar. Perencanaan, Tindakan, Sumber Data, dan API</a></li>
<li><a href="../id458500/index.html">Metamorfosis dari pengujian redux-saga</a></li>
<li><a href="../id458502/index.html">Rahasia utama untuk mengembangkan aplikasi Elektron yang baik</a></li>
<li><a href="../id458504/index.html">Trik 13 npm untuk menghemat waktu</a></li>
<li><a href="../id458506/index.html">Bukan Portal 3, tapi tutup: teleportasi kuantum informasi di dalam berlian</a></li>
<li><a href="../id458508/index.html">Pandangan dari dalam: sekolah pascasarjana di EPFL. Bagian 4.2: sisi keuangan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>