<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèä ‚ÜîÔ∏è üöú AI, cours pratique. Apprentissage en profondeur pour g√©n√©rer de la musique üêô üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ‚≠êÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est le dernier article d'une s√©rie d'articles de formation pour les d√©veloppeurs dans le domaine de l'intelligence artificielle. Il d√©crit les √©t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI, cours pratique. Apprentissage en profondeur pour g√©n√©rer de la musique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/423727/"><img src="https://habrastorage.org/webt/zy/do/u4/zydou4yx-zh_x9qzbumtrbdhwy4.jpeg"><br><br>  Ceci est le dernier article d'une s√©rie d'articles de formation pour les d√©veloppeurs dans le domaine de l'intelligence artificielle.  Il d√©crit les √©tapes pour cr√©er un mod√®le d'apprentissage en profondeur pour la g√©n√©ration de musique, en choisissant le bon mod√®le et le pr√©traitement des donn√©es, et d√©crit les proc√©dures de configuration, de formation, de test et de modification de BachBot. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">G√©n√©ration de musique - R√©flexion sur une t√¢che</font> </h2><br>  La premi√®re √©tape pour r√©soudre de nombreux probl√®mes √† l'aide de l'intelligence artificielle (IA) consiste √† r√©duire le probl√®me √† un probl√®me de base qui peut √™tre r√©solu au moyen de l'IA.  Un de ces probl√®mes est la pr√©diction de s√©quence, qui est utilis√©e dans les applications de traduction et de traitement en langage naturel.  Notre t√¢che de g√©n√©rer de la musique peut √™tre r√©duite au probl√®me de pr√©dire une s√©quence, et la pr√©diction sera effectu√©e pour une s√©quence de notes de musique. <br><br><h2>  <font color="#0071c5">S√©lection du mod√®le</font> </h2><br>  Il existe plusieurs types de r√©seaux de neurones diff√©rents qui peuvent √™tre consid√©r√©s comme des mod√®les: les r√©seaux de neurones √† distribution directe, les r√©seaux de neurones r√©currents et les r√©seaux de neurones √† m√©moire √† long terme. <br><br>  Les neurones sont les √©l√©ments abstraits de base qui se combinent pour former des r√©seaux de neurones.  Essentiellement, un neurone est une fonction qui re√ßoit des donn√©es en entr√©e et g√©n√®re le r√©sultat. <br><br><img src="https://habrastorage.org/webt/56/pq/hs/56pqhseblx5mqec0apoegck7vd4.png"><br>  <i>Neuron</i> <br><br>  Des couches de neurones qui re√ßoivent les m√™mes donn√©es √† l'entr√©e et ont des sorties connect√©es peuvent √™tre combin√©es pour construire un <i>r√©seau neuronal √† propagation directe</i> .  Ces r√©seaux de neurones pr√©sentent des r√©sultats √©lev√©s en raison de la composition des fonctions d'activation non lin√©aires lors du passage de donn√©es √† travers plusieurs couches (ce que l'on appelle le deep learning). <br><br><img src="https://habrastorage.org/webt/e8/ps/1v/e8ps1vchys7uap5mjucmyip5ob8.png"><br>  <i>R√©seau de neurones √† distribution directe</i> <br><br>  Un r√©seau de neurones √† distribution directe donne de bons r√©sultats dans une large gamme d'applications.  Cependant, un tel r√©seau neuronal pr√©sente un inconv√©nient qui ne permet pas de l'utiliser dans une t√¢che li√©e √† la composition musicale (pr√©diction de s√©quence): il a une dimension fixe de donn√©es d'entr√©e, et les compositions musicales peuvent avoir des longueurs diff√©rentes.  De plus, <i>les r√©seaux de neurones √† distribution directe ne prennent pas en compte les entr√©es des pas de temps pr√©c√©dents, ce qui les rend peu utiles pour r√©soudre le probl√®me de pr√©diction de s√©quence!</i>  Un mod√®le appel√© <i>r√©seau neuronal r√©current est</i> mieux adapt√© √† cette t√¢che. <br><br>  Les r√©seaux de neurones r√©cursifs r√©solvent ces deux probl√®mes en introduisant des liens entre les n≈ìuds cach√©s: dans ce cas, au pas de temps suivant, les n≈ìuds peuvent recevoir des informations sur les donn√©es au pas de temps pr√©c√©dent. <br><br><img src="https://habrastorage.org/webt/xc/jv/dr/xcjvdrzlx66olpyziwbtfywxukq.png"><br>  <i>Repr√©sentation d√©taill√©e d'un r√©seau neuronal r√©current</i> <br><br>  Comme vous pouvez le voir sur la figure, chaque neurone re√ßoit maintenant une entr√©e de la couche neuronale pr√©c√©dente et de l'heure pr√©c√©dente. <br><br>  Les r√©seaux de neurones r√©cursifs traitant de grandes s√©quences d'entr√©e rencontrent ce que l'on appelle le <i>probl√®me du gradient de fuite</i> : cela signifie que l'influence des pas de temps ant√©rieurs dispara√Æt rapidement.  Ce probl√®me est caract√©ristique de la t√¢che de la composition musicale, car il existe d'importantes d√©pendances √† long terme dans les ≈ìuvres musicales qui doivent √™tre prises en compte. <br><br>  Pour r√©soudre le probl√®me d'un gradient de fuite, une modification du r√©seau r√©current, appel√© <i>r√©seau de neurones √† m√©moire √† court terme (ou r√©seau de neurones LSTM), peut √™tre utilis√©e</i> .  Ce probl√®me est r√©solu en introduisant des cellules de m√©moire, qui sont soigneusement surveill√©es par trois types de ¬´portes¬ª.  Cliquez sur le lien suivant pour plus d'informations: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations g√©n√©rales sur les r√©seaux de neurones LSTM</a> . <br><br>  Ainsi, BachBot utilise un mod√®le bas√© sur le r√©seau neuronal LSTM. <br><br><h2>  <font color="#0071c5">Pr√©traitement</font> </h2><br>  La musique est une forme d'art tr√®s complexe et comprend diverses dimensions: hauteur, rythme, tempo, nuances dynamiques, articulation et plus encore.  Pour simplifier la musique aux fins de ce projet <i>, seules la hauteur et la dur√©e des sons sont prises en compte</i> .  De plus, tous les choraux ont √©t√© <i>transpos√©s</i> sur la tonalit√© en do majeur ou en la mineur, et les dur√©es des notes ont √©t√© <i>quantifi√©es dans le temps</i> (arrondies) au multiple le plus proche de la seizi√®me note.  Ces mesures ont √©t√© prises pour r√©duire la complexit√© des compositions et augmenter les performances du r√©seau, tandis que le contenu de base de la musique est rest√© inchang√©.  Les op√©rations de normalisation des tonalit√©s et des dur√©es des notes ont √©t√© effectu√©es √† l'aide de la biblioth√®que music21. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standardize_key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(score)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Converts into the key of C major or A minor. Adapted from https://gist.github.com/aldous-rey/68c6c43450517aa47474 """</span></span> <span class="hljs-comment"><span class="hljs-comment"># conversion tables: eg Ab -&gt; C is up 4 semitones, D -&gt; A is down 5 semitones majors = dict([("A-", 4),("A", 3),("B-", 2),("B", 1),("C", 0),("C#",-1), ("D-", -1),("D", -2),("E-", -3),("E", -4),("F", -5),("F#",6), ("G-", 6), ("G", 5)]) minors = dict([("A-", 1),("A", 0),("B-", -1),("B", -2),("C", -3),("C#",-4), ("D-", -4),("D", -5),("E-", 6),("E", 5),("F", 4),("F#",3), ("G-",3),("G", 2)]) # transpose score key = score.analyze('key') if key.mode == "major": halfSteps = majors[key.tonic.name] elif key.mode == "minor": halfSteps = minors[key.tonic.name] tScore = score.transpose(halfSteps) # transpose key signature for ks in tScore.flat.getKeySignatures(): ks.transpose(halfSteps, inPlace=True) return tScore</span></span></code> </pre> <br>  <i>Le code utilis√© pour normaliser les caract√®res cl√©s dans les ≈ìuvres collect√©es, les cl√©s en do majeur ou la mineur sont utilis√©es dans la sortie</i> <br><br>  La quantification temporelle au multiple le plus proche de la seizi√®me note a √©t√© effectu√©e √† l'aide de la fonction <i>Stream.quantize ()</i> de la biblioth√®que <i>music21</i> .  Voici une comparaison des statistiques associ√©es √† un ensemble de donn√©es avant et apr√®s son traitement pr√©liminaire: <br><br><img src="https://habrastorage.org/webt/kr/wh/5n/krwh5n0d1dubkwn0urbjmp7ovzs.png"><br>  <i>Utiliser chaque classe de notes avant (√† gauche) et apr√®s le pr√©traitement (√† droite).</i>  <i>Une classe de notes est une note quelle que soit son octave.</i> <br><br><img src="https://habrastorage.org/webt/mz/rq/i0/mzrqi0fynco56dhr9kdk-nsfjrs.png"><br>  <i>Emplacement des notes avant (√† gauche) et apr√®s le pr√©traitement (√† droite)</i> <br><br>  Comme le montre la figure ci-dessus, la transposition de la tonalit√© originale des chorals √† la tonalit√© de do majeur ou de do mineur (la mineur) a consid√©rablement influenc√© la classe des notes utilis√©es dans les ≈ìuvres collect√©es.  En particulier, le nombre d'occurrences de notes dans les cl√©s dans les cl√©s majeures (do majeur) et la mineur (la mineur) (do, mi, mi, fa, sol, a, b) a augment√©.  Vous pouvez √©galement observer de petits pics pour les notes F # et G # en raison de leur pr√©sence dans la s√©quence ascendante de la m√©lodique A mineur (A, B, C, D, E, F # et G #).  <i>En revanche, la quantification du temps a eu un effet beaucoup plus faible.</i>  Cela peut s'expliquer par la haute r√©solution de quantification (similaire √† l'arrondi √† de nombreux chiffres significatifs). <br><br><h2>  <font color="#0071c5">Codage</font> </h2><br>  Une fois les donn√©es pr√©trait√©es, il est n√©cessaire de coder les chorales dans un format qui peut √™tre facilement trait√© √† l'aide d'un r√©seau de neurones r√©current.  Le format requis est une <i>s√©quence de jetons</i> .  Pour le projet BachBot, le codage a √©t√© choisi au niveau des notes (chaque token repr√©sente une note) au lieu du niveau des accords (chaque token repr√©sente un accord).  Cette solution a r√©duit la taille du dictionnaire de 128 <sup>4</sup> accords possibles √† 128 notes possibles, ce qui a permis d'augmenter l'efficacit√© du travail. <br><br>  Un sch√©ma de codage original pour les compositions musicales a √©t√© cr√©√© pour le projet BachBot.  Le choral est divis√© en pas de temps correspondant aux doubles croches.  Ces √©tapes sont appel√©es cadres.  Chaque image contient une s√©quence de tuples repr√©sentant la valeur de la hauteur d'une note au format d'une interface d'instrument de musique num√©rique (MIDI) et un signe de liaison de cette note √† une note pr√©c√©dente de la m√™me hauteur (note, signe de reliure).  Les notes dans le cadre sont num√©rot√©es par ordre d√©croissant de hauteur (soprano ‚Üí alt ‚Üí t√©nor ‚Üí basse).  Chaque trame peut √©galement avoir une trame qui marque la fin d'une phrase;  Fermata est repr√©sent√© par un point (.) Au-dessus de la note.  Les symboles <i>START</i> et <i>END</i> sont ajout√©s au d√©but et √† la fin de chaque choral.  Ces symboles provoquent l'initialisation du mod√®le et permettent √† l'utilisateur de d√©terminer quand la composition se termine. <br><br> <code>START <br> (59, True) <br> (56, True) <br> (52, True) <br> (47, True) <br> ||| <br> (59, True) <br> (56, True) <br> (52, True) <br> (47, True) <br> ||| <br> (.) <br> (57, False) <br> (52, False) <br> (48, False) <br> (45, False) <br> ||| <br> (.) <br> (57, True) <br> (52, True) <br> (48, True) <br> (45, True) <br> ||| <br> END</code> <br>  <i>Un exemple d'encodage de deux accords.</i>  <i>Chaque accord dure un huiti√®me temps d'une mesure, le deuxi√®me accord est accompagn√© d'une ferme.</i>  <i>La s√©quence "|||"</i>  <i>marque la fin du cadre</i> <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode_score</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(score, keep_fermatas=True, parts_to_mask=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Encodes a music21 score into a List of chords, where each chord is represented with a (Fermata :: Bool, List[(Note :: Integer, Tie :: Bool)]). If `keep_fermatas` is True, all `has_fermata`s will be False. All tokens from parts in `parts_to_mask` will have output tokens `BLANK_MASK_TXT`. Time is discretized such that each crotchet occupies `FRAMES_PER_CROTCHET` frames. """</span></span> encoded_score = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chord <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (score .quantize((FRAMES_PER_CROTCHET,)) .chordify(addPartIdAsGroup=bool(parts_to_mask)) .flat .notesAndRests): <span class="hljs-comment"><span class="hljs-comment"># aggregate parts, remove markup # expand chord/rest st constant timestep between frames if chord.isRest: encoded_score.extend((int(chord.quarterLength * FRAMES_PER_CROTCHET)) * [[]]) else: has_fermata = (keep_fermatas) and any(map(lambda e: e.isClassOrSubclass(('Fermata',)), chord.expressions)) encoded_chord = [] # </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> sorts Soprano, Bass, Alto, Tenor without breaking ties # c = chord.sortAscending() # sorted_notes = [c[-1], c[0]] + c[1:-1] # for note in sorted_notes: for note in chord: if parts_to_mask and note.pitch.groups[0] in parts_to_mask: encoded_chord.append(BLANK_MASK_TXT) else: has_tie = note.tie is not None and note.tie.type != 'start' encoded_chord.append((note.pitch.midi, has_tie)) encoded_score.append((has_fermata, encoded_chord)) # repeat pitches to expand chord into multiple frames # all repeated frames when expanding a chord should be tied encoded_score.extend((int(chord.quarterLength * FRAMES_PER_CROTCHET) - 1) * [ (has_fermata, map(lambda note: BLANK_MASK_TXT if note == BLANK_MASK_TXT else (note[0], True), encoded_chord)) ]) return encoded_score</span></span></code> </pre> <br>  <i>Code utilis√© pour coder la tonalit√© music21 √† l'aide d'un sch√©ma de codage sp√©cial</i> <br><br><h2>  <font color="#0071c5">T√¢che de mod√®le</font> </h2><br>  Dans la partie pr√©c√©dente, une explication a √©t√© donn√©e montrant que la t√¢che de composition automatique peut √™tre r√©duite √† la t√¢che de pr√©dire une s√©quence.  En particulier, un mod√®le peut pr√©dire la prochaine note la plus probable sur la base des notes pr√©c√©dentes.  Pour r√©soudre ce type de probl√®me, un r√©seau de neurones avec une m√©moire √† court terme √† long terme (LSTM) est le mieux adapt√©.  Formellement, le mod√®le devrait pr√©dire P (x <sub>t + 1</sub> | x <sub>t</sub> , h <sub>t-1</sub> ), la distribution de probabilit√© pour les prochaines notes possibles (x <sub>t + 1</sub> ) en fonction du jeton actuel (x <sub>t</sub> ) et de l'√©tat cach√© pr√©c√©dent (h <sub>t-1</sub> ) .  Fait int√©ressant, la m√™me op√©ration est effectu√©e par des mod√®les de langage bas√©s sur des r√©seaux de neurones r√©currents. <br><br>  En mode composition, le mod√®le est initialis√© avec le jeton <i>START</i> , apr√®s quoi il s√©lectionne le prochain jeton le plus probable √† suivre.  Apr√®s cela, le mod√®le continue de s√©lectionner le prochain jeton le plus probable en utilisant la note pr√©c√©dente et l'√©tat cach√© pr√©c√©dent jusqu'√† ce qu'un jeton END soit g√©n√©r√©.  Le syst√®me contient des √©l√©ments de temp√©rature qui ajoutent un certain degr√© d'al√©atoire pour emp√™cher BachBot de composer la m√™me pi√®ce encore et encore. <br><br><h3>  <font color="#0071c5">Fonction de perte</font> </h3><br>  Lors de la formation d'un mod√®le pour la pr√©diction, il existe g√©n√©ralement une fonction qui doit √™tre minimis√©e (appel√©e fonction de perte).  Cette fonction d√©crit la diff√©rence entre la pr√©diction du mod√®le et la propri√©t√© de v√©rit√© terrain.  BachBot minimise la perte d'entropie crois√©e entre la distribution pr√©dite (x <sub>t + 1</sub> ) et la distribution r√©elle de la fonction objectif.  L'utilisation de l'entropie crois√©e comme fonction de perte est un bon point de d√©part pour un large √©ventail de t√¢ches, mais dans certains cas, vous pouvez utiliser votre propre fonction de perte.  Une autre approche acceptable consiste √† essayer d'utiliser diverses fonctions de perte et √† appliquer un mod√®le qui minimise la perte r√©elle lors de la v√©rification. <br><br><h3>  <font color="#0071c5">Formation / tests</font> </h3><br>  Lors de la formation d'un r√©seau neuronal r√©cursif, BachBot a utilis√© la correction de jeton avec la valeur x <sub>t + 1</sub> au lieu d'appliquer la pr√©diction du mod√®le.  Ce processus, connu sous le nom d'apprentissage obligatoire, est utilis√© pour assurer la convergence, car les pr√©dictions du mod√®le produiront naturellement de mauvais r√©sultats au d√©but de la formation.  En revanche, lors de la validation et de la composition, la pr√©diction du mod√®le x <sub>t + 1</sub> doit √™tre r√©utilis√©e comme entr√©e pour la prochaine pr√©diction. <br><br><h3>  <font color="#0071c5">Autres consid√©rations</font> </h3><br>  Pour augmenter l'efficacit√© de ce mod√®le, les m√©thodes pratiques suivantes, communes aux r√©seaux de neurones LSTM, ont √©t√© utilis√©es: troncature de gradient normalis√©e, m√©thode d'√©limination, normalisation des paquets et m√©thode de propagation par erreur temporelle tronqu√©e (BPTT). <br><br>  <i>La m√©thode de troncature de gradient normalis√©e</i> √©limine le probl√®me de croissance incontr√¥l√©e de la valeur de gradient (l'inverse du probl√®me de gradient de fuite, qui a √©t√© r√©solu en utilisant l'architecture des cellules de m√©moire LSTM).  En utilisant cette technique, les valeurs de gradient qui d√©passent un certain seuil sont tronqu√©es ou mises √† l'√©chelle. <br><br>  <i>La m√©thode d'exclusion</i> est une technique dans laquelle certains neurones <i>s√©lectionn√©s au hasard sont</i> d√©connect√©s (exclus) lors de la formation du r√©seau.  Cela √©vite le sur-ajustement et am√©liore la qualit√© de la g√©n√©ralisation.  Le probl√®me du surajustement se pose lorsque le mod√®le est optimis√© pour l'ensemble de donn√©es d'apprentissage et, dans une moindre mesure, applicable pour des √©chantillons en dehors de cet ensemble.  La m√©thode d'exclusion aggrave souvent la perte pendant la formation, mais l'am√©liore au stade de la v√©rification (voir ci-dessous). <br><br>  Le calcul du gradient dans un r√©seau neuronal r√©current pour une s√©quence de 1000 √©l√©ments est √©quivalent en co√ªt aux passages avant et arri√®re dans le r√©seau neuronal √† distribution directe de 1000 couches.  <i>La</i> m√©thode de <i>propagation de retour d'erreur tronqu√©e</i> (BPTT) dans le temps est utilis√©e pour r√©duire le co√ªt de mise √† jour des param√®tres pendant la formation.  Cela signifie que les erreurs ne se propagent que pendant un nombre fixe de pas de temps compt√©s √† partir du moment actuel.  Veuillez noter que les d√©pendances d'apprentissage √† long terme sont toujours possibles avec la m√©thode BPTT, car les √©tats latents ont d√©j√† √©t√© r√©v√©l√©s √† de nombreux pas de temps pr√©c√©dents. <br><br><h3>  <font color="#0071c5">Param√®tres</font> </h3><br>  Voici une liste de param√®tres pertinents pour les mod√®les de r√©seaux de neurones r√©currents / r√©seaux de neurones avec une m√©moire √† court terme: <br><ul><li>  <i>Le nombre de couches</i> .  L'augmentation de ce param√®tre peut augmenter l'efficacit√© du mod√®le, mais il faudra plus de temps pour le former.  De plus, trop de couches peuvent entra√Æner un sur-ajustement. </li><li>  <i>La dimension de l'√©tat latent</i> .  L'augmentation de ce param√®tre peut augmenter la complexit√© du mod√®le, mais cela peut entra√Æner un sur-ajustement. </li><li>  <i>Dimension des comparaisons vectorielles</i> </li><li>  <i>La longueur de la s√©quence</i> / le nombre de trames avant de tronquer la propagation inverse de l'erreur dans le temps. </li><li>  <i>Probabilit√© d'exclusion des neurones</i> .  La probabilit√© avec laquelle un neurone sera exclu du r√©seau au cours de chaque cycle de mise √† jour. </li></ul><br>  La m√©thodologie de s√©lection de l'ensemble optimal de param√®tres sera discut√©e plus loin dans cet article. <br><br><h2>  <font color="#0071c5">Impl√©mentation, formation et tests</font> </h2><br><h3>  <font color="#0071c5">S√©lection de la plateforme</font> </h3><br>  Actuellement, il existe de nombreuses plates-formes qui vous permettent d'impl√©menter des mod√®les d'apprentissage automatique dans diff√©rents langages de programmation (y compris m√™me JavaScript!).  Les plates-formes populaires incluent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scikit-learn</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TensorFlow</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Torch</a> . <br><br>  La biblioth√®que Torch a √©t√© choisie comme plate-forme pour le projet BachBot.  Au d√©but, la biblioth√®que TensorFlow a √©t√© essay√©e, mais √† cette √©poque, elle utilisait de vastes r√©seaux de neurones r√©currents, ce qui a entra√Æn√© un d√©bordement de la RAM du GPU.  Torch est une plate-forme de calcul scientifique propuls√©e par le langage de programmation rapide LuaJIT *.  La plate-forme Torch contient d'excellentes biblioth√®ques pour travailler avec les r√©seaux de neurones et l'optimisation. <br><br><h3>  <font color="#0071c5">Mise en ≈ìuvre du mod√®le et formation</font> </h3><br>  L'impl√©mentation variera √©videmment en fonction de la langue et de la plateforme sur lesquelles vous choisirez.  Pour savoir comment BachBot impl√©mente des r√©seaux de neurones avec une m√©moire √† long terme et √† court terme √† l'aide de Torch, consultez les scripts utilis√©s pour entra√Æner et d√©finir les param√®tres de BachBot.  Ces scripts sont disponibles sur le site Web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Feynman Lyang GitHub.</a> <br><br>  Un bon point de d√©part pour naviguer dans le r√©f√©rentiel est le <a href="">script 1-train.zsh</a> .  Avec lui, vous pouvez trouver le chemin d'acc√®s au fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bachbot.py</a> . <br><br>  Plus pr√©cis√©ment, le script principal pour d√©finir les param√®tres du mod√®le est le fichier <a href="">LSTM.lua</a> .  Le script de formation du mod√®le est le fichier <a href="">train.lua</a> . <br><br><h3>  <font color="#0071c5">Optimisation hyperparam√©trique</font> </h3><br>  Pour rechercher les valeurs optimales des hyperparam√®tres, la m√©thode de recherche de grille a √©t√© utilis√©e en utilisant la grille de param√®tres suivante. <br><br><img src="https://habrastorage.org/webt/91/7p/_3/917p_3g7mtewimqlykgaskxn8y0.png"><br>  <i>Grille de param√®tres utilis√©e par BachBot dans la recherche de grille</i> <br><br>  Une recherche dans la grille est une recherche compl√®te de toutes les combinaisons possibles de param√®tres.  D'autres m√©thodes sugg√©r√©es pour optimiser les hyperparam√®tres sont la recherche al√©atoire et l'optimisation bay√©sienne. <br><br>  L'ensemble optimal d'hyperparam√®tres d√©tect√©s √† la suite d'une recherche dans la grille est le suivant: nombre de couches = 3, dimension de l'√©tat cach√© = 256, dimension des comparaisons vectorielles = 32, longueur de s√©quence = 128, probabilit√© d'√©limination des neurones = 0,3. <br><br>  Ce mod√®le a atteint une perte d'entropie crois√©e de 0,324 pendant l'entra√Ænement et de 0,477 au stade de la v√©rification.  Le graphique de la courbe d'apprentissage montre que le processus d'apprentissage converge apr√®s 30 it√©rations (‚âà28,5 minutes lors de l'utilisation d'un seul GPU). <br><br>  Les graphiques de perte pendant l'entra√Ænement et pendant la phase de v√©rification peuvent √©galement illustrer l'effet de chaque hyperparam√®tre.  La probabilit√© d'√©liminer les neurones nous int√©resse particuli√®rement: <br><br><img src="https://habrastorage.org/webt/ad/zd/_s/adzd_s3hxek23oyz8dqg_d1pkys.png"><br>  <i>Courbes d'apprentissage pour divers param√®tres de m√©thode d'exclusion</i> <br><br>  On peut voir sur la figure que la m√©thode d'√©limination √©vite vraiment l'apparition de sur-ajustement.  Bien qu'avec une probabilit√© d'exclusion de 0,0, la perte pendant l'entra√Ænement est minime, au stade de la v√©rification, la perte a une valeur maximale.  Des valeurs de probabilit√© √©lev√©es entra√Ænent une augmentation des pertes lors de la formation et une diminution des pertes au stade de la v√©rification.  La valeur minimale de la perte lors de la phase de v√©rification lors de l'utilisation de BachBot a √©t√© fix√©e avec une probabilit√© d'exception de 0,3. <br><br><h3>  <font color="#0071c5">M√©thodes d'√©valuation alternatives (facultatif)</font> </h3><br>  Pour certains mod√®les - en particulier pour les applications cr√©atives telles que la composition de musique - la perte peut ne pas √™tre une mesure appropri√©e du succ√®s du syst√®me.  Au lieu de cela, la perception humaine subjective peut √™tre le meilleur crit√®re. <br><br>  Le but du projet BachBot est de composer automatiquement une musique qui ne se distingue pas des propres compositions de Bach.  Pour √©valuer le succ√®s des r√©sultats, une enqu√™te aupr√®s des utilisateurs sur Internet a √©t√© r√©alis√©e.  L'enqu√™te a pris la forme d'un concours dans lequel les utilisateurs √©taient invit√©s √† d√©terminer quelles ≈ìuvres appartenaient au projet BachBot et lesquelles appartenaient √† Bach. <br><br>  Les r√©sultats de l'enqu√™te ont montr√© que les participants √† l'enqu√™te (759 personnes avec diff√©rents niveaux de formation) √©taient en mesure de distinguer avec pr√©cision entre deux √©chantillons dans seulement 59 pour cent des cas.  C'est seulement 9 pour cent de plus que le r√©sultat d'une estimation al√©atoire!  Essayez vous-m√™me l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enqu√™te BachBot</a> ! <br><br><h2>  <font color="#0071c5">Adapter le mod√®le √† l'harmonisation</font> </h2><br>  Maintenant, BachBot peut calculer P (x <sub>t + 1</sub> | x <sub>t</sub> , h <sub>t-1</sub> ), la distribution de probabilit√© pour les prochaines notes possibles en fonction de la note actuelle et de l'√©tat cach√© pr√©c√©dent.  Ce mod√®le de pr√©diction s√©quentielle peut ensuite √™tre adapt√© pour harmoniser la m√©lodie.  Un tel mod√®le adapt√© est n√©cessaire pour harmoniser la m√©lodie, modul√©e √† l'aide d'√©motions, dans le cadre d'un projet musical avec diaporama. <br><br>  Lorsque vous travaillez avec l'harmonisation du mod√®le, une m√©lodie pr√©d√©finie est fournie (g√©n√©ralement c'est une partie soprano), et apr√®s cela, le mod√®le devrait composer de la musique pour le reste des morceaux.  Pour accomplir cette t√¢che, une recherche ¬´best-first¬ª gourmande est utilis√©e avec la restriction que les notes de m√©lodie sont fixes.  Les algorithmes gourmands impliquent des d√©cisions optimales d'un point de vue local.  Voici donc une strat√©gie simple utilis√©e pour l'harmonisation: <br><blockquote>  Supposons que x <sub>t</sub> sont des jetons dans l'harmonisation propos√©e.  Au pas de temps t, si la note correspond √† la m√©lodie, alors x <sub>t</sub> est √©gal √† la note donn√©e.  Sinon, x <sub>t</sub> est √©gal √† la note suivante la <i>plus probable</i> conform√©ment aux pr√©dictions du mod√®le.  Le code de cette adaptation du mod√®le est disponible sur le site Web de Feynman Lyang GitHub: <a href="">HarmModel.lua</a> , <a href="">harmonize.lua</a> . </blockquote><br>  Ce qui suit est un exemple d'harmonisation de la berceuse Twinkle, Twinkle, Little Star avec BachBot, en utilisant la strat√©gie ci-dessus. <br><br><img src="https://habrastorage.org/webt/wl/mu/kf/wlmukfjpuyeswxwfr15lmkgfvrw.jpeg"><br>  <i>Harmonisation de la berceuse de Twinkle, Twinkle, Little Star avec BachBot (dans la partie soprano).</i>  <i>Des parties d'alto, de t√©nor et de basse √©taient √©galement remplies de BachBot</i> <br><br>  Dans cet exemple, la m√©lodie de la berceuse Twinkle, Twinkle, Little Star est donn√©e dans la partie soprano.  Apr√®s cela, les parties d'alto, de t√©nor et de basse ont √©t√© remplies en utilisant BachBot en utilisant une strat√©gie d'harmonisation.  Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici comment √ßa sonne</a> . <br><br>  Malgr√© le fait que BachBot a montr√© de bonnes performances dans l'ex√©cution de cette t√¢che, il existe certaines limitations associ√©es √† ce mod√®le.  Plus pr√©cis√©ment, l'algorithme <i>ne regarde pas vers l'avant</i> dans la m√©lodie et utilise uniquement la note actuelle de la m√©lodie et le contexte pass√© pour g√©n√©rer des notes ult√©rieures.  Lors de l'harmonisation d'une m√©lodie par des personnes, ils peuvent couvrir toute la m√©lodie, ce qui simplifie la d√©rivation d'harmonisations appropri√©es.  Le fait que ce mod√®le ne soit pas capable de le faire peut entra√Æner des <i>surprises en</i> raison des restrictions d'utilisation des informations ult√©rieures qui provoquent des erreurs.  Pour r√©soudre ce probl√®me, la <i>recherche</i> dite de <i>faisceau</i> peut √™tre utilis√©e. <br><br>  Lorsque vous utilisez la recherche de faisceau, diverses lignes de mouvement sont v√©rifi√©es.  Par exemple, au lieu d'en utiliser une seule, la note la plus probable, qui est actuellement en cours, quatre ou cinq notes les plus probables peuvent √™tre consid√©r√©es, apr√®s quoi l'algorithme continue son travail avec chacune de ces notes.  L'examen des diff√©rentes options peut aider le mod√®le √† se <i>remettre des erreurs</i> .  La recherche par faisceau est couramment utilis√©e dans les applications de traitement du langage naturel pour cr√©er des phrases. <br><br>  Les m√©lodies modul√©es √† l'aide d'√©motions peuvent d√©sormais passer par un tel mod√®le d'harmonisation pour les compl√©ter. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423727/">https://habr.com/ru/post/fr423727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423713/index.html">"Made in Russia" - Langage de programmation WBASIC pour le d√©veloppement d'applications Web c√¥t√© serveur</a></li>
<li><a href="../fr423719/index.html">D'Erlang / Elixir √† Java et vice versa. Aventure pendant 20 minutes</a></li>
<li><a href="../fr423721/index.html">¬´Vous √™tes une m√®re laide ** ker¬ª: algorithmes de d√©tection des langues hostiles et solutions de contournement</a></li>
<li><a href="../fr423723/index.html">Projet (non) commercial: Redis change de licence mais reste open source</a></li>
<li><a href="../fr423725/index.html">Processus de conception dans ISPsystem. Comment introduire une id√©ologie, construire un d√©partement et rester en vie</a></li>
<li><a href="../fr423729/index.html">5 millions de comptes enregistr√©s dans le crypto-mail ProtonMail</a></li>
<li><a href="../fr423731/index.html">Calcul de caract√®res avec Python. Partie 1. Les bases</a></li>
<li><a href="../fr423733/index.html">L'impact du RGPD sur les op√©rateurs de donn√©es personnelles russes</a></li>
<li><a href="../fr423735/index.html">La conf√©rence Internet of Things accueillera la bataille des startups. Nous invitons les participants</a></li>
<li><a href="../fr423737/index.html">Optimisation stricte du travail avec les donn√©es du march√© pour les √©changes de crypto-monnaie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>