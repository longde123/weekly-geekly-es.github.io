<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì† üíæ ü§òüèº Gerando √≠cones de v√°rias plataformas e com v√°rias marcas com o Sketch e um script Node.js. - Parte # 2 üÜö üëßüèª ü•°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte de uma postagem sobre a cria√ß√£o de um pipeline que pode pegar um arquivo de esbo√ßo e exportar todos os √≠cones inclu√≠dos no arqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerando √≠cones de v√°rias plataformas e com v√°rias marcas com o Sketch e um script Node.js. - Parte # 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/441042/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Esta √© a segunda parte de uma postagem sobre a cria√ß√£o de um pipeline que pode pegar um arquivo de esbo√ßo e exportar todos os √≠cones inclu√≠dos no arquivo, em diferentes formatos, para diferentes plataformas, com a possibilidade de a AB testar cada √≠cone. <br><br>  Voc√™ pode ler a primeira parte do post <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Os arquivos do Sketch, com todos os √≠cones coletados, estilizados e nomeados corretamente, estavam prontos.  Agora era hora de come√ßar a escrever o c√≥digo. <br><br>  Basta dizer que o processo foi uma tentativa e erro: ap√≥s o importante n√∫cleo inicial do c√≥digo, desenvolvido pelo l√≠der da minha equipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nikhil Verma</a> (que estabeleceu as bases do script), passei por um processo incremental que exigia pelo menos tr√™s fases de refatora√ß√£o e algumas revis√µes.  Por esse motivo, n√£o entrarei em muitos detalhes sobre como o script foi desenvolvido, mas focarei em como o script funciona hoje, em sua forma final. <br><a name="habracut"></a><br><h2>  O script de constru√ß√£o </h2><br>  O script de constru√ß√£o - escrito em Node.js - √© relativamente direto em seu fluxo: uma vez importadas as depend√™ncias, declaradas a lista de arquivos do Sketch a serem processados ‚Äã‚Äã(como uma lista de marcas e, para cada marca, uma lista de arquivos para essa marca) e verificou se o Sketch est√° instalado no cliente, o script faz um loop na matriz de marcas e, para cada uma delas, executa estas etapas em sequ√™ncia: <br><br><ol><li>  Obtenha os tokens de design para a marca (precisamos dos valores de cor) </li><li>  Clone os arquivos de esbo√ßo associados √† marca, descompacte-os para expor os arquivos JSON internos e manipule alguns dos valores internos desses arquivos JSON (mais sobre isso mais adiante) </li><li>  Leia os meta-dados relevantes dos arquivos JSON do Sketch ( <i>document.json</i> , <i>meta.json</i> e <i>pages / pageUniqueID.json</i> );  em particular, precisamos da lista de estilos compartilhados e da lista de ativos / √≠cones contidos nos arquivos </li><li>  Ap√≥s algumas manipula√ß√µes adicionais dos arquivos Sketch JSON, remova-os e, usando os arquivos de esbo√ßo (clonados e atualizados), exporte e gere os arquivos finais de sa√≠da para as tr√™s plataformas (iOS, Android, Mobile Web) </li></ol><br>  Voc√™ pode visualizar as partes relevantes do script de constru√ß√£o principal aqui: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; { // get the design tokens for the brand const brandTokens = getDesignTokens(brand); // prepare the Sketch files (unzipped) and get a list of them const sketchUnzipFolders = await prepareSketchFiles({ brand, sketchFileNames: SKETCH_FILES[brand], sketchFolder: SKETCH_FOLDER_PATH, sketchTempFolder: SKETCH_TEMP_PATH }); // get the Sketch metadata const sketchMetadata = getSketchMetadata(sketchUnzipFolders); const sketchDataSharedStyles = sketchMetadata.sharedStyles; const sketchDataAssets = sketchMetadata.assetsMetadata; generateAssetsPDF({ platform: 'ios', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsSVGDynamicMobileWeb({ platform: 'mw', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsVectorDrawableDynamicAndroid({ platform: 'android', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); }); }</code> </pre> <br>  Na verdade, todo o c√≥digo do pipeline √© muito mais complexo que isso, e a complexidade est√° nas <b>fun√ß√µes prepareSketchFiles</b> , <b>getSketchMetadata</b> e <b>generateAssets [format] [platform]</b> .  Vou tentar explic√°-los com mais detalhes abaixo. <br><br><h2>  Preparando os arquivos de esbo√ßo </h2><br>  A primeira etapa do processo de cria√ß√£o √© a prepara√ß√£o dos arquivos do Sketch, para que possam ser usados ‚Äã‚Äãposteriormente para a exporta√ß√£o dos ativos para as diferentes plataformas. <br><br>  Os arquivos associados √† marca - para o Blendr, por exemplo, os arquivos <i>icons_common.sketch</i> e <i>icons_blendr.sketch</i> - s√£o inicialmente clonados em uma pasta tempor√°ria (mais precisamente, em uma subpasta com o nome da marca que est√° sendo processada) e descompactados. <br><br>  Em seguida, os arquivos JSON internos s√£o processados, com um prefixo adicionado aos ativos que ser√£o submetidos ao teste AB, para que, quando exportados, sejam salvos em uma subpasta com um nome predefinido (o nome exclusivo da experi√™ncia).  Para entender quais ativos est√£o sendo testados, basta verificar se o nome da p√°gina em que est√£o armazenados no Sketch √© prefixado com <i>"XP_"</i> . <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br>  <i>Uma compara√ß√£o dos nomes das camadas, dentro dos arquivos do Sketch, antes e depois da atualiza√ß√£o.</i> <br><br>  No exemplo acima, quando exportados, os ativos ser√£o salvos na subpasta <i>"this__is_an_experiment"</i> , com um nome de arquivo <i>"icon-name [variant-name] .ext"</i> . <br><br><h2>  Lendo os metadados do esbo√ßo </h2><br>  A segunda etapa importante do processo √© obter todos os metadados relevantes dos arquivos do Sketch, em particular dos arquivos JSON internos.  Como explicado acima, esses arquivos s√£o os dois arquivos principais ( <i>document.json</i> e <i>meta.json</i> ) e os arquivos de <i>p√°ginas</i> ( <i>pages / pageUniqueId.json</i> ). <br><br>  O <i>arquivo document.json</i> √© usado para obter a lista dos estilos compartilhados, que aparecem na propriedade do objeto <i>layerStyles</i> : <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": { "_class": "sharedStyleContainer", "objects": [ { "_class": "sharedStyle", "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4", "name": "features/feature-like", "value": { "_class": "style", "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.10588235408067703, "green": 0.4000000059604645, "red": 1 }, "fillType": 0, "noiseIndex": 0, "noiseIntensity": 0, "patternFillType": 1, "patternTileScale": 1 } ], "blur": {...}, "startMarkerType": 0, "endMarkerType": 0, "miterLimit": 10, "windingRule": 1 } }, ...</code> </pre> <br>  Para cada estilo, armazenamos algumas informa√ß√µes b√°sicas em um objeto de valor-chave.  Isso ser√° usado posteriormente sempre que precisarmos recuperar o nome de um estilo com base em seu ID exclusivo (no Sketch, a propriedade <i>do_objectID</i> ): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = { name: object.name, isFill: _.get(object, 'value.fills[0].color') !== undefined, isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br><br>  Neste ponto, passamos para o arquivo <i>meta.json</i> para obter a lista de p√°ginas, em particular precisamos <i>do ID</i> e <i>nome</i> <i>exclusivos</i> : <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": { "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": { "name": "Icons", "artboards": { "3275987C-CE1B-4369-B789-06366EDA4C98": { "name": "badge-feature-like" }, "C6992142-8439-45E7-A346-FC35FA01440F": { "name": "badge-feature-crush" }, ... "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": { "name": "tabbar-livestream" } ... } }, "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": { "name": "XP_this__is_an_experiment", "artboards": { "31A812E8-D960-499F-A10F-C2006DDAEB65": { "name": "this__is_an_experiment/tabbar-livestream[variant1]" }, "20F03053-ED77-486B-9770-32E6BA73A0B8": { "name": "this__is_an_experiment/tabbar-livestream[variant2]" }, "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": { "name": "this__is_an_experiment/tabbar-livestream[control]" } } },</code> </pre> <br>  Ent√£o, para cada p√°gina, lemos o arquivo JSON correspondente na pasta <i>pages</i> (como j√° foi dito, o nome do arquivo √© <i>[pageUniqueId] .json</i> ) e <i>examinamos</i> os ativos contidos nessa p√°gina (eles aparecem como camadas).  Dessa forma, para cada √≠cone, obtemos seu nome, sua largura / altura, os metadados do Sketch para o √≠cone dessa camada e, se estiver em uma p√°gina de experi√™ncia, o nome do teste AB em quest√£o e o nome da variante para esse √≠cone. <br><br>  <i>Observe</i> : o objeto "page.json" √© muito complexo, ent√£o n√£o vou entrar aqui.  Se voc√™ estiver curioso e quiser ver como √©, sugiro que voc√™ crie um novo arquivo de esbo√ßo em branco, adicione algum conte√∫do e salve;  renomeie sua extens√£o em zip, descompacte-a e procure em um dos arquivos que aparecem na pasta "p√°ginas". <br><br>  Ao processar as pranchetas, tamb√©m criamos uma lista de experimentos (com seus ativos correspondentes) que ser√£o usados ‚Äã‚Äãposteriormente para determinar quais op√ß√µes de √≠cone s√£o usadas e para qual experimento, associando o nome das op√ß√µes de √≠cone ao objeto "base do √≠cone". <br><br>  Para cada arquivo de Sketch que est√° sendo processado associado √† marca, produzimos um objeto <i>assetsMetadata com a</i> seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": { "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977", ...sketch_artboard_properties, "name": "navigation-bar-edit", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 "layers": [ { "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4", "name": "Path", ...sketch_layer_properties, "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5", "style": { ... "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.8784313725490196, "green": 0.8784313725490196, "red": 0.8784313725490196 }, } ], "miterLimit": 10, "startMarkerType": 0, "windingRule": 1 }, }, ], ... }, "experiment-name/navigation-bar-edit[variant]": { "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7", ...sketch_artboard_properties, "name": "experiment-name/navigation-bar-edit[variant]", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 ...</code> </pre> <br>  Como voc√™ pode ver, o mesmo "√≠cone" (neste caso <i>, barra de navega√ß√£o de edi√ß√£o</i> ) pode ter v√°rios "ativos" associados a ele, em termos de experimentos.  Mas o mesmo √≠cone pode aparecer com o mesmo nome em um segundo arquivo de Sketch associado √† marca, e isso √© muito √∫til: √© o truque que usamos, para compilar um conjunto comum de √≠cones e, em seguida, definir variantes de √≠cones diferentes espec√≠ficas, dependendo da marca. <br><br>  Por isso, declaramos os arquivos de esbo√ßo associados a cada marca em particular como uma matriz: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Porque neste caso a ordem √© importante.  De fato, na fun√ß√£o <i>getSketchMetadata</i> , chamada pelo script de constru√ß√£o, n√£o retornamos os objetos <i>assetsMetadata</i> (um por arquivo) como uma lista, mas fazemos uma mesclagem profunda de cada objeto, um no outro, e ent√£o n√≥s retorne um √∫nico objeto <i>assetsMetadata</i> mesclado. <br><br>  Isso nada mais √© do que a mesclagem "l√≥gica" dos arquivos do Sketch e seus ativos em um √∫nico arquivo.  Mas a l√≥gica n√£o √© t√£o simples quanto parece.  Aqui est√° o esquema que tivemos que criar para descobrir o que acontece quando h√° √≠cones com o mesmo nome (possivelmente em teste AB) em arquivos diferentes associados √† mesma marca: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br>  <i>O esquema l√≥gico de como a "substitui√ß√£o" do mesmo √≠cone funciona, entre um conjunto comum / compartilhado de √≠cones e √≠cones projetados especificamente para marcas brancas (tamb√©m considerando o caso do teste AB)</i> <br><br><h2>  Gerando os arquivos finais em diferentes formatos para diferentes plataformas </h2><br>  A √∫ltima etapa do processo √© a gera√ß√£o real dos arquivos de √≠cone com diferentes formatos para as diferentes plataformas (PDF para iOS, SVG / JSX para Web e VectorDrawable para Android). <br><br>  Como voc√™ pode ver pelo n√∫mero de par√¢metros passados ‚Äã‚Äãpara as fun√ß√µes <i>generateAssets [formato] [plataforma],</i> essa √© a parte mais complexa do pipeline.  Aqui √© onde <b>o processo come√ßa a se dividir e divergir</b> para as diferentes plataformas.  Veja abaixo o fluxo l√≥gico completo do script e como a parte relacionada √† gera√ß√£o dos ativos se <b>divide em tr√™s fluxos semelhantes, mas n√£o id√™nticos:</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Para gerar os ativos finais com as cores corretas associadas √† marca que est√° sendo processada, precisamos fazer outro conjunto de manipula√ß√µes nos arquivos JSON do Sketch: passamos iterativamente por todas as camadas que t√™m um estilo compartilhado aplicado e substitu√≠mos o valores de cores com as cores dos tokens de design da marca. <br><br>  Para a gera√ß√£o Android, √© necess√°ria uma manipula√ß√£o extra (mais sobre isso posteriormente): alteramos a propriedade de regra de preenchimento de cada camada de <i>√≠mpar par</i> para <i>diferente de zero</i> (isso √© controlado pela propriedade "windingRule" no objeto JSON, em que " 1 "significa" √≠mpar par "e" 0 "significa" diferente de zero "). <br><br>  Depois de concluir essas manipula√ß√µes, compactamos os arquivos JSON do Sketch de volta em um arquivo de Sketch padr√£o, para que possam ser processados ‚Äã‚Äãpara exportar os ativos com as propriedades atualizadas (os arquivos clonados e atualizados s√£o arquivos de Sketch absolutamente normais: eles podem ser abertos no Sketch , visualizado, editado, salvo etc.). <br><br>  Nesse ponto, podemos usar o sketchtool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um wrapper de n√≥</a> ) para exportar automaticamente todos os ativos em formatos espec√≠ficos para plataformas espec√≠ficas.  Para cada arquivo associado a uma marca (mais corretamente, sua vers√£o clonada e atualizada), executamos este comando: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg &lt;i&gt;--scales=1 &lt;/i&gt;--output=${destinationFolder} --overwriting`);</code> </pre> <br>  Como voc√™ pode imaginar, esse comando exporta os ativos em um formato espec√≠fico, aplicando uma escala opcional (por enquanto, sempre mantemos a escala original), para uma pasta de destino.  A op√ß√£o <i>--overwriting</i> √© a chave aqui: da mesma maneira que fazemos uma "mesclagem profunda" dos objetos assetsMetadata (que equivale a uma "mesclagem l√≥gica" dos arquivos do Sketch), quando exportamos, fazemos isso de v√°rios arquivos para a mesma pasta (exclusiva por marca / plataforma).  Isso significa que, se um ativo - identificado pelo nome da camada - j√° existia em um arquivo de esbo√ßo anterior, ele ser√° substitu√≠do pela exporta√ß√£o a seguir.  O que, novamente, nada mais √© do que uma opera√ß√£o de "mesclagem". <br><br>  Nesse caso, por√©m, podemos ter alguns ativos que s√£o "fantasmas".  Isso acontece quando um √≠cone √© testado AB em um arquivo, mas substitu√≠do em um arquivo subsequente.  Nesses casos, os arquivos variantes s√£o exportados para a pasta de destino, referenciada no objeto <i>assetsMetadata</i> como ativo (com sua chave e propriedades), mas n√£o associada a nenhum ativo "base" (devido √† mesclagem profunda dos objetos <i>assetsMetadata</i> ).  Esses arquivos ser√£o removidos em uma etapa posterior, antes da conclus√£o do processo. <br><br><hr><br>  Como mencionado acima, precisamos de diferentes formatos finais para diferentes plataformas.  Para iOS, queremos arquivos PDF e podemos export√°-los diretamente com o comando <i>sketchtool</i> .  Enquanto, para a Web m√≥vel, queremos arquivos JSX, e para Android, arquivos VectorDrawable;  por esse motivo, exportamos os ativos no formato SVG para uma pasta intermedi√°ria e os sujeitamos a processamento adicional. <br><br><h2>  Arquivos PDF para iOS </h2><br>  Estranhamente, o PDF √© o formato (apenas?) Suportado pelo Xcode e OS / iOS para importar e renderizar ativos vetoriais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma breve explica√ß√£o</a> dos motivos t√©cnicos por tr√°s dessa escolha da Apple). <br><br>  Como podemos exportar diretamente em PDF via Sketchtool, n√£o h√° necessidade de etapas extras para esta plataforma: simplesmente salvamos os arquivos diretamente na pasta de destino, e √© isso. <br><br><h2>  Arquivos React / JSX para web </h2><br>  No caso da Web, usamos uma biblioteca Node chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">svgr,</a> que converte arquivos SVG simples em componentes React.  Mas queremos fazer algo ainda mais poderoso: queremos "pintar dinamicamente" o √≠cone em tempo de execu√ß√£o, com as cores provenientes dos tokens de design.  Por esse motivo, imediatamente antes da convers√£o, substitu√≠mos no SVG os valores de <i>preenchimento</i> dos caminhos que originalmente tinham um estilo compartilhado aplicado, pelo valor do token correspondente associado a esse estilo. <br><br>  Portanto, se este √© o arquivo <i>badge-feature-like.svg</i> exportado do Sketch: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) - &lt;a href="http://www.bohemiancoding.com/sketch"&gt;http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt; &lt;g id="badge-feature-like"&gt; &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt; &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  o recurso / √≠cone <i>badge-feature-like.js</i> final ter√° a seguinte apar√™ncia: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return ( &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt; &lt;g fill="none" fillRule="evenodd"&gt; &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt; &lt;path fill="#FFF" d="M80.4061668,..." /&gt; &lt;/g&gt; &lt;/svg&gt; ); };</code> </pre> <br>  Como voc√™ pode ver, substitu√≠mos o valor est√°tico da cor de <i>preenchimento</i> do c√≠rculo por um din√¢mico, que recebe o valor dos tokens de design (eles ser√£o disponibilizados para o componente React <i>&lt;Icon /&gt;</i> via API de contexto, mas isso √© outra hist√≥ria). <br><br>  Essa substitui√ß√£o √© poss√≠vel atrav√©s dos metadados do Sketch para o ativo armazenado no objeto de <i>metadados</i> do <i>ativo</i> : fazendo um loop recursivo pelas camadas do ativo, √© poss√≠vel criar um seletor DOM (no caso acima, seria <i>#Icons # badge-feature- como #circle</i> ) e use-o para encontrar o n√≥ na √°rvore SVG e substitua o valor do atributo de <i>preenchimento</i> (para esta opera√ß√£o, usamos a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cheerio</a> ). <br><br><h2>  Arquivos desenh√°veis ‚Äã‚Äãpara Android </h2><br>  O Android suporta gr√°ficos vetoriais usando seu formato vetorial personalizado, chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VectorDrawable</a> .  Normalmente, a convers√£o de SVG para VectorDrawable √© feita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diretamente no Android Studio</a> pelos desenvolvedores.  Mas aqui quer√≠amos automatizar todo o processo, portanto, precisamos encontrar uma maneira de convert√™-los via c√≥digo. <br><br>  Depois de examinar diferentes bibliotecas e ferramentas, decidimos usar uma biblioteca chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">svg2vectordrawable</a> .  N√£o apenas √© mantido ativamente (pelo menos, melhor que os outros que encontramos), mas tamb√©m √© mais completo. <br><br>  O fato √© que o VectorDrawable n√£o tem paridade de recursos com o SVG: alguns dos recursos avan√ßados do SVG (por exemplo, gradientes radiais, m√°scaras complexas etc.) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o</a> s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suportados</a> e alguns deles ganharam suporte apenas recentemente (com a API Android 24 e superior).  Uma desvantagem disso √© que, no Android anterior a 24, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a regra de preenchimento "√≠mpares pares" n√£o √© suportada</a> .  Mas no Badoo, precisamos oferecer suporte ao Android 5 e superior.  √â por isso que, como explicado acima, para Android, precisamos converter todos os caminhos nos arquivos do Sketch para preenchimento "diferente de zero". <br><br>  Potencialmente, os designers podem fazer isso manualmente: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  mas isso pode ser facilmente esquecido e, portanto, propenso a erros humanos. <br><br>  Por esse motivo, adicionamos uma etapa extra em nosso processo para Android, onde convertemos automaticamente todos os caminhos para <i>diferentes de zero</i> no JSON do Sketch.  Isso ocorre quando exportamos os √≠cones para SVG, eles j√° est√£o nesse formato e cada VectorDrawable gerado tamb√©m √© compat√≠vel com os dispositivos Android 5. <br><br>  O arquivo <i>badge-feature-like.xml</i> final, neste caso, √© assim: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path android:fillColor="?color_feature_liked_you" android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path android:fillColor="#FFFFFF" android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Como voc√™ pode ver, tamb√©m nos arquivos VectorDrawable, injetamos nomes de vari√°veis ‚Äã‚Äãpara as cores de <i>preenchimento</i> , que s√£o associadas aos tokens de design por meio de estilos personalizados nos aplicativos Android. <br><br>  √â assim que o VectorDrawable √© importado no Android Studio: <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br>  <i>Um exemplo de √≠cone VectorDrawable importado para o Android Studio</i> <br><br>  Uma coisa a observar neste caso: o Android Studio tem uma maneira muito estrita e prescritiva de organizar os ativos: nenhuma pasta aninhada e todos os nomes em min√∫sculas!  Isso significava que tivemos que criar um formato ligeiramente diferente para os nomes de seus √≠cones: no caso de um ativo em experi√™ncia, seu nome ser√° algo como <i>ic_icon-name__experiment-name__variant-name</i> . <br><br><h2>  Dicion√°rio JSON como biblioteca de ativos </h2><br>  Depois que os arquivos de ativos s√£o salvos em seu formato final, a √∫ltima coisa a ser feita √© salvar todas as metainforma√ß√µes coletadas durante o processo de compila√ß√£o e armazen√°-las em um "dicion√°rio", para que possam ser disponibilizadas posteriormente quando os ativos s√£o importados e consumidos pela base de c√≥digo das diferentes plataformas. <br><br>  Depois de extrair a lista simples de √≠cones do objeto <i>assetsMetadata</i> , fazemos um loop sobre ele e para cada item, verificamos: <br><br><ul><li>  se √© um ativo normal (por exemplo, <i>tabbar-livestream</i> ) e, se for, apenas o mantemos; </li><li>  se for uma variante em um teste AB (por exemplo, <i>experiment / tabbar-livestream [variant]</i> ), associaremos seu nome, caminho, teste AB e nomes de variantes √†s <i>abstests</i> de propriedades do <i>ativo</i> "base" (neste caso, <i>tabbar- livestream</i> ) e, em seguida, removemos a entrada variante da lista / objeto (apenas a "base" conta); </li><li>  se for uma variante "fantasma", excluiremos o arquivo e removeremos a entrada da lista / objeto. </li></ul><br>  Depois que o loop for conclu√≠do, o dicion√°rio conter√° a lista de todos e somente os √≠cones "base" (e seus testes AB, se estiverem sendo experimentados).  Para cada um deles, ele conter√° seu nome, tamanho, caminho e, no caso de um √≠cone estar em teste AB, as informa√ß√µes sobre as diferentes op√ß√µes do ativo. <br><br>  Este dicion√°rio √© salvo no formato JSON na pasta de destino da <i>marca</i> e <i>plataforma</i> .  Aqui, por exemplo, est√° o arquivo <i>assets.json</i> gerado para o aplicativo "Blendr" na "web m√≥vel": <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": { "badge-feature-like": { "assetname": "badge-feature-like", "path": "assets/badge-feature-like.jsx", "width": 64, "height": 64, "source": "icons_common" }, "navigation-bar-edit": { "assetname": "navigation-bar-edit", "path": "assets/navigation-bar-edit.jsx", "width": 48, "height": 48, "source": "icons_common" }, "tabbar-livestream": { "assetname": "tabbar-livestream", "path": "assets/tabbar-livestream.jsx", "width": 128, "height": 128, "source": "icons_blendr", "abtest": { "this__is_an_experiment": { "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx", "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx", "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx" }, "a_second-experiment": { "control": "assets/a_second-experiment/tabbar-livestream__control.jsx", "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx" } } }, ... } }</code> </pre> <br>  A √∫ltima etapa √© compactar todas as pastas de <i>ativos</i> .  arquivos <i>zip</i> , para que possam ser baixados mais facilmente. <br><br><h2>  O resultado final </h2><br>  O processo descrito acima - da clonagem e manipula√ß√£o inicial dos arquivos do Sketch, √† exporta√ß√£o (e convers√£o) dos ativos no formato desejado para todas as plataformas suportadas e ao armazenamento das metainforma√ß√µes coletadas em uma biblioteca de ativos - √© repetido para cada marca declarada no script de constru√ß√£o. <br><br>  Abaixo est√° uma captura de tela da apar√™ncia da estrutura das pastas <i>src</i> e <i>dist</i> , assim que o processo de compila√ß√£o for conclu√≠do: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br>  <i>Estrutura das pastas "src" e "dist" ap√≥s a conclus√£o do processo de compila√ß√£o.</i> <br><br>  Neste ponto, com um comando simples, √© poss√≠vel fazer o upload de todos os recursos (arquivos JSON, arquivos ZIP e arquivos de ativos) para um reposit√≥rio remoto e disponibiliz√°-los para todas as plataformas, para baixar e consumir em suas bases de c√≥digo. <br><br>  (Como as plataformas reais recuperam e processam os ativos - por meio de scripts personalizados criados ad-hoc para esse fim - est√° al√©m do escopo deste artigo. Mas isso provavelmente ser√° abordado muito em breve em outras postagens de blog dedicadas, por um dos outros desenvolvedores que trabalharam comigo neste projeto). <br><br><h2>  Conclus√µes (e li√ß√µes aprendidas ao longo do caminho) </h2><br>  Eu sempre amei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sketch</a> .  Durante anos, tem sido a ferramenta "de fato" escolhida para o design (e desenvolvimento) de aplicativos e web.  Por isso, fiquei muito interessado e curioso em explorar poss√≠veis integra√ß√µes, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">html-sketchapp</a> ou ferramentas similares, o que poder√≠amos usar em nossos fluxos de trabalho e pipelines. <br><br>  Esse fluxo (ideal) sempre foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">santo graal para mim</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">e muitos outros</a> ): <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  O esbo√ßo como uma ferramenta de design pode ser imaginado como um poss√≠vel "destino" da base de c√≥digo. <br><br>  Mas tenho que admitir que recentemente comecei a me perguntar se o Sketch ainda era a ferramenta certa, especialmente no contexto de um sistema de design.  Ent√£o, comecei a explorar novas ferramentas como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Figma</a> , com suas APIs abertas, e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Framer X</a> , com sua incr√≠vel integra√ß√£o com o React, porque n√£o estava vendo esfor√ßos equivalentes do Sketch para avan√ßar para a integra√ß√£o com o c√≥digo (qualquer que seja o c√≥digo). <br><br>  Bem, este projeto mudou de id√©ia.  N√£o completamente, mas definitivamente muito. <br><br>  Talvez o Sketch n√£o exponha oficialmente suas APIs, mas certamente a maneira pela qual eles constru√≠ram a estrutura interna de seus arquivos √© uma esp√©cie de API "n√£o oficial".  Eles poderiam ter usado nomes enigm√°ticos ou ofuscar as chaves nos objetos JSON;  em vez disso, optaram por uma conven√ß√£o de nomenclatura sem√¢ntica clara, f√°cil de ler, leg√≠vel por humanos.  N√£o acho que isso seja apenas acidental. <br><br>  O fato de os arquivos do Sketch poderem ser manipulados abriu minha mente para uma ampla gama de poss√≠veis desenvolvimentos e melhorias futuros.  Desde plugins para validar a nomea√ß√£o, estilo e estrutura das camadas para os √≠cones, at√© poss√≠veis integra√ß√µes com nosso wiki e nossa documenta√ß√£o do sistema de design (em ambas as dire√ß√µes), atrav√©s da cria√ß√£o de aplicativos Node hospedados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Electron</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Carlo</a> para facilitar muitos dos tarefas repetitivas que os designers precisam realizar. <br><br>  Um b√¥nus inesperado deste projeto (pelo menos para mim) √© que agora os arquivos do Sketch com os "√≠cones do Cosmos" se tornaram uma "fonte de verdade", semelhante ao que aconteceu com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistema de design</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cosmos</a> .  Se um √≠cone n√£o estiver l√°, ele n√£o existe na base de c√≥digo (ou melhor, n√£o deveria existir: mas pelo menos sabemos que √© uma exce√ß√£o).  Eu sei que √© meio √≥bvio agora, mas n√£o era antes, pelo menos para mim. <br><br>  O que come√ßou como um projeto MVP, logo se tornou um mergulho profundo (literalmente) nas partes internas dos arquivos do Sketch, com a constata√ß√£o de que eles podem ser manipulados.  Ainda n√£o sabemos aonde tudo isso levar√°, mas at√© agora tem sido um sucesso.  Designers, desenvolvedores, PMs e partes interessadas concordam que isso economizar√° muito trabalho manual para todos e evitar√° muitos erros em potencial.  Mas tamb√©m abrir√° as portas para os usos dos √≠cones que eram imposs√≠veis at√© agora. <br><br>  Uma √∫ltima coisa: o que descrevi neste longo post √© um pipeline que criamos aqui para resolver <i>nossos</i> problemas espec√≠ficos e, portanto, √© necessariamente super-personalizado para o <i>nosso</i> contexto.  Lembre-se de que pode n√£o atender <i>√†s</i> necessidades da <i>sua</i> empresa ou ser apropriado ao <i>seu</i> contexto. <br><br>  Mas o que √© importante para mim e o que eu queria compartilhar √© que isso pode ser feito.  Talvez de maneiras diferentes, com abordagens diferentes e formatos de sa√≠da diferentes, talvez envolvendo menos complexidade (ou seja, talvez voc√™ n√£o precise da marca m√∫ltipla e do teste AB).  Mas agora voc√™ pode automatizar o fluxo de trabalho envolvido na entrega de seus √≠cones com um script Node.js. personalizado e o Sketch. <br><br>  Encontre sua pr√≥pria maneira de faz√™-lo.  √â divertido (e relativamente f√°cil). <br><br><h2>  Cr√©ditos </h2><br>  Esse grande projeto foi desenvolvido em colabora√ß√£o com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nikhil Verma</a> (Web m√≥vel), que criou a primeira vers√£o do script de compila√ß√£o, e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artem Rudoi</a> (Android) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Igor Savelev</a> (iOS), que desenvolveram os scripts que importam e consomem os ativos em seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sites</a> . respectivas plataformas nativas.  Obrigado pessoal, foi um prazer trabalhar com voc√™ nesse projeto e v√™-lo ganhar vida. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441042/">https://habr.com/ru/post/pt441042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441030/index.html">Detectando ataques da Web com um autoencodificador Seq2Seq</a></li>
<li><a href="../pt441032/index.html">KeeBee Criando seu pr√≥prio teclado USB a partir do zero</a></li>
<li><a href="../pt441034/index.html">6 pontos de crescimento de convers√µes ou como aumentar a confian√ßa usando um telefone no site</a></li>
<li><a href="../pt441036/index.html">Como dar e receber feedback se voc√™ √© pardal-sociophobus</a></li>
<li><a href="../pt441040/index.html">Gerando √≠cones de v√°rias plataformas e com v√°rias marcas com o Sketch e um script Node.js. - Parte # 1</a></li>
<li><a href="../pt441044/index.html">A hist√≥ria de como mudamos o √≠cone do PVS-Studio</a></li>
<li><a href="../pt441046/index.html">A hist√≥ria de como mudamos o √≠cone do PVS-Studio</a></li>
<li><a href="../pt441048/index.html">Escrit√≥rio pr√≥-agressivo</a></li>
<li><a href="../pt441050/index.html">Criando uma c√¢mera t√©rmica DIY baseada em um Raspberry Pi</a></li>
<li><a href="../pt441052/index.html">16 de mar√ßo de Badoo PHP Meetup: testes e qualidade de c√≥digo. O registro est√° aberto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>