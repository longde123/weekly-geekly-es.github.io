<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚖️ 🍙 💛 Sistema de tarefas e caminho de pesquisa 🍣 👨🏿‍🤝‍👨🏻 🆓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mapa 
 Em um artigo anterior, analisei o que é o novo sistema de tarefas, como funciona, como criar tarefas, preenchê-las com dados e executar cálculo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de tarefas e caminho de pesquisa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Mapa </h3><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> analisei o que é o novo <b>sistema de</b> tarefas, como funciona, como criar tarefas, preenchê-las com dados e executar cálculos multiencadeados e apenas expliquei brevemente onde você pode usar esse sistema.  Neste artigo, tentarei analisar um exemplo específico de onde você pode usar esse sistema para obter mais desempenho. <br><a name="habracut"></a><br>  Como o sistema foi originalmente desenvolvido com o objetivo de trabalhar com dados, é ótimo para resolver tarefas de localização de caminhos. <br><br>  <b>O Unity</b> já possui um bom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navegador NavMesh</a> , mas não funciona em projetos 2D, embora existam muitas soluções prontas no mesmo <i>ativo</i> .  Bem, e tentaremos criar não apenas um sistema que procure maneiras no mapa criado, mas tornar esse mapa dinâmico, para que toda vez que algo mude nele, o sistema criará um novo mapa, e tudo isso, é claro, calcularemos usando um novo sistema de tarefas, para não carregar o thread principal. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de operação do sistema</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="imagem"><br></div></div><br>  No exemplo, uma grade é construída no mapa, há um bot e um obstáculo.  A grade é reconstruída toda vez que alteramos quaisquer propriedades do mapa, seja seu tamanho ou posição. <br><br>  Para aviões, usei um <b>SpriteRenderer</b> simples, este componente possui uma excelente propriedade de <b>limites</b> com a qual você pode descobrir facilmente o tamanho do mapa. <br><br>  Isso é basicamente tudo para começar, mas não vamos parar e começar imediatamente aos negócios. <br><br>  Vamos começar com os scripts.  E o primeiro é o script de obstrução de <b>obstáculos</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obstáculo</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Dentro da classe <b>Obstacle</b> , capturaremos todas as alterações nos obstáculos no mapa, por exemplo, alterando a posição ou o tamanho de um objeto. <br>  Em seguida, você pode criar a classe de mapa <b>Map</b> , na qual a grade será construída, e herdá-la da classe <b>Obstacle</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  A classe <b>Map</b> também rastreará todas as alterações no mapa para reconstruir a grade, se necessário. <br><br>  Para fazer isso, preencha a classe base <b>Obstacle</b> com todas as variáveis ​​e métodos necessários para controlar as alterações no objeto. <br><br><div class="spoiler">  <b class="spoiler_title">Obstáculo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Aqui, a variável <b>renderer</b> terá uma referência ao componente <b>SpriteRenderer</b> , e as <b>variáveis ​​tempSize</b> e <b>tempPos</b> serão usadas para rastrear alterações no tamanho e na posição do objeto. <br><br>  O método virtual <b>Awake</b> será usado para inicializar as variáveis, e o método virtual <b>CheckChanges</b> rastreará as alterações atuais no tamanho e posição do objeto e retornará um resultado <b>booleano</b> . <br><br>  Por enquanto, vamos deixar o script <b>Obstacle</b> e seguir para o script <b>Map</b> map, onde também o preenchemos com os parâmetros necessários para o trabalho. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  A variável <b>nodeSize</b> indicará o tamanho das células no mapa. <b>Limitei</b> seu tamanho de 0,1 a 1 para que as células na grade não sejam muito pequenas, mas também muito grandes.  A variável de <b>deslocamento</b> será usada para recuar o mapa ao construir a grade, para que a grade não seja construída ao longo das bordas do mapa. <br><br>  Como agora existem duas novas variáveis ​​no mapa, verifica-se que suas alterações também precisarão ser rastreadas.  Para fazer isso, adicione algumas variáveis ​​e sobrecarregue o método <b>CheckChanges</b> na classe <b>Map</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Feito.  Agora você pode criar um sprite de mapa no palco e lançar um script de <b>mapa</b> nele. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="imagem"><br><br>  Faremos o mesmo com um obstáculo - crie um sprite simples no palco e jogue o script <b>Obstacle</b> nele. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="imagem"><br><br>  Agora, temos objetos de mapa e obstáculos no palco. <br><br>  O script <b>Map</b> será responsável por rastrear todas as alterações no mapa, onde, no método <b>Update</b> , verificaremos cada quadro quanto às alterações. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Portanto, no método <b>UpdateChanges, o</b> mapa rastreará apenas suas alterações até o momento.  Você pode até iniciar o jogo agora e tentar alterar o tamanho do mapa ou <b>compensar o deslocamento</b> para garantir que todas as alterações sejam rastreadas. <br><br>  Agora você precisa acompanhar de alguma forma as mudanças dos obstáculos no mapa.  Para fazer isso, colocaremos cada obstáculo em uma lista no mapa, que por sua vez atualizará cada quadro no método <b>Update</b> . <br><br>  Na classe <b>Mapa</b> , crie uma lista de todos os obstáculos possíveis no mapa e alguns métodos estáticos para registrá-los. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  No método estático <b>RegisterObstacle</b> , registraremos um novo obstáculo no mapa e o adicionaremos à lista, mas, antes de tudo, é importante considerar que o próprio mapa também é herdado da classe <b>Obstacle</b> e, portanto, devemos verificar se estamos tentando registrar o cartão como um obstáculo. <br><br>  O método estático <b>UnregisterObstacle</b> , pelo contrário, elimina o obstáculo do mapa e o remove da lista quando permitimos que ele seja destruído. <br><br>  Ao mesmo tempo, toda vez que adicionamos ou removemos um obstáculo do mapa, é necessário recriar o mapa em si; portanto, após a execução desses métodos estáticos, defina a variável <b>requireRebuild</b> como <b>true</b> . <br><br>  Além disso, para ter acesso fácil ao script <b>Map a</b> partir de qualquer script, criei uma propriedade <b>Instance</b> estática que retornará para mim essa mesma instância do <b>Map</b> . <br><br>  Agora, voltemos ao script <b>Obstacle,</b> onde registraremos um obstáculo no <b>mapa.Para</b> fazer isso, adicione alguns métodos <b>OnEnable</b> e <b>OnDisable</b> a ele. <br><br><div class="spoiler">  <b class="spoiler_title">Obstáculo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Cada vez que criamos um novo obstáculo enquanto jogamos no mapa, ele será registrado automaticamente no método <b>OnEnable</b> , onde será levado em consideração ao criar uma nova grade e nos removeremos do mapa no método <b>OnDisable</b> quando ele for destruído ou desativado. <br><br>  Resta apenas rastrear as alterações dos obstáculos no script <b>Map</b> no método <b>CheckChanges</b> sobrecarregado. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Agora temos um mapa, obstáculos - em geral, tudo o que você precisa para construir uma grade e agora pode passar para a coisa mais importante. <br><br><h4>  Malha </h4><br>  A grade, em sua forma mais simples, é uma matriz bidimensional de pontos.  Para construí-lo, você precisa conhecer o tamanho do mapa e o tamanho dos pontos, depois de alguns cálculos, obtemos o número de pontos horizontal e verticalmente, esta é a nossa grade. <br><br>  Existem muitas maneiras de encontrar um caminho em uma grade.  Neste artigo, no entanto, o principal é entender como usar corretamente os recursos do sistema de tarefas; portanto, não considerarei opções diferentes para encontrar o caminho, suas vantagens e desvantagens, mas utilizarei a opção de pesquisa mais simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A *</a> . <br><br>  Nesse caso, todos os pontos na grade devem ter, além da posição, as coordenadas e a propriedade de permeabilidade. <br><br>  Com permeabilidade, acho que tudo fica claro por que é necessário, mas as coordenadas indicam a ordem do ponto na grade, essas coordenadas não estão ligadas especificamente à posição do ponto no espaço.  A imagem abaixo mostra uma grade simples, mostrando as diferenças de coordenadas de uma posição. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="imagem"><br>  <i>Por que as coordenadas?</i> <br>  O fato é que, em unidade, para indicar a posição de um objeto no espaço, <b>é usado</b> um <b>flutuador</b> simples que é muito impreciso e pode ser um número fracionário ou negativo; portanto, será difícil usá-lo para implementar uma pesquisa de caminho no mapa.  As coordenadas são feitas na forma de um <b>int</b> claro, que sempre será positivo e com o qual é muito mais fácil trabalhar ao procurar pontos vizinhos. <br><br>  Primeiro, vamos definir um objeto de ponto, essa será uma estrutura de <b>nó</b> simples. <br><br><div class="spoiler">  <b class="spoiler_title">Nó</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Essa estrutura conterá a posição <b>position</b> na forma de <b>Vector2</b> , onde, com essa variável, desenharemos um ponto no espaço.  A <b>variável de</b> coordenadas de <b>coords</b> na forma de <b>Vector2Int</b> indicará as coordenadas de um ponto no mapa, e a variável <b>id</b> , seu número numérico de conta, usando-o, compararemos diferentes pontos na grade e verificaremos a existência de um ponto. <br><br>  A perviedade do ponto será indicada na forma de sua propriedade <b>booleana</b> , mas como não podemos usar os <i>tipos de</i> dados <i>conversíveis</i> no sistema de tarefas, indicaremos sua perviedade na forma de um número <b>int</b> , para isso usei uma enumeração simples <b>NodeType</b> , em que: 0 não é um ponto passável, e 1 é aceitável. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType e Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Além disso, para facilitar o trabalho com um ponto, sobrecarregarei o método <b>Equals</b> para facilitar a comparação de pontos e também complementarei o método de verificação para a existência de um ponto. <br><br><div class="spoiler">  <b class="spoiler_title">Nó</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Como o número de <b>identificação</b> do ponto na grade começará com 1 unidade, vou verificar a existência do ponto como uma condição para que sua <b>identificação seja</b> maior que 0. <br><br>  Vá para a classe <b>Map,</b> onde prepararemos tudo para criar um mapa. <br>  Já temos uma verificação para alterar os parâmetros do mapa, agora precisamos determinar como o processo de construção da grade será realizado.  Para fazer isso, crie uma nova variável e vários métodos. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  A propriedade <b>reconstruir</b> indicará se o processo de <b>malha</b> está em andamento.  O método <b>Rebuild</b> coletará dados e tarefas para a construção da grade, o método <b>OnRebuildStart</b> iniciará o processo de criação da grade e o método <b>OnRebuildFinish</b> coletará dados das tarefas. <br><br>  Agora vamos mudar um <b>pouco</b> o método <b>UpdateChanges</b> para que a condição da grade seja levada em consideração. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> }</code> </pre> <br></div></div><br>  Como você pode ver agora no método <b>UpdateChanges</b> , <b>há</b> uma condição de que, enquanto a construção da malha antiga não está começando a começar a construir uma nova, e também no método <b>Reconstruir</b> , a primeira ação verifica se o processo de malha já está em andamento. <br><br><h4>  Resolução de problemas </h4><br>  Agora um pouco sobre o processo de construção de um mapa. <br>  Como usaremos o sistema de tarefas e construiremos a grade em paralelo para construir o mapa, usei o tipo da tarefa <b>IJobParallelFor</b> , que será executada um certo número de vezes.  Para não carregar o processo de construção com nenhuma tarefa separada, usaremos o conjunto de tarefas agrupadas em um <b>JobHandle</b> . <br><br>  Na maioria das vezes, para construir uma grade, use dois ciclos aninhados um ao outro para criar, por exemplo, horizontal e verticalmente.  Neste exemplo, também construiremos a grade horizontalmente e depois verticalmente.  Para fazer isso, calculamos o número de pontos horizontais e verticais no método <b>Rebuild</b> , depois no método <b>Rebuild</b> percorremos o ciclo ao longo dos pontos verticais e vamos construir pontos horizontais em paralelo na tarefa.  Para imaginar melhor o processo de criação, dê uma olhada na animação abaixo. <br><br><div class="spoiler">  <b class="spoiler_title">Malha</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="imagem"><br></div></div><br>  O número de pontos verticais indicará o número de tarefas, por sua vez, cada tarefa criará pontos apenas horizontalmente, após a conclusão de todas as tarefas, os pontos serão somados em uma lista.  É por isso que preciso usar uma tarefa como <b>IJobParallelFor</b> para passar o índice do ponto na grade horizontalmente para o método <b>Execute</b> . <br><br>  E, como temos a estrutura de pontos, agora você pode criar a estrutura da tarefa <b>Job</b> e herdá-la da interface <b>IJobParallelFor</b> , tudo é simples aqui. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Retornamos ao método <b>Rebuild da</b> classe <b>Map</b> , onde faremos os cálculos necessários para a medição da grade. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(“ !”); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  No método <b>Rebuild</b> , calculamos o tamanho exato do mapa <b>mapSize</b> , levando em consideração o recuo e, nas <b>verticais</b> , escrevemos o número de pontos verticalmente, e nas <b>horizontais o</b> número de pontos horizontalmente.  Se o número de pontos verticais for 0, paramos de construir o mapa e chamamos o método <b>OnRebuildFinish</b> para concluir o processo.  A variável de <b>origem</b> indicará o local de onde começaremos a construir a grade - no exemplo, este é o ponto inferior esquerdo no mapa. <br><br>  Agora você pode ir para as tarefas e preenchê-las com dados. <br>  Durante a construção da grade, a tarefa precisará de uma matriz <b>NativeArray</b> onde colocaremos os pontos, também porque temos obstáculos no mapa, também precisaremos passá-los para a tarefa, para isso usaremos outra matriz <b>NativeArray e</b> , em seguida, precisaremos do tamanho dos pontos no problema , a posição inicial de onde iremos construir os pontos, bem como as coordenadas iniciais da série. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  <b>Marquei</b> a matriz de pontos com o atributo <b>WriteOnly,</b> pois na tarefa será necessário " <i>gravar</i> " os pontos recebidos na matriz, pelo contrário, a matriz de <b>limites</b> de obstáculos <b>é</b> marcada com o atributo <b>ReadOnly,</b> pois na tarefa apenas " <i>leremos</i> " dados dessa matriz. <br><br>  Bem, por enquanto, vamos prosseguir com o cálculo dos pontos depois. <br><br>  Agora, de volta à classe <b>Map</b> , onde denotamos todas as variáveis ​​envolvidas nas tarefas. <br>  Aqui, primeiro, precisamos de um <b>identificador</b> global <b>de</b> tarefas, uma série de obstáculos na forma de <b>NativeArray</b> , uma lista de tarefas que conterá todos os pontos recebidos na grade e <b>Dicionário</b> com todas as coordenadas e pontos no mapa, para que seja mais conveniente procurá-las mais tarde. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Agora, novamente, retornamos ao método <b>Rebuild</b> e continuamos a construir a grade. <br>  Primeiro, inicialize o conjunto de obstáculos dos <b>limites</b> para passá-lo à tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Aqui, criamos uma instância do <b>NativeArray</b> por meio de um novo construtor com três parâmetros.  Examinei os dois primeiros parâmetros em um artigo anterior, mas o terceiro parâmetro nos ajudará a economizar um pouco de tempo criando uma matriz.  O fato é que gravaremos dados na matriz imediatamente após sua criação, o que significa que não precisamos garantir que eles sejam limpos.  Este parâmetro é útil para <b>NativeArray,</b> que será usado apenas no modo de <i>leitura</i> na tarefa. <br><br>  E assim, então preenchemos a matriz de <b>limites</b> com dados. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Agora podemos começar a criar tarefas, para isso, percorreremos um ciclo por todas as linhas verticais da grade. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Para começar, em <b>xPos</b> e <b>yPos</b> , obtemos a posição horizontal inicial da série. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Em seguida, criamos um <b>NativeArray</b> simples onde os pontos da tarefa serão colocados, aqui para a <b>matriz,</b> você precisa especificar quantos pontos serão criados horizontalmente e o tipo de alocação <b>Persistente</b> , porque a tarefa pode demorar mais de um quadro. <br>  Depois disso, crie a própria instância da tarefa <b>Job</b> , coloque as coordenadas iniciais da série <b>startCoords</b> , a posição inicial da série <b>startPos</b> , o tamanho dos pontos <b>nodeSize</b> , a matriz de obstáculos de <b>limites</b> e a própria matriz de pontos no final. <br>  Resta apenas colocar a tarefa em <b>controle</b> e a lista de tarefas global. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Feito.  Temos uma lista de tarefas e seu <b>identificador</b> comum, agora podemos executá-lo chamando seu método <b>Complete</b> no método <b>OnRebuildStart</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Como a variável de <b>reconstrução</b> indicará que o processo de <b>malha</b> está em andamento, o <b>próprio</b> método <b>UpdateChanges</b> também deve especificar a condição em que esse processo terminará usando o <b>identificador</b> e sua propriedade <b>IsCompleted</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Atualizações</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(“  ...”); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(“  ,   !”); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Depois de concluir as tarefas, o método <b>OnRebuildFinish</b> será chamado onde já coletamos os pontos recebidos em uma lista geral do <b>Dicionário</b> e, o mais importante, para limpar os recursos ocupados. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, limpamos o dicionário de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos pontos anteriores, depois usamos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop foreach para</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classificar todos os pontos que recebemos das tarefas e os colocamos no dicionário de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde a chave são as coordenadas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NÃO a posição</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Do ponto e o valor é o próprio ponto. </font><font style="vertical-align: inherit;">Com a ajuda deste dicionário, será mais fácil procurar pontos vizinhos no mapa. </font><font style="vertical-align: inherit;">Após o preenchimento, limpamos a matriz do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando o método </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, no final, limpamos a própria lista de tarefas dos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também precisará limpar os </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limites</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos obstáculos </font><font style="vertical-align: inherit;">se ele tiver sido criado anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de todas essas ações, obtemos uma lista de todos os pontos no mapa e agora você pode desenhá-los no palco.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo assim</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, na classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">crie o método </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onde desenharemos os pontos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, através do loop, desenhamos cada ponto. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de todas essas ações, nosso mapa parece um pouco chato, para realmente obter uma grade, você precisa que os pontos sejam conectados um ao outro. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malha</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para procurar pontos vizinhos, basta encontrar o ponto desejado por suas coordenadas em 8 direções; portanto, na classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">criaremos uma matriz estática simples de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direções</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">Direções</font></b><font style="vertical-align: inherit;"> e o método de pesquisa de células por suas coordenadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... …*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O método </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornará um ponto por coordenadas da lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nós</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas você precisa fazer isso com cuidado, porque se as coordenadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiverem incorretas, ocorrerá um erro; portanto, aqui usamos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloco try catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exception </font><font style="vertical-align: inherit;">, que ajudará a ignorar a exceção e não " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travará</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " o aplicativo inteiro com um erro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, percorreremos um ciclo em todas as direções e tentaremos encontrar pontos vizinhos no método </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, o mais importante, não se esqueça de considerar a permeabilidade do ponto.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora você pode iniciar o jogo com segurança e ver o que aconteceu. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa dinâmico</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, construímos apenas o próprio gráfico usando tarefas, mas foi o que aconteceu depois que eu parafusei no sistema o próprio algoritmo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que também usa o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema Job</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar o caminho, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonte no final do artigo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa de mapa e caminho</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, você pode usar o novo sistema de tarefas para seus objetivos e criar sistemas interessantes sem muito esforço. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no artigo anterior, o sistema de tarefas é usado sem o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas se você usar esse sistema em conjunto com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , poderá obter resultados simplesmente surpreendentes nos ganhos de desempenho. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boa sorte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Origem do Projeto Path Finder</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423601/">https://habr.com/ru/post/pt423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423589/index.html">Como escolhemos o TTS, por exemplo, sons no dicionário</a></li>
<li><a href="../pt423591/index.html">Músicas antigas sobre o principal. Java e solicitações de saída</a></li>
<li><a href="../pt423593/index.html">Google anuncia concurso para ataques a algoritmos de visão de máquina</a></li>
<li><a href="../pt423595/index.html">Anomalia de Frango, Intercâmbio</a></li>
<li><a href="../pt423597/index.html">Como e quais clusters podem ser alocados na base de clientes</a></li>
<li><a href="../pt423603/index.html">RxSwift parte 1</a></li>
<li><a href="../pt423607/index.html">Linus Torvalds desiste de estilo difícil e tira um tempo</a></li>
<li><a href="../pt423609/index.html">Para onde vão os sites após a morte? Experiência pessoal</a></li>
<li><a href="../pt423611/index.html">Pagamento com um clique - bom ou mau?</a></li>
<li><a href="../pt423615/index.html">Habilidades profissionais exigidas entre especialistas em UX (fatia 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>