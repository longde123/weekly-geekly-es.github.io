<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öñÔ∏è üçô üíõ Sistema de tarefas e caminho de pesquisa üç£ üë®üèø‚Äçü§ù‚Äçüë®üèª üÜì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mapa 
 Em um artigo anterior, analisei o que √© o novo sistema de tarefas, como funciona, como criar tarefas, preench√™-las com dados e executar c√°lculo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de tarefas e caminho de pesquisa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  Mapa </h3><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> analisei o que √© o novo <b>sistema de</b> tarefas, como funciona, como criar tarefas, preench√™-las com dados e executar c√°lculos multiencadeados e apenas expliquei brevemente onde voc√™ pode usar esse sistema.  Neste artigo, tentarei analisar um exemplo espec√≠fico de onde voc√™ pode usar esse sistema para obter mais desempenho. <br><a name="habracut"></a><br>  Como o sistema foi originalmente desenvolvido com o objetivo de trabalhar com dados, √© √≥timo para resolver tarefas de localiza√ß√£o de caminhos. <br><br>  <b>O Unity</b> j√° possui um bom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navegador NavMesh</a> , mas n√£o funciona em projetos 2D, embora existam muitas solu√ß√µes prontas no mesmo <i>ativo</i> .  Bem, e tentaremos criar n√£o apenas um sistema que procure maneiras no mapa criado, mas tornar esse mapa din√¢mico, para que toda vez que algo mude nele, o sistema criar√° um novo mapa, e tudo isso, √© claro, calcularemos usando um novo sistema de tarefas, para n√£o carregar o thread principal. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de opera√ß√£o do sistema</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="imagem"><br></div></div><br>  No exemplo, uma grade √© constru√≠da no mapa, h√° um bot e um obst√°culo.  A grade √© reconstru√≠da toda vez que alteramos quaisquer propriedades do mapa, seja seu tamanho ou posi√ß√£o. <br><br>  Para avi√µes, usei um <b>SpriteRenderer</b> simples, este componente possui uma excelente propriedade de <b>limites</b> com a qual voc√™ pode descobrir facilmente o tamanho do mapa. <br><br>  Isso √© basicamente tudo para come√ßar, mas n√£o vamos parar e come√ßar imediatamente aos neg√≥cios. <br><br>  Vamos come√ßar com os scripts.  E o primeiro √© o script de obstru√ß√£o de <b>obst√°culos</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  Dentro da classe <b>Obstacle</b> , capturaremos todas as altera√ß√µes nos obst√°culos no mapa, por exemplo, alterando a posi√ß√£o ou o tamanho de um objeto. <br>  Em seguida, voc√™ pode criar a classe de mapa <b>Map</b> , na qual a grade ser√° constru√≠da, e herd√°-la da classe <b>Obstacle</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  A classe <b>Map</b> tamb√©m rastrear√° todas as altera√ß√µes no mapa para reconstruir a grade, se necess√°rio. <br><br>  Para fazer isso, preencha a classe base <b>Obstacle</b> com todas as vari√°veis ‚Äã‚Äãe m√©todos necess√°rios para controlar as altera√ß√µes no objeto. <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Aqui, a vari√°vel <b>renderer</b> ter√° uma refer√™ncia ao componente <b>SpriteRenderer</b> , e as <b>vari√°veis ‚Äã‚ÄãtempSize</b> e <b>tempPos</b> ser√£o usadas para rastrear altera√ß√µes no tamanho e na posi√ß√£o do objeto. <br><br>  O m√©todo virtual <b>Awake</b> ser√° usado para inicializar as vari√°veis, e o m√©todo virtual <b>CheckChanges</b> rastrear√° as altera√ß√µes atuais no tamanho e posi√ß√£o do objeto e retornar√° um resultado <b>booleano</b> . <br><br>  Por enquanto, vamos deixar o script <b>Obstacle</b> e seguir para o script <b>Map</b> map, onde tamb√©m o preenchemos com os par√¢metros necess√°rios para o trabalho. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  A vari√°vel <b>nodeSize</b> indicar√° o tamanho das c√©lulas no mapa. <b>Limitei</b> seu tamanho de 0,1 a 1 para que as c√©lulas na grade n√£o sejam muito pequenas, mas tamb√©m muito grandes.  A vari√°vel de <b>deslocamento</b> ser√° usada para recuar o mapa ao construir a grade, para que a grade n√£o seja constru√≠da ao longo das bordas do mapa. <br><br>  Como agora existem duas novas vari√°veis ‚Äã‚Äãno mapa, verifica-se que suas altera√ß√µes tamb√©m precisar√£o ser rastreadas.  Para fazer isso, adicione algumas vari√°veis ‚Äã‚Äãe sobrecarregue o m√©todo <b>CheckChanges</b> na classe <b>Map</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  Feito.  Agora voc√™ pode criar um sprite de mapa no palco e lan√ßar um script de <b>mapa</b> nele. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="imagem"><br><br>  Faremos o mesmo com um obst√°culo - crie um sprite simples no palco e jogue o script <b>Obstacle</b> nele. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="imagem"><br><br>  Agora, temos objetos de mapa e obst√°culos no palco. <br><br>  O script <b>Map</b> ser√° respons√°vel por rastrear todas as altera√ß√µes no mapa, onde, no m√©todo <b>Update</b> , verificaremos cada quadro quanto √†s altera√ß√µes. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Portanto, no m√©todo <b>UpdateChanges, o</b> mapa rastrear√° apenas suas altera√ß√µes at√© o momento.  Voc√™ pode at√© iniciar o jogo agora e tentar alterar o tamanho do mapa ou <b>compensar o deslocamento</b> para garantir que todas as altera√ß√µes sejam rastreadas. <br><br>  Agora voc√™ precisa acompanhar de alguma forma as mudan√ßas dos obst√°culos no mapa.  Para fazer isso, colocaremos cada obst√°culo em uma lista no mapa, que por sua vez atualizar√° cada quadro no m√©todo <b>Update</b> . <br><br>  Na classe <b>Mapa</b> , crie uma lista de todos os obst√°culos poss√≠veis no mapa e alguns m√©todos est√°ticos para registr√°-los. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  No m√©todo est√°tico <b>RegisterObstacle</b> , registraremos um novo obst√°culo no mapa e o adicionaremos √† lista, mas, antes de tudo, √© importante considerar que o pr√≥prio mapa tamb√©m √© herdado da classe <b>Obstacle</b> e, portanto, devemos verificar se estamos tentando registrar o cart√£o como um obst√°culo. <br><br>  O m√©todo est√°tico <b>UnregisterObstacle</b> , pelo contr√°rio, elimina o obst√°culo do mapa e o remove da lista quando permitimos que ele seja destru√≠do. <br><br>  Ao mesmo tempo, toda vez que adicionamos ou removemos um obst√°culo do mapa, √© necess√°rio recriar o mapa em si; portanto, ap√≥s a execu√ß√£o desses m√©todos est√°ticos, defina a vari√°vel <b>requireRebuild</b> como <b>true</b> . <br><br>  Al√©m disso, para ter acesso f√°cil ao script <b>Map a</b> partir de qualquer script, criei uma propriedade <b>Instance</b> est√°tica que retornar√° para mim essa mesma inst√¢ncia do <b>Map</b> . <br><br>  Agora, voltemos ao script <b>Obstacle,</b> onde registraremos um obst√°culo no <b>mapa.Para</b> fazer isso, adicione alguns m√©todos <b>OnEnable</b> e <b>OnDisable</b> a ele. <br><br><div class="spoiler">  <b class="spoiler_title">Obst√°culo</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Cada vez que criamos um novo obst√°culo enquanto jogamos no mapa, ele ser√° registrado automaticamente no m√©todo <b>OnEnable</b> , onde ser√° levado em considera√ß√£o ao criar uma nova grade e nos removeremos do mapa no m√©todo <b>OnDisable</b> quando ele for destru√≠do ou desativado. <br><br>  Resta apenas rastrear as altera√ß√µes dos obst√°culos no script <b>Map</b> no m√©todo <b>CheckChanges</b> sobrecarregado. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Agora temos um mapa, obst√°culos - em geral, tudo o que voc√™ precisa para construir uma grade e agora pode passar para a coisa mais importante. <br><br><h4>  Malha </h4><br>  A grade, em sua forma mais simples, √© uma matriz bidimensional de pontos.  Para constru√≠-lo, voc√™ precisa conhecer o tamanho do mapa e o tamanho dos pontos, depois de alguns c√°lculos, obtemos o n√∫mero de pontos horizontal e verticalmente, esta √© a nossa grade. <br><br>  Existem muitas maneiras de encontrar um caminho em uma grade.  Neste artigo, no entanto, o principal √© entender como usar corretamente os recursos do sistema de tarefas; portanto, n√£o considerarei op√ß√µes diferentes para encontrar o caminho, suas vantagens e desvantagens, mas utilizarei a op√ß√£o de pesquisa mais simples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A *</a> . <br><br>  Nesse caso, todos os pontos na grade devem ter, al√©m da posi√ß√£o, as coordenadas e a propriedade de permeabilidade. <br><br>  Com permeabilidade, acho que tudo fica claro por que √© necess√°rio, mas as coordenadas indicam a ordem do ponto na grade, essas coordenadas n√£o est√£o ligadas especificamente √† posi√ß√£o do ponto no espa√ßo.  A imagem abaixo mostra uma grade simples, mostrando as diferen√ßas de coordenadas de uma posi√ß√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="imagem"><br>  <i>Por que as coordenadas?</i> <br>  O fato √© que, em unidade, para indicar a posi√ß√£o de um objeto no espa√ßo, <b>√© usado</b> um <b>flutuador</b> simples que √© muito impreciso e pode ser um n√∫mero fracion√°rio ou negativo; portanto, ser√° dif√≠cil us√°-lo para implementar uma pesquisa de caminho no mapa.  As coordenadas s√£o feitas na forma de um <b>int</b> claro, que sempre ser√° positivo e com o qual √© muito mais f√°cil trabalhar ao procurar pontos vizinhos. <br><br>  Primeiro, vamos definir um objeto de ponto, essa ser√° uma estrutura de <b>n√≥</b> simples. <br><br><div class="spoiler">  <b class="spoiler_title">N√≥</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Essa estrutura conter√° a posi√ß√£o <b>position</b> na forma de <b>Vector2</b> , onde, com essa vari√°vel, desenharemos um ponto no espa√ßo.  A <b>vari√°vel de</b> coordenadas de <b>coords</b> na forma de <b>Vector2Int</b> indicar√° as coordenadas de um ponto no mapa, e a vari√°vel <b>id</b> , seu n√∫mero num√©rico de conta, usando-o, compararemos diferentes pontos na grade e verificaremos a exist√™ncia de um ponto. <br><br>  A perviedade do ponto ser√° indicada na forma de sua propriedade <b>booleana</b> , mas como n√£o podemos usar os <i>tipos de</i> dados <i>convers√≠veis</i> no sistema de tarefas, indicaremos sua perviedade na forma de um n√∫mero <b>int</b> , para isso usei uma enumera√ß√£o simples <b>NodeType</b> , em que: 0 n√£o √© um ponto pass√°vel, e 1 √© aceit√°vel. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType e Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  Al√©m disso, para facilitar o trabalho com um ponto, sobrecarregarei o m√©todo <b>Equals</b> para facilitar a compara√ß√£o de pontos e tamb√©m complementarei o m√©todo de verifica√ß√£o para a exist√™ncia de um ponto. <br><br><div class="spoiler">  <b class="spoiler_title">N√≥</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  Como o n√∫mero de <b>identifica√ß√£o</b> do ponto na grade come√ßar√° com 1 unidade, vou verificar a exist√™ncia do ponto como uma condi√ß√£o para que sua <b>identifica√ß√£o seja</b> maior que 0. <br><br>  V√° para a classe <b>Map,</b> onde prepararemos tudo para criar um mapa. <br>  J√° temos uma verifica√ß√£o para alterar os par√¢metros do mapa, agora precisamos determinar como o processo de constru√ß√£o da grade ser√° realizado.  Para fazer isso, crie uma nova vari√°vel e v√°rios m√©todos. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  A propriedade <b>reconstruir</b> indicar√° se o processo de <b>malha</b> est√° em andamento.  O m√©todo <b>Rebuild</b> coletar√° dados e tarefas para a constru√ß√£o da grade, o m√©todo <b>OnRebuildStart</b> iniciar√° o processo de cria√ß√£o da grade e o m√©todo <b>OnRebuildFinish</b> coletar√° dados das tarefas. <br><br>  Agora vamos mudar um <b>pouco</b> o m√©todo <b>UpdateChanges</b> para que a condi√ß√£o da grade seja levada em considera√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Como voc√™ pode ver agora no m√©todo <b>UpdateChanges</b> , <b>h√°</b> uma condi√ß√£o de que, enquanto a constru√ß√£o da malha antiga n√£o est√° come√ßando a come√ßar a construir uma nova, e tamb√©m no m√©todo <b>Reconstruir</b> , a primeira a√ß√£o verifica se o processo de malha j√° est√° em andamento. <br><br><h4>  Resolu√ß√£o de problemas </h4><br>  Agora um pouco sobre o processo de constru√ß√£o de um mapa. <br>  Como usaremos o sistema de tarefas e construiremos a grade em paralelo para construir o mapa, usei o tipo da tarefa <b>IJobParallelFor</b> , que ser√° executada um certo n√∫mero de vezes.  Para n√£o carregar o processo de constru√ß√£o com nenhuma tarefa separada, usaremos o conjunto de tarefas agrupadas em um <b>JobHandle</b> . <br><br>  Na maioria das vezes, para construir uma grade, use dois ciclos aninhados um ao outro para criar, por exemplo, horizontal e verticalmente.  Neste exemplo, tamb√©m construiremos a grade horizontalmente e depois verticalmente.  Para fazer isso, calculamos o n√∫mero de pontos horizontais e verticais no m√©todo <b>Rebuild</b> , depois no m√©todo <b>Rebuild</b> percorremos o ciclo ao longo dos pontos verticais e vamos construir pontos horizontais em paralelo na tarefa.  Para imaginar melhor o processo de cria√ß√£o, d√™ uma olhada na anima√ß√£o abaixo. <br><br><div class="spoiler">  <b class="spoiler_title">Malha</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="imagem"><br></div></div><br>  O n√∫mero de pontos verticais indicar√° o n√∫mero de tarefas, por sua vez, cada tarefa criar√° pontos apenas horizontalmente, ap√≥s a conclus√£o de todas as tarefas, os pontos ser√£o somados em uma lista.  √â por isso que preciso usar uma tarefa como <b>IJobParallelFor</b> para passar o √≠ndice do ponto na grade horizontalmente para o m√©todo <b>Execute</b> . <br><br>  E, como temos a estrutura de pontos, agora voc√™ pode criar a estrutura da tarefa <b>Job</b> e herd√°-la da interface <b>IJobParallelFor</b> , tudo √© simples aqui. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Retornamos ao m√©todo <b>Rebuild da</b> classe <b>Map</b> , onde faremos os c√°lculos necess√°rios para a medi√ß√£o da grade. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  No m√©todo <b>Rebuild</b> , calculamos o tamanho exato do mapa <b>mapSize</b> , levando em considera√ß√£o o recuo e, nas <b>verticais</b> , escrevemos o n√∫mero de pontos verticalmente, e nas <b>horizontais o</b> n√∫mero de pontos horizontalmente.  Se o n√∫mero de pontos verticais for 0, paramos de construir o mapa e chamamos o m√©todo <b>OnRebuildFinish</b> para concluir o processo.  A vari√°vel de <b>origem</b> indicar√° o local de onde come√ßaremos a construir a grade - no exemplo, este √© o ponto inferior esquerdo no mapa. <br><br>  Agora voc√™ pode ir para as tarefas e preench√™-las com dados. <br>  Durante a constru√ß√£o da grade, a tarefa precisar√° de uma matriz <b>NativeArray</b> onde colocaremos os pontos, tamb√©m porque temos obst√°culos no mapa, tamb√©m precisaremos pass√°-los para a tarefa, para isso usaremos outra matriz <b>NativeArray e</b> , em seguida, precisaremos do tamanho dos pontos no problema , a posi√ß√£o inicial de onde iremos construir os pontos, bem como as coordenadas iniciais da s√©rie. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  <b>Marquei</b> a matriz de pontos com o atributo <b>WriteOnly,</b> pois na tarefa ser√° necess√°rio " <i>gravar</i> " os pontos recebidos na matriz, pelo contr√°rio, a matriz de <b>limites</b> de obst√°culos <b>√©</b> marcada com o atributo <b>ReadOnly,</b> pois na tarefa apenas " <i>leremos</i> " dados dessa matriz. <br><br>  Bem, por enquanto, vamos prosseguir com o c√°lculo dos pontos depois. <br><br>  Agora, de volta √† classe <b>Map</b> , onde denotamos todas as vari√°veis ‚Äã‚Äãenvolvidas nas tarefas. <br>  Aqui, primeiro, precisamos de um <b>identificador</b> global <b>de</b> tarefas, uma s√©rie de obst√°culos na forma de <b>NativeArray</b> , uma lista de tarefas que conter√° todos os pontos recebidos na grade e <b>Dicion√°rio</b> com todas as coordenadas e pontos no mapa, para que seja mais conveniente procur√°-las mais tarde. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Agora, novamente, retornamos ao m√©todo <b>Rebuild</b> e continuamos a construir a grade. <br>  Primeiro, inicialize o conjunto de obst√°culos dos <b>limites</b> para pass√°-lo √† tarefa. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Aqui, criamos uma inst√¢ncia do <b>NativeArray</b> por meio de um novo construtor com tr√™s par√¢metros.  Examinei os dois primeiros par√¢metros em um artigo anterior, mas o terceiro par√¢metro nos ajudar√° a economizar um pouco de tempo criando uma matriz.  O fato √© que gravaremos dados na matriz imediatamente ap√≥s sua cria√ß√£o, o que significa que n√£o precisamos garantir que eles sejam limpos.  Este par√¢metro √© √∫til para <b>NativeArray,</b> que ser√° usado apenas no modo de <i>leitura</i> na tarefa. <br><br>  E assim, ent√£o preenchemos a matriz de <b>limites</b> com dados. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Agora podemos come√ßar a criar tarefas, para isso, percorreremos um ciclo por todas as linhas verticais da grade. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Para come√ßar, em <b>xPos</b> e <b>yPos</b> , obtemos a posi√ß√£o horizontal inicial da s√©rie. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Em seguida, criamos um <b>NativeArray</b> simples onde os pontos da tarefa ser√£o colocados, aqui para a <b>matriz,</b> voc√™ precisa especificar quantos pontos ser√£o criados horizontalmente e o tipo de aloca√ß√£o <b>Persistente</b> , porque a tarefa pode demorar mais de um quadro. <br>  Depois disso, crie a pr√≥pria inst√¢ncia da tarefa <b>Job</b> , coloque as coordenadas iniciais da s√©rie <b>startCoords</b> , a posi√ß√£o inicial da s√©rie <b>startPos</b> , o tamanho dos pontos <b>nodeSize</b> , a matriz de obst√°culos de <b>limites</b> e a pr√≥pria matriz de pontos no final. <br>  Resta apenas colocar a tarefa em <b>controle</b> e a lista de tarefas global. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruir</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Feito.  Temos uma lista de tarefas e seu <b>identificador</b> comum, agora podemos execut√°-lo chamando seu m√©todo <b>Complete</b> no m√©todo <b>OnRebuildStart</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  Como a vari√°vel de <b>reconstru√ß√£o</b> indicar√° que o processo de <b>malha</b> est√° em andamento, o <b>pr√≥prio</b> m√©todo <b>UpdateChanges</b> tamb√©m deve especificar a condi√ß√£o em que esse processo terminar√° usando o <b>identificador</b> e sua propriedade <b>IsCompleted</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Atualiza√ß√µes</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Depois de concluir as tarefas, o m√©todo <b>OnRebuildFinish</b> ser√° chamado onde j√° coletamos os pontos recebidos em uma lista geral do <b>Dicion√°rio</b> e, o mais importante, para limpar os recursos ocupados. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, limpamos o dicion√°rio de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos pontos anteriores, depois usamos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loop foreach para</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classificar todos os pontos que recebemos das tarefas e os colocamos no dicion√°rio de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde a chave s√£o as coordenadas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√ÉO a posi√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Do ponto e o valor √© o pr√≥prio ponto. </font><font style="vertical-align: inherit;">Com a ajuda deste dicion√°rio, ser√° mais f√°cil procurar pontos vizinhos no mapa. </font><font style="vertical-align: inherit;">Ap√≥s o preenchimento, limpamos a matriz do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando o m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, no final, limpamos a pr√≥pria lista de tarefas dos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tamb√©m precisar√° limpar os </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limites</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos obst√°culos </font><font style="vertical-align: inherit;">se ele tiver sido criado anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de todas essas a√ß√µes, obtemos uma lista de todos os pontos no mapa e agora voc√™ pode desenh√°-los no palco.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo assim</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, na classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">crie o m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> onde desenharemos os pontos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, atrav√©s do loop, desenhamos cada ponto. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depois de todas essas a√ß√µes, nosso mapa parece um pouco chato, para realmente obter uma grade, voc√™ precisa que os pontos sejam conectados um ao outro. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malha</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para procurar pontos vizinhos, basta encontrar o ponto desejado por suas coordenadas em 8 dire√ß√µes; portanto, na classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">criaremos uma matriz est√°tica simples de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dire√ß√µes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">Dire√ß√µes</font></b><font style="vertical-align: inherit;"> e o m√©todo de pesquisa de c√©lulas por suas coordenadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornar√° um ponto por coordenadas da lista de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√≥s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas voc√™ precisa fazer isso com cuidado, porque se as coordenadas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estiverem incorretas, ocorrer√° um erro; portanto, aqui usamos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloco try catch</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exception </font><font style="vertical-align: inherit;">, que ajudar√° a ignorar a exce√ß√£o e n√£o " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travar√°</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " o aplicativo inteiro com um erro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, percorreremos um ciclo em todas as dire√ß√µes e tentaremos encontrar pontos vizinhos no m√©todo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, o mais importante, n√£o se esque√ßa de considerar a permeabilidade do ponto.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora voc√™ pode iniciar o jogo com seguran√ßa e ver o que aconteceu. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa din√¢mico</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, constru√≠mos apenas o pr√≥prio gr√°fico usando tarefas, mas foi o que aconteceu depois que eu parafusei no sistema o pr√≥prio algoritmo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que tamb√©m usa o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema Job</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar o caminho, a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonte no final do artigo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesquisa de mapa e caminho</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="imagem"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, voc√™ pode usar o novo sistema de tarefas para seus objetivos e criar sistemas interessantes sem muito esfor√ßo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no artigo anterior, o sistema de tarefas √© usado sem o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas se voc√™ usar esse sistema em conjunto com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , poder√° obter resultados simplesmente surpreendentes nos ganhos de desempenho. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boa sorte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Origem do Projeto Path Finder</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423601/">https://habr.com/ru/post/pt423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423589/index.html">Como escolhemos o TTS, por exemplo, sons no dicion√°rio</a></li>
<li><a href="../pt423591/index.html">M√∫sicas antigas sobre o principal. Java e solicita√ß√µes de sa√≠da</a></li>
<li><a href="../pt423593/index.html">Google anuncia concurso para ataques a algoritmos de vis√£o de m√°quina</a></li>
<li><a href="../pt423595/index.html">Anomalia de Frango, Interc√¢mbio</a></li>
<li><a href="../pt423597/index.html">Como e quais clusters podem ser alocados na base de clientes</a></li>
<li><a href="../pt423603/index.html">RxSwift parte 1</a></li>
<li><a href="../pt423607/index.html">Linus Torvalds desiste de estilo dif√≠cil e tira um tempo</a></li>
<li><a href="../pt423609/index.html">Para onde v√£o os sites ap√≥s a morte? Experi√™ncia pessoal</a></li>
<li><a href="../pt423611/index.html">Pagamento com um clique - bom ou mau?</a></li>
<li><a href="../pt423615/index.html">Habilidades profissionais exigidas entre especialistas em UX (fatia 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>