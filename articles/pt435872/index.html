<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïï ü§üüèª üíê Linguagem de programa√ß√£o Zig üëÜ ü§∏üèª üë®‚Äç‚ù§Ô∏è‚Äçüë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O primeiro coment√°rio sobre o maravilhoso artigo Vis√£o Subjetiva de uma Linguagem de Programa√ß√£o Ideal acabou sendo uma refer√™ncia √† linguagem de prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linguagem de programa√ß√£o Zig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  O primeiro coment√°rio sobre o maravilhoso artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vis√£o Subjetiva de uma Linguagem de Programa√ß√£o Ideal</a> acabou sendo uma refer√™ncia √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linguagem de programa√ß√£o Zig</a> .  Naturalmente, tornou-se interessante que tipo de linguagem √© que afirma ser um nicho de C ++, D e Rust.  Eu olhei - a linguagem parecia bonita e um tanto interessante.  Sintaxe agrad√°vel, semelhante a si, abordagem original para tratamento de erros, corotinas integradas.  Este artigo √© uma breve vis√£o geral da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o oficial</a> intercalada com pensamentos e impress√µes pr√≥prios dos exemplos de c√≥digo em execu√ß√£o. <br><a name="habracut"></a><br><h2>  Introdu√ß√£o </h2><br>  Instalar o compilador √© bastante simples, para Windows - basta descompactar o pacote de distribui√ß√£o em alguma pasta.  N√≥s criamos o arquivo de texto hello.zig na mesma pasta, inserimos o c√≥digo da documenta√ß√£o e o salvamos.  A montagem √© feita pelo comando <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  ap√≥s o qual hello.exe aparece no mesmo diret√≥rio. <br><br>  Al√©m da montagem, o modo de teste de unidade est√° dispon√≠vel; para isso, os blocos de teste s√£o usados ‚Äã‚Äãno c√≥digo, e a montagem e o lan√ßamento dos testes s√£o realizados por <br><br><pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  Primeiras esquisitices </h3><br>  O compilador n√£o suporta quebras de linha do Windows (\ r \ n).  Obviamente, o fato de que as quebras de linha em cada sistema (Win, Nix, Mac) serem parte delas √© selvageria e uma rel√≠quia do passado.  Mas n√£o h√° nada a ser feito; basta selecionar, por exemplo, no Notepad ++ o formato que voc√™ deseja para o compilador. <br><br>  A segunda estranheza que me deparei por acidente - as guias n√£o s√£o suportadas no c√≥digo!  Apenas espa√ßos.  Mas acontece :) <br><br>  No entanto, isso est√° escrito honestamente na documenta√ß√£o - a verdade j√° est√° no fim. <br><br><h3>  Coment√°rios </h3><br>  Outra singularidade √© que o Zig n√£o suporta coment√°rios de v√°rias linhas.  Lembro que tudo foi feito corretamente no antigo turbo pascal - coment√°rios de v√°rias linhas aninhados foram suportados.  Aparentemente, desde ent√£o, nenhum desenvolvedor de idiomas dominou uma coisa t√£o simples :) <br><br>  Mas existem coment√°rios documentais.  Comece com ///.  Deve estar em determinados lugares - na frente dos objetos correspondentes (vari√°veis, fun√ß√µes, classes ...).  Se eles estiverem em outro lugar - um erro de compila√ß√£o.  Nada mal. <br><br><h3>  Declara√ß√£o vari√°vel </h3><br>  Feito no estilo moderno agora (e ideologicamente correto), quando a palavra-chave (const ou var) √© escrita primeiro, depois o nome, depois o tipo e, em seguida, o valor inicial.  I.e.  infer√™ncia de tipo autom√°tica est√° dispon√≠vel.  As vari√°veis ‚Äã‚Äãdevem ser inicializadas - se voc√™ n√£o especificar um valor inicial, haver√° um erro de compila√ß√£o.  No entanto, √© fornecido um valor indefinido especial, que pode ser usado explicitamente para especificar vari√°veis ‚Äã‚Äãn√£o inicializadas. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Sa√≠da do console </h3><br>  Para experimentos, precisamos de sa√≠da para o console - em todos os exemplos, este √© o m√©todo usado.  No campo de plug-ins <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  e o c√≥digo est√° escrito assim: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  O compilador possui alguns erros, que s√£o honestamente relatados ao tentar gerar um n√∫mero inteiro ou um ponto de ponto flutuante da seguinte maneira: <br><blockquote>  erro: erro do compilador: literais inteiro e flutuante na fun√ß√£o var args devem ser convertidos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Tipos de dados </h2><br><h3>  Tipos primitivos </h3><br>  Aparentemente, os nomes dos tipos s√£o obtidos do Rust (i8, u8, ... i128, u128), tamb√©m existem tipos especiais para compatibilidade bin√°ria C, 4 tipos de tipos de ponto flutuante (f16, f32, f64, f128).  Existe um tipo bool.  Existe um tipo de comprimento nulo e um retorno especial, que discutirei mais adiante. <br><br>  Voc√™ tamb√©m pode construir tipos inteiros de qualquer tamanho em bits, de 1 a 65535. O nome do tipo come√ßa com a letra i ou u e, em seguida, o comprimento em bits √© gravado. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  No entanto, n√£o foi poss√≠vel obter esse valor no console - ocorreu um erro no LLVM durante a compila√ß√£o. <br><br>  Em geral, essa √© uma solu√ß√£o interessante, embora amb√≠gua (IMHO: o suporte a literais num√©ricos exatamente longos no n√≠vel do compilador esteja correto, mas nomear tipos dessa maneira n√£o √© muito bom, √© melhor faz√™-lo honestamente atrav√©s de um tipo de modelo).  E por que o limite √© 65535?  Bibliotecas como o GMP n√£o parecem impor essas restri√ß√µes? <br><br><h3>  Literais de string </h3><br>  Essas s√£o matrizes de caracteres (sem zero no final).  Para literais com um zero final, o prefixo 'c' √© usado. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Como a maioria dos idiomas, o Zig suporta seq√º√™ncias de escape padr√£o e a inser√ß√£o de caracteres Unicode atrav√©s de seus c√≥digos (\ uNNNN, \ UNNNNNN, onde N √© um d√≠gito hexadecimal). <br>  Literais de v√°rias linhas s√£o formados usando duas barras invertidas no in√≠cio de cada linha.  N√£o s√£o necess√°rias aspas.  Ou seja, algumas tentativas de criar cadeias brutas, mas o IMHO n√£o tem √™xito - a vantagem das cadeias brutas √© que voc√™ pode inserir qualquer parte do texto de qualquer lugar do c√≥digo - e, idealmente, n√£o altera nada, mas aqui voc√™ deve adicionar \\ no in√≠cio de cada linha. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Literais inteiros </h3><br>  Tudo est√° em idiomas semelhantes a si.  Fiquei muito satisfeito com o fato de que, para literais octais, o prefixo 0o √© usado, e n√£o apenas zero, como em C.  Literais bin√°rios com o prefixo 0b tamb√©m s√£o suportados.  Literais de ponto flutuante podem ser hexadecimais (como √© feito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extens√£o GCC</a> ). <br><br><h3>  Opera√ß√µes </h3><br>  Obviamente, existem opera√ß√µes C aritm√©ticas, l√≥gicas e bit a bit padr√£o.  Opera√ß√µes abreviadas s√£o suportadas (+ = etc.).  Em vez de &amp;&amp; e ||  as palavras-chave e e ou s√£o usadas.  Um ponto interessante √© que opera√ß√µes com sem√¢ntica envolvente garantida tamb√©m s√£o suportadas.  Eles se parecem com isso: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  Nesse caso, opera√ß√µes aritm√©ticas comuns n√£o garantem o estouro e seus resultados durante o estouro s√£o considerados indefinidos (e erros de compila√ß√£o s√£o gerados para constantes).  IMHO isso √© um pouco estranho, mas aparentemente √© feito de algumas considera√ß√µes profundas de compatibilidade com a sem√¢ntica da linguagem C. <br><br><h3>  Matrizes </h3><br>  Literais de matriz s√£o assim: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  Strings s√£o matrizes de caracteres, como em C.  Indexa√ß√£o cl√°ssica com colchetes.  As opera√ß√µes de adi√ß√£o (concatena√ß√£o) e multiplica√ß√£o de matrizes s√£o fornecidas.  √â uma coisa muito interessante, e se tudo estiver claro com concatena√ß√£o e multiplica√ß√£o - fiquei esperando at√© que algu√©m o implementasse e agora espero :) No Assembler (!) H√° uma opera√ß√£o dup que permite gerar dados duplicados.  Agora em Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Ponteiros </h3><br>  A sintaxe √© semelhante a C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  Para desreferenciar (pegar valores pelo ponteiro), uma opera√ß√£o incomum do postfix √© usada: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  O tipo de ponteiro √© definido explicitamente, definindo um asterisco na frente do nome do tipo <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Fatias (fatias) </h3><br>  Uma estrutura de dados incorporada √† linguagem que permite fazer refer√™ncia a uma matriz ou parte dela.  Cont√©m um ponteiro para o primeiro elemento e o n√∫mero de elementos.  √â assim: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  Parece ter sido tirado do Go, n√£o tenho certeza.  E tamb√©m n√£o tenho certeza se vale a pena incorporar em um idioma, enquanto a implementa√ß√£o em qualquer idioma OOP de algo assim √© muito elementar. <br><br><h3>  Estruturas </h3><br>  Uma maneira interessante de declarar uma estrutura: uma constante √© declarada, cujo tipo √© exibido automaticamente como "tipo" (tipo) e √© isso que √© usado como o nome da estrutura.  E a pr√≥pria estrutura (struct) √© "sem nome". <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  √â imposs√≠vel especificar um nome da maneira usual em linguagens do tipo C, no entanto, o compilador exibe o nome do tipo de acordo com certas regras - em particular, no caso considerado acima, ele coincidir√° com o nome da constante ‚Äútipo‚Äù. <br><br>  Em geral, o idioma n√£o garante a ordem dos campos e seu alinhamento na mem√≥ria.  Se forem necess√°rias garantias, estruturas "empacotadas" devem ser usadas. <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Inicializa√ß√£o - no estilo dos designadores de Sishny: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Estruturas podem ter m√©todos.  No entanto, colocar um m√©todo em uma estrutura √© simplesmente usar a estrutura como um espa√ßo para nome;  ao contr√°rio do C ++, nenhum par√¢metro impl√≠cito √© passado. <br><br><h3>  Transfer√™ncias </h3><br>  Em geral, o mesmo que em C / C ++.  Existem alguns meios internos convenientes de acessar meta-informa√ß√µes, por exemplo, o n√∫mero de campos e seus nomes, implementados por macros de sintaxe incorporadas ao idioma (chamadas de fun√ß√µes internas na documenta√ß√£o). <br><br>  Para "compatibilidade bin√°ria com C", algumas enumera√ß√µes externas s√£o fornecidas. <br><br>  Para indicar o tipo que deve estar subjacente √† enumera√ß√£o, uma constru√ß√£o do formul√°rio <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  onde u8 √© o tipo de base. <br>  As enumera√ß√µes podem ter m√©todos semelhantes √†s estruturas (por exemplo, usar um nome de enumera√ß√£o como espa√ßo para nome). <br><br><h3>  Sindicatos </h3><br>  Pelo que entendi, a uni√£o em Zig √© uma soma de tipo alg√©brica, ou seja  cont√©m um campo de tag oculto que determina qual dos campos de uni√£o est√° "ativo".  A ‚Äúativa√ß√£o‚Äù de outro campo √© realizada por uma reatribui√ß√£o completa de toda a associa√ß√£o.  Exemplo de documenta√ß√£o <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Os sindicatos tamb√©m podem usar explicitamente enumera√ß√µes para a tag. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  As uni√µes, como enumera√ß√µes e estruturas, tamb√©m podem fornecer seu pr√≥prio espa√ßo para nome para m√©todos. <br><br><h3>  Tipos opcionais </h3><br>  O Zig possui suporte opcional embutido.  Um ponto de interroga√ß√£o √© adicionado antes do nome do tipo: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Curiosamente, Zig implementa uma coisa sobre a possibilidade de que eu suspeitava, mas n√£o tinha certeza se estava certa ou n√£o.  Os ponteiros s√£o compat√≠veis com as op√ß√µes sem adicionar um campo oculto adicional (‚Äútag‚Äù), que armazena um sinal da validade do valor;  e null √© usado como um valor inv√°lido.  Assim, os tipos de refer√™ncia representados no Zig por ponteiros nem precisam de mem√≥ria adicional para ‚Äúopcionalidade‚Äù.  Ao mesmo tempo, √© proibido atribuir valores nulos a ponteiros regulares. <br><br><h3>  Tipos de erro </h3><br>  Eles s√£o semelhantes aos tipos opcionais, mas, em vez da marca booleana (‚Äúrealmente inv√°lida‚Äù), um elemento de enumera√ß√£o correspondente ao c√≥digo de erro √© usado.  A sintaxe √© semelhante √†s op√ß√µes, um ponto de exclama√ß√£o √© adicionado em vez de um ponto de interroga√ß√£o.  Assim, esses tipos podem ser usados, por exemplo, para retornar de fun√ß√µes: o resultado do objeto da opera√ß√£o bem-sucedida da fun√ß√£o √© retornado ou um erro com o c√≥digo correspondente √© retornado.  Os tipos de erro s√£o uma parte importante do sistema de tratamento de erros do idioma Zig. Para obter mais detalhes, consulte a se√ß√£o Tratamento de erros. <br><br><h3>  Tipo nulo </h3><br>  Vari√°veis ‚Äã‚Äãcomo void e opera√ß√µes com elas s√£o poss√≠veis no Zig <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  nenhum c√≥digo √© gerado para essas opera√ß√µes;  esse tipo √© √∫til principalmente para metaprograma√ß√£o. <br><br>  H√° tamb√©m um tipo de c_void para compatibilidade com C. <br><br><h2>  Operadores de controle e fun√ß√µes </h2><br>  Eles incluem: blocos, alternar, enquanto, por, se, mais, interromper, continuar.  Para agrupar o c√≥digo, colchetes padr√£o s√£o usados.  Apenas blocos, como em C / C ++, s√£o usados ‚Äã‚Äãpara limitar o escopo das vari√°veis.  Blocos podem ser considerados como express√µes.  N√£o h√° goto no idioma, mas existem r√≥tulos que podem ser usados ‚Äã‚Äãcom as instru√ß√µes break e continue.  Por padr√£o, esses operadores trabalham com loops; no entanto, se um bloco tiver um r√≥tulo, voc√™ poder√° us√°-lo. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  A instru√ß√£o switch difere do operador por n√£o ter uma "explica√ß√£o", ou seja,  apenas uma condi√ß√£o (caso) √© executada e o comutador sai.  A sintaxe √© mais compacta: em vez de mai√∫sculas e min√∫sculas, a seta "=&gt;" √© usada.  Switch tamb√©m pode ser considerado uma express√£o. <br><br>  As instru√ß√µes while e if s√£o geralmente as mesmas que em todos os idiomas semelhantes a C.  A declara√ß√£o for √© mais parecida com foreach.  Todos eles podem ser considerados como express√µes.  Dos novos recursos, while e for, assim como se, pode ter um bloco else que √© executado se n√£o houver itera√ß√£o de loop. <br><br>  E aqui √© hora de falar sobre um recurso comum para o switch, enquanto, de alguma forma, √© emprestado do conceito de loops foreach - vari√°veis ‚Äã‚Äãde "captura".  √â assim: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Aqui, o argumento while √© uma certa "fonte" de dados, que pode ser opcional, para uma matriz ou uma fatia, e uma vari√°vel localizada entre duas linhas verticais cont√©m um valor "expandido" - ou seja,  o elemento atual da matriz ou fatia (ou um ponteiro para ele), o valor interno do tipo opcional (ou um ponteiro para ele). <br><br><h3>  Adiar e errar as declara√ß√µes </h3><br>  A declara√ß√£o de execu√ß√£o adiada emprestada do Go.  Funciona da mesma maneira - o argumento desse operador √© executado ao sair do escopo em que o operador √© usado.  Al√©m disso, √© fornecido o operador errdefer, que √© acionado se um tipo de erro com um c√≥digo de erro ativo for retornado da fun√ß√£o.  Isso faz parte do sistema original de tratamento de erros do Zig. <br><br><h3>  Operador inacess√≠vel </h3><br>  O elemento da programa√ß√£o do contrato.  Uma palavra-chave especial, que √© colocada onde o gerenciamento n√£o deve vir sob nenhuma circunst√¢ncia.  Se ele chegar l√°, nos modos Debug e ReleaseSafe, um p√¢nico √© gerado, e no ReleaseFast o otimizador lan√ßa esses ramos completamente. <br><br><h3>  voltar </h3><br>  Tecnicamente, √© um tipo compat√≠vel em express√µes com qualquer outro tipo.  Isso √© poss√≠vel devido ao fato de que um objeto desse tipo nunca retornar√°.  Como os operadores s√£o express√µes no Zig, √© necess√°rio um tipo especial para express√µes que nunca ser√£o avaliadas.  Isso acontece quando o lado direito da express√£o transfere irrevogavelmente o controle para algum lugar externo.  Para tais declara√ß√µes quebram, continuam, retornam, loops inacess√≠veis e infinitos e fun√ß√µes que nunca retornam o controle.  Para compara√ß√£o, uma chamada para uma fun√ß√£o regular (retornando controle) n√£o √© um operador de retorno normal, porque, embora o controle seja transferido para fora, ele ser√° retornado ao ponto de chamada mais cedo ou mais tarde. <br><br>  Assim, as seguintes express√µes se tornam poss√≠veis: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  A vari√°vel a obt√©m o valor retornado pela instru√ß√£o if / else.  Para isso, as partes (if e else) devem retornar uma express√£o do mesmo tipo.  A parte if retorna bool, a parte else √© do tipo noreturn, tecnicamente compat√≠vel com qualquer tipo, como resultado, o c√≥digo √© compilado sem erros. <br><br><h3>  Fun√ß√µes </h3><br>  A sintaxe √© cl√°ssica para idiomas desse tipo: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  Em geral, as fun√ß√µes parecem bastante padr√£o.  At√© o momento, n√£o notei sinais de fun√ß√µes de primeira classe, mas meu conhecimento da linguagem √© muito superficial, posso estar errado.  Embora talvez isso ainda n√£o tenha sido feito. <br><br>  Outro recurso interessante √© que, no Zig, ignorar valores retornados s√≥ pode ser explicitamente feito usando o sublinhado _ <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  H√° uma reflex√£o que permite obter v√°rias informa√ß√µes sobre a fun√ß√£o <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Execu√ß√£o de c√≥digo em tempo de compila√ß√£o </h2><br>  O Zig fornece um recurso poderoso - execu√ß√£o de c√≥digo escrito em zig no momento da compila√ß√£o.  Para que o c√≥digo seja executado em tempo de compila√ß√£o, envolva-o em um bloco com a palavra-chave comptime.  A mesma fun√ß√£o pode ser chamada em tempo de compila√ß√£o e em tempo de execu√ß√£o, o que permite escrever c√≥digo universal.  Obviamente, existem algumas limita√ß√µes associadas a diferentes contextos do c√≥digo.  Por exemplo, na documenta√ß√£o de muitos exemplos, o comptime √© usado para verificar o tempo de compila√ß√£o: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  Mas √© claro que o poder desse operador est√° longe de ser totalmente divulgado aqui.  Assim, na descri√ß√£o da linguagem, √© dado um exemplo cl√°ssico do uso efetivo de macros sint√°ticas - a implementa√ß√£o de uma fun√ß√£o semelhante √† printf, mas analisando a sequ√™ncia de formata√ß√£o e conduzindo toda a verifica√ß√£o de tipo necess√°ria de argumentos no est√°gio de compila√ß√£o. <br><br>  Al√©m disso, a palavra comptime √© usada para indicar os par√¢metros das fun√ß√µes em tempo de compila√ß√£o, que s√£o semelhantes √†s fun√ß√µes do modelo C ++. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Tratamento de erros </h2><br>  O Zig inventou um sistema original de tratamento de erros que n√£o era como outros idiomas.  Isso pode ser chamado de "exce√ß√µes expl√≠citas" (nesse idioma, a explicita√ß√£o geralmente √© um dos idiomas).  Tamb√©m se parece com os c√≥digos de retorno Go, mas funciona de maneira diferente. <br><br>  O sistema de processamento de erros do Zig √© baseado em enumera√ß√µes especiais para implementar c√≥digos de erro personalizados (erro) e constru√≠dos com base em "tipos de erro" (soma alg√©brica do tipo, combinando o tipo de fun√ß√£o retornado e o c√≥digo de erro). <br><br>  As enumera√ß√µes de erro s√£o declaradas da mesma maneira que as enumera√ß√µes regulares: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  No entanto, todos os c√≥digos de erro recebem valores maiores que zero;  Al√©m disso, se voc√™ declarar um c√≥digo com o mesmo nome em duas enumera√ß√µes, ele receber√° o mesmo valor.  No entanto, convers√µes impl√≠citas entre diferentes enumera√ß√µes de erros s√£o proibidas. <br><br>  A palavra-chave anyerror significa uma enumera√ß√£o que inclui todos os c√≥digos de erro. <br><br>  Como os tipos opcionais, o idioma suporta a gera√ß√£o de tipos de erro usando sintaxe especial.  O tipo! U64 √© uma forma abreviada de anyerror! U64, que por sua vez significa uma uni√£o (op√ß√£o), que inclui o tipo u64 e o tipo anyerror (como eu o entendo, o c√≥digo 0 √© reservado para indicar a aus√™ncia de um erro e a validade do campo de dados, o restante dos c√≥digos √© c√≥digos de erro). <br><br>  A palavra-chave catch permite capturar o erro e transform√°-lo em um valor padr√£o: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  Portanto, se ocorrer um erro na fun√ß√£o parseU64 retornando o tipo! U64, o catch "interceptar√°" e retornar√° o valor padr√£o 13. <br><br>  A palavra-chave try permite que voc√™ "encaminhe" o erro para o n√≠vel superior (ou seja, para o n√≠vel da fun√ß√£o de chamada).  Ver c√≥digo <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  equivalente a isso: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Aqui acontece o seguinte: parseU64 √© chamado, se um erro √© retornado - √© interceptado pela instru√ß√£o catch, na qual o c√≥digo de erro √© extra√≠do usando a sintaxe "capture", colocada na vari√°vel err, retornada via! Void para a fun√ß√£o de chamada. <br><br>  O operador Errdefer descrito anteriormente tamb√©m se refere ao tratamento de erros.  O c√≥digo do argumento de erro √© executado apenas se a fun√ß√£o retornar um erro. <br><br>  Mais algumas possibilidades.  Usando o ||  voc√™ pode mesclar conjuntos de erros <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  O Zig tamb√©m fornece recursos como rastreamento de erros.  Isso √© algo semelhante a um rastreamento de pilha, mas cont√©m informa√ß√µes detalhadas sobre o erro que ocorreu e como ele se propagou ao longo da cadeia de tentativas, do local da ocorr√™ncia at√© a principal fun√ß√£o do programa. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, o sistema de tratamento de erros no Zig √© uma solu√ß√£o muito original, que n√£o se parece com exce√ß√µes no C ++ ou nos c√≥digos de retorno no Go. </font><font style="vertical-align: inherit;">Podemos dizer que essa solu√ß√£o tem um determinado pre√ßo - mais 4 bytes, que devem ser retornados juntamente com cada valor retornado; </font><font style="vertical-align: inherit;">vantagens √≥bvias s√£o visibilidade e transpar√™ncia absolutas. </font><font style="vertical-align: inherit;">Ao contr√°rio do C ++, aqui a fun√ß√£o n√£o pode gerar uma exce√ß√£o desconhecida em algum lugar profundo da cadeia de chamadas. </font><font style="vertical-align: inherit;">Tudo o que a fun√ß√£o retorna - ela retorna explicitamente e apenas explicitamente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutines </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Zig possui corotinas embutidas. </font><font style="vertical-align: inherit;">Essas s√£o fun√ß√µes criadas com a palavra-chave ass√≠ncrona, com a qual as fun√ß√µes do alocador e do desalocador s√£o transferidas (como eu entendo, para uma pilha adicional).</font></font><br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async retorna um objeto especial do tipo promessa-&gt; T (onde T √© o tipo de retorno da fun√ß√£o). Usando esse objeto, voc√™ pode controlar a corotina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os n√≠veis mais baixos incluem as palavras-chave suspender, retomar e cancelar. Usando a suspens√£o, a execu√ß√£o da rotina √© pausada e passada para o programa de chamada. A sintaxe do bloco de suspens√£o √© poss√≠vel, tudo dentro do bloco √© executado at√© que a corotina seja realmente suspensa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resume pega um argumento do tipo promessa-&gt; T e retoma a execu√ß√£o da corotina de onde foi suspensa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cancelar libera mem√≥ria de rotina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta figura mostra a transfer√™ncia de controle entre o programa principal (na forma de um teste) e a corotina. Tudo √© bem simples:</font></font><br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="imagem"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo recurso (n√≠vel superior) √© o uso de aguardar. </font><font style="vertical-align: inherit;">Essa √© a √∫nica coisa que, francamente, eu n√£o entendi (infelizmente, a documenta√ß√£o ainda √© muito escassa). </font><font style="vertical-align: inherit;">Aqui est√° o diagrama de transfer√™ncia de controle real de um exemplo ligeiramente modificado da documenta√ß√£o, talvez isso explique algo para voc√™:</font></font><br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="imagem"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fun√ß√µes incorporadas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√µes embutidas - um conjunto razoavelmente grande de fun√ß√µes integradas ao idioma e n√£o requer a conex√£o de nenhum m√≥dulo. Talvez seja mais correto chamar algumas delas de "macros sint√°ticas integradas", porque os recursos de muitos v√£o muito al√©m das fun√ß√µes. os built-in fornecem acesso √†s ferramentas de reflex√£o (sizeOf, tagName, TagType, typeInfo, typeName, typeOf), com seus m√≥dulos de ajuda (importa√ß√£o) conectados. Outros s√£o mais parecidos com o cl√°ssico C / C ++ interno - eles implementam convers√µes de tipo de baixo n√≠vel, v√°rias opera√ß√µes como sqrt, popCount, slhExact, etc. √â muito prov√°vel que a lista de fun√ß√µes internas mude √† medida que o idioma se desenvolve.</font></font><br><br><h3>  Em conclus√£o </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â muito agrad√°vel que esses projetos apare√ßam e se desenvolvam. </font><font style="vertical-align: inherit;">Embora a linguagem C seja conveniente, concisa e familiar para muitos, ainda est√° desatualizada e, por raz√µes de arquitetura, n√£o pode suportar muitos conceitos de programa√ß√£o modernos. </font><font style="vertical-align: inherit;">O C ++ est√° em desenvolvimento, mas objetivamente reprojetado, est√° se tornando cada vez mais dif√≠cil a cada nova vers√£o, e pelos mesmos motivos arquiteturais e devido √† necessidade de compatibilidade com vers√µes anteriores, nada pode ser feito sobre isso. </font><font style="vertical-align: inherit;">A ferrugem √© interessante, mas com um limiar de entrada muito alto, o que nem sempre √© justificado. </font><font style="vertical-align: inherit;">D √© uma boa tentativa, mas existem algumas falhas menores, parece que inicialmente a linguagem foi criada com maior probabilidade sob a influ√™ncia do Java, e os recursos subsequentes foram introduzidos de alguma forma, de alguma forma, n√£o como deveriam. </font><font style="vertical-align: inherit;">Obviamente, Zig √© outra dessas tentativas. </font><font style="vertical-align: inherit;">A linguagem √© interessante, e √© interessante ver o que sai dela.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435872/">https://habr.com/ru/post/pt435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435862/index.html">Hall da fama da eletr√¥nica de consumo: as hist√≥rias dos melhores gadgets dos √∫ltimos 50 anos, parte 4</a></li>
<li><a href="../pt435864/index.html">Mapeando solicita√ß√µes para Netty</a></li>
<li><a href="../pt435866/index.html">Release IT: uma nova plataforma para o lan√ßamento de produtos e servi√ßos como parte do festival SXSW 2019</a></li>
<li><a href="../pt435868/index.html">Slush 2018. Dia da pr√©-visualiza√ß√£o</a></li>
<li><a href="../pt435870/index.html">Orquestra Cibern√©tica. Orquestra√ß√£o de cont√™iner do Docker com aplicativos .NET Core na nuvem</a></li>
<li><a href="../pt435876/index.html">Configura√ß√µes detalhadas do navegador Firefox</a></li>
<li><a href="../pt435878/index.html">Amador em c√≥digo aberto - li√ß√µes aprendidas em 3 anos</a></li>
<li><a href="../pt435880/index.html">Alterando o esquema das tabelas do PostgreSQL sem bloqueios longos. Palestra Yandex</a></li>
<li><a href="../pt435882/index.html">Xiaomi Mi Box S revis√£o e uma pequena compara√ß√£o com Mi Box 3</a></li>
<li><a href="../pt435884/index.html">Pesquisa de metais e ... rede neural</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>