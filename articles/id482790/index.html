<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšˆ ğŸ¥™ ğŸ—¿ Lupakan enkripsi homomorfik: sekarang kami memiliki enkripsi fungsional ğŸ“¬ ğŸ“¯ ğŸ‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda mendengar tentang enkripsi fungsional (FS)? Mungkin Anda pernah mendengarnya, dan untuk diri Anda sendiri Anda menyamakannya dengan enk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lupakan enkripsi homomorfik: sekarang kami memiliki enkripsi fungsional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482790/"><img src="https://habrastorage.org/webt/b-/db/xt/b-dbxtbizpu1ox7keddccrw2kqy.jpeg"><br><br>  Pernahkah Anda mendengar tentang <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">enkripsi fungsional</a> (FS)?  Mungkin Anda pernah mendengarnya, dan untuk diri Anda sendiri Anda <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BC%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2580%25D1%2584%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">menyamakannya</a> dengan <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BC%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2580%25D1%2584%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">enkripsi homomorfik</a> , yang tidak sepenuhnya salah, tetapi tidak sepenuhnya benar. <br><br>  Mari kita lihat apa yang ada pada FS hari ini, analisis beberapa contoh dan bagaimana perbedaannya dari enkripsi sepenuhnya homomorfik (PGS). <br><br>  Pertama-tama mari kita putuskan apa yang kita maksudkan ketika berbicara tentang FS.  Baru-baru ini, pada 2010, Dan Bonnet, Amit Sahai dan Brent Waters meresmikan konsep FS.  Kira-kira FS dapat digambarkan sebagai berikut: ini adalah skema enkripsi dengan kunci publik, di mana kunci berbeda untuk dekripsi memungkinkan pengguna untuk belajar tentang fungsi-fungsi tertentu dari data yang dienkripsi. <br><a name="habracut"></a><br>  Jadi, dalam skema FS untuk fungsi F (Â·, Â·), enkripsi dengan kunci master menghasilkan kunci s <sub>k</sub> , yang memungkinkan menghitung fungsi F (k, Â·) dari data yang dienkripsi sehingga decryptor, mengetahui teks yang dienkripsi c dari data x dan kunci s <sub>k</sub> , mampu menghitung F (k, x) tanpa bisa menemukan apa pun selain hasil komputasi fungsi dari x. <br><br><h2>  FS vs PGS </h2><br>  Jika Anda terbiasa dengan konsep PGS, akan menarik untuk menarik paralel berikut: <br><br>  Dengan menggunakan PGS, Anda dapat menghitung fungsi apa pun dari data yang dienkripsi tanpa mendekripsi data ini.  Ini adalah kesempatan yang menarik untuk mendelegasikan komputasi ke pihak ketiga yang tidak memiliki kepercayaan.  The minus dari pendekatan adalah bahwa hasilnya juga dienkripsi, dan untuk mendekripsi itu, Anda harus mengirimkannya ke pemilik kunci pribadi.  Proses PGS dapat direpresentasikan sebagai berikut, di mana E adalah skema enkripsi dan F adalah fungsi yang ingin kita hitung dari data terenkripsi: <br><br>  E (x_1), E (x_2), ..., E (x_n) â†’ E (F (x_1, x_2, Â· Â·, x_n)) <br><br>  Di sisi lain, dengan FS, hasilnya langsung tersedia bagi kami segera setelah perhitungan, yaitu, berikut ini tersedia untuk kami: <br><br>  E (x_1), E (x_2), Â· Â·, E (x_n) â†’ F (x_1, x_2, Â· Â·, x_n) <br><br>  Dalam arti tertentu, FS adalah skema yang secara simultan menghitung dan mendekripsi hasilnya, tanpa kebocoran kunci pribadi dan informasi apa pun tentang x1, x2, Â· Â· Â·, <sub>xn</sub> kecuali hasil perhitungan itu sendiri. <br><br>  Jelas, kami tidak memerlukan semua orang untuk dapat menghitung fungsi apa pun yang mereka inginkan, karena jika tidak, akan mudah untuk mendapatkan informasi tentang parameter individu dalam teks yang jelas (misalnya, untuk menghitung fungsi yang identik).  Oleh karena itu, hanya pemilik kunci pribadi yang dapat mendekripsi E (x_i) dan menghasilkan kunci penyelesaian untuk fungsi tertentu yang dipilihnya.  Ini berarti bahwa FS mensyaratkan kehadiran â€œotoritas pusatâ€ yang mengeluarkan â€œkunci penyelesaianâ€ bagi orang yang bertanggung jawab atas perhitungan fungsional. <br><br>  Artinya, FS adalah generalisasi dari ide enkripsi dengan kunci publik, yang memungkinkan pengguna untuk mendelegasikan kepada pihak ketiga perhitungan kelas fungsi tertentu dari data yang dienkripsi dengan menghasilkan kunci rahasia tertentu untuk fungsi-fungsi ini.  Tidak seperti skema enkripsi standar, ini memungkinkan Anda untuk lebih akurat mengontrol kemampuan dekripsi yang tersedia untuk pihak ketiga. <br><br>  FS sangat berguna karena memungkinkan kita untuk dengan sengaja mentransfer informasi tertentu tentang data terenkripsi ke pengguna tertentu.  Misalnya, kita bisa mendapatkan nilai rata-rata dari satu set data terenkripsi tanpa mengungkapkan data itu sendiri, atau mendapatkan lebih banyak statistik tentang set ini.  Dengan masalah keamanan saat ini dan persyaratan yang diajukan oleh undang-undang baru, seperti GDPR, kebutuhan akan skema FS yang efektif menjadi lebih jelas, karena memungkinkan pihak ketiga untuk memproses data terenkripsi tanpa memberikan data ini kepada siapa pun dalam bentuk murni.  Ini berarti bahwa kita dapat melangkah lebih jauh daripada anonimisasi semu dari data pribadi yang memungkinkan, menjamin kerahasiaan yang lebih ketat! <br><br><h2>  Kembali ke FS </h2><br>  Karena sifat umumnya, FS merangkul dan menggabungkan banyak skema enkripsi canggih lainnya yang sebelumnya dipelajari secara independen, yaitu: <a href="https://ru.wikipedia.org/wiki/Searchable_Encryption" rel="nofollow">enkripsi</a> <a href="https://ru.wikipedia.org/wiki/ID-based_encryption" rel="nofollow">berbasis</a> <a href="https://ru.wikipedia.org/wiki/Searchable_Encryption" rel="nofollow">otentikasi,</a> enkripsi yang <a href="https://ru.wikipedia.org/wiki/Searchable_Encryption" rel="nofollow">dapat dicari</a> , enkripsi vektor tersembunyi, enkripsi berbasis otentikasi dengan pola wildcard, <a href="https://ru.wikipedia.org/wiki/Attribute-based_Encryption" rel="nofollow">enkripsi berbasis atribut</a> , enkripsi fungsional dengan produk skalar. <br><br>  Meskipun skema FS masih sangat muda, banyak yang telah terjadi sejak 2010, dan sudah ada banyak skema menarik yang memungkinkan Anda melakukan hal-hal yang tampaknya sangat rumit 8 tahun yang lalu.  Sudah mencapai titik bahwa laporan tentang FS diatur pada konferensi kriptografi tertentu! <br><br>  Mari kita lihat beberapa jenis skema FS.  Sebagai contoh: <br><br><ul><li>  Enkripsi fungsional dengan produk skalar (FSFS), di mana plaintext adalah vektor, dan data terenkripsi bersama dengan kunci dapat digunakan untuk menghitung produk skalar dari vektor ini dengan yang lain.  FSSP memiliki beberapa opsi: untuk banyak klien, untuk banyak input, didesentralisasi, dengan fungsi persembunyian, dll. </li><li>  Enkripsi berbasis atribut (SHO), di mana data yang dienkripsi dikaitkan dengan sekumpulan atribut dan kunci rahasia bersama dengan aturan tertentu yang mengontrol teks terenkripsi mana yang dapat dienkripsi, tergantung pada atribut yang kita miliki. </li><li>  FS "tujuan umum", yang memungkinkan untuk menghitung fungsi f dalam bentuk apa pun dari data terenkripsi Enc (x). </li></ul><br>  Namun, penting untuk dicatat di sini bahwa meskipun banyak pekerjaan telah dilakukan dengan berkonsentrasi pada aspek teoritis FS untuk mengembangkan area ini sebanyak mungkin, semua FS tujuan umum terlalu tidak efektif untuk penggunaan praktis saat ini.  Ini adalah salah satu topik penelitian proyek FENTEC (program riset <a href="http://fentec.eu/" rel="nofollow">Teknologi Enkripsi Fungsional</a> Eropa): membawa FS ke penerapan praktis dengan merancang dan mengimplementasikan skema praktis yang dapat digunakan pada skala industri.  Dalam proyek ini, tidak hanya skema baru dengan fungsi yang lebih kaya dikembangkan, tetapi juga coprocessor khusus yang dapat mempercepat perhitungan yang dibutuhkan bahkan lebih - segalanya untuk membawa teori lebih dekat ke praktik.  Informasi lebih lanjut tentang peralatan ini dapat ditemukan di <a href="http://fentec.eu/content/hardware-support-and-acceleration-functional-encryption" rel="nofollow">posting blog proyek</a> FENTEC. <br><br><h2>  Ingin menggunakan FS hari ini?  Silakan gunakan </h2><br>  Tetapi bagaimana jika Anda ingin menggunakan FS hari ini?  Seharusnya tidak ada masalah dengan itu!  Sebagai bagian dari proyek FENTEC, tim dari XLAB terlibat dalam implementasi banyak skema yang dikembangkan oleh universitas mitra dalam bentuk <a href="https://github.com/fentec-project/CiFEr" rel="nofollow">CiFEr</a> C-library dan <a href="https://github.com/fentec-project/CiFEr" rel="nofollow">GoFE</a> Go-library. <br><br>  Anda dapat membaca lebih lanjut tentang perpustakaan <a href="http://fentec.eu/content/functional-encryption-library" rel="nofollow">di blog FENTEC secara lebih rinci</a> , atau langsung pergi ke Github dan mulai bermain dengan <a href="https://github.com/fentec-project/gofe" rel="nofollow">perpustakaan CiFEr</a> dan <a href="https://github.com/fentec-project/gofe" rel="nofollow">GoFE</a> .  Omong-omong, kami memeriksa bahwa mereka berfungsi bahkan di browser melalui WASM! <br><br>  Bahkan ada beberapa contoh di repositori Github proyek: <br><br><ul><li>  Enkripsi berbasis atribut dari akses ke data medis: <a href="https://github.com/fentec-project/Selective-Access-to-Clinical-Data" rel="nofollow">github.com/fentec-project/Selective-Access-to-Clinical-Data</a> </li><li>  Bagaimana FS dengan produk skalar membantu menciptakan "peta panas" yang sepenuhnya anonim dari lokasi pengguna: <a href="https://github.com/fentec-project/FE-anonymous-heatmap" rel="nofollow">github.com/fentec-project/FE-anonymous-heatmap</a> </li><li>  Bagaimana kuadratik FS memungkinkan pembelajaran mesin menggunakan data terenkripsi dan pengenalan optik nomor tulisan tangan tanpa mengungkapkan angka-angka ini sendiri: <a href="https://github.com/fentec-project/neural-network-on-encrypted-data" rel="nofollow">github.com/fentec-project/neural-network-on-encrypted-data</a> </li></ul><br><h2>  Semua detail mengerikan: apa yang ada di dalam skema FS </h2><br>  Di antara skema yang sudah diterapkan, Anda dapat menemukan banyak skema yang disebut "enkripsi fungsional dengan produk skalar."  Tapi apa arti nama ini?  Ini harus diambil secara harfiah: skema ini memungkinkan pihak ketiga untuk menghitung hasil produk skalar dari dua vektor menggunakan FS. <br><br>  Misalkan Anda ingin mengenkripsi vektor a dan mendapatkan hasil produk skalar-nya dengan vektor y.  Untuk memulainya, kita membutuhkan otoritas pusat untuk mengimplementasikan FS. <br><br>  Dalam kasus ini, otoritas pusat mengeluarkan "kunci master publik" mpk, serta kunci penyelesaian z <sub>y</sub> untuk vektor yang diberikan y.  Kemudian, siapa pun yang mengetahui kunci publik dapat mengenkripsi vektor a, memungkinkan pihak ketiga mana pun yang memiliki kunci z <sub>y</sub> untuk menghitung &lt;a, y&gt;, memiliki E <sub>mpk</sub> (a), dan tidak mengetahui apa pun tentang vektor itu sendiri. <br><br>  Perhatikan bahwa dalam skema FS ini, vektor y yang terkait dengan kunci komputasi z <sub>y</sub> harus diketahui oleh pihak ketiga untuk menghitung produk skalar.  Artinya, hanya vektor a yang tetap menjadi rahasia. <br><br>  Bagaimana jika Anda ingin kedua vektor, a dan y tetap rahasia, tetapi pada saat yang sama sehingga pihak ketiga dapat menghitung produk skalar mereka? <br><br>  Untungnya, bidang penelitian ini juga telah membuat terobosan besar dalam beberapa tahun terakhir.  Itu dikenal sebagai "FS dengan fungsi persembunyian."  Bahkan, skema enkripsi produk skalar "menyembunyikan fungsi" jika kunci dan ciphertext tidak memberikan informasi tambahan tentang vektor a dan y, kecuali untuk produk skalar mereka &lt;a, y&gt;.  Dalam skema baru dengan FS, fungsi persembunyian semakin umum ( <a href="https://eprint.iacr.org/2017/972.pdf" rel="nofollow">1</a> , <a href="https://eprint.iacr.org/2016/440.pdf" rel="nofollow">2</a> , <a href="http://fentec.eu/content/paper-multi-input-functional-encryption-inner-products-function-hiding-realizations-and" rel="nofollow">3</a> ). <br><br><h2>  Untuk meringkas </h2><br>  Meskipun enkripsi fungsional telah muncul baru-baru ini, kita sudah dapat membayangkan banyak opsi untuk penggunaannya di masa depan.  Yang sangat menarik adalah kemampuan untuk mentransfer proses pengambilan keputusan, berdasarkan enkripsi data ujung ke ujung, dari sistem backend ke sistem gateway tertentu di jaringan yang kompleks.  Kami menyebutnya "pengambilan keputusan lokal," dan kesempatan seperti itu merupakan langkah besar untuk menciptakan jaringan aman untuk "Internet of Things" dan jaringan lain yang sangat terdesentralisasi yang ingin menerapkan enkripsi ujung-ke-ujung tanpa kehilangan terlalu banyak kemampuan pengambilan keputusan di tingkat gateway. <br><br>  Sekarang kami sedang mengerjakan prototipe produk yang, menggunakan FS dengan produk skalar, mampu mendeteksi pergerakan dalam aliran video dari kamera ke sistem backend, di tingkat gateway, menggunakan apa yang disebut  "Vektor gerak" termasuk dalam standar AVC H.264 / MPEG-4. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb3/f12/87d/cb3f1287d2fdbc789f9679001b0312de.png"><br>  <i>Visualisasi vektor gerakan dalam bingkai ketika pengkodean <a href="https://ru.wikipedia.org/wiki/H.264" rel="nofollow">H.264</a> membuka kartun pendek <a href="http://www.bigbuckbunny.org/" rel="nofollow">Big Buck Bunny</a></i> <br><br>  Harap perhatikan seberapa bagus vektor gerak sebagai kandidat untuk digunakan dalam skema dengan FS dengan produk skalar - karena produk skalar didefinisikan pada ruang vektor!  Kami masih mencari opsi terbaik untuk metode deteksi gerakan, dan berharap untuk mendapatkan prototipe yang berfungsi penuh menggunakan FS untuk pengenalan gerak pada akhir tahun 2020. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482790/">https://habr.com/ru/post/id482790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482778/index.html">Ventilasi dengan pemulihan di apartemen. Tanpa saluran dan SMS</a></li>
<li><a href="../id482780/index.html">Eksperimen dengan jaringan saraf berdasarkan data seismik</a></li>
<li><a href="../id482784/index.html">Kehidupan rahasia dari server Linux atau serangan brute force pada subsistem SSH</a></li>
<li><a href="../id482786/index.html">Teka-teki yang tidak terpecahkan</a></li>
<li><a href="../id482788/index.html">Apa yang ada di dalam Google Coral Edge TPU: tes untuk kecepatan dan penguraian perangkat</a></li>
<li><a href="../id482792/index.html">Proyek ITER pada 2019</a></li>
<li><a href="../id482794/index.html">Jaringan saraf. Kemana perginya semua</a></li>
<li><a href="../id482800/index.html">Pencarian saya untuk panel kontrol fisik rumah pintar</a></li>
<li><a href="../id482802/index.html">Dimasukkannya jauh skrip Mikrotik dari Telegram v 2.0</a></li>
<li><a href="../id482804/index.html">Java: menciutkan log multi-baris ke log satu-baris menggunakan Spring dan Logback atau Log4j2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>