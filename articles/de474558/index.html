<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è±Ô∏è ü§∏üèæ üë©‚Äçüç≥ Protokollorientierte Programmierung, Teil 2 üôÉ üç£ üëåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Fortsetzung des Themas werden wir Protokolltypen und verallgemeinerten Code untersuchen. 


 Die folgenden Punkte werden dabei ber√ºcksichtigt: 


-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokollorientierte Programmierung, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474558/"><p>  In Fortsetzung des Themas werden wir Protokolltypen und verallgemeinerten Code untersuchen. </p><br><p>  Die folgenden Punkte werden dabei ber√ºcksichtigt: </p><br><ul><li>  Implementierung von Polymorphismus ohne Vererbung und Referenztypen </li><li>  wie Objekte vom Typ Protokoll gespeichert und verwendet werden </li><li>  Wie funktioniert der Methodenversand mit ihnen? </li></ul><a name="habracut"></a><br><h2 id="protokolnye-tipy">  <strong>Protokolltypen</strong> </h2><br><p>  <strong>Implementierung von Polymorphismus ohne Vererbung und Referenztypen:</strong> </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, x2, y1, y2: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawbles = [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawbles { d.draw() }</code> </pre> <br><ol><li>  Bezeichnen Sie das Drawable-Protokoll, das √ºber eine Draw-Methode verf√ºgt. </li><li>  Wir implementieren dieses Protokoll f√ºr Point und Line - jetzt k√∂nnen Sie damit wie mit Drawable umgehen (Aufruf der Draw-Methode) </li></ol><br><p>  Wir haben immer noch einen polymorphen Code.  Das d-Element des drawables-Arrays verf√ºgt √ºber eine Schnittstelle, die im Drawable-Protokoll angegeben ist, jedoch √ºber unterschiedliche Implementierungen seiner Methoden, die in Line und Point angegeben sind. </p><br><blockquote>  Das Hauptprinzip (Ad-hoc) des Polymorphismus: "Gemeinsame Schnittstelle - viele Implementierungen" </blockquote><p>  <strong>Dynamischer Versand ohne virtuelle Tabelle</strong> </p><br><p>  Denken Sie daran, dass die Definition der korrekten Implementierung der Methode beim Arbeiten mit Klassen (Referenztypen) durch Dynamic Submission und eine virtuelle Tabelle erreicht wird.  Jeder Klassentyp verf√ºgt √ºber eine virtuelle Tabelle, in der Implementierungen seiner Methoden gespeichert sind.  Der dynamische Versand definiert die Methodenimplementierung f√ºr einen Typ, indem er in seine virtuelle Tabelle schaut.  All dies ist aufgrund der M√∂glichkeit der Vererbung und des √úberschreibens von Methoden erforderlich. </p><br><p>  Bei Strukturen ist eine Vererbung sowie eine Neudefinition von Methoden nicht m√∂glich.  Auf den ersten Blick ist dann keine virtuelle Tabelle erforderlich, aber wie funktioniert dann der dynamische Versand?  Wie kann ein Programm verstehen, welche Methode auf d.draw () aufgerufen wird? </p><br><blockquote>  Es ist anzumerken, dass die Anzahl der Implementierungen dieser Methode gleich der Anzahl der Typen ist, die dem Drawable-Protokoll entsprechen. </blockquote><br><h2 id="protocol-witness-table">  <strong>Protokoll Zeuge Tabelle</strong> </h2><br><p>  ist die Antwort auf diese Frage.  Jeder Typ, der ein Protokoll implementiert, hat diese Tabelle.  Wie eine virtuelle Tabelle f√ºr Klassen werden Implementierungen der f√ºr das Protokoll erforderlichen Methoden gespeichert. </p><br><blockquote>  Im Folgenden wird die Protokollzeugen-Tabelle als "Protokoll-Methodentabelle" bezeichnet. </blockquote><p>  Ok, jetzt wissen wir, wo wir nach Methodenimplementierungen suchen m√ºssen.  Es bleiben nur zwei Fragen: </p><br><ol><li>  Wie finde ich die entsprechende Protokoll-Methodentabelle f√ºr ein Objekt, das dieses Protokoll implementiert hat?  Wie finden Sie in unserem Fall diese Tabelle f√ºr das Element d des Zeichnungsarrays? </li><li>  Die Elemente des Arrays m√ºssen dieselbe Gr√∂√üe haben (dies ist der Kern des Arrays).  Wie kann dann ein zeichnbares Array diese Anforderung erf√ºllen, wenn es sowohl Linie als auch Punkt darin speichern kann und sie unterschiedliche Gr√∂√üen haben? </li></ol><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)) <span class="hljs-comment"><span class="hljs-comment">// 32 bits MemoryLayout.size(ofValue: Point(...)) // 16 bits</span></span></code> </pre> <br><h3 id="ekzistencialnyy-konteyner">  Existenzieller Container </h3><br><p>  Um diese beiden Probleme zu beheben, verwendet Swift ein spezielles Speicherschema f√ºr Instanzen von Protokolltypen, die als existenzieller Container bezeichnet werden.  Es sieht so aus: </p><br><p><img src="https://habrastorage.org/webt/ru/nt/v_/runtv_rsqkbtwyq0soofiqidbde.jpeg"></p><br><p>  Es werden 5 Maschinenw√∂rter ben√∂tigt (im x64-Bit-System 5 * 8 = 40 Bit).  Es ist in drei Teile gegliedert: </p><br><p>  Wertepuffer - Speicherplatz f√ºr die Instanz selbst <br>  vwt - Zeiger auf Value Witness Table <br>  pwt - Zeiger auf die Protokollzeugen-Tabelle </p><br><p>  Betrachten Sie alle drei Teile genauer: </p><br><p>  <strong>Inhaltspuffer</strong> </p><br><p>  Nur drei Maschinenw√∂rter zum Speichern einer Instanz.  Wenn die Instanz in den Inhaltspuffer passen kann, wird sie darin gespeichert.  Wenn die Instanz mehr als 3 Maschinenw√∂rter enth√§lt, passt sie nicht in den Puffer und das Programm wird gezwungen, Speicher auf dem Heap zuzuweisen, die Instanz dort abzulegen und einen Zeiger auf diesen Speicher in den Inhaltspuffer zu setzen.  Betrachten Sie ein Beispiel: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...)</code> </pre> <br><p>  Point () belegt 2 Maschinenw√∂rter und passt perfekt in den Wertepuffer - das Programm legt es dort ab: </p><br><p><img src="https://habrastorage.org/webt/c3/it/ir/c3itirb85eqbbrvpop_9jstl0vm.jpeg"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)</code> </pre> <br><p>  Zeile () belegt 4 Maschinenw√∂rter und kann nicht in einen Wertepuffer passen - das Programm weist ihm Speicher f√ºr den Heap zu und f√ºgt einen Zeiger auf diesen Speicher im Wertepuffer hinzu: </p><br><p><img src="https://habrastorage.org/webt/jm/5w/yj/jm5wyjsk6zazutscdsx8a1a32y4.jpeg"></p><br><p>  ptr zeigt auf eine Instanz von Line () auf dem Heap: </p><br><p><img src="https://habrastorage.org/webt/we/sk/td/wesktdeuiw6iypty_2dkbklezgm.jpeg"></p><br><p>  <strong>Lebenszyklustabelle</strong> </p><br><p>  Neben der Protokoll-Methodentabelle hat jede Tabelle, die das Protokoll enth√§lt, diese Tabelle.  Es enth√§lt eine Implementierung von vier Methoden: Zuweisen, Kopieren, Zerst√∂ren, Freigeben.  Diese Methoden steuern den gesamten Lebenszyklus eines Objekts.  Betrachten Sie ein Beispiel: </p><br><ol><li>  Beim Erstellen eines Objekts (Punkt (...) als Zeichenobjekt) wird die Zuweisungsmethode von T.Zh.  dieses Objekt.  Die Zuweisungsmethode entscheidet, wo der Inhalt des Objekts abgelegt werden soll (im Wertepuffer oder auf dem Heap). Wenn er auf dem Heap abgelegt werden soll, weist er die erforderliche Speichermenge zu </li><li>  Die Kopiermethode platziert den Inhalt des Objekts an der entsprechenden Stelle. </li><li>  Nach Abschluss der Arbeit mit dem Objekt wird die Destruct-Methode aufgerufen, die alle Verkn√ºpfungsz√§hlungen, falls vorhanden, reduziert </li><li>  Nach der Zerst√∂rung wird die Freigabemethode aufgerufen, die den auf dem Heap zugewiesenen Speicher freigibt, falls vorhanden </li></ol><br><p>  <strong>Protokoll Methodentabelle</strong> </p><br><p>  Wie oben beschrieben, enth√§lt es Implementierungen der Methoden, die das Protokoll f√ºr den Typ ben√∂tigt, an den diese Tabelle gebunden ist. </p><br><p>  <strong>Existenzcontainer - Antworten</strong> </p><br><p>  Wir haben also zwei Fragen beantwortet: </p><br><ol><li>  Die Protokoll-Methodentabelle ist im Existential-Container dieses Objekts gespeichert und kann leicht von diesem abgerufen werden </li><li>  Wenn der Elementtyp des Arrays ein Protokoll ist, nimmt jedes Element dieses Arrays einen festen Wert von 5 Maschinenw√∂rtern an - genau das ist f√ºr einen existenziellen Container erforderlich.  Wenn der Inhalt des Elements nicht im Wertepuffer abgelegt werden kann, wird er auf dem Heap abgelegt.  Wenn dies m√∂glich ist, wird der gesamte Inhalt in den Wertepuffer gestellt.  In jedem Fall erhalten wir, dass die Gr√∂√üe des Objekts mit dem Protokolltyp 5 Maschinenw√∂rter (40 Bit) betr√§gt, und daraus folgt, dass alle Elemente des Arrays dieselbe Gr√∂√üe haben. </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: line) <span class="hljs-comment"><span class="hljs-comment">// 40 bits let drawables: [Drawable] = [Line(...), Point(...), Line(...)] MemoryLayout.size(ofValue: drawables._content) // 120 bits</span></span></code> </pre> <br><p>  <strong>Existenzcontainer - Beispiel</strong> </p><br><p>  Betrachten Sie das Verhalten eines existenziellen Containers in diesem Code: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) drawACopy(val)</code> </pre> <br><p>  Ein existenzieller Container kann folgenderma√üen dargestellt werden: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistContDrawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBuffer: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vwt: <span class="hljs-type"><span class="hljs-type">ValueWitnessTable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwt: <span class="hljs-type"><span class="hljs-type">ProtocolWitnessTable</span></span> }</code> </pre> <br><p>  <strong>Pseudocode</strong> </p><br><p>  Hinter den Kulissen nimmt die drawACopy-Funktion ExistContDrawable auf: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... }</code> </pre> <br><p>  Der Funktionsparameter wird manuell erstellt: Erstellen Sie einen Container, f√ºllen Sie seine Felder aus dem empfangenen Argument: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> local = <span class="hljs-type"><span class="hljs-type">ExistContDrawable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vwt = val.vwt <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pwt = val.pwt local.type = type local.pwt = pwt ... }</code> </pre> <br><p>  Wir entscheiden, wo der Inhalt gespeichert wird (im Puffer oder Heap).  Wir rufen vwt.allocate und vwt.copy auf, um den lokalen Inhalt mit val zu f√ºllen: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.allocateBufferAndCopy(&amp;local, val) }</code> </pre> <br><p>  Wir rufen die Zeichenmethode auf und √ºbergeben ihr einen Zeiger auf self (die projectBuffer-Methode entscheidet, wo sich self befindet - im Puffer oder auf dem Heap - und gibt den richtigen Zeiger zur√ºck): </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... pwt.draw(vwt.projectBuffer(&amp;local)) }</code> </pre> <br><p>  Wir beenden die Arbeit mit lokalen.  Wir s√§ubern alle angesagten Links von lokalen.  Die Funktion gibt einen Wert zur√ºck - wir l√∂schen den gesamten f√ºr drawACopy (Stapelrahmen) zugewiesenen Speicher: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.destructAndDeallocateBuffer(&amp;local) }</code> </pre> <br><p>  <strong>Existenzieller Container - Zweck</strong> </p><br><p>  Die Verwendung eines existenziellen Containers erfordert viel Arbeit - das obige Beispiel hat dies best√§tigt - aber warum ist es √ºberhaupt notwendig, was ist der Zweck?  Ziel ist es, Polymorphismus mit Hilfe von Protokollen und den Typen, die diese implementieren, zu implementieren.  In OOP verwenden wir abstrakte Klassen und erben von ihnen durch √úberschreiben von Methoden.  In EPP verwenden wir Protokolle und setzen deren Anforderungen um.  Auch bei Protokollen ist die Implementierung von Polymorphismus eine gro√üe und energieaufwendige Aufgabe.  Um "unn√∂tige" Arbeit zu vermeiden, m√ºssen Sie daher verstehen, wann Polymorphismus erforderlich ist und wann nicht. </p><br><p>  Polymorphismus bei der Implementierung von EPP gewinnt durch die Tatsache, dass bei Verwendung von Strukturen keine konstante Referenzz√§hlung erforderlich ist und keine Klassenvererbung erfolgt.  Ja, alles ist sehr √§hnlich. Klassen verwenden eine virtuelle Tabelle, um die Implementierung einer Methode zu bestimmen. Protokolle verwenden die Protokollmethode.  Es werden Klassen auf den Haufen gelegt, manchmal k√∂nnen auch Strukturen dort platziert werden.  Das Problem ist jedoch, dass so viele Zeiger wie m√∂glich auf die auf dem Heap platzierte Klasse gerichtet werden k√∂nnen und eine Referenzz√§hlung erforderlich ist und nur ein Zeiger auf die auf dem Heap platzierten Strukturen in einem existenziellen Container gespeichert ist. </p><br><p>  In der Tat ist es wichtig zu beachten, dass eine Struktur, die in einem existenziellen Container gespeichert ist, die Semantik von Werttypen beibeh√§lt, unabh√§ngig davon, ob sie auf dem Stapel oder dem Heap platziert wird.  Die Lebenszyklustabelle ist f√ºr die Erhaltung der Semantik verantwortlich, da sie Methoden beschreibt, die die Semantik bestimmen. </p><br><p>  <strong>Existenzieller Container - Gespeicherte Eigenschaften</strong> </p><br><p>  Wir haben untersucht, wie eine protokollartige Variable von einer Funktion √ºbergeben und verwendet wird.  Betrachten wir, wie solche Variablen gespeichert werden: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> f: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> s: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>) { first = f second = s } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Line</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>())</code> </pre> <br><p>  Wie werden diese beiden Drawable-Strukturen in der Pair-Struktur gespeichert?  Was ist der Inhalt des Paares?  Es besteht aus zwei existenziellen Containern - einem f√ºr den ersten und einem f√ºr den zweiten.  Zeile passt nicht in den Puffer und wird auf den Heap gelegt.  Punkt in den Puffer passen.  Die Pair-Struktur kann auch Objekte unterschiedlicher Gr√∂√üe speichern: </p><br><pre> <code class="swift hljs">pair.second = <span class="hljs-type"><span class="hljs-type">Line</span></span>()</code> </pre> <br><p>  Jetzt wird auch der Inhalt von second auf den Heap gelegt, da er nicht in den Puffer passt.  √úberlegen Sie, wozu dies f√ºhren kann: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Nach dem Ausf√ºhren dieses Codes erh√§lt das Programm den folgenden Speicherstatus: </p><br><p><img src="https://habrastorage.org/webt/yp/qz/td/ypqztdofriyggwgvlrl2rc3wvtc.jpeg"></p><br><p>  Wir haben 4 Speicherzuordnungen auf dem Heap, was nicht gut ist.  Versuchen wir Folgendes zu beheben: </p><br><ol><li>  Erstellen Sie eine analoge Klassenlinie </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineStorage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><ol><li>  Wir verwenden es paarweise </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lineStorage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(lineStorage, lineStorage) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Wir bekommen eine Platzierung auf dem Haufen und 4 Zeiger darauf: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  Wir haben es aber mit referentiellem Verhalten zu tun.  Das √Ñndern von copy.first wirkt sich auf pair.first aus (dasselbe gilt f√ºr .second), was nicht immer das ist, was wir wollen. </p><br><p>  <strong>Indirektes Speichern und Kopieren bei √Ñnderung (Copy-on-Write)</strong> </p><br><p>  Davor wurde erw√§hnt, dass String eine Copy-on-Write-Struktur ist (speichert seinen Inhalt auf dem Heap und kopiert ihn, wenn er sich √§ndert).  √úberlegen Sie, wie Sie Ihre Struktur implementieren k√∂nnen, die beim √Ñndern kopiert wird: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BetterLine</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storage: <span class="hljs-type"><span class="hljs-type">LineStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isKnownUniquelyReferenced(&amp;storage) { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage) } <span class="hljs-comment"><span class="hljs-comment">// storage editing } }</span></span></code> </pre> <br><ol><li>  BetterLine speichert alle Eigenschaften im Speicher. Der Speicher ist eine Klasse und wird auf dem Heap gespeichert. </li><li>  Der Speicher kann nur mit der Verschiebungsmethode ge√§ndert werden.  Darin √ºberpr√ºfen wir, dass nur ein Zeiger auf Speicher verweist.  Wenn es mehr Zeiger gibt, teilt diese BetterLine den Speicher mit jemandem. Damit sich BetterLine vollst√§ndig als Struktur verh√§lt, muss der Speicher individuell sein - wir erstellen eine Kopie und arbeiten in Zukunft damit. </li></ol><br><p>  Mal sehen, wie es im Speicher funktioniert: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">BetterLine</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair copy.second.x1 = <span class="hljs-number"><span class="hljs-number">3.0</span></span></code> </pre> <br><p>  Als Ergebnis der Ausf√ºhrung dieses Codes erhalten wir: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  Mit anderen Worten, wir haben zwei Instanzen von Pair, die sich denselben Speicher teilen: LineStorage.  Wenn Sie den Speicher in einem seiner Benutzer √§ndern (erster / zweiter), wird eine separate Kopie des Speichers f√ºr diesen Benutzer erstellt, damit sich die √Ñnderung nicht auf andere auswirkt.  Dies l√∂st das Problem der Verletzung der Semantik von Werttypen aus dem vorherigen Beispiel. </p><br><h2 id="protokolnye-tipy---itog">  Protokolltypen - Zusammenfassung </h2><br><ol><li>  <em>Kleine Werte</em> .  Wenn wir mit Objekten arbeiten, die wenig Speicherplatz beanspruchen und im Puffer eines existenziellen Containers abgelegt werden k√∂nnen, dann: </li></ol><br><ul><li>  Es wird keine Platzierung auf dem Haufen geben </li><li>  keine Referenzz√§hlung </li><li>  Polymorphismus (dynamisches Senden) unter Verwendung einer Protokolltabelle </li></ul><br><ol><li>  <em>Tolles Preis-Leistungs-Verh√§ltnis.</em>  Wenn wir mit Objekten arbeiten, die nicht in den Puffer passen, dann: </li></ol><br><ul><li>  Haufenplatzierung </li><li>  Referenzz√§hlung, wenn Objekte Verkn√ºpfungen enthalten. </li></ul><br><blockquote>  Die Mechanismen der Verwendung des Umschreibens f√ºr √Ñnderungen und indirekte Speicherung wurden demonstriert und k√∂nnen die Situation mit Referenzz√§hlung bei einer gro√üen Anzahl von ihnen erheblich verbessern. </blockquote><p>  Wir haben festgestellt, dass Protokolltypen wie Klassen in der Lage sind, Polymorphismus zu realisieren.  Dies geschieht durch Speichern in einem existenziellen Container und Verwenden von Protokolltabellen - Lebenszyklustabellen und Protokollmethodentabellen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474558/">https://habr.com/ru/post/de474558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474546/index.html">Von Terraform zu CloudFormation gewechselt - und es bereut</a></li>
<li><a href="../de474548/index.html">Google BERT ist ein neuer Suchalgorithmus. Wie wird sich das Ranking √§ndern und was ist jetzt zu tun?</a></li>
<li><a href="../de474550/index.html">Wie kann ich die gr√ºne TLS-Anzeige im neuen Firefox 70 zur√ºckgeben?</a></li>
<li><a href="../de474554/index.html">Intel Tremont - Neue Mikroarchitektur f√ºr Energieeffizienz</a></li>
<li><a href="../de474556/index.html">So machen Sie PCRE2-Unterst√ºtzung f√ºr Apache 2.4</a></li>
<li><a href="../de474560/index.html">In 4 Schritten vom √ñkonomen zum Custom Development Manager oder zur IT, um mit Langeweile umzugehen</a></li>
<li><a href="../de474562/index.html">LEGO MINDSTORMS Education EV3 + MicroPython: Wir programmieren einen Kinderkonstruktor in einer Sprache f√ºr Erwachsene</a></li>
<li><a href="../de474564/index.html">Autosampler - Leben nach Leben</a></li>
<li><a href="../de474566/index.html">Diese Stadt braucht einen neuen Helden: eine √úberpr√ºfung der diebstahlsicheren Rucks√§cke von Bobby Hero</a></li>
<li><a href="../de474568/index.html">Milch von den Z√§hnen: ein Berufswechsel f√ºr Zellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>