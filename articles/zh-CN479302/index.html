<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♒️ 👨‍👩‍👧‍👧 Ⓜ️ Unity Shader Graph基础 👨‍🔧 💕 🗺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="着色器是一个小型程序，其中包含针对GPU的指令。 它描述了如何计算特定材料的屏幕颜色。 

 尽管Unity具有标准着色器，但有时您需要实现标准着色器无法提供的效果。 

 以前，这需要特定着色器语言（例如Cg或HLSL）的知识，并且其中的方法与通常创建游戏脚本的方式略有不同。 对于许多人来说，编写...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Shader Graph基础</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479302/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/f7b/1ff/78ff7b1ff1bc94d8a45e9b1f52e2ff2e.jpg" alt="图片"></div><br> 着色器是一个小型程序，其中包含针对GPU的指令。 它描述了如何计算特定材料的屏幕颜色。 <br><br> 尽管Unity具有标准着色器，但有时您需要实现标准着色器无法提供的效果。 <br><br> 以前，这需要特定着色器语言（例如Cg或HLSL）的知识，并且其中的方法与通常创建游戏脚本的方式略有不同。 对于许多人来说，编写着色器是游戏开发中不受欢迎的方面，因为它需要开发其他学习曲线。 <br><br>  Unity引入了<strong>Shader Graph</strong> ，这使编写几乎不需要代码的着色器变得更加容易。 最重要的是，Shader Graph允许您使用可视的交互式界面。 <br><br> 在本教程中，您将创建第一个Unity着色器！ <br><a name="habracut"></a><br><h2> 开始工作 </h2><br> 本教程使用Unity 2019.1或更高版本。 在<a href="https://unity3d.com/get-unity/update">此处</a>下载新版本的Unity。 <br><br><blockquote>  <em>注意</em> ：尽管本教程是供Shader Graph的初学者使用的，但假定您已了解Unity中开发的基础知识并已掌握引擎的界面。 如果您不熟悉Unity，请查看出色的<a href="https://www.raywenderlich.com/5589-unity-tutorial-part-1-getting-started" rel="noopener">Unity入门</a>教程。 </blockquote><br> 在<a href="">此处</a>下载教程材料。 然后解压缩内容并在Unity中打开“ <strong>Shader Graph Starter简介”</strong> 。 <br><br>  “项目”窗口中的<strong>RW</strong>文件夹的组织方式如下： <br><br><ul><li>  <strong>字体</strong> ：场景中使用的字体。 </li><li>  <strong>材料</strong> ：用于场景的材料。 </li><li>  <strong>模型</strong> ：游戏形状和背景的3D网格。 </li><li>  <strong>PostFX</strong> ：场景渲染的后处理效果。 </li><li>  <strong>预制件</strong> ：各种预制组件。 </li><li>  <strong>场景</strong> ：游戏场景。 </li><li>  <strong>脚本</strong> ：具有游戏逻辑的脚本。 </li><li>  <strong>着色器</strong> ：为本教程创建的<strong>着色</strong>器图。 </li><li>  <strong>精灵</strong> ：用作说明一部分的精灵。 </li><li>  <strong>纹理</strong> ：游戏形状和背景的纹理贴图。 </li></ul><br> 现在从“ <b>场景”</b>文件夹中加载“ <b>七巧板拼图</b> ” <b>场景</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/174/581/b8e1745819cb97e299c2d2216323a498.jpg"></div><br> 这是一个名为<b>七巧板</b>的简单游戏，它于19世纪在中国出现。 玩家的任务是移动七个平坦的几何形状，使其成为程式化的象形图或轮廓。 <br><br> 在编辑器中启动“ <b>播放”</b>模式并测试演示游戏。 <br><br> 您可以单击形状并将其拖动。 使用方向键旋转形状。 旋转和移动形状，以使它们彼此不重叠。 <br><br> 您能弄清楚如何移动这七个形状来创建这样的图案吗？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/59c/f3b/a8059cf3b9b0a92a0bd6439768cca473.jpg"></div><br> 因此，从<i>技术</i>角度来看，该游戏可以运行，但不会提供有关所选图形的任何视觉反馈。 <br><br> 如果我们可以在鼠标悬停在其上方时使形状发光怎么办？ 这将改善用户界面。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/aba/5ec/dddaba5ecb269c55ff4ed734565dd44d.jpg"></div><br> 这是展示Shader Graph功能的绝好机会！ <br><br><h2> 检查着色器图的管线参数 </h2><br>  Shader Graph仅适用于相对较新的<b>可编写脚本的渲染管线</b> ，即适用于<em>High-Definition Render Pipeline</em>或<em>Lightweight Render Pipeline</em> 。 <br><br> 创建用于使用Shader Graph的新项目时，请选择正确的模板。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/213/6b1/315/2136b13151945e40c96e3ebb592ca1c5.jpg"></div><br> 该示例项目已配置为可与“ <b>轻量级渲染管道”一起使用</b> 。 首先，在PackageManager中，选择<b>Window►PackageManager</b> ，确认您已安装<b>Lightweight RP</b>和<b>ShaderGraph</b>软件包。 <br><br> 然后选择可用版本之一，如有必要，请单击<b>更新到</b>按钮。 通常，最好的选择是最新的<i>验证</i>版本。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/d1c/a7d/54cd1ca7dd3795ea4c4deed83b04566d.jpg"></div><br> 更新软件包后，请在“ <b>编辑”►“项目设置”中</b>仔细检查管道参数的正确性。 <br><br> 在“ <b>图形”</b>选项卡上，“ <b>可编写脚本的渲染管道设置”</b>参数应设置为<b>LWRP-HighQuality</b> 。 因此，项目将为“轻量级渲染管道”使用最高的默认设置。 <br><br> 确保使用<b>脚本编写的渲染管道</b>资源之一后，关闭此窗口。 <br><br><h2> 创建PBR图 </h2><br> 在屏幕上渲染3D网格时，材质和着色器始终协同工作。 因此，在开始创建着色器之前，我们需要材料。 <br><br> 首先，在“项目”窗口中单击“ <b>创建”</b>按钮，以在<b>RW /材料</b>文件夹中生成新材料。 选择<b>创建►材质</b> ，然后将其重命名为<b>Glow_Mat</b> 。 <br><br> 然后，在<b>RW / Shaders</b>文件夹中，通过选择<b>创建</b> <b>►Shader►PBR Graph</b>来<b>创建PBR图</b> 。 这是一个着色器图形，支持<i>物理上精确的渲染</i>或PBR。 <br><br> 将其命名为<b>HighlightShaderGraph</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a22/1f8/52e/a221f852e2e1e71f73482ed388374495.gif"></div><br> 到目前为止，“材质Glow_Mat”使用<b>LightweightRenderPipeline</b>的标准着色器，称为<b>LightweightRenderPipeline /Lit。</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/eeb/d28/39feebd289c2fbf6363ddcc24f6e0789.gif"></div><br> 将其更改为新创建的新着色器图。 选择<strong>Glow_Mat后</strong> ，单击检查<b>器</b>顶部的“ <b>Shader”</b>下拉菜单，然后选择“ <b>Shader Graphs”</b> <strong>►HighlightShaderGraph</strong> 。 <br><br>  Glow_Mat会呈现较浅的灰色阴影，但其他情况下将保持沉闷。 不用担心，我们会尽快修复。 <br><br> 现在，双击<b>HighlightShaderGraph</b>资产或在检查<b>器</b>中单击“ <b>打开着色器编辑器</b> ”。 这将打开“ <strong>Shader Graph”</strong>窗口。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/365/141/7f1365141746fb31c6b7226b4da4b35d.gif"></div><br> 查看此界面的主要部分： <br><br><ul><li>  <b>主工作区</b>是一个深灰色区域，将在其中存储图形操作。 您可以右键单击工作区以打开上下文菜单。 </li><li>  <b>节点</b>是图的单个元素。 每个节点都有一个输入，输出或操作，具体取决于其端口。 节点使用<b>edge</b>彼此连接。 </li><li>  <b>主节点</b>是图形的最后一个输出节点。 在此示例中，我们使用物理上准确的渲染选项，也称为PBR主节点。 您可能会注意到其中的某些属性，例如标准明暗器中使用的反照率，法线，发射和金属。 </li><li>  <b>黑板</b>可以提供对检查器中图形某些部分的访问。 这样，用户无需直接编辑图形本身即可配置参数。 </li><li>  <b>主预览以</b>交互方式将着色器的当前输出显示为球体。 </li></ul><br> 通过连接各个节点，您可以创建一个<b>着色器图</b> ，Unity可以将该<b>着色器图</b>编译并传输到GPU。 <br><br><h2> 创建一个颜色节点 </h2><br> 首先，让我们为着色器提供一些基本颜色。 为此，请将颜色节点与PBR主节点的Albedo组件相连。  <b>右键单击</b>工作区以通过选择<b>创建节点►输入►基本►颜色</b>从上下文菜单创建第一个节点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/509/a40/363509a4051583a7535f3dac08f5112a.gif"></div><br> 请注意，“ <b>创建节点”</b>菜单中有数百个节点！ 乍一看似乎令人困惑，但是您很快就会发现最常用的那些。 <br><br> 接下来，将节点拖到工作区上，并保持其标题栏不变。 然后将其放在<b>PBR主</b>节点左侧的某个位置。 <br><br>  “ <b>颜色”节点</b>允许您指定一种颜色。 单击颜色字段，然后选择漂亮的红色，例如<b>R：128，G：5，B：5</b> 。 <br><br> 要将颜色输出到<b>PBR主</b>节点，请将“ <b>输出”</b>端口拖到<b>Albedo</b>端口，该端口指示着色器的基本颜色。 <br><br> 通过并排连接节点，您应该看到“ <b>主预览</b> ”中的球体如何变为红色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/3f4/19d/f7c3f419dbd4caca163997b64b15df35.jpg"></div><br> 太好了！ 在编写着色器方面，创建单色着色器类似于<em>Hello world！</em> <br><br> 尽管您可能还不了解这一点，但是您只是创建了第一个着色器！ <br><br><h2> 使用界面 </h2><br> 尽管图中只有几个节点，但现在是适应Shader Graph界面的最佳时间。 <br><br> 尝试拖动节点，请注意<b>彩色</b>输出端口和<b>PBR主</b>输入端口之间的边缘保持连接。 <br><br> 节点可以包含各种类型的数据。 就像我们创建一个包含单个输入颜色的节点一样，我们可以创建一个代表单个数字的节点。 选择<b>创建节点►输入►基本►整数</b> 。 我们不会对该节点做任何事情；仅需说明原理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36f/82d/64f/36f82d64fb65d569c0471e419191a5e4.jpg"></div><br> 将<b>Integer Out</b>端口连接到<b>PBR主</b>节点的<b>Alpha</b>端口。 <br><br> 我们的图仍然很小，但是我们已经有足够的节点来检查热键的动作。 选择一对节点，然后按以下键： <br><br><ul><li>  <b>F</b> ：框住所选节点。 </li><li>  <b>A</b> ：构图整个图。 </li></ul><br> 您也可以使用窗口顶部的按钮在<b>Main Preview</b>和<b>Blackboard</b>之间切换。  “ <b>在项目中显示”</b>按钮有助于在“项目”窗口中找到当前的着色器图形。 <br><br> 处理完图形的管理后，我们将其清除。 我们需要的只是<b>Color</b>和<b>PBR Master</b>节点。 <br><br> 右键单击<b>Integer</b>和<b>Master</b>节点之间的连接，然后选择<b>Delete</b> 。 这会将节点与图形分开。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/bf4/3b1/4c4bf43b168f47d748443962faa62b77.jpg"></div><br> 同样，您可以完全删除<b>Integer</b>节点。 右键单击该节点，然后选择“ <b>删除”</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/ddc/87c/1b9ddc87cdf18aac23371e3f9fcb1362.jpg"></div><br> 完成后，单击界面左上角的“ <b>保存资产”</b>按钮。  Unity将保存所有更改，然后编译并激活着色器。 每当您要在编辑器中查看最新更改时，都应执行此步骤。 <br><br> 现在回到窗口并选择<b>Glow_Mat</b>材料。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/e45/8c8/886e458c866aa26b261adaa95677372d.jpg"></div><br> 随着着色器延伸到材质，检查器的预览窗口中的球体应变为红色。 <br><br> 现在，将“ <b>Glow_Mat”</b>材质<b>拖到</b> “ <b>场景”</b>窗口中的七巧板形状上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/044/2d4/5ef0442d42d3391f07152f1842ddc342.gif"></div><br> 不出所料，带有着色器的材质将网格物体涂成美丽，均匀的红色。 <br><br><h2> 添加发光效果 </h2><br> 如果希望Glow_Mat材质具有更神秘的发光效果，则需要再次编辑着色器图。 <br><br> 现在， <b>颜色</b>输出将传输到<b>Albedo</b> <b>PBR主</b>节点的输入。 <br><br> 您也可以将另一条边从“ <b>出”</b>拖到<b>“</b> <b>发射”</b> 。 现在，两次使用相同的颜色：既用作基础颜色，又用作辐射线的颜色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/4dc/2e0/1854dc2e00739e3a8c9ea765faa8771d.jpg"></div><br> 输出端口可以有多个边，输入端口只能有一个。 <br><br> 现在，将“ <b>颜色”</b>节点的“ <b>模式”</b>下拉菜单切换为<b>HDR</b>模式。 因此，我们将包括<i>扩展</i>的颜色<i>动态</i>范围。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb3/562/3ac/fb35623acdb347bffaeb33925936e936.jpg"></div><br> 现在更改颜色字段。 在<b>HDR模式下</b> ，出现了其他<b>强度</b>选项。 在底部面板中单击<b>+1</b>两次，或将滑块拖动到<b>2.5</b>左右。 现在保存更改并返回编辑器。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/55d/b51/35055db513df608effa2f27b1956c83f.png"></div><br> 在编辑器中，该图将以亮橙色发光。 场景中的后处理功能已经启用，它可以增强动态范围的色彩。 <br><br> 现在，在层次结构中选择游戏对象<b>PostProcessing</b> 。 发光是由于<b>布隆</b>效应。 <br><br> 打开“ <b>Bloom”</b>选项，然后设置“ <b>强度”</b> （发光强度）和“ <b>阈值”</b> （发光起始阈值）。 该示例显示值<b>3</b>和<b>2</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/999/c29/c83999c293634a90fd3f4f93c2444a82.jpg"></div><br> 哇，这闪耀！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1c/f3e/a78/f1cf3ea784a21f33d2e5c1417e7d7fd5.jpg"></div><br><h2> 创建突出显示脚本 </h2><br> 我们不希望人物不断发光。 我们需要仅根据鼠标的位置打开发光。 <br><br> 当鼠标光标悬停在形状上时，我们必须启用Glow_Mat材料。 在其他情况下，该图应与标准材料Wood_Mat一起显示。 <br><br> 首先，在<strong>RW /脚本中</strong>创建一个新的<b>C＃</b>脚本，并将其命名为<strong>Highlighter</strong> 。 他将帮助我们在程序执行期间在两种材料之间切换。 用以下代码替换脚本中的所有行： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-comment"><span class="hljs-comment">// 1 [RequireComponent(typeof(MeshRenderer))] [RequireComponent(typeof(Collider))] public class Highlighter : MonoBehaviour { // 2 // reference to MeshRenderer component private MeshRenderer meshRenderer; [SerializeField] private Material originalMaterial; [SerializeField] private Material highlightedMaterial; void Start() { // 3 // cache a reference to the MeshRenderer meshRenderer = GetComponent&lt;MeshRenderer&gt;(); // 4 // use non-highlighted material by default EnableHighlight(false); } // toggle betweeen the original and highlighted materials public void EnableHighlight(bool onOff) { // 5 if (meshRenderer != null &amp;&amp; originalMaterial != null &amp;&amp; highlightedMaterial != null) { // 6 meshRenderer.material = onOff ? highlightedMaterial : originalMaterial; } } }</span></span></code> </pre> <br> 让我们分析一下这个脚本： <br><br><ol><li> 该脚本只能应用于包含组件<code>MeshRenderer</code>和<code>Collider</code>的对象。 这是通过将<code>[RequireComponent]</code>属性添加到脚本顶部来控制的。 </li><li> 这些是指向<code>MeshRenderer</code> ， <code>originalMaterial</code>和<code>MeshRenderer</code>链接。 用<code>[SerializeField]</code>属性标记材料，该属性使您可以从检查器分配它们。 </li><li> 在<code>Start</code>方法中，我们使用<code>GetComponent</code>自动填充<code>GetComponent</code> 。 </li><li> 称为<code>EnableHighlight(false)</code> 。 这可以确保默认情况下显示非突出显示的内容。 下面是公共的<code>EnableHighlight</code>方法，该方法可切换渲染器材质。 它接收布尔参数<code>onOff</code> ，该参数确定背光的状态。 </li><li> 防止所有NullReference错误 </li><li> 为了节省空间，我们使用三元运算符。 </li></ol><br><h2> 添加鼠标事件 </h2><br> 由于此脚本适用于具有<code>MeshCollider</code>形状，因此我们可以使用内置方法<code>OnMouseOver</code>和<code>OnMouseOver</code> 。 在<code>EnableHighlight</code>方法之后添加以下代码： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseOver</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnableHighlight(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseExit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnableHighlight(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br> 当鼠标悬停在形状上时，它将调用<code>EnableHighlight(true)</code> 。 同样，当鼠标离开Collider时，它将调用<code>EnableHighlight(false)</code> 。 <br><br> 仅此而已！ 保存脚本。 <br><br><h2> 图高亮 </h2><br> 如果在本教程的前面各节中将Glow_Mat应用于任何图形，那么在编辑器中，您需要将Wood_Mat材质返回给所有游戏图形。 现在，要打开发光效果，我们将在程序运行时使用<b>荧光笔</b> 。 <br><br> 首先，我们将在变换<b>七巧板中</b>选择七个对象，它们是单独的形状。 然后，我们将所有<code>Highlighter</code>脚本同时添加到它们。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1d/99b/452/e1d99b452c4d7adffec90997fc53d296.jpg"></div><br> 然后将<b>Wood_Mat</b>拖到“ <b>原始材质”</b>字段中，将<b>Glow_Mat</b>拖到“ <b>突出显示的材质”</b> <b>字段中</b> 。 现在运行“ <b>播放”</b>模式并检查我们的工作结果。 <br><br> 还不错！ 当您将鼠标悬停在七巧板形状上时，它开始以亮红色发光。 如果从中删除光标，它将返回其原始状态。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d74/c09/f33/d74c09f333e899af67b3687733769285.gif"></div><br> 在游戏本身中，什么都没有改变，但是高光效果增加了视觉趣味并允许玩家专注。 <br><br><h2> 使用纹理节点 </h2><br> 目前，我们的简单着色器具有纯色亮红色。 我们将更改着色器，以使其不会丢失其原始的木材纹理。 为此，我们将使背光显示为表面<i>周围的</i>发光边缘。 <br><br> 首先，通过双击或选择来更改<b>HighlightShaderGraph</b> <br> 在<b>Open Shader Editor中</b> 。 <br><br>  <b>右键单击</b>并选择<b>Delete，</b>以删除<b>Color</b>节点。 我们将从头开始创建所有内容。 <br><br> 我们使用“ <b>Sample Texture 2D</b> ”（ <b>采样纹理2D）</b>节点代替单色，而不是单色。 <br><br>  <b>通过右键单击</b>并选择“ <b>创建节点”</b> ，或使用热键（空格），从上下文菜单<b>创建节点</b> 。 选择<b>输入►纹理►采样2D纹理</b> 。 <br><br>  <b>Sample Texture 2D</b>节点从纹理资产读取颜色信息并输出其RGB值。 <br><br> 从“ <b>纹理”</b>输入端口中选择一个纹理。 单击空白字段旁边的点以打开文件浏览器。 <br><br> 选择WoodAlbedo纹理<b>资产</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9a/97c/4fd/f9a97c4fd623492c7fa1352f52137a29.jpg"></div><br> 将<b>Sample Texture 2D</b>节点的<b>RGBA</b>输出端口连接到<b>PBR主Albedo</b>端口。 <br><br> 瞧！ 现在，树的纹理显示在预览球体的表面上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/340/f6f/c8a/340f6fc8ac69c61cf9b574b90964741c.jpg"></div><br> 如果添加法线贴图，则可以在曲面上创建零件。 首先，通过选择<b>创建节点►输入►纹理►样本纹理2D来</b>创建另一个<b>Sample Texture 2D</b>节点。 <br><br> 在“纹理”输入端口中选择一个<b>WoodNormal</b>纹理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed3/f17/157/ed3f17157cb757325db5ac5fff3063a2.jpg"></div><br> 将<b>类型</b>下拉菜单从<b>默认</b>更改为<b>普通</b> 。 <br><br> 将<b>RGBA</b>值输出到<b>PBR主</b>节点的“ <b>普通”</b>端口。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/269/2e2/c352692e26036e357e7ca5934371925f.jpg"></div><br> 现在，“ <b>主预览</b> ”的范围看起来应该更粗糙。 法线贴图模仿了表面上的小不规则和凹痕。 这使您可以模拟树的外观。 <br><br><blockquote>  <em>注意</em> ：每个端口的数据类型显示在端口旁边的括号中。  <b>（T2）</b>表示该端口与二维纹理兼容， <b>（4）</b>表示该端口使用<b>Vector4</b> 。 根据上下文，着色器图可能会忽略额外的浮点值。 </blockquote><br><h2> 添加菲涅耳效果 </h2><br> 现在，纯红色已更改为基本纹理和法线贴图，让我们使用另一种方法添加高光效果。 <br><br> 除了将整个对象均匀发光外，我们将发光仅限制在其边缘。 这可以使用<b>菲涅耳效应</b>来实现。 <br><br> 通过<b>右键单击</b>或空格键创建一个新节点，然后选择“ <b>创建节点”►“数学”►“向量”►“菲涅耳效应”</b> 。 <br><br> 这个新节点显示了一个直径为白色辐射环的球体。 您可以使用<b>电源</b>输入端口调整此光晕的宽度。 单击并将<b>X</b>拖动到该字段的左侧，或输入所需的数字。 <br><br> 值越大，光环变得越薄，值越小，使其变得非常宽。 要在边缘周围创建微妙的光晕，可以使用值<b>4</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f62/519/63c/f6251963c4a386e595c2e160213d061a.gif"></div><br> 为了将此光晕传达给材料，我们将<b>菲涅耳效果</b>输出连接到<b>PBR主</b>节点的“ <b>发射”</b>输入。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/135/f1d/6ac/135f1d6ac986df2f97eebb4ee4edc6aa.jpg"></div><br> 现在， <b>MainPreview</b>通过一个<b>菲涅耳效应</b>获得了一个带有明亮白色光晕的木质球体。 <br><br><blockquote>  <em>注意</em> ：菲涅耳效应是以法国物理学家奥古斯丁·让·菲涅尔的名字命名的。 他注意到，当观察者接近<i>滑行角</i>时，光线使表面非常明亮，看起来像镜子。 </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/137/921/1cb/1379211cb556a35dfe79d01d8db52ae2.gif"></div><br> 您可以尝试在厨房的桌子上用餐。 我们使用这种现象的Unity版本来给几何图形发光。 <br><br><h2> 颜色相乘 </h2><br> 您可以使用简单的颜色计算将颜色添加到发光轮廓。 <br><br> 创建一个新的颜色节点，该节点将指示发光环的颜色。  <b>右键单击</b>或用空格键打开上下文菜单，然后选择“ <b>创建”节点►“输入”►“基本”►“颜色”</b> 。 将色彩模式切换为<b>HDR</b> 。 <br><br> 选择一种将指示背光源颜色的颜色。 例如，选择一个美丽的亮绿色： <b>R：5，G：255，B：5</b> 。 <br><br> 将<b>强度</b>增加到<b>3.5</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d9/652/ad0/7d9652ad083521122e9079d850010e93.jpg"></div><br> 我们不能将新颜色与菲涅耳效果结合使用。 因为它没有颜色输入。 因此，我们需要将效果的输出与颜色节点的输出结合起来。 可以使用“ <b>乘”</b>节点来完成。 <br><br>  <b>右键单击</b>以创建一个<b>乘法</b>节点，然后选择<b>创建节点►数学►基本►乘法</b> 。 <br><br> 删除<b>菲涅耳效果</b>和<b>PBR主控</b>之间的边缘。 将<b>菲涅耳效果</b>输出连接到“ <b>乘”</b>节点的<b>A</b>输入。 <br><br> 将“ <b>颜色</b> <b>”</b>节点的“ <b>输出”</b>节点连接到<b>“</b> <b>乘”</b>节点的输入<b>B。</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da3/bc9/943/da3bc9943795de428ea498ce46d6f4b2.jpg"></div><br> 然后将<b>“</b> <b>乘出”</b>节点连接到<b>PBR主</b>节点的“ <b>发射”</b>端口。 瞧！ 现在，我们了解鲜绿色的HDR颜色如何围绕<b>主预览</b>球体。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13f/514/e08/13f514e08ea71acd0cc175279d7e6738.jpg"></div><br> 请记住，您可以使用<b>菲涅耳效果功率</b>来增加或减少光晕。 如果将该值减小到1.5，则会发出宽绿色的光。 <br><br> 对于我们的游戏示例，从<b>4</b>到<b>5</b>的值<b>是</b>好的，但是您可以尝试使用自己的值。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18a/13b/95d/18a13b95dbd4fea691a17a7f7fd9c2b1.jpg"></div><br> 保存着色器图形并返回到编辑器。 您将立即看到您的<b>HighlightShaderGraph</b>在起作用。 <br><br> 启动<b>播放</b>模式。 <br><br> 将鼠标悬停在形状上时，它会保留其树纹理。 但是，现在在其边缘周围出现了明亮的绿色光芒。 正式而言，游戏中什么都没有改变，只有背光变弱了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/f7b/1ff/78ff7b1ff1bc94d8a45e9b1f52e2ff2e.jpg"></div><br><h2> 添加黑板属性 </h2><br> 如果要更改发光效果的外观，则需要返回到“ Shader Graph”编辑器窗口并进行这些更改。 例如，使用<b>菲涅耳效果功率，</b>扩大或缩小晕圈。 <br><br> 如果我们要测试各种更改，这不是很方便。 幸运的是，Shader Graph具有属性的概念。 <br><br> 您可以在检查器中使图形的一部分公开可见，从而允许您交互式地进行小的更改。 这是使用<b>Blackboard</b>界面完成的。 <br><br> 返回到“着色器图”并打开“ <b>黑板”</b>显示。 如果它是隐藏的，则单击右上角的“ <b>黑板”</b>按钮。 <br><br><h3> 添加基础纹理和法线贴图属性 </h3><br> 现在，我们将同时打开基础纹理和法线贴图，以便可以通过检查器对其进行访问。 <br><br> 单击<b>Blackboard</b>右上角的<b>+</b>图标。 从下拉列表中选择“ <b>Texture 2D</b> ”。 该项目应出现在<b>黑板上</b> 。 将其重命名为<b>BaseTexture</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e15/b99/3bb/e15b993bb5c806ae0e00c65dfc7d6f18.jpg"></div><br> 确保已选中<b>暴露的</b>复选框。 如果您打开财产，它将在检查员中公开并可以访问。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/269/c8e/bea269c8e357d460265c573c3de1c706.jpg"></div><br> 要将属性添加到图形，只需将其通过标签拖动到工作区中即可。 将其放在“ <b>采样纹理2D”</b>节点左侧的某个位置。 <br><br> 将<b>BaseTexture</b>端口连接到连接到Albedo的<b>SampleTexture 2D</b>节点的<b>Texture</b>输入端口。 这将替代先前的设定值。 <br><br> 对<b>法线贴图</b>重复相同的过程。 单击<b>+</b>图标，然后创建一个新的<b>Texture 2D</b> 。 将其重命名为<b>法线贴图</b> 。 <br><br> 将属性拖到工作区中，并将其附加到法线贴图的<b>Sample Texture 2D</b>中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a19/0fd/324/a190fd3243a5e151df9d4354868f0906.jpg"></div><br> 单击<b>保存资产</b>并返回到主编辑器窗口。 <br><br> 选择<b>Glow_Mat</b>材质，并在检查器中注意两个新字段： <b>基本纹理</b>和<b>法线贴图</b> 。 <br><br> 由于尚未为其设置纹理，因此预览窗口中灰色球上方的绿色高亮显示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/b70/c88/3e7b70c8847d16294fb2a1ff0d03f455.jpg"></div><br>  <b>为</b> <b>BaseTexture</b>和<b>NormalMap</b>选择<b>WoodAlbedo</b>和<b>WoodNormal</b> 。 <br><br> 现在，在发光的边缘下，树的纹理将正确显示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe3/0b2/f5a/fe30b2f5ae65b3d25f0b86a0933737c6.jpg"></div><br> 公共属性允许用户直接将数据输入到着色器中，而无需编辑着色器图。 自己尝试各种不同的基本纹理和法线贴图。 <br><br><h3> 添加属性发光尺寸和发光颜色 </h3><br> 现在，我们将揭示Blackboard中的其他类型的属性。 例如，更改菲涅耳效果功率值将很有用。 <br><br> 单击<b>Blackboard</b>上的<b>+</b>图标，然后创建<b>Vector1</b>属性。 它表示float类型的单个参数。 <br><br> 将其重命名为<b>GlowSize</b> 。 <br><br> 您可以通过将其转换为<b>滑块</b>来限制为此属性输入的值的范围。 将“ <b>模式”</b>切换到“ <b>滑块”</b> ，然后将“ <b>最小值”</b>设置为<b>0.05</b> ，将“ <b>最大值”设置</b>为<b>6</b>以指定范围。 将<b>默认</b>值设置为<b>5</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2c/fba/b70/b2cfbab70c7b0597bc27953aab56cff9.jpg"></div><br> 将<b>GlowSize</b>属性拖到工作区中。 将输出端口连接到<b>菲涅耳效果电源</b>输入。 <br><br> 现在，让用户设置发光的颜色。 不用在Blackboard中创建属性，而是变换图形中的现有节点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14c/e33/445/14ce334459feee966f622d0d041bbf29.jpg"></div><br> 选择“ <b>颜色”</b>节点，然后<b>右键单击</b>并选择“ <b>转换为属性”</b> 。 <br><br>  “ <b>颜色”节点</b>在<b>Blackboard中</b>转换为color属性，不能再在图形中直接更改。 将属性重命名为<b>GlowColor</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/208/6fe/b82/2086feb822d8a23a18d61d1acfee2528.jpg"></div><br> 单击<b>保存资产</b>并返回到主编辑器窗口。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd1/a22/b42/cd1a22b4290547018d7fbb4b12424124.jpg"></div><br> 在“项目”窗口中选择<b>Glow_Mat</b>材料。 您应该看到<b>GlowSize</b>滑块和<b>GlowColor</b>字段现在在检查器中可用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/65c/339/07965c339c3a356635df7cc1add76c8a.jpg"></div><br> 根据您的口味更改材料值。 启动<em>播放</em>模式以测试您的工作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/d63/a65/adfd63a65155b52a0f5ef17be7feb823.gif"></div><br> 现在，您可以自定义背光，可以根据需要进行更改！ <br><br><h2> 接下来要去哪里 </h2><br> 恭喜你！ 现在，您可以使用“着色器图”创建自己的着色器！ <br><br> 利用自己的创造能力，您自己会为成功感到惊讶。 要创建一个很酷的梦幻激光束或力场吗？ 使我们的工作结果适应您所需的着色器。 <br><br> 尽管实际上有数百个节点，但是本教程应该可以帮助您学习Shader Graph。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479302/">https://habr.com/ru/post/zh-CN479302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479292/index.html">如何教一个神经网络重现游戏物理</a></li>
<li><a href="../zh-CN479294/index.html">通过创建EKS集群和环境面板发布了GitLab 12.5</a></li>
<li><a href="../zh-CN479296/index.html">我如何停止仇恨并爱上发展</a></li>
<li><a href="../zh-CN479298/index.html">PostgreSQL反模式：CTE x CTE</a></li>
<li><a href="../zh-CN479300/index.html">生态和数据中心。 在俄罗斯和国外，“绿色数据”</a></li>
<li><a href="../zh-CN479304/index.html">临时容器Kubernetes的第一步</a></li>
<li><a href="../zh-CN479306/index.html">PHP摘要169（2019年11月26日至12月9日）</a></li>
<li><a href="../zh-CN479308/index.html">专业需求计划，Holt-Winters和XGboost</a></li>
<li><a href="../zh-CN479310/index.html">如何使1C程序员成为Java开发人员</a></li>
<li><a href="../zh-CN479312/index.html">为iOS团队创建增量服务器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>