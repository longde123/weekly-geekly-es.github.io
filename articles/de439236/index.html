<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∫ üë®‚Äçüë¶ üë∞üèª xenvman: Flexible Microservice-Testumgebungen (und mehr) üç≤ ü§ß üë®üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Ich m√∂chte ein wenig √ºber das Projekt sprechen, an dem ich in den letzten sechs Monaten gearbeitet habe. Ich mache das Projekt i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>xenvman: Flexible Microservice-Testumgebungen (und mehr)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439236/"><p>  Hallo allerseits! </p><br><p>  Ich m√∂chte ein wenig √ºber das Projekt sprechen, an dem ich in den letzten sechs Monaten gearbeitet habe.  Ich mache das Projekt in meiner Freizeit, aber die Motivation f√ºr seine Entstehung kam von den Beobachtungen, die bei der Hauptarbeit gemacht wurden. </p><br><p>  In einem Arbeitsprojekt verwenden wir die Architektur von Microservices. Eines der Hauptprobleme, das sich im Laufe der Zeit manifestiert hat, und die zunehmende Anzahl dieser Services ist das Testen.  Wenn ein bestimmter Dienst von f√ºnf bis sieben anderen Diensten sowie einer anderen Datenbank (oder sogar mehreren) zum Booten abh√§ngt, ist es sehr unpraktisch, ihn sozusagen in einer "Live" -Form zu testen.  Sie m√ºssen Mokas von allen Seiten so fest anziehen, dass Sie nicht einmal den Teig selbst erkennen k√∂nnen.  Nun, oder organisieren Sie irgendwie eine Testumgebung, in der alle Abh√§ngigkeiten wirklich gestartet werden k√∂nnen. </p><a name="habracut"></a><br><p> Um die zweite Option zu vereinfachen, habe ich mich einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hingesetzt</a> , um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xenvman</a> zu schreiben.  Kurz gesagt, dies ist so etwas wie ein Docker-Compose- und Testcontainer-Hybrid, nur ohne Bindung an Java (oder eine andere Sprache) und mit der F√§higkeit, Umgebungen dynamisch √ºber die HTTP-API zu erstellen und zu konfigurieren. </p><br><p> <code>xenvman</code> in Go geschrieben und als einfacher HTTP-Server implementiert, mit dem Sie alle verf√ºgbaren Funktionen aus jeder Sprache nutzen k√∂nnen, die dieses Protokoll sprechen kann. </p><br><p>  Die Hauptsache, die Xenvman tun kann, ist: </p><br><ul><li>  Beschreiben Sie Umgebungsinhalte flexibel mit einfachen JavaScript-Skripten </li><li>  Erstellen Sie Bilder im laufenden Betrieb </li><li>  Erstellen Sie die richtige Anzahl von Containern und kombinieren Sie sie zu einem einzigen isolierten Netzwerk </li><li>  Leiten Sie interne Ports der Umgebung nach au√üen weiter, damit Tests die erforderlichen Dienste auch von anderen Hosts aus erreichen k√∂nnen </li><li>  √Ñndern Sie die Zusammensetzung der Umgebung (Stoppen, Starten und Hinzuf√ºgen neuer Container) unterwegs dynamisch, ohne die Arbeitsumgebung anzuhalten. </li></ul><br><h2 id="okruzheniya">  Umwelt </h2><br><p>  Die Hauptfigur in Xenvman ist die Umgebung.  Dies ist eine solche isolierte Blase, in der alle erforderlichen Abh√§ngigkeiten (in Docker-Containern verpackt) Ihres Dienstes gestartet werden. </p><br><p><img src="https://habrastorage.org/webt/z5/ot/ju/z5otjuqar0vsscxnoqpawyf6vxe.png"></p><br><p>  Die obige Abbildung zeigt den Xenvman-Server und die aktiven Umgebungen, in denen verschiedene Dienste und Datenbanken ausgef√ºhrt werden.  Jede Umgebung wurde direkt aus dem Integrationstestcode erstellt und wird nach Abschluss gel√∂scht. </p><br><h2 id="shablony">  Muster </h2><br><p>  Was direkt Teil der Umgebung ist, wird durch Vorlagen bestimmt, bei denen es sich um kleine Skripte in JS handelt.  xenvman verf√ºgt √ºber einen integrierten Interpreter dieser Sprache. Wenn eine Anforderung zum Erstellen einer neuen Umgebung eingeht, werden einfach die angegebenen Vorlagen ausgef√ºhrt, von denen jede einen oder mehrere Container zur Ausf√ºhrung zur Liste hinzuf√ºgt. </p><br><p>  JavaScript wurde ausgew√§hlt, um das dynamische √Ñndern / Hinzuf√ºgen von Vorlagen zu erm√∂glichen, ohne dass der Server neu erstellt werden muss.  Dar√ºber hinaus verwenden die Vorlagen normalerweise nur die grundlegenden Funktionen und Datentypen der Sprache (das gute alte ES5, kein DOM, React und andere Magie), sodass die Arbeit mit Vorlagen selbst f√ºr diejenigen, die JS √ºberhaupt kennen, keine besonderen Schwierigkeiten bereiten sollte. </p><br><p>  Vorlagen sind parametrierbar, dh wir k√∂nnen die Logik der Vorlage vollst√§ndig steuern, indem wir bestimmte Parameter in unserer HTTP-Anforderung √ºbergeben. </p><br><h2 id="sozdanie-obrazov-na-letu">  Erstellen Sie Bilder im laufenden Betrieb </h2><br><p>  Eine der bequemsten Funktionen von xenvman ist meiner Meinung nach die Erstellung von Docker-Images direkt w√§hrend der Konfiguration der Umgebung.  Warum k√∂nnte dies notwendig sein? <br>  Um beispielsweise in unserem Projekt ein Image eines Dienstes zu erhalten, m√ºssen Sie die √Ñnderungen in einem separaten Zweig festschreiben, starten und warten, bis Gitlab CI das Image sammelt und ausf√ºllt. <br>  Wenn sich nur ein Dienst ge√§ndert hat, kann dies 3-5 Minuten dauern. </p><br><p>  Und wenn wir aktiv neue Funktionen in unserem Service s√§gen oder versuchen zu verstehen, warum dies nicht funktioniert, das gute alte <code>fmt.Printf</code> hin und her hinzuf√ºgen oder den Code h√§ufig irgendwie √§ndern, ist selbst eine Verz√∂gerung von 5 Minuten gro√üartig, um die Leistung zu l√∂schen ( unsere als Codeschreiber).  Stattdessen k√∂nnen wir dem Code einfach alle erforderlichen Fehlerbehebungen hinzuf√ºgen, ihn lokal kompilieren und dann einfach die fertige Bin√§rdatei an die HTTP-Anforderung anh√§ngen. </p><br><p>  Nach Erhalt dieser Genehmigung nimmt die Vorlage diese Bin√§rdatei und erstellt unterwegs ein tempor√§res Image, von dem aus wir den Container bereits starten k√∂nnen, als w√§re nichts passiert. </p><br><p>  In unserem Projekt pr√ºfen wir beispielsweise in der Hauptvorlage f√ºr Dienste, ob die Bin√§rdatei in den Parametern vorhanden ist, und wenn ja, sammeln wir das Bild unterwegs, andernfalls laden wir einfach die <code>latest</code> Version des <code>dev</code> herunter.  Der weitere Code zum Erstellen von Containern ist f√ºr beide Optionen identisch. </p><br><h2 id="nebolshoy-primer">  Ein kleines Beispiel </h2><br><p>  Schauen wir uns zur Verdeutlichung das Mikrobeispiel an. </p><br><p>  Nehmen wir an, wir schreiben eine Art Wunderserver (nennen wir es <code>wut</code> ), der eine Datenbank ben√∂tigt, um alles dort zu speichern.  Nun, als Basis haben wir MongoDB gew√§hlt.  F√ºr vollst√§ndige Tests ben√∂tigen wir daher einen funktionierenden Mongo-Server.  Nat√ºrlich k√∂nnen Sie es lokal installieren und ausf√ºhren, aber zur Vereinfachung und Sichtbarkeit des Beispiels gehen wir davon aus, dass dies aus irgendeinem Grund schwierig ist (bei anderen, komplexeren Konfigurationen in realen Systemen entspricht dies eher der Wahrheit). </p><br><p>  Wir werden also versuchen, xenvman zu verwenden, um eine Umgebung mit Mongo und unserem <code>wut</code> Server zu erstellen. </p><br><p>  Zun√§chst m√ºssen wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisverzeichnis</a> erstellen, in dem alle Vorlagen gespeichert werden: </p><br><p> <code>$ mkdir xenv-templates &amp;&amp; cd xenv-templates</code> </p> <br><p>  Erstellen Sie als N√§chstes zwei Vorlagen, eine f√ºr Mongo und eine f√ºr unseren Server: </p><br><p> <code>$ touch mongo.tpl.js wut.tpl.js</code> </p> <br><h3 id="mongotpljs">  mongo.tpl.js </h3><br><p>  √ñffnen Sie <code>mongo.tpl.js</code> und schreiben Sie dort Folgendes: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>); cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> }); }</code> </pre> <br><p>  Die Vorlage muss eine <em>execute () -</em> Funktion mit zwei Parametern haben. <br>  Die erste ist eine Instanz des tpl-Objekts, √ºber das die Umgebung konfiguriert wird.  Das zweite Argument (params) ist nur ein JSON-Objekt, mit dem wir unsere Vorlage parametrisieren. </p><br><p>  In der Schlange </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag));</code> </pre> <br><p>  Wir bitten Xenvman, das Docker- <code>mongo:&lt;tag&gt;</code> Image herunterzuladen <code>mongo:&lt;tag&gt;</code> , wobei <code>&lt;tag&gt;</code> die Version des Images ist, das wir verwenden m√∂chten.  Im Prinzip entspricht diese Zeile dem <code>docker pull mongo:&lt;tag&gt;</code> <code>tpl</code> <code>docker pull mongo:&lt;tag&gt;</code> , mit dem einzigen Unterschied, dass alle Funktionen des <code>tpl</code> Objekts im Wesentlichen deklarativ sind, <code>tpl</code> das Image wird tats√§chlich erst heruntergeladen, nachdem xenvman alle in der Umgebungskonfiguration angegebenen Vorlagen ausgef√ºhrt hat. </p><br><p>  Nachdem wir das Bild haben, k√∂nnen wir einen Container erstellen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>);</code> </pre> <br><p>  Auch hier wird der Container an dieser Stelle nicht sofort erstellt, wir erkl√§ren einfach die Absicht, ihn sozusagen zu erstellen. </p><br><p>  Als n√§chstes bringen wir ein Etikett auf unserem Beh√§lter an: </p><br><pre> <code class="javascript hljs">cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>);</code> </pre> <br><p>  Verkn√ºpfungen werden verwendet, damit sich Container in einer Umgebung finden k√∂nnen, um beispielsweise die IP-Adresse oder den Hostnamen in die Konfigurationsdatei einzugeben. </p><br><p>  Jetzt m√ºssen wir den internen Mongo-Port (27017) aufh√§ngen.  Dies ist einfach so zu bewerkstelligen: </p><br><pre> <code class="javascript hljs"> cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>);</code> </pre> <br><p>  Bevor xenvman √ºber die erfolgreiche Erstellung der Umgebung berichtet, sollten Sie sicherstellen, dass alle Dienste nicht nur ausgef√ºhrt werden, sondern auch Anfragen annehmen k√∂nnen.  Xenvman hat hierf√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitschaftspr√ºfungen</a> . <br>  F√ºgen Sie eine solche f√ºr unseren Mongo-Beh√§lter hinzu: </p><br><pre> <code class="javascript hljs"> cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> });</code> </pre> <br><p>  Wie wir sehen k√∂nnen, gibt es hier in der Adressleiste Stubs, in die die erforderlichen Werte unmittelbar vor dem Start der Container dynamisch eingesetzt werden. </p><br><p>  Anstelle von <code>{{.ExternalAddress}}</code> externe Adresse des Hosts, auf dem xenvman ausgef√ºhrt wird, ersetzt, und anstelle von <code>{{.Self.ExposedPort 27017}}</code> externe Port ersetzt, der an den internen 27017 weitergeleitet wurde. </p><br><p>  Lesen Sie hier mehr √ºber Interpolation. </p><br><p>  Infolgedessen k√∂nnen wir eine Verbindung zum Mongo herstellen, der in der Umgebung ausgef√ºhrt wird, beispielsweise direkt au√üerhalb des Hosts, auf dem wir unseren Test ausf√ºhren. </p><br><h3 id="wuttpljs">  wut.tpl.js </h3><br><p>  Also, c, nachdem wir uns mit der Monga befasst haben, werden wir eine weitere Vorlage f√ºr unseren <code>wut</code> Server schreiben. <br>  Da wir das Bild unterwegs sammeln m√∂chten, unterscheidet sich die Vorlage geringf√ºgig: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>); img.CopyDataToWorkspace(<span class="hljs-string"><span class="hljs-string">"Dockerfile"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755); // Create container var cont = img.NewContainer("wut"); cont.MountData("config.toml", "/config.toml", {"interpolate": true}); cont.SetPorts(params.port); cont.AddReadinessCheck("http", { "url": fmt('http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/', params.port), "codes": [200] }); }</span></span></code> </pre> <br><p>  Da wir <code>BuildImage()</code> Image hier <code>BuildImage()</code> , verwenden wir <code>BuildImage()</code> anstelle von <code>FetchImage()</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>);</code> </pre> <br><p>  Um das Bild zusammenzusetzen, ben√∂tigen wir mehrere Dateien: <br>  Dockerfile - Anweisungen zum Zusammenstellen eines Bildes <br>  config.toml - Konfigurationsdatei f√ºr unseren <code>wut</code> Server </p><br><p>  Verwenden der Methode <code>img.CopyDataToWorkspace("Dockerfile");</code>  Wir kopieren die Docker-Datei aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Vorlagendatenverzeichnis</a> in ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tempor√§res Arbeitsverzeichnis</a> . </p><br><p>  Das Datenverzeichnis ist ein Verzeichnis, in dem wir alle Dateien speichern k√∂nnen, die f√ºr die Funktion unserer Vorlage erforderlich sind. </p><br><p>  Im tempor√§ren Arbeitsverzeichnis kopieren wir die Dateien (mit img.CopyDataToWorkspace ()), die in das Bild gelangen. </p><br><p>  Folgendes folgt: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755);</span></span></code> </pre> <br><p>  Wir √ºbergeben die Bin√§rdatei unseres Servers direkt in den Parametern in codierter (base64) Form.  Und in der Vorlage dekodieren wir sie einfach und speichern die resultierende Zeichenfolge im Arbeitsverzeichnis als Datei unter dem Namen <code>wut</code> . </p><br><p>  Erstellen Sie dann einen Container und h√§ngen Sie die Konfigurationsdatei darin ein: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"wut"</span></span>); cont.MountData(<span class="hljs-string"><span class="hljs-string">"config.toml"</span></span>, <span class="hljs-string"><span class="hljs-string">"/config.toml"</span></span>, {<span class="hljs-string"><span class="hljs-string">"interpolate"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>});</code> </pre> <br><p>  Ein Aufruf von <code>MountData()</code> bedeutet, dass die Datei <code>config.toml</code> aus dem Datenverzeichnis im Container unter dem Namen <code>/config.toml</code> .  Das <code>interpolate</code> Flag teilt xenvman dem Server mit, dass alle dortigen Stubs vor dem Mounten in der Datei ersetzt werden sollen. </p><br><p>  So k√∂nnte die Konfiguration aussehen: </p><br><pre> <code class="plaintext hljs">{{with .ContainerWithLabel "mongo" "" -}} mongo = "{{.Hostname}}/wut" {{- end}}</code> </pre> <br><p>  Hier suchen wir nach dem Container mit dem <code>mongo</code> Label und ersetzen seinen Hostnamen, unabh√§ngig davon, um was es sich in dieser Umgebung handelt. </p><br><p>  Nach dem Ersetzen sieht die Datei m√∂glicherweise folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs">mongo = ‚Äúmongo.0.mongo.xenv/wut‚Äù</code> </pre> <br><p>  Als n√§chstes ver√∂ffentlichen wir erneut den Port und starten eine Bereitschaftspr√ºfung, diesmal HTTP: </p><br><pre> <code class="javascript hljs">cont.SetPorts(params.port); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"http"</span></span>, { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: fmt(<span class="hljs-string"><span class="hljs-string">'http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/'</span></span>, params.port), <span class="hljs-string"><span class="hljs-string">"codes"</span></span>: [<span class="hljs-number"><span class="hljs-number">200</span></span>] });</code> </pre> <br><p>  Unsere Vorlagen sind daf√ºr bereit und wir k√∂nnen sie im Integrationstestcode verwenden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/client"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/def"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  xenvman  cl := client.New(client.Params{}) //      env := cl.MustCreateEnv(&amp;def.InputEnv{ Name: "wut-test", Description: "Testing Wut", // ,      Templates: []*def.Tpl{ { Tpl: "wut", Parameters: def.TplParams{ "binary": client.FileToBase64("wut"), "port": 5555, }, }, { Tpl: "mongo", Parameters: def.TplParams{"tag": ‚Äúlatest‚Äù}, }, }, }) //      defer env.Terminate() //     wut  wutCont, err := env.GetContainer("wut", 0, "wut") require.Nil(t, err) //      mongoCont, err := env.GetContainer("mongo", 0, "mongo") require.Nil(t, err) //    wutUrl := fmt.Sprintf("http://%s:%d/v1/wut/", env.ExternalAddress, wutCont.Ports[‚Äú5555‚Äù]) mongoUrl := fmt.Sprintf("%s:%d/wut", env.ExternalAddress, mongoCont.Ports["27017"]) // !      ,            ,  </span></span></code> </pre> <br><p>  Es scheint, dass das Schreiben von Vorlagen zu lange dauert. <br>  Mit dem richtigen Design ist dies jedoch eine einmalige Aufgabe, und dann k√∂nnen dieselben Vorlagen immer mehr (und sogar f√ºr verschiedene Sprachen!) Wiederverwendet werden, indem sie einfach durch √úbergabe bestimmter Parameter feinabgestimmt werden.  Wie Sie im obigen Beispiel sehen k√∂nnen, ist der Testcode selbst sehr einfach, da wir alle H√ºlsen beim Einrichten der Umgebung in Vorlagen einf√ºgen. </p><br><p>  In diesem kleinen Beispiel finden Sie hier nicht nur alle Funktionen von xenvman, sondern auch eine ausf√ºhrlichere Schritt-f√ºr-Schritt-Anleitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </p><br><h2 id="klienty">  Kunden </h2><br><p>  Derzeit gibt es Kunden f√ºr zwei Sprachen: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geh</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> </p><br><p>  Das Hinzuf√ºgen neuer ist jedoch nicht schwierig, da die bereitgestellte API sehr, sehr einfach ist. </p><br><h2 id="veb-interfeys">  Webschnittstelle </h2><br><p>  In Version 2.0.0 wurde eine einfache Weboberfl√§che hinzugef√ºgt, mit der Sie Ihre Umgebungen verwalten und verf√ºgbare Vorlagen anzeigen k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/mh/cp/bw/mhcpbw3wxz9rlsyk0nsonsid8_8.png"><br><img src="https://habrastorage.org/webt/7w/_w/wv/7w_wwvi6bq_tsr81bxafvb9vzo4.png"><br><img src="https://habrastorage.org/webt/cw/yr/wi/cwyrwiotyxbnrewwvp0gujta0j0.png"></p><br><h2 id="chem-xenvman-otlichaetsya-ot-docker-compose">  Wie unterscheidet sich Xenvman von Docker-Compose? </h2><br><p>  Nat√ºrlich gibt es viele √Ñhnlichkeiten, aber Xenvman scheint mir ein etwas flexiblerer und dynamischerer Ansatz zu sein als die statische Konfiguration in der Datei. <br>  Hier sind meiner Meinung nach die Hauptunterscheidungsmerkmale: </p><br><ul><li>  Die gesamte Steuerung erfolgt √ºber die HTTP-API. Daher k√∂nnen wir Umgebungen aus dem Code jeder Sprache erstellen, die HTTP versteht </li><li>  Da xenvman auf einem anderen Host ausgef√ºhrt werden kann, k√∂nnen wir alle Funktionen auch von einem Host aus nutzen, auf dem Docker nicht installiert ist. </li><li>  Die F√§higkeit, Bilder im laufenden Betrieb dynamisch zu erstellen </li><li>  Die M√∂glichkeit, die Zusammensetzung der Umgebung (Hinzuf√ºgen / Stoppen von Containern) w√§hrend des Betriebs zu √§ndern </li><li>  Reduzierter Boilerplate-Code, verbesserte Zusammensetzung und die M√∂glichkeit, Konfigurationscode durch die Verwendung parametrierbarer Vorlagen wiederzuverwenden </li></ul><br><h2 id="ssylki">  Referenzen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projektseite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Detailliertes Schritt-f√ºr-Schritt-Beispiel in Englisch.</a> </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Das ist alles  In naher Zukunft plane ich, die Gelegenheit hinzuzuf√ºgen <br>  Rufen Sie Vorlagen aus Vorlagen auf und erm√∂glichen Sie ihnen, diese effizienter zu kombinieren. </p><br><p>  Ich werde versuchen, alle Fragen zu beantworten, und ich w√ºrde mich freuen, wenn jemand anderes dieses Projekt n√ºtzlich findet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439236/">https://habr.com/ru/post/de439236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439222/index.html">Was ist API-Verwaltung?</a></li>
<li><a href="../de439224/index.html">Nochmals zu Voronoi-Diagrammen</a></li>
<li><a href="../de439226/index.html">Scala + MXNet = Microservice mit Neuron in Prod</a></li>
<li><a href="../de439232/index.html">JAMstack: So erstellen Sie Ihr eigenes Blog mit Gatsby + Contentful + Netlify</a></li>
<li><a href="../de439234/index.html">Das Leben von Open Source-Entwicklern in GIFs</a></li>
<li><a href="../de439238/index.html">Der Play Store akzeptiert jetzt progressive Webanwendungen (PWA).</a></li>
<li><a href="../de439240/index.html">Joomla Digest f√ºr Januar 2019</a></li>
<li><a href="../de439242/index.html">Rund um die Beta in 260 Tagen: Wie wir gelernt haben, Benutzern zuzuh√∂ren</a></li>
<li><a href="../de439244/index.html">FAS empfiehlt dringend, russische Software auf Smartphones und Laptops vorinstallieren, die in der Russischen F√∂deration verkauft werden</a></li>
<li><a href="../de439248/index.html">Alan Kay: K√∂nnten die alten R√∂mer einen Computer bauen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>