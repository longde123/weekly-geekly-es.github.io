<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐺 👨‍👦 👰🏻 xenvman: Flexible Microservice-Testumgebungen (und mehr) 🍲 🤧 👨🏼‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 Ich möchte ein wenig über das Projekt sprechen, an dem ich in den letzten sechs Monaten gearbeitet habe. Ich mache das Projekt i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>xenvman: Flexible Microservice-Testumgebungen (und mehr)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439236/"><p>  Hallo allerseits! </p><br><p>  Ich möchte ein wenig über das Projekt sprechen, an dem ich in den letzten sechs Monaten gearbeitet habe.  Ich mache das Projekt in meiner Freizeit, aber die Motivation für seine Entstehung kam von den Beobachtungen, die bei der Hauptarbeit gemacht wurden. </p><br><p>  In einem Arbeitsprojekt verwenden wir die Architektur von Microservices. Eines der Hauptprobleme, das sich im Laufe der Zeit manifestiert hat, und die zunehmende Anzahl dieser Services ist das Testen.  Wenn ein bestimmter Dienst von fünf bis sieben anderen Diensten sowie einer anderen Datenbank (oder sogar mehreren) zum Booten abhängt, ist es sehr unpraktisch, ihn sozusagen in einer "Live" -Form zu testen.  Sie müssen Mokas von allen Seiten so fest anziehen, dass Sie nicht einmal den Teig selbst erkennen können.  Nun, oder organisieren Sie irgendwie eine Testumgebung, in der alle Abhängigkeiten wirklich gestartet werden können. </p><a name="habracut"></a><br><p> Um die zweite Option zu vereinfachen, habe ich mich einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hingesetzt</a> , um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xenvman</a> zu schreiben.  Kurz gesagt, dies ist so etwas wie ein Docker-Compose- und Testcontainer-Hybrid, nur ohne Bindung an Java (oder eine andere Sprache) und mit der Fähigkeit, Umgebungen dynamisch über die HTTP-API zu erstellen und zu konfigurieren. </p><br><p> <code>xenvman</code> in Go geschrieben und als einfacher HTTP-Server implementiert, mit dem Sie alle verfügbaren Funktionen aus jeder Sprache nutzen können, die dieses Protokoll sprechen kann. </p><br><p>  Die Hauptsache, die Xenvman tun kann, ist: </p><br><ul><li>  Beschreiben Sie Umgebungsinhalte flexibel mit einfachen JavaScript-Skripten </li><li>  Erstellen Sie Bilder im laufenden Betrieb </li><li>  Erstellen Sie die richtige Anzahl von Containern und kombinieren Sie sie zu einem einzigen isolierten Netzwerk </li><li>  Leiten Sie interne Ports der Umgebung nach außen weiter, damit Tests die erforderlichen Dienste auch von anderen Hosts aus erreichen können </li><li>  Ändern Sie die Zusammensetzung der Umgebung (Stoppen, Starten und Hinzufügen neuer Container) unterwegs dynamisch, ohne die Arbeitsumgebung anzuhalten. </li></ul><br><h2 id="okruzheniya">  Umwelt </h2><br><p>  Die Hauptfigur in Xenvman ist die Umgebung.  Dies ist eine solche isolierte Blase, in der alle erforderlichen Abhängigkeiten (in Docker-Containern verpackt) Ihres Dienstes gestartet werden. </p><br><p><img src="https://habrastorage.org/webt/z5/ot/ju/z5otjuqar0vsscxnoqpawyf6vxe.png"></p><br><p>  Die obige Abbildung zeigt den Xenvman-Server und die aktiven Umgebungen, in denen verschiedene Dienste und Datenbanken ausgeführt werden.  Jede Umgebung wurde direkt aus dem Integrationstestcode erstellt und wird nach Abschluss gelöscht. </p><br><h2 id="shablony">  Muster </h2><br><p>  Was direkt Teil der Umgebung ist, wird durch Vorlagen bestimmt, bei denen es sich um kleine Skripte in JS handelt.  xenvman verfügt über einen integrierten Interpreter dieser Sprache. Wenn eine Anforderung zum Erstellen einer neuen Umgebung eingeht, werden einfach die angegebenen Vorlagen ausgeführt, von denen jede einen oder mehrere Container zur Ausführung zur Liste hinzufügt. </p><br><p>  JavaScript wurde ausgewählt, um das dynamische Ändern / Hinzufügen von Vorlagen zu ermöglichen, ohne dass der Server neu erstellt werden muss.  Darüber hinaus verwenden die Vorlagen normalerweise nur die grundlegenden Funktionen und Datentypen der Sprache (das gute alte ES5, kein DOM, React und andere Magie), sodass die Arbeit mit Vorlagen selbst für diejenigen, die JS überhaupt kennen, keine besonderen Schwierigkeiten bereiten sollte. </p><br><p>  Vorlagen sind parametrierbar, dh wir können die Logik der Vorlage vollständig steuern, indem wir bestimmte Parameter in unserer HTTP-Anforderung übergeben. </p><br><h2 id="sozdanie-obrazov-na-letu">  Erstellen Sie Bilder im laufenden Betrieb </h2><br><p>  Eine der bequemsten Funktionen von xenvman ist meiner Meinung nach die Erstellung von Docker-Images direkt während der Konfiguration der Umgebung.  Warum könnte dies notwendig sein? <br>  Um beispielsweise in unserem Projekt ein Image eines Dienstes zu erhalten, müssen Sie die Änderungen in einem separaten Zweig festschreiben, starten und warten, bis Gitlab CI das Image sammelt und ausfüllt. <br>  Wenn sich nur ein Dienst geändert hat, kann dies 3-5 Minuten dauern. </p><br><p>  Und wenn wir aktiv neue Funktionen in unserem Service sägen oder versuchen zu verstehen, warum dies nicht funktioniert, das gute alte <code>fmt.Printf</code> hin und her hinzufügen oder den Code häufig irgendwie ändern, ist selbst eine Verzögerung von 5 Minuten großartig, um die Leistung zu löschen ( unsere als Codeschreiber).  Stattdessen können wir dem Code einfach alle erforderlichen Fehlerbehebungen hinzufügen, ihn lokal kompilieren und dann einfach die fertige Binärdatei an die HTTP-Anforderung anhängen. </p><br><p>  Nach Erhalt dieser Genehmigung nimmt die Vorlage diese Binärdatei und erstellt unterwegs ein temporäres Image, von dem aus wir den Container bereits starten können, als wäre nichts passiert. </p><br><p>  In unserem Projekt prüfen wir beispielsweise in der Hauptvorlage für Dienste, ob die Binärdatei in den Parametern vorhanden ist, und wenn ja, sammeln wir das Bild unterwegs, andernfalls laden wir einfach die <code>latest</code> Version des <code>dev</code> herunter.  Der weitere Code zum Erstellen von Containern ist für beide Optionen identisch. </p><br><h2 id="nebolshoy-primer">  Ein kleines Beispiel </h2><br><p>  Schauen wir uns zur Verdeutlichung das Mikrobeispiel an. </p><br><p>  Nehmen wir an, wir schreiben eine Art Wunderserver (nennen wir es <code>wut</code> ), der eine Datenbank benötigt, um alles dort zu speichern.  Nun, als Basis haben wir MongoDB gewählt.  Für vollständige Tests benötigen wir daher einen funktionierenden Mongo-Server.  Natürlich können Sie es lokal installieren und ausführen, aber zur Vereinfachung und Sichtbarkeit des Beispiels gehen wir davon aus, dass dies aus irgendeinem Grund schwierig ist (bei anderen, komplexeren Konfigurationen in realen Systemen entspricht dies eher der Wahrheit). </p><br><p>  Wir werden also versuchen, xenvman zu verwenden, um eine Umgebung mit Mongo und unserem <code>wut</code> Server zu erstellen. </p><br><p>  Zunächst müssen wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Basisverzeichnis</a> erstellen, in dem alle Vorlagen gespeichert werden: </p><br><p> <code>$ mkdir xenv-templates &amp;&amp; cd xenv-templates</code> </p> <br><p>  Erstellen Sie als Nächstes zwei Vorlagen, eine für Mongo und eine für unseren Server: </p><br><p> <code>$ touch mongo.tpl.js wut.tpl.js</code> </p> <br><h3 id="mongotpljs">  mongo.tpl.js </h3><br><p>  Öffnen Sie <code>mongo.tpl.js</code> und schreiben Sie dort Folgendes: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>); cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> }); }</code> </pre> <br><p>  Die Vorlage muss eine <em>execute () -</em> Funktion mit zwei Parametern haben. <br>  Die erste ist eine Instanz des tpl-Objekts, über das die Umgebung konfiguriert wird.  Das zweite Argument (params) ist nur ein JSON-Objekt, mit dem wir unsere Vorlage parametrisieren. </p><br><p>  In der Schlange </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.FetchImage(fmt(<span class="hljs-string"><span class="hljs-string">"mongo:%s"</span></span>, params.tag));</code> </pre> <br><p>  Wir bitten Xenvman, das Docker- <code>mongo:&lt;tag&gt;</code> Image herunterzuladen <code>mongo:&lt;tag&gt;</code> , wobei <code>&lt;tag&gt;</code> die Version des Images ist, das wir verwenden möchten.  Im Prinzip entspricht diese Zeile dem <code>docker pull mongo:&lt;tag&gt;</code> <code>tpl</code> <code>docker pull mongo:&lt;tag&gt;</code> , mit dem einzigen Unterschied, dass alle Funktionen des <code>tpl</code> Objekts im Wesentlichen deklarativ sind, <code>tpl</code> das Image wird tatsächlich erst heruntergeladen, nachdem xenvman alle in der Umgebungskonfiguration angegebenen Vorlagen ausgeführt hat. </p><br><p>  Nachdem wir das Bild haben, können wir einen Container erstellen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>);</code> </pre> <br><p>  Auch hier wird der Container an dieser Stelle nicht sofort erstellt, wir erklären einfach die Absicht, ihn sozusagen zu erstellen. </p><br><p>  Als nächstes bringen wir ein Etikett auf unserem Behälter an: </p><br><pre> <code class="javascript hljs">cont.SetLabel(<span class="hljs-string"><span class="hljs-string">"mongo"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>);</code> </pre> <br><p>  Verknüpfungen werden verwendet, damit sich Container in einer Umgebung finden können, um beispielsweise die IP-Adresse oder den Hostnamen in die Konfigurationsdatei einzugeben. </p><br><p>  Jetzt müssen wir den internen Mongo-Port (27017) aufhängen.  Dies ist einfach so zu bewerkstelligen: </p><br><pre> <code class="javascript hljs"> cont.SetPorts(<span class="hljs-number"><span class="hljs-number">27017</span></span>);</code> </pre> <br><p>  Bevor xenvman über die erfolgreiche Erstellung der Umgebung berichtet, sollten Sie sicherstellen, dass alle Dienste nicht nur ausgeführt werden, sondern auch Anfragen annehmen können.  Xenvman hat hierfür <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitschaftsprüfungen</a> . <br>  Fügen Sie eine solche für unseren Mongo-Behälter hinzu: </p><br><pre> <code class="javascript hljs"> cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"net"</span></span>, { <span class="hljs-string"><span class="hljs-string">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">'{{.ExternalAddress}}:{{.Self.ExposedPort 27017}}'</span></span> });</code> </pre> <br><p>  Wie wir sehen können, gibt es hier in der Adressleiste Stubs, in die die erforderlichen Werte unmittelbar vor dem Start der Container dynamisch eingesetzt werden. </p><br><p>  Anstelle von <code>{{.ExternalAddress}}</code> externe Adresse des Hosts, auf dem xenvman ausgeführt wird, ersetzt, und anstelle von <code>{{.Self.ExposedPort 27017}}</code> externe Port ersetzt, der an den internen 27017 weitergeleitet wurde. </p><br><p>  Lesen Sie hier mehr über Interpolation. </p><br><p>  Infolgedessen können wir eine Verbindung zum Mongo herstellen, der in der Umgebung ausgeführt wird, beispielsweise direkt außerhalb des Hosts, auf dem wir unseren Test ausführen. </p><br><h3 id="wuttpljs">  wut.tpl.js </h3><br><p>  Also, c, nachdem wir uns mit der Monga befasst haben, werden wir eine weitere Vorlage für unseren <code>wut</code> Server schreiben. <br>  Da wir das Bild unterwegs sammeln möchten, unterscheidet sich die Vorlage geringfügig: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tpl, params</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>); img.CopyDataToWorkspace(<span class="hljs-string"><span class="hljs-string">"Dockerfile"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755); // Create container var cont = img.NewContainer("wut"); cont.MountData("config.toml", "/config.toml", {"interpolate": true}); cont.SetPorts(params.port); cont.AddReadinessCheck("http", { "url": fmt('http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/', params.port), "codes": [200] }); }</span></span></code> </pre> <br><p>  Da wir <code>BuildImage()</code> Image hier <code>BuildImage()</code> , verwenden wir <code>BuildImage()</code> anstelle von <code>FetchImage()</code> : </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = tpl.BuildImage(<span class="hljs-string"><span class="hljs-string">"wut-image"</span></span>);</code> </pre> <br><p>  Um das Bild zusammenzusetzen, benötigen wir mehrere Dateien: <br>  Dockerfile - Anweisungen zum Zusammenstellen eines Bildes <br>  config.toml - Konfigurationsdatei für unseren <code>wut</code> Server </p><br><p>  Verwenden der Methode <code>img.CopyDataToWorkspace("Dockerfile");</code>  Wir kopieren die Docker-Datei aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Vorlagendatenverzeichnis</a> in ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">temporäres Arbeitsverzeichnis</a> . </p><br><p>  Das Datenverzeichnis ist ein Verzeichnis, in dem wir alle Dateien speichern können, die für die Funktion unserer Vorlage erforderlich sind. </p><br><p>  Im temporären Arbeitsverzeichnis kopieren wir die Dateien (mit img.CopyDataToWorkspace ()), die in das Bild gelangen. </p><br><p>  Folgendes folgt: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// Extract server binary var bin = type.FromBase64("binary", params.binary); img.AddFileToWorkspace("wut", bin, 0755);</span></span></code> </pre> <br><p>  Wir übergeben die Binärdatei unseres Servers direkt in den Parametern in codierter (base64) Form.  Und in der Vorlage dekodieren wir sie einfach und speichern die resultierende Zeichenfolge im Arbeitsverzeichnis als Datei unter dem Namen <code>wut</code> . </p><br><p>  Erstellen Sie dann einen Container und hängen Sie die Konfigurationsdatei darin ein: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cont = img.NewContainer(<span class="hljs-string"><span class="hljs-string">"wut"</span></span>); cont.MountData(<span class="hljs-string"><span class="hljs-string">"config.toml"</span></span>, <span class="hljs-string"><span class="hljs-string">"/config.toml"</span></span>, {<span class="hljs-string"><span class="hljs-string">"interpolate"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>});</code> </pre> <br><p>  Ein Aufruf von <code>MountData()</code> bedeutet, dass die Datei <code>config.toml</code> aus dem Datenverzeichnis im Container unter dem Namen <code>/config.toml</code> .  Das <code>interpolate</code> Flag teilt xenvman dem Server mit, dass alle dortigen Stubs vor dem Mounten in der Datei ersetzt werden sollen. </p><br><p>  So könnte die Konfiguration aussehen: </p><br><pre> <code class="plaintext hljs">{{with .ContainerWithLabel "mongo" "" -}} mongo = "{{.Hostname}}/wut" {{- end}}</code> </pre> <br><p>  Hier suchen wir nach dem Container mit dem <code>mongo</code> Label und ersetzen seinen Hostnamen, unabhängig davon, um was es sich in dieser Umgebung handelt. </p><br><p>  Nach dem Ersetzen sieht die Datei möglicherweise folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">mongo = “mongo.0.mongo.xenv/wut”</code> </pre> <br><p>  Als nächstes veröffentlichen wir erneut den Port und starten eine Bereitschaftsprüfung, diesmal HTTP: </p><br><pre> <code class="javascript hljs">cont.SetPorts(params.port); cont.AddReadinessCheck(<span class="hljs-string"><span class="hljs-string">"http"</span></span>, { <span class="hljs-string"><span class="hljs-string">"url"</span></span>: fmt(<span class="hljs-string"><span class="hljs-string">'http://{{.ExternalAddress}}:{{.Self.ExposedPort %v}}/'</span></span>, params.port), <span class="hljs-string"><span class="hljs-string">"codes"</span></span>: [<span class="hljs-number"><span class="hljs-number">200</span></span>] });</code> </pre> <br><p>  Unsere Vorlagen sind dafür bereit und wir können sie im Integrationstestcode verwenden: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/client"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/syhpoon/xenvman/pkg/def"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  xenvman  cl := client.New(client.Params{}) //      env := cl.MustCreateEnv(&amp;def.InputEnv{ Name: "wut-test", Description: "Testing Wut", // ,      Templates: []*def.Tpl{ { Tpl: "wut", Parameters: def.TplParams{ "binary": client.FileToBase64("wut"), "port": 5555, }, }, { Tpl: "mongo", Parameters: def.TplParams{"tag": “latest”}, }, }, }) //      defer env.Terminate() //     wut  wutCont, err := env.GetContainer("wut", 0, "wut") require.Nil(t, err) //      mongoCont, err := env.GetContainer("mongo", 0, "mongo") require.Nil(t, err) //    wutUrl := fmt.Sprintf("http://%s:%d/v1/wut/", env.ExternalAddress, wutCont.Ports[“5555”]) mongoUrl := fmt.Sprintf("%s:%d/wut", env.ExternalAddress, mongoCont.Ports["27017"]) // !      ,            ,  </span></span></code> </pre> <br><p>  Es scheint, dass das Schreiben von Vorlagen zu lange dauert. <br>  Mit dem richtigen Design ist dies jedoch eine einmalige Aufgabe, und dann können dieselben Vorlagen immer mehr (und sogar für verschiedene Sprachen!) Wiederverwendet werden, indem sie einfach durch Übergabe bestimmter Parameter feinabgestimmt werden.  Wie Sie im obigen Beispiel sehen können, ist der Testcode selbst sehr einfach, da wir alle Hülsen beim Einrichten der Umgebung in Vorlagen einfügen. </p><br><p>  In diesem kleinen Beispiel finden Sie hier nicht nur alle Funktionen von xenvman, sondern auch eine ausführlichere Schritt-für-Schritt-Anleitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </p><br><h2 id="klienty">  Kunden </h2><br><p>  Derzeit gibt es Kunden für zwei Sprachen: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geh</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python</a> </p><br><p>  Das Hinzufügen neuer ist jedoch nicht schwierig, da die bereitgestellte API sehr, sehr einfach ist. </p><br><h2 id="veb-interfeys">  Webschnittstelle </h2><br><p>  In Version 2.0.0 wurde eine einfache Weboberfläche hinzugefügt, mit der Sie Ihre Umgebungen verwalten und verfügbare Vorlagen anzeigen können. </p><br><p><img src="https://habrastorage.org/webt/mh/cp/bw/mhcpbw3wxz9rlsyk0nsonsid8_8.png"><br><img src="https://habrastorage.org/webt/7w/_w/wv/7w_wwvi6bq_tsr81bxafvb9vzo4.png"><br><img src="https://habrastorage.org/webt/cw/yr/wi/cwyrwiotyxbnrewwvp0gujta0j0.png"></p><br><h2 id="chem-xenvman-otlichaetsya-ot-docker-compose">  Wie unterscheidet sich Xenvman von Docker-Compose? </h2><br><p>  Natürlich gibt es viele Ähnlichkeiten, aber Xenvman scheint mir ein etwas flexiblerer und dynamischerer Ansatz zu sein als die statische Konfiguration in der Datei. <br>  Hier sind meiner Meinung nach die Hauptunterscheidungsmerkmale: </p><br><ul><li>  Die gesamte Steuerung erfolgt über die HTTP-API. Daher können wir Umgebungen aus dem Code jeder Sprache erstellen, die HTTP versteht </li><li>  Da xenvman auf einem anderen Host ausgeführt werden kann, können wir alle Funktionen auch von einem Host aus nutzen, auf dem Docker nicht installiert ist. </li><li>  Die Fähigkeit, Bilder im laufenden Betrieb dynamisch zu erstellen </li><li>  Die Möglichkeit, die Zusammensetzung der Umgebung (Hinzufügen / Stoppen von Containern) während des Betriebs zu ändern </li><li>  Reduzierter Boilerplate-Code, verbesserte Zusammensetzung und die Möglichkeit, Konfigurationscode durch die Verwendung parametrierbarer Vorlagen wiederzuverwenden </li></ul><br><h2 id="ssylki">  Referenzen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projektseite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Detailliertes Schritt-für-Schritt-Beispiel in Englisch.</a> </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Das ist alles  In naher Zukunft plane ich, die Gelegenheit hinzuzufügen <br>  Rufen Sie Vorlagen aus Vorlagen auf und ermöglichen Sie ihnen, diese effizienter zu kombinieren. </p><br><p>  Ich werde versuchen, alle Fragen zu beantworten, und ich würde mich freuen, wenn jemand anderes dieses Projekt nützlich findet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439236/">https://habr.com/ru/post/de439236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439222/index.html">Was ist API-Verwaltung?</a></li>
<li><a href="../de439224/index.html">Nochmals zu Voronoi-Diagrammen</a></li>
<li><a href="../de439226/index.html">Scala + MXNet = Microservice mit Neuron in Prod</a></li>
<li><a href="../de439232/index.html">JAMstack: So erstellen Sie Ihr eigenes Blog mit Gatsby + Contentful + Netlify</a></li>
<li><a href="../de439234/index.html">Das Leben von Open Source-Entwicklern in GIFs</a></li>
<li><a href="../de439238/index.html">Der Play Store akzeptiert jetzt progressive Webanwendungen (PWA).</a></li>
<li><a href="../de439240/index.html">Joomla Digest für Januar 2019</a></li>
<li><a href="../de439242/index.html">Rund um die Beta in 260 Tagen: Wie wir gelernt haben, Benutzern zuzuhören</a></li>
<li><a href="../de439244/index.html">FAS empfiehlt dringend, russische Software auf Smartphones und Laptops vorinstallieren, die in der Russischen Föderation verkauft werden</a></li>
<li><a href="../de439248/index.html">Alan Kay: Könnten die alten Römer einen Computer bauen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>