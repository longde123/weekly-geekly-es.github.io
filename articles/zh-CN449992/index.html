<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍✈️ 💴 ⚗️ NodeMCU简单驱动程序模型（SDM）展示：动态用户界面 📥 💃🏻 🖖🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="NodeMCU是一个交互式固件 ，它允许在ESP8266微控制器上运行Lua解释器（正在开发ESP32支持）。 除所有常规硬件接口外，它还具有WiFi模块和SPIFFS文件系统。 


 本文介绍了NodeMCU的新模块-sdm。 SDM代表简单的驱动程序模型，它为系统提供设备驱动程序模型抽象。 在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NodeMCU简单驱动程序模型（SDM）展示：动态用户界面</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449992/"><p><img src="https://habrastorage.org/webt/45/dq/e8/45dqe8yvyxvpg_kcien-88xslei.jpeg" alt="图片"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NodeMCU</a>是一个<em>交互式固件</em> ，它允许在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESP8266</a>微控制器上运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lua</a>解释器（正在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESP32</a>支持）。 除所有常规硬件接口外，它还具有WiFi模块和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SPIFFS</a>文件系统。 </p><br><p> 本文介绍了NodeMCU的新模块-sdm。  SDM代表简单的驱动程序模型，它为系统提供设备驱动程序模型抽象。 在本文的第一部分中，我们将讨论模型本身，在第二部分中，将展示使用sdm以及一些注释的动态创建的Web用户界面。 </p><a name="habracut"></a><br><h1 id="driver-model-basics"> 驱动程序模型基础 </h1><br><p> 该模型的两个主要组件是<em>设备</em>和<em>驱动程序</em> 。 设备是某些硬件或虚拟设备的抽象表示。 将设备置于树状结构中是有意义的，其中微控制器位于顶部，总线位于中间，传感器作为叶子。 </p><br><pre><code class="plaintext hljs">DEVICES + DRIVERS | +-----+ | +-----+ |1WIRE&lt;----------------------+1WIRE| ++-+-++ | +-----+ | | | | +---------+ | +--------+ | +------+ | | | +------+DS1820| +---v----+ +---v----+ +---v----+ | | +------+ |DS1820|0| |DS1820|1| |DS1822|0| | | +---^----+ +---^----+ +---^----+ | | +------+ | | +--------------+DS1822| | | | | +------+ +-----------+------------------+ +</code> </pre> <br><p> 设备驱动程序是与给定设备关联的逻辑。 驱动程序提供的功能称为<em>方法</em> ，与驱动程序关联的数据容器称为<em>属性</em> 。 方法和属性都位于驱动程序内部。 </p><br><p> 属性具有两个与之关联的功能： <em>getter</em>和<em>setter</em>挂钩。 因此，属性具有超集方法功能，但它们也占用更多内存（微控制器内存稀少，还记得吗？）。 </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-comment"><span class="hljs-comment">-- device handle "ref", -- attribute name "Reference voltage", -- attribute description 5, function(dev) -- this is a getter function return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) -- this is a setter function sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end )</span></span></code> </pre> <br><h2 id="device-binding"> 设备绑定 </h2><br><p> 驱动程序模型的棘手部分是设备驱动程序绑定。 该过程本身非常简单：我们将设备与每个可用的驱动程序匹配，直到适合为止。 仅缺少两个部分-匹配逻辑和一些要匹配的数据。 </p><br><p> 在sdm中，匹配逻辑以<code>_poll()</code>的名称存在于驱动程序中。 这是一个常规方法，使用设备句柄作为参数调用该方法，如果设备无法连接到驱动程序，则分别返回<code>true</code>或<code>false</code> 。 </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- get device attribute "id" if attr == nil then return false end -- if it does not have one, driver does not match -- parent name must be "ESP8266_1W" and first byte of "id" must be "0x28" return (sdm.device_name(par) == "ESP8266_1W") and (attr:byte(1) == 0x28) end )</span></span></code> </pre> <br><p> 如上例所示，驱动程序使用属性来匹配设备。 但是如上所述，属性仅与驱动程序关联。 通常，这是正确的，但是有些属性无法通过软件检索。 这些是芯片ID，使用的引脚等。 对于那些特殊类型的属性已添加到sdm- <em>local属性</em> 。 此属性与设备的一个实例相关联，通常是不可变的。 </p><br><p> 关于驱动程序绑定，只剩下一句话要说。 通常，设备在使用后需要在启动和清除时进行某种初始化。 为此，sdm使用<code>_init()</code>和<code>_free()</code>方法。 <br> 如果驱动程序具有<code>_init()</code>方法，则将在设备绑定后自动调用它。 与<code>_free()</code>相同。 </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> sdm.device_rename(dev, sdm.request_name(<span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- rename device sdm.attr_copy(dev, "temp") -- copy attribute sdm.attr_copy(dev, "precision") -- copy attribute local met = sdm.method_dev_handle(par, "setup") -- get 1Wire bus pin init function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end ) sdm.method_add(drv, "_free", nil, function(dev, drv, par) local met = sdm.method_dev_handle(par, "free") -- get 1Wire bus pin free function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end )</span></span></code> </pre> <br><p> 细心的读者可能会问：上例中的“复制属性”是什么意思？ 他是正确的，因为这与我们尚未讨论的第三种属性<em>-private属性有关</em> 。 在所有设备实例之间共享所有属性数据没有太大意义。 为此，sdm提供了从驱动程序复制属性并将其与设备关联的机制。 这使驱动程序属性成为原型或模板。 </p><br><p> 快速总结： </p><br><ul><li>  <em>本地属性</em>用于无法通过软件检索的数据。 像设备ID，连接的引脚等。 </li><li>  <em>驱动程序属性</em>用于在连接到该驱动程序的所有设备实例之间共享的数据。 </li><li>  <em>私有属性</em>是从驱动程序<em>属性</em>中复制的，并且仅保留与一个设备实例关联的数据。 这种类型是最常见的。 </li></ul><br><div class="scrollable-table"><table><thead><tr><th> 物业资料 </th><th> 本地属性 </th><th> 私人属性 </th><th> 驱动程序（公共）属性 </th></tr></thead><tbody><tr><td> 存放于 </td><td> 装置 </td><td> 装置 </td><td> 司机 </td></tr><tr><td> 使用驱动程序句柄可访问 </td><td>  -- </td><td>  -- </td><td>  + </td></tr><tr><td> 使用设备手柄可访问 </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td> 设备之间共享 </td><td>  -- </td><td>  -- </td><td>  + </td></tr><tr><td> 坚持驾驶员分离 </td><td>  + </td><td>  -- </td><td>  + </td></tr></tbody></table></div><br><h1 id="web-user-interface-implementation">  Web用户界面实现 </h1><br><h2 id="server-code"> 服务器代码 </h2><br><p> 有一个可爱的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/marcoskirsch/nodemcu-">nodemcu-httpserver</a>项目，该项目为NudeMCU实现服务器代码。 可悲的是它似乎已经死了。 它被用作服务器的基础。 首先，将服务器功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">移至LFS</a> ，然后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://gitlab.com/matsievskiysv/nodemcu-pseudo">稍作修改</a>以为每个调用提供一个静态页面。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vue.js</a>是基于模板的网页的理想选择。 因此它被用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前端</a> 。 值得注意的是，NodeMCU可能未连接到Internet。 因此， <code>vue.js</code>库需要在本地存在并由NodeMCU服务器提供服务。 </p><br><p> 由于所有设备均以树结构组织，因此可以像访问目录一样访问它们： <code>/ESP8266/ESP8266_1W/DS18S20-0</code> 。 在这里<code>/ESP8266</code>是NodeMCU页面， <code>/ESP8266/ESP8266_1W</code>是<em>1Wire</em>总线页面，最后<code>/ESP8266/ESP8266_1W/DS18S20-0</code>是温度传感器。 </p><br><p> 如前所述，所有设备页面都是从一个模板页面构建的，每个呼叫都可以使用该模板页面。 然后，此页面内的<em>JS</em>代码会向<code>/api</code> URL前面的相同URL发出请求。 对于上面的示例，调用URL为<code>/api/ESP8266/ESP8266_1W/DS18S20-0</code> 。 对于此类请求，服务器将使用<em>JSON</em>编码的设备特定数据进行响应，该数据将填充页面。 当然，如果仅需要原始数据，则可以跳过<em>HTML</em>页面请求。 </p><br><h2 id="device-tree"> 设备树 </h2><br><p> 初始设备配置使用<em>简单的设备树</em>结构完成。 它就像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设备树</a> ，但是更简单。 它描述了包括设备本地属性在内的硬件配置。 </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> root={ <span class="hljs-comment"><span class="hljs-comment">-- local_attributes={}, children={ { name="ESP8266_1W", -- local_attributes={}, children = { { name="DS18S20-0", -- static declaration alternative to 1Wire poll method local_attributes={ { name="id", desc=nil, -- empty description to save space data=string.char(16) .. string.char(221) .. string.char(109) .. string.char(104) .. string.char(3) .. string.char(8) .. string.char(0) .. string.char(150) -- ugly way to create byte array }, { datapin=2 } } }, } }, { name="ESP8266_SPI", -- local_attributes={}, children = { { name="MCP3208-0" }, } }, } }</span></span></code> </pre> <br><h2 id="hardware-setup"> 硬件设定 </h2><br><p> 从这里开始展示。 为此，将一堆传感器连接到NodeMCU： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DS18B20</a>温度传感器 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DS18S20</a>温度传感器 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MCP3208</a> ADC </li></ul><br><p>  <em>1Wire</em>传感器连接到同一引脚。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fb/sw/zi/fbswzi7xav_pj4waz6g19hktrso.jpeg"></a> </p><br><h2 id="web-pages-and-drivers"> 网页和驱动程序 </h2><br><h3 id="root-device"> 根设备 </h3><br><p> 根设备（aka ESP8266）的主要用途是为其子设备提供连接的地方。 但是，不限于与之关联的方法或属性。 </p><br><p> 此代码段来自<a href="">此处</a> ： </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- get device "id" attribute sdm.attr_set(attr, node.chipid()) -- set "id" value attr = sdm.attr_handle(dev, "float") -- get device "float" attribute sdm.attr_set(attr, 3 / 2 ~= 1) -- set to true if firmware supports floating point instructions end ) sdm.attr_add(drv, "float", "Floating point build", false, function(drv) -- attribute value is set inside "_init" function local attr = sdm.attr_drv_handle(drv, "float") return sdm.attr_data(attr) -- just return stored value end, nil )</span></span></code> </pre> <br><p> 这段代码添加了<code>float</code>属性，该属性用于保存固件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构建类型</a> 。 它的值在<code>_init()</code>挂钩中初始化，该挂钩是一个特殊函数，当驱动程序连接到设备时，它将运行一次。 </p><br><p> 这是根设备的生成页面。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mg/5q/lo/mg5qlog3-nwjkl6itrfw6ynyvuo.png"></a> </p><br><p> 在这里，我们可以看到根设备有一个方法<code>heap</code> ，两个驱动程序属性<code>float</code>和<code>id</code> 。 最后，它连接了两个设备<em>-SPI</em>和<em>1Wire</em>总线。 </p><br><h3 id="spi">  SPI </h3><br><p>  <a href=""><em>SPI</em>驱动程序</a>不是很有趣。 它仅映射<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NodeMCU SPI</a>功能。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qx/mx/g8/qxmxg8mnkmnl5aglfq7q5zhpnv0.png"></a> </p><br><h3 id="mcp3208">  mcp3208 </h3><br><p>  <em>MCP3208</em>是<em>ADC</em>芯片。 它测量从零到<em>参考</em>电压，并返回12位代码。 此<a href="">驱动程序</a>实现的有趣之处在于，只有在固件支持浮点运算的情况下，属性<code>ref</code>才会出现。 如果不支持，则使用绝对值和<code>differential</code>方法返回电压代码，而不是绝对电压。 </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"single"</span></span>, <span class="hljs-string"><span class="hljs-string">"Single ended measure 0|1|2|3|4|5|6|7"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, channel)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... if ref ~= nil then -- this part is executed only if floating point arithmetic is enabled rv = ref * rv / 4096 end return rv end ) if 3/2~=1 then -- other alternative is to access ESP8266 "float" method sdm.attr_add(drv, "ref", "Reference voltage", 5, function(dev) return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end ) end</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/m_/_l/cc/m__lccntxwsrorrujvky3opbm0s.png"></a> </p><br><p> 另请注意，该设备的属性<code>ref</code>标记为<em>private</em> 。 它是按设备设置的。 </p><br><h3 id="1wire">  1线 </h3><br><p>  <a href=""><em>1</em>驱动程序驱动程序</a>实现<code>poll</code>方法- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动态搜索设备</a> 。 </p><br><p> 发现设备后，其类型立即未知。 因此，其<em>1Wire</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唯一地址</a>用作新的设备名称（字节表示为以<code>_</code>字符分隔的数字）。 </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"poll"</span></span>, <span class="hljs-string"><span class="hljs-string">"Poll for devices"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bus, pin)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> children = sdm.device_children(bus) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {} <span class="hljs-comment"><span class="hljs-comment">-- already attached local ids = {} -- get IDs of attached devices for name, handle in pairs(children) do local dpin = sdm.attr_data(sdm.local_attr_handle(handle, "pin")) if dpin == pin then ids[sdm.attr_data(sdm.local_attr_handle(handle, "id"))] = true end end ow.reset_search(pin) -- reset previous search while true do -- for all found devices local id = ow.search(pin) if id == nil then break end if ids[id] == nil then -- if not already present local name = "" for i=1,#id do name = name .. tostring(id:byte(i)) .. "_" end name = name:sub(1,-2) -- add to system with their ID used as name local device = sdm.device_add(name, bus) -- add "pin" attribute local rv = sdm.local_attr_add(device, "datapin", nil, pin, nil, nil) -- add "id" attribute local rv = sdm.local_attr_add(device, "id", nil, id, nil, nil) -- poll for driver local rv = sdm.device_poll(device) end end end )</span></span></code> </pre> <br><p> 这是<em>1Wire</em>驱动程序的初始页面。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/j2/uq/ax/j2uqaxkhqilv0k1fmwaq2hn0iwq.png"></a> </p><br><p> 在发出带有参数<code>2</code> <code>poll</code>并刷新页面后，出现子部分。 请注意，子名称是人类可读的。 这是因为<code>device_rename()</code>函数在其<code>_init</code>期间被调用。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/_z/2x/na/_z2xnadqlt_qgyokfxomwivtwkq.png"></a> </p><br><h3 id="ds18s20">  DS18S20 </h3><br><p> 初始化后， <a href="">DS18S20驱动程序将</a>检查设备<em>ID</em>是否以设备家族代码<code>0x10</code>开头。 将设备连接到驱动程序后，它将重命名为<code>DS18S20-X</code> ，其中<code>DS18S20</code>是基本名称， <code>X</code>是实例编号。 </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attr == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (sdm.device_name(par) == <span class="hljs-string"><span class="hljs-string">"ESP8266_1W"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (attr:<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0x10</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- check family ID end ) sdm.method_add(drv, "_init", nil, function(dev, drv, par) sdm.device_rename(dev, sdm.request_name("DS18S20")) -- rename device sdm.attr_copy(dev, "temp") -- copy attribute to device local met = sdm.method_dev_handle(par, "setup") local func = sdm.method_func(met) -- use parent "setup" method on the device func(par, dev) end )</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/bm/pk/41/bmpk419dphexm-xlvnxq7hw2jxc.png"></a> </p><br><p> 本地属性<code>id</code>和<code>datapin</code>没有<code>getter</code>和<code>setter</code>钩子，因此仅可见其名称。 </p><br><h3 id="ds18b20">  DS18B20 </h3><br><p>  <a href="">DS18B20驱动程序</a>与<a href="">DS18S20驱动程序</a>几乎相同。 唯一的区别是<code>precision</code>方法。 两个<em>DS18？20</em>驱动程序均假定为整数生成，并且不使用浮点除法。 </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>, <span class="hljs-string"><span class="hljs-string">"Precision (9|10|11|12)"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdm.attr_data(attr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> par = sdm.device_parent(dev) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ex = sdm.method_func(sdm.method_dev_handle(par, <span class="hljs-string"><span class="hljs-string">"exchange"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> modes = {[<span class="hljs-number"><span class="hljs-number">9</span></span>]=<span class="hljs-number"><span class="hljs-number">0x1f</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span>]=<span class="hljs-number"><span class="hljs-number">0x3f</span></span>, [<span class="hljs-number"><span class="hljs-number">11</span></span>]=<span class="hljs-number"><span class="hljs-number">0x5f</span></span>, [<span class="hljs-number"><span class="hljs-number">12</span></span>]=<span class="hljs-number"><span class="hljs-number">0x7f</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modes[precision] ~= <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ex(par, dev, {<span class="hljs-number"><span class="hljs-number">0x4e</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, modes[precision]}) sdm.attr_set(attr, precision) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> )</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/er/lj/gb/erljgbs9zby8767izkmsunyhdd8.png"></a> </p><br><h2 id="memory-usage"> 内存使用量 </h2><br><p>  <em>ESP8266的</em>可用内存约为<em>40k</em> 。 服务器代码已移至<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">LFS</a> ，因此在初始化时它不会占用任何RAM空间（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://github.com/marcoskirsch/nodemcu-">原始代码</a>大约需要<em>10k</em> ）。 </p><br><p> 对于5个设备驱动程序和5个设备， <em>SDM</em>大约需要1 <em>万</em> 。 非浮动固件版本略小。 因此，最好在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">驱动程序清单中</a>选择仅手头任务所需的驱动程序。 最消耗内存的任务是提供<code>vue.js</code>库。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yy/u-/_i/yyu-_idkp2osapmg3-jy5z2r8ly.png"></a> </p><br><p> 在请求原始<em>JSON</em>编码的数据（使用<code>curl</code> ）的情况下，峰值内存消耗可能会大大减少。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/w_/hu/xx/w_huxxzt4w2wszdqq04bgbonbt0.png"></a> </p><br><h2 id="instead-of-an-epilogue"> 而不是结尾 </h2><br><p> 我使用sdm实施的第一种方法是绑定 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>node.restart()</code></a> 。 <br> 使用Web用户界面进行尝试产生了一个奇怪的结果。  Web浏览器发出请求后，芯片立即按预期方式重新启动。 但是由于NodeMCU无法正确响应HTTP请求，因此Web浏览器再次尝试了相同的请求。 当NodeMCU服务器重新启动并再次启动时，浏览器已连接到它，重置内部重<em>试</em>计数器并调用了<code>node.restart()</code>方法，从而开始了NodeMCU重新启动的无限循环。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449992/">https://habr.com/ru/post/zh-CN449992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449976/index.html">C ++中的多线程关联容器。 Yandex报告</a></li>
<li><a href="../zh-CN449978/index.html">莫斯科特斯拉俱乐部的伊戈尔·安塔洛夫（Igor Antarov）挣扎着关于特斯拉和电动汽车的20个神话</a></li>
<li><a href="../zh-CN449984/index.html">Google新闻和列夫·托尔斯泰：使用t-SNE可视化Word2Vec单词嵌入</a></li>
<li><a href="../zh-CN449986/index.html">区块链：我们应该建立一个案例？</a></li>
<li><a href="../zh-CN449990/index.html">如何交朋友乳胶，配方和哈伯？</a></li>
<li><a href="../zh-CN449994/index.html">施耐德曼的八个黄金法则将帮助您创建更好的界面</a></li>
<li><a href="../zh-CN449996/index.html">了解FFT算法</a></li>
<li><a href="../zh-CN449998/index.html">常见问题解答：旅行者极客在旅行之前需要了解哪些疫苗</a></li>
<li><a href="../zh-CN450000/index.html">（从右到左（通过窥镜</a></li>
<li><a href="../zh-CN450002/index.html">使用PVS-Studio查找LLVM 8中的错误</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>