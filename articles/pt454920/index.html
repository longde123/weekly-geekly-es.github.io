<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüëß üë∏üèº üöç Desempenho do front end: analisando m√©tricas importantes üë®üèø‚Äçü§ù‚Äçüë®üèæ üö• üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Normalmente, o desempenho √© entendido como o n√∫mero de opera√ß√µes para um determinado intervalo de tempo e, quanto mais delas, melhor. Mas essa defini√ß...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desempenho do front end: analisando m√©tricas importantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Normalmente, o desempenho √© entendido como o n√∫mero de opera√ß√µes para um determinado intervalo de tempo e, quanto mais delas, melhor.  Mas essa defini√ß√£o e a abordagem como um todo t√™m pouca aplicabilidade ao front-end, porque cada usu√°rio ter√° seu pr√≥prio "front-end".  √â sobre isso que eu quero falar, o que est√° acontecendo ‚Äúl√°‚Äù, com o usu√°rio, do outro lado, na realidade, e n√£o no seu MacBook de topo. <br><br>  Al√©m disso, tentarei considerar brevemente as regras gerais para otimizar o c√≥digo e alguns erros que merecem aten√ß√£o.  Tamb√©m vou falar sobre uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta</a> que ajuda n√£o apenas na cria√ß√£o de perfis, mas tamb√©m pronta para o uso, que re√∫ne v√°rias m√©tricas b√°sicas sobre o desempenho do seu aplicativo (e espero que voc√™ leia esta postagem at√© o final). <br><a name="habracut"></a><br>  Primeiro, determinaremos o que √© desempenho de front-end e depois passaremos a como medi-lo.  Portanto, como eu disse, n√£o mediremos algumas opera√ß√µes / segundo, precisamos de dados reais que possam responder √† pergunta do que exatamente acontece com o nosso projeto em cada etapa do seu trabalho.  Para fazer isso, precisamos do seguinte conjunto de m√©tricas: <br><br><ul><li>  velocidade de download; </li><li>  hora da primeira renderiza√ß√£o e interatividade (Time To Interactive); </li><li>  velocidade de rea√ß√£o √†s a√ß√µes do usu√°rio; </li><li>  FPS para rolagem e anima√ß√µes; </li><li>  inicializa√ß√£o de aplicativo; </li><li>  se voc√™ tiver um SPA, precisar√° medir o tempo gasto na altern√¢ncia entre rotas; </li><li>  consumo de mem√≥ria e tr√°fego; </li><li>  e ... o suficiente por enquanto. </li></ul><br>  Todas essas s√£o m√©tricas b√°sicas, sem as quais √© imposs√≠vel entender o que exatamente est√° acontecendo no front-end.  E n√£o apenas no front-end, mas na realidade, com o usu√°rio final.  Mas, para come√ßar a coletar essas m√©tricas, primeiro voc√™ precisa aprender como medi-las, ent√£o vamos lembrar quais m√©todos existem para a an√°lise de desempenho. <br><br>  A primeira coisa a come√ßar √©, obviamente, a API de desempenho.  Ou seja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">performance.timing</a> , atrav√©s do qual voc√™ pode descobrir quanto tempo um usu√°rio levou para abrir seu projeto.  Mas a API de desempenho cobre apenas parte da m√©trica, o restante precisar√° ser medido por n√≥s mesmos e, para isso, temos as seguintes ferramentas: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Pr√≥s</sub> </th><th>  <sub>Contras</sub> </th></tr><tr><td>  <sub>console.time ('label')</sub> </td><td>  <sub>Trabalha fora da caixa.</sub> <sub><br><br></sub>  <sub>√â exibido no console.</sub> <sub><br><br></sub>  <sub>Aparece no DevTools -&gt; Desempenho -&gt; Tempo do usu√°rio.</sub> </td><td> A sa√≠da √© apenas no DevTools, n√£o h√° como envi√°-la ao servidor (ou seja, n√£o h√° como obter um valor para an√°lises adicionais). <br><br>  Requer <code>console.timeEnd</code> com o <code>label</code> original. <br><br>  Sem c√≥digo de cores. <br><br>  Sem agrupamento (algo como <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Controle total sobre o come√ßo e o fim. <br><br>  Voc√™ pode enviar para o servidor. <br><br></td><td>  N√£o h√° exibi√ß√£o no console. <br><br>  N√£o h√° exibi√ß√£o no DevTools -&gt; Desempenho -&gt; Tempo do usu√°rio. <br><br>  Voc√™ precisa arrastar a vari√°vel "start". <br><br>  Sem agrupamento. </td></tr><tr><td>  performance.mark / measure </td><td>  Controle total sobre o come√ßo e o fim. <br><br>  Voc√™ pode enviar para o servidor. <br><br>  Aparece no DevTools -&gt; Desempenho -&gt; Tempo do usu√°rio. </td><td>  N√£o h√° exibi√ß√£o no console. <br><br>  Para medir algo, voc√™ precisa definir tr√™s r√≥tulos exclusivos e chamar dois m√©todos, mas tamb√©m precisa de <code>performance.clearMarks</code> e <code>performance.clearMeasures</code> , o que torna extremamente inconveniente. <br><br>  Sem agrupamento. </td></tr></tbody></table></div>  Naquele momento, percebi que voc√™ precisava ver uma ferramenta que combinasse as vantagens das op√ß√µes acima e, se poss√≠vel, n√£o tivesse desvantagens.  Ent√£o havia o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Controle total sobre o come√ßo e o fim. </li><li>  Voc√™ pode enviar para o servidor. </li><li>  √â exibido no console. </li><li>  Suporta DevTools -&gt; Desempenho -&gt; Tempo do Usu√°rio. </li><li>  Existe um agrupamento. </li><li>  Existe um c√≥digo de cores (assim como unidades de medida, ou seja, voc√™ pode medir n√£o apenas o tempo). </li><li>  Suporta extens√µes. </li></ul><br>  Agora n√£o pintarei a API aqui, n√£o escrevi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> para isso, e o artigo n√£o √© sobre isso, mas continuarei a coletar m√©tricas. <br><br><br><h2>  Velocidade de download da p√°gina </h2>  Como eu j√° disse, voc√™ pode descobrir a velocidade do download em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">performance.timing</a> , que permitir√° descobrir o ciclo completo desde o in√≠cio do carregamento da p√°gina (hora de resolver o DNS, instalar o HTTP Handshake, processar a solicita√ß√£o) e at√© que a p√°gina esteja totalmente carregada (DomReady e OnLoad): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Como resultado, voc√™ deve obter o seguinte conjunto de m√©tricas: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Um exemplo da extens√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navega√ß√£o</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Mas isso n√£o basta, obtivemos apenas os valores b√°sicos e ainda n√£o sabemos o que exatamente levou tanto tempo.  E para descobrir, voc√™ tamb√©m precisa preencher as m√©tricas HTML. <br><br>  Como eu j√° disse, mostrarei exemplos usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> , ent√£o a primeira coisa a fazer √© embutida no pr√≥prio <code>&lt;hed/&gt;</code> PerfKeeper (2,5 Kb) e mais: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Como resultado, voc√™ ver√° tanta beleza no console: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Este √© um m√©todo cl√°ssico de medi√ß√£o do av√¥, 100% funciona.  Mas o mundo n√£o fica parado e, para medi√ß√µes mais precisas, agora temos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de Tempo de Recurso</a> (e se os recursos estiverem em um dom√≠nio separado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tempo de Permiss√£o de Origem</a> para ajud√°-lo). <br><br>  E aqui vale a pena falar sobre erros cl√°ssicos durante o carregamento inicial da p√°gina, a saber: <br><br><ul><li>  falta de GZip e HTTP / 2 (sim, isso ainda √© comum); </li><li>  uso irracional de fontes (algumas vezes, uma fonte √© conectada apenas por um cabe√ßalho ou at√© mesmo um n√∫mero de telefone no rodap√© 0_o); </li><li>  Pacotes CSS / JS muito gen√©ricos. </li></ul><br>  Maneiras de otimizar o carregamento da p√°gina: <br><br><ul><li>  use Brotli (ou mesmo SDCH) em vez de GZip, ative HTTP / 2; </li><li>  Colete apenas o CSS necess√°rio (cr√≠tico) e n√£o se esque√ßa do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CSSO</a> ; </li><li>  minimizar o tamanho do pacote JS separando o pacote CORE m√≠nimo e carregar o restante sob demanda, ou seja,  assincronamente; </li><li>  carregue JS e CSS no modo sem bloqueio, criando dinamicamente <code>/&gt;  &lt;sript src="..."/&gt;</code> , idealmente carregue JS ap√≥s o conte√∫do principal; </li><li>  use SVG em vez de PNG e, se combinado com JS, ele se livrar√° de XML redundante (por exemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">font-awesome</a> ); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">use carregamento lento</a> para imagens e iframes (al√©m disso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte nativo</a> aparecer√° em um futuro pr√≥ximo). </li></ul><br><br><h2>  Primeira renderiza√ß√£o e interatividade (TTI) </h2>  O pr√≥ximo est√°gio ap√≥s o carregamento √© o momento em que o usu√°rio viu o resultado e a interface entrou no modo interativo.  Para isso, precisamos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Performance Paint Timing</a> e do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerformanceObserver</a> . <br><br>  O primeiro √© simples, chamamos <code>performance.getEntriesByType('paint')</code> e obtemos duas m√©tricas: <br><br><ul><li>  primeira pintura - a primeira renderiza√ß√£o; </li><li>  primeira pintura com conte√∫do - e a primeira renderiza√ß√£o completa. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Um exemplo da extens√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tinta</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Mas com a pr√≥xima m√©trica, Time To Interactive, √© um pouco mais interessante.  N√£o h√° uma maneira exata de determinar quando seu aplicativo se tornou interativo, ou seja,  acess√≠vel ao usu√°rio, mas isso pode ser indiretamente entendido pela aus√™ncia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">longas tarefas</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Um exemplo da extens√£o de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Al√©m dessas m√©tricas b√°sicas, tamb√©m √© necess√°ria a m√©trica de prontid√£o do aplicativo, ou seja,  algures no seu c√≥digo deve ser assim: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // Ô∏èapplication-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Taxa de resposta √†s a√ß√µes do usu√°rio </h2>  H√° um campo enorme para as m√©tricas e elas s√£o muito individuais, por isso vou falar sobre duas b√°sicas que s√£o adequadas para qualquer projeto, a saber: <br><br>  <b>primeiro evento</b> - a hora do primeiro evento, por exemplo, o primeiro clique (dividindo onde o usu√°rio cutucou), essa m√©trica √© especialmente relevante para todos os tipos de resultados de pesquisa, uma lista de produtos, feeds de not√≠cias etc.  Com ele, voc√™ pode controlar como o tempo de rea√ß√£o e o usu√°rio fluem de suas a√ß√µes (altera√ß√µes em: design / novos recursos / otimiza√ß√µes, etc.) <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Um exemplo da extens√£o de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>lat√™ncia</b> - atraso no processamento de alguns eventos, por exemplo: <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> etc. <br><br>  Para medir o atraso, basta travar o manipulador de eventos na <code>window</code> com <code>capture = true</code> e use <code>requestAnimationFrame</code> calcular a diferen√ßa, este ser√° o atraso: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Um exemplo da extens√£o de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> trabalhando quando um n√∫mero de Fibonacci √© calculado em um clique.</i> <br><br><br><h2>  FPS ao rolar e animar </h2>  Essa √© a m√©trica mais interessante, geralmente √© medida por <code>requestAnimationFrame</code> e, se voc√™ precisar fazer medi√ß√µes constantes de FPS, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FPSMeter</a> cl√°ssico far√° (embora seja muito otimista).  Mas n√£o funciona se voc√™ precisar medir a suavidade da rolagem da p√°gina, porque  ele precisa de um aquecimento.  E ent√£o me deparei com uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maneira</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interessante</a> . <br><br>  De maneira engenhosa, na verdade, simplesmente criamos uma div transparente (1x1px), adicionamos <code>transition: left 300ms linear</code> e a executamos de um canto a outro, e enquanto anima, atrav√©s de <code>requestAnimationFrame</code> verificamos sua esquerda real e, se o novo comprimento for diferente do anterior, aumente o n√∫mero de quadros renderizados (caso contr√°rio, temos um rebaixamento de FPS). <br><br>  E isso n√£o √© tudo, se voc√™ usa o FF, simplesmente existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mozPaintCount</a> , respons√°vel pelo n√∫mero de quadros renderizados, ou seja,  lembramos de "DO" e, no <code>transitionend</code> da <code>transitionend</code> , calculamos a diferen√ßa. <br><br>  Total, sem nenhum aquecimento, sabemos com certeza se o navegador redesenha o quadro ou n√£o. <br><br>  Eles logo prometem uma API normal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Um exemplo da extens√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fps</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Otimiza√ß√£o de rolagem: <br><br><ul><li>  o mais simples √© n√£o fazer nada na rolagem ou atrasar a execu√ß√£o por meio de <code>requestAnimationFrame</code> ou mesmo <code>requestIdleCallback</code> ; </li><li>  use muito cuidadosamente <code>pointer-events: none</code> , ativ√°-lo e desativ√°-lo pode ter o efeito oposto; portanto, √© melhor realizar um experimento A / B usando <code>pointer-events</code> e sem; </li><li>  n√£o se esque√ßa das listas virtualizadas, quase todos os mecanismos do View agora possuem esses componentes, mas, novamente, tenha cuidado, os elementos dessa lista devem ser o mais simples poss√≠vel ou use "manequins" que ser√£o substitu√≠dos por elementos reais depois que a rolagem for conclu√≠da.  Se voc√™ mesmo escrever uma lista virtualizada, n√£o haver√° HTML interno e n√£o se esque√ßa da reciclagem do DOM (√© quando voc√™ n√£o cria elementos DOM para cada espirro, mas os reutiliza). </li></ul><br><br><h2>  Inicializa√ß√£o de aplicativo </h2>  H√° apenas uma regra: detalhe para que voc√™ possa responder exatamente quanto tempo consumiu desde a inicializa√ß√£o do aplicativo at√© o lan√ßamento final.  Como resultado, voc√™ deve obter pelo menos as seguintes m√©tricas: <br><br><ul><li>  quanto tempo levou para resolver cada v√≠cio; </li><li>  tempo para receber e preparar dados para a aplica√ß√£o; </li><li>  processar aplicativo com detalhamento por blocos. </li></ul><br>  I.e.  na sa√≠da, voc√™ deve obter essas m√©tricas pelas quais pode rastrear com precis√£o exatamente em qual fase o seu rebaixamento est√° ocorrendo. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de trabalho</b> <div class="spoiler_text">  <b>Console</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Tempo do usu√°rio</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Se voc√™ tem SPA, precisa medir o tempo de roteamento </h2>  Primeiro, deve haver uma m√©trica geral para avaliar o desempenho (tempo de tr√¢nsito na rota) como um todo, mas tamb√©m √© necess√°rio ter uma m√©trica para cada rota (por exemplo, temos uma "Lista de threads", "Lendo um thread", "Pesquisa" etc. d.), a pr√≥pria m√©trica deve ser dividida em m√©tricas: <br><br><ul><li>  Recebendo dados (com uma discrimina√ß√£o de quais) <ul><li>  Processamento </li><li>  Update </li></ul></li><li>  Render <ul><li>  Aplica√ß√£o total </li><li>  Blocos (por exemplo, conosco, ser√°: "Coluna esquerda" (tamb√©m conhecida como "Lista de pastas"), "Barra de pesquisa inteligente", "Lista de letras" e similares) </li></ul></li></ul><br>  Sem tudo isso, √© imposs√≠vel entender onde os problemas come√ßam, portanto, temos muitos m√≥dulos <code>endTime</code> para uso com intervalos de tempo (por exemplo, o mesmo m√≥dulo para o XHR possui <code>endTime</code> e <code>endTime</code> , que s√£o registrados automaticamente). <br><br>  Mas essas m√©tricas n√£o s√£o suficientes para avaliar adequadamente o que est√° acontecendo.  Eles s√£o muito gerais porque  como estamos falando de SPA, voc√™ definitivamente tem algum tipo de cache de tempo de execu√ß√£o (para n√£o voltar ao servidor novamente se j√° estiver l√°), para que nossas m√©tricas sejam divididas em roteamento com e sem cache.  Ainda assim, especificamente em nosso caso, dividimos a m√©trica pelo n√∫mero de entidades nela.  Em outras palavras, voc√™ n√£o pode adicionar a visualiza√ß√£o "Encadeamento" com 1, 5, 10 ou mais de 100 letras em uma m√©trica. Portanto, se voc√™ tiver alguma lista exibida, precisar√° selecionar pontos de interrup√ß√£o e separar ainda mais a m√©trica. <br><br><br><h2>  Consumo de mem√≥ria e tr√°fego </h2>  <b>Vamos come√ßar com a mem√≥ria</b> .  E aqui estamos esperando uma grande decep√ß√£o.  No momento, h√° apenas performance.memory n√£o padronizada (somente Chrome), o que fornece n√∫meros ridiculamente baixos.  Mas eles ainda precisam ser medidos e observar como o aplicativo "flui" ao longo do tempo: <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Um exemplo da extens√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mem√≥ria</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Tr√°fego</b>  Para contar o tr√°fego, voc√™ precisar√° do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Timing-Allow-Origin</a> (se os recursos estiverem localizados em um dom√≠nio separado) e da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resource Timing</a> , isso ajudar√° n√£o apenas a calcular o tr√°fego, mas tamb√©m a detalhar: <br><br><ul><li>  qual protocolo √© usado (HTTP / 1, HTTP / 2 etc.); </li><li>  tipos de recursos carregados; </li><li>  quanto tempo levou para baix√°-los; </li><li>  Al√©m disso, voc√™ pode entender se o recurso est√° carregado na rede ou extra√≠do do cache. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Um exemplo da extens√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recurso</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  O que d√° contagem de tr√°fego? <br><br><ul><li>  O mais importante √© que ele permite que voc√™ veja a imagem real, e n√£o como sempre com CSS + JS e al√©m disso, como essa "imagem" muda com o tempo. </li><li>  Depois, voc√™ pode analisar o que exatamente est√° carregado, dividir recursos em grupos etc. </li><li>  Qu√£o bem o cache funciona para voc√™. </li><li>  Existem anomalias, por exemplo, ap√≥s 15 minutos de opera√ß√£o, por exemplo, o c√≥digo entrou em recurs√£o e carrega algum recurso sem parar, o monitoramento do tr√°fego ajudar√° nisso. </li></ul><br>  Bem, um relat√≥rio de atualiza√ß√£o do meu colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Igor Druzhinin</a> sobre este t√≥pico: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Avaliando a qualidade do aplicativo - monitorando o consumo de tr√°fego</a> <br><br><br><h2>  Google Analytics </h2>  Montamos as m√©tricas e depois o que?  E ent√£o eles precisam ser enviados para algum lugar.  E aqui voc√™ escolhe um pouco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grafite</a> ou, para come√ßar, pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Analytics</a> ou similar para agrega√ß√£o de dados para ganho pessoal. <br><br>  E n√£o se esque√ßa, n√£o basta apenas obter um cronograma; para todas as m√©tricas importantes, deve haver percentis que permitam entender, por exemplo, qual a porcentagem de p√∫blico que o projeto est√° carregando para &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s +, etc. <br><br><br><h2>  Escrevendo um c√≥digo de alto desempenho </h2>  No come√ßo, eu queria escrever algo significativo aqui, eles dizem usar WebWorker, n√£o se esque√ßa de <code>requestIdleCallback</code> ou algo ex√≥tico, por exemplo, atrav√©s do Runtime Cache, atrav√©s de guias do navegador usando SharedWorker ou ServiceWorker (que n√£o √© apenas sobre cache, se isso).  Mas tudo isso √© muito abstrato e muitos t√≥picos s√£o superados pela impossibilidade; basta escrever o seguinte: <br><br><ol><li>  Inicialmente, cubra seu c√≥digo com m√©tricas que medem seu desempenho. </li><li>  N√£o acredite nos benchmarks com o jsperf.  A grande maioria deles √© mal escrita e simplesmente retirada de contexto.  A melhor refer√™ncia √© a m√©trica real do projeto, segundo a qual voc√™ ver√° o efeito de suas a√ß√µes. </li><li>  Lembre-se da percep√ß√£o de produtividade, ou melhor, da Lei de Weber-Fechner.  Nomeadamente, se voc√™ iniciou a otimiza√ß√£o, n√£o execute as altera√ß√µes at√© que se tornem melhores pelo menos em 20%, caso contr√°rio os usu√°rios simplesmente n√£o perceber√£o.  A lei tamb√©m funciona na dire√ß√£o oposta. </li><li>  Medo regulares, especialmente aqueles gerados.  Eles n√£o apenas podem travar o navegador, mas tamb√©m obter o XSS, e √© por isso que no nosso Mail √© proibido analisar o HTML usando-os, apenas atrav√©s de um desvio do DOM. </li><li>  Voc√™ n√£o precisa usar matrizes para inserir um valor em um ou outro grupo; para isso, existe um <code>object</code> ou um <code>Set</code> (por exemplo, <code>successSteps.includes(currentStep)</code> necess√°rio <code>successSteps.hasOwnProperty(currentStep)</code> ), O (1) √© tudo. </li><li>  A express√£o "Otimiza√ß√£o prematura √© a raiz de todos os males" n√£o √© sobre escrever o que voc√™ quiser.  Se voc√™ sabe qual a melhor forma, escreva da melhor maneira. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Escreverei alguns par√°grafos sobre o c√≥digo e sua otimiza√ß√£o</b> <div class="spoiler_text">  <b>DOM</b>  Muitas vezes ou√ßo ‚ÄúO Problema no DOM‚Äù - isso, √© claro, √© verdade, mas dado que quase todo mundo agora tem uma abstra√ß√£o sobre ele.  √â ela quem se torna o gargalo, ou melhor, o seu c√≥digo, respons√°vel pela forma√ß√£o da vis√£o e da l√≥gica de neg√≥cios. <br><br>  Mas se falarmos sobre o DOM, por exemplo, em vez de excluir um fragmento do DOM, √© melhor ocult√°-lo ou anex√°-lo.  Se voc√™ ainda precisar excluir, fa√ßa essa opera√ß√£o em <code>requestIdleCallback</code> (se poss√≠vel) ou divida o processo de destrui√ß√£o em duas fases: s√≠ncrona e ass√≠ncrona. <br><br>  Farei uma reserva imediatamente, use essa abordagem com sabedoria, caso contr√°rio, voc√™ pode dar um tapa no joelho. <br><br>  Tamb√©m usamos outra t√©cnica interessante em listas, por exemplo, a "Lista de T√≥picos".  A ess√™ncia da t√©cnica √© que, em vez de uma "Lista" global e atualiza√ß√£o de seus dados, geramos uma "Lista de threads" para cada "Pasta".  Como resultado, quando o usu√°rio navega entre as "Pastas", uma lista √© removida do DOM (n√£o exclu√≠da) e a outra √© atualizada parcial ou totalmente.  E n√£o todos, como √© o caso da "Lista √önica". <br><br>  Tudo isso fornece uma resposta instant√¢nea √†s a√ß√µes do usu√°rio. <br><br>  <b>Matem√°tica</b>  Removemos facilmente toda a matem√°tica no Worker ou no WebAssembly, pois isso funciona h√° muito tempo. <br><br>  <b>Transpilers</b> .  Ah, muitos nem pensam que o c√≥digo que escrevem passa pelo transpilador.  Sim, eles sabem sobre ele, mas √© tudo.  Mas com o que ele se transforma eles n√£o se importam mais.  De fato, no DevTools, eles veem o resultado do mapa de origem. <br><br>  Portanto, estude as ferramentas que voc√™ usa, por exemplo, a mesma babel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">playground</a> tem a oportunidade de ver em que ele gera c√≥digo, dependendo das predefini√ß√µes selecionadas, basta olhar para o mesmo campo, <code>await</code> ou <code>for of</code> . <br><br>  <b>As sutilezas da l√≠ngua</b> .  Menos pessoas ainda sabem do monomorfismo do c√≥digo, ou brega por que o bind √© lento e ... voc√™ finalmente usa o <code>handleEvent</code> ! <br><br>  <b>Dados e pr√©-grava√ß√£o</b> .  Menos pedidos, mais armazenamento em cache.  Al√©m disso, muitas vezes usamos a t√©cnica de "previs√£o", √© quando, em segundo plano, carregamos dados.  Por exemplo, depois de renderizar a "Lista de threads", come√ßamos a carregar segmentos n√£o lidos na "Pasta" atual, para que, quando voc√™ clicar neles, o usu√°rio mude imediatamente para "Leitura" em vez de outro "carregador".  Usamos uma t√©cnica semelhante, n√£o apenas para Data, mas tamb√©m para JS.  Por exemplo, ‚ÄúEscrever uma carta‚Äù √© um pacote enorme (por causa do editor), e nem todas as pessoas escrevem cartas de uma s√≥ vez; portanto, carregamos em segundo plano, depois que o aplicativo √© inicializado. <br><br>  <b>Louders</b>  N√£o sei por que, mas n√£o vi artigos que ensinavam como n√£o fazer um carregador, mas fiz uma apresenta√ß√£o do React "futuro", no qual muito tempo foi dedicado a esse problema no Suspense.  Mas, afinal, o aplicativo ideal √© sem carregadores, tentamos h√° muito tempo no Mail mostr√°-lo apenas em situa√ß√µes de emerg√™ncia. <br><br>  Em geral, temos essa pol√≠tica, n√£o h√° dados, n√£o h√° vis√£o, n√£o h√° nada para desenhar uma semi-interface, primeiro carregamos os dados e s√≥ depois "desenhamos".  √â por isso que usamos a ‚Äúprevis√£o‚Äù de onde o usu√°rio est√° indo e carregamos esses dados para que o usu√°rio n√£o veja o carregador.  Al√©m disso, nossa camada de dados, que √© persistente, ajuda muito nessa tarefa.  se voc√™ solicitou "Encadeamento" em algum lugar de um local, da pr√≥xima vez que solicitar de outro ou do mesmo local, n√£o haver√° solicita√ß√£o, obteremos dados do Runtime Cache (mais precisamente, um link para os dados).  E assim, em tudo, cole√ß√µes de threads tamb√©m s√£o apenas links para dados. <br><br>  Mas se voc√™ ainda decidir criar um carregador, n√£o esque√ßa as regras b√°sicas que tornar√£o seu carregador menos irritante: <ul><li>  n√£o h√° necessidade de mostrar o carregador imediatamente, no momento do envio da solicita√ß√£o, deve haver um atraso de pelo menos 300-500 ms antes do show; </li><li>  Depois de receber os dados, voc√™ n√£o precisa remover muito o carregador, aqui novamente deve haver um atraso. </li></ul><br>  Essas regras simples s√£o necess√°rias para que o carregador apare√ßa apenas em solicita√ß√µes pesadas e n√£o pisque ap√≥s a conclus√£o.  Mas o mais importante, o melhor carregador √© um carregador que n√£o apareceu. </div></div><br><br>  Obrigado pela aten√ß√£o, isso √© tudo, me√ßa, analise e use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo ao vivo</a> ), al√©m do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu github</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">twitter</a> , em caso de d√∫vidas! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454920/">https://habr.com/ru/post/pt454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454906/index.html">Classifica√ß√£o de plataformas educacionais adicionais em TI: de acordo com os resultados do estudo My Circle</a></li>
<li><a href="../pt454912/index.html">Dwarf Fortress Tarn Adams fala sobre desenvolvimento de jogos</a></li>
<li><a href="../pt454914/index.html">N√≥s usamos o Yii2. Estamos escrevendo outro CMS ou uma tentativa de acelerar significativamente o desenvolvimento com o m√≠nimo de sobrecarga</a></li>
<li><a href="../pt454916/index.html">Arquitetura de rede neural para implementar o algoritmo RL com a capacidade de definir a√ß√µes em execu√ß√£o simultaneamente</a></li>
<li><a href="../pt454918/index.html">Como combinar as costas de dois varejistas no SAP em 12 horas</a></li>
<li><a href="../pt454924/index.html">Configura√ß√µes de autentica√ß√£o no Veeam Backup para Microsoft Office 365 v3</a></li>
<li><a href="../pt454928/index.html">Maneira de ignorar a tela de bloqueio do Windows em sess√µes RDP</a></li>
<li><a href="../pt454930/index.html">Coleta de lixo na V8: como o novo GC Orinoco funciona</a></li>
<li><a href="../pt454932/index.html">Investimentos e software: 5 terminais de negocia√ß√£o para negocia√ß√£o na bolsa</a></li>
<li><a href="../pt454936/index.html">Vivaldi: o bloqueio de an√∫ncios deve ser a escolha do usu√°rio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>