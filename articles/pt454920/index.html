<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👧 👸🏼 🚍 Desempenho do front end: analisando métricas importantes 👨🏿‍🤝‍👨🏾 🚥 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Normalmente, o desempenho é entendido como o número de operações para um determinado intervalo de tempo e, quanto mais delas, melhor. Mas essa definiç...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desempenho do front end: analisando métricas importantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454920/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Normalmente, o desempenho é entendido como o número de operações para um determinado intervalo de tempo e, quanto mais delas, melhor.  Mas essa definição e a abordagem como um todo têm pouca aplicabilidade ao front-end, porque cada usuário terá seu próprio "front-end".  É sobre isso que eu quero falar, o que está acontecendo “lá”, com o usuário, do outro lado, na realidade, e não no seu MacBook de topo. <br><br>  Além disso, tentarei considerar brevemente as regras gerais para otimizar o código e alguns erros que merecem atenção.  Também vou falar sobre uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta</a> que ajuda não apenas na criação de perfis, mas também pronta para o uso, que reúne várias métricas básicas sobre o desempenho do seu aplicativo (e espero que você leia esta postagem até o final). <br><a name="habracut"></a><br>  Primeiro, determinaremos o que é desempenho de front-end e depois passaremos a como medi-lo.  Portanto, como eu disse, não mediremos algumas operações / segundo, precisamos de dados reais que possam responder à pergunta do que exatamente acontece com o nosso projeto em cada etapa do seu trabalho.  Para fazer isso, precisamos do seguinte conjunto de métricas: <br><br><ul><li>  velocidade de download; </li><li>  hora da primeira renderização e interatividade (Time To Interactive); </li><li>  velocidade de reação às ações do usuário; </li><li>  FPS para rolagem e animações; </li><li>  inicialização de aplicativo; </li><li>  se você tiver um SPA, precisará medir o tempo gasto na alternância entre rotas; </li><li>  consumo de memória e tráfego; </li><li>  e ... o suficiente por enquanto. </li></ul><br>  Todas essas são métricas básicas, sem as quais é impossível entender o que exatamente está acontecendo no front-end.  E não apenas no front-end, mas na realidade, com o usuário final.  Mas, para começar a coletar essas métricas, primeiro você precisa aprender como medi-las, então vamos lembrar quais métodos existem para a análise de desempenho. <br><br>  A primeira coisa a começar é, obviamente, a API de desempenho.  Ou seja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">performance.timing</a> , através do qual você pode descobrir quanto tempo um usuário levou para abrir seu projeto.  Mas a API de desempenho cobre apenas parte da métrica, o restante precisará ser medido por nós mesmos e, para isso, temos as seguintes ferramentas: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  <sub>Prós</sub> </th><th>  <sub>Contras</sub> </th></tr><tr><td>  <sub>console.time ('label')</sub> </td><td>  <sub>Trabalha fora da caixa.</sub> <sub><br><br></sub>  <sub>É exibido no console.</sub> <sub><br><br></sub>  <sub>Aparece no DevTools -&gt; Desempenho -&gt; Tempo do usuário.</sub> </td><td> A saída é apenas no DevTools, não há como enviá-la ao servidor (ou seja, não há como obter um valor para análises adicionais). <br><br>  Requer <code>console.timeEnd</code> com o <code>label</code> original. <br><br>  Sem código de cores. <br><br>  Sem agrupamento (algo como <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Controle total sobre o começo e o fim. <br><br>  Você pode enviar para o servidor. <br><br></td><td>  Não há exibição no console. <br><br>  Não há exibição no DevTools -&gt; Desempenho -&gt; Tempo do usuário. <br><br>  Você precisa arrastar a variável "start". <br><br>  Sem agrupamento. </td></tr><tr><td>  performance.mark / measure </td><td>  Controle total sobre o começo e o fim. <br><br>  Você pode enviar para o servidor. <br><br>  Aparece no DevTools -&gt; Desempenho -&gt; Tempo do usuário. </td><td>  Não há exibição no console. <br><br>  Para medir algo, você precisa definir três rótulos exclusivos e chamar dois métodos, mas também precisa de <code>performance.clearMarks</code> e <code>performance.clearMeasures</code> , o que torna extremamente inconveniente. <br><br>  Sem agrupamento. </td></tr></tbody></table></div>  Naquele momento, percebi que você precisava ver uma ferramenta que combinasse as vantagens das opções acima e, se possível, não tivesse desvantagens.  Então havia o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> . <br><br><br><h2>  Perfkeeper </h2><ul><li>  Controle total sobre o começo e o fim. </li><li>  Você pode enviar para o servidor. </li><li>  É exibido no console. </li><li>  Suporta DevTools -&gt; Desempenho -&gt; Tempo do Usuário. </li><li>  Existe um agrupamento. </li><li>  Existe um código de cores (assim como unidades de medida, ou seja, você pode medir não apenas o tempo). </li><li>  Suporta extensões. </li></ul><br>  Agora não pintarei a API aqui, não escrevi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> para isso, e o artigo não é sobre isso, mas continuarei a coletar métricas. <br><br><br><h2>  Velocidade de download da página </h2>  Como eu já disse, você pode descobrir a velocidade do download em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">performance.timing</a> , que permitirá descobrir o ciclo completo desde o início do carregamento da página (hora de resolver o DNS, instalar o HTTP Handshake, processar a solicitação) e até que a página esteja totalmente carregada (DomReady e OnLoad): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  Como resultado, você deve obter o seguinte conjunto de métricas: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>Um exemplo da extensão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">navegação</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Mas isso não basta, obtivemos apenas os valores básicos e ainda não sabemos o que exatamente levou tanto tempo.  E para descobrir, você também precisa preencher as métricas HTML. <br><br>  Como eu já disse, mostrarei exemplos usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> , então a primeira coisa a fazer é embutida no próprio <code>&lt;hed/&gt;</code> PerfKeeper (2,5 Kb) e mais: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  Como resultado, você verá tanta beleza no console: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  Este é um método clássico de medição do avô, 100% funciona.  Mas o mundo não fica parado e, para medições mais precisas, agora temos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API de Tempo de Recurso</a> (e se os recursos estiverem em um domínio separado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tempo de Permissão de Origem</a> para ajudá-lo). <br><br>  E aqui vale a pena falar sobre erros clássicos durante o carregamento inicial da página, a saber: <br><br><ul><li>  falta de GZip e HTTP / 2 (sim, isso ainda é comum); </li><li>  uso irracional de fontes (algumas vezes, uma fonte é conectada apenas por um cabeçalho ou até mesmo um número de telefone no rodapé 0_o); </li><li>  Pacotes CSS / JS muito genéricos. </li></ul><br>  Maneiras de otimizar o carregamento da página: <br><br><ul><li>  use Brotli (ou mesmo SDCH) em vez de GZip, ative HTTP / 2; </li><li>  Colete apenas o CSS necessário (crítico) e não se esqueça do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CSSO</a> ; </li><li>  minimizar o tamanho do pacote JS separando o pacote CORE mínimo e carregar o restante sob demanda, ou seja,  assincronamente; </li><li>  carregue JS e CSS no modo sem bloqueio, criando dinamicamente <code>/&gt;  &lt;sript src="..."/&gt;</code> , idealmente carregue JS após o conteúdo principal; </li><li>  use SVG em vez de PNG e, se combinado com JS, ele se livrará de XML redundante (por exemplo, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">font-awesome</a> ); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">use carregamento lento</a> para imagens e iframes (além disso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte nativo</a> aparecerá em um futuro próximo). </li></ul><br><br><h2>  Primeira renderização e interatividade (TTI) </h2>  O próximo estágio após o carregamento é o momento em que o usuário viu o resultado e a interface entrou no modo interativo.  Para isso, precisamos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Performance Paint Timing</a> e do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerformanceObserver</a> . <br><br>  O primeiro é simples, chamamos <code>performance.getEntriesByType('paint')</code> e obtemos duas métricas: <br><br><ul><li>  primeira pintura - a primeira renderização; </li><li>  primeira pintura com conteúdo - e a primeira renderização completa. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>Um exemplo da extensão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tinta</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Mas com a próxima métrica, Time To Interactive, é um pouco mais interessante.  Não há uma maneira exata de determinar quando seu aplicativo se tornou interativo, ou seja,  acessível ao usuário, mas isso pode ser indiretamente entendido pela ausência de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">longas tarefas</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>Um exemplo da extensão de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Além dessas métricas básicas, também é necessária a métrica de prontidão do aplicativo, ou seja,  algures no seu código deve ser assim: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // ️application-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  Taxa de resposta às ações do usuário </h2>  Há um campo enorme para as métricas e elas são muito individuais, por isso vou falar sobre duas básicas que são adequadas para qualquer projeto, a saber: <br><br>  <b>primeiro evento</b> - a hora do primeiro evento, por exemplo, o primeiro clique (dividindo onde o usuário cutucou), essa métrica é especialmente relevante para todos os tipos de resultados de pesquisa, uma lista de produtos, feeds de notícias etc.  Com ele, você pode controlar como o tempo de reação e o usuário fluem de suas ações (alterações em: design / novos recursos / otimizações, etc.) <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>Um exemplo da extensão de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  <b>latência</b> - atraso no processamento de alguns eventos, por exemplo: <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> etc. <br><br>  Para medir o atraso, basta travar o manipulador de eventos na <code>window</code> com <code>capture = true</code> e use <code>requestAnimationFrame</code> calcular a diferença, este será o atraso: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// …. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>Um exemplo da extensão de desempenho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> trabalhando quando um número de Fibonacci é calculado em um clique.</i> <br><br><br><h2>  FPS ao rolar e animar </h2>  Essa é a métrica mais interessante, geralmente é medida por <code>requestAnimationFrame</code> e, se você precisar fazer medições constantes de FPS, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FPSMeter</a> clássico fará (embora seja muito otimista).  Mas não funciona se você precisar medir a suavidade da rolagem da página, porque  ele precisa de um aquecimento.  E então me deparei com uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maneira</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interessante</a> . <br><br>  De maneira engenhosa, na verdade, simplesmente criamos uma div transparente (1x1px), adicionamos <code>transition: left 300ms linear</code> e a executamos de um canto a outro, e enquanto anima, através de <code>requestAnimationFrame</code> verificamos sua esquerda real e, se o novo comprimento for diferente do anterior, aumente o número de quadros renderizados (caso contrário, temos um rebaixamento de FPS). <br><br>  E isso não é tudo, se você usa o FF, simplesmente existe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mozPaintCount</a> , responsável pelo número de quadros renderizados, ou seja,  lembramos de "DO" e, no <code>transitionend</code> da <code>transitionend</code> , calculamos a diferença. <br><br>  Total, sem nenhum aquecimento, sabemos com certeza se o navegador redesenha o quadro ou não. <br><br>  Eles logo prometem uma API normal: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>Um exemplo da extensão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fps</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  Otimização de rolagem: <br><br><ul><li>  o mais simples é não fazer nada na rolagem ou atrasar a execução por meio de <code>requestAnimationFrame</code> ou mesmo <code>requestIdleCallback</code> ; </li><li>  use muito cuidadosamente <code>pointer-events: none</code> , ativá-lo e desativá-lo pode ter o efeito oposto; portanto, é melhor realizar um experimento A / B usando <code>pointer-events</code> e sem; </li><li>  não se esqueça das listas virtualizadas, quase todos os mecanismos do View agora possuem esses componentes, mas, novamente, tenha cuidado, os elementos dessa lista devem ser o mais simples possível ou use "manequins" que serão substituídos por elementos reais depois que a rolagem for concluída.  Se você mesmo escrever uma lista virtualizada, não haverá HTML interno e não se esqueça da reciclagem do DOM (é quando você não cria elementos DOM para cada espirro, mas os reutiliza). </li></ul><br><br><h2>  Inicialização de aplicativo </h2>  Há apenas uma regra: detalhe para que você possa responder exatamente quanto tempo consumiu desde a inicialização do aplicativo até o lançamento final.  Como resultado, você deve obter pelo menos as seguintes métricas: <br><br><ul><li>  quanto tempo levou para resolver cada vício; </li><li>  tempo para receber e preparar dados para a aplicação; </li><li>  processar aplicativo com detalhamento por blocos. </li></ul><br>  I.e.  na saída, você deve obter essas métricas pelas quais pode rastrear com precisão exatamente em qual fase o seu rebaixamento está ocorrendo. <br><br><div class="spoiler">  <b class="spoiler_title">Exemplo de trabalho</b> <div class="spoiler_text">  <b>Console</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>Tempo do usuário</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  Se você tem SPA, precisa medir o tempo de roteamento </h2>  Primeiro, deve haver uma métrica geral para avaliar o desempenho (tempo de trânsito na rota) como um todo, mas também é necessário ter uma métrica para cada rota (por exemplo, temos uma "Lista de threads", "Lendo um thread", "Pesquisa" etc. d.), a própria métrica deve ser dividida em métricas: <br><br><ul><li>  Recebendo dados (com uma discriminação de quais) <ul><li>  Processamento </li><li>  Update </li></ul></li><li>  Render <ul><li>  Aplicação total </li><li>  Blocos (por exemplo, conosco, será: "Coluna esquerda" (também conhecida como "Lista de pastas"), "Barra de pesquisa inteligente", "Lista de letras" e similares) </li></ul></li></ul><br>  Sem tudo isso, é impossível entender onde os problemas começam, portanto, temos muitos módulos <code>endTime</code> para uso com intervalos de tempo (por exemplo, o mesmo módulo para o XHR possui <code>endTime</code> e <code>endTime</code> , que são registrados automaticamente). <br><br>  Mas essas métricas não são suficientes para avaliar adequadamente o que está acontecendo.  Eles são muito gerais porque  como estamos falando de SPA, você definitivamente tem algum tipo de cache de tempo de execução (para não voltar ao servidor novamente se já estiver lá), para que nossas métricas sejam divididas em roteamento com e sem cache.  Ainda assim, especificamente em nosso caso, dividimos a métrica pelo número de entidades nela.  Em outras palavras, você não pode adicionar a visualização "Encadeamento" com 1, 5, 10 ou mais de 100 letras em uma métrica. Portanto, se você tiver alguma lista exibida, precisará selecionar pontos de interrupção e separar ainda mais a métrica. <br><br><br><h2>  Consumo de memória e tráfego </h2>  <b>Vamos começar com a memória</b> .  E aqui estamos esperando uma grande decepção.  No momento, há apenas performance.memory não padronizada (somente Chrome), o que fornece números ridiculamente baixos.  Mas eles ainda precisam ser medidos e observar como o aplicativo "flui" ao longo do tempo: <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>Um exemplo da extensão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">memória</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a></i> <br><br>  <b>Tráfego</b>  Para contar o tráfego, você precisará do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Timing-Allow-Origin</a> (se os recursos estiverem localizados em um domínio separado) e da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resource Timing</a> , isso ajudará não apenas a calcular o tráfego, mas também a detalhar: <br><br><ul><li>  qual protocolo é usado (HTTP / 1, HTTP / 2 etc.); </li><li>  tipos de recursos carregados; </li><li>  quanto tempo levou para baixá-los; </li><li>  Além disso, você pode entender se o recurso está carregado na rede ou extraído do cache. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Um exemplo da extensão de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recurso</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ perf-tools / keeper</a> .</i> <br><br>  O que dá contagem de tráfego? <br><br><ul><li>  O mais importante é que ele permite que você veja a imagem real, e não como sempre com CSS + JS e além disso, como essa "imagem" muda com o tempo. </li><li>  Depois, você pode analisar o que exatamente está carregado, dividir recursos em grupos etc. </li><li>  Quão bem o cache funciona para você. </li><li>  Existem anomalias, por exemplo, após 15 minutos de operação, por exemplo, o código entrou em recursão e carrega algum recurso sem parar, o monitoramento do tráfego ajudará nisso. </li></ul><br>  Bem, um relatório de atualização do meu colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Igor Druzhinin</a> sobre este tópico: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Avaliando a qualidade do aplicativo - monitorando o consumo de tráfego</a> <br><br><br><h2>  Google Analytics </h2>  Montamos as métricas e depois o que?  E então eles precisam ser enviados para algum lugar.  E aqui você escolhe um pouco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grafite</a> ou, para começar, pode usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Analytics</a> ou similar para agregação de dados para ganho pessoal. <br><br>  E não se esqueça, não basta apenas obter um cronograma; para todas as métricas importantes, deve haver percentis que permitam entender, por exemplo, qual a porcentagem de público que o projeto está carregando para &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s +, etc. <br><br><br><h2>  Escrevendo um código de alto desempenho </h2>  No começo, eu queria escrever algo significativo aqui, eles dizem usar WebWorker, não se esqueça de <code>requestIdleCallback</code> ou algo exótico, por exemplo, através do Runtime Cache, através de guias do navegador usando SharedWorker ou ServiceWorker (que não é apenas sobre cache, se isso).  Mas tudo isso é muito abstrato e muitos tópicos são superados pela impossibilidade; basta escrever o seguinte: <br><br><ol><li>  Inicialmente, cubra seu código com métricas que medem seu desempenho. </li><li>  Não acredite nos benchmarks com o jsperf.  A grande maioria deles é mal escrita e simplesmente retirada de contexto.  A melhor referência é a métrica real do projeto, segundo a qual você verá o efeito de suas ações. </li><li>  Lembre-se da percepção de produtividade, ou melhor, da Lei de Weber-Fechner.  Nomeadamente, se você iniciou a otimização, não execute as alterações até que se tornem melhores pelo menos em 20%, caso contrário os usuários simplesmente não perceberão.  A lei também funciona na direção oposta. </li><li>  Medo regulares, especialmente aqueles gerados.  Eles não apenas podem travar o navegador, mas também obter o XSS, e é por isso que no nosso Mail é proibido analisar o HTML usando-os, apenas através de um desvio do DOM. </li><li>  Você não precisa usar matrizes para inserir um valor em um ou outro grupo; para isso, existe um <code>object</code> ou um <code>Set</code> (por exemplo, <code>successSteps.includes(currentStep)</code> necessário <code>successSteps.hasOwnProperty(currentStep)</code> ), O (1) é tudo. </li><li>  A expressão "Otimização prematura é a raiz de todos os males" não é sobre escrever o que você quiser.  Se você sabe qual a melhor forma, escreva da melhor maneira. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Escreverei alguns parágrafos sobre o código e sua otimização</b> <div class="spoiler_text">  <b>DOM</b>  Muitas vezes ouço “O Problema no DOM” - isso, é claro, é verdade, mas dado que quase todo mundo agora tem uma abstração sobre ele.  É ela quem se torna o gargalo, ou melhor, o seu código, responsável pela formação da visão e da lógica de negócios. <br><br>  Mas se falarmos sobre o DOM, por exemplo, em vez de excluir um fragmento do DOM, é melhor ocultá-lo ou anexá-lo.  Se você ainda precisar excluir, faça essa operação em <code>requestIdleCallback</code> (se possível) ou divida o processo de destruição em duas fases: síncrona e assíncrona. <br><br>  Farei uma reserva imediatamente, use essa abordagem com sabedoria, caso contrário, você pode dar um tapa no joelho. <br><br>  Também usamos outra técnica interessante em listas, por exemplo, a "Lista de Tópicos".  A essência da técnica é que, em vez de uma "Lista" global e atualização de seus dados, geramos uma "Lista de threads" para cada "Pasta".  Como resultado, quando o usuário navega entre as "Pastas", uma lista é removida do DOM (não excluída) e a outra é atualizada parcial ou totalmente.  E não todos, como é o caso da "Lista Única". <br><br>  Tudo isso fornece uma resposta instantânea às ações do usuário. <br><br>  <b>Matemática</b>  Removemos facilmente toda a matemática no Worker ou no WebAssembly, pois isso funciona há muito tempo. <br><br>  <b>Transpilers</b> .  Ah, muitos nem pensam que o código que escrevem passa pelo transpilador.  Sim, eles sabem sobre ele, mas é tudo.  Mas com o que ele se transforma eles não se importam mais.  De fato, no DevTools, eles veem o resultado do mapa de origem. <br><br>  Portanto, estude as ferramentas que você usa, por exemplo, a mesma babel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">playground</a> tem a oportunidade de ver em que ele gera código, dependendo das predefinições selecionadas, basta olhar para o mesmo campo, <code>await</code> ou <code>for of</code> . <br><br>  <b>As sutilezas da língua</b> .  Menos pessoas ainda sabem do monomorfismo do código, ou brega por que o bind é lento e ... você finalmente usa o <code>handleEvent</code> ! <br><br>  <b>Dados e pré-gravação</b> .  Menos pedidos, mais armazenamento em cache.  Além disso, muitas vezes usamos a técnica de "previsão", é quando, em segundo plano, carregamos dados.  Por exemplo, depois de renderizar a "Lista de threads", começamos a carregar segmentos não lidos na "Pasta" atual, para que, quando você clicar neles, o usuário mude imediatamente para "Leitura" em vez de outro "carregador".  Usamos uma técnica semelhante, não apenas para Data, mas também para JS.  Por exemplo, “Escrever uma carta” é um pacote enorme (por causa do editor), e nem todas as pessoas escrevem cartas de uma só vez; portanto, carregamos em segundo plano, depois que o aplicativo é inicializado. <br><br>  <b>Louders</b>  Não sei por que, mas não vi artigos que ensinavam como não fazer um carregador, mas fiz uma apresentação do React "futuro", no qual muito tempo foi dedicado a esse problema no Suspense.  Mas, afinal, o aplicativo ideal é sem carregadores, tentamos há muito tempo no Mail mostrá-lo apenas em situações de emergência. <br><br>  Em geral, temos essa política, não há dados, não há visão, não há nada para desenhar uma semi-interface, primeiro carregamos os dados e só depois "desenhamos".  É por isso que usamos a “previsão” de onde o usuário está indo e carregamos esses dados para que o usuário não veja o carregador.  Além disso, nossa camada de dados, que é persistente, ajuda muito nessa tarefa.  se você solicitou "Encadeamento" em algum lugar de um local, da próxima vez que solicitar de outro ou do mesmo local, não haverá solicitação, obteremos dados do Runtime Cache (mais precisamente, um link para os dados).  E assim, em tudo, coleções de threads também são apenas links para dados. <br><br>  Mas se você ainda decidir criar um carregador, não esqueça as regras básicas que tornarão seu carregador menos irritante: <ul><li>  não há necessidade de mostrar o carregador imediatamente, no momento do envio da solicitação, deve haver um atraso de pelo menos 300-500 ms antes do show; </li><li>  Depois de receber os dados, você não precisa remover muito o carregador, aqui novamente deve haver um atraso. </li></ul><br>  Essas regras simples são necessárias para que o carregador apareça apenas em solicitações pesadas e não pisque após a conclusão.  Mas o mais importante, o melhor carregador é um carregador que não apareceu. </div></div><br><br>  Obrigado pela atenção, isso é tudo, meça, analise e use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PerfKeeper</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo ao vivo</a> ), além do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu github</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">twitter</a> , em caso de dúvidas! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454920/">https://habr.com/ru/post/pt454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454906/index.html">Classificação de plataformas educacionais adicionais em TI: de acordo com os resultados do estudo My Circle</a></li>
<li><a href="../pt454912/index.html">Dwarf Fortress Tarn Adams fala sobre desenvolvimento de jogos</a></li>
<li><a href="../pt454914/index.html">Nós usamos o Yii2. Estamos escrevendo outro CMS ou uma tentativa de acelerar significativamente o desenvolvimento com o mínimo de sobrecarga</a></li>
<li><a href="../pt454916/index.html">Arquitetura de rede neural para implementar o algoritmo RL com a capacidade de definir ações em execução simultaneamente</a></li>
<li><a href="../pt454918/index.html">Como combinar as costas de dois varejistas no SAP em 12 horas</a></li>
<li><a href="../pt454924/index.html">Configurações de autenticação no Veeam Backup para Microsoft Office 365 v3</a></li>
<li><a href="../pt454928/index.html">Maneira de ignorar a tela de bloqueio do Windows em sessões RDP</a></li>
<li><a href="../pt454930/index.html">Coleta de lixo na V8: como o novo GC Orinoco funciona</a></li>
<li><a href="../pt454932/index.html">Investimentos e software: 5 terminais de negociação para negociação na bolsa</a></li>
<li><a href="../pt454936/index.html">Vivaldi: o bloqueio de anúncios deve ser a escolha do usuário</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>