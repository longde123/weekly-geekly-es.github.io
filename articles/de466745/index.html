<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéè ‚§µÔ∏è üë©‚Äçüëß‚Äçüë¶ Der erste Arbeitsplatz oder wie man mit der Entwicklung der API auf Node.js beginnt üíá üêò ‚ôãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 In diesem Artikel m√∂chte ich meine Emotionen und erworbenen F√§higkeiten bei der Entwicklung der ersten REST-API auf Node.js mit TypeScrip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der erste Arbeitsplatz oder wie man mit der Entwicklung der API auf Node.js beginnt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466745/"><h3>  Einf√ºhrung </h3><br>  In diesem Artikel m√∂chte ich meine Emotionen und erworbenen F√§higkeiten bei der Entwicklung der ersten REST-API auf Node.js mit TypeScript von Grund auf teilen.  Die Geschichte ist ziemlich banal: <i>‚ÄûIch habe mein Studium abgeschlossen und ein Diplom erhalten.</i>  <i>Wohin zur Arbeit gehen? "</i>  Wie Sie vielleicht vermutet haben, ging das Problem nicht an mir vorbei, obwohl ich nicht zu viel nachdenken musste.  Der Entwickler (Absolvent derselben Fachrichtung) forderte ein Praktikum an.  Ich glaube, dass dies eine ziemlich verbreitete Praxis ist und es viele √§hnliche Geschichten gibt.  Ohne nachzudenken, beschloss ich, mich zu versuchen und ging ... <br><br><img src="https://habrastorage.org/webt/m5/rl/yq/m5rlyqzlhotg2fxugcj6jr1vozu.png" alt="Bild"><br><br><h3>  Erster Tag.  Wir stellen vor: Node.js. </h3><br>  Ich bin zur Backend-Entwicklung gekommen.  Dieses IT-Unternehmen verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-</a> Plattform, mit der ich √ºberhaupt nicht vertraut war.  Ich lief ein wenig vorw√§rts und verga√ü dem Leser zu sagen, dass ich nie etwas in JavaScript entwickelt hatte (au√üer ein paar Skripten mit Kopiercode).  Im Allgemeinen verstand ich den Arbeitsalgorithmus und die Architektur von Webanwendungen, da ich CRUD in Java, Python und Clojure entwickelte, aber dies war nicht genug.  Daher hat dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Screencast</a> am ersten Tag, an dem ich mich ganz dem Studium von Node.js widmete, wirklich geholfen. <br><br>  W√§hrend ich das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Express-</a> Webframework, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm-</a> Paketmanager sowie Dateien wie package.json und tsconfig.json studierte, ging mein Kopf einfach um die Informationsmenge herum.  Eine weitere Lektion ist, dass es nahezu unm√∂glich ist, das gesamte Material gleichzeitig zu beherrschen.  Am Ende des Tages konnte ich die Umgebung immer noch konfigurieren und den Express-Webserver ausf√ºhren!  Aber es war zu fr√ºh, um sich zu freuen, denn er ging mit einem vollen Gef√ºhl des Missverst√§ndnisses nach Hause.  Das Gef√ºhl, in der riesigen Welt von JS zu ertrinken, lie√ü mich keine Minute stehen, so dass ein Neustart erforderlich war. <br><br><a name="habracut"></a><h3>  Zweiter Tag.  Einf√ºhrung in TypeScript </h3><br>  Der gleiche Neustart folgte noch am selben Tag.  An diesem Punkt habe ich mein Problem vollst√§ndig erkannt, wir werden etwas weiter darauf eingehen.  In dem Wissen, dass es nicht notwendig war, in reinem JavaScipt zu schreiben, floss das Training von Node.js reibungslos in die TypeScript-Sprache, n√§mlich deren Funktionen und Syntax.  Hier sah ich die lang erwarteten <b>Typen</b> , ohne die die Programmierung buchst√§blich vor 2 Tagen erfolgte, <b>nicht</b> in funktionalen Programmiersprachen.  Dies war mein gr√∂√ütes Missverst√§ndnis, das mich daran hinderte, den in JavaScript geschriebenen Code am ersten Tag zu verstehen und zu lernen. <br><br>  Zuvor schrieb er gr√∂√ütenteils in objektorientierten Programmiersprachen wie Java, C ++, C #.  Als ich die M√∂glichkeiten von TypeScript erkannte, f√ºhlte ich mich wohl.  Diese Programmiersprache hauchte mir buchst√§blich das Leben dieser komplexen Umgebung ein, wie es mir damals schien.  Gegen Ende des Tages habe ich die Umgebung vollst√§ndig eingerichtet, den Server (bereits in TypeScript) gestartet und die erforderlichen Bibliotheken verbunden, auf die ich weiter unten eingehen werde.  Fazit: Bereit zur Entwicklung der API.  Wir gehen direkt zur Entwicklung √ºber ... <br><br><h3>  API-Entwicklung </h3><br>  Eine Erkl√§rung des Arbeitsprinzips und andere Erkl√§rungen der REST-API werden wir hinterlassen, da das Forum viele Artikel mit Beispielen und Entwicklungen in verschiedenen Programmiersprachen enth√§lt. <br><img src="https://habrastorage.org/webt/jv/0k/fz/jv0kfzdektfwbeiyw6ib5cp5pxi.png" alt="Bild"><br><br>  <b>Die Aufgabe war wie folgt:</b> <br><br>  Erstellen Sie einen Service mit einer REST-API.  Autorisierung durch Inhaber-Token (/ info, / latency, / logout).  Konfiguriertes CORS f√ºr den Zugriff von jeder Domain aus.  DB - MongoDB.  Erstellen Sie bei jedem Aufruf ein Token. <br><br>  <b>API-Beschreibung:</b> <br><br><ol><li>  / signin [POST] - Token-Tr√§ger nach ID und Passwort anfordern // Daten in JSON empfangen </li><li>  / signup [POST] - Registrierung eines neuen Benutzers: // empf√§ngt Daten in json </li><li>  / info [GET] - Gibt die Benutzer-ID und den ID-Typ zur√ºck und erfordert das vom Inhaber bei der Authentifizierung ausgestellte Token </li><li>  / latency [GET] - Gibt eine Verz√∂gerung (Ping) zur√ºck und erfordert das vom Inhaber bei der Authentifizierung ausgestellte Token </li><li>  / logout [GET] - mit dem Parameter all: true - l√∂scht alle Benutzer-Bearer-Token oder false - l√∂scht nur das aktuelle Bearer-Token </li></ol><br>  Ich stelle sofort fest, dass die Aufgabe f√ºr einen Webanwendungsentwickler unglaublich einfach aussieht.  Aber die Aufgabe muss in einer Programmiersprache implementiert werden, von der vor 3 Tagen √ºberhaupt nichts wusste!  Selbst f√ºr mich sieht es auf dem Papier v√∂llig transparent aus und in Python hat die Implementierung etwas Zeit in Anspruch genommen, aber ich hatte keine solche Option.  Der Entwicklungsstapel deutete auf Probleme hin. <br><br><h4>  Mittel zur Umsetzung </h4><br>  Daher habe ich erw√§hnt, dass ich am zweiten Tag, an dem ich bereits mehrere Bibliotheken (Frameworks) studiert habe, damit beginnen werde.  F√ºr das Routing habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Routing-Controller ausgew√§hlt</a> , die sich an vielen √Ñhnlichkeiten mit Dekorateuren aus dem Spring Framework (Java) orientieren.  Als ORM habe ich mich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typeorm</a> entschieden, obwohl ich mit MongoDB im experimentellen Modus arbeite, ist es f√ºr eine solche Aufgabe v√∂llig ausreichend.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uuid verwendet</a> , um Token zu generieren. Variablen werden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.npmjs.com/package/dotenv">dotenv</a> geladen. <br><br><h4>  Start des Webservers </h4><br>  Normalerweise wird Express in seiner reinen Form verwendet, aber ich habe das Routing Controller-Framework erw√§hnt, mit dem wir einen Express-Server wie folgt erstellen k√∂nnen: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Express const app = createExpressServer({ // routePrefix: process.env.SERVER_PREFIX, //  defaults: { nullResultCode: Number(process.env.ERROR_NULL_RESULT_CODE), undefinedResultCode: Number(process.env.ERROR_NULL_UNDEFINED_RESULT_CODE), paramOptions: { required: true } }, //   authorizationChecker: authorizationChecker, // controllers: [UserController] }); //  app.listen(process.env.SERVER_PORT, () =&gt; { console.log(process.env.SERVER_MASSAGE); });</span></span></code> </pre> <br><br>  Wie Sie sehen k√∂nnen, gibt es nichts Kompliziertes.  Tats√§chlich verf√ºgt das Framework √ºber viel mehr Funktionen, die jedoch nicht ben√∂tigt wurden. <br><ul><li>  routePrefix ist nur ein Pr√§fix in Ihrer URL nach der Serveradresse, zum Beispiel: <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 3000 / Pr√§fix</i> </li><li>  Standardeinstellungen - nichts Interessantes, initialisieren Sie einfach die Fehlercodes </li><li>  authorisationChecker - eine gro√üartige Gelegenheit f√ºr das Framework, die Benutzerautorisierung zu √ºberpr√ºfen, dann werden wir genauer darauf eingehen </li><li>  Controller ist eines der Hauptfelder, in denen wir die in unserer Anwendung verwendeten Controller angeben </li></ul><br><br><h4>  DB-Verbindung </h4><br>  Zuvor hatten wir den Webserver bereits gestartet, daher werden wir weiterhin eine Verbindung zur MongoDB-Datenbank herstellen, nachdem wir ihn zuvor auf dem lokalen Server bereitgestellt haben.  Installation und Konfiguration sind in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> ausf√ºhrlich beschrieben.  Wir werden die Verbindung direkt mit typeorm betrachten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  createConnection({ type: 'mongodb', host: process.env.DB_HOST, database: process.env.DB_NAME_DATABASE, entities: [ User ], synchronize: true, logging: false }).catch(error =&gt; console.log(error));</span></span></code> </pre> <br><br>  Alles ist ganz einfach, Sie m√ºssen mehrere Parameter angeben: <br><br><ul><li>  Typ - DB </li><li>  Host - IP-Adresse, an der Sie die Datenbank bereitgestellt haben </li><li>  Datenbank - Der Name der Datenbank, die zuvor in Mongodb erstellt wurde </li><li>  synchronisieren - automatische Synchronisation mit der Datenbank <i>(Hinweis: Es war zu diesem Zeitpunkt schwierig, die Migration zu meistern)</i> </li><li>  Entit√§ten - hier geben wir die Entit√§ten an, mit denen die Synchronisation durchgef√ºhrt wird </li></ul><br><br>  Jetzt verbinden wir den Start des Servers und die Verbindung zur Datenbank.  Ich stelle fest, dass sich der Import von Ressourcen von dem in Node.js verwendeten klassischen unterscheidet.  Als Ergebnis erhalten wir die folgende ausf√ºhrbare Datei, in meinem Fall main.ts: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'reflect-metadata'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dotenv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dotenv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createExpressServer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createConnection } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { authorizationChecker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./auth/authorizationChecker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { UserController } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./controllers/UserController'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./models/User'</span></span>; dotenv.config(); <span class="hljs-comment"><span class="hljs-comment">//  createConnection({ type: 'mongodb', host: process.env.DB_HOST, database: process.env.DB_NAME_DATABASE, entities: [ User ], synchronize: true, logging: false }).catch(error =&gt; console.log(error)); //  Express const app = createExpressServer({ // routePrefix: process.env.SERVER_PREFIX, //  defaults: { nullResultCode: Number(process.env.ERROR_NULL_RESULT_CODE), undefinedResultCode: Number(process.env.ERROR_NULL_UNDEFINED_RESULT_CODE), paramOptions: { required: true } }, //   authorizationChecker: authorizationChecker, // controllers: [UserController] }); //  app.listen(process.env.SERVER_PORT, () =&gt; { console.log(process.env.SERVER_MASSAGE); });</span></span></code> </pre> <br><h4>  Entit√§ten </h4><br>  Ich m√∂chte Sie daran erinnern, dass die Aufgabe darin besteht, Benutzer zu authentifizieren bzw. zu autorisieren. Wir ben√∂tigen eine Entit√§t: Benutzer.  Das ist aber noch nicht alles, denn jeder Benutzer hat einen Token und keinen!  Daher muss eine Token-Entit√§t erstellt werden. <br><br>  <b>Benutzer</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ObjectID } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bson'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IsEmail, MinLength } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'class-validator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Column, Entity, ObjectIdColumn } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Token } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Token'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  @Entity() export class User { //  @ObjectIdColumn() id: ObjectID; //Email    @Column() @IsEmail() email: string; //  @Column({ length: 100 }) @MinLength(2) password: string; //  @Column() token: Token; }</span></span></code> </pre> <br>  In der Benutzertabelle erstellen wir ein Feld - ein Array der Token f√ºr den Benutzer.  Wir <i>aktivieren</i> auch <i>den Calss-Validator</i> , da sich der Benutzer per E-Mail <i>anmelden</i> muss. <br><br>  <b>Token</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Column, Entity } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   @Entity() export class Token { @Column() accessToken: string; @Column() refreshToken: string; @Column() timeKill: number; }</span></span></code> </pre> <br>  Die Basis ist wie folgt: <br><br><img src="https://habrastorage.org/webt/ev/xl/pu/evxlpuuo4bajkn8c0ly1klljere.png" alt="Bild"><br><br><h4>  Benutzerautorisierung </h4><br>  Zur Autorisierung verwenden wir <i>authorisationChecker</i> (einer der Parameter beim Erstellen des Servers, siehe oben). Der Einfachheit halber legen wir ihn in einer separaten Datei ab: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Action, UnauthorizedError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { getMongoRepository } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'typeorm'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authorizationChecker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action: Action</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> token: string; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.request.headers.authorization) { <span class="hljs-comment"><span class="hljs-comment">//   token = action.request.headers.authorization.split(" ", 2); const repository = getMongoRepository(User); const allUsers = await repository.find(); for (let i = 0; i &lt; allUsers.length; i++) { if (allUsers[i].token.accessToken.toString() === token[1]) { return true; } } } else { throw new UnauthorizedError('This user has not token.'); } return false; }</span></span></code> </pre> <br>  Nach der Authentifizierung hat jeder Benutzer sein eigenes Token, sodass wir das erforderliche Token aus den Headern der Antwort <i>abrufen k√∂nnen</i> . Es sieht <i>ungef√§hr</i> so aus: <i>Tr√§ger 046a5f60-c55e-11e9-af71-c75526de439e</i> .  Jetzt k√∂nnen wir √ºberpr√ºfen, ob dieses Token vorhanden ist. Danach gibt die Funktion Autorisierungsinformationen zur√ºck: true - der Benutzer ist autorisiert, false - der Benutzer ist nicht autorisiert.  In der Anwendung k√∂nnen wir einen sehr praktischen Dekorator in der Steuerung verwenden: @Authorized ().  Zu diesem Zeitpunkt wird die Funktion authorisationChecker aufgerufen, die eine Antwort zur√ºckgibt. <br><br><h4>  Logik </h4><br>  Zun√§chst m√∂chte ich die Gesch√§ftslogik beschreiben, da der Controller eine Zeile von Methodenaufrufen unterhalb der dargestellten Klasse ist.  Au√üerdem akzeptieren wir im Controller alle Daten, in unserem Fall JSON und Query.  Wir werden die Methoden f√ºr einzelne Aufgaben betrachten und am Ende die endg√ºltige Datei mit dem Namen UserService.ts erstellen.  Ich stelle fest, dass es zu dieser Zeit einfach nicht genug Wissen gab, um Abh√§ngigkeiten zu beseitigen.  Wenn Sie den Begriff Abh√§ngigkeitsinjektion nicht kennengelernt haben, empfehle ich dringend, dar√ºber zu lesen.  Im Moment verwende ich das DI-Framework, dh ich verwende Container, n√§mlich die Injektion durch Konstruktoren.  Hier, denke ich, ist ein guter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://">Artikel</a> zur √úberpr√ºfung.  Wir kehren zur Aufgabe zur√ºck. <br><br><ul><li>  <b>/ signin [POST]</b> - Authentifizierung des registrierten Benutzers.  Alles ist sehr einfach und transparent.  Wir m√ºssen nur diesen Benutzer in der Datenbank finden und ein neues Token ausstellen.  Zum Lesen und Schreiben wird MongoRepository verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userSignin(user: User): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;string&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repo = getMongoRepository(User); //       let userEmail = await repo.findOne({ email: user.email, password: user.password }); if (userEmail) { //  userEmail = await this.setToken(userEmail); //    repo.save(userEmail); return userEmail.token.accessToken; } return process.env.USER_SERVICE_RESPONSE; }</span></span></code> </pre> </li><li>  <b>/ signup [POST]</b> - Registrieren Sie einen neuen Benutzer.  Eine sehr √§hnliche Methode, da wir zun√§chst auch einen Benutzer suchen, damit wir keine Benutzer mit einer E-Mail registriert haben.  Als n√§chstes schreiben wir den neuen Benutzer in die Datenbank, nachdem wir das Token ausgestellt haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userSignup(newUser: User): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;string&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repo = getMongoRepository(User); //   email (   2    email) const userRepeat = await repo.findOne({ email: newUser.email }); if (!userRepeat) { //  newUser = await this.setToken(newUser); //   const addUser = getMongoManager(); await addUser.save(newUser); return newUser.token.accessToken; } else { return process.env.USER_SERVICE_RESPONSE; } }</span></span></code> </pre> </li><li>  <b>/ info [GET]</b> - Gibt die Benutzer-ID und den ID-Typ zur√ºck und erfordert das vom Inhaber bei der Authentifizierung ausgestellte Token.  Das Bild ist auch transparent: Zuerst erhalten wir das aktuelle Token des Benutzers aus den Anforderungsheadern, suchen es dann in der Datenbank und bestimmen, wem es geh√∂rt, und geben den gefundenen Benutzer zur√ºck. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getUserInfo(req: express.Request): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;User&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repository = getMongoRepository(User); //    const user = await this.findUser(req, repository); return user; } private async findUser(req: express.Request, repository: MongoRepository&lt;User&gt;): Promise&lt;User&gt; { if (req.get(process.env.HEADER_AUTH)) { //  const token = req.get(process.env.HEADER_AUTH).split(' ', 2); //    const usersAll = await repository.find(); //  for (let i = 0; i &lt; usersAll.length; i++) { if (usersAll[i].token.accessToken.toString() === token[1]) { return usersAll[i]; } } } }</span></span></code> </pre> <br></li><li>  <b>/ latency [GET]</b> - Gibt eine Verz√∂gerung (Ping) zur√ºck und erfordert das vom Inhaber bei der Authentifizierung ausgestellte Token.  Ein v√∂llig uninteressanter Absatz des Artikels.  Hier habe ich nur eine vorgefertigte Bibliothek zum √úberpr√ºfen der TCP-Ping-Verz√∂gerung verwendet. <br><br><pre> <code class="javascript hljs">getLatency(): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;IPingResult&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">progress: number, total: number</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(progress, <span class="hljs-string"><span class="hljs-string">'/'</span></span>, total); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = ping({ <span class="hljs-attr"><span class="hljs-attr">address</span></span>: process.env.PING_ADRESS, <span class="hljs-attr"><span class="hljs-attr">attempts</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_ATTEMPTS), <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_PORT), <span class="hljs-attr"><span class="hljs-attr">timeout</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(process.env.PING_TIMEOUT) }, update).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ping result:'</span></span>, result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latency; }</code> </pre></li><li>  <b>/ logout [GET]</b> - mit dem Parameter all: true - l√∂scht alle Benutzer-Bearer-Token oder false - l√∂scht nur das aktuelle Bearer-Token.  Wir m√ºssen nur den Benutzer finden, den Abfrageparameter √ºberpr√ºfen und die Token entfernen.  Ich denke, alles sollte klar sein. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> userLogout(all: boolean, <span class="hljs-attr"><span class="hljs-attr">req</span></span>: express.Request): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Mongo repository const repository = getMongoRepository(User); //    const user = await this.findUser(req, repository); if (all) { // true    user.token.accessToken = process.env.GET_LOGOUT_TOKEN; user.token.refreshToken = process.env.GET_LOGOUT_TOKEN; //  repository.save(user); } else { // false    user.token.accessToken = process.env.GET_LOGOUT_TOKEN; //  repository.save(user); } }</span></span></code> </pre> </li></ul><br><br><h4>  Controller </h4><br>  Viele m√ºssen nicht erkl√§ren, was ben√∂tigt wird und wie der Controller im MVC-Muster verwendet wird, aber ich werde trotzdem zwei W√∂rter sagen.  Kurz gesagt, der Controller ist die Verbindung zwischen dem Benutzer und der Anwendung, die Daten zwischen ihnen umleitet.  Die Logik wurde oben vollst√§ndig beschrieben, deren Methoden gem√§√ü den Routen aufgerufen werden und aus einem URI und einem IP-Server bestehen <i>(Beispiel: localhost: 3000 / signin)</i> .  Ich habe bereits √ºber Dekorateure im Controller gesprochen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Get</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">POST</a> , @Authorized und das wichtigste davon ist @JsonController.  Ein weiteres sehr wichtiges Merkmal dieses Frameworks ist, dass wir, wenn wir JSON senden und empfangen m√∂chten, diesen Dekorator anstelle von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Controller verwenden</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Authorized, Body, Get, Header, JsonController, NotFoundError, Post, QueryParam, Req, UnauthorizedError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'routing-controllers'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { IPingResult } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@network-utils/tcp-ping'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/User'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { UserService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../services/UserService'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    JSON @JsonController() export class UserController { userService: UserService //  constructor() { this.userService = new UserService(); } //  @Post('/signin') async login(@Body() user: User): Promise&lt;string&gt; { const responseSignin = await this.userService.userSignin(user); if (responseSignin !== process.env.USER_SERVICE_RESPONSE) { return responseSignin; } else { throw new NotFoundError(process.env.POST_SIGNIN_MASSAGE); } } //  @Post('/signup') async registrateUser(@Body() newUser: User): Promise&lt;string&gt; { const responseSignup = await this.userService.userSignup(newUser); if (responseSignup !== process.env.USER_SERVICE_RESPONSE) { return responseSignup; } else { throw new UnauthorizedError(process.env.POST_SIGNUP_MASSAGE); } } //   @Get('/info') @Authorized() async getId(@Req() req: express.Request): Promise&lt;User&gt; { return this.userService.getUserInfo(req); } //   @Authorized() @Get('/latency') getPing(): Promise&lt;IPingResult&gt; { return this.userService.getLatency(); } @Get('/logout') async deleteToken(@QueryParam("all") all: boolean, @Req() req: express.Request): Promise&lt;void&gt; { this.userService.userLogout(all, req); } }</span></span></code> </pre> <br><h4>  Fazit </h4><br>  In diesem Artikel wollte ich nicht mehr die technische Komponente des richtigen Codes oder √§hnliches widerspiegeln, sondern einfach die Tatsache teilen, dass eine Person eine Webanwendung mithilfe einer Datenbank erstellen kann und in <b>f√ºnf</b> Tagen mindestens eine Logik von einer absoluten Null enth√§lt.  Denken Sie nur dar√ºber nach, kein Instrument war Ihnen vertraut, erinnern Sie sich an sich selbst oder setzen Sie es einfach an meine Stelle.  In keinem Fall ist dies der Fall, der sagt: "Ich bin der Beste, das kann man nie tun."  Im Gegenteil, dies ist ein Schrei aus der Seele einer Person, die derzeit v√∂llig begeistert von der Welt von Node.js ist und dies mit Ihnen teilt.  Und die Tatsache, dass nichts unm√∂glich ist, m√ºssen Sie nur nehmen und tun! <br><br>  Nat√ºrlich kann nicht geleugnet werden, dass der Autor nichts wusste und sich zum ersten Mal hinsetzte, um Code zu schreiben.  Nein, Kenntnisse √ºber OOP, die Prinzipien der REST-API, ORM und der Datenbank waren in ausreichenden Mengen vorhanden.  Und das kann nur sagen, dass das Mittel zum Erreichen des Ergebnisses absolut keine Rolle spielt und im Stil sagt: "Ich werde nicht zu diesem Job gehen, es gibt eine Programmiersprache, die ich nicht gelernt habe", f√ºr mich ist es jetzt nur die Manifestation einer Person, nicht von Schw√§che, sondern vielmehr Schutz vor einer unbekannten √§u√üeren Umgebung.  Aber was gibt es zu verbergen, die Angst war bei mir vorhanden. <br><br>  Zusammenfassend.  Ich m√∂chte Studenten und Menschen, die ihre Karriere in der IT noch nicht begonnen haben, raten, keine Angst vor Entwicklungstools und unbekannten Technologien zu haben.  √Ñltere Genossen werden Ihnen sicherlich helfen (wenn Sie genauso viel Gl√ºck haben wie ich), sie werden es Ihnen ausf√ºhrlich erkl√§ren und Fragen beantworten, da jeder von ihnen in dieser Position war.  Aber vergessen Sie nicht, dass Ihr Wunsch der wichtigste Aspekt ist! <br><br>  Link zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466745/">https://habr.com/ru/post/de466745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466733/index.html">Willkommen zu DINS Java ABEND am 18. September</a></li>
<li><a href="../de466735/index.html">Eine einfache M√∂glichkeit, einen Sprachalarm im Home Automation-System (‚ÄûSmart Home‚Äú) zu erstellen.</a></li>
<li><a href="../de466737/index.html">Warum das soziale Netzwerk von Google+ fehlgeschlagen ist</a></li>
<li><a href="../de466739/index.html">Das Beste ist der Feind des Guten</a></li>
<li><a href="../de466741/index.html">Das Beste ist der Feind des Guten</a></li>
<li><a href="../de466747/index.html">Mitap iOS-Entwickler bei Redmadrobot</a></li>
<li><a href="../de466753/index.html">Netzwerkadministration schnell und effizient - Netzwerk-MACMonitor</a></li>
<li><a href="../de466755/index.html">Der Computer wird Sie lecker machen</a></li>
<li><a href="../de466757/index.html">Der erste Flutter Mitap in St. Petersburg - 26. September</a></li>
<li><a href="../de466759/index.html">√úber Partnerprogramme von Hosting-Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>