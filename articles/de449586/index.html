<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèæ üòâ üòä Das schwierige Prinzip der alleinigen Verantwortung ‚óºÔ∏è üë®üèº üë®üèΩ‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 
 In den letzten Jahren habe ich an zahlreichen Interviews teilgenommen. Bei jedem von ihnen habe ich die Antragsteller nach dem Grundsatz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das schwierige Prinzip der alleinigen Verantwortung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449586/"><h1>  Hintergrund </h1><br>  In den letzten Jahren habe ich an zahlreichen Interviews teilgenommen.  Bei jedem von ihnen habe ich die Antragsteller nach dem Grundsatz der alleinigen Verantwortung (im Folgenden: SRP) gefragt.  Und die meisten Menschen wissen nichts √ºber das Prinzip.  Und selbst von denen, die die Definition lesen konnten, konnte fast niemand sagen, wie sie dieses Prinzip in ihrer Arbeit anwenden.  Sie konnten nicht sagen, wie sich SRP auf den von ihnen geschriebenen Code oder die Code√ºberpr√ºfung von Kollegen auswirkt.  Einige von ihnen hatten auch das Missverst√§ndnis, dass SRP wie das gesamte SOLID nur f√ºr die objektorientierte Programmierung relevant ist.  Au√üerdem konnten Menschen h√§ufig keine offensichtlichen F√§lle von Verst√∂√üen gegen dieses Prinzip identifizieren, einfach weil der Code in dem vom bekannten Framework empfohlenen Stil geschrieben wurde. <br>  Redux ist ein Paradebeispiel f√ºr ein Framework, dessen Richtlinie gegen SRP verst√∂√üt. <br><a name="habracut"></a><br><h1>  SRP ist wichtig </h1><br>  Ich m√∂chte mit dem Wert dieses Prinzips beginnen, mit den Vorteilen, die es bringt.  Au√üerdem m√∂chte ich darauf hinweisen, dass das Prinzip nicht nur f√ºr OOP gilt, sondern auch f√ºr die prozedurale Programmierung, funktional und sogar deklarativ.  HTML als Vertreter des letzteren kann und sollte auch zerlegt werden, insbesondere jetzt, wenn es von UI-Frameworks wie React oder Angular gesteuert wird.  Dar√ºber hinaus gilt das Prinzip auch f√ºr andere technische Bereiche.  Und nicht nur das Ingenieurwesen, es gab auch einen solchen Ausdruck in milit√§rischen F√§chern: ‚ÄûTeilen und Erobern‚Äú, was im Gro√üen und Ganzen die Verk√∂rperung desselben Prinzips ist.  Komplexit√§t t√∂tet, teilt sie in Teile und Sie werden gewinnen. <br>  In Bezug auf andere technische Bereiche gab es hier auf der Nabe einen interessanten Artikel dar√ºber, wie die entwickelten Triebwerke des Flugzeugs versagten und nicht auf Befehl des Piloten in den R√ºckw√§rtsgang schalteten.  Das Problem war, dass sie den Zustand des Chassis falsch interpretierten.  Anstatt sich auf die Systeme zu verlassen, die das Fahrgestell steuern, liest die Motorsteuerung direkt die Sensoren, Endschalter usw. im Fahrgestell.  In dem Artikel wurde auch erw√§hnt, dass das Triebwerk einer langwierigen Zertifizierung unterzogen werden muss, bevor es √ºberhaupt in einen Prototyp eines Flugzeugs eingebaut wird.  Und eine Verletzung der SRP f√ºhrte in diesem Fall eindeutig dazu, dass bei einer √Ñnderung des Fahrwerksdesigns der Code in der Motorsteuerung ge√§ndert und neu zertifiziert werden musste.  Schlimmer noch, eine Verletzung dieses Prinzips war das Flugzeug und das Leben des Piloten fast wert.  Gl√ºcklicherweise bedroht unsere t√§gliche Programmierung solche Konsequenzen nicht. Sie sollten jedoch die Prinzipien des Schreibens von gutem Code nicht vernachl√§ssigen.  Und hier ist warum: <br><br><ol><li>  Die Zerlegung des Codes verringert seine Komplexit√§t.  Wenn Sie zum L√∂sen eines Problems beispielsweise Code mit einer zyklomatischen Komplexit√§t von vier schreiben m√ºssen, erfordert die Methode, die f√ºr die gleichzeitige L√∂sung von zwei solchen Problemen verantwortlich ist, Code mit der Komplexit√§t 16. Wenn sie in zwei Methoden unterteilt ist, betr√§gt die Gesamtkomplexit√§t 8. Dies ist nat√ºrlich nicht immer der Fall kommt auf den Betrag gegen die Arbeit an, aber der Trend wird sowieso ungef√§hr der gleiche sein. </li><li>  Unit-Tests von zerlegtem Code sind vereinfacht und effizienter. </li><li>  Zerlegter Code erzeugt weniger Widerstand gegen √Ñnderungen.  Bei √Ñnderungen ist es weniger wahrscheinlich, dass ein Fehler gemacht wird. </li><li>  Der Code wird besser strukturiert.  Die Suche nach etwas in Code, der in Dateien und Ordnern angeordnet ist, ist viel einfacher als in einem gro√üen Fu√ütuch. </li><li>  Die Trennung von Boilerplate-Code von Gesch√§ftslogik f√ºhrt dazu, dass die Codegenerierung in einem Projekt angewendet werden kann. </li></ol><br>  Und all diese Zeichen geh√∂ren zusammen, dies sind Zeichen desselben Codes.  Sie m√ºssen sich beispielsweise nicht zwischen gut getestetem Code und gut strukturiertem Code entscheiden. <br><br><h1>  Bestehende Definitionen funktionieren nicht </h1><br>  Eine der Definitionen lautet: ‚ÄûEs sollte nur einen Grund geben, den Code (Klasse oder Funktion) zu √§ndern.‚Äú  Das Problem bei dieser Definition ist, dass sie im Widerspruch zum Open-Close-Prinzip steht, dem zweiten der SOLID-Gruppe von Prinzipien.  Seine Definition: "Der Code muss zur Erweiterung ge√∂ffnet und zur √Ñnderung geschlossen sein."  Ein Grund f√ºr eine √Ñnderung gegen√ºber einem vollst√§ndigen √Ñnderungsverbot.  Wenn wir genauer offenbaren, was hier gemeint ist, stellt sich heraus, dass es keinen Konflikt zwischen den Prinzipien gibt, aber es gibt definitiv einen Konflikt zwischen unscharfen Definitionen. <br><br>  Die zweite, direktere Definition lautet: "Der Code sollte nur eine Verantwortung haben."  Das Problem bei dieser Definition ist, dass es die menschliche Natur ist, alles zu verallgemeinern. <br><br>  Zum Beispiel gibt es eine Farm, auf der H√ºhner angebaut werden, und in diesem Moment hat die Farm nur eine Verantwortung.  Und so wird die Entscheidung getroffen, auch dort Enten zu z√ºchten.  Instinktiv werden wir dies eine Gefl√ºgelfarm nennen, anstatt zuzugeben, dass es jetzt zwei Verantwortlichkeiten gibt.  F√ºgen Sie dort Schafe hinzu, und dies ist jetzt eine Tierfarm.  Dann wollen wir dort Tomaten oder Pilze anbauen und uns den folgenden noch allgemeineren Namen einfallen lassen.  Gleiches gilt f√ºr den ‚Äûeinen Grund‚Äú zur √Ñnderung.  Dieser Grund kann so verallgemeinert werden, wie die Vorstellungskraft ausreicht. <br><br>  Ein weiteres Beispiel ist die Raumstationsmanager-Klasse.  Er macht nichts anderes, er verwaltet nur die Raumstation.  Wie gef√§llt dir dieser Kurs mit einer Verantwortung? <br>  Und da ich Redux erw√§hnt habe, wenn der Bewerber mit dieser Technologie vertraut ist, stelle ich auch die Frage, ob ein typischer SRP-Reduzierer verletzt? <br><br>  Ich erinnere mich, dass der Reduzierer die switch-Anweisung enth√§lt, und es kommt vor, dass er auf zehn oder sogar Hunderte von F√§llen anw√§chst.  Die alleinige Verantwortung des Reduzierers besteht darin, die Status√ºberg√§nge Ihrer Anwendung zu verwalten.  Das hei√üt, buchst√§blich haben einige Antragsteller geantwortet.  Und keine Hinweise k√∂nnten diese Meinung auf den Weg bringen. <br><br>  Wenn eine Art Code dem SRP-Prinzip zu entsprechen scheint, aber gleichzeitig unangenehm riecht, wissen Sie, warum dies geschieht.  Weil die Definition von ‚ÄûCode muss eine Verantwortung haben‚Äú einfach nicht funktioniert. <br><br><h1>  Passendere Definition </h1><br>  Durch Versuch und Irrtum hatte ich eine bessere Definition: <br>  <b>Die Codeverantwortung sollte nicht zu gro√ü sein</b> <br><br>  Ja, jetzt m√ºssen Sie die Verantwortung einer Klasse oder Funktion "messen".  Und wenn es zu gro√ü ist, m√ºssen Sie diese gro√üe Verantwortung in mehrere kleinere Verantwortlichkeiten aufteilen.  Zur√ºck zum Beispiel auf dem Bauernhof: Selbst die Verantwortung f√ºr die H√ºhnerzucht kann zu gro√ü sein, und es ist sinnvoll, beispielsweise Broiler von Legehennen zu trennen. <br><br>  Aber wie kann man es messen, wie kann man feststellen, dass die Verantwortung f√ºr diesen Code zu gro√ü ist? <br><br>  Leider habe ich keine mathematisch genauen Methoden, nur empirische.  Und vor allem kommt dies mit Erfahrung, Anf√§nger sind √ºberhaupt nicht in der Lage, den Code zu zerlegen, fortgeschrittenere k√∂nnen ihn besser besitzen, obwohl sie nicht immer beschreiben k√∂nnen, warum sie es tun und wie es in Theorien wie SRP passt. <br><br><ol><li>  Metrische zyklomatische Komplexit√§t.  Leider gibt es M√∂glichkeiten, diese Metrik zu maskieren. Wenn Sie sie jedoch erfassen, besteht die M√∂glichkeit, dass sie die am st√§rksten gef√§hrdeten Stellen in Ihrer Anwendung anzeigt. </li><li>  Die Gr√∂√üe von Funktionen und Klassen.  Eine 800-Zeilen-Funktion muss nicht gelesen werden, um zu verstehen, dass etwas nicht stimmt. </li><li>  Viele Importe.  Einmal habe ich eine Datei im Projekt eines benachbarten Teams ge√∂ffnet und einen ganzen Bildschirm mit Importen gesehen, die Seite nach unten gedr√ºckt und wieder waren nur Importe auf dem Bildschirm.  Erst nach dem zweiten Dr√ºcken sah ich den Anfang des Codes.  Sie k√∂nnen sagen, dass alle modernen IDEs Importe unter dem "Pluszeichen" verbergen k√∂nnen, aber ich sage, dass ein guter Code die "Ger√ºche" nicht verbergen muss.  Au√üerdem musste ich ein kleines St√ºck Code wiederverwenden und entfernte es aus dieser Datei in eine andere, und ein Viertel oder sogar ein Drittel der Importe gingen hinter dieses St√ºck.  Dieser Code geh√∂rte eindeutig nicht dorthin. </li><li>  Unit-Tests.  Wenn Sie immer noch Schwierigkeiten haben, den Umfang der Verantwortung zu bestimmen, zwingen Sie sich, Tests zu schreiben.  Wenn Sie zwei Dutzend Tests zum Hauptzweck einer Funktion schreiben m√ºssen, ohne Grenzf√§lle usw. zu z√§hlen, ist eine Zerlegung erforderlich. </li><li>  Gleiches gilt f√ºr zu viele vorbereitende Schritte zu Beginn des Tests und f√ºr Pr√ºfungen am Ende.  Im Internet finden Sie √ºbrigens die utopische Aussage, dass die sogenannten  Der Test sollte nur eine Aussage enthalten.  Ich glaube, dass jede willk√ºrlich gute Idee, die zum Absoluten erhoben wird, absurd unpraktisch werden kann. </li><li>  Gesch√§ftslogik sollte nicht direkt von externen Tools abh√§ngen.  F√ºr den Oracle-Treiber Express Routes ist es w√ºnschenswert, all dies von der Gesch√§ftslogik zu trennen und / oder sich hinter den Schnittstellen zu verstecken. </li></ol><br>  Ein paar Punkte: <br><br>  Nat√ºrlich hat die M√ºnze, wie ich bereits erw√§hnt habe, eine Kehrseite, und 800 Methoden in einer Zeile sind m√∂glicherweise nicht besser als eine Methode in 800 Zeilen. Es sollte in allem ein Gleichgewicht bestehen. <br><br>  Zweitens: Ich gehe nicht auf die Frage ein, wo dieser oder jener Code in √úbereinstimmung mit seiner Verantwortung platziert werden soll.  Beispielsweise haben Entwickler manchmal auch Schwierigkeiten, zu viel Logik in die DAL-Schicht zu ziehen. <br><br>  Drittens schlage ich keine spezifischen harten Grenzen wie "nicht mehr als 50 Zeilen pro Funktion" vor.  Dieser Ansatz beinhaltet nur eine Richtung f√ºr die Entwicklung von Entwicklern und m√∂glicherweise Teams.  Er arbeitet f√ºr mich, er muss Geld f√ºr andere verdienen. <br><br>  Und schlie√ülich, wenn Sie TDD durchlaufen, wird dies allein Sie sicherlich dazu bringen, den Code zu zerlegen, lange bevor Sie diese 20 Tests mit jeweils 20 Zusicherungen schreiben. <br><br><h1>  Trennen der Gesch√§ftslogik vom Boilerplate-Code </h1><br>  Wenn man √ºber die Regeln guten Codes spricht, kann man nicht auf Beispiele verzichten.  Das erste Beispiel befasst sich mit der Trennung von Boilerplate-Code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ae/61f/2a4/4ae61f2a4fba4563cbe17e3cfe6da69a.png"><br><br>  Dieses Beispiel zeigt, wie Back-End-Code normalerweise geschrieben wird.  Normalerweise schreiben die Benutzer Logik untrennbar mit dem Code, der dem Webserver Express Parameter wie URL, Anforderungsmethode usw. angibt. <br><br>  Ich habe die Gesch√§ftslogik als gr√ºne Markierung und den rot eingestreuten Code markiert, der mit den Abfrageparametern interagiert (rot). <br><br>  Ich teile diese beiden Verantwortlichkeiten immer auf folgende Weise: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b9/1a2/6a2/4b91a26a2b7d860804f22d72442c9947.png"><br><br>  In diesem Beispiel befindet sich die gesamte Interaktion mit Express in einer separaten Datei. <br><br>  Auf den ersten Blick scheint es, dass das zweite Beispiel keine Verbesserungen gebracht hat, es gab 2 Dateien anstelle von einer, zus√§tzliche Zeilen erschienen, die vorher nicht existierten - der Klassenname und die Methodensignatur.  Und was bringt diese Codetrennung dann?  Erstens ist der ‚ÄûAnwendungseinstiegspunkt‚Äú nicht mehr Express.  Dies ist eine regul√§re Typescript-Funktion.  Oder eine Javascript-Funktion, ob C #, wer schreibt WebAPI auf was. <br><br>  Auf diese Weise k√∂nnen Sie verschiedene Aktionen ausf√ºhren, die im ersten Beispiel nicht verf√ºgbar sind.  Beispielsweise k√∂nnen Sie Verhaltenstests schreiben, ohne Express ausl√∂sen zu m√ºssen, ohne http-Anforderungen im Test zu verwenden.  Und selbst wenn keine Benetzung erforderlich ist, ersetzen Sie das Router-Objekt durch Ihr Testobjekt. Jetzt kann der Anwendungscode einfach direkt aus dem Test aufgerufen werden. <br><br>  Ein weiteres interessantes Merkmal dieser Zerlegung ist, dass Sie jetzt einen Codegenerator schreiben k√∂nnen, der userApiService analysiert und auf seiner Basis Code generiert, der diesen Dienst mit Express verbindet.  In meinen zuk√ºnftigen Ver√∂ffentlichungen m√∂chte ich Folgendes angeben: Die Codegenerierung spart beim Schreiben von Code keine Zeit.  Die Kosten f√ºr den Codegenerator werden sich nicht dadurch auszahlen, dass Sie dieses Boilerplate jetzt nicht mehr kopieren m√ºssen.  Die Codegenerierung zahlt sich dadurch aus, dass der von ihr produzierte Code keine Unterst√ºtzung ben√∂tigt, was auf lange Sicht Zeit und vor allem die Nerven der Entwickler spart. <br><br><h1>  Teilen und erobern </h1><br>  Diese Methode zum Schreiben von Code gibt es schon lange, ich habe sie nicht selbst erfunden.  Ich bin gerade zu dem Schluss gekommen, dass es sehr praktisch ist, Gesch√§ftslogik zu schreiben.  Und daf√ºr habe ich ein weiteres fiktives Beispiel entwickelt, das zeigt, wie Sie schnell und einfach Code schreiben k√∂nnen, der sofort gut zerlegt und auch durch Benennungsmethoden selbst dokumentiert wird. <br><br>  Angenommen, Sie erhalten von einem Gesch√§ftsanalysten die Aufgabe, eine Methode zu erstellen, mit der ein Mitarbeiterbericht an eine Versicherungsgesellschaft gesendet wird.  Daf√ºr: <br><br><ol><li>  Daten m√ºssen aus der Datenbank entnommen werden </li><li>  In das gew√ºnschte Format konvertieren </li><li>  Senden Sie den resultierenden Bericht </li></ol><br>  Solche Anforderungen werden nicht immer explizit geschrieben, manchmal kann eine solche Reihenfolge aus einem Gespr√§ch mit dem Analysten impliziert oder gekl√§rt werden.  Beeilen Sie sich bei der Implementierung der Methode nicht, Verbindungen zur Datenbank oder zum Netzwerk zu √∂ffnen, sondern versuchen Sie stattdessen, diesen einfachen Algorithmus "wie er ist" in den Code zu √ºbersetzen.  Ungef√§hr so: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendEmployeeReportToProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> dal.getEmployeeReportData(reportId);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formatted = reportDataService.prepareEmployeeReport(data);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> networkService.sendReport(formatted);‚Äã }</code> </pre> <br>  Mit diesem Ansatz stellt sich heraus, dass es sich um einen ziemlich einfachen, leicht zu lesenden und zu testenden Code handelt, obwohl ich glaube, dass dieser Code trivial ist und nicht getestet werden muss.  Und es lag in der Verantwortung dieser Methode, keinen Bericht zu senden, sondern diese komplexe Aufgabe in drei Unteraufgaben aufzuteilen. <br><br>  Als n√§chstes kehren wir zu den Anforderungen zur√ºck und stellen fest, dass der Bericht aus einem Gehaltsabschnitt und einem Abschnitt mit Arbeitsstunden bestehen sollte. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareEmployeeReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportData</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> salarySection = prepareSalarySection(reportData);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workHoursSection = prepareWorkHoursSection(reportData);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { salarySection, workHoursSection };‚Äã }</code> </pre><br>  Und so weiter und so fort, brechen wir die Aufgabe weiter auf, bis die Implementierung kleiner Methoden, die nahezu trivial sind, erhalten bleibt. <br><br><h1>  Interaktion mit dem Open-Close-Prinzip </h1><br>  Am Anfang des Artikels habe ich gesagt, dass sich die Definitionen der Prinzipien von SRP und Open-Close widersprechen.  Der erste besagt, dass es einen Grund f√ºr die √Ñnderung geben muss, der zweite besagt, dass der Code f√ºr die √Ñnderung geschlossen werden muss.  Und die Prinzipien selbst widersprechen sich nicht nur nicht, sie arbeiten im Gegenteil in Synergie miteinander.  Alle 5 SOLID-Prinzipien zielen auf ein gutes Ziel ab - dem Entwickler zu sagen, welcher Code ‚Äûschlecht‚Äú ist und wie er ge√§ndert werden kann, damit er ‚Äûgut‚Äú wird.  Die Ironie - ich habe gerade 5 Verantwortlichkeiten durch eine weitere ersetzt. <br>  Stellen Sie sich also zus√§tzlich zum vorherigen Beispiel mit dem Senden des Berichts an die Versicherungsgesellschaft vor, dass ein Gesch√§ftsanalyst zu uns kommt und sagt, dass wir dem Projekt jetzt eine zweite Funktionalit√§t hinzuf√ºgen m√ºssen.  Der gleiche Bericht muss gedruckt werden. <br>  Stellen Sie sich vor, es gibt einen Entwickler, der glaubt, dass es bei SRP "nicht um Zersetzung geht". <br>  Dementsprechend zeigte ihm dieses Prinzip nicht die Notwendigkeit einer Zersetzung, und er realisierte die gesamte erste Aufgabe in einer Funktion.  Nachdem die Aufgabe zu ihm gekommen ist, kombiniert er die beiden Verantwortlichkeiten zu einer, weil  Sie haben viel gemeinsam und verallgemeinern ihren Namen.  Jetzt wird diese Verantwortung als "Servicebericht" bezeichnet.  Die Implementierung sieht ungef√§hr so ‚Äã‚Äãaus: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveEmployeeReportToProvider</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId, serveMethod</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* lots of code to read and convert the report */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(serveMethod) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sendToProvider: <span class="hljs-comment"><span class="hljs-comment">/* implementation of sending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> print: <span class="hljs-comment"><span class="hljs-comment">/* implementation of printing */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br>  Erinnert Sie an Code in Ihrem Projekt?  Wie gesagt, beide direkten Definitionen von SRP funktionieren nicht.  Sie √ºbermitteln dem Entwickler keine Informationen, dass ein solcher Code nicht geschrieben werden kann.  Und welcher Code kann geschrieben werden.  Es gab nur einen Grund f√ºr den Entwickler, diesen Code zu √§ndern.  Er hat einfach den vorherigen Grund umbenannt, Schalter hinzugef√ºgt und ist ruhig.  Und hier kommt das Prinzip des Open-Close-Prinzips zum Tragen, das direkt besagt, dass es unm√∂glich war, eine vorhandene Datei zu √§ndern.  Es war notwendig, Code zu schreiben, damit beim Hinzuf√ºgen neuer Funktionen eine neue Datei hinzugef√ºgt und keine vorhandene bearbeitet werden musste.  Das hei√üt, ein solcher Code ist unter dem Gesichtspunkt zweier Prinzipien gleichzeitig schlecht.  Und wenn der erste nicht geholfen hat, es zu sehen, sollte der zweite helfen. <br><br>  Und wie l√∂st die Divide and Conquer-Methode das gleiche Problem: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printEmployeeReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reportId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> dal.getEmployeeReportData(reportId);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formatted = reportDataService.prepareEmployeeReport(data);‚Äã <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> printService.printReport(formatted);‚Äã }</code> </pre><br>  F√ºgen Sie eine neue Funktion hinzu.  Ich nenne sie manchmal eine "Skriptfunktion", weil sie keine Implementierungen enthalten, sondern die Reihenfolge des Aufrufs zerlegter Teile unserer Verantwortung bestimmen.  Offensichtlich stimmen die ersten beiden Zeilen, die ersten beiden zerlegten Verantwortlichkeiten mit den ersten beiden Zeilen der zuvor implementierten Funktion √ºberein.  Genau wie die ersten beiden Schritte von zwei Aufgaben, die von einem Business Analyst beschrieben wurden, fallen sie zusammen. <br>  Um dem Projekt neue Funktionen hinzuzuf√ºgen, haben wir eine neue Skriptmethode und einen neuen printService hinzugef√ºgt.  Alte Dateien wurden nicht ge√§ndert.  Das hei√üt, diese Methode zum Schreiben von Code ist unter dem Gesichtspunkt zweier Prinzipien gut.  Und SRP und Open-Close <br><br><h1>  Alternative </h1><br>  Ich wollte auch einen alternativen, konkurrierenden Weg erw√§hnen, um einen gut zerlegten Code zu erhalten, der ungef√§hr so ‚Äã‚Äãaussieht - zuerst schreiben wir den Code ‚Äûauf die Stirn‚Äú und √ºberarbeiten ihn dann mit verschiedenen Techniken, zum Beispiel gem√§√ü Fowlers Buch ‚ÄûRefactoring‚Äú.  Diese Methoden erinnerten mich an die mathematische Herangehensweise an das Schachspiel, bei der Sie nicht genau verstehen, was Sie in Bezug auf die Strategie tun. Sie berechnen nur das "Gewicht" Ihrer Position und versuchen, es durch Z√ºge zu maximieren.  Ich mochte diesen Ansatz aus einem kleinen Grund nicht - Methoden und Variablen zu benennen ist bereits schwierig, und wenn sie keinen gesch√§ftlichen Wert haben, wird es unm√∂glich.  Wenn diese Techniken beispielsweise darauf hindeuten, dass Sie von hier und von dort 6 identische Zeilen ausw√§hlen und diese hervorheben m√ºssen, wie sollten Sie diese Methode nennen?  someSixIdenticalLines ()? <br>  Ich m√∂chte eine Reservierung vornehmen - ich denke nicht, dass diese Methode schlecht ist, ich konnte einfach nicht lernen, wie man sie benutzt. <br><br><h1>  Insgesamt </h1><br>  Wenn Sie dem Prinzip folgen, finden Sie Vorteile. <br><br>  Die Definition von ‚Äûes muss eine Verantwortung geben‚Äú funktioniert nicht. <br><br>  Es gibt eine bessere Definition und eine Reihe von indirekten Merkmalen, die sogenannten  Code-Ger√ºche signalisieren die Notwendigkeit der Zersetzung. <br><br>  Mit dem Ansatz ‚ÄûTeilen und Erobern‚Äú k√∂nnen Sie sofort gut strukturierten und selbstdokumentierenden Code schreiben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449586/">https://habr.com/ru/post/de449586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449572/index.html">√úber Ausschreibungen, Ausschreibungsk√§ufe und die Bildung einer Ausschreibungsaufgabe</a></li>
<li><a href="../de449574/index.html">N√ºtzliche SpecFlow-Funktionen</a></li>
<li><a href="../de449576/index.html">Software zur Verwaltung eines Roboterarms zur automatischen Erkennung seiner Konfiguration</a></li>
<li><a href="../de449578/index.html">Die Illusion von intelligentem Design</a></li>
<li><a href="../de449584/index.html">Advantech EKI-2000 Industrial Unmanaged Switches</a></li>
<li><a href="../de449588/index.html">Was ist die St√§rke und Schw√§che des Hosting-Marktes</a></li>
<li><a href="../de449590/index.html">Die Marktkapitalisierung von Microsoft betrug mehr als 1 Billion US-Dollar</a></li>
<li><a href="../de449596/index.html">Einfaches SFML-Spiel</a></li>
<li><a href="../de449600/index.html">"Smart Home" mit Yandex.Alisa</a></li>
<li><a href="../de449602/index.html">Inspiriert von Produktion und Basketball: Wie Yandex eine Programmiermeisterschaft vorbereitet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>