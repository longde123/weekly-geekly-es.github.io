<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèæ üë®üèæ‚Äçüéì ‚úâÔ∏è Onze perles cach√©es de Java 11 ‚¨áÔ∏è ü•° üë•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 11 n'a introduit aucune fonctionnalit√© innovante, mais il contient plusieurs joyaux dont vous n'avez peut-√™tre pas encore entendu parler. Vous av...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Onze perles cach√©es de Java 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 11</a> n'a introduit aucune fonctionnalit√© innovante, mais il contient plusieurs joyaux dont vous n'avez peut-√™tre pas encore entendu parler.  Vous avez d√©j√† regard√© les derni√®res nouveaut√©s en mati√®re de <code>String</code> , <code>Optional</code> , de <code>Collection</code> et autres chevaux de bataille?  Sinon, alors vous √™tes √† l'adresse: aujourd'hui, nous allons voir 11 joyaux cach√©s de Java 11! </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Inf√©rence de type pour les param√®tres lambda </h3><br><p>  Lors de l'√©criture d'une expression lambda, vous pouvez choisir entre sp√©cifier explicitement des types et les ignorer: </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 10 a introduit</a> <code>var</code> , mais il ne pouvait pas √™tre utilis√© dans lambdas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p>  En Java 11, c'est d√©j√† possible.  Mais pourquoi?  Il ne semble pas que <code>var</code> donn√© plus qu'une simple passe de type.  Bien que ce soit le cas, l'utilisation de <code>var</code> pr√©sente deux avantages mineurs: </p><br><ul><li>  rend l'utilisation de <code>var</code> plus universelle en supprimant l'exception √† la r√®gle </li><li>  vous permet d'ajouter des annotations au type de param√®tre sans avoir √† utiliser son nom complet </li></ul><br><p>  Voici un exemple du deuxi√®me cas: </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p>  Bien que le m√©lange de types d√©riv√©s, explicites et implicites dans des expressions lambda de la forme <code>(var type, String option, index) -&gt; ...</code> puisse √™tre impl√©ment√©, mais ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le cadre de JEP-323</a> ) ce travail n'a pas √©t√© effectu√©.  Par cons√©quent, il est n√©cessaire de choisir l'une des trois approches et d'y adh√©rer pour tous les param√®tres de l'expression lambda.  La n√©cessit√© de sp√©cifier <code>var</code> pour tous les param√®tres afin d'ajouter une annotation pour l'un d'eux peut √™tre l√©g√®rement ennuyeuse, mais g√©n√©ralement tol√©rable. </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines">  Traitement de flux de cha√Ænes avec <code>'String::lines'</code> </h3><br><p>  Vous avez une cha√Æne multi-lignes?  Vous voulez faire quelque chose avec chaque ligne?  Alors <code>String::lines</code> est le bon choix: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p>  Notez que la ligne d'origine utilise les d√©limiteurs Windows <code>\r\n</code> , et bien que je sois sous Linux, <code>lines()</code> quand m√™me cass√©.  Cela est d√ª au fait que, malgr√© le syst√®me d'exploitation actuel, cette m√©thode interpr√®te <code>\r</code> , <code>\n</code> et <code>\r\n</code> comme des sauts de ligne - m√™me s'ils sont m√©lang√©s sur la m√™me ligne. </p><br><p>  Un flux de lignes ne contient jamais les s√©parateurs de lignes eux-m√™mes.  Les lignes peuvent √™tre vides ( <code>"\n\n \n\n"</code> , qui contient 5 lignes), mais la derni√®re ligne de la ligne d'origine est ignor√©e si elle est vide ( <code>"\n\n"</code> ; 2 lignes).  <em>(Remarque du traducteur: il est pratique pour eux d'avoir une <code>line</code> , mais d'avoir une <code>string</code> , et nous avons les deux.)</em> </p><br><p>  Contrairement √† <code>split("\R")</code> , les <code>lines()</code> paresseuses et, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">je cite</a> , "offrent de meilleures performances [...] en recherchant plus rapidement de nouveaux sauts de ligne".  (Si quelqu'un veut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©poser un</a> benchmark sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JMH</a> pour v√©rification, faites le moi savoir).  Il refl√®te √©galement mieux l'algorithme de traitement et utilise une structure de donn√©es plus pratique (flux au lieu d'un tableau). </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp">  Suppression d'espaces avec <code>'String::strip'</code> , etc. </h3><br><p>  Initialement, <code>String</code> avait une m√©thode de d√©coupage pour supprimer les espaces blancs, ce qui √©tait consid√©r√© comme tout avec des codes jusqu'√† <code>U+0020</code> .  Oui, <code>BACKSPACE</code> ( <code>U+0008)</code> est un espace blanc comme <code>BELL</code> ( <code>U+0007</code> ), mais <code>LINE SEPARATOR</code> ( <code>U+2028</code> ) n'est plus consid√©r√© comme tel. </p><br><p>  Java 11 a introduit la m√©thode <code>strip</code> , dont l'approche a plus de nuances.  Il utilise la <code>Character::isWhitespace</code> de Java 5 pour d√©terminer exactement ce qui doit √™tre supprim√©.  D'apr√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa documentation,</a> il est clair que ceci: </p><br><ul><li>  <code>SPACE SEPARATOR</code> , <code>LINE SEPARATOR</code> , <code>PARAGRAPH SEPARATOR</code> , mais pas un espace inextricable </li><li>  <code>HORIZONTAL TABULATION</code> ( <code>U+0009</code> ), <code>LINE FEED</code> <code>U+000A</code> <code>LINE FEED</code> ( <code>U+000A</code> ), <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>FORM FEED</code> ( <code>U+000C</code> ), <code>CARRIAGE RETURN</code> ( <code>U+000D</code> ) </li><li>  <code>FILE SEPARATOR</code> <code>U+001C</code> ( <code>U+001C</code> ), <code>U+001C</code> <code>GROUP SEPARATOR</code> ( <code>U+001D</code> ), <code>U+001D</code> <code>RECORD SEPARATOR</code> ( <code>U+001E</code> ), <code>U+001E</code> <code>UNIT SEPARATOR</code> ( <code>U+001F</code> ) </li></ul><br><p>  Avec la m√™me logique, il existe deux autres m√©thodes de nettoyage, <code>stripLeading</code> et <code>stripTailing</code> , qui font exactement ce que l'on attend d'eux. </p><br><p>  Et enfin, si vous avez juste besoin de savoir si la ligne devient vide apr√®s avoir supprim√© les espaces, alors il n'est pas n√©cessaire de vraiment les supprimer - utilisez simplement <code>isBlank</code> : </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat">  R√©p√©tition de cha√Ænes avec <code>'String::repeat'</code> </h3><br><p>  Saisissez l'id√©e: </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk">  √âtape 1: Surveiller JDK </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="Garder un ≈ìil sur le d√©veloppement JDK"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy">  √âtape 2: Recherche de questions li√©es √† StackOverflow </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="Vous recherchez des questions connexes sur Stackoverflow"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah">  √âtape 3: arriver avec une nouvelle r√©ponse bas√©e sur les changements futurs </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="Entrez avec une nouvelle r√©ponse bas√©e sur les changements √† venir"></p><br><h6 id="shag-4-">  √âtape 4: ???? </h6><br><h6 id="shag-4-profit">  √âtape 4: Profit </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¬Ø \ _ („ÉÑ) _ / ¬Ø"></p><br><p>  Comme vous pouvez l'imaginer, <code>String</code> a une nouvelle m√©thode de <code>repeat(int)</code> .  Cela fonctionne exactement conform√©ment aux attentes, et il y a peu de choses √† discuter. </p><br><h3 id="sozdanie-putey-s-pathof">  Cr√©er des chemins avec <code>'Path::of'</code> </h3><br><p>  J'aime vraiment l'API <code>Path</code> , mais convertir des chemins entre diff√©rentes vues (comme <code>Path</code> , <code>File</code> , <code>URL</code> , <code>URI</code> et <code>String</code> ) est toujours ennuyeux.  Ce point est devenu moins d√©routant en Java 11 en copiant deux m√©thodes <code>Paths::get</code> dans <code>Path::of</code> methods: </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p>  Ils peuvent √™tre consid√©r√©s comme canoniques, car les deux anciennes m√©thodes <code>Paths::get</code> utilisent de nouvelles options. </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring">  Lire et √©crire des fichiers avec <code>'Files::readString'</code> et <code>'Files::writeString'</code> </h3><br><p>  Si j'ai besoin de lire √† partir d'un fichier volumineux, j'utilise g√©n√©ralement <code>Files::lines</code> pour obtenir un flux paresseux de ses lignes.  De m√™me, pour enregistrer une grande quantit√© de donn√©es qui peuvent ne pas √™tre enti√®rement stock√©es en m√©moire, j'utilise <code>Files::write</code> passant comme <code>Iterable&lt;String&gt;</code> . </p><br><p>  Mais qu'en est-il du cas simple lorsque je veux traiter le contenu d'un fichier sur une seule ligne?  Ce n'est pas tr√®s pratique, car <code>Files::readAllBytes</code> et les variantes appropri√©es de <code>Files::write</code> fonctionnent sur des tableaux d'octets. </p><br><p>  Et puis Java 11 appara√Æt, ajoutant <code>readString</code> et <code>writeString</code> aux <code>Files</code> : </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p>  Clair et facile √† utiliser.  Si n√©cessaire, vous pouvez passer le jeu de <code>Charset</code> √† <code>readString</code> , et dans <code>writeString</code> √©galement un tableau <code>OpenOptions</code> . </p><br><h3 id="pustoe-io-s-readernullreader-i-tp">  E / S vides avec <code>'Reader::nullReader'</code> , etc. </h3><br><p>  Besoin d'un <code>OutputStream</code> qui n'√©crit nulle part?  Ou un <code>InputStream</code> vide?  Et <code>Reader</code> et <code>Writer</code> qui ne font rien?  Java 11 a tout pour plaire: </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>(Note du traducteur: dans <code>commons-io</code> ces classes existent depuis environ 2014.)</em> </p><br><p>  Cependant, je suis surpris - <code>null</code> est-il vraiment le meilleur pr√©fixe?  Je n'aime pas comment cela est utilis√© pour signifier "absence intentionnelle" ... Peut-√™tre serait-il pr√©f√©rable d'utiliser <code>noOp</code> ?  <em>(Note du traducteur: ce pr√©fixe a probablement √©t√© choisi en raison de l'utilisation courante de <code>/dev/null</code> .)</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code> avec <code>'Collection::toArray'</code> </h3><br><p>  Comment convertir des collections en tableaux? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p>  La premi√®re option, les <code>objects</code> , perd toutes les informations sur les types, elle est donc en vol.  Et le reste?  Les deux sont volumineux, mais le premier est plus court.  Ce dernier cr√©e un tableau de la taille requise, de sorte qu'il semble plus productif (c'est-√†-dire qu'il "semble plus productif", voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr√©dibilit√©</a> ).  Mais est-ce vraiment plus productif?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Non, au contraire, c'est plus lent</a> (pour le moment). </p><br><p>  Mais pourquoi devrais-je m'en soucier?  N'y a-t-il pas une meilleure fa√ßon de proc√©der?  Dans Java 11, il y a: </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  Une nouvelle variante de <code>Collection::toArray</code> , qui accepte <code>IntFunction&lt;T[]&gt;</code> , c'est-√†-dire  une fonction qui re√ßoit la taille du tableau et renvoie un tableau de la taille requise.  Il peut √™tre bri√®vement exprim√© en r√©f√©rence √† un constructeur de la forme <code>T[]::new</code> (pour un <code>T</code> bien connu). </p><br><p>  Fait int√©ressant, l'impl√©mentation par d√©faut de <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> passe toujours <code>0</code> au g√©n√©rateur de tableau.  Au d√©but, j'ai d√©cid√© que cette solution √©tait bas√©e sur les meilleures performances pour les tableaux de longueur nulle, mais maintenant je pense que la raison peut √™tre que pour certaines collections, le calcul de la taille peut √™tre une op√©ration tr√®s co√ªteuse et vous ne devez pas utiliser cette approche dans l'impl√©mentation par d√©faut de <code>Collection</code> .  Cependant, des impl√©mentations de collections sp√©cifiques, telles que <code>ArrayList</code> , peuvent changer cette approche, mais elles ne changent pas dans Java 11.  Pas la peine, je suppose. </p><br><h3 id="proverka-otsutstviya-s-optionalisempty">  <code>'Optional::isEmpty'</code> absence avec <code>'Optional::isEmpty'</code> </h3><br><p>  Avec l'utilisation abondante d' <code>Optional</code> , en particulier dans les grands projets, o√π vous rencontrez souvent une approche non <code>Optional</code> , vous devez souvent v√©rifier si elle a une valeur.  Il existe une m√©thode <code>Optional::isPresent</code> pour cela.  Mais tout aussi souvent, vous devez savoir le contraire - cette <code>Optional</code> vide.  Pas de probl√®me, utilisez simplement <code>!opt.isPresent()</code> , non? </p><br><p>  Bien s√ªr, il peut en √™tre ainsi, mais il est presque toujours plus facile de comprendre la logique <code>if</code> sa condition n'est pas invers√©e.  Et parfois, <code>Optional</code> appara√Æt √† la fin d'une longue cha√Æne d'appels et si vous avez besoin de le v√©rifier pour rien, alors vous devez parier <code>!</code>  au tout d√©but: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p>  Dans ce cas, sautez-le <code>!</code>  tr√®s facile.  √Ä partir de Java 11, il existe une meilleure option: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot">  Inverser les pr√©dicats avec <code>'Predicate::not'</code> </h3><br><p>  En parlant d'inverser ... L'interface <code>Predicate</code> a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> <code>negate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instance de</a> <code>negate</code> : elle retourne un nouveau pr√©dicat qui effectue le m√™me contr√¥le, mais inverse son r√©sultat.  Malheureusement, j'arrive rarement √† l'utiliser ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Le probl√®me est que j'ai rarement acc√®s √† l'instance de <code>Predicate</code> .  Plus souvent, je veux obtenir une telle instance via un lien vers une m√©thode (et l'inverser), mais pour que cela fonctionne, le compilateur doit savoir √† quoi apporter la r√©f√©rence √† la m√©thode - sans lui, il ne peut rien faire.  Et c'est exactement ce qui se passe si vous utilisez la construction <code>(String::isBlank).negate()</code> : le compilateur ne sait plus ce que <code>String::isBlank</code> devrait √™tre l√†-dessus et abandonne.  Une caste correctement sp√©cifi√©e corrige cela, mais √† quel prix? </p><br><p>  Bien qu'il existe une solution simple.  N'utilisez pas la <code>negate</code> instance de <code>negate</code> , mais utilisez la nouvelle m√©thode statique <code>Predicate.not(Predicate&lt;T&gt;)</code> de Java 11: </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p>  D√©j√† mieux! </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate">  Expressions r√©guli√®res en tant que pr√©dicat avec <code>'Pattern::asMatchPredicate'</code> </h3><br><p>  Y a-t-il une expression r√©guli√®re?  Besoin de filtrer les donn√©es dessus?  Que diriez-vous de ceci: </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mot√∂rhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p>  J'√©tais tr√®s heureux de trouver cette m√©thode!  Il vaut la peine d'ajouter qu'il s'agit d'une m√©thode de Java 8. Oups, je l'ai rat√©e alors.  Java 11 a ajout√© une autre m√©thode similaire: <code>Pattern::asMatchPredicate</code> .  Quelle est la diff√©rence? </p><br><ul><li>  <code>asPredicate</code> v√©rifie que la cha√Æne <strong>ou une partie de la cha√Æne</strong> correspond au mod√®le (fonctionne comme <code>s -&gt; this.matcher(s).find()</code> ) </li><li>  <code>asMatchPredicate</code> v√©rifie que la <strong>cha√Æne enti√®re</strong> correspond au mod√®le (fonctionne comme <code>s -&gt; this.matcher(s).matches()</code> ) </li></ul><br><p>  Par exemple, nous avons une expression r√©guli√®re qui v√©rifie les num√©ros de t√©l√©phone, mais elle ne contient pas <code>^</code> et <code>$</code> pour suivre le d√©but et la fin d'une ligne.  Ensuite, le code suivant ne fonctionnera pas comme vous pouvez vous y attendre: </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p>  Avez-vous remarqu√© une erreur?  Une ligne comme <code>" -152 ? +1-202-456-1414"</code> sera filtr√©e, car elle contient un num√©ro de t√©l√©phone valide.  D'un autre c√¥t√©, <code>Pattern::asMatchPredicate</code> ne le permettra pas, car la cha√Æne <strong>enti√®re</strong> ne correspondra <strong>plus</strong> au mod√®le. </p><br><h3 id="samoproverka">  Autotest </h3><br><p>  Voici un aper√ßu de toutes les onze perles - vous souvenez-vous toujours de ce que fait chaque m√©thode?  Si oui, vous avez r√©ussi le test. </p><br><ul><li>  en <code>String</code> : <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li>  dans <code>Path</code> : <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li>  dans les <code>Files</code> : <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li>  dans <code>InputStream</code> : <code>static InputStream nullInputStream()</code> </li><li>  dans <code>OutputStream</code> : <code>static OutputStream nullOutputStream()</code> </li><li>  dans <code>Reader</code> : <code>Reader</code> <code>static Reader nullReader()</code> </li><li>  dans <code>Writer</code> : <code>static Writer nullWriter()</code> </li><li>  dans <code>Collection</code> : <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li>  en <code>Optional</code> : <code>boolean isEmpty()</code> </li><li>  dans le <code>Predicate</code> : <code>Predicate</code> <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li>  dans le <code>Pattern</code> : <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p>  Amusez-vous avec Java 11! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441154/">https://habr.com/ru/post/fr441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441142/index.html">12 points de croissance de conversion, ou du contenu qui se vend vraiment</a></li>
<li><a href="../fr441146/index.html">R√©seaux sans fil industriels: lequel choisir?</a></li>
<li><a href="../fr441148/index.html">Comment g√©rer correctement les erreurs: le silence n'est pas toujours bon</a></li>
<li><a href="../fr441150/index.html">Premi√®re introduction au protocole HTTP en √©crivant le serveur Web Java le plus simple</a></li>
<li><a href="../fr441152/index.html">Comment minimiser les erreurs lors de l'int√©gration avec des services externes: l'exp√©rience d'un courtier en ligne</a></li>
<li><a href="../fr441158/index.html">Comment l'√©thique est devenue le probl√®me le plus cher de la Silicon Valley et la philosophie est devenue sa solution la plus pratique</a></li>
<li><a href="../fr441160/index.html">Comment apprendre √† savoir quand dire non</a></li>
<li><a href="../fr441166/index.html">Nous obtenons le mot de passe principal du gestionnaire de mots de passe verrouill√© 1 Mot de passe 4</a></li>
<li><a href="../fr441168/index.html">QUIC DataChannels: premi√®res √©tapes</a></li>
<li><a href="../fr441172/index.html">Comment le march√© de l'impression 3D a augment√© en 2018 et ce que cela signifie pour les entreprises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>