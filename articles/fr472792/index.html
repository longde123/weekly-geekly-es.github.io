<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏼 😞 🖇️ Ordinateur basé sur les vannes NOR: à l'intérieur de l'ordinateur de commande embarqué Apollo 👩🏿‍🔧 🥨 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, nous avons participé à la restauration de l' ordinateur de contrôle embarqué Apollo, un ordinateur qui était responsable du contrôle, de la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ordinateur basé sur les vannes NOR: à l'intérieur de l'ordinateur de commande embarqué Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Récemment, nous avons participé à la restauration de l'</a> ordinateur de contrôle embarqué Apollo, un ordinateur qui était responsable du contrôle, de la navigation et de la surveillance à bord des missions Apollo volant vers la Lune.  Cet ordinateur historique a été l'un des premiers à utiliser des circuits intégrés (CI) et son processeur a été entièrement construit sur des vannes NOR (le deuxième type de CI, un amplificateur de lecture, a été utilisé dans la mémoire de l'ordinateur).  Dans cet article, je décrirai l'architecture et la conception du CPU. <br><br><h2>  Architecture informatique d'Apollo Control </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Plateaux séparés de l'ordinateur de commande Apollo.</i>  <i>Le plateau de gauche contient une logique basée sur les portes NOR.</i>  <i>À droite - mémoire et composants auxiliaires.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'</a> ordinateur de guidage Apollo (AGC) a été développé dans les années 1960 pour permettre aux missions Apollo de voler vers la lune.  À une époque où la plupart des ordinateurs occupaient de l'espace d'un réfrigérateur pleine grandeur à une pièce entière, l'AGC était quelque chose d'unique - il était assez petit pour tenir à bord du vaisseau spatial Apollo, pesait 32 kg et ne prenait pas plus de 0,03 m <sup>3</sup> (30 litres). <br><a name="habracut"></a><br>  L'ordinateur AGC est de 15 bits.  Il est étrange de rencontrer une taille de mot qui n'est pas une puissance de deux, mais dans les années 1960, avant même que les octets ne deviennent populaires, les ordinateurs utilisaient une variété de tailles de mot.  15 bits ont fourni une précision suffisante pour l'atterrissage sur la lune (et utilisé des données avec une précision double et triple si nécessaire), donc 16 bits augmenteraient simplement la taille et le poids de l'ordinateur inutilement. <br><br>  L'instruction AGC était située dans un mot de 15 bits et comprenait 3 bits, indiquant le code d'opération, et 12 bits, indiquant l'adresse en mémoire.  Malheureusement, ces volumes n'étaient toujours pas suffisants, de sorte que l'ordinateur a utilisé de nombreuses astuces et solutions de contournement, et l'architecture s'est avérée plutôt maladroite.  Une adresse mémoire de 12 bits ne peut accéder qu'aux mots 4K.  Dans le même temps, AGC avait 2 000 mots dans la RAM principale et 36 000 mots dans la mémoire centrale.  Pour accéder à toute la mémoire, AGC a utilisé un système de commutation de banque de mémoire sophistiqué et plusieurs registres.  En d'autres termes, la mémoire était accessible uniquement en morceaux de 256 mots, et la ROM - en morceaux de taille légèrement plus grande. <br><br>  3 bits pour le code d'opération n'étaient pas suffisants pour indiquer directement 34 instructions possibles, donc l'AGC a utilisé des astuces avec l'extension de la valeur des instructions et le fait que certaines instructions avaient du sens de s'exécuter uniquement avec certaines cellules de mémoire.  De plus, des astuces telles que des adresses «magiques» en mémoire ont été utilisées - par exemple, l'écriture dans la cellule «décalage vers la droite» a effectué un décalage au niveau du bit, éliminant ainsi le besoin d'une instruction de «décalage vers la droite» distincte.  Il y avait également des instructions combinant plusieurs actions à la fois. <br><br>  L'architecture AGC était assez simple, même selon les normes des années 1960.  Bien qu'il ait été créé à une époque de mainframes complexes et puissants, les capacités d'AGC étaient très limitées;  en termes de puissance et d'architecture, il est comparable aux premiers microprocesseurs.  Ses points forts étaient sa taille compacte et ses grandes capacités pour fournir des données d'entrée et de sortie en temps réel. <br><br>  Le schéma architectural ci-dessous montre les principaux composants de l'AGC.  J'ai mis en évidence en couleur les parties sur lesquelles je m'attarde plus en détail.  AGC avait un petit ensemble de registres et un module arithmétique simple traitant uniquement de l'addition.  Il n'avait que 36 000 mots de ROM et 2 000 mots de RAM.  Le «bus d'écriture» était le principal moyen de transfert de données entre les composants.  Des instructions de décodage et un générateur de séquence ont généré des impulsions de commande pour l'AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>Schéma fonctionnel AGC</i> <br><br>  Environ la moitié du diagramme est occupée par la mémoire, ce qui reflète le fait que dans de nombreux aspects, l'architecture AGC a été développée autour de sa mémoire.  Comme la plupart des ordinateurs dans les années 1960, AGC a utilisé la mémoire centrale, stockant chaque bit dans un minuscule anneau de ferrite (noyau) enfilé sur un treillis métallique.  Étant donné que chaque bit nécessitait un noyau physique séparé, la quantité de cette mémoire était radicalement inférieure à celle d'un semi-conducteur moderne.  Une caractéristique distinctive de la mémoire sur les cœurs était que la lecture d'un mot de la mémoire le supprimait, donc après chaque accès, cette valeur devait être réécrite.  AGC avait également une mémoire ROM fixe, les fameux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noyaux cousus</a> - ils étaient utilisés pour stocker des programmes et étaient physiquement cousus avec des fils (voir ci-dessous). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Mémoire rapprochée sur les noyaux cousus</i> <br><br><h2>  Vannes NOR </h2><br>  AGC a été l'un des premiers ordinateurs à utiliser IP.  Les possibilités de ces premiers IP étaient très limitées;  sur les puces AGC (ci-dessous), il n'y avait que six transistors et huit résistances, et ensemble, ils ont mis en œuvre une porte NOR avec trois entrées. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>Vanne NOR double avec trois entrées AGC.</i>  <i>Dix fils à l'extérieur du cristal sont connectés aux contacts externes du CI.</i> <br><br>  La désignation schématique de la vanne NOR est indiquée ci-dessous.  Il s'agit de la porte logique la plus simple: si toutes les entrées sont égales à zéro, alors la sortie est égale à un.  Vous pourriez être surpris, mais une porte NOR suffit pour créer un ordinateur.  NOR est une vanne universelle: toute autre vanne logique peut être réalisée sur sa base.  Par exemple, lors de la combinaison de toutes les entrées NOR, nous obtenons un onduleur.  Après avoir placé l'onduleur à la sortie du NOR, nous obtenons une vanne OU.  En plaçant les onduleurs aux entrées de la porte NOR, nous obtenons une porte ET.  Et à partir de ces portes, vous pouvez construire une logique plus complexe: déclencheurs, additionneurs et compteurs. <br><br>  La valve NAND a la même polyvalence.  Dans les circuits modernes, pour des raisons techniques, les NAND sont utilisés plus souvent que les NOR.  Dans le cours populaire " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De NAND à Tetris</a> " décrit comment créer un ordinateur à partir de vannes NAND, jusqu'à la mise en œuvre du jeu "Tetris".  Tout d'abord, un ensemble de portes logiques est construit à partir de NAND (NON, ET, OU, XOR, multiplexeur, démultiplexeur).  Ensuite, des blocs de construction plus grands sont créés à partir d'eux (déclencheur, additionneur, compteur, ALU, registre) et à partir d'eux - un ordinateur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>La porte NOR donne 1, si elle a 0 sur toutes les entrées. Si au moins une des entrées a 1, alors le NOR donne 0.</i> <br><br>  Très souvent, dans AGC rencontre un composant tel que RS-trigger (set-reset, set / reset).  Ce circuit est composé de deux portes NOR et stocke un bit de données.  Le bit 1 est stocké à l'entrée définie et le bit 0 est stocké à l'entrée de réinitialisation. Autrement dit, l'impulsion 1, appliquée à l'entrée définie, ferme la vanne supérieure et active la vanne inférieure, de sorte que la sortie 1 se révèle. L'impulsion 1, appliquée pour réinitialiser l'entrée, fait le contraire. .  Si 0 est appliqué aux deux entrées, le déclencheur se souvient de son état précédent, jouant le rôle d'un lecteur.  Dans la section suivante, nous montrerons comment les registres sont créés à partir d'un déclencheur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>Déclenchement RS de deux portes NOR.</i>  <i>Une valve, lorsqu'elle est ouverte, ferme l'autre.</i>  <i>Une ligne au-dessus de l'une des sorties indique qu'elle complète l'autre.</i> <br><br><h2>  Registres </h2><br>  AGC possède un petit ensemble de registres pour le stockage temporaire de valeurs en dehors de la mémoire principale.  Le registre principal est le lecteur (A) utilisé dans de nombreuses opérations arithmétiques.  Il a également un registre de compteur Z, des registres de blocs arithmétiques X et Y, un tampon B, une adresse de retour Q et quelques autres (dans les ordinateurs modernes, la pile est utilisée pour appeler des routines et en revenir, mais à cette époque, les programmeurs devaient écrire la pile eux-mêmes pour la récursivité )  Pour l'accès à la mémoire, il y a un registre d'adresse mémoire S et pour les données, un registre de mémoire tampon G. De plus, AGC a des registres dans la mémoire principale - par exemple, des compteurs d'entrée / sortie. <br><br>  Le diagramme ci-dessous montre le schéma de registre AGC, simplifié pour le cas avec un bit et deux registres.  Chaque bit de registre a un déclencheur utilisant le schéma décrit précédemment (bleu et violet).  Les données sont transférées vers et depuis les registres via le bus d'écriture (rouge).  Pour écrire dans le registre, le déclencheur est réinitialisé par un signal clair (CQG ou CZG, vert).  Ensuite, le signal "d'écriture" (WQG ou WZG, orange) permet aux données qui transitent par le bus d'écriture de définir le déclencheur de registre correspondant.  Pour lire le registre, le signal de lecture (RQG ou RZG, cyan) passe la sortie de déclenchement via l'amplificateur d'enregistrement au bus d'enregistrement et est utilisé dans d'autres parties de l'AGC.  Le schéma de registre complet est plus complexe, il a plusieurs registres 16 bits, mais le schéma de base est le suivant. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Fonctionnement simplifié du registre AGC</i> <br><br>  Le tableau des registres illustre trois points clés.  Premièrement, le circuit de registre est construit à partir de portes NOR.  Deuxièmement, le mouvement des données est construit autour du bus d'écriture.  Enfin, les actions des registres dépendent de certains signaux de commande arrivant au bon moment. <br><br><h2>  Module arithmétique </h2><br>  La plupart des ordinateurs ont un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">périphérique de logique arithmétique</a> qui effectue des opérations arithmétiques et booléennes.  Par rapport aux ordinateurs modernes, le module arithmétique d'AGC est très limité: il n'effectue que l'addition de quantités de 16 bits, il est donc appelé module arithmétique et non module arithmétique et logique (le reste des opérations est effectué par le biais de diverses astuces; par exemple, la soustraction est effectuée par addition, avant laquelle pour l'un des arguments, les bits sont inversés, etc.). <br><br>  Le diagramme ci-dessous montre un bit du module arithmétique AGC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'additionneur complet</a> (rouge) calcule la somme de deux bits et porte.  Le transfert est transféré à l'additionneur suivant - de cette façon, ils peuvent être combinés pour ajouter des mots plus longs (pour accélérer le transfert des transferts dans des cas comme 111111111111111 + 1, AGC utilise un additionneur avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">saut de transfert</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Les registres X et Y (violet et vert) fournissent deux bits d'entrée à l'additionneur.  Ils sont implémentés à l'aide des déclencheurs déjà décrits sur les vannes NOR.  La boucle bleue écrit les valeurs dans les registres X et Y conformément aux signaux de commande.  Le schéma est assez compliqué, car il vous permet de stocker des constantes et des valeurs avec un décalage dans les registres, mais je n'entrerai pas dans cette rubrique.  Faites attention au signal de commande A2X, qui transfère la valeur du registre A au registre X;  nous lui reviendrons plus tard. <br><br>  La photo ci-dessous montre la mise en œuvre physique du circuit AGC.  Ce module implémente quatre bits pour les registres et un module arithmétique.  Les rectangles noirs sont des adresses IP plates;  chaque module a deux cartes avec 60 puces chacune, et un total de 240 portes NOR.  Le module arithmétique et les registres sont assemblés à partir de quatre modules identiques, chacun traitant quatre bits;  ceci est similaire à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section microprocesseur</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>Le module arithmétique et les registres sont assemblés à partir de quatre modules identiques.</i>  <i>Les modules sont installés dans des emplacements de A8 à A11.</i> <br><br><h2>  Exécution des instructions </h2><br>  Cette section décrit la séquence d'opérations que l'AGC effectue pour exécuter l'instruction.  En particulier, je montrerai comment fonctionne l'instruction ADS (ajouter au stockage).  Cette instruction lit la valeur de la mémoire, l'ajoute au lecteur (registre A) et enregistre la somme à la fois dans l'additionneur et dans la mémoire.  Il s'agit d'une instruction unique, mais pour son exécution, AGC prend plusieurs étapes et de nombreuses valeurs sont déplacées ici et là. <br><br>  Le temporisateur d'instruction est implémenté en raison du sous-système de mémoire sur les noyaux magnétiques.  En particulier, la lecture d'une valeur de la mémoire efface la valeur stockée, donc après chaque lecture, la valeur doit être réécrite.  De plus, lors de l'accès à la mémoire, il y a un délai entre la désignation de l'adresse et la réception des données.  En conséquence, chaque cycle d'horloge passe 12 étapes pour la lecture et l'enregistrement ultérieur.  Chaque intervalle de temps (de T1 à T12) dure un peu moins de microsecondes, et le cycle entier dure 11,7 μs, et est appelé le temps de cycle de mémoire (MCT). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>Module de mémoire à noyau magnétique effaçable d'AGC.</i>  <i>Il stocke 2 feuilles, chaque bit est stocké à l'aide d'un petit anneau de ferrite séparé.</i> <br><br>  MCT est l'unité de base de mémoire pour l'exécution des instructions.  Une instruction typique nécessite deux cycles d'horloge: l'un pour extraire l'instruction de la mémoire, le second pour effectuer l'opération.  Par conséquent, une instruction typique prend deux MCT (23,4 μs), ce qui nous donne 43 000 instructions par seconde (comparé aux processeurs modernes et à leurs milliards d'instructions par seconde, c'est extrêmement lent). <br><br>  AGC traite les instructions, les divisant en sous-commandes, chacune prenant un cycle d'horloge de mémoire.  Par exemple, une instruction ADS se compose de deux sous-commandes: ADS0 (ajout) et STD2 (appel de l'instruction suivante).  Le diagramme ci-dessous montre le mouvement des données dans l'AGC pour exécuter l'instruction ADS0.  12 mesures vont de gauche à droite. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Les étapes les plus importantes sont les suivantes: <br>  T1: l'adresse d'opérande est copiée du registre d'instructions B vers le registre d'adresse mémoire S pour démarrer la lecture depuis la mémoire. <br>  T4: l'opérande est lu de la mémoire au registre de données de la mémoire G. <br>  T5: l'opérande est copié de G vers l'additionneur Y. La valeur du lecteur A est copiée vers l'additionneur X. <br>  T6: l'additionneur calcule la somme U, et la copie dans le registre de données de la mémoire G. <br>  T8: le compteur de programme Z est copié dans le registre d'adresse mémoire S en préparation de la réception de la prochaine instruction de la mémoire. <br>  T10: La somme du registre de données de la mémoire G est réécrite dans la mémoire. <br>  T11: le montant U est copié sur le lecteur A. <br><br>  Bien qu'il s'agisse d'une simple instruction de sommation, de nombreuses données sont transmises à plusieurs reprises ici sur 12 intervalles de temps.  Et à chacune de ces actions un signal de contrôle spécifique est associé;  par exemple, le signal A2X dans l'intervalle T5 copie la valeur du lecteur A dans le registre X. Pour copier le registre G dans le registre Y, deux impulsions de commande sont nécessaires: RG (lire G) et WY (écrire Y).  Dans la section suivante, je vais expliquer comment le module de commande AGC génère les signaux de commande nécessaires pour chaque instruction. <br><br><h2>  Module de commande </h2><br>  Comme la plupart des ordinateurs, le module de contrôle AGC décode chaque instruction et génère des signaux de contrôle qui indiquent au reste du processeur ce qu'il doit faire.  L'AGC utilise un module de commande préprogrammé composé de vannes NOR pour générer des signaux.  AGC n'utilise pas de microcode;  il n'a pas de microinstructions et ne contrôle pas la mémoire, car cela prendrait trop d'espace physique. <br><br>  Le cœur du module de commande AGC est appelé le générateur de point de croisement.  Il prend une sous-commande et l'une des périodes et génère des signaux de contrôle pour cette combinaison.  Il peut être imaginé sous la forme d'un réseau, sur lequel les sous-commandes vont dans une direction, et les segments temporels dans l'autre, et chacun des points d'intersection a son propre signal de commande. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>Le générateur d'intersection nécessite de nombreux composants et est divisé en trois modules;</i>  <i>Il s'agit du module A6.</i>  <i>Faites attention aux fils ajoutés qui changent le circuit.</i>  <i>Il s'agit d'une première version d'un module de test sur le terrain;</i>  <i>les modules de vol n'avaient déjà aucun fil.</i> <br><br>  Pour plus d'efficacité, le module de contrôle final est hautement optimisé.  Les instructions ayant un comportement similaire sont combinées et traitées ensemble par le générateur d'intersection, ce qui réduit la taille du circuit requis.  Par exemple, AGC a une instruction «ajouter à un lecteur avec une double précision» (DAS).  Comme il équivaut approximativement à deux ajouts de mots simples, les sous-commandes DAS1 et ADS0 du générateur d'intersection ont une logique commune.  Le diagramme ci-dessous montre le circuit générateur d'intersection pour l'intervalle de temps T5, et la logique de la sous-commande ADS0 (utilisant le signal DAS1) est mise en évidence.  Par exemple, un signal 5K est généré à partir d'une combinaison de DAS1 et T5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Mais que sont les signaux 5K et 5L?  Ceci est une autre optimisation.  De nombreuses impulsions de commande sont souvent alimentées ensemble, donc au lieu de les générer directement, le générateur d'intersection génère des signaux intermédiaires pour les intersections.  Par exemple, 5K génère des impulsions de commande A2X et RG, et 5L génère une impulsion de commande WY.  Le diagramme ci-dessous montre comment le signal A2X est généré: l'un des 8 signaux différents (y compris 5K) génère A2X.  Des circuits similaires génèrent d'autres signaux de commande.  Ces optimisations ont permis de réduire la taille du générateur d'intersection, mais celui-ci est toujours resté volumineux et est devenu jusqu'à trois modules. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  En résumé, nous pouvons dire que le module de contrôle est chargé de dire au CPU ce qu'il doit faire pour exécuter l'instruction.  Tout d'abord, les instructions sont divisées en sous-commandes.  Le générateur d'intersection génère les impulsions de contrôle nécessaires pour chaque intervalle de temps et sous-commande, indiquant aux registres, au module arithmétique et à la mémoire ce qu'ils doivent faire. <br><br>  En règle générale, les instructions se composaient de deux sous-commandes, mais il y avait des exceptions.  Certaines instructions, telles que la multiplication ou la division, nécessitaient l'utilisation de nombreuses sous-commandes, car elles comportaient de nombreuses étapes.  À l'inverse, l'instruction de saut à TC utilise une sous-commande, car elle n'a besoin que d'appeler l'instruction suivante. <br><br>  D'autres processeurs ont utilisé différentes approches pour générer des signaux de commande.  6502 et de nombreux autres premiers microprocesseurs ont décodé des instructions à l'aide d'un réseau logique programmable (PLA) qui implémente la logique ET / OU via une mémoire morte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br>  <i>Microprocesseur 6502.</i> <br><br><h2>  Conclusion </h2><br>  Ce fut une visite passionnante de l'ordinateur de commande embarqué Apollo.  Afin de ne pas trop l'étirer, je me suis concentré sur les instructions d'addition ADS et quelques impulsions de contrôle (A2X, RG et WY).  J'espère que vous avez une idée de comment assembler un ordinateur à partir d'éléments aussi primitifs que les vannes NOR. <br><br>  La partie la plus visible de l'architecture est le chemin de données: un module arithmétique, des registres et un bus de données.  Les registres AGC sont basés sur des déclencheurs simples à partir de portes NOR.  Et bien que le module arithmétique AGC ne puisse que faire des ajouts, l'ordinateur peut toujours gérer l'ensemble des opérations, y compris la multiplication, la division et les opérations booléennes. <br><br>  Cependant, le chemin de données n'est qu'une partie de l'ordinateur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les autres composants critiques, il existe un module de contrôle qui indique aux composants ce qu'ils doivent faire. </font><font style="vertical-align: inherit;">L'approche utilisée dans AGC est basée sur un générateur d'intersection qui utilise une logique hautement optimisée et codée en dur pour générer les impulsions de commande correctes pour des sous-commandes et des intervalles de temps spécifiques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grâce à ces capacités, l'AGC a fourni des conseils, une navigation et un contrôle à bord des missions Apollo et a permis d'atterrir sur la lune. </font><font style="vertical-align: inherit;">Il a également stimulé le début de l'industrie des circuits intégrés en utilisant 60% des circuits intégrés fabriqués aux États-Unis en 1963. Par conséquent, les ordinateurs modernes doivent beaucoup à AGC et à ses composants NOR simples. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGC travaille dans un laboratoire connecté à un oscilloscope Tektronix vintage</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472792/">https://habr.com/ru/post/fr472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472776/index.html">Sauvegarde, partie 7: Conclusions</a></li>
<li><a href="../fr472778/index.html">5 façons d'utiliser le Raspberry Pi</a></li>
<li><a href="../fr472780/index.html">Pourquoi éviter les amis ou comment j'ai perdu tous mes avantages</a></li>
<li><a href="../fr472782/index.html">Pourquoi 3D Headache / Part 8 Defocus et l'avenir de la 3D</a></li>
<li><a href="../fr472790/index.html">Antiquités: i-Mate Jasjar, un communicateur pour les entreprises</a></li>
<li><a href="../fr472796/index.html">OUI flanche FAANG * ou [guide pratique] sur la recherche d'emploi aux USA / Europe pour spécialiste informatique</a></li>
<li><a href="../fr472798/index.html">Cartes Yandex pour l'application Taxi</a></li>
<li><a href="../fr472802/index.html">MIRO est une plate-forme de robot intérieure ouverte. Partie 2 - Conception de robots</a></li>
<li><a href="../fr472810/index.html">À l'administrateur système débutant: comment mettre de l'ordre dans le chaos</a></li>
<li><a href="../fr472812/index.html">Le serveur «s'éteint» si le test de fumée du centre de données «prend feu»?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>