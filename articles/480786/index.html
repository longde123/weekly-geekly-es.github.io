<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üç∑ üêÖ Clonaci√≥n profunda independiente de objetos en JavaScript ‚úÇÔ∏è üôã üë®üèø‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En cualquier lenguaje de programaci√≥n, hay tipos de datos que los programadores describen a los sujetos para seguir trabajando y, si es necesario, pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clonaci√≥n profunda independiente de objetos en JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480786/"> En cualquier lenguaje de programaci√≥n, hay tipos de datos que los programadores describen a los sujetos para seguir trabajando y, si es necesario, procesarlos.  JavaScript no es una excepci√≥n; tiene tipos de datos primitivos ( <code>Number</code> , <code>String</code> , <code>Boolean</code> , <code>Symbol</code> , etc.) y de referencia ( <code>Array</code> , <code>Object</code> , <code>Function</code> , <code>Maps</code> , <code>Sets</code> , etc.).  Cabe se√±alar que los tipos de datos primitivos son inmutables: sus valores no pueden modificarse, sino que solo pueden sobrescribirse con un nuevo valor completo, pero con los tipos de datos de referencia sucede lo contrario.  Por ejemplo, declare variables de tipo <code>Number</code> y <code>Object</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> };</code> </pre> <br>  No podemos modificar la variable <code>num</code> , solo podemos reescribir su valor, pero podemos modificar la variable obj: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  Como puede ver, en el primer caso sobrescribimos el valor de la variable, y en el segundo expandimos el objeto.  De esto concluimos que los tipos de datos primitivos no pueden expandirse, y con los tipos de datos de referencia podemos hacer esto, incluso con el modificador <code>const</code> . <br><br>  Este √∫ltimo puede congelarse, por ejemplo, usando <code>Object.freeze(obj)</code> , pero este tema est√° m√°s all√° del alcance del art√≠culo (enlaces para la curiosa <a href="http://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="nofollow">Object.defineProperty</a> , <a href="http://getinstance.info/articles/javascript/javascript-object-protecting/" rel="nofollow">protegiendo el objeto de los cambios</a> ). <br><br>  ¬øC√≥mo se pasan los tipos de datos a las funciones en JavaScript?  Cada programador js probablemente responder√° f√°cilmente esta pregunta, pero, sin embargo, digamos: los tipos de datos primitivos siempre se pasan a una funci√≥n solo por valor, y los referenciados siempre son solo por referencia.  Y aqu√≠ con esto √∫ltimo, en algunas situaciones, surgen problemas. <a name="habracut"></a>  Veamos un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Array: "</span></span>, arr); <span class="hljs-comment"><span class="hljs-comment">// output: Array: [0, 1, 2, 3, 4, 5]</span></span></code> </pre> <br>  En este caso, simplemente declaramos un conjunto de n√∫meros y lo mostramos en la consola.  Ahora lo pasamos a una funci√≥n que devuelve una nueva matriz, pero con la adici√≥n de alg√∫n valor en el segundo argumento, al final de la nueva matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Old array: "</span></span>, arr); <span class="hljs-comment"><span class="hljs-comment">// "Old array: " [0, 1, 2, 3, 4, 5] const newArr = insertValToArr(arr, 15); console.log("New array: ", newArr); // output: "New array: " [0, 1, 2, 3, 4, 5, 15] console.log("Old array: ", arr); // output: "Old array: " [0, 1, 2, 3, 4, 5, 15] function insertValToArr(arr, val) { const newArr = arr; newArr.push(val); return newArr; }</span></span></code> </pre> <br>  Como podemos ver en las conclusiones de la consola, no solo ha cambiado la nueva matriz, sino tambi√©n la antigua.  Esto sucedi√≥ porque en la funci√≥n <code>insertValToArr</code> simplemente asignamos una matriz a otra <code>const newArr = arr</code> , y por lo tanto creamos un enlace a una matriz existente y cuando intentamos modificar una nueva matriz, se refer√≠a al √°rea de memoria de la matriz anterior y, en t√©rminos generales, la cambi√≥.  Y dado que ambas matrices se refieren a la misma √°rea de memoria, tendr√°n el mismo valor.  Cambiemos nuestra funci√≥n para que no pueda cambiar la matriz anterior: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newArr = insertValToArr(arr, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New array: "</span></span>, newArr); <span class="hljs-comment"><span class="hljs-comment">// output: "New array: " [0, 1, 2, 3, 4, 5, 15] console.log("Old array: ", arr); // output: "Old array: " [0, 1, 2, 3, 4, 5] function insertValToArr(arr, val) { const newArr = []; arr.forEach((value, ind) =&gt; { newArr[ind] = value}); newArr.push(val); return newArr; }</span></span></code> </pre> <br>  La matriz anterior no ha cambiado, porque recibimos cada uno de sus elementos y asignamos individualmente los valores del elemento a los elementos de la nueva matriz.  Ahora, este √∫ltimo tiene un √°rea de memoria separada y, si la cambia, esto no afectar√° a la matriz anterior.  Pero todos estos son ejemplos simples y en programas reales, lo m√°s probable es que no solo se encuentren matrices unidimensionales, sino tambi√©n bidimensionales, con menos frecuencia tridimensionales e incluso con menos frecuencia de cuatro dimensiones.  En su mayor√≠a se encuentran en forma de matrices asociativas (tablas hash).  En JavaScript, estos son a menudo objetos. <br><br>  Veamos los m√©todos est√°ndar para copiar objetos que proporciona JavaScript: Object.assign () se usa para copiar los valores de todas sus propiedades enumeradas de uno o m√°s objetos de origen al objeto de destino.  Despu√©s de copiar, devuelve el objeto de destino.  Consid√©ralo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newObj); <span class="hljs-comment"><span class="hljs-comment">// output: { a: 1, b: 2 } console.log(obj); // output: { a: 1, b: 2 }</span></span></code> </pre> <br>  Y de nuevo el viejo problema, nos referimos a la misma √°rea de memoria, lo que lleva a la modificaci√≥n de dos objetos a la vez: cambiar uno cambiar√° al otro.  ¬øQu√© hacer si necesitamos obtener una copia de un objeto complejo (con m√∫ltiples ramificaciones) y, al mismo tiempo, cambiar el objeto, no modificar otro?  Responder a esta pregunta es el prop√≥sito de este art√≠culo.  Adem√°s, consideraremos c√≥mo escribir nuestro propio m√©todo para la clonaci√≥n profunda (copia) de objetos de cualquier rama.  Bajemos al c√≥digo. <br><br>  Paso 1: declare e inicialice el objeto <code>Z</code> , y tambi√©n realice la salida de la consola para compararla antes y despu√©s de la clonaci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Z = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: { <span class="hljs-attr"><span class="hljs-attr">g</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-attr"><span class="hljs-attr">t</span></span>: { <span class="hljs-attr"><span class="hljs-attr">q</span></span>: <span class="hljs-number"><span class="hljs-number">48</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">47</span></span>, <span class="hljs-attr"><span class="hljs-attr">l</span></span>: { <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-number"><span class="hljs-number">85</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>: { <span class="hljs-attr"><span class="hljs-attr">u</span></span>: <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-attr"><span class="hljs-attr">m</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> }, <span class="hljs-attr"><span class="hljs-attr">s</span></span>: <span class="hljs-number"><span class="hljs-number">71</span></span> }, <span class="hljs-attr"><span class="hljs-attr">r</span></span>: { <span class="hljs-attr"><span class="hljs-attr">h</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-attr"><span class="hljs-attr">s</span></span>: <span class="hljs-string"><span class="hljs-string">'test2'</span></span> } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Z object before cloning: '</span></span>, Z);</code> </pre> <br><img src="https://habrastorage.org/webt/wl/dh/ew/wldhews_hywg2ilvk8y6aywpanw.png" alt="imagen"><br><br>  Paso 2: asigne el objeto <code>Z</code> al objeto <code>refToZ</code> para mostrar la diferencia entre la asignaci√≥n normal y la clonaci√≥n profunda: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> refToZ = Z;</code> </pre> <br>  Paso 3: asigne el objeto <code>Z</code> objeto <code>Y</code> utilizando la funci√≥n <code>deepClone</code> y agregue una nueva propiedad al objeto <code>Y</code>  Despu√©s de eso, muestre estos dos objetos en la consola: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Y = deepClone(Z); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deepClone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clObj = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj[i] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>) { clObj[i] = deepClone(obj[i]); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } clObj[i] = obj[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clObj; } Y.addnlProp = { <span class="hljs-attr"><span class="hljs-attr">fd</span></span>: <span class="hljs-number"><span class="hljs-number">45</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Z object after cloning: '</span></span>, Z); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Y object: '</span></span>, Y);</code> </pre> <br><img src="https://habrastorage.org/webt/hu/v5/ah/huv5ah6qrpneldq-jp88clzf5n8.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/1n/2l/jy/1n2ljyz3eprcsjqrvanzj2tarum.png" alt="imagen"><br><br>  En la consola, vemos claramente que al cambiar el objeto <code>Y</code> , al agregar una nueva propiedad, no cambiamos el objeto <code>Z</code> y este √∫ltimo no tendr√° la propiedad <code>addnlProp</code> en su cuerpo. <br><br>  Paso 4: cambie la propiedad <code>x</code> , que est√° en el cuerpo de los objetos <code>Z</code> e <code>Y</code> y vuelva a mostrar ambos objetos en la consola: <br><br><pre> <code class="javascript hljs">Yx = <span class="hljs-number"><span class="hljs-number">76</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Y object: '</span></span>, Y); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Z object: '</span></span>, Z);</code> </pre> <br><img src="https://habrastorage.org/webt/gy/px/tt/gypxttieedelgtlbd3nrmun8wri.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/5u/61/ua/5u61uakr_vahvxd_h0gtsw6azqm.png" alt="imagen"><br><br>  Al cambiar la misma propiedad en el objeto <code>Y</code> , no afectamos la propiedad en el cuerpo <code>Z</code> <br><br>  Paso 5: en el √∫ltimo paso, para comparar, simplemente agregamos la propiedad <code>addToZ</code> con el valor 100 al objeto <code>refToZ</code> y mostramos los tres objetos en la consola: <br><br><pre> <code class="javascript hljs">refToZ.addToZ = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'refToZ object: '</span></span>, refToZ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Z object: '</span></span>, Z); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Y object: '</span></span>, Y);</code> </pre> <br><img src="https://habrastorage.org/webt/yx/8g/ja/yx8gjasdzuuc-wahz2zh-vfqcgk.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/gu/cl/cn/guclcn6embjyjxetzr_7onnscfe.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/9c/cy/bm/9ccybmgd_w0bm5wikjlj-glll8i.png" alt="imagen"><br><br>  Al cambiar el objeto <code>refToZ</code> tambi√©n cambiamos <code>Z</code> , pero <code>Y</code> no se vio afectado.  A partir de esto, concluimos que nuestra funci√≥n crea un nuevo objeto independiente con propiedades y sus valores a partir de un objeto existente (el c√≥digo para implementar la funci√≥n <code>deepClone</code> se puede encontrar en <a href="https://codepen.io/Magam9/pen/vYEXMJX" rel="nofollow">CodePen</a> ). <br><br>  Deteng√°monos en la implementaci√≥n de esta funci√≥n.  Este √∫ltimo encuentra cualquier anidamiento del objeto, sin siquiera saberlo.  ¬øC√≥mo hace ella esto?  El caso es que en este caso usamos el conocido algoritmo para gr√°ficos: b√∫squeda en profundidad.  Un objeto es un gr√°fico que tiene una o varias ramas, que a su vez pueden tener sus ramas, etc.  Para que podamos encontrar todo, necesitamos ir a cada rama y avanzar en su profundidad, por lo que encontraremos cada nodo en el gr√°fico y obtendremos sus valores.  La b√∫squeda profunda se puede implementar de 2 maneras: recursividad y usando un bucle.  El segundo puede resultar m√°s r√°pido, ya que no llenar√° la pila de llamadas, lo que a su vez hace la recursividad.  En nuestra implementaci√≥n de la funci√≥n <code>deepClone</code> utilizamos una combinaci√≥n de recursi√≥n con un bucle.  Si desea leer libros sobre algoritmos, le aconsejo que inicie los "algoritmos Grokayem" de Aditya Bhargava o un "Algoritmo: construcci√≥n y an√°lisis" m√°s profundo de Thomas Kormen. <br><br>  Para resumir, recordamos los tipos de datos en JavaScript y c√≥mo se pasan a las funciones.  Observamos un ejemplo simple de clonaci√≥n independiente de una matriz unidimensional simple.  Consideramos una de las implementaciones de lenguaje est√°ndar para copiar objetos y como resultado escribimos una funci√≥n peque√±a (en tama√±o) para la clonaci√≥n profunda independiente de objetos complejos.  Una funci√≥n similar puede encontrar su aplicaci√≥n tanto en el lado del servidor (Nodo js), que es m√°s probable, como en el cliente.  Espero que este art√≠culo te haya sido √∫til.  Nos vemos de nuevo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480786/">https://habr.com/ru/post/480786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480762/index.html">V&V no significa venganza</a></li>
<li><a href="../480774/index.html">No nginx unificado: Ayhor hosting - dash-scratch live</a></li>
<li><a href="../480776/index.html">Implementamos Active Directory por todos los m√©todos posibles.</a></li>
<li><a href="../480778/index.html">Gesti√≥n de gestos: manejo de superposiciones visuales. Parte 2</a></li>
<li><a href="../480782/index.html">5 cosas que me gustar√≠a saber cuando comenc√© a usar Angular</a></li>
<li><a href="../480788/index.html">√Årbol de navidad en la l√≠nea de comando</a></li>
<li><a href="../480790/index.html">"Eficiencia de f√°brica". Encontrar un cuello de botella e implementar un sistema de extracci√≥n para aumentar la productividad</a></li>
<li><a href="../480792/index.html">Ingenier√≠a de regalos</a></li>
<li><a href="../480794/index.html">Un poco sobre el caso especial de la implementaci√≥n de algoritmos de b√∫squeda de puertas abiertas</a></li>
<li><a href="../480796/index.html">Programadores de Schrodinger, devops y gatos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>