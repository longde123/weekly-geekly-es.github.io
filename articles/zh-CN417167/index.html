<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥀 🚣🏿 🕟 在现实世界中启动LDA。 详细指南 👷 🤜🏿 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 


 Internet上有很多教程，它们解释了LDA的工作原理（潜在的狄利克雷分配）以及如何将其付诸实践。 LDA训练的示例通常在sklearn可用的“示例性”数据集（例如“ 20个新闻组数据集”）上进行演示。 


 在“示例性”数据集示例上进行训练的一个特征是，那里的数据总是有序且方便地...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在现实世界中启动LDA。 详细指南</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417167/"><h2 id="predislovie"> 前言 </h2><br><p>  Internet上有很多教程，它们解释了LDA的工作原理（潜在的狄利克雷分配）以及如何将其付诸实践。  LDA训练的示例通常在sklearn可用的“示例性”数据集（例如“ 20个新闻组数据集”）上进行演示。 </p><br><p> 在“示例性”数据集示例上进行训练的一个特征是，那里的数据总是有序且方便地堆叠在一个地方。 在训练生产模型时，直接从真实来源获得的数据通常是相反的： </p><br><ul><li> 大量排放。 </li><li> 标记不正确（如果有）。 </li><li> 非常严重的类不平衡和任何数据集参数的难看分布。 </li><li> 对于文本，这些是：语法错误，大量稀有和独特的单词，多语言。 </li><li> 一种不方便的数据存储方式（不同或稀有格式，需要解析） </li></ul><br><p> 从历史上看，我尝试从尽可能接近实际生产现实的示例中学习，因为通过这种方式，人们可以最充分地感知特定类型任务的问题领域。  LDA也是如此，在本文中，我想分享我的经验-如何在完全原始的数据上从头运行LDA。 本文的某些部分将专门获取这些数据，因此该示例将成为完整的“工程案例”。 </p><a name="habracut"></a><br><h2 id="topic-modeling-i-lda"> 主题建模和LDA。 </h2><br><p> 首先，请考虑LDA的一般功能以及使用的任务。 <br>  LDA通常用于主题建模任务。 这样的任务意味着对文本进行聚类或分类的任务-以每个类或聚类包含具有相似主题的文本的方式。 </p><br><p> 为了将LDA应用于文本数据集（以下称为文本主体），有​​必要将主体转换为术语文档矩阵。 </p><br><p> 术语文档矩阵是具有大小的矩阵 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mtext mathcolor=&quot;red&quot;>\&amp;#x4E58;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4EE5;</mo></mrow><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.517ex" height="2.66ex" viewBox="0 -832 4097.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-4E" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(888,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2218,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-57" x="3048" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi><mtext mathcolor="red">\乘</mtext><mrow class="MJX-TeXAtom-ORD"><mo>以</mo></mrow><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> N \乘以W </script> 在哪里 <br>  N是案件的文件数，W是案件字典的大小，即 在我们的语料库中找到的单词（唯一）的数量。 在第i行中，矩阵的第j列是一个数字-第i个单词在第i个文本中找到了多少次。 </p><br><p> 对于给定的术语文档矩阵和预定数量的主题的T，LDA构造两个分布： </p><br><ol><li> 课文中主题的分布。（实际上，由大小矩阵给出 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mtext mathcolor=&quot;red&quot;>\&amp;#x4E58;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4EE5;</mo></mrow><mi>T</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.718ex" height="2.66ex" viewBox="0 -832 3753.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-4E" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(888,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2218,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-54" x="3048" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi><mtext mathcolor="red">\乘</mtext><mrow class="MJX-TeXAtom-ORD"><mo>以</mo></mrow><mi>T</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> N \乘以T </script>  ） </li><li> 按主题分布的单词（大小矩阵） <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi><mtext mathcolor=&quot;red&quot;>\&amp;#x4E58;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4EE5;</mo></mrow><mi>W</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.089ex" height="2.66ex" viewBox="0 -832 3913.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-54" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(704,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2034,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-57" x="2864" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mtext mathcolor="red">\乘</mtext><mrow class="MJX-TeXAtom-ORD"><mo>以</mo></mrow><mi>W</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> T \乘以W </script>  ） </li></ol><br><p> 这些矩阵的像元值分别是此主题包含在本文档中的概率（或主题在文档中所占的比例，如果我们将文档视为不同主题的混合）则表示矩阵``主题在文本中的分布''。 </p><br><p> 对于矩阵“按主题分布单词”，其值是与主题i在文本中满足单词j的概率，定性地，我们可以将这些数字视为表征该单词在该主题中的典型特征的系数。 </p><br><p> 应该说主题一词不是这个词的“日常”定义。  LDA将T分配给这些主题，但是这些主题是什么样的主题以及它们是否与文本的任何知名主题相对应，例如：“体育”，“科学”，“政治”-尚不清楚。 在这种情况下，将主题作为一种抽象实体来讨论是更合适的，如果您可以将其想象成单词的特征集的集合，并且满足相应的概率，则该抽象实体由主题在单词分布矩阵中的一条线定义，并且与该文本相对应。 （从表格中）以一组特定的文本表示。 </p><br><p> 如果您有兴趣更详细地研究“公式化” LDA的方式和工作方式，请参考以下材料（作者使用）： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用英语举例说明</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语详细信息</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于Python实现</a> </li></ul><br><h2 id="dobyvaem-dikie-dannye"> 我们得到了疯狂的数据 </h2><br><p> 对于我们的“实验室工作”，我们需要一个具有自身缺陷和功能的自定义数据集。 您可以在不同的地方获得它：从Kinopoisk，Wikipedia文章，一些新闻门户网站的新闻下载评论，我们将采取一种更为极端的选择-VKontakte社区的帖子。 </p><br><p> 我们将这样做： </p><br><ol><li> 我们选择一些VK用户。 </li><li> 我们得到了他所有朋友的名单。 </li><li> 对于每个朋友，我们将带走他的整个社区。 </li><li> 对于每个朋友的每个社区，我们抽出前n（n = 100）个社区帖子，并将它们合并为一个社区文本内容。 </li></ol><br><h4 id="instrumenty-i-stati"> 工具和文章 </h4><br><p> 要下载帖子，我们将使用vk模块与VKontakte API（适用于Python）一起使用。 使用VKontakte API编写应用程序时，最复杂的时刻之一就是授权，幸运的是，执行此工作的代码已经编写并且在公共领域，除了vk，我使用了一个小的授权模块-vkauth。 </p><br><p> 链接到用于研究VKontakte API的模块和文章： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vkauth</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vkauth教程</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vk教程</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vk教程编号2</a> </li><li>  Vkontakte API官方文档 </li></ul><br><h4 id="pishem-kod"> 编写代码 </h4><br><p> 因此，使用vkauth登录： </p><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#authorization of app using modules imported. app_id = '6203169' perms = ['photos','friends','groups'] API_ver = '5.68' Auth = VKAuth(perms, app_id, API_ver) Auth.auth() token = Auth.get_token() user_id = Auth.get_user_id() #starting session session = vk.Session(access_token=token) api = vk.API(session)</span></span></code> </pre> <br><p> 在此过程中，编写了一个小模块，其中包含以适当格式下载内容所必需的所有功能，下面列出了这些功能，让我们对其进行遍历： </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_friends_ids</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api, user_id)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' For a given API object and user_id returns a list of all his friends ids. '''</span></span> friends = api.friends.get(user_id=user_id, v = <span class="hljs-string"><span class="hljs-string">'5.68'</span></span>) friends_ids = friends[<span class="hljs-string"><span class="hljs-string">'items'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> friends_ids <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_user_groups</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api, user_id, moder=True, only_open=True)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' For a given API user_id returns list of all groups he subscribed to. Flag model to get only those groups where user is a moderator or an admin) Flag only_open to get only public(open) groups. '''</span></span> kwargs = {<span class="hljs-string"><span class="hljs-string">'user_id'</span></span> : user_id, <span class="hljs-string"><span class="hljs-string">'v'</span></span> : <span class="hljs-string"><span class="hljs-string">'5.68'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> moder == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: kwargs[<span class="hljs-string"><span class="hljs-string">'filter'</span></span>] = <span class="hljs-string"><span class="hljs-string">'moder'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> only_open == <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: kwargs[<span class="hljs-string"><span class="hljs-string">'extended'</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> kwargs[<span class="hljs-string"><span class="hljs-string">'fields'</span></span>] = [<span class="hljs-string"><span class="hljs-string">'is_closed'</span></span>] groups = api.groups.get(**kwargs) groups_refined = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> group <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> groups[<span class="hljs-string"><span class="hljs-string">'items'</span></span>]: cond_check = (only_open <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> group[<span class="hljs-string"><span class="hljs-string">'is_closed'</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> only_open <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cond_check: refined = {} refined[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] = group[<span class="hljs-string"><span class="hljs-string">'id'</span></span>] * (<span class="hljs-number"><span class="hljs-number">-1</span></span>) refined[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = group[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] groups_refined.append(refined) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> groups_refined <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_n_posts_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(api, group_id, n_posts=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">50</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' For a given api and group_id returns first n_posts concatenated as one text. '''</span></span> wall_contents = api.wall.get(owner_id = group_id, count=n_posts, v = <span class="hljs-string"><span class="hljs-string">'5.68'</span></span>) wall_contents = wall_contents[<span class="hljs-string"><span class="hljs-string">'items'</span></span>] text = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> post <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> wall_contents: text += post[<span class="hljs-string"><span class="hljs-string">'text'</span></span>] + <span class="hljs-string"><span class="hljs-string">' '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text</code> </pre> <br><p> 最终的管道如下： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#id of user whose friends you gonna get, like: https://vk.com/id111111111 user_id = 111111111 friends_ids = vt.get_friends_ids(api, user_id) #collecting all groups groups = [] for i,friend in tqdm(enumerate(friends_ids)): if i % 3 == 0: sleep(1) friend_groups = vt.get_user_groups(api, friend, moder=False) groups += friend_groups #converting groups to dataFrame groups_df = pd.DataFrame(groups) groups_df.drop_duplicates(inplace=True) #reading content(content == first 100 posts) for i,group in tqdm(groups_df.iterrows()): name = group['name'] group_id = group['id'] #Different kinds of fails occures during scrapping #For examples there are names of groups with slashes #Like: 'The Kaaats / Indie-rock' try: content = vt.get_n_posts_text(api, group_id, n_posts=100) dst_path = join(data_path, name + '.txt') with open(dst_path, 'w+t') as f: f.write(content) except Exception as e: print('Error occured on group:', name) print(e) continue #need it because of requests limitaion in VK API. if i % 3 == 0: sleep(1)</span></span></code> </pre> <br><h4 id="fails"> 失败 </h4><br><p> 通常，下载数据本身并不困难；您应该仅注意两点： </p><br><ol><li> 有时，由于某些社区的隐私，您将收到访问错误，有时，除非在正确的位置，否则通过安装try可以解决其他错误。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VK</a>对每秒的请求数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有限制</a> 。 </li></ol><br><p> 当发出大量请求时（例如在循环中），我们还将捕获错误。 此问题可以通过几种方式解决： </p><br><ol><li> 愚蠢而直率：每3个请求就坚持睡眠（一些）。 它在一行中完成，并且在数据量不大且没有时间使用更复杂的方法的情况下，极大地降低了卸载速度-这是完全可以接受的（在本文中实现） </li><li> 了解Long Poll请求的工作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://vk.com/dev/using_longpoll</a> </li></ol><br><p> 在本文中，选择了一种简单而缓慢的方法，将来，我可能会写一篇微型文章，介绍绕过或缓解每秒请求数限制的方法。 </p><br><h4 id="itog"> 总结 </h4><br><p> 最初的“一些”用户拥有约150个朋友，他们设法获得了4,679条文本-每个文本都代表了某个VK社区。 这些文本的大小相差很大，并且以多种语言编写-其中一些不适合我们的目的，但是我们将进一步讨论。 </p><br><h3 id="osnovnaya-chast"> 主体 </h3><br><p><img src="https://habrastorage.org/webt/bj/to/hm/bjtohmsrvsxlcbs78u0thlawxky.png" alt="图片"></p><br><p> 让我们仔细研究一下管道的所有部分-首先是强制性的（理想），然后是其余的-它们才是最大的利益。 </p><br><h4 id="countvectorizer">  Countvectorizer </h4><br><p> 在教授LDA之前，我们需要以术语文档矩阵的形式展示文档。 通常包括以下操作： </p><br><ul><li> 删除推论/数字/不必要的标记。 </li><li> 标记化（表示为单词列表） </li><li> 数词，编制热文档矩阵。 </li></ul><br><p>  sklearn中的所有这些动作都可以在一个程序实体sklearn.feature_extraction.text.CountVectorizer的框架内方便地实现。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档链接</a> </p><br><p> 您需要做的只是： </p><br><pre> <code class="python hljs">count_vect = CountVectorizer(input=<span class="hljs-string"><span class="hljs-string">'filename'</span></span>, stop_words=stopwords, vocabulary=voc) dataset = count_vect.fit_transform(train_names)</code> </pre> <br><h4 id="lda">  Lda </h4><br><p> 与CountVectorizer相似，LDA可以在Sklearn和其他框架中完美实现，因此，在我们的纯粹实用文章中，将大量空间直接用于其实现没有太多意义。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档链接</a> </p><br><p> 启动LDA所需要做的就是： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#training LDA lda = LDA(n_components = 60, max_iter=30, n_jobs=6, learning_method='batch', verbose=1) lda.fit(dataset)</span></span></code> </pre> <br><h4 id="preprocessing"> 前处理 </h4><br><p> 如果我们在下载文本后立即使用文本，并使用CountVectorizer将它们转换为Term文档矩阵，并使用内置的默认标记生成器，则将获得大小为4679x769801的矩阵（基于我使用的数据）。 </p><br><p> 我们字典的大小将为769801。即使我们假设大多数单词都具有参考价值，我们仍然不太可能获得良好的LDA，我们会找到类似“尺寸曲线”的内容，更不用说对于几乎所有计算机，我们只会阻塞所有RAM。 实际上，这些词中的大多数都是完全无用的。 其中绝大多数是： </p><br><ul><li> 表情符号，字符，数字。 </li><li> 独特或非常稀有的单词（例如，带有波兰语模因的一组单词中的波兰语单词，拼写错误或使用“阿尔巴尼亚语”的单词）。 </li><li> 语音中非常频繁的部分（例如介词和代词）。 </li></ul><br><p> 此外，VK中的许多小组专门研究图像-那里几乎没有文字帖子-与它们相对应的文字是简并的，在Thermal文档矩阵中，它们几乎给我们零线。 </p><br><p> 因此，让我们整理一下吧！ <br> 我们将所有文本标记化，从中删除标点符号和数字，然后根据单词数查看文本分布的直方图： <br><img src="https://habrastorage.org/webt/v4/qh/w0/v4qhw0mrgpizranmnptbz5lnivk.png" alt="图片"></p><br><p> 我们删除了所有少于100个字的文本（其中有525个） </p><br><p> 现在的字典： <br> 在我们的任务框架中删除所有不是字母的标记（单词）-这是完全可以接受的。  CountVectorizer可以自己执行此操作，即使不是，也可以这样做，那么我认为无需在此处给出示例（它们在本文代码的完整版本中）。 </p><br><p> 减少字典大小的最常见过程之一是删除所谓的停用词（停用词），停用词是没有语义负荷和/或没有主题色彩的词（在我们的示例中为主题建模）。 在我们的案例中，这些词例如是： </p><br><ul><li> 代词和介词。 </li><li> 文章-a。 </li><li> 常用词：“ be”，“ good”，“ probably”等。 </li></ul><br><p>  nltk模块已经形成了俄语和英语停用词列表，但它们的作用很弱。 在Internet上，您还可以找到任何语言的停用词列表，并将其添加到nltk中。 所以我们会做。 从此处获取其他停用词： </p><br><ul><li>  <a href="">https://github.com/stopwords-iso/stopwords-ru/blob/master/stopwords-ru.json</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://gist.github.com/menzenski/7047705</a> </li></ul><br><p> 在实践中，当解决特定问题时，停用词列表会随着模型的训练而逐渐调整和补充，因为对于每个特定的数据集和问题，都有特定的“不一致”词。 在训练了第一代LDA之后，我们还将挑选自定义停用词。 </p><br><p>  CountVectorizer内置了删除停用词的过程-我们只需要它们的列表即可。 </p><br><p> 我们做的够了吗？ </p><br><p><img src="https://habrastorage.org/webt/ja/xd/6l/jaxd6lnbbnd_dmmmk6nog9a2ntm.png" alt="图片"></p><br><p> 我们词典中的大多数单词对于学习LDA而言仍然不太有用，并且不在停用词列表中。 因此，我们对数据应用了另一种过滤方法。 </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>i</mi><mi>d</mi><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF0C;</mo></mrow><mi>D</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>D</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mspace linebreak=&quot;newline&quot; /><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>d</mi><mtext>&amp;#xA0;</mtext><mi>i</mi><mi>n</mi><mi>D</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF1A;</mo></mrow><mi>t</mi><mtext>&amp;#xA0;</mtext><mi>i</mi><mi>n</mi><mi>d</mi><mspace linebreak=&quot;newline&quot; /></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="40.148ex" height="8.202ex" viewBox="0 -832 17286 3531.4" role="img" focusable="false" style="vertical-align: -6.27ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-69" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-64" x="345" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-66" x="869" y="0"></use><g transform="translate(1419,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-74" x="2249" y="0"></use><g transform="translate(2610,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-44" x="3440" y="0"></use><g transform="translate(4269,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-3D" x="5377" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-6C" x="6683" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-6F" x="6982" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-67" x="7467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-66" x="8198" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-72" x="8748" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-61" x="9200" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-63" x="9729" y="0"></use><g transform="translate(10163,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-7C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-44" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-7C" x="1107" y="0"></use></g><g transform="translate(11548,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-7C" x="0" y="0"></use><g transform="translate(0,-1432)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-64" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-69" x="773" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-6E" x="1119" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-44" x="1719" y="0"></use><g transform="translate(2548,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">：</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-74" x="3377" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-69" x="3989" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-6E" x="4334" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMATHI-64" x="4935" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/417167/&amp;usg=ALkJrhgEhUd19OHF_Ra59pTp7oijoVO58A#MJMAIN-7C" x="5458" y="0"></use></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>i</mi><mi>d</mi><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mo>，</mo></mrow><mi>D</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mo>=</mo><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>D</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></mrow><mrow class="MJX-TeXAtom-ORD"><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mspace linebreak="newline"></mspace><mrow class="MJX-TeXAtom-ORD"><mi>d</mi><mtext>&nbsp;</mtext><mi>i</mi><mi>n</mi><mi>D</mi><mrow class="MJX-TeXAtom-ORD"><mo>：</mo></mrow><mi>t</mi><mtext>&nbsp;</mtext><mi>i</mi><mi>n</mi><mi>d</mi><mspace linebreak="newline"></mspace></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> idf（t，D）= \ log \ frac {| D |} {| \\ {d \ in D：t \ in d \\} |} </script></p><br><p> 在哪里 <br>  t是字典中的一个单词。 <br>  D-案例（许多文本） <br>  d是正文之一。 <br> 我们计算所有单词的IDF，并切掉IDF最大（非常少见）和最小（扩展单词）的单词。 </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#'training' (tf-)idf vectorizer. tf_idf = TfidfVectorizer(input='filename', stop_words=stopwords, smooth_idf=False ) tf_idf.fit(train_names) #getting idfs idfs = tf_idf.idf_ #sorting out too rare and too common words lower_thresh = 3. upper_thresh = 6. not_often = idfs &gt; lower_thresh not_rare = idfs &lt; upper_thresh mask = not_often * not_rare good_words = np.array(tf_idf.get_feature_names())[mask] #deleting punctuation as well. cleaned = [] for word in good_words: word = re.sub("^(\d+\w*$|_+)", "", word) if len(word) == 0: continue cleaned.append(word)</span></span></code> </pre> <br><p> 通过上述步骤获得的结果已经非常适合LDA训练，但是我们将做更多的工作-在我们的数据集中经常会找到相同的单词，但是情况有所不同。 为了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阻止，使用pymystem3</a> 。 </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Stemming m = Mystem() stemmed = set() voc_len = len(cleaned) for i in tqdm(range(voc_len)): word = cleaned.pop() stemmed_word = m.lemmatize(word)[0] stemmed.add(stemmed_word) stemmed = list(stemmed) print('After stemming: %d'%(len(stemmed)))</span></span></code> </pre> <br><p> 应用上述过滤后，字典大小从769801减小为 <br>  13611，并且已经有了此类数据，您可以获得具有可接受质量的LDA模型。 </p><br><h3 id="testirovanie-primenenie-i-tyuning-lda"> 测试，应用和调整LDA </h3><br><p> 现在我们有了在处理后的数据集上训练的数据集，预处理和模型，现在很好地检查我们的模型是否适当，以及为它们构建一些应用程序。 </p><br><p> 作为应用程序，对于初学者来说，请考虑为给定文本生成关键字的任务。 您可以按照以下非常简单的方式执行此操作： </p><br><ol><li> 我们从LDA获得了本文主题的分布。 </li><li> 选择n个（例如n = 2）最明显的主题。 </li><li> 对于每个主题，选择m个（例如m = 3）最具特征的单词。 </li><li> 我们有一组n * m个单词来描述给定的文本。 </li></ol><br><p> 我们将编写一个简单的接口类，它将实现此生成关键字的方法： </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Let\`s do simple interface class class TopicModeler(object): ''' Inteface object for CountVectorizer + LDA simple usage. ''' def __init__(self, count_vect, lda): ''' Args: count_vect - CountVectorizer object from sklearn. lda - LDA object from sklearn. ''' self.lda = lda self.count_vect = count_vect self.count_vect.input = 'content' def __call__(self, text): ''' Gives topics distribution for a given text Args: text - raw text via python string. returns: numpy array - topics distribution for a given text. ''' vectorized = self.count_vect.transform([text]) lda_topics = self.lda.transform(vectorized) return lda_topics def get_keywords(self, text, n_topics=3, n_keywords=5): ''' For a given text gives n top keywords for each of m top texts topics. Args: text - raw text via python string. n_topics - int how many top topics to use. n_keywords - how many top words of each topic to return. returns: list - of m*n keywords for a given text. ''' lda_topics = self(text) lda_topics = np.squeeze(lda_topics, axis=0) n_topics_indices = lda_topics.argsort()[-n_topics:][::-1] top_topics_words_dists = [] for i in n_topics_indices: top_topics_words_dists.append(self.lda.components_[i]) shape=(n_keywords*n_topics, self.lda.components_.shape[1]) keywords = np.zeros(shape=shape) for i,topic in enumerate(top_topics_words_dists): n_keywords_indices = topic.argsort()[-n_keywords:][::-1] for k,j in enumerate(n_keywords_indices): keywords[i * n_keywords + k, j] = 1 keywords = self.count_vect.inverse_transform(keywords) keywords = [keyword[0] for keyword in keywords] return keywords</span></span></code> </pre> <br><p> 我们将我们的方法应用于几个文本，看看会发生什么： <br> 社区<strong>：</strong>旅行社“世界的色彩” <br>  <strong>关键字：</strong> [“照片”，“社交”，“旅行”，“社区”，“旅行”，“欧元”，“住宿”，“价格”，“波兰”，“出发”] <br>  <strong>社区：</strong>食物的礼物 <br>  <strong>关键字：</strong> [“黄油”，“ st”，“盐”，“ pc”，“面团”，“烹饪”，“洋葱”，“辣椒”，“糖”，“ gr”] </p><br><p> 上面的结果不是“樱桃精选”，看起来很合适。 实际上，这些是来自已配置模型的结果。 在您经常看到的关键字中，本文中训练的第一批LDA产生了明显较差的结果，例如： </p><br><ol><li> 网址的复合组成部分：www，http，ru，com ... </li><li> 常用词。 </li><li> 单位：厘米，米，公里... </li></ol><br><p> 模型的调整（调整）如下： </p><br><ol><li> 对于每个主题，请选择n（n = 5）个最具特征的单词。 </li><li> 根据培训案例，我们将它们视为idf。 </li><li> 我们引入了最广泛的关键字的5-10％。 </li></ol><br><p> 应该仔细地进行这种“清理”，并预先查看这10％的单词。 相反，应该以这种方式选择要删除的候选词，然后应该从中手动选择要删除的单词。 </p><br><p> 在2-3代模型中的某个地方，采用类似的选择停用词的方式，对于广泛使用的最高关键字分布的前5％，我们得到： <br>  [“任何”，“完全”，“正确”，“简单”，“下一个”，“互联网”，“小”，“方式”，“困难”，“心情”，“太多”，“设置”，“选项'，'名称'，'演讲'，'节目'，'比赛'，'音乐'，'目标'，'电影'，'价格'，'游戏'，'系统'，'播放'，'公司' ，'nice'] </p><br><h3 id="esche-prilozheniya"> 更多应用 </h3><br><p> 我首先想到的第一件事是使用文本中主题的分布作为文本的“嵌入”，在这种解释中，您可以对它们应用可视化或聚类算法，并以此方式寻找最终的“有效”主题聚类。 </p><br><p> 让我们这样做： </p><br><pre> <code class="python hljs">term_doc_matrix = count_vect.transform(names) embeddings = lda.transform(term_doc_matrix) kmeans = KMeans(n_clusters=<span class="hljs-number"><span class="hljs-number">30</span></span>) clust_labels = kmeans.fit_predict(embeddings) clust_centers = kmeans.cluster_centers_ embeddings_to_tsne = np.concatenate((embeddings,clust_centers), axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) tSNE = TSNE(n_components=<span class="hljs-number"><span class="hljs-number">2</span></span>, perplexity=<span class="hljs-number"><span class="hljs-number">15</span></span>) tsne_embeddings = tSNE.fit_transform(embeddings_to_tsne) tsne_embeddings, centroids_embeddings = np.split(tsne_embeddings, [len(clust_labels)], axis=<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p> 在输出中，我们得到以下图像： <br><img src="https://habrastorage.org/webt/7j/2r/qv/7j2rqvpp2-blr9vfq44qjs75upc.png" alt="图片"></p><br><p> 十字是群集的重心（质心）。 </p><br><p> 在嵌入的tSNE图像中，可以看出，使用KMeans选择的聚类形成了非常连通的且最常在空间上可分离的集合。 </p><br><p> 其他一切，由您决定。 </p><br><p> 链接到所有代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//gitlab.com/Mozes/VK_LDA</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417167/">https://habr.com/ru/post/zh-CN417167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417155/index.html">Linux内核4.18：为即将发布的版本做些什么</a></li>
<li><a href="../zh-CN417157/index.html">奇异性正在逼近：人工智能开始控制机器人</a></li>
<li><a href="../zh-CN417161/index.html">汉堡王：秘密监视，谎言，盗窃银行卡。 延续性</a></li>
<li><a href="../zh-CN417163/index.html">精细提交</a></li>
<li><a href="../zh-CN417165/index.html">是什么威胁了汉堡王</a></li>
<li><a href="../zh-CN417171/index.html">研究：由女性管理的对冲基金表现更好</a></li>
<li><a href="../zh-CN417173/index.html">“旧新乙烯基”：有关转盘和唱片的历史和生产的20种材料</a></li>
<li><a href="../zh-CN417175/index.html">二十世纪上半叶的Acme道路信号灯修复</a></li>
<li><a href="../zh-CN417177/index.html">Linux下的本地Web服务器，具有自动主机生成和PHP版本切换功能</a></li>
<li><a href="../zh-CN417179/index.html">设置家庭开发环境（docker + gitlab + DNS）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>