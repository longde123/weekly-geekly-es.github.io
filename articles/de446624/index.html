<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèæ üë± üåÅ Indizes in PostgreSQL - 6 (SP-GiST) üë∂üèΩ üò≥ üôè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits die PostgreSQL- Indizierungs-Engine , die Schnittstelle der Zugriffsmethoden und drei Methoden besprochen: Hash-Index , B-Tree und G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Wir haben bereits die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizierungs-Engine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Schnittstelle der Zugriffsmethoden</a> und drei Methoden besprochen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Index</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> .  In diesem Artikel beschreiben wir SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Zun√§chst ein paar Worte zu diesem Namen.  Der Teil "GiST" spielt auf eine gewisse √Ñhnlichkeit mit der gleichnamigen Zugriffsmethode an.  Die √Ñhnlichkeit besteht: Beide sind verallgemeinerte Suchb√§ume, die einen Rahmen f√ºr die Erstellung verschiedener Zugriffsmethoden bieten. <br><br>  "SP" steht f√ºr Space Partitioning.  Der Raum hier ist oft genau das, was wir als Raum bezeichnen, zum Beispiel eine zweidimensionale Ebene.  Aber wir werden sehen, dass jeder Suchraum gemeint ist, dh tats√§chlich jede Wertdom√§ne. <br><br>  SP-GiST eignet sich f√ºr Strukturen, bei denen der Raum rekursiv in <em>nicht schneidende</em> Bereiche aufgeteilt werden kann.  Diese Klasse umfasst Quadtrees, k-dimensionale B√§ume (kD-B√§ume) und Radix-B√§ume. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Die Idee der SP-GiST-Zugriffsmethode besteht also darin, die Wertdom√§ne in <em>nicht √ºberlappende</em> Subdom√§nen aufzuteilen, von denen jede wiederum auch aufgeteilt werden kann.  Eine solche Partitionierung f√ºhrt zu <em>nicht ausgeglichenen</em> B√§umen (im Gegensatz zu B-B√§umen und regul√§ren GiST). <br><br>  Die Eigenschaft, sich nicht zu √ºberschneiden, vereinfacht die Entscheidungsfindung beim Einf√ºgen und Suchen.  Andererseits sind die induzierten B√§ume in der Regel schwach verzweigt.  Beispielsweise hat ein Knoten eines Quadtree normalerweise vier untergeordnete Knoten (im Gegensatz zu B-B√§umen, bei denen die Knoten Hunderte betragen) und eine gr√∂√üere Tiefe.  B√§ume wie diese passen gut zur Arbeit im RAM, aber der Index wird auf einer Festplatte gespeichert. Um die Anzahl der E / A-Vorg√§nge zu verringern, m√ºssen Knoten in Seiten gepackt werden, und dies ist nicht einfach effizient durchzuf√ºhren.  Au√üerdem kann die Zeit, die ben√∂tigt wird, um verschiedene Werte im Index zu finden, aufgrund von Unterschieden in den Verzweigungstiefen variieren. <br><br>  Diese Zugriffsmethode √ºbernimmt wie GiST Aufgaben auf niedriger Ebene (gleichzeitiger Zugriff und Sperren, Protokollierung und ein reiner Suchalgorithmus) und bietet eine spezielle vereinfachte Schnittstelle, um die Unterst√ºtzung neuer Datentypen und neuer Partitionierungsalgorithmen zu erm√∂glichen. <br><br>  Ein interner Knoten des SP-GiST-Baums speichert Verweise auf untergeordnete Knoten.  F√ºr jede Referenz kann ein <em>Etikett</em> definiert werden.  Au√üerdem kann ein interner Knoten einen Wert speichern, der als <em>Pr√§fix bezeichnet wird</em> .  Tats√§chlich ist dieser Wert kein obligatorisches Pr√§fix;  Es kann als beliebiges Pr√§dikat betrachtet werden, das f√ºr alle untergeordneten Knoten erf√ºllt ist. <br><br>  Blattknoten von SP-GiST enthalten einen Wert vom indizierten Typ und einen Verweis auf eine Tabellenzeile (TID).  Die indizierten Daten selbst (Suchschl√ºssel) k√∂nnen als Wert verwendet werden, sind jedoch nicht obligatorisch: Ein verk√ºrzter Wert kann gespeichert werden. <br><br>  Dar√ºber hinaus k√∂nnen Blattknoten in Listen gruppiert werden.  Ein interner Knoten kann also nicht nur auf einen Wert verweisen, sondern auf eine ganze Liste. <br><br>  Beachten Sie, dass Pr√§fixe, Beschriftungen und Werte in Blattknoten unabh√§ngig voneinander ihre eigenen Datentypen haben. <br><br>  Wie in GiST ist <em>die Konsistenzfunktion</em> die Hauptfunktion, die f√ºr die Suche definiert <em>werden muss</em> .  Diese Funktion wird f√ºr einen Baumknoten aufgerufen und gibt eine Reihe von untergeordneten Knoten zur√ºck, deren Werte mit dem Suchpr√§dikat "√ºbereinstimmen" (wie √ºblich in der Form " <em>Operatorausdruck f√ºr indizierte Felder</em> ").  F√ºr einen Blattknoten bestimmt die Konsistenzfunktion, ob der indizierte Wert in diesem Knoten dem Suchpr√§dikat entspricht. <br><br>  Die Suche beginnt mit dem Wurzelknoten.  Mit der Konsistenzfunktion k√∂nnen Sie herausfinden, welche untergeordneten Knoten ein Besuch sinnvoll ist.  Der Algorithmus wiederholt sich f√ºr jeden der gefundenen Knoten.  Die Suche steht an erster Stelle. <br><br>  Auf der physischen Ebene werden Indexknoten in Seiten gepackt, um die Arbeit mit den Knoten unter dem Gesichtspunkt von E / A-Operationen effizient zu gestalten.  Beachten Sie, dass eine Seite entweder interne oder Blattknoten enthalten kann, jedoch nicht beide. <br><br><h2>  Beispiel: Quadtree </h2><br>  Ein Quadtree wird verwendet, um Punkte in einer Ebene zu indizieren.  Eine Idee ist, Bereiche rekursiv in vier Teile (Quadranten) in Bezug auf <em>den Mittelpunkt</em> aufzuteilen.  Die Tiefe der Zweige in einem solchen Baum kann variieren und h√§ngt von der Dichte der Punkte in geeigneten Quadranten ab. <br><br>  So sieht es in Zahlen aus, am Beispiel der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank,</a> die von Flugh√§fen auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openflights.org erweitert wurde</a> .  √úbrigens haben wir k√ºrzlich eine neue Version der Datenbank ver√∂ffentlicht, in der wir unter anderem L√§ngen- und Breitengrad durch ein Feld vom Typ "Punkt" ersetzt haben. <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Zuerst teilen wir das Flugzeug in vier Quadranten auf ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Dann teilen wir jeden der Quadranten ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Und so weiter, bis wir die endg√ºltige Partitionierung erhalten.</em> <br><br>  Lassen Sie uns weitere Details eines einfachen Beispiels bereitstellen, das wir bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-Artikel betrachtet haben</a> .  Sehen Sie, wie die Partitionierung in diesem Fall aussehen k√∂nnte: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Die Quadranten sind wie in der ersten Abbildung gezeigt nummeriert.  Platzieren wir die untergeordneten Knoten aus Gr√ºnden der Bestimmtheit genau in derselben Reihenfolge von links nach rechts.  Eine m√∂gliche Indexstruktur in diesem Fall ist in der folgenden Abbildung dargestellt.  Jeder interne Knoten verweist auf maximal vier untergeordnete Knoten.  Jede Referenz kann wie in der Abbildung mit der Quadrantennummer gekennzeichnet werden.  Die Implementierung enth√§lt jedoch keine Bezeichnung, da es bequemer ist, ein festes Array von vier Referenzen zu speichern, von denen einige leer sein k√∂nnen. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Punkte, die an den Grenzen liegen, beziehen sich auf den Quadranten mit der kleineren Zahl. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  In diesem Fall wird standardm√§√üig die Operatorklasse "quad_point_ops" verwendet, die die folgenden Operatoren enth√§lt: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Schauen wir uns zum Beispiel an, wie die Abfrage <code>select * from points where p &gt;^ point '(2,7)'</code> wird (finden Sie alle Punkte, die √ºber dem angegebenen liegen). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Wir beginnen mit dem Wurzelknoten und verwenden die Konsistenzfunktion, um auszuw√§hlen, zu welchen untergeordneten Knoten abzusteigen ist.  F√ºr den Operator <code>&gt;^</code> vergleicht diese Funktion den Punkt (2,7) mit dem Mittelpunkt des Knotens (4,4) und w√§hlt die Quadranten aus, die die gesuchten Punkte enthalten k√∂nnen, in diesem Fall den ersten und vierten Quadranten. <br><br>  In dem Knoten, der dem ersten Quadranten entspricht, bestimmen wir erneut die untergeordneten Knoten unter Verwendung der Konsistenzfunktion.  Der zentrale Punkt ist (6,6), und wir m√ºssen noch einmal durch den ersten und vierten Quadranten schauen. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  Die Liste der Blattknoten (8.6) und (7.8) entspricht dem ersten Quadranten, von dem nur der Punkt (7.8) die Abfragebedingung erf√ºllt.  Der Verweis auf den vierten Quadranten ist leer. <br><br>  Im internen Knoten (4.4) ist auch der Verweis auf den vierten Quadranten leer, wodurch die Suche abgeschlossen wird. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Interna </h3><br>  Wir k√∂nnen die interne Struktur von SP-GiST-Indizes mithilfe der bereits erw√§hnten Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gevel</a> " untersuchen.  Schlechte Nachrichten sind, dass diese Erweiterung aufgrund eines Fehlers mit modernen Versionen von PostgreSQL nicht richtig funktioniert.  Eine gute Nachricht ist, dass wir planen, "pageinspect" mit der Funktionalit√§t von "gevel" ( <a href="">Diskussion</a> ) zu erweitern.  Und der Fehler wurde bereits in "pageinspect" behoben. <br><blockquote>  Wiederum ist eine schlechte Nachricht, dass der Patch ohne Fortschritt h√§ngen geblieben ist. <br></blockquote><br>  Nehmen wir zum Beispiel die erweiterte Demo-Datenbank, mit der Bilder mit der Weltkarte gezeichnet wurden. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Zun√§chst k√∂nnen wir einige Statistiken f√ºr den Index erhalten: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Und zweitens k√∂nnen wir den Indexbaum selbst ausgeben: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Beachten Sie jedoch, dass ‚Äûspgist_print‚Äú nicht alle Blattwerte ausgibt, sondern nur den ersten aus der Liste und daher eher die Struktur des Index als dessen vollst√§ndigen Inhalt anzeigt. <br><br><h2>  Beispiel: k-dimensionale B√§ume </h2><br>  F√ºr die gleichen Punkte in der Ebene k√∂nnen wir auch eine andere M√∂glichkeit vorschlagen, den Raum zu unterteilen. <br><br>  Zeichnen wir <em>eine horizontale Linie</em> durch den ersten indizierten Punkt.  Es teilt die Ebene in zwei Teile: obere und untere.  Der zweite zu indizierende Punkt f√§llt in einen dieser Teile.  Zeichnen wir durch diesen Punkt <em>eine vertikale Linie</em> , die diesen Teil in zwei Teile aufteilt: rechts und links.  Wir ziehen wieder eine horizontale Linie durch den n√§chsten Punkt und eine vertikale Linie durch den n√§chsten Punkt und so weiter. <br><br>  Alle auf diese Weise erstellten internen Knoten des Baums haben nur zwei untergeordnete Knoten.  Jede der beiden Referenzen kann entweder zum n√§chsten internen Knoten in der Hierarchie oder zur Liste der Blattknoten f√ºhren. <br><br>  Diese Methode kann leicht f√ºr k-dimensionale R√§ume verallgemeinert werden, und daher werden die B√§ume in der Literatur auch als k-dimensionale (kD-B√§ume) bezeichnet. <br><br>  Erl√§uterung der Methode am Beispiel von Flugh√§fen: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Zuerst teilen wir das Flugzeug in obere und untere Teile ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Dann teilen wir jedes Teil in linke und rechte Teile ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Und so weiter, bis wir die endg√ºltige Partitionierung erhalten.</em> <br><br>  Um eine Partitionierung wie diese zu verwenden, m√ºssen <strong>Sie</strong> beim Erstellen eines Index die Operatorklasse <strong>"kd_point_ops"</strong> explizit angeben. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Diese Klasse enth√§lt genau die gleichen Operatoren wie die "Standard" -Klasse "quad_point_ops". <br><br><h3>  Interna </h3><br>  Wenn wir durch die Baumstruktur schauen, m√ºssen wir ber√ºcksichtigen, dass das Pr√§fix in diesem Fall nur eine Koordinate und kein Punkt ist: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Beispiel: Radixbaum </h2><br>  Wir k√∂nnen SP-GiST auch verwenden, um einen Radix-Baum f√ºr Zeichenfolgen zu implementieren.  Die Idee eines Radixbaums besteht darin, dass eine zu indizierende Zeichenfolge nicht vollst√§ndig in einem Blattknoten gespeichert wird, sondern durch Verketten der in den dar√ºber liegenden Knoten gespeicherten Werte bis zur Wurzel erhalten wird. <br><br>  Angenommen, wir m√ºssen die URLs der Site indizieren: "postgrespro.ru", "postgrespro.com", "postgresql.org" und "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  Der Baum sieht wie folgt aus: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Die internen Knoten des Baums speichern Pr√§fixe, die allen untergeordneten Knoten gemeinsam sind.  In untergeordneten Knoten von "stgres" beginnen die Werte beispielsweise mit "p" + "o" + "stgres". <br><br>  Im Gegensatz zu Quadtrees ist jeder Zeiger auf einen untergeordneten Knoten zus√§tzlich mit einem Zeichen gekennzeichnet (genauer gesagt mit zwei Bytes, dies ist jedoch nicht so wichtig). <br><br>  Die Operatorklasse "Text_ops" unterst√ºtzt B-Baum-√§hnliche Operatoren: "gleich", "gr√∂√üer" und "kleiner": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  Der Unterschied zwischen Operatoren mit Tildes besteht darin, dass sie eher <em>Bytes</em> als <em>Zeichen</em> bearbeiten. <br><br>  Manchmal kann sich eine Darstellung in Form eines Radixbaums als viel kompakter als ein B-Baum herausstellen, da die Werte nicht vollst√§ndig gespeichert, sondern bei Bedarf beim Abstieg durch den Baum rekonstruiert werden. <br><br>  Betrachten Sie eine Abfrage: <code>select * from sites where url like 'postgresp%ru'</code> .  Es kann mit dem Index durchgef√ºhrt werden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  Tats√§chlich wird der Index verwendet, um Werte zu finden, die gr√∂√üer oder gleich "postgresp", aber kleiner als "postgresq" (Index Cond) sind, und dann werden √ºbereinstimmende Werte aus dem Ergebnis ausgew√§hlt (Filter). <br><br>  Zun√§chst muss die Konsistenzfunktion entscheiden, zu welchen untergeordneten Knoten der "p" -Wurzel wir absteigen m√ºssen.  Es stehen zwei Optionen zur Verf√ºgung: "p" + "l" (kein Abstieg erforderlich, was auch ohne tieferes Tauchen klar ist) und "p" + "o" + "stgres" (Abstieg fortsetzen). <br><br>  F√ºr den Knoten "stgres" ist ein erneuter Aufruf der Konsistenzfunktion erforderlich, um "postgres" + "p" + "ro" zu √ºberpr√ºfen.  (Abstieg fortsetzen) und "postgres" + "q" (kein Abstieg erforderlich). <br><br>  F√ºr "ro".  Bei einem Knoten und allen untergeordneten Blattknoten antwortet die Konsistenzfunktion mit "Ja", sodass die Indexmethode zwei Werte zur√ºckgibt: "postgrespro.com" und "postgrespro.ru".  Ein passender Wert wird in der Filterphase ausgew√§hlt. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Interna </h3><br>  Beim Durchsuchen der Baumstruktur m√ºssen die Datentypen ber√ºcksichtigt werden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der SP-GiST-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden fr√ºher bereitgestellt</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  SP-GiST-Indizes k√∂nnen nicht zum Sortieren und zur Unterst√ºtzung der eindeutigen Einschr√§nkung verwendet werden.  Dar√ºber hinaus k√∂nnen solche Indizes nicht f√ºr mehrere Spalten erstellt werden (im Gegensatz zu GiST).  Es ist jedoch zul√§ssig, solche Indizes zur Unterst√ºtzung von Ausschlussbeschr√§nkungen zu verwenden. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Der Unterschied zu GiST besteht darin, dass Clustering nicht m√∂glich ist. <br><br>  Und schlie√ülich sind die folgenden Eigenschaften der Spaltenschicht: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  Das Sortieren wird nicht unterst√ºtzt, was vorhersehbar ist.  Entfernungsoperatoren f√ºr die Suche nach n√§chsten Nachbarn sind in SP-GiST bisher nicht verf√ºgbar.  Diese Funktion wird h√∂chstwahrscheinlich in Zukunft unterst√ºtzt. <br><blockquote>  Es wird in PostgreSQL 12, dem Patch von Nikita Glukhov, unterst√ºtzt. <br></blockquote><br>  SP-GiST kann zumindest f√ºr die besprochenen Operatorklassen f√ºr den Nur-Index-Scan verwendet werden.  Wie wir gesehen haben, werden in einigen F√§llen indizierte Werte explizit in Blattknoten gespeichert, w√§hrend in den anderen F√§llen die Werte w√§hrend des Baumabstiegs Teil f√ºr Teil rekonstruiert werden. <br><br><h3>  Nullen </h3><br>  Um das Bild nicht zu komplizieren, haben wir bisher keine NULL-Werte erw√§hnt.  Aus den Indexeigenschaften geht hervor, dass NULL-Werte unterst√ºtzt werden.  Wirklich: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  NULL ist jedoch f√ºr SP-GiST etwas Fremdes.  Alle Operatoren aus der Operatorklasse "spgist" m√ºssen streng sein: Ein Operator muss NULL zur√ºckgeben, wenn einer seiner Parameter NULL ist.  Die Methode selbst stellt dies sicher: NULL-Werte werden einfach nicht an Operatoren √ºbergeben. <br><br>  Um die Zugriffsmethode f√ºr den Nur-Index-Scan zu verwenden, m√ºssen NULL-Werte ohnehin im Index gespeichert werden.  Und sie werden gespeichert, aber in einem separaten Baum mit eigener Wurzel. <br><br><h2>  Andere Datentypen </h2><br>  Neben Punkten und Radixb√§umen f√ºr Strings sind auch andere auf SP-GiST basierende Methoden in PostgreSQL implementiert: <br><br><ul><li>  Die Operatorklasse Box_ops bietet einen Quadtree f√ºr Rechtecke. <br>  Jedes <em>Rechteck</em> wird durch <em>einen Punkt in einem vierdimensionalen Raum dargestellt</em> , sodass die Anzahl der Quadranten gleich 16 ist. Ein Index wie dieser kann die Leistung von GiST √ºbertreffen, wenn es viele Schnittpunkte der Rechtecke gibt: In GiST ist es unm√∂glich, Grenzen zu zeichnen um sich √ºberschneidende Objekte voneinander zu trennen, w√§hrend es keine derartigen Probleme mit Punkten gibt (auch nicht vierdimensional). <br></li><li>  Die Operatorklasse "Range_ops" bietet einen Quadtree f√ºr Intervalle. <br>  <em>Ein Intervall</em> wird durch <em>einen zweidimensionalen Punkt dargestellt</em> : Die untere Grenze wird zur Abszisse und die obere Grenze wird zur Ordinate. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446624/">https://habr.com/ru/post/de446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446612/index.html">In dem Moment, als wir anfingen, an Innovation zu glauben</a></li>
<li><a href="../de446614/index.html">Virtuelle Linux-Dateisysteme: Warum werden sie ben√∂tigt und wie funktionieren sie? Teil 1</a></li>
<li><a href="../de446616/index.html">Wie wir Cloud FaaS in Kubernetes gemacht und beim Tinkoff Hackathon gewonnen haben</a></li>
<li><a href="../de446620/index.html">DataGrip 2019.1: Unterst√ºtzung f√ºr neue Datenbanken, Initialisierungsskripte, neue Inspektionen und mehr</a></li>
<li><a href="../de446622/index.html">Nachrichten um 11</a></li>
<li><a href="../de446626/index.html">Kaspersky Mobile Talks # 1. Multimodularit√§t</a></li>
<li><a href="../de446628/index.html">Geben Sie mehr HighLoad ++: ab Montag in St. Petersburg</a></li>
<li><a href="../de446630/index.html">Wie man einen 3D-Drucker ausw√§hlt oder warum man einen Heiztisch und eine geschlossene Kamera ben√∂tigt</a></li>
<li><a href="../de446632/index.html">Vom Gesetz zur Big Data-Entwicklung</a></li>
<li><a href="../de446634/index.html">SDN Digest - Sechs Open Source Emulatoren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>