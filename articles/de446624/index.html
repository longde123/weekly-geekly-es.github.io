<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏾 👱 🌁 Indizes in PostgreSQL - 6 (SP-GiST) 👶🏽 😳 🙏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits die PostgreSQL- Indizierungs-Engine , die Schnittstelle der Zugriffsmethoden und drei Methoden besprochen: Hash-Index , B-Tree und G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 6 (SP-GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/">  Wir haben bereits die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indizierungs-Engine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Schnittstelle der Zugriffsmethoden</a> und drei Methoden besprochen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Index</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> .  In diesem Artikel beschreiben wir SP-GiST. <br><br><h1>  SP-GiST </h1><br>  Zunächst ein paar Worte zu diesem Namen.  Der Teil "GiST" spielt auf eine gewisse Ähnlichkeit mit der gleichnamigen Zugriffsmethode an.  Die Ähnlichkeit besteht: Beide sind verallgemeinerte Suchbäume, die einen Rahmen für die Erstellung verschiedener Zugriffsmethoden bieten. <br><br>  "SP" steht für Space Partitioning.  Der Raum hier ist oft genau das, was wir als Raum bezeichnen, zum Beispiel eine zweidimensionale Ebene.  Aber wir werden sehen, dass jeder Suchraum gemeint ist, dh tatsächlich jede Wertdomäne. <br><br>  SP-GiST eignet sich für Strukturen, bei denen der Raum rekursiv in <em>nicht schneidende</em> Bereiche aufgeteilt werden kann.  Diese Klasse umfasst Quadtrees, k-dimensionale Bäume (kD-Bäume) und Radix-Bäume. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Die Idee der SP-GiST-Zugriffsmethode besteht also darin, die Wertdomäne in <em>nicht überlappende</em> Subdomänen aufzuteilen, von denen jede wiederum auch aufgeteilt werden kann.  Eine solche Partitionierung führt zu <em>nicht ausgeglichenen</em> Bäumen (im Gegensatz zu B-Bäumen und regulären GiST). <br><br>  Die Eigenschaft, sich nicht zu überschneiden, vereinfacht die Entscheidungsfindung beim Einfügen und Suchen.  Andererseits sind die induzierten Bäume in der Regel schwach verzweigt.  Beispielsweise hat ein Knoten eines Quadtree normalerweise vier untergeordnete Knoten (im Gegensatz zu B-Bäumen, bei denen die Knoten Hunderte betragen) und eine größere Tiefe.  Bäume wie diese passen gut zur Arbeit im RAM, aber der Index wird auf einer Festplatte gespeichert. Um die Anzahl der E / A-Vorgänge zu verringern, müssen Knoten in Seiten gepackt werden, und dies ist nicht einfach effizient durchzuführen.  Außerdem kann die Zeit, die benötigt wird, um verschiedene Werte im Index zu finden, aufgrund von Unterschieden in den Verzweigungstiefen variieren. <br><br>  Diese Zugriffsmethode übernimmt wie GiST Aufgaben auf niedriger Ebene (gleichzeitiger Zugriff und Sperren, Protokollierung und ein reiner Suchalgorithmus) und bietet eine spezielle vereinfachte Schnittstelle, um die Unterstützung neuer Datentypen und neuer Partitionierungsalgorithmen zu ermöglichen. <br><br>  Ein interner Knoten des SP-GiST-Baums speichert Verweise auf untergeordnete Knoten.  Für jede Referenz kann ein <em>Etikett</em> definiert werden.  Außerdem kann ein interner Knoten einen Wert speichern, der als <em>Präfix bezeichnet wird</em> .  Tatsächlich ist dieser Wert kein obligatorisches Präfix;  Es kann als beliebiges Prädikat betrachtet werden, das für alle untergeordneten Knoten erfüllt ist. <br><br>  Blattknoten von SP-GiST enthalten einen Wert vom indizierten Typ und einen Verweis auf eine Tabellenzeile (TID).  Die indizierten Daten selbst (Suchschlüssel) können als Wert verwendet werden, sind jedoch nicht obligatorisch: Ein verkürzter Wert kann gespeichert werden. <br><br>  Darüber hinaus können Blattknoten in Listen gruppiert werden.  Ein interner Knoten kann also nicht nur auf einen Wert verweisen, sondern auf eine ganze Liste. <br><br>  Beachten Sie, dass Präfixe, Beschriftungen und Werte in Blattknoten unabhängig voneinander ihre eigenen Datentypen haben. <br><br>  Wie in GiST ist <em>die Konsistenzfunktion</em> die Hauptfunktion, die für die Suche definiert <em>werden muss</em> .  Diese Funktion wird für einen Baumknoten aufgerufen und gibt eine Reihe von untergeordneten Knoten zurück, deren Werte mit dem Suchprädikat "übereinstimmen" (wie üblich in der Form " <em>Operatorausdruck für indizierte Felder</em> ").  Für einen Blattknoten bestimmt die Konsistenzfunktion, ob der indizierte Wert in diesem Knoten dem Suchprädikat entspricht. <br><br>  Die Suche beginnt mit dem Wurzelknoten.  Mit der Konsistenzfunktion können Sie herausfinden, welche untergeordneten Knoten ein Besuch sinnvoll ist.  Der Algorithmus wiederholt sich für jeden der gefundenen Knoten.  Die Suche steht an erster Stelle. <br><br>  Auf der physischen Ebene werden Indexknoten in Seiten gepackt, um die Arbeit mit den Knoten unter dem Gesichtspunkt von E / A-Operationen effizient zu gestalten.  Beachten Sie, dass eine Seite entweder interne oder Blattknoten enthalten kann, jedoch nicht beide. <br><br><h2>  Beispiel: Quadtree </h2><br>  Ein Quadtree wird verwendet, um Punkte in einer Ebene zu indizieren.  Eine Idee ist, Bereiche rekursiv in vier Teile (Quadranten) in Bezug auf <em>den Mittelpunkt</em> aufzuteilen.  Die Tiefe der Zweige in einem solchen Baum kann variieren und hängt von der Dichte der Punkte in geeigneten Quadranten ab. <br><br>  So sieht es in Zahlen aus, am Beispiel der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank,</a> die von Flughäfen auf der Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openflights.org erweitert wurde</a> .  Übrigens haben wir kürzlich eine neue Version der Datenbank veröffentlicht, in der wir unter anderem Längen- und Breitengrad durch ein Feld vom Typ "Punkt" ersetzt haben. <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>Zuerst teilen wir das Flugzeug in vier Quadranten auf ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Dann teilen wir jeden der Quadranten ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>Und so weiter, bis wir die endgültige Partitionierung erhalten.</em> <br><br>  Lassen Sie uns weitere Details eines einfachen Beispiels bereitstellen, das wir bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-Artikel betrachtet haben</a> .  Sehen Sie, wie die Partitionierung in diesem Fall aussehen könnte: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Die Quadranten sind wie in der ersten Abbildung gezeigt nummeriert.  Platzieren wir die untergeordneten Knoten aus Gründen der Bestimmtheit genau in derselben Reihenfolge von links nach rechts.  Eine mögliche Indexstruktur in diesem Fall ist in der folgenden Abbildung dargestellt.  Jeder interne Knoten verweist auf maximal vier untergeordnete Knoten.  Jede Referenz kann wie in der Abbildung mit der Quadrantennummer gekennzeichnet werden.  Die Implementierung enthält jedoch keine Bezeichnung, da es bequemer ist, ein festes Array von vier Referenzen zu speichern, von denen einige leer sein können. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  Punkte, die an den Grenzen liegen, beziehen sich auf den Quadranten mit der kleineren Zahl. <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br>  In diesem Fall wird standardmäßig die Operatorklasse "quad_point_ops" verwendet, die die folgenden Operatoren enthält: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br>  Schauen wir uns zum Beispiel an, wie die Abfrage <code>select * from points where p &gt;^ point '(2,7)'</code> wird (finden Sie alle Punkte, die über dem angegebenen liegen). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  Wir beginnen mit dem Wurzelknoten und verwenden die Konsistenzfunktion, um auszuwählen, zu welchen untergeordneten Knoten abzusteigen ist.  Für den Operator <code>&gt;^</code> vergleicht diese Funktion den Punkt (2,7) mit dem Mittelpunkt des Knotens (4,4) und wählt die Quadranten aus, die die gesuchten Punkte enthalten können, in diesem Fall den ersten und vierten Quadranten. <br><br>  In dem Knoten, der dem ersten Quadranten entspricht, bestimmen wir erneut die untergeordneten Knoten unter Verwendung der Konsistenzfunktion.  Der zentrale Punkt ist (6,6), und wir müssen noch einmal durch den ersten und vierten Quadranten schauen. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  Die Liste der Blattknoten (8.6) und (7.8) entspricht dem ersten Quadranten, von dem nur der Punkt (7.8) die Abfragebedingung erfüllt.  Der Verweis auf den vierten Quadranten ist leer. <br><br>  Im internen Knoten (4.4) ist auch der Verweis auf den vierten Quadranten leer, wodurch die Suche abgeschlossen wird. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3>  Interna </h3><br>  Wir können die interne Struktur von SP-GiST-Indizes mithilfe der bereits erwähnten Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gevel</a> " untersuchen.  Schlechte Nachrichten sind, dass diese Erweiterung aufgrund eines Fehlers mit modernen Versionen von PostgreSQL nicht richtig funktioniert.  Eine gute Nachricht ist, dass wir planen, "pageinspect" mit der Funktionalität von "gevel" ( <a href="">Diskussion</a> ) zu erweitern.  Und der Fehler wurde bereits in "pageinspect" behoben. <br><blockquote>  Wiederum ist eine schlechte Nachricht, dass der Patch ohne Fortschritt hängen geblieben ist. <br></blockquote><br>  Nehmen wir zum Beispiel die erweiterte Demo-Datenbank, mit der Bilder mit der Weltkarte gezeichnet wurden. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br>  Zunächst können wir einige Statistiken für den Index erhalten: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br>  Und zweitens können wir den Indexbaum selbst ausgeben: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br>  Beachten Sie jedoch, dass „spgist_print“ nicht alle Blattwerte ausgibt, sondern nur den ersten aus der Liste und daher eher die Struktur des Index als dessen vollständigen Inhalt anzeigt. <br><br><h2>  Beispiel: k-dimensionale Bäume </h2><br>  Für die gleichen Punkte in der Ebene können wir auch eine andere Möglichkeit vorschlagen, den Raum zu unterteilen. <br><br>  Zeichnen wir <em>eine horizontale Linie</em> durch den ersten indizierten Punkt.  Es teilt die Ebene in zwei Teile: obere und untere.  Der zweite zu indizierende Punkt fällt in einen dieser Teile.  Zeichnen wir durch diesen Punkt <em>eine vertikale Linie</em> , die diesen Teil in zwei Teile aufteilt: rechts und links.  Wir ziehen wieder eine horizontale Linie durch den nächsten Punkt und eine vertikale Linie durch den nächsten Punkt und so weiter. <br><br>  Alle auf diese Weise erstellten internen Knoten des Baums haben nur zwei untergeordnete Knoten.  Jede der beiden Referenzen kann entweder zum nächsten internen Knoten in der Hierarchie oder zur Liste der Blattknoten führen. <br><br>  Diese Methode kann leicht für k-dimensionale Räume verallgemeinert werden, und daher werden die Bäume in der Literatur auch als k-dimensionale (kD-Bäume) bezeichnet. <br><br>  Erläuterung der Methode am Beispiel von Flughäfen: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>Zuerst teilen wir das Flugzeug in obere und untere Teile ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Dann teilen wir jedes Teil in linke und rechte Teile ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>Und so weiter, bis wir die endgültige Partitionierung erhalten.</em> <br><br>  Um eine Partitionierung wie diese zu verwenden, müssen <strong>Sie</strong> beim Erstellen eines Index die Operatorklasse <strong>"kd_point_ops"</strong> explizit angeben. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br>  Diese Klasse enthält genau die gleichen Operatoren wie die "Standard" -Klasse "quad_point_ops". <br><br><h3>  Interna </h3><br>  Wenn wir durch die Baumstruktur schauen, müssen wir berücksichtigen, dass das Präfix in diesem Fall nur eine Koordinate und kein Punkt ist: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2>  Beispiel: Radixbaum </h2><br>  Wir können SP-GiST auch verwenden, um einen Radix-Baum für Zeichenfolgen zu implementieren.  Die Idee eines Radixbaums besteht darin, dass eine zu indizierende Zeichenfolge nicht vollständig in einem Blattknoten gespeichert wird, sondern durch Verketten der in den darüber liegenden Knoten gespeicherten Werte bis zur Wurzel erhalten wird. <br><br>  Angenommen, wir müssen die URLs der Site indizieren: "postgrespro.ru", "postgrespro.com", "postgresql.org" und "planet.postgresql.org". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br>  Der Baum sieht wie folgt aus: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  Die internen Knoten des Baums speichern Präfixe, die allen untergeordneten Knoten gemeinsam sind.  In untergeordneten Knoten von "stgres" beginnen die Werte beispielsweise mit "p" + "o" + "stgres". <br><br>  Im Gegensatz zu Quadtrees ist jeder Zeiger auf einen untergeordneten Knoten zusätzlich mit einem Zeichen gekennzeichnet (genauer gesagt mit zwei Bytes, dies ist jedoch nicht so wichtig). <br><br>  Die Operatorklasse "Text_ops" unterstützt B-Baum-ähnliche Operatoren: "gleich", "größer" und "kleiner": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br>  Der Unterschied zwischen Operatoren mit Tildes besteht darin, dass sie eher <em>Bytes</em> als <em>Zeichen</em> bearbeiten. <br><br>  Manchmal kann sich eine Darstellung in Form eines Radixbaums als viel kompakter als ein B-Baum herausstellen, da die Werte nicht vollständig gespeichert, sondern bei Bedarf beim Abstieg durch den Baum rekonstruiert werden. <br><br>  Betrachten Sie eine Abfrage: <code>select * from sites where url like 'postgresp%ru'</code> .  Es kann mit dem Index durchgeführt werden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br>  Tatsächlich wird der Index verwendet, um Werte zu finden, die größer oder gleich "postgresp", aber kleiner als "postgresq" (Index Cond) sind, und dann werden übereinstimmende Werte aus dem Ergebnis ausgewählt (Filter). <br><br>  Zunächst muss die Konsistenzfunktion entscheiden, zu welchen untergeordneten Knoten der "p" -Wurzel wir absteigen müssen.  Es stehen zwei Optionen zur Verfügung: "p" + "l" (kein Abstieg erforderlich, was auch ohne tieferes Tauchen klar ist) und "p" + "o" + "stgres" (Abstieg fortsetzen). <br><br>  Für den Knoten "stgres" ist ein erneuter Aufruf der Konsistenzfunktion erforderlich, um "postgres" + "p" + "ro" zu überprüfen.  (Abstieg fortsetzen) und "postgres" + "q" (kein Abstieg erforderlich). <br><br>  Für "ro".  Bei einem Knoten und allen untergeordneten Blattknoten antwortet die Konsistenzfunktion mit "Ja", sodass die Indexmethode zwei Werte zurückgibt: "postgrespro.com" und "postgrespro.ru".  Ein passender Wert wird in der Filterphase ausgewählt. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Interna </h3><br>  Beim Durchsuchen der Baumstruktur müssen die Datentypen berücksichtigt werden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der SP-GiST-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden früher bereitgestellt</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  SP-GiST-Indizes können nicht zum Sortieren und zur Unterstützung der eindeutigen Einschränkung verwendet werden.  Darüber hinaus können solche Indizes nicht für mehrere Spalten erstellt werden (im Gegensatz zu GiST).  Es ist jedoch zulässig, solche Indizes zur Unterstützung von Ausschlussbeschränkungen zu verwenden. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verfügbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Der Unterschied zu GiST besteht darin, dass Clustering nicht möglich ist. <br><br>  Und schließlich sind die folgenden Eigenschaften der Spaltenschicht: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br>  Das Sortieren wird nicht unterstützt, was vorhersehbar ist.  Entfernungsoperatoren für die Suche nach nächsten Nachbarn sind in SP-GiST bisher nicht verfügbar.  Diese Funktion wird höchstwahrscheinlich in Zukunft unterstützt. <br><blockquote>  Es wird in PostgreSQL 12, dem Patch von Nikita Glukhov, unterstützt. <br></blockquote><br>  SP-GiST kann zumindest für die besprochenen Operatorklassen für den Nur-Index-Scan verwendet werden.  Wie wir gesehen haben, werden in einigen Fällen indizierte Werte explizit in Blattknoten gespeichert, während in den anderen Fällen die Werte während des Baumabstiegs Teil für Teil rekonstruiert werden. <br><br><h3>  Nullen </h3><br>  Um das Bild nicht zu komplizieren, haben wir bisher keine NULL-Werte erwähnt.  Aus den Indexeigenschaften geht hervor, dass NULL-Werte unterstützt werden.  Wirklich: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br>  NULL ist jedoch für SP-GiST etwas Fremdes.  Alle Operatoren aus der Operatorklasse "spgist" müssen streng sein: Ein Operator muss NULL zurückgeben, wenn einer seiner Parameter NULL ist.  Die Methode selbst stellt dies sicher: NULL-Werte werden einfach nicht an Operatoren übergeben. <br><br>  Um die Zugriffsmethode für den Nur-Index-Scan zu verwenden, müssen NULL-Werte ohnehin im Index gespeichert werden.  Und sie werden gespeichert, aber in einem separaten Baum mit eigener Wurzel. <br><br><h2>  Andere Datentypen </h2><br>  Neben Punkten und Radixbäumen für Strings sind auch andere auf SP-GiST basierende Methoden in PostgreSQL implementiert: <br><br><ul><li>  Die Operatorklasse Box_ops bietet einen Quadtree für Rechtecke. <br>  Jedes <em>Rechteck</em> wird durch <em>einen Punkt in einem vierdimensionalen Raum dargestellt</em> , sodass die Anzahl der Quadranten gleich 16 ist. Ein Index wie dieser kann die Leistung von GiST übertreffen, wenn es viele Schnittpunkte der Rechtecke gibt: In GiST ist es unmöglich, Grenzen zu zeichnen um sich überschneidende Objekte voneinander zu trennen, während es keine derartigen Probleme mit Punkten gibt (auch nicht vierdimensional). <br></li><li>  Die Operatorklasse "Range_ops" bietet einen Quadtree für Intervalle. <br>  <em>Ein Intervall</em> wird durch <em>einen zweidimensionalen Punkt dargestellt</em> : Die untere Grenze wird zur Abszisse und die obere Grenze wird zur Ordinate. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446624/">https://habr.com/ru/post/de446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446612/index.html">In dem Moment, als wir anfingen, an Innovation zu glauben</a></li>
<li><a href="../de446614/index.html">Virtuelle Linux-Dateisysteme: Warum werden sie benötigt und wie funktionieren sie? Teil 1</a></li>
<li><a href="../de446616/index.html">Wie wir Cloud FaaS in Kubernetes gemacht und beim Tinkoff Hackathon gewonnen haben</a></li>
<li><a href="../de446620/index.html">DataGrip 2019.1: Unterstützung für neue Datenbanken, Initialisierungsskripte, neue Inspektionen und mehr</a></li>
<li><a href="../de446622/index.html">Nachrichten um 11</a></li>
<li><a href="../de446626/index.html">Kaspersky Mobile Talks # 1. Multimodularität</a></li>
<li><a href="../de446628/index.html">Geben Sie mehr HighLoad ++: ab Montag in St. Petersburg</a></li>
<li><a href="../de446630/index.html">Wie man einen 3D-Drucker auswählt oder warum man einen Heiztisch und eine geschlossene Kamera benötigt</a></li>
<li><a href="../de446632/index.html">Vom Gesetz zur Big Data-Entwicklung</a></li>
<li><a href="../de446634/index.html">SDN Digest - Sechs Open Source Emulatoren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>