<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôÇÔ∏è üêà üç∞ Log cepat üîÆ üç∫ üë°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini saya telah menempatkan tolok ukur panggilan paling pribadi dari penebang. Saya melakukan semua percobaan pada log4net dan NLog, pada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Log cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456488/"><p>  Dalam artikel ini saya telah menempatkan tolok ukur panggilan paling pribadi dari penebang.  Saya melakukan semua percobaan pada log4net dan NLog, pada Intel Windows 10 x64 dengan M.2 SSD. </p><br><p>  Hasil mentah dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Kode dalam repositori yang sama (untuk menjalankan, Anda memerlukan .Net 4.7.2 + Microsoft Visual Studio 2017+). </p><br><p>  Apa, bagaimana dan mengapa - di bawah luka. </p><a name="habracut"></a><br><p>  Agar tidak membaca untuk waktu yang lama, tabel hasil: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,144.677 ns </td><td>  26.3805 ns </td><td>  77,7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,106.691 ns </td><td>  31.4041 ns </td><td>  87,5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4,804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104,3022 ns </td><td>  102.4387 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,642.301 ns </td><td>  73.2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11.834.892 ns </td><td>  82.7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731.250.539 ns </td><td>  14,612.0117 ns </td><td>  27.444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730.271.927 ns </td><td>  11,330.0172 ns </td><td>  10,598.1051 ns </td></tr><tr><td>  BuatLog4NetFromString </td><td>  1,470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  BuatNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1.8895 ns </td></tr><tr><td>  BuatLog4NetLogger </td><td>  21.046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  BuatNLogTypeOfLogger </td><td> 164.487.931 ns </td><td>  3,240.4372 ns </td><td>  3,031.1070 ns </td></tr><tr><td>  BuatNLogDynamicLogger </td><td>  134.459.092 ns </td><td>  1,882.8663 ns </td><td>  1.761.2344 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  8,251.032 ns </td><td>  109,3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260.452 ns </td><td>  145,9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9,133.136 ns </td><td>  89,7420 ns </td><td>  79,5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9,393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6,458.201 ns </td><td>  94.5617 ns </td><td>  88.4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95,5435 ns </td><td>  84.6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83.9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7,524.876 ns </td><td>  82,8979 ns </td><td>  77.5427 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10,506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2,073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2,625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41,525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><h1 id="nooplogging">  NoOpLogging </h1><br><p>  Pertama, mari kita perkirakan berapa banyak kita menghabiskan waktu memanggil metode untuk logging, yang pada akhirnya tidak akan menghasilkan apa-apa.  Dalam kebanyakan kasus (dalam pengalaman saya), Debug verbose dinonaktifkan pada server pertempuran, tetapi tidak ada yang menghapus panggilan. </p><br><p>  Pertama, hasilnya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10,506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48.858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69.463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2,073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2,625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41,525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57.622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><p>  Dan kodenya: </p><br><pre><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p>  Pertama, mari kita tentukan mengapa tes semacam itu dipilih: </p><br><ul><li>  Percobaan dilakukan di perpustakaan paling populer. </li><li><p>  NLog dan log4net memiliki tanda tangan fungsi yang berbeda untuk sejumlah kecil argumen: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul><li>  Teori: ketika mentransfer tipe signifikan ke log4net, tinju akan muncul, yang hanya menghabiskan waktu prosesor dan tidak mengarah ke apa pun.  Dalam kasus NLog, tidak ada perilaku seperti itu, jadi yang terakhir harus bekerja lebih cepat. </li></ul><br></li><li>  Tanda tangan untuk sejumlah besar argumen di perpustakaan kira-kira sama, jadi saya ingin tahu: <br><ul><li>  Betapa jauh lebih efisien untuk memanggil metode dengan sejumlah kecil parameter. </li><li>  Apakah ada perbedaan dalam kecepatan memanggil metode "Apakah ... Diaktifkan" antara dua perpustakaan </li></ul></li></ul><br><p>  Dan sekarang hasil analisisnya: </p><br><ul><li>  Karena penggunaan argumen generik di NLog, ini berfungsi lebih cepat untuk kasus ketika penebangan langsung tidak diperlukan.  Yaitu, untuk kasus ketika dalam program Debug Anda tingkat diaktifkan hanya pada sistem pengujian, hanya mengubah perpustakaan dapat mempercepat perangkat lunak (dan meningkatkan kehidupan pengguna). </li><li>  Jika Anda telah logon dimatikan dan Anda ingin memanggil metode dengan sejumlah besar argumen, maka lebih efisien untuk membaginya menjadi dua.  Karena itu, pemanggilan metode di atas akan bekerja sepuluh kali lebih cepat. </li><li>  Ketika Anda menulis fungsi yang dapat mengambil objek apa pun, seringkali paling efektif untuk bingung dan membuat fungsi generik.  Karena optimasi yang sederhana, kode akan bekerja lebih cepat (ini terlihat jelas dalam perbedaan waktu antara panggilan ke <code>Log4NetSingleReferenceParam</code> dan <code>Log4NetSingleValueParam</code> ) </li></ul><br><h1 id="filelogging">  Filelogging </h1><br><p>  Sebagian besar program (menurut pengamatan saya) masih mencatat hasil ke file, jadi untuk perbandingan kami memilih operasi ini.  Untuk kesederhanaan, kami hanya mengambil konfigurasi para penebang ketika file ditulis ke file tanpa buffering, tanpa kunci tambahan, dll. </p><br><p>  Hasil: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  8,251.032 ns </td><td>  109,3075 ns </td><td>  102.2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8.260.452 ns </td><td>  145,9028 ns </td><td>  136.4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8.378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9,133.136 ns </td><td>  89,7420 ns </td><td>  79,5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9,393.989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061.837 ns </td><td>  69.5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6,458.201 ns </td><td>  94.5617 ns </td><td>  88.4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460.859 ns </td><td>  95,5435 ns </td><td>  84.6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7.236.886 ns </td><td>  89.7334 ns </td><td>  83.9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7,524.876 ns </td><td>  82,8979 ns </td><td>  77.5427 ns </td></tr></tbody></table></div><br><p>  Kode yang digunakan: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p>  Seperti yang Anda lihat, konfigurasi para penebang kurang lebih sama, dan sesuai dengan hasilnya: </p><br><ul><li>  NLog sedikit lebih cepat dari log4net, sekitar 15%. </li><li>  Menurut tes, ternyata lebih efisien untuk mencatat lebih sedikit parameter.  Namun, jangan lupa bahwa dengan jumlah parameter yang lebih besar, string yang dihasilkan juga diperluas.  Oleh karena itu, tabel hanya membandingkan NLog dengan log4net dengan benar. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok">  NLog - berbagai jenis kunci </h1><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,642.301 ns </td><td>  73.2291 ns </td><td>  68.4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11.834.892 ns </td><td>  82.7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731.250.539 ns </td><td>  14,612.0117 ns </td><td>  27.444.8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730.271.927 ns </td><td>  11,330.0172 ns </td><td>  10,598.1051 ns </td></tr></tbody></table></div><br><p>  Kode Sumber: </p><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p>  Jika kami menempatkan semua kombinasi yang memungkinkan sebagai pengganti XXXXX dan YYYYY, kami mendapatkan tes dari tabel. </p><br><p>  Hasilnya cukup dapat diprediksi: </p><br><ul><li>  Jika Anda mengaktifkan ConcurrentWrites, maka sistem akan terus-menerus mengambil dan memberikan Mutex, yang tidak gratis.  Tetapi, seperti yang kita lihat, menulis satu baris ke file kira-kira setara dengan satu kunci sistem. </li><li>  Menutup dan membuka file, seperti yang kita lihat, lebih memengaruhi kinerja sistem.  Dalam contoh dengan <code>KeepFileOpen=true</code> untuk setiap operasi logging, kami membuat file (bersama-sama dengan Handle), menulis ke disk, bernama Flush, kembali Handle dan juga membuat banyak operasi kap mesin.  Akibatnya, kecepatan turun ratusan kali. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok">  Logging asinkron dan metode penguncian berbeda </h1><br><p>  Perpustakaan NLog juga dapat melakukan semua operasi IO pada utas lainnya, segera membebaskan yang sekarang.  Dan dia melakukannya dengan kompeten, menjaga urutan peristiwa, menjatuhkan semua data dalam blok, dan di setiap blok bilangan bulat adalah nomor peristiwa (sehingga garis yang dipotong tidak diperoleh), dan seterusnya. </p><br><p>  Hasil dari berbagai metode non-pemblokiran: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,144.677 ns </td><td>  26.3805 ns </td><td>  77,7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,106.691 ns </td><td>  31.4041 ns </td><td>  87,5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4,804.426 ns </td><td>  110.3406 ns </td><td>  103.2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104,3022 ns </td><td>  102.4387 ns </td></tr></tbody></table></div><br><p>  Perbandingan pendekatan pemblokiran dan asinkron akan lebih jauh, tetapi di sini - hanya yang terakhir. </p><br><p>  Kode <code>AsyncTargetWrapper</code> : </p><br><pre> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, QueueLimit = 10000 }</code> </pre> <br><p>  Seperti yang Anda lihat, pengaturan pembungkus sedemikian rupa sehingga pembuangan langsung ke file tidak memakan waktu cukup lama.  Dengan demikian, buffer besar terakumulasi, yang berarti bahwa semua operasi sumber daya intensif seperti "file terbuka" dilakukan sekali untuk seluruh blok.  Namun, algoritma semacam itu membutuhkan memori tambahan (dan banyak). </p><br><p>  Kesimpulan: </p><br><ul><li>  Jika output asinkron digunakan, tidak masalah apa pun pengaturan output dengan file yang digunakan.  Anda dapat membuka dan menutup file setiap kali, dengan buffer besar itu akan hampir tak terlihat. </li><li>  Semua pengukuran adalah benar hanya untuk kasus ketika data memerah ke disk pada kecepatan yang sama dengan pengisian buffer (saya melakukan ini karena sistem file cepat + jeda alami antara pengukuran). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie">  Logging sinkron dan asinkron </h1><br><div class="scrollable-table"><table><thead><tr><th>  Hasil: </th><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835.730 ns </td><td>  55,3980 ns </td><td>  163.3422 ns </td><td>  1,791.901 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7.076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7.075.394 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5,438.306 ns </td><td>  42.0170 ns </td><td>  37.2470 ns </td><td>  5,427.805 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0,0141 ns </td><td>  0,0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1,045 ns </td><td>  0,0037 ns </td><td>  0,0033 ns </td><td>  1,045 ns </td></tr></tbody></table></div><br><p>  Kesimpulan: </p><br><ul><li>  Meskipun disk cepat (dalam kasus saya - M.2 SSD), menulis ke file dalam aliran lain mempercepat pekerjaan beberapa kali.  Jika aplikasi Anda menulis ke disk HDD, dan bahkan berjalan di mesin virtual, maka keuntungannya akan lebih besar. </li><li>  Namun, meskipun pengoperasian kode asinkron yang bahkan lebih cepat, kurangnya pencatatan memberikan hasil yang lebih besar (walaupun sedikit berbeda, tergantung pada pustaka). </li></ul><br><h1 id="sozdanie-loggerov">  Menciptakan Penebang </h1><br><p>  Hasil: </p><br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th></tr></thead><tbody><tr><td>  BuatLog4NetFromString </td><td>  1,470.662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  BuatNLogFromString </td><td>  228.774 ns </td><td>  2.1315 ns </td><td>  1.8895 ns </td></tr><tr><td>  BuatLog4NetLogger </td><td>  21.046.294 ns </td><td>  284.1171 ns </td><td>  265.7633 ns </td></tr><tr><td>  BuatNLogTypeOfLogger </td><td>  164.487.931 ns </td><td>  3,240.4372 ns </td><td>  3,031.1070 ns </td></tr><tr><td>  BuatNLogDynamicLogger </td><td>  134.459.092 ns </td><td>  1,882.8663 ns </td><td>  1.761.2344 ns </td></tr></tbody></table></div><br><p>  Apa yang diuji: </p><br><pre> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p>  Komentar penting: sayangnya, sulit bagi saya untuk membuat tolok ukur yang dapat direproduksi yang tidak mengarah ke Memori Kehabisan, tetapi yang akan membuat penebang yang berbeda (mis. Untuk jenis yang berbeda, untuk garis yang berbeda dan sebagainya). </p><br><p>  Namun, setelah mempelajari karya perpustakaan, saya menemukan bahwa hampir semua operasi yang paling sulit dilakukan untuk membuat kunci logger (mis., Menentukan nama, menghapus argumen Generik, dan sebagainya). <br>  Selain itu, untuk menstabilkan patokan untuk membuat logger untuk log4net, perlu untuk melakukan bukan hanya satu operasi, tetapi 16 (mis. Sebuah array dari 16 objek yang identik dikembalikan).  Jika Anda tidak mengembalikan apa pun, maka .Net mengoptimalkan eksekusi untuk saya (tampaknya, tidak mengembalikan hasilnya), yang menyebabkan hasil yang salah. </p><br><p>  Dan kesimpulannya: </p><br><ul><li>  Logger dibuat paling cepat dari string (NLog lebih cepat lagi, namun, perbedaan antara perpustakaan kecil, mengingat logger dibuat bukan hanya seperti itu, tetapi untuk pekerjaan selanjutnya dengan mereka). </li><li>  log4net lebih cepat dari NLog saat menginisialisasi proyek.  Mungkin ini disebabkan oleh caching tambahan di sisi NLog, yang membantu mempercepat panggilan langsung ke <code>Debug</code> , <code>Info</code> , dll.  Faktanya, setiap <code>ILogger</code> mengetahui jawabannya sendiri: apakah akan memanggil metode berikut atau tidak (dan ini membutuhkan setidaknya beberapa jenis pengikatan pada konfigurasi umum).  Karena skema kerja ini, Memori Habis digunakan oleh saya pada sebagian besar tes (jika saya menggunakan jalur yang berbeda, dll.). </li><li>  <code>LogManager.GetCurrentClassLogger()</code> bahkan lebih lambat dari <code>LogManager.GetLogget(typeof(XXX))</code> .  Ini logis, bahkan pengembang NLog tidak menyarankan memanggil metode pertama dalam satu lingkaran. </li><li>  Dan yang paling penting: kecepatan semua metode ini sering hanya mempengaruhi awal yang dingin dari aplikasi ketika bidang bentuk <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  Artinya, itu tidak secara langsung mempengaruhi kinerja sistem. </li></ul><br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Apa cara terbaik untuk menangani log: </p><br><ul><li>  Jika mungkin untuk tidak login sama sekali, ini akan menjadi yang tercepat (yang sudah jelas sejauh ini). </li><li>  Jika proyek memiliki banyak panggilan logger yang tidak membuang data ke file (ke konsol, dll.), Maka NLog lebih cepat.  Selain itu, ia mengalokasikan lebih sedikit objek di heap. </li><li>  Jika Anda masih perlu menulis ke file, maka NLog bekerja secara asinkron dengan paling cepat.  Ya, itu memakan lebih banyak memori (dibandingkan dengan NLog dalam mode sinkron, karena menurut pengukuran saya sebelumnya, log4net bahkan tidak mencoba untuk menggunakan kembali array dan <code>Stream</code> 's.  Namun, program akan dapat berjalan lebih cepat. </li><li>  Membuat logger bukan operasi gratis, jadi seringkali lebih baik untuk membuatnya dengan bidang statis.  Ini tidak berlaku untuk membuat dari string, yaitu sesuatu seperti <code>LogManager.GetLogger("123")</code> .  Panggilan semacam itu bekerja lebih cepat, yang berarti bahwa logger dapat dibuat untuk instance objek yang besar (misalnya, "satu logger untuk konteks kueri"). </li><li>  Jika Anda ingin menampilkan banyak parameter ke log, tetapi dalam kebanyakan kasus tidak akan ada data dump langsung ke file, yang terbaik adalah membuat beberapa panggilan.  Oleh karena itu, NLog tidak akan membuat objek tambahan di heap jika mereka tidak diperlukan di sana. </li></ul><br><p>  Kesimpulan untuk kode Anda: </p><br><ul><li>  Jika metode Anda menerima objek sewenang-wenang (mis. <code>object</code> ) dan dalam kebanyakan kasus tidak melakukan apa-apa (yang berlaku untuk kontrak / validator), maka paling benar untuk membungkus panggilan dalam bentuk generik (mis. Membuat metode dalam bentuk <code>Something&lt;TArg&gt;(TArg arg)</code> ).  Ini akan bekerja sangat cepat. </li><li>  Jika dalam kode Anda reset data file diperbolehkan dan pada saat yang sama bekerja dengan sesuatu yang lain, lebih baik untuk menjadi bingung dan mendukung ini.  Ya, tampak jelas bahwa eksekusi paralel dapat mempercepat pekerjaan, namun, dalam kasus operasi IO, pendekatan ini juga memberikan peningkatan kinerja tambahan pada mesin dengan disk yang lambat. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456488/">https://habr.com/ru/post/id456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456470/index.html">Jebakan dari Penerbit Paket WSUS</a></li>
<li><a href="../id456472/index.html">Memperkenalkan Go dan Kerangka Mggo</a></li>
<li><a href="../id456474/index.html">Tic Tac Toe Bagian 0: Membandingkan Langsing dan Bereaksi</a></li>
<li><a href="../id456476/index.html">Modifikasi tumpukan Bluetooth untuk meningkatkan kualitas audio pada headphone tanpa codec AAC, aptX, atau LDAC</a></li>
<li><a href="../id456486/index.html">Antarmuka dan Pilihan (2014)</a></li>
<li><a href="../id456490/index.html">Ceramah tentang otak, bagian 1. Evolusi otak manusia. Fungsi otak pada setiap tahap perkembangannya</a></li>
<li><a href="../id456492/index.html">Tentara Troll</a></li>
<li><a href="../id456494/index.html">Di Amerika Serikat, GOST juga biasa-biasa saja. YubiKey FIPS kerentanan fatal yang bisa dihindari</a></li>
<li><a href="../id456498/index.html">Pengelola Perangkat Perluas MIS ke perangkat</a></li>
<li><a href="../id456500/index.html">Cara mengajar mengatasi kesulitan, dan pada saat yang sama menulis siklus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>