<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 🤾🏾 🛋️ Échanges atomiques de brillance et de pauvreté 🍮 😽 🛀🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi les échanges atomiques sont mauvais et comment les canaux les aideront, ce qui est important dans la fourche dure de Constantinople et quoi f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Échanges atomiques de brillance et de pauvreté</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483828/">  Pourquoi les échanges atomiques sont mauvais et comment les canaux les aideront, ce qui est important dans la fourche dure de Constantinople et quoi faire quand il n'y a rien à payer pour le gaz. <br><br>  La principale motivation de tout professionnel de la sécurité est le désir d'éviter la responsabilité. <br><br>  La Providence a été gracieuse, j'ai quitté l'ICO, n'attendant pas la première transaction irréversible, mais je me suis vite retrouvé derrière le développement d'un échange de crypto-monnaie. <br><a name="habracut"></a><br>  Je ne suis définitivement pas Malchish Kibalchish, et un regard strict me suffit pour passer toutes les clés et mots de passe.  Par conséquent, mon objectif principal en tant qu'architecte était de placer la piqûre brûlante de la cryptanalyse aussi loin que possible des éléments d'infrastructure qui me sont chers. <br><br><h2>  Pas vos clés, pas vos problèmes </h2><br>  Nous construisons un système d'échange d'actifs et souhaitons exclure le stockage intermédiaire de ces actifs à domicile, mais nous devons assurer la sécurité de la transaction. <br><br>  Vous pouvez agir en tant que juge dans une situation controversée et effectuer des transactions avec des portefeuilles qui nécessitent deux des trois signatures: l'acheteur, le vendeur et l'entiercement. <br><br>  Cependant, si un participant réussit à attaquer un séquestre, il reçoit alors les deux signatures requises. <br><br>  Le swap atomique est un système d'échange où un contrat intelligent agit en tant que garant, ce qui ne permet qu'un comportement honnête. <br><br>  Comme dans une énigme sur une chèvre loup et un chou, vous ne pouvez agir que selon le seul scénario correct et subir des pertes si vous vous en éloignez. <br><br>  Seulement au lieu d'animaux voraces, l'ordre fournit une fonction de hachage dans laquelle il est si difficile de trouver une collision qu'il ne vaut pas la peine de commencer. <br><br><h4>  Première étape: l'énigme </h4><br>  Supposons qu'Alice veuille donner Bitcoin à Bob pour une poignée de «crypto yuan» un beau matin. <br><br><ul><li>  Elle fait un grand secret </li><li>  Reçoit un hachage de celui-ci </li><li>  Il transfère des bitcoins vers un contrat intelligent, à partir duquel Bob peut prendre de l'argent en présentant un secret (le hachage de celui-ci doit être égal à celui spécifié dans le contrat) </li><li>  Dans le cas où Bob n'est pas à ses bitcoins dans la soirée, Alice peut les ramener à elle. </li></ul><br><h4>  Deuxième étape: appât </h4><br>  Bob entre dans le jeu et transfère «cryptoeuro» à son contrat, qui est rédigé de telle manière que: <br><br><ul><li>  Alice peut ramasser des «crypto-pièces» en présentant un numéro secret </li><li>  Pas avant le déjeuner, Bob, si Alice n'apparaît pas, peut retourner le dépôt <br></li></ul><br><h4>  Troisième étape: la solution dans l'appât </h4><br>  Alice vient chercher son argent et prend l'argent du contrat de Bob, tout en révélant son secret. <br><br><h4>  La dernière étape: l'énigme est résolue </h4><br>  Bob voit la transaction et avec son regard aquilin il isole d'elle le secret présenté par Alice au contrat.  Il utilise ce secret pour récupérer ses bitcoins. <br><br><h3>  Quand quelque chose tourne mal </h3><br>  Si Alice se révèle soudainement mortelle, Bob prend son yuan pour le déjeuner. <br><br>  À son tour, Alice dans la soirée retourne Bitcoin si le perfide Bob décide de conserver l'argent jusqu'à des temps meilleurs. <br><br>  Si vous préférez une image à un texte, sur Habré il y a <a href="https://habr.com/en/post/458646/">pour vous</a> une <a href="https://habr.com/en/post/458646/">explication</a> plus détaillée et plus claire <a href="https://habr.com/en/post/458646/">du travail des swaps atomiques</a> . <br><br>  La différence entre les délais d'attente est conçue pour nous protéger contre la malveillante Alice, qui prend l'argent de Bob au tout dernier moment, et le délai expire pendant qu'il conduit l'hexagone dans la transaction avec les doigts tremblants. <br><br>  Les participants ne peuvent pas perdre leur argent, le maximum devra attendre un retour. <br><br><div class="spoiler">  <b class="spoiler_title">Prise en charge de la blockchain</b> <div class="spoiler_text">  C'est un schéma simple comme des bottes en feutre, qui ne nécessite rien des chaînes de blocs en interaction: <br><br><ul><li>  Prise en charge des contrats intelligents avec au moins une succursale </li><li>  Les deux chaînes de blocs doivent prendre en charge les mêmes algorithmes de hachage (n'oubliez pas de vérifier la longueur du secret) </li><li>  Timelocks. </li></ul><br></div></div><br>  À première vue, on peut déjà dire à l’échange «au revoir, notre rencontre était une erreur», mais elle n’était pas là. <br><br>  Pour tous ses mérites, les solutions de swap atomique ne frappent pas avec la liquidité.  En grande partie parce que dans la paire de BTC-USD la plus populaire, la partie fiduciaire n'était pas complètement symbolisée. <br>  Le succès de l'USDT a généré une vague de pièces stables au format ERC20 pour tous les goûts, du USDC gardien au DAI le plus algorithmique. <br><br>  Par conséquent, pour simplifier, nous soutenons en outre qu'Alice vend des Bobcoins à Bob pour certains jetons ERC20, et nous espérons le succès des stabilisateurs, car nous avons beaucoup plus de problèmes techniques. <br><br><h3>  La vitesse </h3><br>  Bitcoin et Ethereum seuls ne sont pas trop rapides, mais ici, nous devons d'abord attendre un dépôt avec toutes les confirmations, puis le second. <br><br>  Tout cela parce qu'au début, le participant gagne de l'argent, qui connaît le secret, et l'adversaire attend la finalité et ne transfère ensuite sa part. <br><br>  De plus, nous avons affaire à un actif très volatil, de sorte que pendant ce temps, le cours peut changer considérablement et changer les conditions n'est pas facile. <br><br><h3>  Confidentialité </h3><br>  Tout échange laisse des artefacts sur les deux chaînes de blocs.  Un observateur attentif peut remarquer les mêmes hachages dans les contrats intelligents et conclure logiquement qu'un accord a été conclu ici, à partir duquel de nombreuses conclusions peuvent être tirées du taux de change à la taxe. <br><br>  Lorsque l'échange connaît vos affaires - c'est extrêmement désagréable, quand tout le monde le sait - c'est doublement désagréable. <br><br><h3>  Convivialité </h3><br>  Le cheval blockchain en général et l'éther en particulier.  Voyons quels mouvements corporels le vendeur et l'acheteur devront effectuer. <br><br>  Du point de vue du vendeur, tout est relativement simple: il suffit de transférer Bitcoin vers une adresse p2sh.  Avec l'éther, tout est beaucoup plus délicat. <br><br><div class="spoiler">  <b class="spoiler_title">Le contrat</b> <div class="spoiler_text">  Considérons un contrat de swap en moyenne gigab: <br><br><pre><code class="plaintext hljs">contract iERC20 { function totalSupply() public view returns (uint256); function transfer(address receiver, uint numTokens) public returns (bool); function balanceOf(address tokenOwner) public view returns (uint); function approve(address delegate, uint numTokens) public returns (bool); function allowance(address owner, address delegate) public view returns (uint); function transferFrom(address owner, address buyer, uint numTokens) public returns (bool); } contract Swapper { struct Swap { iERC20 token; bytes32 hash; uint amount; uint refundTime; bytes32 secret; } mapping (address =&gt; mapping(address =&gt; Swap)) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, uint refundTime) public { require(swaps[msg.sender][receiver].amount == 0); // check is swap with given hash already exists require(token.transferFrom(msg.sender, address(this), amount)); // transfer locked tokens to swap contract swaps[msg.sender][receiver] = Swap(token, hash, amount, refundTime, 0x00); //create swap } function hashOf(bytes32 secret) public pure returns(bytes32) { return sha256(abi.encodePacked(secret)); } function withdraw(address owner, bytes32 secret) public { Swap memory swap = swaps[owner][msg.sender]; require(swap.secret == bytes32(0)); require(swap.hash == sha256(abi.encodePacked(secret))); // swap exists swaps[owner][msg.sender].secret = secret; swap.token.transfer(msg.sender, swap.amount); } function refund(address receiver) public { Swap memory swap = swaps[msg.sender][receiver]; require(now &gt; swap.refundTime); delete swaps[msg.sender][receiver]; swap.token.transfer(msg.sender, swap.amount); } }</code> </pre> <br>  <b>Attention!</b>  N'utilisez pas cela et d'autres contrats d'un article sur la production, ils sont écrits uniquement à des fins de démonstration.  <b>Surtout celui-ci</b> . <br></div></div><br><ul><li>  Bob doit appeler la méthode d' <code>approve</code> sur le contrat de jeton, donnant au contrat d'échange l'accès à ses jetons <br></li><li>  Bob crée un swap et un contrat à l'aide de la méthode <code>transferFrom</code> prend les jetons d'expéditeur à son adresse <br></li><li>  Alice en <code>withdraw</code> révèle un secret et le contrat appelle le <code>transfer</code> <br></li></ul><br>  La plupart des portefeuilles et des <code>approve</code> ne prennent pas en charge les jetons d' <code>approve</code> , et pour une bonne raison. <br><br>  Les utilisateurs eux-mêmes se trompent souvent et transfèrent simplement des jetons au contrat, après quoi les jetons sont simplement perdus.  Les commentaires sur Etherscan sont pleins de misérables gémissants. <br><br>  Et pour appeler un contrat, vous devez payer une commission en ETH, donc les deux participants doivent les approvisionner avant le début de la transaction, et peu de gens veulent le faire. <br><br><h3>  Support de gaz </h3><br>  Pour commencer, cela vaut la peine de retirer le chèque de l'expéditeur dans la mesure du possible et de supposer que nous avons quelqu'un qui souffre d'un excès de gaz et cause des contrats pour tout le monde. <br><br><div class="spoiler">  <b class="spoiler_title">Contrat amélioré</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">contract Swapper { struct Swap { iERC20 token; address receiver; uint amount; address refundAddress; uint refundTime; } mapping (bytes32 =&gt; Swap) swaps; function create(iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public { require(swaps[hash].amount == 0); // use hash once require(token.transferFrom(msg.sender, address(this), amount)); swaps[hash] = Swap(token, receiver, amount, refundAddress, refundTime); } function withdraw(bytes memory secret) public { bytes32 hash = sha256(secret); Swap memory swap = swaps[hash]; require(swap.amount &gt; 0); delete swaps[hash]; swap.token.transfer(swap.receiver, swap.amount); } function refund(bytes32 hash) public { Swap memory swap = swaps[hash]; require(now &gt; swap.refundTime); delete swaps[hash]; swap.token.transfer(swap.refundAddress, swap.amount); } }</code> </pre><br></div></div><br><h3>  Dualisme de clé de contrat et EIP 712 </h3><br>  Comme nous le savons, l'adresse à l'antenne peut être un contrat ou un sujet, c'est-à-dire une clé. <br>  L'occupation principale de la clé est de signer tous les messages. <br><br>  Nous pouvons utiliser le contrat Bob comme expéditeur, qui effectue toutes les passes nécessaires, avant de vérifier la signature de la clé Bob. <br><br>  Désormais, n'importe qui peut parrainer une commission membre, mais seul celui qui connaît la clé prend la décision. <br><br><div class="spoiler">  <b class="spoiler_title">Contrat Bob</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library EIP712ProxyLibrary { function hashCommand(address sender, iERC20 token, Swapper swapper, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime) public view returns(bytes32); } contract ProxyBob { address owner; constructor(address _owner) public { owner = _owner; } function createSwap(Swapper swapper, iERC20 token, bytes32 hash, address receiver, uint amount, address refundAddress, uint refundTime, uint8 v, bytes32 r, bytes32 s) public { require(owner == ecrecover(EIP712ProxyLibrary.hashCommand(address(this), token, swapper, hash, receiver, amount, refundAddress, refundTime), v, r, s)); token.approve(address(swapper), amount); swapper.create(token, hash, receiver, amount, refundAddress, refundTime); } }</code> </pre><br></div></div><br>  Ethereum dispose d'une norme <a href="" rel="nofollow">EIP 712</a> pour travailler avec les signatures de structures de données complexes. Vous pouvez en savoir plus à ce sujet sur le <a href="https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26" rel="nofollow">blog du portefeuille Metamask.</a> <br><br><h3>  Diviser et conquérir </h3><br>  Souvent, le scénario de piratage d'un contrat Ethereum ressemble à ceci: <br><br><ul><li>  Le participant verse des fonds au contrat </li><li>  Prend ensuite l'argent </li><li>  Quelque chose ne va pas </li><li>  Un attaquant prend de l'argent encore et encore </li></ul><br>  Si nous revenons à notre premier exemple, quelque chose ne va pas si l'énigme est un ensemble d'octets vide. <br><br><div class="spoiler">  <b class="spoiler_title">Comment voler un million</b> <div class="spoiler_text">  Créer un échange avec un hachage <code>0x66687aadf862bd776c8fc18b8e9f8e20089714856ee233b3902a591d0d5f2925</code> <br>  C'est sha256 de <code>0x0000000000000000000000000000000000000000000000000000000000000000</code> <br>  Nous passons le secret et récupérons nos jetons <br>  Nous le repassons et prenons les étrangers, tout cela parce que 0 = 0 <br></div></div><br>  En créant un contrat distinct pour chaque transaction, nous pouvons isoler les contrats au niveau EVM. <br><br>  Mais ce n'est pas tout: chaque transaction a désormais sa propre adresse, à laquelle vous pouvez transférer des jetons depuis n'importe quel portefeuille ou échange. <br><br><h2>  Contrats abandonnés et create2 </h2><br>  Mais maintenant, pour chaque transaction, nous devons créer un contrat et attendre que l'acheteur y transfère la «cryptofening» de la main-d'œuvre.  Dans le schéma «contrats du matin, argent du soir», il y a toujours un risque que l'acheteur tombe, et l'éther a déjà été dépensé pour créer le contrat. <br><br>  Est-il possible de gagner de l'argent le matin et des octets le soir? <br><br>  Dans le hard fork de Constantinople, les développeurs <a href="https://eips.ethereum.org/EIPS/eip-1014" rel="nofollow">EIP 1014</a> ont ajouté une instruction create2 qui crée un nouveau contrat à une adresse déterministe <br><br><pre> <code class="plaintext hljs">keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]</code> </pre><br>  O Where <br><br><ul><li>  adresse - adresse du contrat d'usine </li><li>  sel - un certain nombre, dont nous apprendrons la signification dans la prochaine série </li><li>  init_code - contrat bytecode et paramètres constructeur. </li></ul><br><div class="spoiler">  <b class="spoiler_title">L'usine</b> <div class="spoiler_text">  L'instruction ne fonctionne que par l'assemblage, donc l'usine semble un peu intimidante: <br><br><pre> <code class="plaintext hljs">contract Factory { event Deployed(address addr, uint256 salt); function create2(bytes memory code, uint256 salt) public { address addr; assembly { addr := create2(0, add(code, 0x20), mload(code), salt) } emit Deployed(addr, salt); } }</code> </pre><br>  Votre code de contrat peut être obtenu via web3: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyContract = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(ABI, {}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ode = MyContract.deploy({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: BYTECODE, <span class="hljs-attr"><span class="hljs-attr">arguments</span></span>: contructorArgs }).encodeABI(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> web3.eth.Contract(FACTORY_ABI, factoryAddress); tx = factory.methods.create2(ode, salt);</code> </pre><br>  En raison d'un soutien limité en solidité, le gaz pour le contrat peut ne pas être calculé correctement en raison de certaines subtilités de l'éther. <br><br>  Il est particulièrement agréable qu'en cas de pénurie de gaz, le contrat tombe avec une erreur interne, sans informer qu'il n'y avait pas assez de gaz, comme on pouvait s'y attendre. <br></div></div><br>  Maintenant, nous pouvons transférer des jetons vers des contrats sans les créer à l'avance et jusqu'à ce que nous les publions sur le réseau, personne ne devinera exactement ce que fait le contrat. <br><br><h3>  Le corbeau ne picorera pas le corbeau </h3><br>  Il est clair que les trucs d'un tel enfant n'arrêteront pas un véritable analyste, en particulier celui qui a reçu de bons investissements dans la lutte contre les <s>ennemis du régime de</s> blanchiment d'argent, et après avoir créé le contrat, il verra toujours un hachage. <br><br>  Comment s'assurer que le hachage ne s'allume pas? <br><br>  Nous transférons le swap lui-même à la chaîne: les participants échangent des signatures pour être transférés vers un contrat de swap, puis le secret est divulgué en privé. <br><br><div class="spoiler">  <b class="spoiler_title">Pas à pas</b> <div class="spoiler_text">  Deux "multisig" sont créés, desquels vous pouvez retirer des fonds si vous avez les signatures d'Alice et Bob. <br><br>  Afin de se déconnecter l'un des participants n'est pas devenu une tragédie, nous ajoutons le bon vieux timeout. <br><br>  Alice et Bob font des dépôts en parallèle <br><br><ul><li>  Alice fait un secret et donne à Bob le hachage du secret et la signature de la transaction, qui transfère les bitcoins à l'adresse de swap </li><li>  Bob donne à Alice une signature sur le retrait de jetons sur un contrat de swap avec un hachage caché. </li><li>  Alice révèle à Bob le secret. </li></ul><br></div></div><br>  À ce moment, l'harmonie s'ensuit: Alice et Bob peuvent conclure l'accord à tout moment.  Dans un environnement aussi convivial, ils peuvent échanger des signatures pour retirer de l'argent à leur adresse finale. <br><br>  Pour un observateur extérieur, il semble que l'argent ait passé un contrat avec une multi-signature 2 sur 2. <br><br>  Et un tel schéma permet également aux deux parties d'effectuer un dépôt en même temps, car le secret est déjà constitué après toutes les confirmations. <br><br><h2>  Niveau 2 </h2><br>  Étant donné que nous pouvons retirer de l'argent à une seule adresse et ne pas publier une transaction intermédiaire, rien ne nous empêche de retirer de l'argent à plusieurs adresses et d'effectuer un nombre illimité de transactions intermédiaires.  Non pas que c'était un ensemble nécessaire pour un échange, mais si vous avez commencé à collecter un échange, il est difficile de s'arrêter. <br><br>  Maintenant, Alice et Bob pourront se retourner avec puissance et main.  Par exemple, calculez automatiquement le prix moyen en échangeant Satoshi par seconde, ou connectez simplement directement le teneur de marché et le destinataire de la liquidité. <br><br><div class="spoiler">  <b class="spoiler_title">Pas à pas</b> <div class="spoiler_text"><ul><li>  Le vendeur fait un secret et donne à l'acheteur un hachage de la signature secrète et de la transaction où une partie des fonds est transférée à l'adresse d'échange p2sh et le reste est retourné à l'adresse du vendeur <br></li><li>  L'acheteur transmet une signature permettant de retirer les jetons sur le swap et la livraison à l'adresse du destinataire. <br></li><li>  Le vendeur révèle un secret </li><li>  L'histoire se répète avec un nouveau secret, tandis qu'au swap et à la remise s'ajoute la sortie précédemment achetée à l'adresse de l'acheteur et déjà payée à l'adresse du vendeur </li></ul><br></div></div><br>  Nous avons maintenant accès au trading P2P à grande vitesse, l'essentiel est de surveiller l'heure et de conclure l'affaire avant l'expiration. <br><br>  Cependant, après avoir légèrement ajusté nos contrats, nous pouvons donner à nos chaînes une immortalité, ce qui simplifiera grandement la création d'un réseau pour nous. <br><br>  Mais nous en parlerons dans la prochaine série. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483828/">https://habr.com/ru/post/fr483828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483814/index.html">Abraham Flexner: l'utilité des connaissances inutiles (1939)</a></li>
<li><a href="../fr483818/index.html">Moteur, langage de script et roman visuel - en 45 heures</a></li>
<li><a href="../fr483820/index.html">Ce qui affecte l'émission de crédit. Aperçu de la concurrence pour le risque de défaut de crédit</a></li>
<li><a href="../fr483822/index.html">5 fonctionnalités JavaScript sans lesquelles je ne pouvais pas écrire de code</a></li>
<li><a href="../fr483826/index.html">Connexion d'un capteur de CO2 modèle MH-Z19B à l'aide de la sortie analogique Vo</a></li>
<li><a href="../fr483832/index.html">RxJava à Coroutines: migration des fonctionnalités de bout en bout</a></li>
<li><a href="../fr483834/index.html">Debian: transformer simplement i386 en amd64</a></li>
<li><a href="../fr483842/index.html">L'histoire de la création d'un cloud domestique. Partie 5. Mise à jour 2019 - PHP 7.2, MariaDB 10.4 et Nextcloud 17</a></li>
<li><a href="../fr483844/index.html">Analyse des documents réglementaires sur la protection des informations dans le secteur russe du crédit et des finances</a></li>
<li><a href="../fr483846/index.html">Gestion alternative des fenêtres sous Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>