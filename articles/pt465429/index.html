<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶ üìµ ‚ñ∂Ô∏è No entanto, C √© uma linguagem de baixo n√≠vel üßõ üë∑üèª üôã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima d√©cada, desde o advento da linguagem C, muitas linguagens de programa√ß√£o interessantes foram criadas. Alguns deles ainda s√£o usados, outros ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No entanto, C √© uma linguagem de baixo n√≠vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/465429/"><p><img src="https://habrastorage.org/webt/0w/1l/ey/0w1leycdhljvvpoqezgzueoho8a.jpeg"></p><br><p>  Na √∫ltima d√©cada, desde o advento da linguagem C, muitas linguagens de programa√ß√£o interessantes foram criadas.  Alguns deles ainda s√£o usados, outros influenciaram a pr√≥xima gera√ß√£o de idiomas, a popularidade do terceiro desapareceu silenciosamente.  Enquanto isso, arcaico, pol√™mico, primitivo, tornava as piores tradi√ß√µes de sua gera√ß√£o de l√≠nguas C (e seus herdeiros) mais vivas do que todos os seres vivos. </p><br><p>  Criticism C √© um g√™nero epistolar cl√°ssico para nossa ind√∫stria.  Parece mais alto, depois mais silencioso, mas ultimamente tem sido literalmente impressionante.  Um exemplo √© uma tradu√ß√£o do artigo de David Ciswell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúC n√£o √© um idioma de baixo n√≠vel‚Äù,</a> publicado em nosso blog h√° algum tempo.  Voc√™ pode dizer coisas diferentes sobre C, h√° realmente muitos erros desagrad√°veis ‚Äã‚Äãno design da linguagem, mas recusar C no "n√≠vel baixo" √© demais! </p><br><p>  Para n√£o tolerar tal injusti√ßa, tomei coragem e tentei decidir o que era uma linguagem de programa√ß√£o de baixo n√≠vel e quais pr√°ticas eles queriam dela. Depois disso, examinei os argumentos dos cr√≠ticos C. Foi assim que este artigo foi publicado. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Argumentos de cr√≠tica C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linguagem de programa√ß√£o de baixo n√≠vel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√£o se trata apenas de PDP-11</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Otimizando compiladores e linguagem de baixo n√≠vel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Padr√£o como um bem absoluto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquiteturas alternativas - computa√ß√£o especial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C viver√°</a> </li></ul><br><h1 id="argumenty-kritikov-c">  Argumentos de cr√≠tica C </h1><br><p>  Aqui est√£o alguns dos argumentos dos cr√≠ticos de C, incluindo os listados em um artigo de David Chiznell: </p><br><ol><li>  A m√°quina abstrata da linguagem C √© muito semelhante √† arquitetura desatualizada do PDP-11, que h√° muito tempo deixa de corresponder ao dispositivo dos populares processadores modernos. </li><li> A incompatibilidade entre uma m√°quina abstrata e o dispositivo de m√°quinas reais complica o desenvolvimento de otimizadores de compiladores de linguagem. </li><li>  A incompletude e a complexidade do padr√£o de idioma levam a discrep√¢ncias nas implementa√ß√µes padr√£o. </li><li>  O dom√≠nio das linguagens do tipo C n√£o permite explorar arquiteturas alternativas de processadores. </li></ol><br><p>  Vamos primeiro determinar os requisitos para uma linguagem de baixo n√≠vel, ap√≥s o que retornamos aos argumentos fornecidos. </p><br><h1 id="yazyk-programmirovaniya-nizkogo-urovnya">  Linguagem de programa√ß√£o de baixo n√≠vel </h1><br><p>  N√£o existe uma defini√ß√£o universalmente aceita de uma linguagem de baixo n√≠vel.  Mas antes de discutir quest√µes controversas, √© desej√°vel ter pelo menos alguns requisitos iniciais para o assunto da disputa. </p><br><p>  Ningu√©m argumentar√° que a linguagem assembly est√° no n√≠vel mais baixo.  Mas em cada plataforma √© √∫nico, portanto, o c√≥digo em um idioma assim n√£o pode ser port√°til.  Mesmo em uma plataforma compat√≠vel com vers√µes anteriores, pode ser necess√°rio usar algumas novas instru√ß√µes. </p><br><p>  A partir daqui segue o primeiro requisito para um idioma de baixo n√≠vel: ele deve manter <em>recursos comuns para plataformas populares</em> .  Simplificando, o compilador deve ser port√°til.  A portabilidade do compilador simplifica o desenvolvimento de compiladores de linguagem para novas plataformas, e a variedade de plataformas suportadas por compiladores elimina a necessidade de desenvolvedores reescreverem programas de aplicativos para cada nova m√°quina. </p><br><p>  O primeiro requisito entra em conflito com os desejos dos desenvolvedores de programas especiais: linguagens de programa√ß√£o, drivers, sistemas operacionais e bancos de dados de alto desempenho.  Os programadores que escrevem esses programas desejam otimizar manualmente, trabalhar diretamente com a mem√≥ria e assim por diante.  Em uma palavra, uma linguagem de baixo n√≠vel <em>deve permitir trabalhar com os detalhes da implementa√ß√£o da plataforma</em> . </p><br><p>  Encontrar um equil√≠brio entre esses dois requisitos - identificar aspectos comuns √†s plataformas e acessar o m√°ximo de detalhes poss√≠vel - √© um motivo fundamental para a dificuldade de desenvolver uma linguagem de baixo n√≠vel. </p><br><p>  Observe que abstra√ß√µes de alto n√≠vel n√£o s√£o t√£o importantes para essa linguagem - √© mais importante que sirva de contrato entre a plataforma, o compilador e o desenvolvedor.  E se houver um contrato, ser√° necess√°rio um <em>idioma independente do padr√£o de implementa√ß√£o espec√≠fico</em> . </p><br><p>  Nosso primeiro requisito - recursos comuns √†s plataformas de destino - √© expresso em uma m√°quina de linguagem abstrata; portanto, iniciaremos a discuss√£o com C. </p><br><h1 id="delo-ne-tolko-v-pdp-11">  N√£o se trata apenas de PDP-11 </h1><br><p>  A plataforma na qual a linguagem C apareceu √© o PDP-11.  √â baseado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquitetura</a> tradicional de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">von Neumann</a> , na qual os programas s√£o executados seq√ºencialmente pelo processador central, e a mem√≥ria √© uma fita plana, na qual os dados e os programas s√£o armazenados.  Essa arquitetura √© facilmente implementada em hardware e, com o tempo, todos os computadores de uso geral come√ßaram a us√°-la. </p><br><p>  As melhorias modernas na arquitetura de von Neumann visam eliminar seu principal gargalo - atrasos na troca de dados entre o processador e a mem√≥ria ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gargalo em</a> ingl√™s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">von Neuman</a> ).  A diferen√ßa no desempenho da mem√≥ria e da CPU levou ao surgimento de subsistemas de cache dos processadores (n√≠vel √∫nico e, posteriormente, multin√≠vel). </p><br><p>  Mas mesmo caches nos dias de hoje n√£o s√£o suficientes.  Os processadores modernos tornaram-se superescalares.  Atrasos quando as instru√ß√µes recebem dados da mem√≥ria s√£o parcialmente compensados ‚Äã‚Äãpela execu√ß√£o extraordin√°ria ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paralelismo no n√≠vel</a> das instru√ß√µes) das instru√ß√µes, juntamente com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">preditor de ramifica√ß√£o</a> . </p><br><p>  A m√°quina abstrata seq√ºencial C (e muitas outras l√≠nguas) imita o trabalho n√£o tanto especificamente do PDP-11, mas de qualquer computador organizado de acordo com o princ√≠pio da arquitetura de von Neumann.  Inclui arquiteturas constru√≠das em torno de processadores com um √∫nico n√∫cleo: desktop e servidor x86, ARM m√≥vel, provenientes da cena do Sun / Oracle SPARC e IBM POWER. </p><br><p>  Com o tempo, v√°rios n√∫cleos de processamento come√ßaram a ser integrados em um processador, como resultado, tornou-se necess√°rio manter a coer√™ncia dos caches de cada n√∫cleo e exigir protocolos de intera√ß√£o internuclear.  A arquitetura de Von Neumann foi, portanto, dimensionada para v√°rios n√∫cleos. </p><br><p>  A vers√£o original da m√°quina abstrata C era seq√ºencial, n√£o refletindo a presen√ßa de encadeamentos de execu√ß√£o de programa interagindo atrav√©s da mem√≥ria.  A apar√™ncia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo de mem√≥ria</a> no padr√£o expandiu os recursos da m√°quina abstrata para paralelo. </p><br><p>  Portanto, a afirma√ß√£o de que a m√°quina C abstrata √© inconsistente com a estrutura dos processadores modernos n√£o se refere tanto a uma linguagem espec√≠fica, mas a computadores que usam a arquitetura von Neumann, inclusive em execu√ß√£o paralela. </p><br><p>  Mas, como profissional, quero observar o seguinte: podemos assumir que a abordagem de Fonneimann est√° desatualizada, podemos assumir que √© relevante, mas isso n√£o cancela o fato de que as arquiteturas de uso geral de hoje usam derivadas da abordagem tradicional. </p><br><p>  A incorpora√ß√£o padronizada e port√°til da arquitetura von Neumann - a m√°quina C abstrata - √© convenientemente implementada em todas as principais plataformas e, portanto, goza de sua popularidade como montadora port√°til de maneira merecedora. </p><br><h1 id="optimiziruyuschie-kompilyatory-i-yazyk-nizkogo-urovnya">  Otimizando compiladores e linguagem de baixo n√≠vel </h1><br><p>  Nosso segundo requisito para um idioma de baixo n√≠vel √© o acesso aos detalhes de implementa√ß√£o de baixo n√≠vel de cada uma das plataformas populares.  No caso de C, trata-se de trabalho direto com mem√≥ria e objetos, como uma matriz de bytes, a capacidade de trabalhar diretamente com endere√ßos de bytes e aritm√©tica avan√ßada de ponteiros. </p><br><p>  Os cr√≠ticos de C apontam que o padr√£o de linguagem oferece muitas garantias em rela√ß√£o, por exemplo, √† localiza√ß√£o de campos individuais em estruturas e associa√ß√µes.  Juntamente com ponteiros e mecanismos primitivos de loops, isso complica o trabalho do otimizador. </p><br><p>  De fato, uma abordagem mais declarativa permitiria ao compilador resolver independentemente os problemas de alinhamento de dados na mem√≥ria ou a ordem ideal de campos nas estruturas;  e os ciclos de n√≠vel superior oferecem a liberdade que voc√™ precisa ao vetorizar. </p><br><p>  A posi√ß√£o dos desenvolvedores C neste caso √© a seguinte: uma linguagem de baixo n√≠vel deve permitir que ele funcione em um n√≠vel baixo o suficiente para que o programador resolva problemas de otimiza√ß√£o de forma independente.  Em C, √© poss√≠vel trabalhar como compilador, escolhendo, por exemplo, instru√ß√µes SIMD e colocando os dados corretamente na mem√≥ria. </p><br><p>  Em outras palavras, nosso requisito de acesso aos detalhes de implementa√ß√£o de cada plataforma entra em conflito com os desejos dos desenvolvedores de otimizar compiladores precisamente devido √† presen√ßa de ferramentas de baixo n√≠vel. </p><br><p>  Curiosamente, em seu artigo intitulado "C n√£o √© uma linguagem de baixo n√≠vel", Lifewell argumenta paradoxalmente que C √© de n√≠vel <em>muito</em> baixo, indicando a aus√™ncia de ferramentas de alto n√≠vel.  Mas os profissionais precisam de ferramentas exatamente de baixo n√≠vel; caso contr√°rio, a linguagem n√£o pode ser usada para desenvolver sistemas operacionais e outros programas de baixo n√≠vel, ou seja, n√£o atender√° ao segundo de nossos requisitos. </p><br><p>  Distraindo-me da descri√ß√£o dos problemas de otimiza√ß√£o de C, quero observar que, no momento, n√£o s√£o investidos menos esfor√ßos na otimiza√ß√£o de compiladores de linguagens de alto n√≠vel (o mesmo C # e Java) do que no GCC ou Clang.  Linguagens funcionais tamb√©m t√™m compiladores efetivos suficientes: MLTon, OCaml e outros.  Mas os desenvolvedores do mesmo OCaml ainda podem apresentar desempenho, na melhor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">das</a> hip√≥teses, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">com metade da velocidade do c√≥digo C</a> ... </p><br><h1 id="standart-kak-bezuslovnoe-blago">  Padr√£o como um bem absoluto </h1><br><p>  Em seu artigo, Chiznell cita os resultados de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa</a> realizada em 2015: muitos programadores cometeram erros ao resolver problemas de compreens√£o dos padr√µes C. </p><br><p>  Suponho que um dos leitores estava lidando com o padr√£o C. Eu tenho uma vers√£o em papel do C99, 900 p√°ginas de comerciais. Esta n√£o √© uma especifica√ß√£o lac√¥nica de esquema com um volume inferior a 100 p√°ginas e nem um padr√£o ML lambido de 300. Prazer no trabalho ningu√©m recebe o padr√£o C: nem desenvolvedores de compiladores, nem desenvolvedores de documentos, nem programadores. </p><br><p>  Mas devemos entender que o padr√£o C foi desenvolvido ap√≥s o fato, ap√≥s o surgimento de muitos "quase mal coloca" dialetos compat√≠veis.  Os autores do ANSI C fizeram um √≥timo trabalho resumindo as implementa√ß√µes existentes e cobrindo in√∫meras incont√°veis ‚Äã‚Äã"muletas" de imparcialidade no design da linguagem. </p><br><p>  Pode parecer estranho que algu√©m se comprometa a implementar esse documento.  Mas o C foi implementado por muitos compiladores.  N√£o vou recontar as hist√≥rias de outras pessoas sobre o zool√≥gico do mundo UNIX do final dos anos 80, especialmente porque naquela √©poca eu mesmo n√£o a considerava com muita confian√ßa e s√≥ at√© as cinco.  Mas, obviamente, todos na ind√∫stria realmente precisavam de um padr√£o. </p><br><p>  O melhor √© que ele existe e √© implementado por pelo menos tr√™s compiladores grandes e muitos compiladores menores, que juntos suportam centenas de plataformas.  Nenhuma das l√≠nguas concorrentes C, que reivindica a coroa do rei das l√≠nguas de baixo n√≠vel, pode se orgulhar de tanta diversidade e versatilidade. </p><br><p>  Na verdade, o padr√£o C atual n√£o √© t√£o ruim.  Um programador mais ou menos experiente √© capaz de desenvolver um compilador C n√£o otimizado em um per√≠odo de tempo razo√°vel, o que √© confirmado pela exist√™ncia de muitas implementa√ß√µes semi-amadoras (o mesmo TCC, LCC e 8cc). </p><br><p>  Ter um padr√£o geralmente aceito significa que C satisfaz o √∫ltimo de nossos requisitos para um idioma de baixo n√≠vel: esse idioma √© constru√≠do em uma especifica√ß√£o, n√£o em uma implementa√ß√£o espec√≠fica. </p><br><h1 id="alternativnye-arhitektury---udel-specialnyh-vychisleniy">  Arquiteturas alternativas - computa√ß√£o especial </h1><br><p>  Mas Lifewell cita outro argumento, voltando ao dispositivo dos modernos processadores de uso geral que implementam as op√ß√µes de arquitetura von Neumann.  Ele afirma que faz sentido mudar os princ√≠pios do processador central.  Mais uma vez, essa cr√≠tica n√£o √© espec√≠fica para C, mas para o modelo mais b√°sico de programa√ß√£o imperativa. </p><br><p>  De fato, existem muitas alternativas √† abordagem tradicional com execu√ß√£o seq√ºencial de programas: modelos SIMD no estilo GPU, modelos no estilo de uma m√°quina Erlang abstrata e outros.  Mas cada uma dessas abordagens tem aplicabilidade limitada quando usada em um processador central. </p><br><p>  As GPUs, por exemplo, multiplicam notavelmente matrizes em jogos e aprendizado de m√°quina, mas s√£o dif√≠ceis de usar para o tra√ßado de raios.  Em outras palavras, esse modelo √© adequado para aceleradores especializados, mas n√£o funciona para processadores de uso geral. </p><br><p>  Erlang funciona muito bem em um cluster, mas √© dif√≠cil fazer uma classifica√ß√£o r√°pida eficiente ou uma tabela de hash r√°pida.  O modelo de atores independentes √© melhor usado em um n√≠vel superior, em um cluster grande, onde cada n√≥ ainda √© a mesma m√°quina de alto desempenho que um processador tradicional. </p><br><p>  Enquanto isso, os processadores modernos compat√≠veis com x86 h√° muito incluem um conjunto de instru√ß√µes vetoriais semelhantes √† GPU nos prop√≥sitos e nos princ√≠pios operacionais, mas preservam o circuito geral do processador no estilo von Neumann como um todo.  N√£o tenho d√∫vidas de que qualquer abordagem bastante geral da computa√ß√£o ser√° inclu√≠da nos processadores populares. </p><br><p>  Existe uma opini√£o t√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">autorit√°ria</a> : o futuro est√° em aceleradores program√°veis ‚Äã‚Äãespecializados.  Sob essas pe√ßas extraordin√°rias de ferro, realmente faz sentido desenvolver linguagens com sem√¢ntica especial.  Mas um computador de uso geral era e permanece semelhante ao pr√≥prio PDP-11, para o qual as linguagens imperativas do tipo C s√£o t√£o adequadas. </p><br><h1 id="s-budet-zhit">  C viver√° </h1><br><p>  H√° uma contradi√ß√£o fundamental no artigo de Chiznell.  Ele escreve que, para garantir a velocidade dos programas em C, os processadores imitam a m√°quina C abstrata (e o h√° muito esquecido PDP-11), ap√≥s o qual apontam as limita√ß√µes dessa m√°quina.  Mas n√£o entendo por que isso significa que "C n√£o √© uma linguagem de baixo n√≠vel". </p><br><p>  Em geral, n√£o se trata das falhas de C como linguagem, mas de cr√≠ticas √†s arquiteturas comuns do estilo von Neumann e ao modelo de programa√ß√£o que delas se segue.  Mas at√© agora n√£o parece que a ind√∫stria esteja pronta para abandonar a arquitetura familiar (pelo menos n√£o nos processadores de uso geral). </p><br><p>  Apesar da disponibilidade de muitos processadores especializados, como GPUs e TPUs, a arquitetura von Neumann est√° atualmente sob controle e o setor precisa de uma linguagem que permita operar no n√≠vel mais baixo poss√≠vel dentro da estrutura da arquitetura mais popular.  Um bastante simples, portado para dezenas de plataformas e linguagem de programa√ß√£o padronizada √© o C (e sua fam√≠lia imediata). </p><br><p>  Por tudo isso, C tem insufici√™ncias suficientes: uma biblioteca arcaica de fun√ß√µes, um padr√£o intrincado e inconsistente e erros grosseiros de design.  Mas, aparentemente, os criadores da linguagem ainda fizeram algo certo. </p><br><p>  De uma forma ou de outra, ainda precisamos de uma linguagem de baixo n√≠vel, e ela foi criada especificamente para computadores Fonneimann populares.  E deixe C desatualizado, mas, aparentemente, qualquer sucessor ainda ter√° que se basear nos mesmos princ√≠pios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465429/">https://habr.com/ru/post/pt465429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465417/index.html">Plugins de volume de armazenamento Kubernetes: Flexvolume to CSI</a></li>
<li><a href="../pt465419/index.html">Amanh√£ na ITMO University: o processo educacional, competi√ß√µes e educa√ß√£o no exterior - uma sele√ß√£o dos pr√≥ximos eventos</a></li>
<li><a href="../pt465423/index.html">Ind√∫stria e manufatura inteligentes 4.0: tr√™s principais tend√™ncias tecnol√≥gicas</a></li>
<li><a href="../pt465425/index.html">Vepp - novo servidor e painel de controle do ISPsystem</a></li>
<li><a href="../pt465427/index.html">An√°lise do Apache Dubbo RPC Framework pelo analisador de c√≥digo est√°tico PVS-Studio</a></li>
<li><a href="../pt465431/index.html">An√°lise do c√≥digo-fonte RPC da estrutura Apache Dubbo com o analisador est√°tico PVS-Studio</a></li>
<li><a href="../pt465433/index.html">Rob√¥s de trabalho - homem feliz</a></li>
<li><a href="../pt465435/index.html">Qual distribui√ß√£o √© melhor usar no seu sistema embarcado?</a></li>
<li><a href="../pt465437/index.html">Por que me recusei a trabalhar na AWS</a></li>
<li><a href="../pt465441/index.html">LuaVela: implementa√ß√£o Lua 5.1 baseada em LuaJIT 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>