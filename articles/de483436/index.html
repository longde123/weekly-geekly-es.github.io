<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèª üõãÔ∏è üë©üèø‚Äçüåæ Spielen Sie "osu!", Aber achten Sie auf Bugs üè´ üòû üöΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ihr alle Sammler von exotischen und einfachen K√§fern! Wir haben heute ein seltenes Exemplar auf unserem PVS-Studio-Pr√ºfstand - ein Spiel namens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spielen Sie "osu!", Aber achten Sie auf Bugs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483436/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="Bild 1" align="left"></p><br>  Hallo, ihr alle Sammler von exotischen und einfachen K√§fern!  Wir haben heute ein seltenes Exemplar auf unserem PVS-Studio-Pr√ºfstand - ein Spiel namens "osu!", Geschrieben in C #.  Wie √ºblich werden wir nach Bugs suchen, diese analysieren und spielen. <br><a name="habracut"></a><br><h2>  Das Spiel </h2><br>  Osu!  ist ein Open-Source-Rhythmus-Spiel.  Laut der <a href="https://osu.ppy.sh/home">Website</a> des Spiels ist es mit mehr als 15 Millionen Spielerkonten recht beliebt.  Das Projekt bietet kostenloses Gameplay, farbenfrohes Design, Kartenanpassung, ein erweitertes Online-Player-Ranking-System, einen Multiplayer-Modus und eine Vielzahl von Musikst√ºcken.  Es macht keinen Sinn, das Spiel weiter zu erl√§utern.  Sie k√∂nnen alles dar√ºber im Internet lesen.  Beginnen Sie mit <a href="https://en.wikipedia.org/wiki/Osu!">dieser Seite</a> . <br><br>  Ich interessiere mich mehr f√ºr den Quellcode des Projekts, der auf <a href="https://github.com/ppy/osu">GitHub</a> verf√ºgbar ist.  Eine Sache, die sofort auff√§llt, ist die gro√üe Anzahl von Repository-Commits (√ºber 24.000), was ein Zeichen intensiver, kontinuierlicher Entwicklung ist (das Spiel wurde erstmals 2007 ver√∂ffentlicht, aber die Arbeit muss noch fr√ºher begonnen haben).  Das Projekt ist jedoch nicht gro√ü: Nur 1813 .cs-Dateien mit insgesamt 135.000 nicht leeren LOCs.  Diese Zahl beinhaltet auch Tests, die ich normalerweise bei der Durchf√ºhrung von Pr√ºfungen nicht ber√ºcksichtige.  Die Tests machen 306 der .cs-Dateien mit 25.000 LOC aus.  Das Projekt ist in der Tat klein: Zum Beispiel ist der C # -Kern von PVS-Studio ungef√§hr 300.000 LOC lang. <br><br>  Ich lie√ü die Testdateien weg und √ºberpr√ºfte 1507 Dateien mit einer L√§nge von 110.000 LOC.  Der Check hat ein paar interessante Fehler aufgedeckt, die ich Ihnen gerne zeigen m√∂chte. <br><br><h2>  Die K√§fer </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Es gibt identische Unterausdr√ºcke 'result == HitResult.Perfect' links und rechts vom '||'  Betreiber.  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br>  Dies ist ein gutes Beispiel f√ºr kopierorientiertes Programmieren, ein humorvoller Begriff, den mein Kollege Valeriy Komarov k√ºrzlich in seinem Artikel " <a href="https://www.viva64.com/en/b/0699/">Top 10 Bugs Found in Java Projects in 2019</a> " verwendet hat. <br><br>  Auf jeden Fall werden zwei identische Pr√ºfungen hintereinander ausgef√ºhrt.  Eine von ihnen sollte wahrscheinlich eine andere Konstante der <i>HitResult-</i> Aufz√§hlung <i>√ºberpr√ºfen</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br>  Welche Konstante sollte √ºberpr√ºft werden?  Oder sollte der zweite Scheck gar nicht da sein?  Dies sind die Fragen, die nur die Autoren beantworten k√∂nnen.  Auf jeden Fall ist dies ein Fehler, der die Ausf√ºhrungslogik des Programms verf√§lscht. <br><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Es gibt identische Unterausdr√ºcke 'family! = GetFamilyString (TournamentTypeface.Aquatico)' links und rechts vom Operator '&amp;&amp;'.  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br>  Kopieren-Einf√ºgen erneut.  Ich habe den Code √ºberarbeitet, damit der Fehler jetzt leicht bemerkt wird, aber urspr√ºnglich war er in einer Zeile geschrieben worden.  Wie im vorherigen Beispiel kann ich nicht genau sagen, wie dieses Problem behoben werden soll.  Die <i>TournamentTypeface-</i> Enumeration enth√§lt nur eine Konstante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br>  Vielleicht liegt der Fehler darin, die <i>Familienvariable</i> zweimal zu √ºberpr√ºfen, aber ich kann mich irren. <br><br>  <a href="https://www.viva64.com/en/w/v3009/">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer denselben Wert von 'false' zur√ºckgibt.  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Diese Methode gibt jedes Mal <i>false</i> zur√ºck.  In solchen F√§llen √ºberpr√ºfe ich normalerweise den Funktionsaufruf, da Sie h√§ufig feststellen, dass der Aufrufer den R√ºckgabewert nicht verwendet, was bedeutet, dass es kein Problem gibt (au√üer einem schlechten Stil).  So sieht der Aufruf in diesem Fall aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Wie Sie sehen, verwendet der Aufrufer den von der <i>OnPressed-</i> Methode zur√ºckgegebenen Wert.  Da dieser Wert immer <i>falsch ist</i> , gibt der Aufrufer selbst immer auch <i>falsch zur√ºck</i> .  Dieser Code enth√§lt sehr wahrscheinlich einen Fehler und sollte √ºberarbeitet werden. <br><br>  Ein weiterer √§hnlicher Fehler: <br><br><ul><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer denselben Wert von 'false' zur√ºckgibt.  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'val.NewValue'-Objekts TournamentTeam.cs 41 verwendet <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br>  Die Variable <i>val.NewValue</i> wird unter der Bedingung <i>?:</i> Operator auf gef√§hrliche Weise behandelt.  Was den Analyzer zu der Annahme veranlasst, ist die Tatsache, dass sp√§ter in der <i>then-</i> Verzweigung dieselbe Variable auf sichere Weise mit dem Operator f√ºr bedingte Zugriffe behandelt wird: <i>val.NewValue? .Substring (....)</i> . <br><br>  Ein weiterer √§hnlicher Fehler: <br><br><ul><li>  V3042 [CWE-476] M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'val.NewValue'-Objekts TournamentTeam.cs 48 verwendet </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'api'-Objekts SetupScreen.cs 77 verwendet <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br>  Dieser ist mehrdeutig, aber ich glaube, es ist auch ein Fehler.  Der Programmierer erstellt ein Objekt vom Typ <i>ActionableInfo</i> .  Das Feld " <i>Aktion"</i> wird mit einer Lambda-Funktion initialisiert, die die potenziell Null-Referenz- <i>API</i> auf gef√§hrliche Weise verarbeitet.  Der Analysator betrachtet dieses Muster als Fehler, da die <i>API-</i> Variable sp√§ter bei der Initialisierung des Parameters <i>Value auf</i> sichere Weise behandelt wird.  Ich habe diesen Fall als mehrdeutig bezeichnet, weil der Code in der Lambda-Funktion eine verz√∂gerte Ausf√ºhrung impliziert, bis zu deren Ablauf der Entwickler m√∂glicherweise garantiert, dass die <i>API-</i> Referenz nicht null ist.  Aber da bin ich mir nicht sicher, da der K√∂rper der Lambda-Funktion anscheinend keine sichere Referenzbehandlung wie vorherige √úberpr√ºfungen verwendet. <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> [CWE-683] M√∂gliche falsche Reihenfolge der an die Methode 'Atan2' √ºbergebenen Argumente: 'diff.X' und 'diff.Y'.  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br>  Der Analysator vermutet, dass die Argumente der <i>Atan2-</i> Methode in der falschen Reihenfolge √ºbergeben werden.  Dies ist die Deklaration der Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br>  Die Werte wurden in umgekehrter Reihenfolge √ºbergeben.  Ich bin nicht sicher, ob dies ein Fehler ist, da die <i>UpdateProgress-</i> Methode ziemlich viele nicht-triviale Berechnungen enth√§lt.  Ich erw√§hne es nur als m√∂glichen Fehler. <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> [CWE-476] M√∂gliche Null-Dereferenzierung.  Betrachten Sie 'Beatmap'.  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br>  Der Analyzer weist auf eine m√∂gliche Null-Dereferenzierung von <i>Beatmap hin</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br>  Nun, der Analysator ist korrekt. <br><br>  Weitere Informationen dar√ºber, wie PVS-Studio solche Fehler erkennt und welche neuen Funktionen in C # 8.0 hinzugef√ºgt wurden, die mit der Behandlung von potenziell <a href="https://www.viva64.com/en/b/0631/">leeren Referenzen</a> zu tun haben, finden Sie im Artikel " <a href="https://www.viva64.com/en/b/0631/">Nullbare Referenztypen in C # 8.0 und statische Analyse</a> ". <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> [CWE-367] Unsicherer Aufruf des Ereignisses 'ObjectConverted', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br>  Dies ist ein kleiner und recht h√§ufiger Fehler.  Die Abonnenten k√∂nnen das Ereignis zwischen der Nullpr√ºfung und dem Ereignisaufruf abbestellen, was zu einem Absturz f√ºhrt.  Dies ist eine M√∂glichkeit, den Fehler zu beheben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3095/">V3095</a> [CWE-476] Das Objekt 'columns' wurde verwendet, bevor es gegen null verifiziert wurde.  Zeilen √ºberpr√ºfen: 141, 142. SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br>  Die Iteration √ºber die <i>Spaltensammlung</i> erfolgt auf gef√§hrliche Weise.  Der Entwickler ging davon aus, dass die <i>Spaltenreferenz</i> null sein k√∂nnte, was durch die Verwendung des Operators f√ºr den bedingten Zugriff angegeben wird, um im Code weiter auf die Auflistung zuzugreifen. <br><br>  <a href="https://www.viva64.com/en/w/v3119/">V3119 Das</a> Aufrufen des √ºberschriebenen Ereignisses 'OnNewResult' kann zu unvorhersehbarem Verhalten f√ºhren.  Erw√§gen Sie, Ereignis-Accessoren explizit zu implementieren, oder verwenden Sie das Schl√ºsselwort 'sealed'.  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br>  Der Analysator sagt, es sei gef√§hrlich, ein √ºberschriebenes oder virtuelles Ereignis zu verwenden.  Erl√§uterungen finden Sie in der <a href="https://www.viva64.com/en/w/v3119/">Beschreibung</a> der Diagnose.  Ich schrieb auch einen Artikel zu diesem Thema: " <a href="https://www.viva64.com/en/b/0453/">Virtuelle Ereignisse in C #: etwas ist schief gelaufen</a> ". <br><br>  Hier ist eine weitere √§hnliche unsichere Konstruktion: <br><br><ul><li>  V3119 Das Aufrufen eines √ºberschriebenen Ereignisses kann zu unvorhersehbarem Verhalten f√ºhren.  Erw√§gen Sie, Ereignis-Accessoren explizit zu implementieren, oder verwenden Sie das Schl√ºsselwort 'sealed'.  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Vielleicht das '??'  Der Bediener arbeitet anders als erwartet.  Seine Priorit√§t ist niedriger als die Priorit√§t anderer Operatoren im linken Teil.  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br>  Zum besseren Verst√§ndnis hier ein synthetisches Beispiel, das die urspr√ºngliche Logik dieses Codes demonstriert: <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br>  Der Fehler r√ºhrt von der Tatsache her, dass der Operator "*" eine h√∂here Priorit√§t hat als der Operator "??"  Betreiber.  So sollte der feste Code aussehen (mit Klammern): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br>  Ein weiterer √§hnlicher Fehler: <br><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Vielleicht das '??'  Der Bediener arbeitet anders als erwartet.  Seine Priorit√§t ist niedriger als die Priorit√§t anderer Operatoren im linken Teil.  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  Wie im vorherigen Fall hatte der Programmierer falsche Annahmen √ºber die Priorit√§t der Operatoren.  Der urspr√ºngliche Ausdruck, der an die <i>Math.Abs-</i> Methode √ºbergeben wird, wird wie folgt ausgewertet: <br><br><pre> <code class="cs hljs">(a ‚Äì b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  So sollte es behoben werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime ‚Äì (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3142/">V3142</a> [CWE-561] Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br>  Der Analysator ist der Ansicht, dass der Code des <i>OnPressed-Handlers</i> ab der zweiten <i>if-</i> Anweisung nicht mehr erreichbar ist.  Dies ergibt sich aus der Tatsache, dass die erste Bedingung immer wahr ist, dh, dass die <i>base.OnPressed-</i> Methode immer <i>false</i> <i>zur√ºckgibt</i> .  <i>Werfen</i> wir einen Blick auf die <i>base.OnPressed-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Und jetzt bei der <i>UpdateResult-</i> Methode: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br>  Beachten Sie, dass die Implementierung der <i>Judged-</i> Eigenschaft hier keine Rolle spielt, da die Logik der <i>UpdateResult-</i> Methode impliziert, dass die letzte <i>return-</i> Anweisung der folgenden entspricht: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Dies bedeutet, dass die <i>UpdateResult-</i> Methode die ganze Zeit <i>false</i> <i>zur√ºckgibt</i> , was zu dem fr√ºher im Stapel <i>aufgetretenen</i> Problem mit nicht erreichbarem Code f√ºhrt. <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> [CWE-476] M√∂gliche Null-Dereferenzierung von 'Regelsatz'.  Der 'FirstOrDefault' kann einen Standard-Nullwert zur√ºckgeben.  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br>  Der Analyzer ist der Ansicht, dass der Aufruf von <i>ruleset.CreateInstance ()</i> nicht sicher ist.  Vor diesem Aufruf <i>erh√§lt</i> die <i>Regelmengenvariable</i> einen Wert, wenn die <i>GetRuleset-</i> Methode <i>aufgerufen</i> wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br>  Wie Sie sehen, ist die Warnung g√ºltig, da die <i>Aufrufsequenz</i> die <i>FirstOrDefault-</i> Methode enth√§lt, die <i>null zur√ºckgeben kann</i> . <br><br><h2>  Fazit </h2><br>  Es gibt nicht viele Fehler im Code von "osu!". Und das ist gut so.  Ich empfehle den Autoren dennoch, die vom Analyseger√§t gemeldeten Probleme zu √ºberpr√ºfen.  Ich hoffe, dies wird dazu beitragen, die hohe Qualit√§t aufrechtzuerhalten, und das Spiel wird den Spielern weiterhin Freude bereiten. <br><br>  Zur Erinnerung, PVS-Studio ist eine gute Wahl, wenn Sie mit Quellcode basteln m√∂chten.  Der Analysator steht auf der offiziellen Website zum <a href="https://www.viva64.com/en/pvs-studio-download/">Download</a> zur Verf√ºgung.  Eine andere Sache, an die Sie denken sollten, ist, dass einmalige √úberpr√ºfungen wie diese nichts mit der normalen Verwendung der statischen Analyse im realen Entwicklungsprozess zu tun haben.  Es ist nur dann am effektivsten, wenn es regelm√§√üig sowohl auf dem Build-Server als auch auf den Computern der Entwickler verwendet wird (dies wird als inkrementelle Analyse bezeichnet).  Ihr oberstes Ziel ist es, zu verhindern, dass Fehler in das Versionskontrollsystem gelangen, indem Sie sie in der Codierungsphase abfangen. <br><br>  Viel Gl√ºck und bleiben Sie kreativ! <br><br><h2>  Referenzen </h2><br>  Dies ist unser erster Artikel im Jahr 2020. W√§hrend wir gerade dabei sind, finden Sie hier die Links zu den Pr√ºfungen von C # -Projekten, die im letzten Jahr durchgef√ºhrt wurden: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0605/">Suchen nach Fehlern im Amazon Web Services SDK-Quellcode f√ºr .NET</a> </li><li>  <a href="https://www.viva64.com/en/b/0622/">√úberpr√ºfen des Roslyn-Quellcodes</a> </li><li>  <a href="https://www.viva64.com/en/b/0631/">Nullf√§hige Referenztypen in C # 8.0 und statische Analyse</a> </li><li>  <a href="https://www.viva64.com/en/b/0653/">WinForms: Fehler, Holmes</a> </li><li>  <a href="https://www.viva64.com/en/b/0654/">Die Geschichte, wie PVS-Studio einen Fehler in der in ... PVS-Studio verwendeten Bibliothek gefunden hat</a> </li><li>  <a href="https://www.viva64.com/en/b/0656/">√úberpr√ºfen des .NET Core Libraries-Quellcodes mit dem PVS-Studio Static Analyzer</a> </li><li>  <a href="https://www.viva64.com/en/b/0664/">√úberpr√ºfung der Roslyn-Analyseger√§te</a> </li><li>  <a href="https://www.viva64.com/en/b/0677/">√úberpr√ºfen der Telerik-Benutzeroberfl√§che auf UWP als Einstieg in PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell: Meistens harmlos</a> </li><li>  <a href="https://www.viva64.com/en/b/0681/">Scannen des Orchard CMS-Codes auf Fehler</a> </li><li>  <a href="https://www.viva64.com/en/b/0683/">√úberpr√ºfen des OpenCvSharp-Wrappers auf OpenCV mit PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0692/">Azure SDK f√ºr .NET: Geschichte √ºber eine schwierige Fehlersuche</a> </li><li>  <a href="https://www.viva64.com/en/b/0694/">SARIF SDK und seine Fehler</a> </li><li>  <a href="https://www.viva64.com/en/b/0698/">Die 10 h√§ufigsten Fehler in C # -Projekten im Jahr 2019</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483436/">https://habr.com/ru/post/de483436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483416/index.html">Versuche Prozesse mit Powershell zu automatisieren</a></li>
<li><a href="../de483418/index.html">Ticketsysteme: Wie haben Sie drei kostenlose OTRS erhalten?</a></li>
<li><a href="../de483424/index.html">DBA: √úbertragung von SEQUENCE-Werten zwischen PostgreSQL-Datenbanken</a></li>
<li><a href="../de483426/index.html">Freitag Tab Umfrage</a></li>
<li><a href="../de483428/index.html">Wie wird die elektronische Dokumentenverwaltung nach Inkrafttreten von Gesetzes√§nderungen zur elektronischen Signatur aussehen?</a></li>
<li><a href="../de483438/index.html">Spielen Sie "osu!", Vergessen Sie Fehler nicht</a></li>
<li><a href="../de483440/index.html">Neueste D-Compiler</a></li>
<li><a href="../de483444/index.html">DORA-Bericht 2019: So verbessern Sie die DevOps-Leistung</a></li>
<li><a href="../de483446/index.html">Wissenschaftler haben einen neuen Weg gefunden, um den Eisengehalt im Trinkwasser zu senken</a></li>
<li><a href="../de483448/index.html">Disney - die gr√∂√üte Zwei-Wege in der Geschichte der Menschheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>