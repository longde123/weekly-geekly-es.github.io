<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏻 🛋️ 👩🏿‍🌾 Spielen Sie "osu!", Aber achten Sie auf Bugs 🏫 😞 🚽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ihr alle Sammler von exotischen und einfachen Käfern! Wir haben heute ein seltenes Exemplar auf unserem PVS-Studio-Prüfstand - ein Spiel namens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spielen Sie "osu!", Aber achten Sie auf Bugs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/483436/"><p><img src="https://habrastorage.org/getpro/habr/post_images/3ac/9da/a12/3ac9daa12b519fc14e45f7f65abdd204.png" alt="Bild 1" align="left"></p><br>  Hallo, ihr alle Sammler von exotischen und einfachen Käfern!  Wir haben heute ein seltenes Exemplar auf unserem PVS-Studio-Prüfstand - ein Spiel namens "osu!", Geschrieben in C #.  Wie üblich werden wir nach Bugs suchen, diese analysieren und spielen. <br><a name="habracut"></a><br><h2>  Das Spiel </h2><br>  Osu!  ist ein Open-Source-Rhythmus-Spiel.  Laut der <a href="https://osu.ppy.sh/home">Website</a> des Spiels ist es mit mehr als 15 Millionen Spielerkonten recht beliebt.  Das Projekt bietet kostenloses Gameplay, farbenfrohes Design, Kartenanpassung, ein erweitertes Online-Player-Ranking-System, einen Multiplayer-Modus und eine Vielzahl von Musikstücken.  Es macht keinen Sinn, das Spiel weiter zu erläutern.  Sie können alles darüber im Internet lesen.  Beginnen Sie mit <a href="https://en.wikipedia.org/wiki/Osu!">dieser Seite</a> . <br><br>  Ich interessiere mich mehr für den Quellcode des Projekts, der auf <a href="https://github.com/ppy/osu">GitHub</a> verfügbar ist.  Eine Sache, die sofort auffällt, ist die große Anzahl von Repository-Commits (über 24.000), was ein Zeichen intensiver, kontinuierlicher Entwicklung ist (das Spiel wurde erstmals 2007 veröffentlicht, aber die Arbeit muss noch früher begonnen haben).  Das Projekt ist jedoch nicht groß: Nur 1813 .cs-Dateien mit insgesamt 135.000 nicht leeren LOCs.  Diese Zahl beinhaltet auch Tests, die ich normalerweise bei der Durchführung von Prüfungen nicht berücksichtige.  Die Tests machen 306 der .cs-Dateien mit 25.000 LOC aus.  Das Projekt ist in der Tat klein: Zum Beispiel ist der C # -Kern von PVS-Studio ungefähr 300.000 LOC lang. <br><br>  Ich ließ die Testdateien weg und überprüfte 1507 Dateien mit einer Länge von 110.000 LOC.  Der Check hat ein paar interessante Fehler aufgedeckt, die ich Ihnen gerne zeigen möchte. <br><br><h2>  Die Käfer </h2><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Es gibt identische Unterausdrücke 'result == HitResult.Perfect' links und rechts vom '||'  Betreiber.  DrawableHoldNote.cs 266 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckForResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... ApplyResult(r =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holdNote.hasBroken &amp;&amp; (result == HitResult.Perfect || result == HitResult.Perfect)) result = HitResult.Good; .... }); }</code> </pre> <br>  Dies ist ein gutes Beispiel für kopierorientiertes Programmieren, ein humorvoller Begriff, den mein Kollege Valeriy Komarov kürzlich in seinem Artikel " <a href="https://www.viva64.com/en/b/0699/">Top 10 Bugs Found in Java Projects in 2019</a> " verwendet hat. <br><br>  Auf jeden Fall werden zwei identische Prüfungen hintereinander ausgeführt.  Eine von ihnen sollte wahrscheinlich eine andere Konstante der <i>HitResult-</i> Aufzählung <i>überprüfen</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HitResult { None, Miss, Meh, Ok, Good, Great, Perfect, }</code> </pre> <br>  Welche Konstante sollte überprüft werden?  Oder sollte der zweite Scheck gar nicht da sein?  Dies sind die Fragen, die nur die Autoren beantworten können.  Auf jeden Fall ist dies ein Fehler, der die Ausführungslogik des Programms verfälscht. <br><br>  <a href="https://www.viva64.com/en/w/v3001/">V3001</a> Es gibt identische Unterausdrücke 'family! = GetFamilyString (TournamentTypeface.Aquatico)' links und rechts vom Operator '&amp;&amp;'.  TournamentFont.cs 64 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeightString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> family, FontWeight weight</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight == FontWeight.Regular &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico) &amp;&amp; family != GetFamilyString(TournamentTypeface.Aquatico)) weightString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; .... }</code> </pre> <br>  Kopieren-Einfügen erneut.  Ich habe den Code überarbeitet, damit der Fehler jetzt leicht bemerkt wird, aber ursprünglich war er in einer Zeile geschrieben worden.  Wie im vorherigen Beispiel kann ich nicht genau sagen, wie dieses Problem behoben werden soll.  Die <i>TournamentTypeface-</i> Enumeration enthält nur eine Konstante: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TournamentTypeface { Aquatico }</code> </pre> <br>  Vielleicht liegt der Fehler darin, die <i>Familienvariable</i> zweimal zu überprüfen, aber ich kann mich irren. <br><br>  <a href="https://www.viva64.com/en/w/v3009/">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer denselben Wert von 'false' zurückgibt.  KeyCounterAction.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> forwards</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EqualityComparer&lt;T&gt;.Default.Equals(action, Action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; IsLit = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forwards) Increment(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Diese Methode gibt jedes Mal <i>false</i> zurück.  In solchen Fällen überprüfe ich normalerweise den Funktionsaufruf, da Sie häufig feststellen, dass der Aufrufer den Rückgabewert nicht verwendet, was bedeutet, dass es kein Problem gibt (außer einem schlechten Stil).  So sieht der Aufruf in diesem Fall aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T action</span></span></span><span class="hljs-function">)</span></span> =&gt; Target.Children .OfType&lt;KeyCounterAction&lt;T&gt;&gt;() .Any(c =&gt; c.OnPressed(action, Clock.Rate &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Wie Sie sehen, verwendet der Aufrufer den von der <i>OnPressed-</i> Methode zurückgegebenen Wert.  Da dieser Wert immer <i>falsch ist</i> , gibt der Aufrufer selbst immer auch <i>falsch zurück</i> .  Dieser Code enthält sehr wahrscheinlich einen Fehler und sollte überarbeitet werden. <br><br>  Ein weiterer ähnlicher Fehler: <br><br><ul><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer denselben Wert von 'false' zurückgibt.  KeyCounterAction.cs 30 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'val.NewValue'-Objekts TournamentTeam.cs 41 verwendet <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TournamentTeam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Acronym.ValueChanged += val =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) FlagName.Value = val.NewValue.Length &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= ? val.NewValue?.Substring(0, 2).ToUpper() : string.Empty; }; .... }</span></span></code> </pre> <br>  Die Variable <i>val.NewValue</i> wird unter der Bedingung <i>?:</i> Operator auf gefährliche Weise behandelt.  Was den Analyzer zu der Annahme veranlasst, ist die Tatsache, dass später in der <i>then-</i> Verzweigung dieselbe Variable auf sichere Weise mit dem Operator für bedingte Zugriffe behandelt wird: <i>val.NewValue? .Substring (....)</i> . <br><br>  Ein weiterer ähnlicher Fehler: <br><br><ul><li>  V3042 [CWE-476] Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'val.NewValue'-Objekts TournamentTeam.cs 48 verwendet </li></ul><br>  <a href="https://www.viva64.com/en/w/v3042/">V3042</a> [CWE-476] Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'api'-Objekts SetupScreen.cs 77 verwendet <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionableInfo { Label = <span class="hljs-string"><span class="hljs-string">"Current User"</span></span>, ButtonText = <span class="hljs-string"><span class="hljs-string">"Change Login"</span></span>, Action = () =&gt; { api.Logout(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }, Value = api?.LocalUser.Value.Username, .... }, .... } private class ActionableInfo : LabelledDrawable&lt;Drawable&gt; { .... public Action Action; .... }</span></span></code> </pre> <br>  Dieser ist mehrdeutig, aber ich glaube, es ist auch ein Fehler.  Der Programmierer erstellt ein Objekt vom Typ <i>ActionableInfo</i> .  Das Feld " <i>Aktion"</i> wird mit einer Lambda-Funktion initialisiert, die die potenziell Null-Referenz- <i>API</i> auf gefährliche Weise verarbeitet.  Der Analysator betrachtet dieses Muster als Fehler, da die <i>API-</i> Variable später bei der Initialisierung des Parameters <i>Value auf</i> sichere Weise behandelt wird.  Ich habe diesen Fall als mehrdeutig bezeichnet, weil der Code in der Lambda-Funktion eine verzögerte Ausführung impliziert, bis zu deren Ablauf der Entwickler möglicherweise garantiert, dass die <i>API-</i> Referenz nicht null ist.  Aber da bin ich mir nicht sicher, da der Körper der Lambda-Funktion anscheinend keine sichere Referenzbehandlung wie vorherige Überprüfungen verwendet. <br><br>  <a href="https://www.viva64.com/en/w/v3066/">V3066</a> [CWE-683] Mögliche falsche Reihenfolge der an die Methode 'Atan2' übergebenen Argumente: 'diff.X' und 'diff.Y'.  SliderBall.cs 182 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> completionProgress</span></span></span><span class="hljs-function">)</span></span> { .... Rotation = <span class="hljs-number"><span class="hljs-number">-90</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(-Math.Atan2(diff.X, diff.Y) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI); .... }</code> </pre> <br>  Der Analysator vermutet, dass die Argumente der <i>Atan2-</i> Methode in der falschen Reihenfolge übergeben werden.  Dies ist die Deklaration der Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Parameters: // y: // The y coordinate of a point. // // x: // The x coordinate of a point. public static double Atan2(double y, double x);</span></span></code> </pre> <br>  Die Werte wurden in umgekehrter Reihenfolge übergeben.  Ich bin nicht sicher, ob dies ein Fehler ist, da die <i>UpdateProgress-</i> Methode ziemlich viele nicht-triviale Berechnungen enthält.  Ich erwähne es nur als möglichen Fehler. <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> [CWE-476] Mögliche Null-Dereferenzierung.  Betrachten Sie 'Beatmap'.  WorkingBeatmap.cs 57 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Track </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObject = Beatmap.HitObjects.LastOrDefault(); .... }</code> </pre> <br>  Der Analyzer weist auf eine mögliche Null-Dereferenzierung von <i>Beatmap hin</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBeatmap Beatmap { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LoadBeatmapAsync().Result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TaskCanceledException) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br>  Nun, der Analysator ist korrekt. <br><br>  Weitere Informationen darüber, wie PVS-Studio solche Fehler erkennt und welche neuen Funktionen in C # 8.0 hinzugefügt wurden, die mit der Behandlung von potenziell <a href="https://www.viva64.com/en/b/0631/">leeren Referenzen</a> zu tun haben, finden Sie im Artikel " <a href="https://www.viva64.com/en/b/0631/">Nullbare Referenztypen in C # 8.0 und statische Analyse</a> ". <br><br>  <a href="https://www.viva64.com/en/w/v3083/">V3083</a> [CWE-367] Unsicherer Aufruf des Ereignisses 'ObjectConverted', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  BeatmapConverter.cs 82 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjectConverted != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { converted = converted.ToList(); ObjectConverted.Invoke(obj, converted); } .... }</code> </pre> <br>  Dies ist ein kleiner und recht häufiger Fehler.  Die Abonnenten können das Ereignis zwischen der Nullprüfung und dem Ereignisaufruf abbestellen, was zu einem Absturz führt.  Dies ist eine Möglichkeit, den Fehler zu beheben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertHitObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... converted = converted.ToList(); ObjectConverted?.Invoke(obj, converted); .... }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3095/">V3095</a> [CWE-476] Das Objekt 'columns' wurde verwendet, bevor es gegen null verifiziert wurde.  Zeilen überprüfen: 141, 142. SquareGraph.cs 141 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redrawProgress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ColumnCount; i++) columns[i].State = i &lt;= progress ? ColumnState.Lit : ColumnState.Dimmed; columns?.ForceRedraw(); }</code> </pre> <br>  Die Iteration über die <i>Spaltensammlung</i> erfolgt auf gefährliche Weise.  Der Entwickler ging davon aus, dass die <i>Spaltenreferenz</i> null sein könnte, was durch die Verwendung des Operators für den bedingten Zugriff angegeben wird, um im Code weiter auf die Auflistung zuzugreifen. <br><br>  <a href="https://www.viva64.com/en/w/v3119/">V3119 Das</a> Aufrufen des überschriebenen Ereignisses 'OnNewResult' kann zu unvorhersehbarem Verhalten führen.  Erwägen Sie, Ereignis-Accessoren explizit zu implementieren, oder verwenden Sie das Schlüsselwort 'sealed'.  DrawableRuleset.cs 256 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHitObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TObject hitObject</span></span></span><span class="hljs-function">)</span></span> { .... drawableObject.OnNewResult += (_, r) =&gt; OnNewResult?.Invoke(r); .... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;JudgementResult&gt; OnNewResult;</code> </pre> <br>  Der Analysator sagt, es sei gefährlich, ein überschriebenes oder virtuelles Ereignis zu verwenden.  Erläuterungen finden Sie in der <a href="https://www.viva64.com/en/w/v3119/">Beschreibung</a> der Diagnose.  Ich schrieb auch einen Artikel zu diesem Thema: " <a href="https://www.viva64.com/en/b/0453/">Virtuelle Ereignisse in C #: etwas ist schief gelaufen</a> ". <br><br>  Hier ist eine weitere ähnliche unsichere Konstruktion: <br><br><ul><li>  V3119 Das Aufrufen eines überschriebenen Ereignisses kann zu unvorhersehbarem Verhalten führen.  Erwägen Sie, Ereignis-Accessoren explizit zu implementieren, oder verwenden Sie das Schlüsselwort 'sealed'.  DrawableRuleset.cs 257 </li></ul><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Vielleicht das '??'  Der Bediener arbeitet anders als erwartet.  Seine Priorität ist niedriger als die Priorität anderer Operatoren im linken Teil.  OsuScreenStack.cs 45 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * ((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; }</code> </pre> <br>  Zum besseren Verständnis hier ein synthetisches Beispiel, das die ursprüngliche Logik dieses Codes demonstriert: <br><br><pre> <code class="cs hljs">x = (c * a) ?? b;</code> </pre> <br>  Der Fehler rührt von der Tatsache her, dass der Operator "*" eine höhere Priorität hat als der Operator "??"  Betreiber.  So sollte der feste Code aussehen (mit Klammern): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScreenChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IScreen prev, IScreen next</span></span></span><span class="hljs-function">)</span></span> { parallaxContainer.ParallaxAmount = ParallaxContainer.DEFAULT_PARALLAX_AMOUNT * (((IOsuScreen)next)?.BackgroundParallaxAmount ?? <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre> <br>  Ein weiterer ähnlicher Fehler: <br><br>  <a href="https://www.viva64.com/en/w/v3123/">V3123</a> [CWE-783] Vielleicht das '??'  Der Bediener arbeitet anders als erwartet.  Seine Priorität ist niedriger als die Priorität anderer Operatoren im linken Teil.  FramedReplayInputHandler.cs 103 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime - NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  Wie im vorherigen Fall hatte der Programmierer falsche Annahmen über die Priorität der Operatoren.  Der ursprüngliche Ausdruck, der an die <i>Math.Abs-</i> Methode übergeben wird, wird wie folgt ausgewertet: <br><br><pre> <code class="cs hljs">(a – b) ?? <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  So sollte es behoben werden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inImportantSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsImportant(frame) &amp;&amp; Math.Abs(CurrentTime – (NextFrame?.Time ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt;= AllowedImportantTimeSpan; } }</code> </pre> <br>  <a href="https://www.viva64.com/en/w/v3142/">V3142</a> [CWE-561] Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  DrawableHoldNote.cs 214 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnPressed(action)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Result.Type == HitResult.Miss) <span class="hljs-comment"><span class="hljs-comment">// &lt;= holdNote.hasBroken = true; .... }</span></span></code> </pre> <br>  Der Analysator ist der Ansicht, dass der Code des <i>OnPressed-Handlers</i> ab der zweiten <i>if-</i> Anweisung nicht mehr erreichbar ist.  Dies ergibt sich aus der Tatsache, dass die erste Bedingung immer wahr ist, dh, dass die <i>base.OnPressed-</i> Methode immer <i>false</i> <i>zurückgibt</i> .  <i>Werfen</i> wir einen Blick auf die <i>base.OnPressed-</i> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPressed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ManiaAction action</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action != Action.Value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UpdateResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Und jetzt bei der <i>UpdateResult-</i> Methode: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userTriggered</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.Elapsed &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Judged) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Judged; }</code> </pre> <br>  Beachten Sie, dass die Implementierung der <i>Judged-</i> Eigenschaft hier keine Rolle spielt, da die Logik der <i>UpdateResult-</i> Methode impliziert, dass die letzte <i>return-</i> Anweisung der folgenden entspricht: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Dies bedeutet, dass die <i>UpdateResult-</i> Methode die ganze Zeit <i>false</i> <i>zurückgibt</i> , was zu dem früher im Stapel <i>aufgetretenen</i> Problem mit nicht erreichbarem Code führt. <br><br>  <a href="https://www.viva64.com/en/w/v3146/">V3146</a> [CWE-476] Mögliche Null-Dereferenzierung von 'Regelsatz'.  Der 'FirstOrDefault' kann einen Standard-Nullwert zurückgeben.  APILegacyScoreInfo.cs 24 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ScoreInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScoreInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RulesetStore rulesets</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ruleset = rulesets.GetRuleset(OnlineRulesetID); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mods = Mods != <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? ruleset.CreateInstance() <span class="hljs-comment"><span class="hljs-comment">// &lt;= .GetAllMods().Where(....) .ToArray() : Array.Empty&lt;Mod&gt;(); .... }</span></span></code> </pre> <br>  Der Analyzer ist der Ansicht, dass der Aufruf von <i>ruleset.CreateInstance ()</i> nicht sicher ist.  Vor diesem Aufruf <i>erhält</i> die <i>Regelmengenvariable</i> einen Wert, wenn die <i>GetRuleset-</i> Methode <i>aufgerufen</i> wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RulesetInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRuleset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> =&gt; AvailableRulesets.FirstOrDefault(....);</code> </pre> <br>  Wie Sie sehen, ist die Warnung gültig, da die <i>Aufrufsequenz</i> die <i>FirstOrDefault-</i> Methode enthält, die <i>null zurückgeben kann</i> . <br><br><h2>  Fazit </h2><br>  Es gibt nicht viele Fehler im Code von "osu!". Und das ist gut so.  Ich empfehle den Autoren dennoch, die vom Analysegerät gemeldeten Probleme zu überprüfen.  Ich hoffe, dies wird dazu beitragen, die hohe Qualität aufrechtzuerhalten, und das Spiel wird den Spielern weiterhin Freude bereiten. <br><br>  Zur Erinnerung, PVS-Studio ist eine gute Wahl, wenn Sie mit Quellcode basteln möchten.  Der Analysator steht auf der offiziellen Website zum <a href="https://www.viva64.com/en/pvs-studio-download/">Download</a> zur Verfügung.  Eine andere Sache, an die Sie denken sollten, ist, dass einmalige Überprüfungen wie diese nichts mit der normalen Verwendung der statischen Analyse im realen Entwicklungsprozess zu tun haben.  Es ist nur dann am effektivsten, wenn es regelmäßig sowohl auf dem Build-Server als auch auf den Computern der Entwickler verwendet wird (dies wird als inkrementelle Analyse bezeichnet).  Ihr oberstes Ziel ist es, zu verhindern, dass Fehler in das Versionskontrollsystem gelangen, indem Sie sie in der Codierungsphase abfangen. <br><br>  Viel Glück und bleiben Sie kreativ! <br><br><h2>  Referenzen </h2><br>  Dies ist unser erster Artikel im Jahr 2020. Während wir gerade dabei sind, finden Sie hier die Links zu den Prüfungen von C # -Projekten, die im letzten Jahr durchgeführt wurden: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0605/">Suchen nach Fehlern im Amazon Web Services SDK-Quellcode für .NET</a> </li><li>  <a href="https://www.viva64.com/en/b/0622/">Überprüfen des Roslyn-Quellcodes</a> </li><li>  <a href="https://www.viva64.com/en/b/0631/">Nullfähige Referenztypen in C # 8.0 und statische Analyse</a> </li><li>  <a href="https://www.viva64.com/en/b/0653/">WinForms: Fehler, Holmes</a> </li><li>  <a href="https://www.viva64.com/en/b/0654/">Die Geschichte, wie PVS-Studio einen Fehler in der in ... PVS-Studio verwendeten Bibliothek gefunden hat</a> </li><li>  <a href="https://www.viva64.com/en/b/0656/">Überprüfen des .NET Core Libraries-Quellcodes mit dem PVS-Studio Static Analyzer</a> </li><li>  <a href="https://www.viva64.com/en/b/0664/">Überprüfung der Roslyn-Analysegeräte</a> </li><li>  <a href="https://www.viva64.com/en/b/0677/">Überprüfen der Telerik-Benutzeroberfläche auf UWP als Einstieg in PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0678/">Azure PowerShell: Meistens harmlos</a> </li><li>  <a href="https://www.viva64.com/en/b/0681/">Scannen des Orchard CMS-Codes auf Fehler</a> </li><li>  <a href="https://www.viva64.com/en/b/0683/">Überprüfen des OpenCvSharp-Wrappers auf OpenCV mit PVS-Studio</a> </li><li>  <a href="https://www.viva64.com/en/b/0692/">Azure SDK für .NET: Geschichte über eine schwierige Fehlersuche</a> </li><li>  <a href="https://www.viva64.com/en/b/0694/">SARIF SDK und seine Fehler</a> </li><li>  <a href="https://www.viva64.com/en/b/0698/">Die 10 häufigsten Fehler in C # -Projekten im Jahr 2019</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483436/">https://habr.com/ru/post/de483436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483416/index.html">Versuche Prozesse mit Powershell zu automatisieren</a></li>
<li><a href="../de483418/index.html">Ticketsysteme: Wie haben Sie drei kostenlose OTRS erhalten?</a></li>
<li><a href="../de483424/index.html">DBA: Übertragung von SEQUENCE-Werten zwischen PostgreSQL-Datenbanken</a></li>
<li><a href="../de483426/index.html">Freitag Tab Umfrage</a></li>
<li><a href="../de483428/index.html">Wie wird die elektronische Dokumentenverwaltung nach Inkrafttreten von Gesetzesänderungen zur elektronischen Signatur aussehen?</a></li>
<li><a href="../de483438/index.html">Spielen Sie "osu!", Vergessen Sie Fehler nicht</a></li>
<li><a href="../de483440/index.html">Neueste D-Compiler</a></li>
<li><a href="../de483444/index.html">DORA-Bericht 2019: So verbessern Sie die DevOps-Leistung</a></li>
<li><a href="../de483446/index.html">Wissenschaftler haben einen neuen Weg gefunden, um den Eisengehalt im Trinkwasser zu senken</a></li>
<li><a href="../de483448/index.html">Disney - die größte Zwei-Wege in der Geschichte der Menschheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>