<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÅ üìâ üë©üèø‚Äçüè≠ MVCC in PostgreSQL-5. In-Page-Vakuum und HOT-Updates ü§≤üèΩ üò¥ üë≤üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zur Erinnerung, wir haben bereits Probleme im Zusammenhang mit der Isolation besprochen, einen Exkurs zur Datenstruktur auf niedriger Ebene gemacht un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-5. In-Page-Vakuum und HOT-Updates</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/483768/">  Zur Erinnerung, wir haben bereits Probleme im Zusammenhang mit der <a href="https://habr.com/ru/company/postgrespro/blog/467437/">Isolation</a> besprochen, einen Exkurs zur <a href="https://habr.com/ru/company/postgrespro/blog/469087/">Datenstruktur</a> auf <a href="https://habr.com/ru/company/postgrespro/blog/469087/">niedriger Ebene gemacht</a> und dann die <a href="https://habr.com/ru/company/postgrespro/blog/477648/">Zeilenversionen untersucht</a> und beobachtet, wie <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Datenschnappsch√ºsse</a> aus Zeilenversionen abgerufen werden. <br><br>  Nun werden zwei eng miteinander verbundene Probleme behandelt: <em>In-Page-Vakuum</em> und <em>HOT-Updates</em> .  Beide Techniken k√∂nnen auf Optimierungen bezogen werden;  Sie sind wichtig, werden jedoch in der Dokumentation praktisch nicht behandelt. <br><br><h1>  In-Page-Vakuum w√§hrend regelm√§√üiger Updates </h1><br>  Wenn PostgreSQL beim Zugriff auf eine Seite f√ºr ein Update oder einen Lesevorgang feststellt, dass auf der Seite nicht mehr gen√ºgend Speicherplatz vorhanden ist, kann ein schnelles Unterdrucken der Seite durchgef√ºhrt werden.  Dies geschieht in beiden F√§llen: <br><br><ol><li>  In einem vorherigen Update auf dieser Seite wurde nicht gen√ºgend Speicherplatz gefunden, um eine neue Zeilenversion auf derselben Seite zuzuweisen.  Eine solche Situation wird im Seitenkopf gespeichert und beim n√§chsten Mal wird die Seite gesaugt. </li><li> Die Seite ist zu mehr als <code>fillfactor</code> Prozent <code>fillfactor</code> .  In diesem Fall wird sofort abgesaugt, ohne bis zum n√§chsten zu warten. </li></ol><a name="habracut"></a><br>  <code>fillfactor</code> ist ein Speicherparameter, der f√ºr eine Tabelle (und f√ºr einen Index) definiert werden kann.  PostgresSQL f√ºgt nur dann eine neue Zeile in eine Seite ein, wenn die Seite zu weniger als <code>fillfactor</code> Prozent <code>fillfactor</code> .  Der verbleibende Speicherplatz ist f√ºr neue Tupel reserviert, die aufgrund von Aktualisierungen erstellt werden.  Der Standardwert f√ºr Tabellen ist 100, dh, es ist kein Speicherplatz reserviert (und der Standardwert f√ºr Indizes ist 90). <br><br>  In-Page-Vakuum l√∂scht Tupel, die in keinem Snapshot sichtbar sind (jenseits des <a href="https://habr.com/ru/company/postgrespro/blog/479512/">zuletzt</a> diskutierten Transaktionshorizonts der Datenbank), dies jedoch ausschlie√ülich innerhalb einer Tabellenseite.  Zeiger auf vakuumierte Tupel werden nicht freigegeben, da sie aus Indizes referenziert werden k√∂nnen und sich ein Index auf einer anderen Seite befindet.  Das In-Page-Vakuum reicht nie √ºber eine Tabellenseite hinaus, sondern arbeitet sehr schnell. <br><br>  Aus den gleichen Gr√ºnden wird die Karte mit dem freien Speicherplatz nicht aktualisiert.  Dies reserviert auch den zus√§tzlichen Platz f√ºr Aktualisierungen und nicht f√ºr Einf√ºgungen.  Die Sichtbarkeitskarte wird ebenfalls nicht aktualisiert. <br><br>  Die Tatsache, dass eine Seite w√§hrend des Lesens gesaugt werden kann, bedeutet, dass eine SELECT-Abfrage einen Seitenwechsel nach sich ziehen kann.  Dies ist ein weiterer Fall wie dieser, zus√§tzlich zu einer verz√∂gerten √Ñnderung von Hinweisbits, die zuvor er√∂rtert wurde. <br><br>  Betrachten wir ein Beispiel, wie es funktioniert.  Lassen Sie uns eine Tabelle und Indizes f√ºr beide Spalten erstellen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> hot(id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">2000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">75</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_id <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> hot(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> hot(s);</code> </pre><br>  Wenn in der Spalte <code>s</code> nur lateinische Zeichen gespeichert sind, belegt jede Zeilenversion 2004 Byte plus 24 Byte eines Headers.  Wir setzen den <code>fillfactor</code> Speicherparameter auf 75%, was gerade genug Platz f√ºr drei Zeilen reserviert. <br><br>  Um sich den Inhalt der Tabellenseite bequem anzusehen, erstellen wir eine bereits bekannte Funktion neu, indem wir der Ausgabe zwei weitere Felder hinzuf√ºgen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, hhu <span class="hljs-type"><span class="hljs-type">text</span></span>, hot <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask2 &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">16384</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'t'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> hhu, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask2 &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">32768</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'t'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> hot, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Erstellen wir auch eine Funktion, um in die Indexseite zu schauen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(itemoffset <span class="hljs-type"><span class="hljs-type">smallint</span></span>, ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> itemoffset, ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> bt_page_items(relname,pageno); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Lassen Sie uns √ºberpr√ºfen, wie In-Page-Vakuum funktioniert.  Dazu f√ºgen wir eine Zeile ein und √§ndern sie mehrmals: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'D'</span></span>;</code> </pre><br>  Die Seite enth√§lt jetzt vier Tupel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 3979 (c) | 3980 (c) | | | (0,2) (0,2) | normal | 3980 (c) | 3981 (c) | | | (0,3) (0,3) | normal | 3981 (c) | 3982 | | | (0,4) (0,4) | normal | 3982 | 0 (a) | | | (0,4) (4 rows)</code> </pre><br>  Wie erwartet haben wir gerade den <code>fillfactor</code> Schwellenwert √ºberschritten.  Dies geht aus dem Unterschied zwischen dem <code>pagesize</code> und den <code>upper</code> Werten hervor: Es √ºberschreitet den Schwellenwert, der 75% der Seitengr√∂√üe entspricht, was 6144 Bytes ergibt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | pagesize -------+-------+---------- 40 | 64 | 8192 (1 row)</code> </pre><br>  Wenn das n√§chste Mal auf die Seite zugegriffen wird, muss ein In-Page-Vakuum auftreten.  Lassen Sie uns das √ºberpr√ºfen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'E'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | dead | | | | | (0,2) | dead | | | | | (0,3) | dead | | | | | (0,4) | normal | 3982 (c) | 3983 | | | (0,5) (0,5) | normal | 3983 | 0 (a) | | | (0,5) (5 rows)</code> </pre><br>  Alle toten Tupel (0,1), (0,2) und (0,3) werden abgesaugt;  danach wird ein neues Tupel (0.5) in den freigegebenen Raum eingef√ºgt. <br><br>  Die Tupel, die das Staubsaugen √ºberstanden haben, werden physisch zu hohen Adressen der Seite verschoben, sodass der gesamte freie Speicherplatz durch einen zusammenh√§ngenden Bereich dargestellt wird.  Die Werte der Zeiger werden entsprechend ge√§ndert.  Dadurch entstehen keine Probleme mit der Fragmentierung des freien Speicherplatzes auf einer Seite. <br><br>  Zeiger auf vakuumierte Tupel k√∂nnen nicht freigegeben werden, da sie auf der Indexseite referenziert sind.  <code>hot_s</code> wir einen Blick auf die erste Seite des <code>hot_s</code> Index (da Seite Null von Metainformationen belegt ist): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) 4 | (0,4) 5 | (0,5) (5 rows)</code> </pre><br>  Das gleiche Bild sehen wir auch im anderen Index: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,5) 2 | (0,4) 3 | (0,3) 4 | (0,2) 5 | (0,1) (5 rows)</code> </pre><br>  Sie werden vielleicht bemerken, dass Zeiger auf Tabellenzeilen in umgekehrter Reihenfolge folgen, aber das macht keinen Unterschied, da alle Tupel den gleichen Wert haben: id = 1.  Im vorherigen Index sind die Zeiger jedoch nach den Werten von <code>s</code> geordnet, und dies ist von wesentlicher Bedeutung. <br><br>  Beim Indexzugriff kann PostgreSQL (0,1), (0,2) oder (0,3) als Tupel-IDs erhalten.  Anschlie√üend wird versucht, die entsprechende Zeilenversion von der Tabellenseite abzurufen. Aufgrund des Status "tot" des Zeigers stellt PostgreSQL jedoch fest, dass eine solche Version nicht mehr vorhanden ist, und ignoriert sie.  (Nachdem PostgreSQL einmal festgestellt hat, dass die Version einer Tabellenzeile nicht verf√ºgbar ist, √§ndert es den Zeigerstatus auf der Indexseite, um nicht mehr auf die Tabellenseite zuzugreifen.) <br><br>  Es ist wichtig, dass In-Page-Vakuum nur innerhalb einer Tabellenseite funktioniert und keine Indexseiten saugt. <br><br><h1>  HEISSE Updates </h1><br>  Warum ist es nicht sinnvoll, Verweise auf alle Zeilenversionen im Index zu speichern? <br><br>  Bei jeder √Ñnderung der Zeile m√ºssen zun√§chst alle f√ºr die Tabelle erstellten Indizes aktualisiert werden: Sobald eine neue Version erstellt wurde, muss auf diese verwiesen werden.  Und das m√ºssen wir auf jeden Fall tun, auch wenn die Felder ge√§ndert werden, die nicht indiziert sind.  Dies ist offensichtlich nicht sehr effizient. <br><br>  Zweitens akkumulieren Indizes Verweise auf historische Tupel, die dann zusammen mit den Tupeln selbst abgesaugt werden m√ºssen (wir werden etwas sp√§ter diskutieren, wie dies gemacht wird). <br><br>  Dar√ºber hinaus hat B-Tree in PostgreSQL die Implementierungsspezifikationen.  Wenn auf einer Indexseite nicht gen√ºgend Platz zum Einf√ºgen einer neuen Zeile vorhanden ist, wird die Seite zweigeteilt und alle Daten zwischen ihnen verteilt.  Dies wird als Seitenaufteilung bezeichnet.  Wenn jedoch Zeilen gel√∂scht werden, werden die beiden Indexseiten nicht zu einer zusammengef√ºhrt.  Aus diesem Grund kann die Indexgr√∂√üe m√∂glicherweise nicht verringert werden, selbst wenn ein erheblicher Teil der Daten gel√∂scht wird. <br><br>  Je mehr Indizes f√ºr eine Tabelle erstellt werden, desto komplexer wird es nat√ºrlich. <br><br>  Wenn jedoch ein Wert in einer Spalte ge√§ndert wird, die √ºberhaupt nicht indiziert ist, ist es nicht sinnvoll, eine zus√§tzliche B-Baum-Zeile zu erstellen, die denselben Wert des Schl√ºssels enth√§lt.  Genau so funktioniert die Optimierung mit dem Namen <em>HOT Update</em> (Heap-Only Tuple Update). <br><br>  W√§hrend dieses Updates enth√§lt die Indexseite nur eine Zeile, die auf die allererste Version der Zeile auf der Tabellenseite verweist.  Und es ist bereits in der Tabellenseite, dass eine Kette von Tupeln organisiert ist: <br><br><ul><li>  Aktualisierte Zeilen in der Kette sind mit dem Bit Heap Hot Updated gekennzeichnet. </li><li>  Zeilen, auf die nicht aus dem Index verwiesen wird, sind mit dem Bit Heap Only Tuple gekennzeichnet. </li><li>  Zeilenversionen werden wie gewohnt √ºber das Feld <code>ctid</code> verkn√ºpft. </li></ul><br>  Wenn PostgreSQL w√§hrend des Index-Scans auf eine Tabellenseite zugreift und ein Tupel mit der Bezeichnung Heap Hot Updated findet, sollte es nicht aufh√∂ren, sondern der HOT-Kette folgen, wobei jedes Tupel darin ber√ºcksichtigt wird.  Nat√ºrlich wird f√ºr alle auf diese Weise erhaltenen Tupel die Sichtbarkeit √ºberpr√ºft, bevor sie an den Client zur√ºckgegeben werden. <br><br>  Um zu beobachten, wie ein HOT-Update funktioniert, l√∂schen wir einen Index und l√∂schen die Tabelle. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> hot_s; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> hot;</code> </pre><br>  Jetzt wiederholen wir das Einf√ºgen und Aktualisieren einer Zeile. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Und das sehen wir auf der Tabellenseite: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | normal | 3986 (c) | 3987 | t | | (0,2) (0,2) | normal | 3987 | 0 (a) | | t | (0,2) (2 rows)</code> </pre><br>  Es gibt eine Reihe von √Ñnderungen auf der Seite: <br><br><ul><li>  Das Flag Heap Hot Updated gibt an, dass die <code>ctid</code> Kette <code>ctid</code> muss. </li><li>  Das Heap Only Tuple-Flag gibt an, dass dieses Tupel nicht aus Indizes referenziert wird. </li></ul><br>  Die Kette w√§chst (innerhalb der Seite) mit weiteren √Ñnderungen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'D'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 3986 (c) | 3987 (c) | t | | (0,2) (0,2) | normal | 3987 (c) | 3988 (c) | t | t | (0,3) (0,3) | normal | 3988 (c) | 3989 | t | t | (0,4) (0,4) | normal | 3989 | 0 (a) | | t | (0,4) (4 rows)</code> </pre><br>  Der Index enth√§lt jedoch nur einen Verweis auf den Kopf der Kette: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) (1 row)</code> </pre><br>  Hervorzuheben ist, dass HOT-Aktualisierungen in dem Fall funktionieren, in dem die zu aktualisierenden Felder √ºberhaupt nicht indiziert sind.  Andernfalls w√ºrde ein Index einen Verweis direkt auf eine neue Zeilenversion enthalten, was mit dem Konzept dieser Optimierung nicht kompatibel ist. <br><br>  Die Optimierung funktioniert nur auf einer Seite. Daher ben√∂tigt ein zus√§tzlicher Durchgang durch die Kette keinen Zugriff auf andere Seiten und beeintr√§chtigt die Leistung nicht. <br><br><h1>  In-Page-Vakuum w√§hrend HOT-Updates </h1><br>  Das Staubsaugen w√§hrend HOT-Updates ist ein spezieller, aber wichtiger Fall von In-Page-Vakuum. <br><br>  Nach wie vor haben wir den <code>fillfactor</code> Schwellenwert bereits √ºberschritten, daher muss das n√§chste Update ein In-Page-Vakuum verursachen.  Aber dieses Mal gibt es eine Reihe von Updates auf der Seite.  Der Kopf dieser HOT-Kette muss immer dort bleiben, wo er ist, da auf ihn vom Index verwiesen wird, w√§hrend der Rest der Zeiger freigegeben werden kann: Es ist bekannt, dass sie keine Referenzen von au√üen haben. <br><br>  Um den Kopfzeiger nicht zu ber√ºhren, wird eine indirekte Adressierung verwendet: Der Zeiger, auf den der Index (in diesem Fall 0,1) verweist, erh√§lt den Status "Weiterleiten", der zum entsprechenden Tupel weiterleitet. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'E'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+-------+-----+-----+-------- (0,1) | redirect to 4 | | | | | (0,2) | normal | 3990 | 0 (a) | | t | (0,2) (0,3) | unused | | | | | (0,4) | normal | 3989 (c) | 3990 | t | t | (0,2) (4 rows)</code> </pre><br>  Beachten Sie, dass: <br><br><ul><li>  Die Tupel (0,1), (0,2) und (0,3) wurden abgesaugt. </li><li>  Der Kopfzeiger (0,1) bleibt erhalten, hat jedoch den Status "Weiterleiten" erhalten. </li><li>  Die neue Zeilenversion hat (0,2) √ºberschrieben, da es mit Sicherheit keine Verweise auf dieses Tupel gab und der Zeiger freigegeben wurde (Status "unbenutzt"). </li></ul><br>  Lass uns ein Update mehrmals durchf√ºhren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'F'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 4 | | | | | (0,2) | normal | 3990 (c) | 3991 (c) | t | t | (0,3) (0,3) | normal | 3991 (c) | 3992 | t | t | (0,5) (0,4) | normal | 3989 (c) | 3990 (c) | t | t | (0,2) (0,5) | normal | 3992 | 0 (a) | | t | (0,5) (5 rows)</code> </pre><br>  Das n√§chste Update f√ºhrt erneut zu In-Page-Vacuuming: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'H'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+-------+-----+-----+-------- (0,1) | redirect to 5 | | | | | (0,2) | normal | 3993 | 0 (a) | | t | (0,2) (0,3) | unused | | | | | (0,4) | unused | | | | | (0,5) | normal | 3992 (c) | 3993 | t | t | (0,2) (5 rows)</code> </pre><br>  Auch hier werden einige Tupel abgesaugt und der Zeiger auf den Kopf der Kette entsprechend bewegt. <br><br>  Fazit: Wenn Spalten, die nicht indiziert sind, h√§ufig aktualisiert werden, ist es m√∂glicherweise sinnvoll, den Parameter <code>fillfactor</code> zu reduzieren, um Seitenbereich f√ºr Aktualisierungen zu reservieren.  Wir sollten jedoch ber√ºcksichtigen, dass je kleiner der <code>fillfactor</code> , desto mehr freier Speicherplatz auf einer Seite <code>fillfactor</code> , sodass die physische Gr√∂√üe der Tabelle zunimmt. <br><br><h1>  Bruch einer hei√üen Kette </h1><br>  Wenn auf der Seite nicht gen√ºgend Speicherplatz f√ºr die Zuweisung eines neuen Tupels vorhanden ist, wird die Kette unterbrochen.  Und wir m√ºssen einen separaten Verweis vom Index auf die Zeilenversion auf einer anderen Seite erstellen. <br><br>  Um diese Situation zu reproduzieren, starten wir eine gleichzeitige Transaktion und erstellen den Datenschnappschuss. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hot;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 1 | (1 row)</code> </pre><br>  Mit dem Schnappschuss k√∂nnen die Tupel auf der Seite nicht abgesaugt werden.  Jetzt machen wir ein Update in der ersten Sitzung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'I'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'J'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'K'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 2 | | | | | (0,2) | normal | 3993 (c) | 3994 (c) | t | t | (0,3) (0,3) | normal | 3994 (c) | 3995 (c) | t | t | (0,4) (0,4) | normal | 3995 (c) | 3996 | t | t | (0,5) (0,5) | normal | 3996 | 0 (a) | | t | (0,5) (5 rows)</code> </pre><br>  Beim n√§chsten Update hat die Seite nicht gen√ºgend Speicherplatz, aber das In-Page-Vakuum kann nichts wegsaugen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> hot <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'L'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- snapshot no longer needed</span></span></code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+---------------+----------+----------+-----+-----+-------- (0,1) | redirect to 2 | | | | | (0,2) | normal | 3993 (c) | 3994 (c) | t | t | (0,3) (0,3) | normal | 3994 (c) | 3995 (c) | t | t | (0,4) (0,4) | normal | 3995 (c) | 3996 (c) | t | t | (0,5) (0,5) | normal | 3996 (c) | 3997 | | t | (1,1) (5 rows)</code> </pre><br>  Im Tupel (0,5) befindet sich ein Verweis auf (1,1) auf Seite 1. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'hot'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+------+-------+-----+-----+-------- (1,1) | normal | 3997 | 0 (a) | | | (1,1) (1 row)</code> </pre><br>  Der Index enth√§lt jetzt zwei Zeilen, die jeweils auf den Anfang der HOT-Kette verweisen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'hot_id'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (1,1) 2 | (0,1) (2 rows)</code> </pre><br><blockquote>  Leider fehlen in der Dokumentation praktisch Informationen zu In-Page-Vakuum- und HOT-Updates, und Sie sollten im Quellcode nach Antworten suchen.  Ich <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dblob%3Bf%3Dsrc/backend/access/heap/README.HOT%3Bhb%3DHEAD">rate</a> Ihnen, mit <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dblob%3Bf%3Dsrc/backend/access/heap/README.HOT%3Bhb%3DHEAD">README.HOT</a> zu beginnen. <br></blockquote><br>  <a href="https://habr.com/ru/company/postgrespro/blog/484106/">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483768/">https://habr.com/ru/post/de483768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483754/index.html">Wie kann man die Teamverbesserung messen?</a></li>
<li><a href="../de483756/index.html">Wir stellen HTTP-Anfragen, verschlechtern die Qualit√§t (und nicht eine einzige L√ºcke)</a></li>
<li><a href="../de483758/index.html">Top 10 Startups von Mobile Application Development-Unternehmen k√∂nnen 2020 eine Partnerschaft eingehen</a></li>
<li><a href="../de483762/index.html">GitLab 12.6 mit Project Safety Ratings und Release Materials ver√∂ffentlicht</a></li>
<li><a href="../de483766/index.html">Gerichte als Instrument des Social Hacking oder ein wenig √ºber die Zuverl√§ssigkeit von Informationen in den WHOIS-Datenbanken</a></li>
<li><a href="../de483770/index.html">Auf dem Weg zur SSL-Automatisierung</a></li>
<li><a href="../de483774/index.html">Die Zusammenfassung der Ereignisse f√ºr Personalfachleute in der IT f√ºr Januar 2020</a></li>
<li><a href="../de483776/index.html">Einf√ºhrung in die semantische Differentialmethode in 5 Minuten</a></li>
<li><a href="../de483778/index.html">Sicherheitswoche 03: Verantwortungsvolle Fehlerberichte</a></li>
<li><a href="../de483780/index.html">Was ist Slack und wie funktioniert es?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>