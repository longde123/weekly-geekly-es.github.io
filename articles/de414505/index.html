<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤šğŸ½ ğŸ‘¨ğŸ¼â€ğŸ”¬ ğŸšµğŸ¿ MIT-Kurs "Computer Systems Security". Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ, Teil 1 ğŸ„ ğŸƒ ğŸ’›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/414505/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die VortrÃ¤ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefÃ¤hrden, und Sicherheitstechniken, die auf jÃ¼ngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehÃ¶ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: â€EinfÃ¼hrung: Bedrohungsmodelleâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  <b>James Mickens:</b> In der vorherigen Vorlesung haben wir alles Ã¼ber PufferÃ¼berlaufangriffe gelernt, und heute werden wir einige Methoden zum Starten dieser Angriffe weiter diskutieren.  Die Grundidee hinter einem PufferÃ¼berlaufangriff lautet wie folgt. <br><br><img src="https://habrastorage.org/webt/ii/9r/h5/ii9rh5-e9oyrvipsizqgmnoln10.jpeg"><br><br>  ZunÃ¤chst stelle ich fest, dass diese Angriffe verschiedene UmstÃ¤nde betreffen.  Der erste Umstand, den sie verwenden, ist, dass Systemsoftware hÃ¤ufig in C geschrieben ist. <br><br>  Mit Systemsoftware meine ich Datenbanken, Compiler, Netzwerkserver und dergleichen.  Sie kÃ¶nnen sich an so etwas wie Ihre Lieblingsbefehlsshell erinnern.  All diese â€Softwareâ€œ ist normalerweise in C geschrieben. Warum in C?  Zum einen ist es schneller und zum anderen gilt C als Assembler auf hoher Ebene, der die Anforderungen einer Vielzahl von Hardwareplattformen am besten erfÃ¼llt.  Daher sind alle kritischen Systeme in dieser einfachen Programmiersprache geschrieben.  Das Problem mit in C geschriebener Software besteht darin, dass sie wirklich Rohspeicheradressen verwendet und keine Tools oder Softwaremodule zum ÃœberprÃ¼fen dieser Adressen hat.  In einigen FÃ¤llen kann dies katastrophale Folgen haben. <br><br>  Warum gibt es in C keine Array-IndexprÃ¼fung, dh keine RandprÃ¼fung?  Ein Grund ist, dass die Hardware dies nicht tut.  Und Leute, die in C schreiben, wollen normalerweise die schnellstmÃ¶gliche ProgrammausfÃ¼hrungsgeschwindigkeit.  Ein weiterer Grund ist, dass es in C, wie wir spÃ¤ter diskutieren, tatsÃ¤chlich sehr schwierig ist, die Semantik zu definieren, was ein Zeiger ist und inwieweit er wirken sollte.  Daher wÃ¤re es in einigen FÃ¤llen sehr schwierig, Softwareprozesse in C zu automatisieren. <br>  Lassen Sie uns einige Technologien diskutieren, die tatsÃ¤chlich versuchen, eine Art automatische Speicherverwaltung zu erstellen.  Aber wie wir sehen werden, ist keine dieser Methoden vollstÃ¤ndig â€kugelsicherâ€œ. <br><br>  DarÃ¼ber hinaus verwenden PufferÃ¼berlaufangriffe x86-Kenntnisse der Architektur, z. B. in welche Richtung der Stapel wÃ¤chst.  Was ist eine Aufrufkonvention fÃ¼r Funktionen?  Wie sieht der Stapel aus, wenn Sie auf Funktion C zugreifen?  Und wie sehen diese ausgewÃ¤hlten Hauptstrukturen aus, wenn Sie ein Objekt auf dem Heap auswÃ¤hlen? <br><br>  Schauen wir uns ein einfaches Beispiel an.  Dies ist sehr Ã¤hnlich zu dem, was Sie in der letzten Vorlesung gesehen haben.  Also, hier haben wir eine Standard-Leseanforderung, und dann bekommen wir einen Puffer, hier kommt das kanonische <b>int i</b> , gefolgt vom berÃ¼chtigten get-Befehl.  Und unten haben wir andere notwendige Dinge. <br><br><img src="https://habrastorage.org/webt/ay/gn/u0/aygnu0xbps6qt4pqoarpqe_jjgq.jpeg"><br><br>  Wie wir letzte Woche in der Vorlesung besprochen haben, ist das problematisch, oder?  Da dies <b>eine</b> Operation erhÃ¤lt, werden die Puffergrenzen nicht Ã¼berprÃ¼ft.  Wenn der Benutzer den Puffer mit Daten fÃ¼llt und wir diese unsichere Funktion hier verwenden, kÃ¶nnen wir den Puffer tatsÃ¤chlich Ã¼berlaufen lassen.  Wir kÃ¶nnen den gesamten Inhalt des Stapels neu schreiben.  Ich mÃ¶chte Sie daran erinnern, wie es aussieht. <br><br>  Ganz unten befindet sich das Array "i".  Ein Puffer befindet sich darÃ¼ber, er hat die erste Adresse unten und die letzte oben.  In jedem Fall haben wir Ã¼ber dem Puffer den gespeicherten Wert des LÃ¼ckenindikators - den gespeicherten Wert EBP.  DarÃ¼ber befindet sich die RÃ¼cksprungadresse fÃ¼r die Funktion, und noch hÃ¶her sind einige Dinge aus dem vorherigen Frame. <br><br>  Und vergessen Sie nicht, dass hier unten links von "i" ein ESP-Stapelzeiger angezeigt wird und ein neuer Unterbrechungszeiger im gespeicherten EBP-Bereich angezeigt wird.  Die RÃ¼cksprungadresse enthÃ¤lt ESP, und der Rest des vorherigen Frames enthÃ¤lt einen Haltepunkt. <br><br><img src="https://habrastorage.org/webt/xq/y8/7h/xqy87haonu0ryqknxcmuxvessrk.jpeg"><br><br>  Ich mÃ¶chte Sie daran erinnern, dass der Stapel Ã¼berlÃ¤uft, indem Daten in Richtung dieses Pfeils nach rechts nach oben gesammelt werden.  Wenn die get-Operation gestartet wird, beginnen wir, Bytes in den Puffer zu schreiben. Am Ende beginnt sie, alles zu Ã¼berschreiben, was sich stromaufwÃ¤rts befindet.  GrundsÃ¤tzlich sollte Ihnen alles bekannt vorkommen. <br><br>  Was unternimmt ein Angreifer, um dies auszunutzen?  GrundsÃ¤tzlich wird eine lange Datenfolge eingegeben.  Daher ist die SchlÃ¼sselidee, dass eine solche Technik verwendet werden kann, um anzugreifen. <br><br>  Und wenn die RÃ¼cksprungadresse vom Angreifer erfasst wird, kann er bestimmen, wohin die Funktion nach dem Ãœberlauf springen wird.  Das heiÃŸt, das einzige, was ein Hacker tun kann, ist, die Absenderadresse abzufangen und zu springen, wohin er will.  Meistens fÃ¼hren Angreifer Code mit Berechtigungen aus, um den Abfangprozess zu steuern. <br><br>  Wenn dieser Prozess beispielsweise eine hohe PrioritÃ¤t hatte, wurde er als Root oder Administrator ausgefÃ¼hrt, unabhÃ¤ngig davon, wie wir den Superuser Ihres bevorzugten Betriebssystems nennen. Jetzt kann dieses Programm, das von einem Angreifer gesteuert wird, mit den Berechtigungen dieser PrioritÃ¤t alles tun, was es will.  So kann ein Hacker Dateien lesen oder Spam senden, wenn er einen Mailserver beschÃ¤digt hat.  Es kann sogar Firewalls besiegen, da die Idee einer Firewall darin besteht, dass sich dahinter â€guteâ€œ und dahinter â€schlechteâ€œ Maschinen befinden.  In der Regel â€vertrauenâ€œ sich die Computer in der Firewall gegenseitig. Wenn Sie es schaffen, mindestens einen Computer in einem durch eine Firewall geschÃ¼tzten Netzwerk zu hacken, ist dies groÃŸartig.  Denn jetzt kÃ¶nnen Sie einfach die vielen ÃœberprÃ¼fungen Ã¼berspringen, die diese Computer normalerweise in Bezug auf "fremde" Maschinen durchfÃ¼hren, da sie Sie als vertrauenswÃ¼rdige Person betrachten. <br><br>  Es gibt eine Sache, Ã¼ber die Sie nachdenken mÃ¼ssten und die ich mir als Student vorgestellt habe: <br><br>  â€GroÃŸartig, sie haben uns gezeigt, wie man den Puffer Ã¼berlÃ¤uft, aber warum kann das Betriebssystem dies nicht stoppen?  Handelt sie nicht als jemand wie die WÃ¤chter der Galaxis, der das Gute vor bÃ¶sen Dingen schÃ¼tzt? " <br><br>  Es ist wichtig zu beachten, dass das Betriebssystem Sie nicht stÃ¤ndig Ã¼berwacht.  Und die Hardware beobachtet, extrahiert Anweisungen und entschlÃ¼sselt sie und macht vieles Ã„hnliches.  Aber was macht das Betriebssystem in erster NÃ¤herung?  GrundsÃ¤tzlich werden Seitentabellen eingerichtet, mit denen die Anwendung arbeiten kann. Wenn Sie das Betriebssystem beispielsweise auffordern, ein Netzwerkpaket zu senden, oder eine IPC-Anfrage oder Ã¤hnliches stellen mÃ¶chten, wenden Sie sich an das Betriebssystem, um Hilfe zu erhalten.  Das Betriebssystem befolgt jedoch nicht alle Anweisungen, die Ihre Anwendung ausfÃ¼hrt.  Mit anderen Worten, wenn dieser Puffer voll ist, Ã¼berwacht das Betriebssystem Ã¼berhaupt nicht, wie der Speicher dieses Stapels verwendet wird.  Der gesamte Adressraum gehÃ¶rt Ihnen als Initiator des Prozesses, und dies gilt nicht fÃ¼r das Betriebssystem.  Sie kÃ¶nnen damit tun, was Sie wollen, und das Betriebssystem kann Ihnen bei Problemen nicht helfen. <br><br>  SpÃ¤ter werden wir einige der Dinge besprechen, die das Betriebssystem in Bezug auf Hardware tun kann, um sich gegen diese Art von Angriff zu verteidigen.  Ich mÃ¶chte Sie noch einmal daran erinnern, dass nur die Hardware Ã¼berwacht, was Sie tun, und darauf reagiert.  Damit Sie einige spezielle Schutzarten nutzen kÃ¶nnen, werden wir dies weiter diskutieren. <br><br>  So sieht ein PufferÃ¼berlauf aus.  Wie werden wir all diese Dinge reparieren? <br><br>  Eine MÃ¶glichkeit, PufferÃ¼berlÃ¤ufe zu verhindern, besteht darin, einfach Fehler im C-Code zu vermeiden. Dies ist ein konstruktiver Ansatz, denn wenn Ihr Programm keine Fehler aufweist, kann der Angreifer diese nicht verwenden.  Dies ist jedoch leichter gesagt als getan.  Es gibt einige sehr einfache Dinge, die Programmierer tun kÃ¶nnen, um eine â€Hygieneâ€œ der Sicherheit zu gewÃ¤hrleisten.  Zum Beispiel kÃ¶nnen Funktionen wie get, von denen wir jetzt wissen, dass sie als "Go-tos" oder "Capture the Operating System" bezeichnet werden, was eine Sicherheitsverletzung darstellt. <br><br>  Wenn Sie Ihren Code mit einem modernen Compiler wie GCC oder Visual Studio kompilieren, werden die Nachteile solcher Funktionen angezeigt.  Sie werden sagen: "Hey, Sie verwenden eine gefÃ¤hrliche Sache, Ã¼berlegen Sie besser, ob Sie die Funktion fgets oder andere Funktionen verwenden, mit denen Sie die Einhaltung der Grenzbestimmungen wirklich verfolgen kÃ¶nnen."  Dies ist eines der einfachen Dinge, die Programmierer tun kÃ¶nnen. <br><br>  Beachten Sie jedoch, dass viele Anwendungen Puffer tatsÃ¤chlich manipulieren, ohne auf alle diese Funktionen zurÃ¼ckzugreifen.  Dies ist sehr hÃ¤ufig bei Netzwerkservern der Fall, die ihre eigenen Analyseverfahren definieren und dann sicherstellen, dass die Daten wie gewÃ¼nscht aus dem Puffer abgerufen werden.  Wenn Sie sich also einfach auf die Auswahl der richtigen Befehlsfunktionen beschrÃ¤nken, ist es nicht mÃ¶glich, das Problem vollstÃ¤ndig zu lÃ¶sen. <br><br>  Ein weiterer Umstand, der diese Herangehensweise an das Problem erschwert, ist, dass es nicht immer offensichtlich ist, dass das Problem durch einen Fehler in einem in C geschriebenen Programm verursacht wird. Wenn Sie jemals an einem in C geschriebenen GroÃŸprogramm gearbeitet haben, wissen Sie , wie es bei Funktionskennungen der Fall ist, die 18 Sterne Ã¼ber dem void * -Zeiger haben.  Ich denke nur Zeus weiÃŸ, was das bedeuten kann, oder?  Bei Sprachen wie C kann es selbst einem Programmierer sehr schwer fallen zu verstehen, ob ein Fehler aufgetreten ist oder nicht. <br><br>  Im Allgemeinen wird eines der Hauptthemen unserer Vorlesungen sein, dass die Sprache C ein Produkt des Teufels ist.  Und wir benutzen es nur, weil wir immer schneller sein wollen als alle anderen, oder?  Da die Hardware jedoch immer schneller wird, verwenden wir fortgeschrittenere Sprachen, um umfangreichen Systemcode zu schreiben.  Es ist jedoch nicht immer sinnvoll, Ihren C-Code zu schreiben, auch wenn Sie glauben, dass er schneller sein wird.  Wir werden dieses Problem spÃ¤ter diskutieren. <br><br><img src="https://habrastorage.org/webt/hy/ki/da/hykidavsdlgsuaiitifmgkyff40.jpeg"><br><br>  Der erste Ansatz zur LÃ¶sung des Problems besteht darin, Fehler im C-Programmcode zu vermeiden, und der zweite darin, Tools zu erstellen, mit denen Programmierer solche Fehler finden kÃ¶nnen.  Ein Beispiel fÃ¼r ein solches Tool ist die statische Code-Analyse.  SpÃ¤ter werden wir ausfÃ¼hrlich darÃ¼ber sprechen, und jetzt werde ich sagen, dass die statische Analyse eine MÃ¶glichkeit ist, den Quellcode Ihres Programms zu analysieren, bevor es Ã¼berhaupt startet, und dabei hilft, potenzielle Probleme zu erkennen. <br><br>  Stellen Sie sich vor, Sie haben eine solche Funktion. Nennen wir sie <b>void foo (int, * p)</b> . Sie enthÃ¤lt ganzzahlige Daten und einen Zeiger.  Angenommen, es wird ein ganzzahliger Offsetwert <b>int off</b> deklariert.  Diese Funktion deklariert einen weiteren Zeiger und fÃ¼gt ihm einen Offset hinzu: <b>int * z = p + off</b> .  Selbst jetzt, wenn eine Funktion geschrieben wird, kann die statische Code-Analyse uns sagen, dass diese Offset-Variable nicht initialisiert ist. <br><br><img src="https://habrastorage.org/webt/h3/z3/kj/h3z3kjqa65p3l1bwlzvbf1wu040.jpeg"><br><br>  Durch die Analyse des Programms ist es daher mÃ¶glich, die Frage zu beantworten, ob unsere Funktion ordnungsgemÃ¤ÃŸ funktioniert.  In diesem Beispiel ist es sehr einfach, die Antwort "Nein, wird es nicht" zu sehen, da keine Offset-Initialisierung erfolgt.  Statische Analyse ist Software, und wenn Sie den beliebten Compiler zum Erstellen Ihres Codes verwenden, erfahren Sie: â€Hey, Kumpel, dieses Ding ist nicht initialisiert.  Bist du sicher, dass du genau das tun willst? "  Dies ist eines der einfachsten Beispiele fÃ¼r die Verwendung statischer Analysen. <br><br>  Ein anderes Beispiel betrachtet den Fall, wenn wir einen Zweig einer Funktion haben, dh ihre AusfÃ¼hrung unter einer bestimmten Bedingung. <br><br><img src="https://habrastorage.org/webt/zk/fy/av/zkfyavkq4pcc2tywksll-hiecfy.jpeg"><br><br>  Wenn also der Offset grÃ¶ÃŸer als 8 ist, <b>wenn (aus&gt; 8)</b> , fÃ¼hrt dies zu einem Aufruf einer Funktionsleiste <b>(aus)</b> .  Diese Bedingung sagt uns also, was der Versatzwert ist.  Selbst wenn wir die Tatsache ignorieren, dass der Versatz nicht initialisiert ist, stellen wir bei der Analyse dieses Zweigs der Funktion fest, dass er grÃ¶ÃŸer als 8 sein kann. Wenn wir also mit der statischen Analyse des Balkens beginnen, stellen wir fest, dass der Versatz nur bestimmte Werte annehmen kann.  Ich stelle noch einmal fest, dass dies eine sehr oberflÃ¤chliche EinfÃ¼hrung in die statische Analyse ist. SpÃ¤ter werden wir dieses Tool genauer betrachten.  Dieses Beispiel zeigt jedoch, wie Sie einige Arten von Fehlern erkennen kÃ¶nnen, auch ohne Code auszufÃ¼hren. <br><br>  Eine weitere Sache, Ã¼ber die Sie nachdenken kÃ¶nnten, ist, dass sie dasselbe tut wie die statische Analyse.  Dies ist Software-Fuzzing.  Seine Idee ist, dass Sie alle Funktionen in Ihrem Programmcode Ã¼bernehmen und dann zufÃ¤llige Werte eingeben.  Somit Ã¼berschneiden sich alle Optionen fÃ¼r die Werte und Formate Ihres Codes.  Das heiÃŸt, Fuzzing ist ein Tool zum automatischen Suchen nach Schwachstellen, indem ungÃ¼ltige Daten oder Daten im falschen Format an die Programmeingabe gesendet werden.  Beispielsweise geben Sie beim Komponententest die Werte 2, 4, 8 und 15 ein und erhalten die Meldung, dass die Zahl 15 wahrscheinlich falsch ist, da alle Zahlen gerade, aber ungerade sind. <br><br>  TatsÃ¤chlich mÃ¼ssen Sie sich ansehen, wie viele Zweige des gesamten Programms Ihren Testcode beeinflussen, da dies normalerweise die Stellen sind, an denen die â€Fehlerâ€œ versteckt sind.  Programmierer denken nicht an solche â€Ecken und Winkelâ€œ und als Ergebnis bestehen sie einige Unit-Tests, man kann sagen, die meisten dieser Tests.  Sie untersuchen jedoch nicht alle â€Ecken und Winkelâ€œ des Programms, und hier kann die statische Analyse helfen.  Wieder mit Dingen wie dem Konzept der EinschrÃ¤nkung.  In unserem Programmabschnitt ist dies beispielsweise eine Bedingung fÃ¼r die Verzweigung einer Funktion, die einen Versatz von mehr als acht definiert.  Somit kÃ¶nnen wir herausfinden, dass diese Verschiebung statisch ist.  Und wenn wir die automatische Fuzzing-Generierung von Eingabedaten basierend auf dieser EinschrÃ¤nkung verwenden, kÃ¶nnen wir sicherstellen, dass einer der Eingabewerte fÃ¼r den Offset kleiner als 8, einer 8 und einer grÃ¶ÃŸer als 8 ist. Ist das klar? <br><br><img src="https://habrastorage.org/webt/mc/tn/ty/mctntyvh1aqv58xvu6p1zjvqxo8.jpeg"><br><br>  Dies ist also die Hauptidee hinter dem Konzept, Tools zu erstellen, mit denen Programmierer Fehler finden kÃ¶nnen.  Selbst eine teilweise Codeanalyse kann bei der Arbeit mit der C-Sprache sehr nÃ¼tzlich sein. Viele der Tools, die wir uns ansehen werden, um PufferÃ¼berlÃ¤ufe zu verhindern oder die Initialisierung von Variablen zu Ã¼berprÃ¼fen, kÃ¶nnen nicht alle Probleme des Programmcodes erkennen.  Sie kÃ¶nnen jedoch von praktischem Nutzen sein, um die Sicherheit dieser Programme zu verbessern.  Der Nachteil dieser Werkzeuge ist, dass sie nicht vollstÃ¤ndig sind.  Der voraussichtliche Fortschritt ist kein vollstÃ¤ndiger Fortschritt.  Daher mÃ¼ssen Sie das Problem des Schutzes vor Exploits sowohl in in C geschriebenen Programmen als auch in anderen Programmen aktiv untersuchen.  Wir haben zwei AnsÃ¤tze zur LÃ¶sung des Problems des PufferÃ¼berlaufschutzes untersucht, aber es gibt auch andere AnsÃ¤tze. <br><br>  Der dritte Ansatz ist also die Verwendung einer speichersicheren Sprache oder einer Sprache, die die Speichersicherheit gewÃ¤hrleistet.  Diese Sprachen umfassen Python, Java, c #.  Ich mÃ¶chte Perl nicht mit ihnen gleichsetzen, weil es von "schlechten Leuten" benutzt wird.  Auf diese Weise kÃ¶nnen Sie eine speichersichere Sprache verwenden, und es sieht so aus, als ob dies das offensichtlichste ist, was Sie tun kÃ¶nnen.  Ich habe Ihnen gerade erklÃ¤rt, dass C im Grunde ein Assembler-Encoder auf hoher Ebene ist, aber Rohzeiger und andere unerwÃ¼nschte Dinge bereitstellt. Warum also nicht einfach eine dieser Programmiersprachen auf hoher Ebene verwenden? <br><br>  DafÃ¼r gibt es mehrere GrÃ¼nde.  Erstens gibt es in diesen Sprachen viele Elemente des von C geerbten Codes. Alles ist in Ordnung, wenn Sie ein neues Projekt starten und eine der Hochsprachen verwenden, die die Speichersicherheit dafÃ¼r gewÃ¤hrleisten.  Aber was wÃ¤re, wenn Sie eine groÃŸe BinÃ¤rdatei oder eine groÃŸe Quelldistribution erhalten wÃ¼rden, die in C geschrieben und 10-15 Jahre lang gepflegt wurde? Dies war ein Generationsprojekt. Ich meine, sogar unsere Kinder werden weiter daran arbeiten ?  In diesem Fall kÃ¶nnen Sie nicht sagen: "Ich schreibe einfach alles in C # um und verÃ¤ndere die Welt!". <br><br>  Und das Problem liegt nicht nur in der C-Sprache, es gibt Systeme, vor denen Sie noch mehr Angst haben sollten, da sie Fortran- und COBOL-Codes verwenden, Dinge aus dem BÃ¼rgerkrieg.  Warum passiert das?  Weil wir als Ingenieure denken wollen, dass wir einfach alles selbst bauen kÃ¶nnen, und es wird groÃŸartig sein, es wird so sein, wie ich will, und ich werde meine Variablen so aufrufen, wie ich will. <br><br>  In der realen Welt passiert dies jedoch nicht.  Sie erscheinen bei der Arbeit, und Sie haben dieses System, das bereits existiert, und Sie schauen sich die Basis des Codes an und Ã¼berlegen, warum es nicht das tut, was benÃ¶tigt wird?  Und dann sagen sie zu Ihnen: "HÃ¶ren Sie, wir werden alles tun, was Sie wollen, aber nur in der zweiten Version des Programms, und jetzt mÃ¼ssen Sie das machen, was wir arbeiten mÃ¼ssen, weil die Kunden sonst ihr Geld zurÃ¼cknehmen." <br><br>  Wie gehen wir also mit dem groÃŸen Problem der erzwungenen Verwendung von Legacy-Code um?  Wie Sie wissen, besteht einer der Vorteile von Systemen mit fehlerhafter Definition von Grenzen darin, dass sie mit diesem veralteten Code perfekt funktionieren.  Dies ist einer der GrÃ¼nde, warum Sie das Problem des PufferÃ¼berlaufs nicht beseitigen kÃ¶nnen, indem Sie einfach zu Sprachen wechseln, die eine sichere Speichernutzung bieten. <br><br><img src="https://habrastorage.org/webt/z5/hp/1b/z5hp1bdiuxbyazad1amzu-_iezm.jpeg"><br><br>  Was ist, wenn wir einfachen Zugriff auf Hardware benÃ¶tigen?  Zum Beispiel, um Treiber und andere Dinge zu aktualisieren. <br><br>  Ein weiteres Problem tritt auf, wenn Sie Zugriff auf GerÃ¤te auf niedriger Ebene benÃ¶tigen, was beim Schreiben von Treibern fÃ¼r einige GerÃ¤te der Fall ist.  In diesem Fall benÃ¶tigen Sie wirklich die Vorteile, die C bietet, z. B. die MÃ¶glichkeit, Register und Ã¤hnliche Funktionselemente zu betrachten. <br><br>  DarÃ¼ber hinaus besteht die Notwendigkeit, C zu verwenden, wenn Sie sich Gedanken Ã¼ber die Systemleistung machen.  ,     ,   ,      . ,       ,          .  ,  ,         memory-safe .    ,   JIT. ,     Java,  Java Script.     ,  ,      Â«Â».     ,    .      ,         Â«Â»  x86. <br><br>          ,           ,  -. ,     ,  JVM, -   Java.      ,    -        . ,  - JVM   ,       .      ,    ,       .      .        ,    ,   . <br><br>           ,  ,     86.   JIT-     ,        .  JIT-       ,   . <br><br>       ,       JavaScript     ,     , Â«Â» 32-  ,       .       JIT-,         Â«Â»  . ,    ,  JIT-, ,      ,    . <br><br><img src="https://habrastorage.org/webt/yx/zv/9l/yxzv9lj9b57b09rpogi_ojgabs8.jpeg"><br><br>     Â«Â» ,   asm.js â€“  JavaScript, ,   ,   .   ,    , ,    JavaScript     ,    .            JavaScript,       JavaScript,     C  ++. <br><br>   ,       -,   IO.      .  ,           ,   ,    ,   .      Â«Â»  ,               . <br><br>         . ,   -            .     ,      C  C++,    ,       .        Python, ,  ,    .          .         . <br><br> ,     ,   ,    . <br><br>   ,        .         ,    .      ,          .   ,          Â«Â»  ,       .   ,        C  C++,        . <br><br> ,           ?        , , ?       ? <br><br>       . ,     â€“      .  ,  -       ,         .   ,     .  , -,    ,        .        IP , ,            .  ,     -          .           ,   ,        .      ,      ,           Â«Â» . <br><br> ,  ,  ,     ,   ,   ,         .     ,    -  ,   .    ,        ,             ,      . ,   ,    ,        ,  ,       ,      . <br><br><img src="https://habrastorage.org/webt/gk/41/p2/gk41p2phaguhv4easepocrejn4q.jpeg"><br><br> ,      .   stack canaries, Â« Â»,         ,         .   Â« Â»   ,           ,           ,     .  ,       ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnen wir ein Diagramm unseres Stapels. </font><font style="vertical-align: inherit;">Wir mÃ¼ssen sicherstellen, dass der Angreifer zuerst "in den Kanarienvogel gelangt", bevor er die Absenderadresse erreicht. </font><font style="vertical-align: inherit;">Und wenn wir dies erkennen kÃ¶nnen, bevor wir von der Funktion zurÃ¼ckkehren, kÃ¶nnen wir "bÃ¶se" erkennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">28:30 min </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung:</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorlesung 2: â€Kontrolle von Hackerangriffenâ€œ, Teil 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vollversion des Kurses finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Vielen Dank fÃ¼r Ihren Aufenthalt bei uns.  GefÃ¤llt dir unser Artikel?  MÃ¶chten Sie weitere interessante Materialien sehen?  UnterstÃ¼tzen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder Ihren Freunden empfehlen, einen <b>Rabatt von 30% fÃ¼r Habr-Benutzer auf ein einzigartiges Analogon von Einstiegsservern, das wir fÃ¼r Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit Ã¼ber VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s von $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfÃ¼gbar). <br><br>  <b>Dell R730xd 2 mal gÃ¼nstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr Ã¼ber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines InfrastrukturgebÃ¤udes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern fÃ¼r 9.000 Euro fÃ¼r einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414505/">https://habr.com/ru/post/de414505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414495/index.html">toString: GroÃŸartig und schrecklich</a></li>
<li><a href="../de414497/index.html">Consulo UI API von der Idee bis zum Prototyp</a></li>
<li><a href="../de414499/index.html">Bericht des Club of Rome 2018, Kapitel 1.1.3: â€Eine leere Welt gegen einen vollen Friedenâ€œ</a></li>
<li><a href="../de414501/index.html">Bericht des Club of Rome 2018, Kapitel 3.11: â€Reformen des Finanzsektorsâ€œ</a></li>
<li><a href="../de414503/index.html">Intel NUC Hades Canyon mit AMD Vega Graphics - VR oder nicht VR?</a></li>
<li><a href="../de414507/index.html">Wie sich die beliebteste programmierbare Tastatur fÃ¼r den Handel verÃ¤ndert hat: die Geschichte der Bloomberg-Tastatur</a></li>
<li><a href="../de414509/index.html">Wir verbinden jeden (fast) GPS-Tracker (am Beispiel des Sinotrack ST-901) mit dem HomeAssistant Smart Home</a></li>
<li><a href="../de414513/index.html">27 groÃŸartige Open Source-Webentwicklungstools</a></li>
<li><a href="../de414515/index.html">Lektion zur Optimierung von Webanwendungsservern</a></li>
<li><a href="../de414517/index.html">Oxford-Wissenschaftler: Die Wahrscheinlichkeit, dass wir im vorhersehbaren Teil des Universums allein sind, ist viel hÃ¶her als Null</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>