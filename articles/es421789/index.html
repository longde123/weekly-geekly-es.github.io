<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßù üë®üèº‚Äçüè≠ üò¶ Hacer frontend "backend" de nuevo üë´ üë®üèæ‚ÄçüöÄ ‚ñ´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolai Ryzhikov propuso su versi√≥n de la respuesta a la pregunta de por qu√© es tan dif√≠cil desarrollar una interfaz de usuario. En el ejemplo de su p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacer frontend "backend" de nuevo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421789/">  Nikolai Ryzhikov propuso su versi√≥n de la respuesta a la pregunta de por qu√© es tan dif√≠cil desarrollar una interfaz de usuario.  En el ejemplo de su proyecto, demostrar√° que la aplicaci√≥n en el frontend de algunas ideas del backend afecta tanto la reducci√≥n de la complejidad del desarrollo como la capacidad de prueba del frontend. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XBfi3Q74BnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  El material fue preparado sobre la base de un informe de Nikolai Ryzhikov en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia de</a> primavera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HolyJS 2018 Piter</a> . <br><a name="habracut"></a><br>  Actualmente, Nikolai Ryzhikov est√° trabajando en el sector de TI de Salud para crear sistemas de informaci√≥n m√©dica.  Miembro de la comunidad de programadores funcionales de San Petersburgo FPROG.  Miembro activo de la comunidad Online Clojure, miembro del est√°ndar de intercambio de informaci√≥n m√©dica HL7 FHIR.  Ha estado programando durante 15 a√±os. <br><br><hr><br>  - Siempre me atormentaba la pregunta: ¬øpor qu√© la interfaz gr√°fica siempre era dif√≠cil de hacer?  ¬øPor qu√© esto siempre ha planteado muchas preguntas? <br><br>  Hoy tratar√© de especular si es posible desarrollar efectivamente una interfaz de usuario.  ¬øPodemos reducir la complejidad de su desarrollo? <br><br><h3>  ¬øQu√© es la eficiencia? </h3><br>  Definamos qu√© es la eficiencia.  Desde el punto de vista del desarrollo de una interfaz de usuario, eficiencia significa: <br><br><ul><li>  velocidad de desarrollo </li><li>  cantidad de errores </li><li>  cantidad de dinero gastado ... </li></ul><br>  Hay una muy buena definici√≥n: <br><br><blockquote>  La eficiencia est√° haciendo m√°s con menos </blockquote><br>  Despu√©s de esta determinaci√≥n, puede poner lo que quiera: dedicar menos tiempo y menos esfuerzo.  Por ejemplo, "si escribe menos c√≥digo, permita menos errores" y logre el mismo objetivo.  En general, gastamos mucho esfuerzo en vano.  Y la eficiencia es un objetivo bastante alto: deshacerse de estas p√©rdidas y hacer solo lo que se necesita. <br><br><h3>  ¬øQu√© es la complejidad? </h3><br>  En mi opini√≥n, la complejidad es el principal problema en el desarrollo. <br><br>  Fred Brooks escribi√≥ un art√≠culo en 1986 llamado Sin bala de plata.  En √©l, reflexiona sobre el software.  En hardware, el progreso es a pasos agigantados, y con el software todo es mucho peor.  La pregunta principal de Fred Brooks: ¬øpuede haber una tecnolog√≠a que nos acelere de inmediato en un orden de magnitud?  Y √©l mismo da una respuesta pesimista, afirmando que en el software no es posible lograr esto, explicando su posici√≥n.  Recomiendo leer este art√≠culo. <br><br>  Un amigo m√≠o dijo que la programaci√≥n de la interfaz de usuario es un "problema sucio".  No puede sentarse una vez y encontrar la opci√≥n correcta para que el problema se resuelva para siempre.  Adem√°s, en los √∫ltimos 10 a√±os, la complejidad del desarrollo solo ha aumentado. <br><br><h3>  Hace 12 a√±os ... </h3><br>  Comenzamos a desarrollar un sistema de informaci√≥n m√©dica hace 12 a√±os.  Primero con flash.  Luego miramos lo que Gmail comenz√≥ a hacer.  Nos gust√≥ y quer√≠amos cambiar a JavaScript con HTML. <br><br>  De hecho, entonces est√°bamos muy adelantados.  Tomamos un dojo y, de hecho, ten√≠amos todo igual que ahora.  Hab√≠a componentes que eran bastante buenos en los widgets de dojo, hab√≠a un sistema de compilaci√≥n modular y requer√≠a que el compilador de Google Clojure se construyera y minimizara (RequireJS y CommonJS ni siquiera ol√≠an entonces). <br><br>  Todo sali√≥ bien.  Miramos a Gmail, nos sentimos inspirados, pensamos que todo estaba bien.  Al principio, solo escribimos un lector de tarjetas de paciente.  Luego cambiaron gradualmente a la automatizaci√≥n de otros flujos de trabajo en el hospital.  Y todo se volvi√≥ complicado.  El equipo parece ser profesional, pero cada caracter√≠stica comenz√≥ a crujir.  Esta sensaci√≥n apareci√≥ hace 12 a√±os, y todav√≠a no me deja. <br><br><h3>  Carriles camino + jQuery </h3><br>  Hicimos la certificaci√≥n del sistema y fue necesario escribir un portal para pacientes.  Este es un sistema en el que el paciente puede ir y ver sus datos m√©dicos. <br><br>  Nuestro backend fue escrito en Ruby on Rails.  Aunque la comunidad de Ruby on Rails no es muy grande, ha tenido un gran impacto en la industria.  De su peque√±a comunidad apasionada, han venido todos sus gerentes de paquetes, GitHub, Git, maquillajes autom√°ticos, etc. <br><br>  La esencia del desaf√≠o que enfrentamos fue que tuvimos que implementar el portal del paciente en dos semanas.  Y decidimos probar el camino de Rails: hacer todo en el servidor.  Una web tan cl√°sica 2.0.  Y lo hicieron, realmente lo hicieron en dos semanas. <br><br>  Est√°bamos por delante de todo el planeta: hicimos SPA, ten√≠amos una API REST, pero por alguna raz√≥n no fue efectiva.  Algunas caracter√≠sticas ya pod√≠an formar unidades, porque solo ellas pod√≠an acomodar toda esta complejidad de componentes, la relaci√≥n del backend con la interfaz.  Y cuando tomamos el camino de Rails, un poco desactualizado por nuestros est√°ndares, las caracter√≠sticas de repente comenzaron a ser fascinantes.  El desarrollador promedio comenz√≥ a implementar la funci√≥n en unos d√≠as.  E incluso comenzamos a escribir pruebas simples. <br><br>  Sobre esta base, todav√≠a tengo una lesi√≥n: hab√≠a preguntas.  Cuando cambiamos de Java a Rails en el back-end, la eficiencia del desarrollo aument√≥ aproximadamente 10 veces.  Pero cuando obtuvimos puntajes en el SPA, la eficiencia del desarrollo tambi√©n aument√≥ significativamente.  ¬øC√≥mo es eso? <br><br><h3>  ¬øPor qu√© fue efectiva la Web 2.0? </h3><br>  Comencemos con otra pregunta: ¬øpor qu√© hacemos una aplicaci√≥n de p√°gina √∫nica, por qu√© creemos en ella? <br><br>  Simplemente nos dicen: tenemos que hacer esto, y lo hacemos.  Y muy raramente lo cuestionan.  ¬øEs correcta la arquitectura REST API y SPA?  ¬øEs realmente adecuado para el caso donde lo usamos?  No pensamos <br><br>  Por otro lado, hay ejemplos conversos sobresalientes.  Todos usan GitHub.  ¬øSabes que GitHub no es una aplicaci√≥n de p√°gina √∫nica?  GitHub es una aplicaci√≥n "rail" normal que se representa en el servidor y donde hay pocos widgets.  ¬øAlguien ha experimentado harina de esto?  Creo que hay tres personas.  El resto ni se dio cuenta.  Esto no afect√≥ al usuario de ninguna manera, pero al mismo tiempo, por alguna raz√≥n, tenemos que pagar 10 veces m√°s por el desarrollo de otras aplicaciones (tanto fuerza, complejidad, etc.).  Otro ejemplo es Basecamp.  Twitter fue una vez solo una aplicaci√≥n Rails. <br><br>  De hecho, hay tantas aplicaciones Rails.  Esto fue parcialmente determinado por el genio DHH (David Heinemeier Hansson, creador de Ruby on Rails).  Fue capaz de crear una herramienta centrada en los negocios, que le permite hacer de inmediato lo que necesita, sin distraerse por problemas t√©cnicos. <br><br>  Cuando usamos el modo Rails, por supuesto, hab√≠a mucha magia negra.  A medida que nos desarrollamos gradualmente, cambiamos de Ruby a Clojure, pr√°cticamente manteniendo la misma eficiencia, pero haciendo que todo sea un orden de magnitud m√°s simple.  Y fue maravilloso. <br><br><h3>  Han pasado 12 a√±os </h3><br>  Con el tiempo, nuevas tendencias comenzaron a aparecer en la interfaz. <br><br>  Ignoramos por completo a Backbone, porque la aplicaci√≥n de dojo que escribimos antes era a√∫n m√°s sofisticada que la que ofrece Backbone. <br><br>  Luego vino Angular.  Fue un "rayo de luz" bastante interesante: desde el punto de vista de la eficiencia, Angular es muy bueno.  Tomas al desarrollador promedio, y √©l remacha la funci√≥n.  Pero desde el punto de vista de la simplicidad, Angular trae muchos problemas: es opaco, complejo, hay vigilancia, optimizaci√≥n, etc. <br><br>  React apareci√≥, lo que trajo un poco de simplicidad (al menos la sencillez del renderizado, que, debido al DOM virtual, nos permite cada vez como simplemente volver a dibujar, simplemente entender y simplemente escribir).  Pero en t√©rminos de eficiencia, para ser honesto, React nos hizo retroceder significativamente. <br><br>  Lo peor es que nada ha cambiado en 12 a√±os.  Todav√≠a estamos haciendo lo mismo que entonces.  Es hora de pensar: algo est√° mal aqu√≠. <br><br>  Fred Brooks dice que hay dos problemas con el desarrollo de software.  Por supuesto, √©l ve el problema principal en la complejidad, pero lo divide en dos grupos: <br><br><ul><li>  Complejidad significativa que proviene de la tarea misma.  Simplemente no se puede tirar, porque es parte de la tarea. </li><li>  La complejidad aleatoria es la que traemos al tratar de resolver este problema. </li></ul><br>  La pregunta es, ¬øcu√°l es el equilibrio entre ellos?  Esto es precisamente lo que estamos discutiendo ahora. <br><br><h3>  ¬øPor qu√© es tan doloroso hacer la interfaz de usuario? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/667/d4e/d22667d4e3249034be27b07250a635ff.png"><br><br>  Me parece que la primera raz√≥n es nuestro modelo de aplicaci√≥n mental.  Los componentes de reacci√≥n son un enfoque puramente OOP.  Nuestro sistema es un gr√°fico din√°mico de objetos mutables interconectados.  Los tipos completos de Turing generan constantemente nodos de este gr√°fico, algunos nodos desaparecen.  ¬øAlguna vez has tratado de imaginar tu aplicaci√≥n en tu cabeza?  Esto da miedo!  Usualmente presento una aplicaci√≥n OOP como esta: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cd/7b4/c7a/7cd7b4c7a846d2e973b012d566945a19.png"><br><br>  Recomiendo leer las tesis de Roy Fielding (autor de la arquitectura REST).  Su disertaci√≥n se titula "Estilos arquitect√≥nicos y el dise√±o de software basado en red".  Al principio hay una muy buena introducci√≥n, donde habla sobre c√≥mo llegar a la arquitectura en general e introduce los conceptos: divide el sistema en componentes y las relaciones entre estos componentes.  Tiene una arquitectura "cero", donde todos los componentes pueden asociarse potencialmente con todos.  Este es el caos arquitect√≥nico.  Esta es nuestra representaci√≥n de objeto de la interfaz de usuario. <br><br>  Roy Fielding recomienda buscar e imponer un conjunto de restricciones, porque es un conjunto de restricciones que define su arquitectura. <br><br>  Probablemente lo m√°s importante es que las restricciones son amigos del arquitecto.  Busque estas limitaciones reales y dise√±e un sistema a partir de ellas.  Porque la libertad es malvada.  Libertad significa que tiene un mill√≥n de opciones entre las que puede elegir, y ning√∫n criterio por el cual puede determinar si la elecci√≥n fue correcta.  Busque restricciones y construya sobre ellas. <br><br>  Hay un excelente art√≠culo llamado OUT OF THE TAR PIT ("M√°s f√°cil que un pozo de alquitr√°n"), en el que los chicos despu√©s de Brooks decidieron analizar qu√© contribuye exactamente a la complejidad de la aplicaci√≥n.  Llegaron a la decepcionante conclusi√≥n de que un sistema mutable, extendido por el estado, es la principal fuente de complejidad.  Aqu√≠ es posible explicar de manera puramente combinatoria: si tiene dos celdas, y en cada una de ellas una bola puede mentir (o no mentir), ¬øcu√°ntos estados son posibles?  - cuatro. <br><br>  Si tres celdas - 2 <sup>3</sup> , si 100 celdas - 2 <sup>100</sup> .  Si presenta su aplicaci√≥n y comprende cu√°nto estado est√° borroso, se dar√° cuenta de que hay un n√∫mero infinito de estados posibles de su sistema.  Si al mismo tiempo no est√° limitado por nada, es demasiado dif√≠cil.  Y el cerebro humano es d√©bil, esto ya ha sido probado por varios estudios.  Somos capaces de mantener hasta tres elementos en nuestras cabezas al mismo tiempo.  Algunos dicen siete, pero incluso para esto el cerebro usa un truco.  Por lo tanto, la complejidad es realmente un problema para nosotros. <br><br>  Recomiendo leer este art√≠culo, donde los chicos llegan a la conclusi√≥n de que hay que hacer algo con este estado mutable.  Por ejemplo, hay bases de datos relacionales, puede eliminar todo el estado mutable all√≠.  Y el resto se hace en un estilo puramente funcional.  Y simplemente se les ocurri√≥ la idea de tal programaci√≥n funcional-relacional. <br><br>  Entonces, el problema proviene del hecho de que: <br><br><ul><li>  En primer lugar, no tenemos un buen modelo de interfaz de usuario fijo.  Los enfoques de componentes nos llevan al infierno existente.  No imponemos ninguna restricci√≥n, difundimos el estado mutable, como resultado, la complejidad del sistema en alg√∫n momento simplemente nos aplasta; <br></li><li>  en segundo lugar, si estamos escribiendo una aplicaci√≥n cl√°sica de interfaz de usuario, ya es un sistema distribuido.  Y la primera regla de los sistemas distribuidos es no crear sistemas distribuidos (Primera ley del dise√±o de objetos distribuidos: no distribuya sus objetos, por Martin Fowler), ya que aumenta inmediatamente la complejidad en un orden de magnitud.  Cualquiera que haya escrito alguna integraci√≥n comprende que tan pronto como ingrese a la interacci√≥n entre sistemas, todas las estimaciones del proyecto pueden multiplicarse por 10. Pero simplemente nos olvidamos de eso y pasamos a sistemas distribuidos.  Esta fue probablemente la consideraci√≥n principal cuando cambiamos a Rails, devolviendo todo el control al servidor. <br></li></ul><br>  Todo esto es demasiado duro para un cerebro humano pobre.  Pensemos en lo que podemos hacer con estos dos problemas: la falta de restricciones en la arquitectura (el gr√°fico de objetos mutables) y la transici√≥n a sistemas distribuidos que son tan complejos que los acad√©micos todav√≠a est√°n desconcertando c√≥mo hacerlo correctamente (al mismo tiempo, nosotros condenarnos a estos tormentos en las aplicaciones comerciales m√°s simples)? <br><br><h3>  ¬øC√≥mo evolucion√≥ el backend? </h3><br>  Si escribimos el backend en el mismo estilo que estamos creando la interfaz de usuario ahora, habr√° el mismo "desastre sangriento".  Pasaremos tanto tiempo en ello.  As√≠ que realmente una vez intent√© hacerlo.  Luego, gradualmente comenzaron a imponer restricciones. <br><br>  La primera gran invenci√≥n de backend es la base de datos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/d5a/8aa/777d5a8aa62a6623e0918cdc57abdbee.png"><br><br>  Al principio, en el programa, todo el estado colgaba inexplicablemente donde, y era dif√≠cil de manejar.  Con el tiempo, los desarrolladores crearon una base de datos y eliminaron todo el estado all√≠. <br><br>  La primera diferencia interesante entre la base de datos es que los datos no tienen algunos objetos con su propio comportamiento, esto es pura informaci√≥n.  Hay tablas u otras estructuras de datos (por ejemplo, JSON).  No tienen comportamiento, y esto tambi√©n es muy importante.  Porque el comportamiento es una interpretaci√≥n de la informaci√≥n, y puede haber muchas interpretaciones.  Y los hechos b√°sicos: siguen siendo b√°sicos. <br><br>  Otro punto importante es que sobre esta base de datos tenemos un lenguaje de consulta como SQL.  Desde el punto de vista de las limitaciones, en la mayor√≠a de los casos, SQL no es un lenguaje completo de Turing, es m√°s simple.  Por otro lado, es declarativo, m√°s expresivo, porque en SQL se dice "qu√©", no "c√≥mo".  Por ejemplo, cuando combina dos etiquetas en SQL, SQL decide c√≥mo realizar esta operaci√≥n de manera eficiente.  Cuando buscas algo, √©l recoge un √≠ndice para ti.  Nunca declaras expl√≠citamente esto.  Si intenta combinar algo en JavaScript, tendr√° que escribir un mont√≥n de c√≥digo para esto. <br><br>  Aqu√≠, nuevamente, es importante que hayamos impuesto restricciones y ahora vamos a esta base a trav√©s de un lenguaje m√°s simple y expresivo.  Complejidad redistribuida. <br><br>  Despu√©s de que el backend ingres√≥ a la base, la aplicaci√≥n se convirti√≥ en ap√°trida.  Esto conduce a efectos interesantes: ahora, por ejemplo, es posible que no tengamos miedo de actualizar la aplicaci√≥n (el estado no se bloquea en la capa de la aplicaci√≥n en la memoria, que desaparecer√° si la aplicaci√≥n se reinicia).  Para una capa de aplicaci√≥n, sin estado es una buena caracter√≠stica y una restricci√≥n excelente.  P√≥ntelo si puedes.  Adem√°s, una nueva aplicaci√≥n se puede incorporar a la base anterior, porque los hechos y su interpretaci√≥n no son cosas relacionadas. <br><br>  Desde este punto de vista, los objetos y las clases son terribles porque pegan el comportamiento y la informaci√≥n.  La informaci√≥n es m√°s rica; vive m√°s tiempo.  Las bases de datos y los hechos sobreviven al c√≥digo escrito en Delphi, Perl o JavaScript. <br><br>  Cuando el backend lleg√≥ a tal arquitectura, todo se volvi√≥ mucho m√°s simple.  La era dorada de la Web 2.0 ha llegado.  Fue posible obtener algo de la base de datos, someter los datos a plantillas (funci√≥n pura) y devolver el HTML-ku, que se env√≠a al navegador. <br><br>  Aprendimos a escribir aplicaciones bastante complejas en el backend.  Y la mayor√≠a de las aplicaciones est√°n escritas en este estilo.  Pero tan pronto como el backend da un paso al costado, hacia la incertidumbre, los problemas comienzan nuevamente. <br><br>  La gente comenz√≥ a pensar en ello y se le ocurri√≥ la idea de tirar la OLP y los rituales. <br><br>  ¬øQu√© hacen realmente nuestros sistemas?  Toman informaci√≥n de alg√∫n lugar, del usuario, de otro sistema y similares, la colocan en la base de datos, la transforman, de alguna manera la verifican.  Desde la base lo sacan con consultas astutas (anal√≠ticas o sint√©ticas) y lo devuelven.  Eso es todo  Y esto es importante de entender.  Desde este punto de vista, las simulaciones son un concepto muy incorrecto y malo. <br><br>  Me parece que, en general, toda la POO realmente naci√≥ de la IU.  Las personas intentaron simular y simular una interfaz de usuario.  Vieron cierto objeto gr√°fico en el monitor y pensaron: ser√≠a bueno estimularlo en nuestro tiempo de ejecuci√≥n, junto con sus propiedades, etc.  Toda esta historia est√° muy estrechamente entrelazada con la OOP.  Pero la simulaci√≥n es la forma m√°s sencilla e ingenua de resolver la tarea.  Se hacen cosas interesantes cuando te haces a un lado.  Desde este punto de vista, es m√°s importante separar la informaci√≥n del comportamiento, deshacerse de estos objetos extra√±os, y todo ser√° mucho m√°s f√°cil: su servidor web recibe una cadena HTTP, devuelve una cadena de respuesta HTTP.  Si agrega una base a la ecuaci√≥n, obtiene una funci√≥n generalmente pura: el servidor acepta la base y solicita, devuelve una nueva base y respuesta (datos ingresados ‚Äã‚Äã- datos restantes). <br><br>  En el camino de esta simplificaci√≥n, los funcionarios tiraron otro ‚Öî del equipaje que se hab√≠a acumulado en el backend.  No era necesario, solo era un ritual.  Todav√≠a no somos un desarrollador de juegos: no necesitamos que el paciente y el m√©dico vivan de alguna manera en tiempo de ejecuci√≥n, se muevan y sigan sus coordenadas.  Nuestro modelo de informaci√≥n es otra cosa.  No pretendemos ser medicina, ventas o cualquier otra cosa.  Estamos creando algo nuevo en el cruce.  Por ejemplo, Uber no simula el comportamiento de operadores y m√°quinas: introduce un nuevo modelo de informaci√≥n.  En nuestro campo, tambi√©n estamos creando algo nuevo, para que pueda sentir la libertad. <br><br>  No es necesario intentar simular completamente: crear. <br><br><h3>  Clojure = JS-- </h3><br>  Es hora de decirte exactamente c√≥mo puedes tirar todo.  Y aqu√≠ quiero mencionar Clojure Script.  De hecho, si conoce JavaScript, conoce Clojure.  En Clojure, no agregamos funciones a JavaScript, sino que las eliminamos. <br><br><ul><li>  Eliminamos la sintaxis: en Clojure (en Lisp) no hay sintaxis.  En un lenguaje ordinario, escribimos un c√≥digo, que luego se analiza y se obtiene un AST, que se compila y ejecuta.  En Lisp, escribimos inmediatamente un AST que se puede ejecutar, interpretar o compilar. <br></li><li>  Tiramos la mutabilidad.  No hay objetos o matrices mutables en Clojure.  Cada operaci√≥n genera como si una nueva copia.  Adem√°s, esta copia es muy barata.  Eso est√° tan h√°bilmente hecho para ser barato.  Y esto nos permite trabajar, como en matem√°ticas, con valores.  No estamos cambiando nada, estamos creando algo nuevo.  Seguro, f√°cil <br></li><li>  Lanzamos clases, juegos con prototipos, etc.  Esto simplemente no est√° ah√≠. </li></ul><br>  Como resultado, todav√≠a tenemos funciones y estructuras de datos sobre las cuales operamos, as√≠ como primitivas.  Aqu√≠ est√° todo el Clojure.  Y en √©l puedes hacer lo mismo que haces en otros idiomas, donde hay muchas herramientas adicionales que nadie sabe c√≥mo usar. <br><br><h4>  Ejemplos </h4><br>  ¬øC√≥mo llegamos a Lisp a trav√©s de AST?  Aqu√≠ hay una expresi√≥n cl√°sica: <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Si intentamos escribir su AST, por ejemplo, en forma de matriz, donde el encabezado es el tipo de nodo y lo que sigue es un par√°metro, obtendremos algo similar (estamos tratando de escribir esto en Java Script): <br><br><pre> <code class="hljs json">['minus', ['plus', <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Ahora descarte las comillas adicionales, podemos reemplazar el menos con <code>-</code> , y el m√°s con <code>+</code> .  Deseche las comas que son espacios en blanco en Lisp.  Obtendremos el mismo AST: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Y en Lisp, todos escribimos as√≠.  Podemos verificar: esta es una funci√≥n matem√°tica pura (mi emacs est√° conectado al navegador; dejo caer el script all√≠, eval√∫a el comando all√≠ y lo env√≠a de vuelta a emacs; ve el valor despu√©s del s√≠mbolo <code>=&gt;</code> ): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Tambi√©n podemos declarar una funci√≥n: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> xplus [ab] (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) ((<span class="hljs-name"><span class="hljs-name">fn</span></span> [xy] (<span class="hljs-name"><span class="hljs-name">*</span></span> xy)) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  O una funci√≥n an√≥nima.  Quiz√°s esto parezca un poco aterrador: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">type</span></span> xplus)</code> </pre><br>  Su tipo es una funci√≥n de JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> xplus) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Podemos llamarlo pas√°ndole el par√°metro: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">xplus</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Es decir, todo lo que hacemos es escribir AST, que luego se compila en JS o bytecode, o se interpreta. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> mymin [ab] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">a</span></span> &gt; b) ba))</code> </pre><br>  Clojure es un lenguaje alojado.  Por lo tanto, toma primitivas del tiempo de ejecuci√≥n principal, es decir, en el caso de Clojure Script, tendremos tipos de JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[Number]</code> </pre><br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "string") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[String]</code> </pre><br>  Entonces regexp est√°n escritos: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> #"^Cl.*$") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[RegExp]</code> </pre><br>  Las funciones que tenemos son funciones: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> (fn [x] x)) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Luego necesitamos alg√∫n tipo de tipos compuestos. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Esto se puede leer como si estuviera creando un objeto en JavaScript: <br><br><pre> <code class="hljs pgsql">(def <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span>: "niquola" ‚Ä¶</code> </pre><br>  En Clojure, esto se llama hashmap.  Este es un contenedor en el que se encuentran los valores.  Si se utilizan corchetes, esto se llama vector, esta es su matriz: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} =&gt; #'intro/user (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Registramos cualquier informaci√≥n con hashmaps y vectores. <br><br>  Los nombres de dos puntos extra√±os ( <code>:name</code> ) son los llamados caracteres: cadenas constantes que se crean para usarse como claves en hashmaps.  En diferentes idiomas se les llama de manera diferente: s√≠mbolos, algo m√°s.  Pero esto puede tomarse simplemente como una cadena constante.  Son bastante efectivos: puede escribir nombres largos y no gastar muchos recursos en ellos, porque est√°n conectados (es decir, no se repiten). <br><br>  Clojure proporciona cientos de funciones para manejar estas estructuras de datos gen√©ricas y primitivas.  Podemos agregar, agregar nuevas claves.  Adem√°s, siempre tenemos una sem√°ntica de copia, es decir, cada vez que recibimos una nueva copia.  Primero debes acostumbrarte, porque ya no podr√°s guardar algo, como antes, en alg√∫n lugar de la variable, y luego cambiar este valor.  Su c√°lculo siempre debe ser sencillo: todos los argumentos deben pasarse expl√≠citamente a la funci√≥n. <br><br>  Esto lleva a algo importante.  En lenguajes funcionales, una funci√≥n es un componente ideal porque recibe todo expl√≠citamente en la entrada.  No hay enlaces ocultos divergentes en el sistema.  Puede tomar una funci√≥n de un lugar, transferirla a otro y usarla all√≠. <br><br>  En Clojure, tenemos excelentes operaciones de igualdad en valor incluso para tipos compuestos complejos: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">=</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) =&gt; true</code> </pre><br>  Y esta operaci√≥n es barata debido al hecho de que las astutas estructuras inmutables se pueden comparar simplemente por referencia.  Por lo tanto, incluso un hashmap con millones de claves podemos comparar en una sola operaci√≥n. <br><br>  Por cierto, los chicos de React simplemente copiaron la implementaci√≥n de Clojure e hicieron JS inmutable. <br><br>  Clojure tambi√©n tiene un mont√≥n de operaciones, por ejemplo, obtener algo de una ruta anidada en hashmap: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">get-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>])</code> </pre><br>  Ponga algo a lo largo de la ruta anidada en hashmap: <br><br><pre> <code class="hljs ruby">(assoc-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>] <span class="hljs-string"><span class="hljs-string">"LA"</span></span>) =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"LA"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}], <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>}</code> </pre><br>  Actualiza alg√∫n valor: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">update-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span>] (<span class="hljs-name"><span class="hljs-name">fn</span></span> [old] (<span class="hljs-name"><span class="hljs-name">str</span></span> old <span class="hljs-string"><span class="hljs-string">"+++++"</span></span>)))</code> </pre><br>  Seleccione solo una clave espec√≠fica: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select-keys</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span>])</code> </pre><br>  Lo mismo con el vector: <br><br><pre> <code class="hljs pgsql">(def clojurists [{:<span class="hljs-type"><span class="hljs-type">name</span></span> "Rich"} {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Micael"}]) (first clojurists) (second clojurists) =&gt; {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Michael"}</code> </pre><br>  Hay cientos de operaciones de la biblioteca base que le permiten operar en estas estructuras de datos.  Hay una interoperabilidad con el host.  Necesitas acostumbrarte un poco: <br><br><pre> <code class="hljs pgsql">(js/alert "Hello!") =&gt; nil &lt;/csource&gt;         "".    <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: &lt;source lang="clojure"&gt; (.-<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)</code> </pre><br>  Hay cada az√∫car para ir a lo largo de las cadenas: <br><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -href) =&gt; "http://localhost:3000/#/billing/dashboard"</code> </pre><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -host) =&gt; "localhost:3000"</code> </pre><br>  Puedo tomar la fecha JS y devolverle el a√±o: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [d (<span class="hljs-name"><span class="hljs-name">js/Date</span></span>.)] (.getFullYear d)) =&gt; <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Rich Hickey, el creador de Clojure, nos ha limitado severamente.  Realmente no tenemos nada m√°s, por lo que hacemos todo a trav√©s de estructuras de datos gen√©ricas.  Por ejemplo, cuando escribimos SQL, generalmente lo escribimos con una estructura de datos.  Si observa detenidamente, ver√° que esto es solo un hashmap en el que algo est√° incrustado.  Luego hay alguna funci√≥n que traduce todo esto en una cadena SQL: <br><br><pre> <code class="hljs ruby">{select [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]} =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:select</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]}</code> </pre><br>  Tambi√©n escribimos rutas con una estructura de datos y estructuras de datos tipogr√°ficas: <br><br><pre> <code class="hljs ruby">{<span class="hljs-string"><span class="hljs-string">"users"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:users-list</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:welcome-page</span></span>}}</code> </pre><br><pre> <code class="hljs json">[:div.row [:div {:on-click #(.log js/console <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)} <span class="hljs-string"><span class="hljs-string">"User "</span></span>]]</code> </pre><br><h3>  DB en la interfaz de usuario </h3><br>  Entonces, discutimos Clojure.  Pero mencion√© anteriormente que un gran logro en el backend fue la base de datos.  Si observa lo que est√° sucediendo en la interfaz ahora, veremos que los chicos usan el mismo patr√≥n: ingresan a la base de datos en la interfaz de usuario (en una aplicaci√≥n de una sola p√°gina). <br><br>  Las bases de datos se introducen en elm-architecture, en el marco de Ccripure con secuencia de comandos, e incluso en alguna forma limitada en flux y redux (se deben configurar complementos adicionales aqu√≠ para lanzar solicitudes).  La arquitectura, el nuevo marco y el flujo de Elm se lanzaron aproximadamente al mismo tiempo y se tomaron prestados el uno del otro.  Escribimos en remarcar.  A continuaci√≥n, hablar√© un poco sobre c√≥mo funciona. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/11e/ddf/8ff11eddf7c9e2eb3254a3d9eee47d3d.png"><br><br>  El evento (es un poco como redux) sale de la vista-chi, que es capturada por cierto controlador.  El controlador que llamamos controlador de eventos.  El controlador de eventos emite un efecto, que tambi√©n es alguien interpretado por la estructura de datos. <br><br>  Un tipo de efecto es actualizar la base de datos.  Es decir, toma el valor de la base de datos actual y devuelve uno nuevo.  Tambi√©n tenemos una suscripci√≥n, un an√°logo de solicitudes en el backend.  Es decir, estas son algunas consultas reactivas que podemos lanzar a esta base de datos.  Estas solicitudes reactivas, posteriormente nos agrupamos en la vista.  En el caso de reaccionar, parecemos volver a dibujar completamente, y si el resultado de esta solicitud ha cambiado, esto es conveniente. <br>  React est√° presente con nosotros solo en alg√∫n lugar al final, y en general la arquitectura no est√° relacionada de ninguna manera con √©l.  Se parece a esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/655/922/42b65592288ba93676e13b086f3f48b7.png"><br><br>  Aqu√≠ se agrega lo que falta, por ejemplo, en redux-s. <br><br>  Primero, separamos los efectos.  La aplicaci√≥n frontend no es independiente.  Tiene un cierto backend, una especie de "fuente de verdad".  La aplicaci√≥n debe escribir constantemente algo all√≠ y leer algo desde all√≠.  Peor a√∫n, si tiene varios backends a los que deber√≠a ir.  En la implementaci√≥n m√°s simple, esto se podr√≠a hacer directamente en el creador de acciones, en su controlador, pero esto es malo.  Por lo tanto, los chicos de re-frame introducen un nivel adicional de indirecci√≥n: una cierta estructura de datos sale del controlador, que dice lo que hay que hacer.  Y esta publicaci√≥n tiene su propio controlador que hace el trabajo sucio.  Esta es una introducci√≥n muy importante, que discutiremos m√°s adelante. <br><br>  Tambi√©n es importante (a veces se olvidan): algunos datos b√°sicos deben estar en la base.  Todo lo dem√°s se puede eliminar de la base de datos, y las consultas generalmente hacen esto, transforman los datos, no agregan nueva informaci√≥n, sino que estructuran correctamente la existente.  Necesitamos esta consulta.  En redux, en mi opini√≥n, esto ahora proporciona reselect, y en re-frame lo tenemos listo para usar (incorporado). <br><br>  Echa un vistazo a nuestro diagrama de arquitectura.  Reproducimos un peque√±o backend (en el estilo de la Web 2.0) con una base, controlador, vista.  Lo √∫nico agregado es la reactividad.  Esto es muy similar a MVC, excepto que todo est√° en un solo lugar.  Una vez que los primeros MVC para cada widget crearon su propio modelo, pero aqu√≠ todo se pliega en una base.  En principio, puede sincronizar con el backend desde el controlador a trav√©s del efecto, puede crear un aspecto m√°s gen√©rico para que la base de datos funcione como un proxy para el backend.  Incluso hay alg√∫n tipo de algoritmo gen√©rico: escribe en su base de datos local y se sincroniza con la principal. <br><br>  Ahora, en la mayor√≠a de los casos, la base es solo un tipo de objeto en el que escribimos algo en redux.  Pero, en principio, uno puede imaginar que m√°s adelante se convertir√° en una base de datos completa con un rico lenguaje de consulta.  Quiz√°s con alg√∫n tipo de sincronizaci√≥n gen√©rica.  Por ejemplo, hay datomic, una base de datos l√≥gica de triple tienda que se ejecuta directamente en el navegador.  Lo recoges y pones todo tu estado all√≠.  Datomic tiene un lenguaje de consulta bastante rico, comparable en potencia a SQL, e incluso gana en alg√∫n lugar.  Otro ejemplo es Google escribi√≥ lovefield.  Todo se mover√° a alguna parte all√≠. <br><br>  A continuaci√≥n explicar√© por qu√© necesitamos una suscripci√≥n reactiva. <br><br>  Ahora tenemos la primera percepci√≥n ingenua: conseguimos al usuario desde el backend, lo ponemos en la base de datos y luego tenemos que dibujarlo.  En el momento del renderizado, sucede mucha l√≥gica cierta, pero mezclamos esto con el renderizado, con la vista.  Si inmediatamente comenzamos a representar a este usuario, obtenemos una gran pieza dif√≠cil que hace algo con el DOM virtual y algo m√°s.  Y se mezcla con el modelo l√≥gico de nuestra visi√≥n. <br><br>  Un concepto muy importante que debe entenderse: debido a la complejidad de la interfaz de usuario, tambi√©n debe modelarse.  Es necesario separar c√≥mo se dibuja (como parece) de su modelo l√≥gico.  Entonces el modelo l√≥gico ser√° m√°s estable.  No puede cargarlo con la dependencia de un marco espec√≠fico: Angular, React o VueJS.  Un modelo es el ciudadano de primera clase habitual en su tiempo de ejecuci√≥n.  Idealmente, si son solo algunos datos y un conjunto de funciones por encima de ellos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/52f/9c3/c7b52f9c3c048a91276c3ae8dcd33771.png"><br><br>  Es decir, a partir del modelo de back-end (objeto), podemos obtener un modelo de vista en el que, sin utilizar ninguna representaci√≥n todav√≠a, podemos recrear el modelo l√≥gico.  Si hay alg√∫n tipo de men√∫ o algo similar, todo esto se puede hacer en el modelo de vista. <br><br><h3>  Por qu√© </h3><br>  ¬øPor qu√© estamos todos haciendo esto? <br><br>  He visto buenas pruebas de IU solo donde hay un equipo de 10 evaluadores. <br>  Por lo general, no hay pruebas de IU.  Por lo tanto, estamos tratando de sacar esta l√≥gica de los componentes en el modelo de vista.  La falta de pruebas es una muy mala se√±al, lo que indica que algo est√° mal all√≠, de alguna manera todo est√° mal estructurado. <br><br>  ¬øPor qu√© es dif√≠cil probar la IU?  ¬øPor qu√© los chicos del backend aprendieron c√≥mo probar su c√≥digo, proporcionaron una cobertura enorme y realmente ayuda a vivir con el c√≥digo del backend?  ¬øPor qu√© est√° mal la IU?  Lo m√°s probable es que estamos haciendo algo mal.  Y todo lo que describ√≠ anteriormente en realidad nos movi√≥ en la direcci√≥n de la capacidad de prueba. <br><br><h3>  ¬øC√≥mo hacemos pruebas? </h3><br>  Si observa de cerca, la parte de nuestra arquitectura, que contiene el controlador, la suscripci√≥n y la base de datos, ni siquiera est√° relacionada con JS.  Es decir, este es alg√∫n tipo de modelo que opera simplemente en estructuras de datos: los agregamos en alguna parte, de alguna manera transformamos, sacamos la consulta.  A trav√©s de los efectos, estamos desconectados de la interacci√≥n con el mundo exterior.  Y esta pieza es totalmente port√°til.  Se puede escribir en el llamado cljc: este es un subconjunto com√∫n entre Clojure Script y Clojure, que se comporta de la misma manera all√≠ y all√°.  Podemos cortar esta pieza de la interfaz y ponerla en la JVM, donde vive el backend.  Luego podemos escribir otro efecto en la JVM, que llega directamente al punto final: tira del enrutador sin ninguna conversi√≥n de cadena http, an√°lisis, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/b23/d1d/5b2b23d1d90d589a6cff9d99582d416d.png"><br><br>  Como resultado, podemos escribir una prueba muy simple: la misma prueba integral funcional que los chicos escriben en el back-end.  Lanzamos un evento determinado, arroja un efecto que golpea directamente el punto final en el backend.  Nos devuelve algo, lo coloca en la base de datos, calcula la suscripci√≥n y en la suscripci√≥n se encuentra una vista l√≥gica (ponemos all√≠ la l√≥gica de la interfaz de usuario al m√°ximo).  Afirmamos esta opini√≥n. <br><br>  Por lo tanto, podemos probar el 80% del c√≥digo en el back-end, mientras que todas las herramientas de desarrollo de back-end est√°n disponibles para nosotros.  Usando accesorios o algunas f√°bricas, podemos recrear una situaci√≥n espec√≠fica en la base de datos. <br><br>  Por ejemplo, tenemos un nuevo paciente o algo no se paga, etc.  Podemos pasar por un mont√≥n de posibles combinaciones. <br><br>  Por lo tanto, podemos lidiar con el segundo problema: con un sistema distribuido.  Debido a que el contrato entre los sistemas es precisamente el principal problema, porque estos son dos tiempos de ejecuci√≥n diferentes, dos sistemas diferentes: el backend cambi√≥ algo y algo se rompi√≥ en nuestra interfaz (no puede estar seguro de que esto no suceda). <br><br><h3>  Demostraci√≥n </h3><br>  As√≠ es como se ve en la pr√°ctica.  Este es un asistente de backend que limpi√≥ la base y escribi√≥ un peque√±o mundo en ella: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/ef0/e23/919ef0e23883707631e051ff6c62acf6.png"><br><br>  A continuaci√≥n lanzamos la suscripci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/bcb/35a/2a1bcb35a77444806d276e859f7aaebb.png"><br><br>  Por lo general, la URL define completamente la p√°gina y se produce alg√∫n evento: ahora est√° en tal o cual p√°gina con un conjunto de par√°metros.  Aqu√≠ entramos en un nuevo flujo de trabajo y nuestra suscripci√≥n regres√≥: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/956/34e/776/95634e7760690ebbef5ce5bbc51de9d6.png"><br><br>  Detr√°s de la escena, fue a la base, tom√≥ algo, lo puso en nuestra base de UI.  La suscripci√≥n funcion√≥ y se dedujo de √©l el modelo de vista l√≥gica. <br><br>  Lo inicializamos.  Y aqu√≠ est√° nuestro modelo l√≥gico: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d84/ee7/e0a/d84ee7e0a7e22ab8da638d8488df8833.png"><br><br>  Incluso sin mirar la interfaz de usuario, podemos adivinar lo que se dibujar√° de acuerdo con este modelo: vendr√° alguna advertencia, alguna informaci√≥n sobre el paciente, encuentros y un conjunto de enlaces (este es un widget de flujo de trabajo que dirige la recepci√≥n en ciertos pasos cuando llega el paciente). <br><br>  Aqu√≠ llegamos a un mundo m√°s complejo.  Hicieron algunos pagos y tambi√©n probaron despu√©s de la inicializaci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/032/f24/4ea032f24871cc57608dddf4687c30d7.png"><br><br>  Si ya ha pagado la visita, ver√° esto en la interfaz de usuario: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/71a/910/0b871a910ae3741ebd45e2b442f76d9c.png"><br><br>  Ejecutar pruebas, establecer en CI.  La sincronizaci√≥n entre el backend y el frontend estar√° garantizada por pruebas, y no honestamente. <br><br><h3>  De vuelta al backend? </h3><br>  Presentamos las pruebas hace seis meses y realmente nos gust√≥.  El problema de la l√≥gica borrosa persiste.  Cuanto m√°s inteligente se comporta una aplicaci√≥n comercial, m√°s informaci√≥n necesita para algunos pasos.  Si intenta ejecutar alg√∫n tipo de flujo de trabajo desde el mundo real all√≠, habr√° dependencias de todo: para cada interfaz de usuario, necesita obtener algo de diferentes partes de la base de datos en el back-end.  Si escribimos sistemas de contabilidad, esto no se puede evitar.  Como resultado, como dije, toda la l√≥gica est√° manchada. <br><br>  Con la ayuda de tales pruebas, podemos crear la ilusi√≥n al menos en tiempo de desarrollo, en el momento del desarrollo, de que nosotros, como en los viejos tiempos de la web 2.0, estamos sentados en el servidor en un tiempo de ejecuci√≥n y todo es c√≥modo. <br><br>  Otra idea loca surgi√≥ (a√∫n no se ha implementado).  ¬øPor qu√© no bajar esta parte al backend?  ¬øPor qu√© no alejarse completamente de la aplicaci√≥n distribuida ahora?  ¬øDeje que esta suscripci√≥n y nuestro modelo de vista se generen en el backend?  All√≠ la base est√° disponible, todo es sincr√≥nico.  Todo es simple y claro. <br><br>  La primera ventaja que veo en esto es que tendremos control en un solo lugar.  Simplemente simplificamos todo de inmediato en comparaci√≥n con nuestra aplicaci√≥n distribuida.  Las pruebas se vuelven simples, las validaciones dobles desaparecen.  El mundo de moda de los sistemas interactivos multiusuario se abre (si dos usuarios van a la misma forma, les informamos al respecto; pueden editarla al mismo tiempo). <br><br>  Aparece una caracter√≠stica interesante: al ir al backend y al prospecto de la sesi√≥n, podemos entender qui√©n est√° actualmente en el sistema y qu√© est√° haciendo.  Esto es un poco como el desarrollo del juego, donde los servidores funcionan as√≠.  All√≠ el mundo vive en el servidor, y el front-end solo se renderiza.  Como resultado, podemos obtener un cierto cliente ligero. <br><br>  Por otro lado, esto crea un desaf√≠o.  Tendremos que tener un servidor con estado en el que vivan estas sesiones.  Si tenemos varios servidores de aplicaciones, ser√° necesario equilibrar adecuadamente la carga o replicar la sesi√≥n.  Sin embargo, existe la sospecha de que este problema es menor que la cantidad de ventajas que obtenemos. <br><br>  Por lo tanto, vuelvo al eslogan principal: hay muchos tipos de aplicaciones que se pueden escribir sin distribuir, para eliminar la complejidad de ellas.  Y puede obtener un aumento m√∫ltiple en la eficiencia si revisa una vez m√°s los postulados b√°sicos en los que confiamos en el desarrollo. <br><br><blockquote>  Si le gust√≥ el informe, preste atenci√≥n: del 24 al 25 de noviembre, se celebrar√° un nuevo <b>HolyJS</b> en Mosc√∫, y tambi√©n habr√° muchas cosas interesantes all√≠.  La informaci√≥n ya conocida sobre el programa est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio</a> , y los boletos se pueden comprar all√≠. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421789/">https://habr.com/ru/post/es421789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421775/index.html">Red neuronal entrenada para reconocer la depresi√≥n mediante el discurso arbitrario de una persona sin contexto</a></li>
<li><a href="../es421779/index.html">OceanLotus: nueva puerta trasera, viejos esquemas</a></li>
<li><a href="../es421783/index.html">Fun State Management Huex Framework</a></li>
<li><a href="../es421785/index.html">California est√° a punto de rechazar por completo el carbono en la producci√≥n de energ√≠a.</a></li>
<li><a href="../es421787/index.html">Desarrollo de arquitectura de proyectos, naves y JavaScript</a></li>
<li><a href="../es421791/index.html">Cuestiones √©ticas de la inteligencia artificial</a></li>
<li><a href="../es421793/index.html">En busca de lo mejor o c√≥mo elegimos la red blockchain para el proyecto</a></li>
<li><a href="../es421795/index.html">Decisi√≥n basada en datos sobre el ejemplo de elegir un color para pintar paredes</a></li>
<li><a href="../es421797/index.html">¬øPor qu√© necesitas Splunk? Monitoreo de infraestructura de TI</a></li>
<li><a href="../es421799/index.html">¬øC√≥mo conseguir un trabajo de forma remota en una empresa que no acepta empleados remotos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>