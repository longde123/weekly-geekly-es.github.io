<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§’ğŸ» ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸ§ğŸ½ Lima Metode Untuk Kebingungan Basis Data ğŸŒ‹ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸŒ–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengguna ClickHouse sudah tahu bahwa keuntungan terbesarnya adalah pemrosesan kueri analitik berkecepatan tinggi. Tetapi klaim seperti ini perlu dikon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lima Metode Untuk Kebingungan Basis Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/485096/">  Pengguna ClickHouse sudah tahu bahwa keuntungan terbesarnya adalah pemrosesan kueri analitik berkecepatan tinggi.  Tetapi klaim seperti ini perlu dikonfirmasi dengan pengujian kinerja yang andal.  Itulah yang ingin kita bicarakan hari ini. <br><br> <a href="https://habr.com/en/company/yandex/blog/457354/"><img src="https://habrastorage.org/webt/ds/2m/sd/ds2msd5-4zeahpzlzptlqz8wgs8.png"></a> <br><br>  Kami mulai menjalankan tes pada 2013, jauh sebelum produk tersedia sebagai sumber terbuka.  Saat itu, sama seperti sekarang, perhatian utama kami adalah kecepatan pemrosesan data di Yandex.Metrica.  Kami telah menyimpan data itu di ClickHouse sejak Januari 2009. Sebagian data telah ditulis ke database mulai tahun 2012, dan sebagian dikonversi dari <a href="https://clickhouse.yandex/blog/evolution-of-data-structures-in-yandex-metrica">OLAPServer dan Metrage</a> (struktur data yang sebelumnya digunakan oleh Yandex.Metrica).  Untuk pengujian, kami mengambil subset pertama secara acak dari data selama 1 miliar tampilan halaman.  Yandex.Metrica tidak memiliki pertanyaan apa pun pada saat itu, jadi kami membuat pertanyaan yang menarik bagi kami, menggunakan semua cara yang mungkin untuk memfilter, menggabungkan, dan mengurutkan data. <br><br>  Kinerja ClickHouse dibandingkan dengan sistem serupa seperti Vertica dan MonetDB.  Untuk menghindari bias, pengujian dilakukan oleh karyawan yang tidak berpartisipasi dalam pengembangan ClickHouse, dan kasus khusus dalam kode tidak dioptimalkan hingga semua hasil diperoleh.  Kami menggunakan pendekatan yang sama untuk mendapatkan set data untuk pengujian fungsional. <br><br>  Setelah ClickHouse dirilis sebagai sumber terbuka pada tahun 2016, orang-orang mulai mempertanyakan tes ini. <br><br><a name="habracut"></a><h2>  Kekurangan tes pada data pribadi </h2><br>  Tes kinerja kami: <br><br><ol><li>  Tidak dapat direproduksi secara independen karena mereka menggunakan data pribadi yang tidak dapat dipublikasikan.  Beberapa tes fungsional tidak tersedia untuk pengguna eksternal karena alasan yang sama. </li><li>  Perlu pengembangan lebih lanjut.  Serangkaian tes perlu diperluas secara substansial untuk mengisolasi perubahan kinerja pada bagian-bagian sistem. </li><li>  Jangan dijalankan berdasarkan per-komit atau untuk permintaan penarikan individual.  Pengembang eksternal tidak dapat memeriksa kode mereka untuk regresi kinerja. </li></ol><br>  Kita bisa menyelesaikan masalah ini dengan membuang tes lama dan menulis yang baru berdasarkan data terbuka, seperti <a href="https://clickhouse.yandex/docs/en/getting_started/example_datasets/ontime">data penerbangan untuk Amerika Serikat</a> dan <a href="https://clickhouse.yandex/docs/en/getting_started/example_datasets/nyc_taxi">naik taksi di New York</a> .  Atau kita bisa menggunakan tolok ukur seperti TPC-H, TPC-DS, dan <a href="https://clickhouse.yandex/docs/en/getting_started/example_datasets/star_schema">Star Schema Benchmark</a> .  Kerugiannya adalah bahwa data ini sangat berbeda dari data Yandex.Metrica, dan kami lebih suka menyimpan pertanyaan pengujian. <br><br><h2>  Mengapa penting menggunakan data nyata </h2><br>  Kinerja seharusnya hanya diuji pada data nyata dari lingkungan produksi.  Mari kita lihat beberapa contoh. <br><br>  <strong>Contoh 1</strong> <br><br>  Katakanlah Anda mengisi basis data dengan nomor pseudorandom yang didistribusikan secara merata.  Kompresi data tidak akan berfungsi dalam kasus ini, meskipun kompresi data sangat penting untuk database analitik.  Tidak ada solusi peluru perak untuk tantangan memilih algoritma kompresi yang tepat dan cara yang tepat untuk mengintegrasikannya ke dalam sistem, karena kompresi data memerlukan kompromi antara kecepatan kompresi dan dekompresi dan potensi efisiensi kompresi.  Tetapi sistem yang tidak bisa mengompres data dijamin kalah.  Jika pengujian Anda menggunakan angka acak acak yang didistribusikan secara merata, faktor ini diabaikan, dan hasilnya akan terdistorsi. <br><br>  Intinya: Data uji harus memiliki rasio kompresi yang realistis. <br><br>  Saya membahas optimasi algoritma kompresi data ClickHouse di <a href="https://habr.com/en/company/yandex/blog/457612/">posting sebelumnya</a> . <br><br>  <strong>Contoh 2</strong> <br><br>  Katakanlah kami tertarik pada kecepatan eksekusi query SQL ini: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> RegionID, uniq(UserID) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> visitors <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> test.hits <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> RegionID <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> visitors <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Ini adalah permintaan khas untuk Yandex.Metrica.  Apa yang mempengaruhi kecepatan pemrosesan? <br><br><ul><li>  Bagaimana GROUP BY dijalankan. </li><li>  Struktur data mana yang digunakan untuk menghitung fungsi agregat uniq. </li><li>  Berapa banyak RegionID yang berbeda dan berapa banyak RAM yang diperlukan oleh setiap negara bagian dari fungsi uniq. </li></ul><br>  Tetapi faktor penting lainnya adalah bahwa jumlah data didistribusikan secara tidak merata antar wilayah.  (Ini mungkin mengikuti hukum kekuasaan. Saya meletakkan distribusi pada grafik log-log, tapi saya tidak bisa mengatakannya dengan pasti.) Jika ini masalahnya, penting bahwa keadaan fungsi agregat uniq dengan nilai penggunaan yang lebih sedikit memori yang sangat sedikit.  Ketika ada banyak kunci agregasi yang berbeda, setiap byte dihitung.  Bagaimana kita bisa mendapatkan data yang dihasilkan yang memiliki semua properti ini?  Solusi yang jelas adalah menggunakan data nyata. <br><br>  Banyak DBMS menerapkan struktur data HyperLogLog untuk perkiraan COUNT (DISTINCT), tetapi tidak ada yang bekerja dengan sangat baik karena struktur data ini menggunakan jumlah memori yang tetap.  ClickHouse memiliki fungsi yang menggunakan <a href="https://clickhouse.yandex/docs/en/query_language/agg_functions/reference/">kombinasi tiga struktur data yang berbeda</a> , tergantung pada ukuran kumpulan data. <br><br>  Intinya: Data uji harus mewakili sifat distribusi dari data nyata dengan cukup baik, yang berarti kardinalitas (jumlah nilai berbeda per kolom) dan kardinalitas lintas-kolom (jumlah nilai yang berbeda dihitung di beberapa kolom yang berbeda). <br><br>  <strong>Contoh 3</strong> <br><br>  Alih-alih menguji kinerja DBMS ClickHouse, mari kita ambil sesuatu yang lebih sederhana, seperti tabel hash.  Untuk tabel hash, penting untuk memilih fungsi hash yang tepat.  Ini tidak sepenting std :: unordered_map, karena ini adalah tabel hash berdasarkan chaining dan bilangan prima digunakan sebagai ukuran array.  Implementasi pustaka standar dalam GCC dan Dentang menggunakan fungsi hash sepele sebagai fungsi hash default untuk tipe numerik.  Namun, std :: unordered_map bukanlah pilihan terbaik saat kami mencari kecepatan maksimum.  Dengan tabel hash pengalamatan terbuka, kita tidak bisa hanya menggunakan fungsi hash standar.  Memilih fungsi hash yang tepat menjadi faktor penentu. <br><br>  Sangat mudah untuk menemukan tes kinerja tabel hash menggunakan data acak yang tidak mempertimbangkan fungsi hash yang digunakan.  Ada juga banyak tes fungsi hash yang berfokus pada kecepatan perhitungan dan kriteria kualitas tertentu, meskipun mereka mengabaikan struktur data yang digunakan.  Tetapi kenyataannya adalah bahwa tabel hash dan HyperLogLog memerlukan kriteria kualitas fungsi hash yang berbeda. <br><br><img src="https://habrastorage.org/webt/bp/3h/32/bp3h320eztrirqzhm-lexeuhmbq.png"><br><br>  Anda dapat mempelajari lebih lanjut tentang ini di <a href="https://www.youtube.com/watch%3Fv%3DEoX82TEz2sQ">"Bagaimana tabel hash bekerja di ClickHouse"</a> (presentasi dalam bahasa Rusia).  Informasi ini sedikit ketinggalan zaman, karena tidak mencakup <a href="https://abseil.io/blog/20180927-swisstables">Tabel Swiss</a> . <br><br><h2>  Tantangan </h2><br>  Tujuan kami adalah untuk memperoleh data untuk menguji kinerja yang memiliki struktur yang sama dengan data Yandex.Metrica dengan semua properti yang penting untuk tolok ukur, tetapi sedemikian rupa sehingga tidak ada jejak pengguna situs web nyata dalam data ini.  Dengan kata lain, data harus dianonimkan dan masih dipertahankan: <br><br><ul><li>  Rasio kompresi. </li><li>  Kardinalitas (jumlah nilai yang berbeda). </li><li>  Kardinalitas timbal balik antara beberapa kolom berbeda. </li><li>  Properti distribusi probabilitas yang dapat digunakan untuk pemodelan data (misalnya, jika kami percaya bahwa wilayah didistribusikan menurut hukum daya, maka eksponen - parameter distribusi - harus kira-kira sama untuk data buatan dan untuk data nyata). </li></ul><br>  Bagaimana kita bisa mendapatkan rasio kompresi yang sama untuk data?  Jika LZ4 digunakan, substring dalam data biner harus diulang kira-kira pada jarak yang sama dan pengulangan harus kira-kira sama panjangnya.  Untuk ZSTD, entropi per byte juga harus bersamaan. <br><br>  Tujuan utamanya adalah membuat alat yang tersedia untuk umum yang dapat digunakan siapa saja untuk menganonimkan set data mereka untuk publikasi.  Ini akan memungkinkan kami untuk melakukan debug dan menguji kinerja pada data orang lain yang serupa dengan data produksi kami.  Kami juga ingin agar data yang dihasilkan menarik. <br><br>  Namun, ini adalah persyaratan yang sangat longgar dan kami tidak berencana untuk menulis pernyataan masalah formal atau spesifikasi untuk tugas ini. <br><br><h2>  Kemungkinan solusi </h2><br>  Saya tidak ingin membuatnya terdengar seperti masalah ini sangat penting.  Itu tidak pernah benar-benar dimasukkan dalam perencanaan dan tidak ada yang punya niat untuk mengerjakannya.  Saya hanya terus berharap bahwa suatu ide akan muncul suatu hari, dan tiba-tiba saya akan berada dalam suasana hati yang baik dan dapat menunda semuanya sampai nanti. <br><br><h2>  Model probabilistik eksplisit </h2><br>  Gagasan pertama adalah mengambil setiap kolom dalam tabel dan menemukan keluarga distribusi probabilitas yang memodelkannya, kemudian menyesuaikan parameter berdasarkan statistik data (pemasangan model) dan menggunakan distribusi yang dihasilkan untuk menghasilkan data baru.  Generator nomor pseudorandom dengan benih yang telah ditentukan dapat digunakan untuk mendapatkan hasil yang dapat direproduksi. <br><br>  Rantai Markov dapat digunakan untuk bidang teks.  Ini adalah model yang akrab yang dapat diimplementasikan secara efektif. <br><br>  Namun, itu membutuhkan beberapa trik: <br><br><ul><li>  Kami ingin menjaga kesinambungan rangkaian waktu.  Ini berarti bahwa untuk beberapa jenis data, kita perlu memodelkan perbedaan antara nilai-nilai tetangga, bukan nilai itu sendiri. </li><li>  Untuk memodelkan "kardinalitas bersama" kolom kita juga harus secara eksplisit mencerminkan dependensi antar kolom.  Misalnya, biasanya ada sangat sedikit alamat IP per ID pengguna, jadi untuk menghasilkan alamat IP kami akan menggunakan nilai hash ID pengguna sebagai seed dan juga menambahkan sejumlah kecil data pseudorandom lainnya. </li><li>  Kami tidak yakin bagaimana mengekspresikan ketergantungan yang sering dikunjungi pengguna yang sama dengan URL domain yang cocok pada waktu yang bersamaan. </li></ul><br>  Semua ini dapat ditulis dalam "script" C ++ dengan distribusi dan dependensi yang dikodekan dengan keras.  Namun, model Markov diperoleh dari kombinasi statistik dengan smoothing dan menambahkan noise.  Saya mulai menulis skrip seperti ini, tetapi setelah menulis model eksplisit untuk sepuluh kolom, itu menjadi sangat membosankan - dan tabel "hit" di Yandex.Metrica memiliki lebih dari 100 kolom pada tahun 2012. <br><br><pre> <code class="cpp hljs">EventTime.day(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::discrete_distribution&lt;&gt;({ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, ...})(random)); EventTime.hour(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::discrete_distribution&lt;&gt;({ <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, ...})(random)); EventTime.minute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;UInt8&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>)(random)); EventTime.second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;UInt8&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>)(random)); UInt64 UserID = hash(<span class="hljs-number"><span class="hljs-number">4</span></span>, powerLaw(<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">1.1</span></span>)); UserID = UserID / <span class="hljs-number"><span class="hljs-number">10000000000U</span></span>LL * <span class="hljs-number"><span class="hljs-number">10000000000U</span></span>LL + <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>&gt;(EventTime) + UserID % <span class="hljs-number"><span class="hljs-number">1000000</span></span>; random_with_seed.seed(powerLaw(<span class="hljs-number"><span class="hljs-number">5000</span></span>, <span class="hljs-number"><span class="hljs-number">1.1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> get_random_with_seed = [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> random_with_seed(); };</code> </pre><br>  Pendekatan ini gagal.  Jika saya berusaha lebih keras, mungkin skripnya sudah siap sekarang. <br><br>  Keuntungan: <br><br><ul><li>  Kesederhanaan konseptual. </li></ul><br>  Kekurangan: <br><br><ul><li>  Diperlukan banyak pekerjaan. </li><li>  Solusinya hanya berlaku untuk satu jenis data. </li></ul><br>  Dan saya lebih suka solusi yang lebih umum yang dapat digunakan untuk data Yandex.Metrica serta untuk mengaburkan data lainnya. <br><br>  Bagaimanapun, solusi ini dapat ditingkatkan.  Alih-alih memilih model secara manual, kita dapat mengimplementasikan katalog model dan memilih yang terbaik di antara mereka (paling cocok ditambah beberapa bentuk regularisasi).  Atau mungkin kita bisa menggunakan model Markov untuk semua jenis bidang, bukan hanya untuk teks.  Ketergantungan antara data juga dapat diekstraksi secara otomatis.  Ini akan membutuhkan penghitungan <a href="https://en.wikipedia.org/wiki/Kullback%25E2%2580%2593Leibler_divergence">entropi</a> relatif (jumlah relatif informasi) antar kolom.  Alternatif yang lebih sederhana adalah menghitung kardinalitas relatif untuk setiap pasangan kolom (sesuatu seperti "berapa banyak nilai A yang berbeda rata-rata untuk nilai tetap B").  Misalnya, ini akan memperjelas bahwa URLDomain sepenuhnya tergantung pada URL, dan bukan sebaliknya. <br><br>  Tetapi saya juga menolak ide ini, karena ada terlalu banyak faktor untuk dipertimbangkan dan akan terlalu lama untuk ditulis. <br><br><h2>  Jaringan saraf </h2><br>  Seperti yang telah saya sebutkan, tugas ini tidak tinggi pada daftar prioritas - tidak ada yang berpikir untuk mencoba menyelesaikannya.  Tetapi seperti nasib yang beruntung, kolega kami Ivan Puzirevsky mengajar di Sekolah Tinggi Ekonomi.  Dia bertanya kepada saya apakah saya memiliki masalah menarik yang akan berfungsi sebagai topik tesis yang cocok untuk murid-muridnya.  Ketika saya menawarinya yang satu ini, dia meyakinkan saya bahwa potensinya.  Jadi saya memberikan tantangan ini kepada seorang pria baik "di jalan" Sharif (dia memang harus menandatangani NDA untuk mengakses data, meskipun). <br><br>  Saya membagikan semua ide saya dengannya tetapi menekankan bahwa tidak ada batasan tentang bagaimana masalah itu dapat diselesaikan, dan pilihan yang baik adalah mencoba pendekatan yang tidak saya ketahui, seperti menggunakan LSTM untuk menghasilkan data teks.  Ini tampak menjanjikan setelah menemukan artikel <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">Efektivitas Yang Tidak Beralasan dari Jaringan Syaraf Berulang</a> . <br><br>  Tantangan pertama adalah kita perlu menghasilkan data terstruktur, bukan hanya teks.  Tetapi tidak jelas apakah jaringan saraf berulang dapat menghasilkan data dengan struktur yang diinginkan.  Ada dua cara untuk menyelesaikan ini.  Solusi pertama adalah menggunakan model terpisah untuk menghasilkan struktur dan "pengisi" dan hanya menggunakan jaringan saraf untuk menghasilkan nilai.  Namun pendekatan ini ditunda dan kemudian tidak pernah selesai.  Solusi kedua adalah dengan hanya menghasilkan dump TSV sebagai teks.  Pengalaman menunjukkan bahwa beberapa baris dalam teks tidak cocok dengan struktur, tetapi baris ini dapat dibuang saat memuat data. <br><br>  Tantangan kedua adalah bahwa jaringan saraf berulang menghasilkan urutan data, dan dengan demikian ketergantungan pada data harus mengikuti urutan urutan.  Tetapi dalam data kami, urutan kolom berpotensi terbalik untuk dependensi di antara mereka. <br>  Kami tidak melakukan apa pun untuk menyelesaikan masalah ini. <br><br>  Saat musim panas mendekat, kami memiliki skrip Python yang berfungsi pertama yang menghasilkan data.  Sekilas kualitas data tampak layak: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f31/4c0/56f/f314c056f24678ea65fdeec9076991bc.jpg"><br><br>  Namun, kami mengalami beberapa kesulitan: <br><br><ol><li>  Ukuran model ini sekitar satu gigabyte.  Kami mencoba membuat model untuk data yang berukuran beberapa gigabytes (untuk permulaan).  Fakta bahwa model yang dihasilkan sangat besar menimbulkan kekhawatiran.  Apakah mungkin untuk mengekstraksi data nyata yang dilatihnya?  Tidak mungkin.  Tapi saya tidak tahu banyak tentang pembelajaran mesin dan jaringan saraf, dan saya belum membaca kode Python pengembang ini, jadi bagaimana saya bisa yakin?  Ada beberapa artikel yang diterbitkan pada saat itu tentang cara mengompres jaringan saraf tanpa kehilangan kualitas, tetapi tidak diimplementasikan.  Di satu sisi, ini tampaknya tidak menjadi masalah serius, karena kita dapat memilih keluar dari menerbitkan model dan hanya menerbitkan data yang dihasilkan.  Di sisi lain, jika terjadi overfitting, data yang dihasilkan dapat berisi beberapa bagian dari data sumber. </li><li>  Pada mesin dengan CPU tunggal, kecepatan pembuatan data sekitar 100 baris per detik.  Tujuan kami adalah menghasilkan setidaknya satu miliar baris.  Perhitungan menunjukkan bahwa ini tidak akan selesai sebelum tanggal pertahanan tesis.  Tidak masuk akal untuk menggunakan perangkat keras tambahan, karena tujuannya adalah membuat alat pembuatan data yang dapat digunakan oleh siapa saja. </li></ol><br>  Sharif mencoba menganalisis kualitas data dengan membandingkan statistik.  Antara lain, ia menghitung frekuensi karakter berbeda yang terjadi pada sumber data dan dalam data yang dihasilkan.  Hasilnya menakjubkan: karakter yang paling sering adalah Ã dan Ã‘. <br><br>  Tapi jangan khawatir tentang Sharif.  Dia berhasil mempertahankan tesisnya dan kemudian kami dengan senang hati melupakan semuanya. <br><br><h2>  Mutasi data terkompresi </h2><br>  Mari kita asumsikan bahwa pernyataan masalah telah direduksi menjadi satu titik: kita perlu menghasilkan data yang memiliki rasio kompresi yang sama dengan data sumber, dan data harus didekompresi pada kecepatan yang sama.  Bagaimana kita bisa mencapai ini?  Kita perlu mengedit byte data terkompresi secara langsung!  Ini memungkinkan kita untuk mengubah data tanpa mengubah ukuran data yang dikompresi, ditambah semuanya akan bekerja dengan cepat.  Saya ingin mencoba ide ini segera, terlepas dari kenyataan bahwa masalah yang dipecahkannya tidak sama dengan yang kami mulai.  Tapi begitulah adanya. <br><br>  Jadi bagaimana kita mengedit file terkompresi?  Katakanlah kita hanya tertarik pada LZ4.  Data terkompresi LZ4 terdiri dari urutan, yang pada gilirannya adalah string byte tidak dikompresi (literal), diikuti oleh salinan pertandingan: <br><br><ol><li>  Literal (salin N byte berikut apa adanya). </li><li>  Cocok dengan panjang pengulangan minimum 4 (ulangi N byte yang ada di file pada jarak M). </li></ol><br>  Sumber data: <br>  <code>Hello world Hello</code> . <br><br>  Data terkompresi (contoh sewenang-wenang): <br>  <code>literals 12 "Hello world " match 5 12</code> . <br><br>  Dalam file terkompresi, kita membiarkan "cocok" apa adanya, dan mengubah nilai byte dalam "literal".  Akibatnya, setelah dekompresi, kami mendapatkan file di mana semua urutan berulang setidaknya 4 byte panjang juga diulang pada jarak yang sama, tetapi mereka terdiri dari set byte yang berbeda (pada dasarnya, file yang dimodifikasi tidak mengandung satu pun byte yang diambil dari file sumber). <br><br>  Tetapi bagaimana kita mengubah byte?  Jawabannya tidak jelas, karena selain jenis kolom, data juga memiliki struktur internal, implisit yang ingin kami pertahankan.  Misalnya, teks sering disimpan dalam pengkodean UTF-8, dan kami ingin data yang dihasilkan juga valid UTF-8.  Saya mengembangkan heuristik sederhana yang melibatkan memenuhi beberapa kriteria: <br><br><ul><li>  Null byte dan karakter kontrol ASCII disimpan apa adanya. </li><li>  Beberapa karakter tanda baca tetap apa adanya. </li><li>  ASCII dikonversi ke ASCII dan untuk yang lainnya bit yang paling signifikan dipertahankan (atau set eksplisit pernyataan "jika" ditulis untuk panjang UTF-8 yang berbeda).  Dalam kelas satu byte nilai baru diambil secara acak. </li><li>  Fragmen seperti <code>https://</code> dipelihara, jika tidak terlihat agak konyol. </li></ul><br>  Satu-satunya peringatan untuk pendekatan ini adalah bahwa model data adalah sumber data itu sendiri, yang berarti tidak dapat dipublikasikan.  Model ini hanya cocok untuk menghasilkan jumlah data yang tidak lebih besar dari sumbernya.  Sebaliknya, pendekatan sebelumnya menyediakan model yang memungkinkan menghasilkan data dengan ukuran sewenang-wenang. <br><br>  Contoh untuk URL: <br><br> <code>http://ljc.she/kdoqdqwpgafe/klwlpm&amp;qw=962788775I0E7bs7OXeAyAx <br> http://ljc.she/kdoqdqwdffhant.am/wcpoyodjit/cbytjgeoocvdtclac <br> http://ljc.she/kdoqdqwpgafe/klwlpm&amp;qw=962788775I0E7bs7OXe <br> http://ljc.she/kdoqdqwdffhant.am/wcpoyodjit/cbytjgeoocvdtclac <br> http://ljc.she/kdoqdqwdbknvj.s/hmqhpsavon.yf#aortxqdvjja <br> http://ljc.she/kdoqdqw-bknvj.s/hmqhpsavon.yf#aortxqdvjja <br> http://ljc.she/kdoqdqwpdtu-Unu-Rjanjna-bbcohu_qxht <br> http://ljc.she/kdoqdqw-bknvj.s/hmqhpsavon.yf#aortxqdvjja <br> http://ljc.she/kdoqdqwpdtu-Unu-Rjanjna-bbcohu_qxht <br> http://ljc.she/kdoqdqw-bknvj.s/hmqhpsavon.yf#aortxqdvjja <br> http://ljc.she/kdoqdqwpdtu-Unu-Rjanjna-bbcohu-702130 <br></code> <br>  Hasilnya positif dan datanya menarik, tetapi ada sesuatu yang tidak beres.  URL mempertahankan struktur yang sama, tetapi di beberapa di antaranya terlalu mudah untuk mengenali "yandex" atau "avito" (pasar yang populer di Rusia), jadi saya membuat heuristik yang menukar beberapa byte di sekitar. <br><br>  Ada juga kekhawatiran lain.  Misalnya, informasi sensitif mungkin berada di kolom FixedString dalam representasi biner dan berpotensi terdiri dari karakter kontrol ASCII dan tanda baca, yang saya putuskan untuk dipertahankan.  Namun, saya tidak mempertimbangkan tipe data. <br><br>  Masalah lain adalah bahwa jika sebuah kolom menyimpan data dalam format "length, value" (ini adalah bagaimana kolom String disimpan), bagaimana cara memastikan bahwa panjangnya tetap benar setelah mutasi?  Ketika saya mencoba untuk memperbaikinya, saya langsung kehilangan minat. <br><br><h2>  Permutasi acak </h2><br>  Sayangnya, masalahnya tidak terpecahkan.  Kami melakukan beberapa percobaan, dan itu menjadi lebih buruk.  Satu-satunya yang tersisa adalah duduk dan tidak melakukan apa pun dan menjelajahi web secara acak, karena sihirnya telah hilang.  Untungnya, saya menemukan halaman yang <a href="http://fabiensanglard.net/fizzlefade/index.php">menjelaskan algoritma</a> untuk rendering kematian karakter utama di game Wolfenstein 3D. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d4/974/bc8/6d4974bc880538a894617dfb0c77eb3d.gif" width="640" height="480"><br><br>  Animasi ini dilakukan dengan sangat baik - layar dipenuhi dengan darah.  Artikel ini menjelaskan bahwa ini sebenarnya permutasi acak pseudorandom.  Permutasi acak dari sekumpulan elemen adalah transformasi bijective (satu-ke-satu) yang dipilih secara acak, atau pemetaan di mana masing-masing dan setiap elemen turunan berhubungan dengan tepat satu elemen asli (dan sebaliknya).  Dengan kata lain, ini adalah cara untuk secara acak beralih melalui semua elemen dari kumpulan data.  Dan itulah proses yang ditunjukkan dalam gambar: setiap piksel diisi dalam urutan acak, tanpa pengulangan.  Jika kita hanya memilih piksel acak pada setiap langkah, itu akan memakan waktu lama untuk sampai ke yang terakhir. <br><br>  Gim ini menggunakan algoritma yang sangat sederhana untuk permutasi pseudorandom yang disebut linear feedback shift register ( <a href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">LFSR</a> ).  Mirip dengan generator nomor pseudorandom, permutasi acak, atau lebih tepatnya keluarga mereka, dapat secara kriptografis kuat ketika diparetrize oleh kunci.  Inilah yang kita butuhkan untuk transformasi data.  Namun, detailnya mungkin lebih sulit.  Sebagai contoh, enkripsi kriptografis yang kuat dari N byte ke N byte dengan kunci yang ditentukan sebelumnya dan vektor inisialisasi tampaknya akan bekerja untuk permutasi pseudorandom satu set string N-byte.  Memang, ini adalah transformasi satu-ke-satu dan tampaknya acak.  Tetapi jika kita menggunakan transformasi yang sama untuk semua data kita, hasilnya mungkin rentan terhadap analisis kripto karena vektor inisialisasi dan nilai kunci yang sama digunakan beberapa kali.  Ini mirip dengan mode operasi <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">Codebook Elektronik</a> untuk cipher blok. <br><br>  Apa cara yang mungkin untuk mendapatkan permutasi pseudorandom?  Kita dapat mengambil transformasi satu-ke-satu yang sederhana dan membangun fungsi kompleks yang terlihat acak.  Berikut adalah beberapa transformasi satu-ke-satu favorit saya: <br><br><ul><li>  Perkalian dengan bilangan ganjil (seperti bilangan prima yang besar) dalam aritmatika komplemen dua. </li><li>  Xorshift: <code>x ^= x &gt;&gt; N</code> </li><li>  CRC-N, di mana N adalah jumlah bit dalam argumen. </li></ul><br>  Sebagai contoh, tiga perkalian dan dua operasi xorshift digunakan untuk finalizer <a href="">murmurhash</a> .  Operasi ini adalah permutasi pseudorandom.  Namun, saya harus menunjukkan bahwa fungsi hash tidak harus satu-ke-satu (bahkan hash dari N bits ke N bits). <br><br>  Atau inilah <a href="https://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/">contoh</a> menarik lainnya <a href="https://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/">dari teori bilangan dasar</a> dari situs web Jeff Preshing. <br><br>  Bagaimana kita bisa menggunakan permutasi pseudorandom untuk menyelesaikan masalah kita?  Kita dapat menggunakannya untuk mengubah semua bidang angka sehingga kita dapat mempertahankan kardinalitas dan kardinalitas bersama dari semua kombinasi bidang.  Dengan kata lain, COUNT (DISTINCT) akan mengembalikan nilai yang sama seperti sebelum transformasi, dan selanjutnya, dengan GROUP BY. <br><br>  Perlu dicatat bahwa menjaga semua kardinalitas agak bertentangan dengan tujuan anonimisasi data kami.  Katakanlah seseorang tahu bahwa sumber data untuk sesi situs berisi pengguna yang mengunjungi situs dari 10 negara yang berbeda, dan mereka ingin menemukan pengguna itu dalam data yang diubah.  Data yang diubah juga menunjukkan bahwa pengguna mengunjungi situs dari 10 negara yang berbeda, yang memudahkan untuk mempersempit pencarian.  Bahkan jika mereka mengetahui apa yang ditransformasikan oleh pengguna, itu tidak akan sangat berguna, karena semua data lain juga telah ditransformasikan, sehingga mereka tidak akan dapat mengetahui situs apa yang dikunjungi oleh pengguna atau hal lainnya.  Namun aturan ini bisa diterapkan dalam sebuah rantai.  Misalnya, jika seseorang tahu bahwa situs web yang paling sering terjadi dalam data kami adalah Yandex, dengan Google di tempat kedua, mereka hanya dapat menggunakan peringkat untuk menentukan pengidentifikasi situs yang diubah yang sebenarnya berarti Yandex dan Google.  Tidak ada yang mengejutkan tentang ini, karena kami bekerja dengan pernyataan masalah informal dan kami hanya mencoba untuk menemukan keseimbangan antara penganoniman data (menyembunyikan informasi) dan menjaga properti data (pengungkapan informasi).  Untuk informasi tentang cara mendekati masalah anonimisasi data dengan lebih andal, baca <a href="https://medium.com/georgian-impact-blog/a-brief-introduction-to-differential-privacy-eacf8722283b">artikel</a> ini. <br><br>  Selain menjaga kardinalitas asli dari nilai, saya juga ingin menjaga urutan besarnya nilai.  Maksud saya adalah bahwa jika sumber data berisi angka di bawah 10, maka saya ingin angka yang diubah juga kecil.  Bagaimana kita bisa mencapai ini? <br><br>  Sebagai contoh, kita dapat membagi satu set nilai yang mungkin menjadi kelas ukuran dan melakukan permutasi dalam setiap kelas secara terpisah (mempertahankan kelas ukuran).  Cara termudah untuk melakukan ini adalah dengan mengambil kekuatan terdekat dari dua atau posisi bit paling signifikan dalam jumlah sebagai kelas ukuran (ini adalah hal yang sama).  Angka 0 dan 1 akan selalu tetap apa adanya.  Angka 2 dan 3 terkadang akan tetap apa adanya (dengan probabilitas 1/2) dan kadang-kadang akan ditukar (dengan probabilitas 1/2).  Himpunan angka 1024. 2047 akan dipetakan ke salah satu dari 1024!  varian (faktorial), dan sebagainya.  Untuk nomor yang ditandatangani, kami akan menyimpannya. <br><br>  Juga diragukan apakah kita membutuhkan fungsi satu-ke-satu.  Kita mungkin bisa menggunakan fungsi hash yang kuat secara kriptografis.  Transformasi tidak akan satu-ke-satu, tetapi kardinalitas akan mendekati sama. <br><br>  Namun, kita memang membutuhkan permutasi acak yang kuat secara kriptografis sehingga ketika kita mendefinisikan kunci dan memperoleh permutasi dengan kunci itu, akan sulit untuk mengembalikan data asli dari data yang disusun ulang tanpa mengetahui kunci. <br><br>  Ada satu masalah: selain tidak tahu apa-apa tentang jaringan saraf dan pembelajaran mesin, saya juga tidak tahu apa-apa tentang kriptografi.  Itu menyisakan keberanian saya.  Saya masih membaca halaman web acak, dan menemukan tautan di <a href="https://news.ycombinator.com/item%3Fid%3D15122540">Hackers News</a> untuk diskusi di halaman Fabien Sanglard.  Itu memiliki tautan ke <a href="http://antirez.com/news/113">posting blog</a> oleh pengembang Redis Salvatore Sanfilippo yang berbicara tentang menggunakan cara generik yang luar biasa untuk mendapatkan permutasi acak, yang dikenal sebagai <a href="https://en.wikipedia.org/wiki/Feistel_cipher">jaringan Feistel</a> . <br><br>  Jaringan Feistel bersifat iteratif, terdiri dari putaran.  Setiap putaran adalah transformasi luar biasa yang memungkinkan Anda untuk mendapatkan fungsi satu-ke-satu dari fungsi apa pun.  Mari kita lihat cara kerjanya. <br><br><ol><li>  Bit argumen dibagi menjadi dua bagian: <br> <code>arg: xxxxyyyy <br> <font color="#0fc000">arg_l</font> : xxxx <br> <font color="#0000ff">arg_r</font> : yyyy</code> </li> <li>  Setengah kanan menggantikan kiri.  Sebagai gantinya kami menempatkan hasil XOR pada nilai awal setengah kiri dan hasil fungsi yang diterapkan pada nilai awal setengah kanan, seperti ini: <br> <code>res: yyyyzzzz <br> <font color="#0000ff">res_l</font> = yyyy = <font color="#0000ff">arg_r</font> <br> <font color="#FF6600">res_r</font> = zzzz = <font color="#0fc000">arg_l</font> ^ F( <font color="#0000ff">arg_r</font> )</code> </li> </ol><br>  Ada juga klaim bahwa jika kita menggunakan fungsi pseudorandom kriptografi yang kuat untuk F dan menerapkan putaran Feistel setidaknya 4 kali, kita akan mendapatkan permutasi pseudorandom kuat secara kriptografis. <br><br>  Ini seperti keajaiban: kami mengambil fungsi yang menghasilkan sampah acak berdasarkan data, memasukkannya ke jaringan Feistel, dan kami sekarang memiliki fungsi yang menghasilkan sampah acak berdasarkan data, tetapi belum dapat dibalik! <br><br>  Jaringan Feistel adalah jantung dari beberapa algoritma enkripsi data.  Apa yang akan kita lakukan adalah enkripsi, hanya saja itu sangat buruk.  Ada dua alasan untuk ini: <br><br><ul><li>  Kami mengenkripsi nilai individual secara independen dan dengan cara yang sama, mirip dengan mode operasi Codebook Elektronik. </li><li>  Kami menyimpan informasi tentang urutan besarnya (kekuatan terdekat dua) dan tanda nilai, yang berarti bahwa beberapa nilai tidak berubah sama sekali. </li></ul><br>  Dengan cara ini kita dapat mengaburkan bidang angka sambil mempertahankan properti yang kita butuhkan.  Misalnya, setelah menggunakan LZ4, rasio kompresi harus tetap kira-kira sama, karena nilai duplikat dalam data sumber akan diulang dalam data yang dikonversi, dan pada jarak yang sama satu sama lain. <br><br><h2>  Model Markov </h2><br>  Model teks digunakan untuk kompresi data, input prediksi, pengenalan ucapan, dan pembuatan string acak.  Model teks adalah distribusi probabilitas dari semua string yang mungkin.  Katakanlah kita memiliki distribusi probabilitas khayalan dari semua buku yang bisa ditulis manusia.  Untuk menghasilkan string, kami hanya mengambil nilai acak dengan distribusi ini dan mengembalikan string yang dihasilkan (buku acak yang bisa ditulis manusia).  Tetapi bagaimana kita mengetahui distribusi probabilitas dari semua string yang mungkin? <br><br>  Pertama, ini membutuhkan terlalu banyak informasi.  Ada 256 ^ 10 string yang mungkin yang panjangnya 10 byte, dan akan membutuhkan cukup banyak memori untuk secara eksplisit menulis tabel dengan probabilitas setiap string.  Kedua, kami tidak memiliki statistik yang cukup untuk menilai distribusi secara akurat. <br><br>  Inilah sebabnya kami menggunakan distribusi probabilitas yang diperoleh dari statistik kasar sebagai model teks.  Sebagai contoh, kita bisa menghitung probabilitas setiap huruf yang terjadi dalam teks, dan kemudian menghasilkan string dengan memilih setiap huruf berikutnya dengan probabilitas yang sama.  Model primitif ini berfungsi, tetapi senarnya masih sangat tidak alami. <br><br>  Untuk sedikit memperbaiki model, kita juga dapat menggunakan probabilitas bersyarat dari kemunculan huruf jika didahului oleh huruf N tertentu.  N adalah konstanta yang ditentukan sebelumnya.  Katakanlah N = 5 dan kami menghitung probabilitas huruf "e" yang muncul setelah huruf "compr".  Model teks ini disebut model Orde-N Markov. <br><br> <code>P(cat <font color="#ff0000">a</font> | cat) = 0.8 <br> P(cat <font color="#ff0000">b</font> | cat) = 0.05 <br> P(cat <font color="#ff0000">c</font> | cat) = 0.1 <br> ...</code> <br> <br>  Mari kita lihat bagaimana model Markov bekerja di situs web <a href="https://projects.haykranen.nl/markov/demo/">Hay Kranen</a> .  Tidak seperti jaringan saraf LSTM, model hanya memiliki memori yang cukup untuk konteks kecil fixed-length N, sehingga mereka menghasilkan teks yang lucu dan tidak masuk akal.  Model Markov juga digunakan dalam metode primitif untuk menghasilkan spam, dan teks yang dihasilkan dapat dengan mudah dibedakan dari yang asli dengan menghitung statistik yang tidak sesuai dengan model.  Ada satu keuntungan: model Markov bekerja jauh lebih cepat daripada jaringan saraf, yang memang kita butuhkan. <br><br>  Contoh untuk Judul (contoh kami dalam bahasa Turki karena data yang digunakan): <br><br><blockquote>  Hyunday Butter'dan anket shluha - Politika head manÅŸetleri |  STALKER BOXER Ã‡iftede book - YanudistkarÄ±ÅŸmanlÄ± MÄ± Kanal |  League el Digitalika Haberler Haberleri - Haberlerisi - Hotel dengan Centry'ler Neden babah.com </blockquote><br>  Kami dapat menghitung statistik dari sumber data, membuat model Markov, dan menghasilkan data baru dengannya.  Perhatikan bahwa model ini perlu diperhalus untuk menghindari pengungkapan informasi tentang kombinasi langka dalam data sumber, tetapi ini bukan masalah.  Saya menggunakan kombinasi model dari 0 hingga N. Jika statistik tidak mencukupi untuk model pesanan N, model N - 1 digunakan sebagai gantinya. <br><br>  Tetapi kami masih ingin mempertahankan kardinalitas data.  Dengan kata lain, jika data sumber memiliki 123456 nilai URL unik, hasilnya akan memiliki jumlah nilai unik yang kira-kira sama.  Kita dapat menggunakan generator nomor acak yang diinisialisasi secara deterministik untuk mencapai hal ini.  Cara termudah untuk melakukan ini adalah dengan menggunakan fungsi hash dan menerapkannya ke nilai asli.  Dengan kata lain, kita mendapatkan hasil pseudorandom yang secara eksplisit ditentukan oleh nilai asli. <br><br>  Persyaratan lain adalah bahwa data sumber mungkin memiliki banyak URL berbeda yang dimulai dengan awalan yang sama tetapi tidak identik.  Misalnya: <code>https://www.yandex.ru/images/cats/?id=xxxxxx</code> .  Kami ingin hasilnya juga memiliki URL yang semuanya dimulai dengan awalan yang sama, tetapi berbeda.  Misalnya: <code>http://ftp.google.kz/cgi-bin/index.phtml?item=xxxxxx</code> .  Sebagai generator angka acak untuk menghasilkan karakter berikutnya menggunakan model Markov, kami akan mengambil fungsi hash dari jendela bergerak 8 byte pada posisi yang ditentukan (alih-alih mengambilnya dari seluruh string). <br><br> <code>https://www.yandex.ru/ <font color="#0fc000">images/c</font> ats/?id=12345 <br> ^^^^^^^^ <br> <br> distribution: [aaaa][b][cc][dddd][e][ff][g <font color="#ff0000">g</font> ggg][h]... <br> hash(" <font color="#0fc000">images/c</font> ") % total_count:           ^ <br> <br></code> <code>http://ftp.google.kz/c <font color="#ff0000">g</font> ...</code> <br> <br>  Ternyata persis seperti yang kita butuhkan.  Inilah contoh judul halaman: <br><br><blockquote><pre>  PhotoFunia - Haber7 - Hava mÃ¼kemment.net Oynamak iÃ§inde ÅŸaÅŸÄ±racak haber, Oyunu OynanÄ±lmaz â€¢ aprÃ³d.hu kÃ­nÃ¡latÃ¡ban - RT Bahasa Arab
 PhotoFunia - Kinobar.Net - aprÃ³d: Ingyenes |  Posti
 PhotoFunia - Peg Perfeo - Castika, SÄ±radÄ±ÅŸÄ± Deniz Lokoning Your Code, Sire Eminema.tv/
 PhotoFunia - TUT.BY - Anak Anda AyakkanÄ±n Son Dakika Spor,
 PhotoFunia - film besar, Del Meireles offilim, Samsung DealeXtreme DeÄŸerler NEWSru.com.tv, Smotri.com Mobile yapmak Okey
 PhotoFunia 5 |  Galaksi, gt, duplikat anal bilgi yarak Ceza RE050A V-StranÃ§
 PhotoFunia :: Miami olacaksÄ±nÄ± yerel Haberler Oyun Young video
 PhotoFunia Monstelli'nin En Ä°yi kisa.com.tr â€“Star Thunder EkranÄ±
 PhotoFunia Seks - Politika, Ekonomi, Spor GTA SANAYÄ° VE
 PhotoFunia Taker-Rating Bintang TV Resmi SÃ¶ylenen YataÄŸa kaÅ¼dy dzieÅ¼ wierzchnie
 PhotoFunia TourIndex.Marketime Oyunu Oyna GeldollarÄ± Mynet Spor, Magazin, Haberler dan Habereri, Solvia, korkusuz Ev SahneTv
 PhotoFunia todo di Gratis Perky Parti'nin yapÄ±yÄ± bu fotogram
 PhotoFunian DÃ¼nyasÄ±n takÄ±mÄ±z halles en kullarÄ± - TEZ
</pre></blockquote><br><h2>  Hasil </h2><br>  Setelah mencoba empat metode, saya bosan dengan masalah ini sehingga tiba saatnya untuk memilih sesuatu, menjadikannya alat yang dapat digunakan, dan mengumumkan solusinya.  Saya memilih solusi yang menggunakan permutasi acak dan model Markov parametrized oleh kunci.  Ini diimplementasikan sebagai program <b>clickhouse-obfuscator</b> , yang sangat mudah digunakan.  Input adalah dump tabel dalam <a href="https://clickhouse.yandex/docs/en/interfaces/formats/">format yang didukung</a> (seperti CSV atau JSONEachRow), dan parameter baris perintah menentukan struktur tabel (nama dan tipe kolom) dan kunci rahasia (string apa pun, yang dapat Anda lupakan segera setelah digunakan).  Outputnya adalah jumlah baris yang sama dari data yang dikaburkan. <br><br>  Program ini diinstal dengan clickhouse-client, tidak memiliki dependensi, dan bekerja pada hampir semua rasa Linux.  Anda bisa menerapkannya pada sembarang database dump, bukan hanya ClickHouse.  Misalnya, Anda dapat menghasilkan data uji dari database MySQL atau PostgreSQL atau membuat database pengembangan yang mirip dengan database produksi Anda. <br><br> <code>clickhouse-obfuscator \ <br> --seed "$(head -c16 /dev/urandom | base64)" \ <br> --input-format TSV --output-format TSV \ <br> --structure 'CounterID UInt32, URLDomain String, \ <br> URL String, SearchPhrase String, Title String' \ <br> &lt; table.tsv &gt; result.tsv <br> <br> clickhouse-obfuscator --help <br></code> <br>  Tentu saja, semuanya tidak begitu dipotong dan dikeringkan, karena data yang diubah oleh program ini hampir sepenuhnya reversibel.  Pertanyaannya adalah apakah mungkin untuk melakukan transformasi terbalik tanpa mengetahui kuncinya.  Jika transformasi menggunakan algoritma kriptografi, operasi ini akan sesulit pencarian kasar.  Meskipun transformasi menggunakan beberapa primitif kriptografi, mereka tidak digunakan dengan cara yang benar, dan data rentan terhadap metode analisis tertentu.  Untuk menghindari masalah, masalah ini dicakup dalam dokumentasi untuk program (akses menggunakan <code>--help</code> ). <br><br>  Pada akhirnya, kami mengubah set data yang kami butuhkan <a href="https://clickhouse.yandex/docs/en/getting_started/example_datasets/metrica/">untuk pengujian fungsional dan kinerja</a> serta Yandex VP publikasi keamanan data yang disetujui. <br><br>  <a href="">clickhouse-datasets.s3.yandex.net/hits/tsv/hits_v1.tsv.xz</a> <br>  <a href="">clickhouse-datasets.s3.yandex.net/visits/tsv/visits_v1.tsv.xz</a> <br><br>  Pengembang non-Yandex menggunakan data ini untuk pengujian kinerja nyata ketika mengoptimalkan algoritma di dalam ClickHouse.  Pengguna pihak ketiga dapat memberi kami data yang dikaburkan sehingga kami dapat membuat ClickHouse lebih cepat bagi mereka.  Kami juga merilis patokan terbuka independen untuk penyedia perangkat keras dan cloud di atas data ini: <a href="https://clickhouse.yandex/benchmark_hardware.html">clickhouse.yandex/benchmark_hardware.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485096/">https://habr.com/ru/post/id485096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485084/index.html">Office Plankton - Evolusi</a></li>
<li><a href="../id485088/index.html">Menyapu retrospektif. Bagaimana solusi buatan sendiri ternyata lebih keren dari pada yang dibayarkan</a></li>
<li><a href="../id485090/index.html">Rahasia efisiensi adalah kode kualitas, bukan manajer yang efektif</a></li>
<li><a href="../id485092/index.html">Validasi data dalam aplikasi iOS</a></li>
<li><a href="../id485094/index.html">Layanan microser dengan Spring Boot. Bagian 3. Membuat microservice konversi mata uang</a></li>
<li><a href="../id485098/index.html">Bisakah desain memengaruhi kecepatan pengiriman?</a></li>
<li><a href="../id485100/index.html">Ke mana harus pergi: acara gratis berikutnya untuk pengembang di Moskow (30 Januari - 15 Februari)</a></li>
<li><a href="../id485102/index.html">Topleaked: alat untuk menangkap kebocoran memori</a></li>
<li><a href="../id485104/index.html">Membuat kunci RFID universal untuk interkom</a></li>
<li><a href="../id485108/index.html">Statistik spesialis PMI bersertifikat di Rusia pada 01/10/2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>