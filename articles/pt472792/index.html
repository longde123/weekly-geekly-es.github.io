<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∏ ‚òéÔ∏è üåâ Computador baseado em v√°lvulas NOR: dentro do computador de controle de bordo Apollo ü§∏üèø üññüèº üë≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, est√°vamos envolvidos na restaura√ß√£o do computador de controle de bordo Apollo, um computador respons√°vel por controlar, navegar e monito...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Computador baseado em v√°lvulas NOR: dentro do computador de controle de bordo Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recentemente, est√°vamos envolvidos na restaura√ß√£o do</a> computador de controle de bordo Apollo, um computador respons√°vel por controlar, navegar e monitorar as miss√µes Apollo que voavam para a Lua.  Este computador hist√≥rico foi um dos primeiros a usar circuitos integrados (ICs) e seu processador foi completamente constru√≠do em v√°lvulas NOR (o segundo tipo de CIs, um amplificador de leitura, foi usado na mem√≥ria do computador).  Neste artigo, descreverei a arquitetura e o design da CPU. <br><br><h2>  Arquitetura de computador Apollo Control </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Bandejas separadas do computador de controle Apollo.</i>  <i>A bandeja esquerda cont√©m l√≥gica baseada em portas NOR.</i>  <i>Na direita - mem√≥ria e componentes auxiliares.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O</a> Computador de Orienta√ß√£o Apollo (AGC) foi desenvolvido na d√©cada de 1960 para permitir que as miss√µes da Apollo voassem para a lua.  No momento em que a maioria dos computadores ocupava espa√ßo de uma geladeira de tamanho normal para uma sala inteira, o AGC era algo √∫nico - era pequeno o suficiente para caber a bordo da espa√ßonave Apollo, pesava 32 kg e n√£o levava mais que 0,03 m <sup>3</sup> (30 litros). <br><a name="habracut"></a><br>  O computador AGC √© de 15 bits.  √â estranho encontrar um tamanho de palavra que n√£o seja uma pot√™ncia de dois, mas na d√©cada de 1960, mesmo antes de os bytes se tornarem populares, os computadores usavam uma variedade de tamanhos de palavra.  15 bits forneciam precis√£o suficiente para pousar na lua (e usavam dados com precis√£o dupla e tripla, se necess√°rio); portanto, 16 bits simplesmente aumentariam o tamanho e o peso do computador desnecessariamente. <br><br>  A instru√ß√£o AGC estava localizada em uma palavra de 15 bits e consistia em 3 bits, indicando o c√≥digo de opera√ß√£o, e 12 bits, indicando o endere√ßo na mem√≥ria.  Infelizmente, esses volumes ainda n√£o eram suficientes; portanto, o computador usou v√°rios truques e solu√ß√µes alternativas, e a arquitetura acabou sendo um pouco estranha.  Um endere√ßo de mem√≥ria de 12 bits s√≥ pode acessar palavras em 4K.  Ao mesmo tempo, o AGC tinha 2K palavras na RAM principal e 36K na mem√≥ria principal.  Para acessar toda a mem√≥ria, a AGC usou um sofisticado sistema de comuta√ß√£o de banco de mem√≥ria e v√°rios registros.  Em outras palavras, a mem√≥ria pode ser acessada apenas em peda√ßos de 256 palavras e ROM - em peda√ßos de tamanho um pouco maior. <br><br>  3 bits para o c√≥digo de opera√ß√£o n√£o foram suficientes para indicar diretamente 34 instru√ß√µes poss√≠veis; portanto, o AGC usou truques com a extens√£o do valor das instru√ß√µes e com o fato de que algumas instru√ß√µes faziam sentido para serem executadas apenas com determinadas c√©lulas de mem√≥ria.  Al√©m disso, truques como endere√ßos ‚Äúm√°gicos‚Äù na mem√≥ria foram usados ‚Äã‚Äã- por exemplo, a grava√ß√£o na c√©lula ‚Äúshift right register‚Äù executou uma mudan√ßa bit a bit, eliminando assim a necessidade de uma instru√ß√£o ‚Äúshift direita‚Äù separada.  Havia tamb√©m instru√ß√µes combinando v√°rias a√ß√µes ao mesmo tempo. <br><br>  A arquitetura AGC era bastante simples, mesmo para os padr√µes da d√©cada de 1960.  Embora tenha sido criado em uma era de mainframes complexos e poderosos, as capacidades da AGC eram muito limitadas;  em termos de pot√™ncia e arquitetura, √© compar√°vel aos primeiros microprocessadores.  Seus pontos fortes foram o tamanho compacto e os excelentes recursos para fornecer entrada e sa√≠da de dados em tempo real. <br><br>  O diagrama arquitetural abaixo mostra os principais componentes do AGC.  Destaquei em cores as partes em que me refiro com mais detalhes.  O AGC possu√≠a um pequeno conjunto de registros e um m√≥dulo aritm√©tico simples que tratava apenas da adi√ß√£o.  Ele tinha apenas 36K palavras ROM e 2K palavras RAM.  O "barramento de grava√ß√£o" era a principal maneira de transferir dados entre componentes.  As instru√ß√µes de decodifica√ß√£o e um gerador de sequ√™ncia geraram pulsos de controle para o AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>Diagrama de blocos AGC</i> <br><br>  Cerca de metade do diagrama √© ocupado por mem√≥ria, o que reflete o fato de que em muitos aspectos a arquitetura AGC foi desenvolvida em torno de sua mem√≥ria.  Como a maioria dos computadores da d√©cada de 1960, a AGC usava mem√≥ria central, armazenando cada bit em um min√∫sculo anel de ferrite (n√∫cleo) preso a uma malha de arame.  Como cada bit exigia um n√∫cleo f√≠sico separado, a quantidade dessa mem√≥ria era radicalmente menor que a de um semicondutor moderno.  Uma caracter√≠stica distintiva da mem√≥ria nos n√∫cleos era que a leitura de uma palavra da mem√≥ria a exclu√≠a; portanto, ap√≥s cada acesso, esse valor precisava ser reescrito.  O AGC tamb√©m tinha mem√≥ria ROM fixa, os famosos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫cleos costurados</a> - eles eram usados ‚Äã‚Äãpara armazenar programas e eram costurados fisicamente com fios (veja abaixo). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Mem√≥ria de close-up em n√∫cleos costurados</i> <br><br><h2>  V√°lvulas NOR </h2><br>  O AGC foi um dos primeiros computadores a usar IP.  As possibilidades desses primeiros IPs eram muito limitadas;  nos chips AGC (abaixo), havia apenas seis transistores e oito resistores, e juntos eles implementaram uma porta NOR com tr√™s entradas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>V√°lvula NOR dupla com tr√™s entradas da AGC.</i>  <i>Dez fios fora do cristal est√£o conectados aos contatos externos do IC.</i> <br><br>  A designa√ß√£o esquem√°tica da v√°lvula NOR √© mostrada abaixo.  Esta √© a porta l√≥gica mais simples: se todas as entradas forem iguais a zero, a sa√≠da ser√° igual a uma.  Voc√™ pode se surpreender, mas um port√£o NOR √© suficiente para criar um computador.  A NOR √© uma v√°lvula universal: qualquer outra v√°lvula l√≥gica pode ser fabricada com base.  Por exemplo, ao combinar todas as entradas NOR, obtemos um inversor.  Depois de colocar o inversor na sa√≠da da NOR, obtemos uma v√°lvula OR.  Ao colocar os inversores nas entradas da porta NOR, obtemos uma porta AND.  E a partir desses port√µes voc√™ pode construir uma l√≥gica mais complexa: gatilhos, somadores e contadores. <br><br>  A v√°lvula NAND tem a mesma versatilidade.  Nos circuitos modernos, por raz√µes t√©cnicas, as NANDs s√£o usadas com mais frequ√™ncia do que as NORs.  No curso popular " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">From NAND to Tetris</a> " descreve como criar um computador a partir de v√°lvulas NAND, at√© a implementa√ß√£o do jogo "Tetris".  Primeiro, um conjunto de portas l√≥gicas √© constru√≠do a partir de NAND (NOT, AND, OR, XOR, multiplexador, desmultiplexador).  Ent√£o, blocos de constru√ß√£o maiores s√£o criados a partir deles (gatilho, somador, contador, ALU, registro) e a partir deles - um computador. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>A porta NOR fornece 1 se todas as entradas tiverem 0. Se pelo menos uma das entradas tiver 1, a NOR fornecer√° 0.</i> <br><br>  Muitas vezes, no AGC, encontra-se um componente como o acionador RS (set-reset, set / reset).  Este circuito √© composto de duas portas NOR e armazena um bit de dados.  O bit 1 √© armazenado na entrada configurada e o bit 0 √© armazenado na entrada de redefini√ß√£o, ou seja, o pulso 1, aplicado √† entrada de ajuste, desliga a v√°lvula superior e liga a mais baixa, de modo que a sa√≠da 1 √© acionada. .  Se 0 for aplicado √†s duas entradas, o gatilho lembrar√° seu estado anterior, desempenhando o papel de uma unidade.  Na pr√≥xima se√ß√£o, mostraremos como os registros s√£o feitos a partir de um gatilho. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>Gatilho RS de dois port√µes NOR.</i>  <i>Uma v√°lvula, quando ligada, desliga a outra.</i>  <i>Uma linha acima de uma das sa√≠das indica que complementa a outra.</i> <br><br><h2>  Registros </h2><br>  O AGC possui um pequeno conjunto de registros para armazenamento tempor√°rio de valores fora da mem√≥ria principal.  O registro principal √© o inversor (A) usado em muitas opera√ß√µes aritm√©ticas.  Ele tamb√©m possui um contador registrador Z, bloco aritm√©tico registra X e Y, buffer B, endere√ßo de retorno Q e alguns outros (em computadores modernos, a pilha √© usada para chamar rotinas e retornar a partir delas, mas nessa √©poca, os programadores precisavam escrever a pilha para recurs√£o. )  Para acessar a mem√≥ria, h√° um registro de endere√ßo de mem√≥ria S e, para dados, um registro de buffer de mem√≥ria G. Al√©m disso, o AGC possui registros na mem√≥ria principal - por exemplo, contadores de entrada / sa√≠da. <br><br>  O diagrama abaixo mostra o esquema de registro AGC, simplificado para o caso com um bit e dois registros.  Cada bit de registro possui um gatilho usando o esquema descrito anteriormente (azul e roxo).  Os dados s√£o transferidos de e para os registradores atrav√©s do barramento de grava√ß√£o (vermelho).  Para gravar no registro, o gatilho √© redefinido por um sinal claro (CQG ou CZG, verde).  Em seguida, o sinal de "grava√ß√£o" (WQG ou WZG, laranja) permite que os dados que percorrem o barramento de grava√ß√£o definam o gatilho de registro correspondente.  Para ler o registro, o sinal de leitura (RQG ou RZG, ciano) passa a sa√≠da do gatilho pelo amplificador de grava√ß√£o para o barramento de grava√ß√£o e √© usado em outras partes do AGC.  O esquema de registro completo √© mais complexo, possui v√°rios registros de 16 bits, mas o esquema b√°sico √© o seguinte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Opera√ß√£o simplificada de registro AGC</i> <br><br>  O gr√°fico de registro ilustra tr√™s pontos principais.  Em primeiro lugar, o circuito de registro √© constru√≠do a partir de portas NOR.  Em segundo lugar, a movimenta√ß√£o de dados √© constru√≠da em torno do barramento de grava√ß√£o.  Finalmente, as a√ß√µes dos registradores dependem de certos sinais de controle que chegam no momento certo. <br><br><h2>  M√≥dulo aritm√©tico </h2><br>  A maioria dos computadores possui um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dispositivo l√≥gico aritm√©tico</a> que executa opera√ß√µes aritm√©ticas e booleanas.  Em compara√ß√£o com os computadores modernos, o m√≥dulo aritm√©tico do AGC √© muito limitado: ele apenas realiza a adi√ß√£o de quantidades de 16 bits; portanto, √© chamado m√≥dulo aritm√©tico e n√£o o m√≥dulo aritm√©tico-l√≥gico (o restante das opera√ß√µes √© realizado por meio de v√°rios truques; por exemplo, a subtra√ß√£o √© realizada por adi√ß√£o, antes da qual para um dos argumentos, os bits s√£o invertidos etc.). <br><br>  O diagrama abaixo mostra um bit do m√≥dulo aritm√©tico do AGC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O somador completo</a> (vermelho) calcula a soma de dois bits e carrega.  A transfer√™ncia √© transferida para o pr√≥ximo adicionador - dessa forma, eles podem ser combinados para adicionar palavras mais longas (para acelerar a transfer√™ncia de transfer√™ncias em casos como 111111111111111 + 1, o AGC usa um adicionador com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">salto de transfer√™ncia</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Os registros X e Y (roxo e verde) fornecem dois bits de entrada para o somador.  Eles s√£o implementados usando os gatilhos j√° descritos nas v√°lvulas NOR.  O loop azul grava os valores nos registradores X e Y de acordo com os sinais de controle.  O esquema √© bastante complicado, porque permite armazenar constantes e valores com uma altera√ß√£o nos registros, mas n√£o vou entrar neste t√≥pico.  Preste aten√ß√£o ao sinal de controle A2X, que transfere o valor do registro A para o registro X;  voltaremos a ele mais tarde. <br><br>  A foto abaixo mostra a implementa√ß√£o f√≠sica do circuito AGC.  Este m√≥dulo implementa quatro bits para registros e um m√≥dulo aritm√©tico.  Ret√¢ngulos pretos s√£o IPs planos;  cada m√≥dulo possui duas placas com 60 chips cada e um total de 240 portas NOR.  O m√≥dulo aritm√©tico e os registros s√£o montados a partir de quatro m√≥dulos id√™nticos, cada um dos quais processa quatro bits;  isso √© semelhante √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se√ß√£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">microprocessador</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>O m√≥dulo aritm√©tico e os registros s√£o montados a partir de quatro m√≥dulos id√™nticos.</i>  <i>Os m√≥dulos s√£o instalados nos slots de A8 a A11.</i> <br><br><h2>  Execu√ß√£o de instru√ß√µes </h2><br>  Esta se√ß√£o descreve a sequ√™ncia de opera√ß√µes que o AGC executa para executar a instru√ß√£o.  Em particular, mostrarei como a instru√ß√£o ADS (adicionar ao armazenamento) funciona.  Esta instru√ß√£o l√™ o valor da mem√≥ria, o adiciona √† unidade (registro A) e salva a soma no somador e na mem√≥ria.  Esta √© uma instru√ß√£o √∫nica, mas, para sua execu√ß√£o, o AGC executa v√°rias etapas e muitos valores s√£o movidos para c√° e para l√°. <br><br>  O cron√¥metro de instru√ß√µes √© implementado devido ao subsistema de mem√≥ria nos n√∫cleos magn√©ticos.  Em particular, a leitura de um valor da mem√≥ria apaga o valor armazenado; portanto, ap√≥s cada leitura, o valor deve ser gravado novamente.  Al√©m disso, ao acessar a mem√≥ria, h√° um atraso entre a designa√ß√£o do endere√ßo e o recebimento de dados.  Como resultado, cada ciclo do rel√≥gio passa 12 etapas para leitura e grava√ß√£o subseq√ºente.  Cada intervalo de tempo (de T1 a T12) dura um pouco menos de microssegundos e todo o ciclo dura 11,7 Œºs e √© chamado de tempo de ciclo de mem√≥ria (MCT). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>M√≥dulo de mem√≥ria de n√∫cleo magn√©tico apag√°vel da AGC.</i>  <i>Ele armazena 2 folhas de quilos, cada bit √© armazenado usando um pequeno anel de ferrita separado.</i> <br><br>  MCT √© a unidade b√°sica de mem√≥ria para executar instru√ß√µes.  Uma instru√ß√£o t√≠pica requer dois ciclos de rel√≥gio: um para extrair a instru√ß√£o da mem√≥ria e o segundo para executar a opera√ß√£o.  Portanto, uma instru√ß√£o t√≠pica utiliza dois MCTs (23,4 Œºs), o que fornece 43.000 instru√ß√µes por segundo (comparado aos processadores modernos e seus bilh√µes de instru√ß√µes por segundo, isso √© extremamente lento). <br><br>  O AGC processa instru√ß√µes, dividindo-as em subcomandos, cada um dos quais requer um ciclo de clock de mem√≥ria.  Por exemplo, uma instru√ß√£o ADS consiste em dois subcomandos: ADS0 (adi√ß√£o) e STD2 (chamando a pr√≥xima instru√ß√£o).  O diagrama abaixo mostra o movimento dos dados dentro do AGC para executar a instru√ß√£o ADS0.  12 medidas v√£o da esquerda para a direita. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Os passos mais importantes s√£o os seguintes: <br>  T1: o endere√ßo do operando √© copiado do registro de instru√ß√µes B para o registro de endere√ßos de mem√≥ria S para iniciar a leitura da mem√≥ria. <br>  T4: O operando √© lido da mem√≥ria no registro de dados da mem√≥ria G. <br>  T5: O operando √© copiado de G para o somador Y. O valor da unidade A √© copiado para o somador X. <br>  T6: O somador calcula a soma U e a copia para o registro de dados da mem√≥ria G. <br>  T8: O contador de programa Z √© copiado para o registrador de endere√ßo de mem√≥ria S, em prepara√ß√£o para receber a pr√≥xima instru√ß√£o da mem√≥ria. <br>  T10: A soma do registro de dados da mem√≥ria G √© gravada de volta na mem√≥ria. <br>  T11: O valor U √© copiado para a unidade A. <br><br>  Embora esta seja uma instru√ß√£o simples de soma, muitos dados s√£o transmitidos repetidamente aqui em 12 intervalos de tempo.  E com cada uma dessas a√ß√µes um sinal de controle espec√≠fico √© associado;  por exemplo, o sinal A2X no intervalo T5 copia o valor do inversor A para registrar X. Para copiar o registro G para registrar Y, s√£o necess√°rios dois pulsos de controle: RG (leia G) e WY (escreva Y).  Na pr√≥xima se√ß√£o, explicarei como o m√≥dulo de controle AGC gera os sinais de controle necess√°rios para cada instru√ß√£o. <br><br><h2>  M√≥dulo de controle </h2><br>  Como a maioria dos computadores, o m√≥dulo de controle AGC decodifica cada instru√ß√£o e gera sinais de controle que informam ao restante do processador o que ele precisa fazer.  O AGC usa um m√≥dulo de controle pr√©-programado que consiste em v√°lvulas NOR para gerar sinais.  O AGC n√£o usa microc√≥digo;  ele n√£o possui microinstru√ß√µes e controle a mem√≥ria, pois isso ocuparia muito espa√ßo f√≠sico. <br><br>  O cora√ß√£o do m√≥dulo de controle AGC √© chamado de gerador de ponto cruzado.  Leva um subcomando e um dos per√≠odos de tempo e gera sinais de controle para essa combina√ß√£o.  Pode ser imaginada na forma de uma rede, na qual os subcomandos v√£o em uma dire√ß√£o e os segmentos de tempo na outra, e cada um dos pontos de interse√ß√£o possui seu pr√≥prio sinal de controle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>O gerador de interse√ß√£o requer muitos componentes e √© dividido em tr√™s m√≥dulos;</i>  <i>Este √© o m√≥dulo A6.</i>  <i>Preste aten√ß√£o aos fios adicionados que alteram o circuito.</i>  <i>Esta √© uma vers√£o inicial de um m√≥dulo para testes no terreno;</i>  <i>m√≥dulos de v√¥o j√° n√£o tinham fios.</i> <br><br>  Para efici√™ncia, o m√≥dulo de controle final √© altamente otimizado.  Instru√ß√µes com comportamento semelhante s√£o combinadas e processadas pelo gerador de interse√ß√£o, o que reduz o tamanho do circuito necess√°rio.  Por exemplo, o AGC possui uma instru√ß√£o "adicionar a uma unidade com precis√£o dupla" (DAS).  Como √© aproximadamente equivalente a duas adi√ß√µes de palavras √∫nicas, os subcomandos DAS1 e ADS0 no gerador de interse√ß√£o t√™m l√≥gica comum.  O diagrama abaixo mostra o circuito gerador de interse√ß√£o para o intervalo de tempo T5, e a l√≥gica do subcomando ADS0 (usando o sinal DAS1) √© destacada.  Por exemplo, um sinal 5K √© gerado a partir de uma combina√ß√£o de DAS1 e T5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Mas o que s√£o sinais 5K e 5L?  Essa √© outra otimiza√ß√£o.  Muitos pulsos de controle geralmente s√£o alimentados juntos; portanto, em vez de ger√°-los diretamente, o gerador de interse√ß√£o gera sinais intermedi√°rios para interse√ß√µes.  Por exemplo, 5K gera pulsos de controle A2X e RG e 5L gera pulsos de controle WY.  O diagrama abaixo mostra como o sinal A2X √© gerado: qualquer um dos 8 sinais diferentes (incluindo 5K) gera A2X.  Circuitos semelhantes geram outros sinais de controle.  Essas otimiza√ß√µes tornaram poss√≠vel reduzir o tamanho do gerador de interse√ß√£o, mas ele ainda permaneceu grande e cresceu para tr√™s m√≥dulos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  Resumindo, podemos dizer que o m√≥dulo de controle √© respons√°vel por dizer √† CPU o que fazer para executar a instru√ß√£o.  Primeiro, as instru√ß√µes s√£o divididas em subcomandos.  O gerador de interse√ß√£o gera os pulsos de controle necess√°rios para cada intervalo de tempo e subcomando, informando aos registradores, m√≥dulo aritm√©tico e mem√≥ria o que eles precisam fazer. <br><br>  Normalmente, as instru√ß√µes consistiam em dois subcomandos, mas havia exce√ß√µes.  Algumas instru√ß√µes, como multiplica√ß√£o ou divis√£o, exigiram o uso de muitos subcomandos, pois consistiam em v√°rias etapas.  Por outro lado, a instru√ß√£o de salto no TC usava um subcomando, pois s√≥ precisava chamar a pr√≥xima instru√ß√£o. <br><br>  Outros processadores usaram abordagens diferentes para a gera√ß√£o de sinais de controle.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O 6502 e muitos outros microprocessadores iniciais decodificaram as instru√ß√µes usando um PLA (array l√≥gico program√°vel) que implementa a l√≥gica AND / OR atrav√©s da mem√≥ria somente leitura. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microprocessador 6502.</font></font></i> <br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi um passeio emocionante pelo computador de controle a bordo da Apollo. Para n√£o esticar muito, concentrei-me nas instru√ß√µes de adi√ß√£o do ADS e em alguns pulsos de controle (A2X, RG e WY). Espero que voc√™ tenha uma id√©ia de como montar um computador a partir de elementos primitivos como as v√°lvulas NOR. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A parte mais vis√≠vel da arquitetura √© o caminho dos dados: um m√≥dulo aritm√©tico, registradores e um barramento de dados. Os registros AGC s√£o baseados em gatilhos simples de portas NOR. E embora o m√≥dulo aritm√©tico do AGC possa fazer apenas a adi√ß√£o, o computador ainda pode lidar com todo o conjunto de opera√ß√µes, incluindo opera√ß√µes de multiplica√ß√£o, divis√£o e booleanas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, o caminho dos dados √© apenas parte do computador. </font><font style="vertical-align: inherit;">Entre outros componentes cr√≠ticos, h√° um m√≥dulo de controle que informa aos componentes o que eles precisam fazer. </font><font style="vertical-align: inherit;">A abordagem usada no AGC √© baseada em um gerador de interse√ß√£o que usa l√≥gica altamente otimizada e codificada para gerar os pulsos de controle corretos para subcomandos espec√≠ficos e intervalos de tempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esses recursos, o AGC forneceu orienta√ß√£o, navega√ß√£o e controle a bordo das miss√µes Apollo e tornou poss√≠vel pousar na lua. </font><font style="vertical-align: inherit;">Ele tamb√©m estimulou a ind√∫stria de circuitos integrados inicial, usando 60% dos CIs fabricados nos EUA em 1963. Portanto, os computadores modernos devem muito ao AGC e seus componentes simples da NOR. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O AGC trabalha em um laborat√≥rio conectado a um oscilosc√≥pio Tektronix vintage</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472792/">https://habr.com/ru/post/pt472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472776/index.html">Backup Parte 7: Conclus√µes</a></li>
<li><a href="../pt472778/index.html">5 maneiras de usar o Raspberry Pi</a></li>
<li><a href="../pt472780/index.html">Por que evitar amigos ou como eu perdi todas as minhas vantagens</a></li>
<li><a href="../pt472782/index.html">Por que dor de cabe√ßa 3D / Parte 8 Desfoque e o futuro do 3D</a></li>
<li><a href="../pt472790/index.html">Antiguidades: i-Mate Jasjar, um comunicador para neg√≥cios</a></li>
<li><a href="../pt472796/index.html">YES recua FAANG * ou [guia pr√°tico] em busca de emprego nos EUA / Europa para especialista em TI</a></li>
<li><a href="../pt472798/index.html">Mapas Yandex para aplica√ß√£o de t√°xi</a></li>
<li><a href="../pt472802/index.html">O MIRO √© uma plataforma de rob√¥ indoor aberta. Parte 2 - Design de Rob√¥</a></li>
<li><a href="../pt472810/index.html">Para o administrador do sistema iniciante: como fazer o pedido sair do caos</a></li>
<li><a href="../pt472812/index.html">O servidor "extingue" se o teste de fuma√ßa do data center "pegar fogo"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>