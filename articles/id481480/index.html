<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€ğŸ“ ğŸ‘©ğŸ½â€ğŸ¨ ğŸ˜‘ Ini adalah norma: apa itu peta normal dan bagaimana cara kerjanya ğŸ“² ğŸ‘°ğŸ» ğŸ¤›ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama beberapa tahun, saya mencoba memahami peta normal dan masalah yang biasanya muncul ketika bekerja dengannya. 

 Sebagian besar penjelasan yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ini adalah norma: apa itu peta normal dan bagaimana cara kerjanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481480/">  Selama beberapa tahun, saya mencoba memahami peta normal dan masalah yang biasanya muncul ketika bekerja dengannya. <br><br>  Sebagian besar penjelasan yang saya temukan terlalu teknis, tidak lengkap, atau terlalu rumit untuk saya pahami, jadi saya memutuskan untuk mencoba menjelaskan informasi yang saya kumpulkan.  Saya mengerti bahwa penjelasan ini mungkin tidak lengkap atau tidak sepenuhnya akurat, tetapi saya akan tetap mencoba. <br><br>  Model 3D buatan manusia pertama terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/aa7/cfb/deeaa7cfbf5b448d8db6a06b719c1ece.jpg" alt="gambar"></div><br>  Ini bagus, tetapi model seperti itu memiliki batasan yang jelas: terlihat terlalu poligonal. <br><br>  Solusi yang paling jelas: tambahkan lebih banyak poligon, buat permukaan lebih seragam dan halus, hingga poligon muncul sebagai satu permukaan halus.  Tetapi ternyata untuk membuat permukaan seperti bola halus, Anda membutuhkan sejumlah besar poligon (terutama hari ini). <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/78a/f86/60a78af862d484ce11d083a1f201adb7.jpg" alt="gambar"></div><br>  Diperlukan solusi yang berbeda, sehingga normals diciptakan.  (Itu tidak terjadi seperti itu, tetapi lebih mudah untuk dijelaskan dan dipahami.) <br><br>  Mari ikuti garis dari pusat poligon tegak lurus ke permukaannya.  Kami akan memberikan baris ini nama yang sangat tidak biasa: normal.  Tujuan dari normal adalah untuk mengontrol di mana titik-titik permukaan, sehingga ketika cahaya memantul dari permukaan ini, ia dapat menggunakan normal untuk menghitung refleksi yang dihasilkan.  Ketika cahaya mengenai poligon, kita membandingkan sudut sinar cahaya dengan normal poligon.  Balok dipantulkan pada sudut yang sama relatif terhadap arah normal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/b24/bb5/842b24bb518ce0e63a7694cbd0d752e2.jpg" alt="gambar"></div><br>  Dengan kata lain, pantulan cahaya akan simetris sehubungan dengan normal poligon.  Begitulah cara kerja sebagian besar refleksi di dunia nyata.  Secara default, sinar cahaya dipantulkan dari semua poligon yang sepenuhnya tegak lurus ke permukaannya (sebagaimana seharusnya dalam kehidupan nyata), karena normalnya poligon tegak lurus terhadap permukaan poligon secara default.  Jika ada celah pada normalnya, maka kita akan melihatnya sebagai permukaan yang terpisah, karena cahayanya akan dipantulkan dalam satu atau arah lainnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/138/c84/ff7138c843c2d67bfcfc8c061cb1953a.jpg" alt="gambar"></div><br>  Jika kedua wajah terhubung, maka kita dapat meminta komputer untuk memperlancar transisi antara normal satu poligon ke yang lain, sehingga normals secara bertahap disejajarkan sesuai dengan normal terdekat dari poligon.  Jadi, ketika cahaya mengenai pusat satu poligon, cahaya akan dipantulkan langsung, sesuai dengan arah normal.  Tetapi di antara poligon, arah normal ini dihaluskan, mengubah pantulan cahaya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/607/b7e/dc4/607b7edc436e1e47b80ccb2599fdbe22.jpg" alt="gambar"></div><br>  Kami akan menganggap transisi sebagai satu permukaan tunggal, karena cahaya akan dipantulkan antara satu dan yang lain poligon dengan cara yang halus, dan tidak akan ada celah di antara mereka.  Faktanya, cahaya memantulkan poligon ini dengan lancar, seolah-olah kita memiliki banyak poligon. <br><br>  Inilah yang kami kontrol dengan mengatur kelompok penghalus (Max 3ds, Blender) atau menentukan tepi sebagai keras atau halus (Modo, Maya): kami memberi tahu program mana transisi antara wajah yang harus mulus dan yang harus keras. <br><br>  Berikut ini adalah perbandingan satu bidang 288 poligon dengan transisi keras dan halus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c20/5b2/5ef/c205b25ef1eb8886ee3e2fc7773f0125.jpg" alt="gambar"></div><br>  Secara potensial, kita dapat menentukan sesuatu seperti parallelepiped sehingga semua simpulnya memiliki rata-rata normal.  Editor 3D akan berusaha untuk menghaluskan permukaannya sehingga terlihat seperti permukaan halus tunggal.  Untuk editor 3D, ini cukup logis, tetapi terlihat sangat aneh, karena kami memiliki objek yang jelas harus memiliki beberapa permukaan yang terpisah (masing-masing permukaan kotak), namun, program mencoba menunjukkannya sebagai satu permukaan halus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ec/d6c/1cc/9ecd6c1cc60c2d431065cb9aa6741979.jpg" alt="gambar"></div><br>  Itulah sebabnya editor 3D biasanya memiliki parameter untuk sudut pemulusan: jika kita memiliki dua poligon yang terhubung pada sudut yang melebihi sudut pemulusan, maka transisinya akan mulus, dan menghubungkan poligon pada sudut kurang dari sudut pemulusan akan menjadi kaku.  Karena ini, sudut curam antara permukaan akan ditampilkan sebagai permukaan yang berbeda, seperti yang terjadi di dunia nyata. <br><br>  Jadi, kami menggunakan normals untuk mengontrol transisi antara wajah model, tetapi Anda bisa melangkah lebih jauh. <br><br>  Karena kita mengubah cara cahaya dipantulkan dari suatu objek, kita juga dapat membuat objek yang sangat sederhana memantulkan cahaya sebagai kompleks.  Ini disebut peta normal.  Kami menggunakan tekstur untuk mengubah arah cahaya yang dipantulkan dari objek 3D, membuatnya terlihat lebih sulit daripada sebenarnya. <br><br>  Contoh dari dunia nyata adalah hologram yang sebelumnya diberikan sebagai hadiah saat membeli keripik kentang (setidaknya di sini, di Spanyol).  Mereka benar-benar datar, tetapi memantulkan cahaya seperti yang dilakukan objek 3D, membuatnya lebih sulit daripada sebenarnya.  Dalam dunia grafis 3D, ini bekerja lebih baik, tetapi masih memiliki keterbatasan (karena permukaannya tetap datar). <br><br>  Meskipun kami menggunakan normal poligon untuk menerapkan semacam sihir hitam, pada kenyataannya, kami tidak mengontrol perataan permukaan model menggunakan normal poligon.  Kami menggunakan vertex normals untuk mengontrol smoothing normals.  Intinya, idenya sama, tetapi sedikit lebih rumit. <br><br>  Setiap dhuwur dapat dikaitkan dengan satu atau lebih normals.  Jika memiliki satu normal, maka kita dapat menyebutnya normal rata-rata dari titik, dan jika beberapa - maka normal dibagi dari titik tersebut. <br><br>  Mari kita ambil dua poligon yang terhubung oleh sebuah ujung.  Jika transisi antara dua wajah mulus (jika kita tentukan itu mulus di Maya / Modo, atau keduanya memiliki grup smoothing yang sama dalam Max / Blender), maka setiap simpul memiliki satu normal, yang merupakan rata-rata normal dari poligon (itulah sebabnya disebut rata-rata normal dari vertex tersebut) )  Catatan penting: hingga baru-baru ini, setiap editor 3D menggunakan caranya sendiri untuk menghitung rata-rata simpul normal, yaitu, peta normal yang dikomputasi dalam satu program di program lain dapat terlihat sangat berbeda.  Saya akan memberi tahu Anda lebih banyak tentang ini di bagian kedua tutorial. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/d8d/4bd/e6bd8d4bd97239a2766676bba73a5185.jpg" alt="gambar"></div><br>  Jika transisi sulit (tepi keras atau kelompok smoothing berbeda), maka setiap simpul memiliki beberapa normals: satu untuk setiap simpul yang terhubung selaras sesuai dengan normalnya.  Dalam hal ini, celah terbentuk antara normals, yang terlihat seperti dua permukaan yang berbeda.  Inilah yang dinamakan split vertex normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05b/9c9/fe5/05b9c9fe5bf8f37e8212f2b25438c9c9.jpg" alt="gambar"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fc/7ed/f7e/6fc7edf7ebada96250b95870ffc4d26c.jpg" alt="gambar"></div><br>  Seperti yang Anda duga, kontrol normal vertex sangat penting jika kita ingin mengontrol peta normal.  Untungnya, kami tidak harus mengubah normals secara langsung atau bahkan melihatnya, tetapi memahami cara kerjanya akan membantu Anda memahami mengapa kami melakukan pekerjaan ini dan untuk lebih memahami masalah yang mungkin kami temui. <br><br>  Saat memanggang peta normal, kami pada dasarnya memberitahu program untuk mengubah arah yang diikuti oleh normals dari model lowpoly, sehingga mereka sesuai dengan arah dalam model highpoly;  oleh karena itu, model lowpoly akan memantulkan cahaya dengan cara yang sama seperti highpoly.  Semua informasi ini disimpan dalam tekstur yang disebut peta normal.  Mari kita lihat sebuah contoh. <br><br>  Katakanlah kita memiliki model low-poly (lowpoly).  Permukaan datar empat titik dengan pengaturan UV yang akan digunakan oleh program memanggang untuk membuat peta normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/888/39d/26288839d4eb72924d12407d19352c76.jpg" alt="gambar"></div><br>  Dan dia perlu mendapatkan informasi tentang normals dari model highpoly ini, normals yang lebih rumit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/bbb/b94/e4ebbbb943f8a3ad71016ee396bc55bb.jpg" alt="gambar"></div><br>  Ingatlah bahwa kami hanya mentransfer informasi tentang normals, mis. UV, material, topologi, transformasi, dll.  tidak relevan  Aturan terbukti: jika model highpoly terlihat bagus, maka normalnya juga bagus dan harus cocok untuk dipanggang. <br><br>  Program memanggang mengambil model lowpoly dan memancarkan sinar mengikuti petunjuk dari lowpoly normals (itulah sebabnya kita perlu mengontrol normalspoly rendah).  Sinar ini memiliki panjang yang terbatas sehingga tidak mendapatkan informasi normal dari tepi yang jauh (biasanya jarak ini disebut jarak panggang atau jarak kandang).  Ketika sinar ini bertabrakan dengan highpoly, program memanggang menghitung bagaimana memantulkan sinar ini sehingga mereka mengikuti arah normal-highpoly dan menyimpan informasi ini di peta normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/487/534/72c48753443123074b3b0170ee04e7e8.jpg" alt="gambar"></div><br>  Berikut adalah hasil memanggang untuk contoh kita: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/256/508/4f3/2565084f33aaafaedfb752e7b5c01b89.jpg" alt="gambar"></div><br>  Kami memiliki tekstur yang digunakan mesin untuk mengubah normals lowpoly sehingga cahaya memantulkan model lowpoly ini seperti halnya dari versi highpoly.  Jangan lupa bahwa ini hanya tekstur yang tidak mempengaruhi siluet model lowpoly (tidak mungkin untuk mengubah cara cahaya tercermin dari model jika cahaya tidak jatuh pada model ini). <br><br>  Meskipun jelas bahwa seseorang dapat "menghitung" tampilan highpoly oleh penampilan peta normal, jelas bahwa peta normal bukan tekstur biasa, karena mereka menyimpan informasi bukan tentang warna, tetapi tentang normal.  Ini juga berarti bahwa peta normal tidak dapat dianggap sebagai tekstur biasa;  selain itu, seperti yang akan kita lihat, mereka memiliki parameter kompresi dan koreksi gamma khusus. <br><br>  Anda dapat melihat peta normal sebagai satu set tiga tekstur dalam nuansa abu-abu, disimpan dalam satu gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/f22/2ce/c4ef222ce73d3cd29b0b055cec587c6b.jpg" alt="gambar"></div><br>  Gambar pertama memberitahu mesin bagaimana model ini harus mencerminkan insiden cahaya di sebelah kanan;  disimpan di saluran merah dari tekstur peta normal. <br><br>  Gambar kedua memberitahu mesin bagaimana model harus mencerminkan insiden cahaya dari bawah *;  disimpan di saluran hijau dari tekstur peta normal. <br><br>  * Dalam beberapa program, cahaya tidak jatuh dari bawah, tetapi dari atas, yaitu, mungkin ada peta normal "sisi kiri" dan "sisi kanan".  Seperti yang akan kita lihat nanti, ini dapat menyebabkan beberapa masalah. <br><br>  Gambar ketiga memberi tahu mesin bagaimana model harus mencerminkan insiden cahaya dari depan;  disimpan di saluran biru dari tekstur peta normal.  Karena sebagian besar objek tampak putih ketika diterangi dari depan, peta normal biasanya tampak kebiru-biruan. <br><br>  Ketika kami menggabungkan ketiga gambar menjadi satu, kami mendapatkan peta yang normal.  Ingat bahwa penjelasan ini tidak sepenuhnya benar, tetapi saya berharap ini akan memungkinkan Anda untuk memahami informasi yang tersimpan di dalam peta normal dan lebih memahami apa yang dilakukannya. <br><br>  Untuk meringkas: <br><br>  Normal adalah vektor yang digunakan untuk menentukan bagaimana cahaya dipantulkan dari suatu permukaan.  Mereka dapat digunakan untuk mengontrol transisi antara wajah (rata-rata normal dari simpul yang terhubung untuk membuat transisi yang mulus atau memisahkan mereka untuk membuat transisi yang kaku), tetapi Anda juga dapat mengubah arahnya sehingga model lowpoly memantulkan cahaya dengan cara yang sama seperti model yang lebih kompleks. <br><br>  Informasi ini disimpan dalam tiga saluran gambar terpisah, dan editor 3D membacanya untuk memahami ke arah mana permukaan model akan terlihat. <br><br>  Dalam artikel berikutnya dalam seri ini, kita akan berbicara tentang cara memanggang bagian-bagian ini dari model highpoly menjadi lowpoly. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481480/">https://habr.com/ru/post/id481480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481470/index.html">Karangan bunga pintar untuk sepanjang tahun</a></li>
<li><a href="../id481472/index.html">Riwayat DNS: Saat Nama Domain Dibayar</a></li>
<li><a href="../id481474/index.html">Kami dari tes lain - kami sedang menguji database di MSTest</a></li>
<li><a href="../id481476/index.html">Bagaimana saya mulai berbicara di konferensi dan tidak bisa berhenti</a></li>
<li><a href="../id481478/index.html">STM32 + CMSIS + STM32CubeIDE</a></li>
<li><a href="../id481482/index.html">Posting silang ke halaman Facebook menggunakan PHP SDK</a></li>
<li><a href="../id481484/index.html">AI berusaha menghindari masalah perilaku belajar yang rumit</a></li>
<li><a href="../id481486/index.html">â€œTetap hidup, tetap hidupâ€: protokol baru akan meningkatkan radius kemungkinan penggunaan Wi-Fi hingga 60 meter</a></li>
<li><a href="../id481488/index.html">Bagaimana pejabat Wilayah Moskow mengukur polusi udara</a></li>
<li><a href="../id481490/index.html">Vitamin D. Wisata Singkat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>