<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏻 🐉 ❕ تحليلات البيانات التنبؤية - النمذجة والتحقق من الصحة 🦃 🚽 🍠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أقدم لكم ترجمة فصل من كتاب علم البيانات العملي مع أناكوندا 
 "تحليلات البيانات التنبؤية - النمذجة والتحقق" 



 هدفنا الرئيسي في إجراء تحليلات البيانا...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تحليلات البيانات التنبؤية - النمذجة والتحقق من الصحة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428321/" style=";text-align:right;direction:rtl">  أقدم لكم ترجمة فصل من كتاب علم البيانات العملي مع أناكوندا <br>  <b>"تحليلات البيانات التنبؤية - النمذجة والتحقق"</b> <br><br><img src="https://habrastorage.org/webt/eg/b0/jk/egb0jk10gh3cnlxzozestcagccc.png" height="500" width="300"><br><br>  هدفنا الرئيسي في إجراء تحليلات البيانات المختلفة هو البحث عن أنماط للتنبؤ بما قد يحدث في المستقبل.  بالنسبة لسوق الأوراق المالية ، يجري الباحثون والخبراء اختبارات مختلفة لفهم آليات السوق.  في هذه الحالة ، يمكنك طرح الكثير من الأسئلة.  ماذا سيكون مستوى مؤشر السوق في السنوات الخمس المقبلة؟  ماذا سيكون النطاق السعري التالي لشركة IBM؟  هل سيزداد تقلب السوق أو ينقص في المستقبل؟  ماذا يمكن أن يكون التأثير إذا غيرت الحكومات سياساتها الضريبية؟  ما هي المكاسب والخسائر المحتملة إذا بدأت دولة حربا تجارية مع دولة أخرى؟  كيف نتنبأ بسلوك المستهلك من خلال تحليل بعض المتغيرات ذات الصلة؟  هل يمكننا توقع احتمالية تخرج طالب الدراسات العليا بنجاح؟  هل يمكننا إيجاد علاقة بين السلوك المحدد لمرض معين؟ <br><br>  لذلك ، سننظر في المواضيع التالية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فهم تحليل البيانات التنبؤية </li><li style=";text-align:right;direction:rtl">  مجموعات بيانات مفيدة </li><li style=";text-align:right;direction:rtl">  التنبؤ بالأحداث المستقبلية </li><li style=";text-align:right;direction:rtl">  اختيار النموذج </li><li style=";text-align:right;direction:rtl">  اختبار جرانجر السببي </li></ul><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  فهم تحليل البيانات التنبؤية </h2><br>  قد يكون لدى الناس العديد من الأسئلة بخصوص الأحداث المستقبلية. <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المستثمر ، إذا استطاع التنبؤ بالحركة المستقبلية لأسعار الأسهم ، يمكنه تحقيق ربح كبير. </li><li style=";text-align:right;direction:rtl">  إذا تمكنت الشركات من توقع اتجاه منتجاتها ، فيمكنها زيادة سعر سهمها وحصتها في السوق. </li><li style=";text-align:right;direction:rtl">  إذا تمكنت الحكومات من التنبؤ بأثر شيخوخة السكان على المجتمع والاقتصاد ، فسيكون لديها المزيد من الحوافز لتطوير سياسات أفضل من حيث ميزانية الدولة والقرارات الاستراتيجية الأخرى ذات الصلة. </li><li style=";text-align:right;direction:rtl">  الجامعات ، إذا كان بإمكانهم فهم طلب السوق جيدًا من حيث الجودة والمهارات المحددة لخريجيهم ، فيمكنهم تطوير مجموعة من البرامج الأفضل أو إطلاق برامج جديدة لتلبية احتياجات القوى العاملة في المستقبل. </li></ul><br>  من أجل تشخيص أفضل ، يجب على الباحثين النظر في العديد من الأسئلة.  على سبيل المثال ، هل بيانات العينة صغيرة جدًا؟  كيفية إزالة المتغيرات المفقودة؟  هل مجموعة البيانات هذه متحيزة من حيث إجراءات جمع البيانات؟  كيف نشعر بشأن التطرف أو الانبعاثات؟  ما هي الموسمية وكيف نتعامل معها؟  ما النماذج التي يجب أن نستخدمها؟  سيتناول هذا الفصل بعض هذه القضايا.  لنبدأ بمجموعة بيانات مفيدة. <br><br><h1 style=";text-align:right;direction:rtl">  مجموعات بيانات مفيدة </h1><br>  أحد أفضل مصادر البيانات هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مستودع تعلم الآلة UCI</a> .  بعد زيارة الموقع سنرى القائمة التالية: <br><br><img src="https://habrastorage.org/webt/p2/sa/47/p2sa47ajhhmjdwnigi4vg19raue.png"><br><br>  على سبيل المثال ، إذا قمت بتحديد مجموعة البيانات الأولى (أذن البحر) ، فسوف نرى ما يلي.  لتوفير المساحة ، يتم عرض الجزء العلوي فقط: <br><br><img src="https://habrastorage.org/webt/g2/6i/u4/g26iu42u1yln7fvxz4oj_cybzxm.png"><br><br>  من هنا ، يمكن للمستخدمين تنزيل مجموعة البيانات والعثور على تعريفات متغيرة.  يمكن استخدام الكود التالي لتحميل مجموعة البيانات: <br><br><pre style=";text-align:right;direction:rtl"><code class="bash hljs">dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"UCIdatasets"</span></span> path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) dim(.UCIdatasets) head(.UCIdatasets)</code> </pre> <br>  يظهر الناتج المقابل هنا: <br><br><img src="https://habrastorage.org/webt/sk/rn/8j/skrn8jh3kygkqwxfvpzza2xnnzk.png"><br><br>  من الاستنتاج السابق ، نعلم أنه توجد في مجموعة البيانات 427 ملاحظة (مجموعات البيانات).  لكل منها ، لدينا 7 وظائف ذات صلة ، مثل <i>الاسم و Data_Types و Default_Task و Attribute_Types و N_Instance</i> (عدد الحالات) و <i>N_Attributes</i> (عدد السمات) <i>والسنة</i> .  يمكن تفسير متغير يسمى <i>Default_Task</i> على أنه الاستخدام الرئيسي لكل مجموعة بيانات.  على سبيل المثال ، يمكن استخدام مجموعة بيانات أولى تسمى <i>Abalone</i> في <i>التصنيف</i> .  يمكن استخدام وظيفة <i>() الفريدة</i> للبحث عن جميع مهام <i>Default_Task</i> الممكنة الموضحة هنا: <br><br><img src="https://habrastorage.org/webt/ul/4-/fj/ul4-fjckb20uvcz1iif9yup4wem.png"><br><br><h3 style=";text-align:right;direction:rtl">  حزمة R AppliedPredictiveModeling </h3><br>  تتضمن هذه الحزمة العديد من مجموعات البيانات المفيدة التي يمكن استخدامها لهذا الفصل وغيرها.  أسهل طريقة للعثور على مجموعات البيانات هذه هي عن طريق وظيفة <i>help ()</i> الموضحة هنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(AppliedPredictiveModeling) <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(package=AppliedPredictiveModeling)</code> </pre><br>  نعرض هنا بعض الأمثلة لتحميل مجموعات البيانات هذه.  لتحميل مجموعة بيانات واحدة ، نستخدم الدالة <i>data ()</i> .  بالنسبة لمجموعة البيانات الأولى المسماة <i>أذن البحر</i> ، لدينا الكود التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(AppliedPredictiveModeling) data(abalone) dim(abalone) head(abalone)</code> </pre><br>  الإخراج كما يلي: <br><br><img src="https://habrastorage.org/webt/wb/ah/sb/wbahsbbuw2teuts6nhjhiqawm4g.png"><br><br>  في بعض الأحيان ، تتضمن مجموعة بيانات كبيرة عدة مجموعات بيانات فرعية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(AppliedPredictiveModeling) data(solubility) ls(pattern=<span class="hljs-string"><span class="hljs-string">"sol"</span></span>)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] <span class="hljs-string"><span class="hljs-string">"solTestX"</span></span> <span class="hljs-string"><span class="hljs-string">"solTestXtrans"</span></span> <span class="hljs-string"><span class="hljs-string">"solTestY"</span></span> [4] <span class="hljs-string"><span class="hljs-string">"solTrainX"</span></span> <span class="hljs-string"><span class="hljs-string">"solTrainXtrans"</span></span> <span class="hljs-string"><span class="hljs-string">"solTrainY"</span></span></code> </pre><br>  لتحميل كل مجموعة بيانات ، يمكننا استخدام الوظائف <i>dim ()</i> <i>والرأس ()</i> <i>والذيل ()</i> <i>والملخص ()</i> . <br><br><h3 style=";text-align:right;direction:rtl">  تحليلات السلاسل الزمنية </h3><br>  يمكن تعريف السلاسل الزمنية على أنها مجموعة من القيم التي يتم الحصول عليها في لحظات متتالية من الزمن ، غالبًا بفترات متساوية بينها.  هناك فترات مختلفة ، مثل السنوية والفصلية والشهرية والأسبوعية واليومية.  بالنسبة للسلسلة الزمنية للناتج المحلي الإجمالي (الناتج المحلي الإجمالي) ، نستخدم عادةً ربع سنويًا أو سنويًا.  لعروض الأسعار - الترددات السنوية والشهرية واليومية.  باستخدام الكود التالي ، يمكننا الحصول على بيانات الناتج المحلي الإجمالي للولايات المتحدة كل ربع سنة ولفترة سنوية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">ath&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPannual"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) head(.usGDPannual)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">YEAR GDP 1 1930 92.2 2 1931 77.4 3 1932 59.5 4 1933 57.2 5 1934 66.8 6 1935 74.3</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPquarterly"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) head(.usGDPquarterly)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> DATE GDP_CURRENT GDP2009DOLLAR 1 1947Q1 243.1 1934.5 2 1947Q2 246.3 1932.3 3 1947Q3 250.1 1930.3 4 1947Q4 260.3 1960.7 5 1948Q1 266.2 1989.5 6 1948Q2 272.9 2021.9</code> </pre><br>  ومع ذلك ، لدينا العديد من الأسئلة لتحليل السلاسل الزمنية.  على سبيل المثال ، من وجهة نظر الاقتصاد الكلي ، لدينا دورات تجارية أو اقتصادية.  قد يكون للصناعات أو الشركات الموسمية.  على سبيل المثال ، باستخدام الصناعة الزراعية ، سوف ينفق المزارعون أكثر في فصلي الربيع والخريف وأقل في الشتاء.  بالنسبة لتجار التجزئة ، سيكون لديهم تدفق هائل من الأموال في نهاية العام. <br><br>  لمعالجة السلسلة الزمنية ، يمكننا استخدام العديد من الميزات المفيدة المضمنة في حزمة R ، والتي تسمى <i>timeSeries</i> .  في المثال ، نأخذ متوسط ​​البيانات اليومية بتردد أسبوعي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(timeSeries) data(MSFT) x &lt;- MSFT by &lt;- timeSequence(from = start(x), to = end(x), by = <span class="hljs-string"><span class="hljs-string">"week"</span></span>) y&lt;-aggregate(x,by,mean)</code> </pre><br>  يمكننا أيضًا استخدام الدالة <i>head ()</i> لرؤية بعض الملاحظات: <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">head(x)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">GMT Open High Low Close Volume 2000-09-27 63.4375 63.5625 59.8125 60.6250 53077800 2000-09-28 60.8125 61.8750 60.6250 61.3125 26180200 2000-09-29 61.0000 61.3125 58.6250 60.3125 37026800 2000-10-02 60.5000 60.8125 58.2500 59.1250 29281200 2000-10-03 59.5625 59.8125 56.5000 56.5625 42687000 2000-10-04 56.3750 56.5625 54.5000 55.4375 68226700</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">head(y)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">GMT Open High Low Close Volume 2000-09-27 63.4375 63.5625 59.8125 60.6250 53077800 2000-10-04 59.6500 60.0750 57.7000 58.5500 40680380 2000-10-11 54.9750 56.4500 54.1625 55.0875 36448900 2000-10-18 53.0375 54.2500 50.8375 52.1375 50631280 2000-10-25 61.7875 64.1875 60.0875 62.3875 86457340 2000-11-01 66.1375 68.7875 65.8500 67.9375 53496000</code> </pre> <br><br><h2 style=";text-align:right;direction:rtl">  التنبؤ بالأحداث المستقبلية </h2><br>  هناك العديد من الطرق التي يمكننا استخدامها عند محاولة التنبؤ بالمستقبل ، مثل المتوسط ​​المتحرك ، والانحدار ، والانحدار الذاتي ، وما إلى ذلك. أولاً ، فلنبدأ بالأسهل للمتوسط ​​المتحرك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">movingAverageFunction&lt;- <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(data,n=10){ out= data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> n:length(data)){ out[i] = mean(data[(i-n+1):i]) } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>(out) }</code> </pre> <br>  في الكود السابق ، القيمة الافتراضية لعدد الفترات هي 10. يمكننا استخدام مجموعة بيانات تسمى MSFT مضمنة في حزمة R تسمى <i>timeSeries</i> (انظر الكود التالي): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(timeSeries) data(MSFT) p&lt;-MSFT<span class="hljs-variable"><span class="hljs-variable">$Close</span></span> <span class="hljs-comment"><span class="hljs-comment"># ma&lt;-movingAverageFunction(p,3) head(p)</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 60.6250 61.3125 60.3125 59.1250 56.5625 55.4375</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">head(ma)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 60.62500 61.31250 60.75000 60.25000 58.66667 57.04167</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">mean(p[1:3])</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 60.75</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">mean(p[2:4])</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 60.25</code> </pre> <br>  في الوضع اليدوي ، نجد أن متوسط ​​القيم الثلاث الأولى لـ <i>x</i> يطابق القيمة الثالثة لـ <i>y</i> .  بطريقة ما ، يمكننا استخدام المتوسط ​​المتحرك للتنبؤ بالمستقبل. <br><br>  في المثال التالي ، سنوضح كيفية تقييم عوائد السوق المتوقعة العام المقبل.  هنا نستخدم مؤشر S &amp; P500 والمتوسط ​​السنوي للقيمة السنوية كقيمنا المتوقعة.  يتم استخدام الأوامر القليلة الأولى لتحميل مجموعة بيانات ذات صلة تسمى <i>.sp500monthly</i> .  الغرض من البرنامج هو تقييم المتوسط ​​السنوي وفاصل الثقة 90 في المائة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(data.table) path&lt;-<span class="hljs-string"><span class="hljs-string">'http://canisius.edu/~yany/RData/'</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">'sp500monthly.RData'</span></span> link&lt;-paste(path,dataSet,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(link)) <span class="hljs-comment"><span class="hljs-comment">#head(.sp500monthly,2) p&lt;-.sp500monthly$ADJ.CLOSE n&lt;-length(p) logRet&lt;-log(p[2:n]/p[1:(n-1)]) years&lt;-format(.sp500monthly$DATE[2:n],"%Y") y&lt;-data.frame(.sp500monthly$DATE[2:n],years,logRet) colnames(y)&lt;-c("DATE","YEAR","LOGRET") y2&lt;- data.table(y) z&lt;-y2[,sum(LOGRET),by=YEAR] z2&lt;-na.omit(z) annualRet&lt;-data.frame(z2$YEAR,exp(z2[,2])-1) n&lt;-nrow(annualRet) std&lt;-sd(annualRet[,2]) stdErr&lt;-std/sqrt(n) ourMean&lt;-mean(annualRet[,2]) min2&lt;-ourMean-2*stdErr max2&lt;-ourMean+2*stdErr cat("[min mean max ]\n")</span></span></code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[min mean max ]</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cat(min2,ourMean,max2,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">0.05032956 0.09022369 0.1301178</code> </pre><br>  كما ترى من النتائج ، فإن المتوسط ​​السنوي للعائد السنوي لمؤشر S &amp; P500 هو 9٪.  لكن لا يمكننا القول أن ربحية المؤشر العام المقبل ستكون 9٪ ، لأن  يمكن أن يكون من 5٪ إلى 13٪ ، وهذه تقلبات كبيرة. <br><br><h3 style=";text-align:right;direction:rtl">  موسمية </h3><br>  في المثال التالي ، نظهر استخدام الارتباط الذاتي.  أولاً ، <i>ننزل</i> حزمة R تسمى <i>astsa</i> ، والتي تعني تحليل السلاسل الزمنية الإحصائية التطبيقية.  ثم نقوم بتحميل الناتج المحلي الإجمالي للولايات المتحدة بوتيرة ربع سنوية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(astsa) path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPquarterly"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) x&lt;-.usGDPquarterly<span class="hljs-variable"><span class="hljs-variable">$DATE</span></span> y&lt;-.usGDPquarterly<span class="hljs-variable"><span class="hljs-variable">$GDP_CURRENT</span></span> plot(x,y) diff4 = diff(y,4) acf2(diff4,24)</code> </pre> <br>  في التعليمة البرمجية أعلاه ، تقبل الدالة <i>diff ()</i> الفرق ، على سبيل المثال ، القيمة الحالية مطروحًا منها القيمة السابقة.  تشير قيمة الإدخال الثانية إلى تأخير.  يتم استخدام دالة تسمى <i>acf2 ()</i> لإنشاء وطباعة السلاسل الزمنية ACF و PACF.  يرمز ACF إلى دالة التباين الذاتي ، و PACF إلى وظيفة الارتباط الذاتي الجزئي.  يتم عرض الرسوم البيانية ذات الصلة هنا: <br><br><img src="https://habrastorage.org/webt/n6/89/sv/n689svzvvvik4co4abbgzeobtnw.png" height="400" width="300"><br><br><h3 style=";text-align:right;direction:rtl">  <b>تصور المكون</b> </h3><br>  من الواضح أن المفاهيم ومجموعات البيانات ستكون مفهومة أكثر بكثير إذا تمكنا من استخدام الرسوم البيانية.  يوضح المثال الأول التقلبات في الناتج المحلي الإجمالي للولايات المتحدة على مدى العقود الخمسة الماضية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">path&lt;-<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/RData/"</span></span> dataSet&lt;-<span class="hljs-string"><span class="hljs-string">"usGDPannual"</span></span> con&lt;-paste(path,dataSet,<span class="hljs-string"><span class="hljs-string">".RData"</span></span>,sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) load(url(con)) title&lt;-<span class="hljs-string"><span class="hljs-string">"US GDP"</span></span> xTitle&lt;-<span class="hljs-string"><span class="hljs-string">"Year"</span></span> yTitle&lt;-<span class="hljs-string"><span class="hljs-string">"US annual GDP"</span></span> x&lt;-.usGDPannual<span class="hljs-variable"><span class="hljs-variable">$YEAR</span></span> y&lt;-.usGDPannual<span class="hljs-variable"><span class="hljs-variable">$GDP</span></span> plot(x,y,main=title,xlab=xTitle,ylab=yTitle)</code> </pre> <br>  يظهر الجدول المقابل هنا: <br><br><img src="https://habrastorage.org/webt/rz/9z/h8/rz9zh8qa22budzolcuushzzgwow.png" height="400" width="300"><br><br>  إذا استخدمنا المقياس اللوغاريتمي للناتج المحلي الإجمالي ، فسيكون لدينا الرمز والرسم البياني التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">yTitle&lt;-<span class="hljs-string"><span class="hljs-string">"Log US annual GDP"</span></span> plot(x,<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(y),main=title,xlab=xTitle,ylab=yTitle)</code> </pre> <br>  المخطط التالي قريب من خط مستقيم: <br><br><img src="https://habrastorage.org/webt/ae/f_/a6/aef_a6iuo4ielgslci9ry0vf1c8.png" height="400" width="300"><br><br><h3 style=";text-align:right;direction:rtl">  حزمة R - LiblineaR </h3><br>  هذه الحزمة هي نموذج تنبؤي خطي يعتمد على مكتبة LIBLINEAR C / C ++.  فيما يلي مثال على استخدام مجموعة بيانات <i>القزحية</i> .  يحاول البرنامج التنبؤ بالفئة التي ينتمي إليها النبات باستخدام بيانات التدريب: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(LiblineaR) data(iris) attach(iris) x=iris[,1:4] y=factor(iris[,5]) train=sample(1:dim(iris)[1],100) xTrain=x[train,];xTest=x[-train,] yTrain=y[train]; yTest=y[-train] s=scale(xTrain,center=TRUE,scale=TRUE) <span class="hljs-comment"><span class="hljs-comment"># tryTypes=c(0:7) tryCosts=c(1000,1,0.001) bestCost=NA bestAcc=0 bestType=NA # for(ty in tryTypes){ for(co in tryCosts){ acc=LiblineaR(data=s,target=yTrain,type=ty,cost=co,bias=1,cross=5,verbose=FALSE) cat("Results for C=",co,": ",acc," accuracy.\n",sep="") if(acc&gt;bestAcc){ bestCost=co bestAcc=acc bestType=ty } } } cat("Best model type is:",bestType,"\n") cat("Best cost is:",bestCost,"\n") cat("Best accuracy is:",bestAcc,"\n") # Re-train best model with best cost value. m=LiblineaR(data=s,target=yTrain,type=bestType,cost=bestCost,bias=1,verbose=FALSE) # Scale the test data s2=scale(xTest,attr(s,"scaled:center"),attr(s,"scaled:scale")) pr=FALSE; # Make prediction if(bestType==0 || bestType==7) pr=TRUE p=predict(m,s2,proba=pr,decisionValues=TRUE) res=table(p$predictions,yTest) # Display confusion matrix print(res) # Compute Balanced Classification Rate BCR=mean(c(res[1,1]/sum(res[,1]),res[2,2]/sum(res[,2]),res[3,3]/sum(res[,3]))) print(BCR)</span></span></code> </pre><br>  الاستنتاج على النحو التالي.  BCR هو معدل تصنيف متوازن.  لهذا الرهان ، كلما كان ذلك أفضل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best model type is:"</span></span>,bestType,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Best model <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> is: 4</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best cost is:"</span></span>,bestCost,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Best cost is: 1</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">cat(<span class="hljs-string"><span class="hljs-string">"Best accuracy is:"</span></span>,bestAcc,<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Best accuracy is: 0.98</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(res) yTest setosa versicolor virginica setosa 16 0 0 versicolor 0 17 0 virginica 0 3 14 <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(BCR)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 0.95</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  حزمة R - الكسوف </h3><br>  هذه الحزمة عبارة عن تجمع متوسط ​​التوجه للنماذج التنبؤية المفسرة في البيانات عالية الأبعاد.  أولاً ، دعنا نلقي نظرة على مجموعة بيانات تسمى <i>simdata</i> تحتوي على بيانات محاكاة لحزمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(eclust) data(<span class="hljs-string"><span class="hljs-string">"simdata"</span></span>) dim(simdata)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 100 502</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">simdata[1:5, 1:6]</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> YE Gene1 Gene2 Gene3 Gene4 [1,] -94.131497 0 -0.4821629 0.1298527 0.4228393 0.36643188 [2,] 7.134990 0 -1.5216289 -0.3304428 -0.4384459 1.57602830 [3,] 1.974194 0 0.7590055 -0.3600983 1.9006443 -1.47250061 [4,] -44.855010 0 0.6833635 1.8051352 0.1527713 -0.06442029 [5,] 23.547378 0 0.4587626 -0.3996984 -0.5727255 -1.75716775</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">table(simdata[,<span class="hljs-string"><span class="hljs-string">"E"</span></span>])</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">0 1 50 50</code> </pre><br>  يوضح الاستنتاج السابق أن بُعد البيانات هو 100 × 502. <b>Y</b> هو ناقل الاستجابة المستمر ، و <b>E</b> هو متغير البيئة الثنائية لطريقة ECLUST.  <b>E = 0</b> للغير مكشوف (n = 50) و <b>E = 1</b> للكشف (n = 50). <br><br>  يقوم البرنامج التالي R بتقييم تحويل Fisher z: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(eclust) data(<span class="hljs-string"><span class="hljs-string">"simdata"</span></span>) X = simdata[,c(-1,-2)] firstCorr&lt;-cor(X[1:50,]) secondCorr&lt;-cor(X[51:100,]) score&lt;-u_fisherZ(n0=100,cor0=firstCorr,n1=100,cor1=secondCorr) dim(score)</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 500 500</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">score[1:5,1:5]</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> Gene1 Gene2 Gene3 Gene4 Gene5 Gene1 1.000000 -8.062020 6.260050 -8.133437 -7.825391 Gene2 -8.062020 1.000000 9.162208 -7.431822 -7.814067 Gene3 6.260050 9.162208 1.000000 8.072412 6.529433 Gene4 -8.133437 -7.431822 8.072412 1.000000 -5.099261 Gene5 -7.825391 -7.814067 6.529433 -5.099261 1.000000</code> </pre><br>  نحدد تحويل فيشر z.  بافتراض أن لدينا مجموعة من أزواج <b>n</b> <b>x</b> <i>i</i> و <b>y</b> <i>i</i> ، يمكننا تقدير ارتباطها باستخدام الصيغة التالية: <br><br><img src="https://habrastorage.org/webt/rn/7c/gq/rn7cgq57sb0htzxqrypdk20keqo.png"><br><br>  <b>p</b> هنا هو الارتباط بين متغيرين ، و <img src="https://habrastorage.org/webt/f5/uq/fm/f5uqfmo1am-aj0zhkkrswmlglka.png" height="30" width="20">  و <img src="https://habrastorage.org/webt/ew/sg/o0/ewsgo0q-nftlketprnpqlgvxgw4.png" height="20" width="20">  هي وسيلة نموذجية للمتغيرات العشوائية <b>x</b> و <b>y</b> .  يتم تعريف قيمة <b>z</b> على النحو التالي: <br><br><img src="https://habrastorage.org/webt/se/u4/-t/seu4-tahwcqhc9iz0sgcw7lnmsi.png" height="400" width="500"><br><br>  <b>ln</b> هي دالة اللوغاريتم الطبيعي ، و <b>arctanh ()</b> هي دالة المماس الزائدية العكسية. <br><br><h1 style=";text-align:right;direction:rtl">  اختيار النموذج </h1><br>  عند العثور على نموذج جيد ، نواجه أحيانًا نقصًا / فائضًا في البيانات.  تم استعارة المثال التالي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من هنا</a> .  يوضح مشاكل العمل مع هذا وكيف يمكننا استخدام الانحدار الخطي مع ميزات كثيرة الحدود لتقريب الوظائف غير الخطية.  الوظيفة المحددة: <br><br><img src="https://habrastorage.org/webt/s8/cx/ey/s8cxeys7x5so7oet9x1gywgjle4.png" height="200" width="300"><br><br>  في البرنامج التالي ، نحاول استخدام نماذج خطية ومتعددة الحدود لتقريب معادلة.  يظهر رمز معدل قليلاً هنا.  يوضح البرنامج تأثير نقص البيانات / العرض الزائد على النموذج: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">import sklearn import numpy as np import matplotlib.pyplot as plt from sklearn.pipeline import Pipeline from sklearn.preprocessing import PolynomialFeatures from sklearn.linear_model import LinearRegression from sklearn.model_selection import cross_val_score <span class="hljs-comment"><span class="hljs-comment"># np.random.seed(123) n= 30 # number of samples degrees = [1, 4, 15] def true_fun(x): return np.cos(1.5*np.pi*x) x = np.sort(np.random.rand(n)) y = true_fun(x) + np.random.randn(n) * 0.1 plt.figure(figsize=(14, 5)) title="Degree {}\nMSE = {:.2e}(+/- {:.2e})" name1="polynomial_features" name2="linear_regression" name3="neg_mean_squared_error" # for i in range(len(degrees)): ax=plt.subplot(1,len(degrees),i+1) plt.setp(ax, xticks=(), yticks=()) pFeatures=PolynomialFeatures(degree=degrees[i],include_bias=False) linear_regression = LinearRegression() pipeline=Pipeline([(name1,pFeatures),(name2,linear_regression)]) pipeline.fit(x[:,np.newaxis],y) scores=cross_val_score(pipeline,x[:,np.newaxis],y,scoring=name3,cv=10) xTest = np.linspace(0, 1, 100) plt.plot(xTest,pipeline.predict(xTest[:,np.newaxis]),label="Model") plt.plot(xTest,true_fun(xTest),label="True function") plt.scatter(x,y,edgecolor='b',s=20,label="Samples") plt.xlabel("x") plt.ylabel("y") plt.xlim((0,1)) plt.ylim((-2,2)) plt.legend(loc="best") plt.title(title.format(degrees[i],-scores.mean(),scores.std())) plt.show()</span></span></code> </pre><br>  تظهر الرسوم البيانية الناتجة هنا: <br><br><img src="https://habrastorage.org/webt/nz/4q/io/nz4qioulhxn9jmgwprxj2e_zffo.png"><br><br><h3 style=";text-align:right;direction:rtl">  حزمة بايثون - نموذج المنصة </h3><br>  يمكن العثور على مثال <a href="">هنا</a> . <br><br>  تظهر الأسطر القليلة الأولى من التعليمات البرمجية هنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">import datetime import pandas from sqlalchemy import create_engine from metta import metta_io as metta from catwalk.storage import FSModelStorageEngine, CSVMatrixStore from catwalk.model_trainers import ModelTrainer from catwalk.predictors import Predictor from catwalk.evaluation import ModelEvaluator from catwalk.utils import save_experiment_and_get_hash <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(FSModelStorageEngine)</code> </pre> <br>  يظهر الاستنتاج المقابل هنا.  لتوفير المساحة ، يتم تقديم الجزء العلوي فقط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Help on class FSModelStorageEngine <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> module catwalk.storage: class FSModelStorageEngine(ModelStorageEngine) | Method resolution order: | FSModelStorageEngine | ModelStorageEngine | builtins.object | | Methods defined here: | | __init__(self, *args, **kwargs) | Initialize self. See <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(self)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> accurate signature. | | get_store(self, model_hash) | | ----------------------------------------------------------------------</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">| Data descriptors inherited from ModelStorageEngine: | | __dict__ | dictionary <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance variables (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined) | | __weakref__ | list of weak references to the object (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined)</code> </pre><br><h3 style=";text-align:right;direction:rtl">  حزمة بايثون - sklearn </h3><br>  نظرًا لأن <i>sklearn</i> هي حزمة مفيدة جدًا ، يجدر إظهار المزيد من الأمثلة على استخدام هذه الحزمة.  يوضح المثال الموضح هنا كيفية استخدام الحزمة لتصنيف المستندات حسب الموضوع باستخدام نهج مجموعة الكلمات. <br>  يستخدم هذا المثال مصفوفة <i>scipy.sparse</i> لتخزين الكائنات ويوضح المصنفات المختلفة التي يمكنها معالجة المصفوفات المتفرقة بكفاءة.  يستخدم هذا المثال مجموعة بيانات من 20 مجموعة أخبار.  سيتم تنزيله تلقائيًا ثم تخزينه مؤقتًا.  يحتوي الملف المضغوط على ملفات إدخال ويمكن تنزيلها من <a href="">هنا</a> .  الكود متاح <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> .  لتوفير المساحة ، يتم عرض الأسطر القليلة الأولى فقط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">import logging import numpy as np from optparse import OptionParser import sys from time import time import matplotlib.pyplot as plt from sklearn.datasets import fetch_20newsgroups from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.feature_extraction.text import HashingVectorizer from sklearn.feature_selection import SelectFromModel</code> </pre><br>  يظهر الناتج المقابل هنا: <br><br><img src="https://habrastorage.org/webt/i-/tb/sv/i-tbsvgaud04-iz5chghtgp2zqq.png"><br><br>  هناك ثلاثة مؤشرات لكل طريقة: التقييم ووقت التدريب ووقت الاختبار. <br><br><h3 style=";text-align:right;direction:rtl">  حزمة جوليا - QuantEcon </h3><br>  خذ على سبيل المثال استخدام سلاسل ماركوف: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">using QuantEcon P = [0.4 0.6; 0.2 0.8]; mc = MarkovChain(P) x = simulate(mc, 100000); mean(x .== 1) <span class="hljs-comment"><span class="hljs-comment"># mc2 = MarkovChain(P, ["employed", "unemployed"]) simulate(mc2, 4)</span></span></code> </pre> <br>  النتيجة: <br><br><img src="https://habrastorage.org/webt/6x/ru/4p/6xru4ppkn3ebq_sa6etrwlefdeu.png"><br><br>  الغرض من المثال هو معرفة كيف يتحول شخص من وضع اقتصادي في المستقبل إلى وضع آخر.  أولاً ، دعنا نلقي نظرة على الرسم البياني التالي: <br><br><img src="https://habrastorage.org/webt/1y/so/ho/1ysoho1nccj6fr7_zyh_ebvrcbu.png"><br><br>  دعونا ننظر إلى أقصى اليسار بيضاوي مع الحالة "الفقيرة".  0.9 يعني أن الشخص الذي لديه هذا الوضع لديه فرصة 90 ٪ للبقاء فقيرا ، و 10 ٪ يذهبون إلى الطبقة المتوسطة.  يمكن تمثيله بالمصفوفة التالية ، الأصفار حيث لا توجد حافة بين العقد: <br><br><img src="https://habrastorage.org/webt/5o/cn/m4/5ocnm45t6i6i_nalizeusknyjxi.png" height="200" width="400"><br><br>  يقال أن حالتين ، x و y ، مرتبطتان ببعضهما إذا كان هناك أعداد صحيحة موجبة j و k ، مثل: <br><br><img src="https://habrastorage.org/webt/rb/d9/_l/rbd9_lo7hsj78rafch1eposdsgy.png"><br><br>  تسمى سلسلة ماركوف <i>P</i> غير قابلة للاختزال إذا كانت جميع الحالات متصلة ؛  أي ، إذا <i>تم</i> الإبلاغ عن <i>س</i> و <i>ص</i> لكل (س ، ص).  سيؤكد الرمز التالي هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">using QuantEcon P = [0.9 0.1 0.0; 0.4 0.4 0.2; 0.1 0.1 0.8]; mc = MarkovChain(P) is_irreducible(mc)</code> </pre><br>  يمثل الرسم البياني التالي حالة متطرفة ، حيث ستكون الحالة المستقبلية للشخص الفقير 100 ٪ فقيرة: <br><br><img src="https://habrastorage.org/webt/xj/1h/u_/xj1hu_jmqywzhb1plv68dvy0sgk.png" height="600" width="400"><br><br>  سيؤكد الرمز التالي هذا أيضًا ، لأن النتيجة ستكون <i>خاطئة</i> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">using QuantEcon P2 = [1.0 0.0 0.0; 0.1 0.8 0.1; 0.0 0.2 0.8]; mc2 = MarkovChain(P2) is_irreducible(mc2)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  اختبار جرانجر السببي </h1><br>  يتم استخدام اختبار السببية Granger لتحديد ما إذا كانت سلسلة زمنية واحدة عاملاً وتوفر معلومات مفيدة للتنبؤ بالسلسلة الثانية.  يستخدم الكود التالي <i>مجموعة بيانات</i> تسمى <i>ChickEgg كتوضيح</i> .  تحتوي مجموعة البيانات على عمودين ، عدد الدجاج وعدد البيض ، مع طابع زمني: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(lmtest) data(ChickEgg) dim(ChickEgg)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">[1] 54 2</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">ChickEgg[1:5,]</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">chicken egg [1,] 468491 3581 [2,] 449743 3532 [3,] 436815 3327 [4,] 444523 3255 [5,] 433937 3156</code> </pre> <br>  السؤال هو ، هل يمكننا استخدام عدد البيض هذا العام للتنبؤ بعدد الدجاج في العام المقبل؟ <br><br>  إذا كان الأمر كذلك ، فسيكون عدد الدجاج هو سبب جرانجر لعدد البيض.  إذا لم يكن الأمر كذلك ، فنحن نقول أن عدد الدجاجات ليس سببًا في جرانجر لعدد البيض.  إليك الرمز المناسب: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(lmtest) data(ChickEgg) grangertest(chicken~egg, order = 3, data = ChickEgg)</code> </pre> <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: chicken ~ Lags(chicken, 1:3) + Lags(egg, 1:3) Model 2: chicken ~ Lags(chicken, 1:3) Res.Df Df F Pr(&gt;F) 1 44 2 47 -3 5.405 0.002966 ** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  في النموذج 1 ، نحاول استخدام تباطؤ الفراخ بالإضافة إلى تباطؤ البيض لشرح عدد الفراخ. <br><br>  لأن  قيمة <b>P</b> صغيرة جدًا (وهي مهمة عند 0.01) ، نقول أن عدد البيض هو سبب Granger لعدد الدجاج. <br><br>  يوضح الاختبار التالي أنه لا يمكن استخدام بيانات الدجاج للتنبؤ بالفترة التالية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">grangertest(egg~chicken, order = 3, data = ChickEgg)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: egg ~ Lags(egg, 1:3) + Lags(chicken, 1:3) Model 2: egg ~ Lags(egg, 1:3) Res.Df Df F Pr(&gt;F) 1 44 2 47 -3 0.5916 0.6238</code> </pre><br>  في المثال التالي ، نتحقق من ربحية IBM و S &amp; P500 من أجل معرفة أنها سبب Granger لسبب آخر. <br><br>  أولاً ، نحدد دالة العائد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">ret_f&lt;-<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(x,ticker=<span class="hljs-string"><span class="hljs-string">""</span></span>){ n&lt;-nrow(x) p&lt;-x[,6] ret&lt;-p[2:n]/p[1:(n-1)]-1 output&lt;-data.frame(x[2:n,1],ret) name&lt;-paste(<span class="hljs-string"><span class="hljs-string">"RET_"</span></span>,toupper(ticker),sep=<span class="hljs-string"><span class="hljs-string">''</span></span>) colnames(output)&lt;-c(<span class="hljs-string"><span class="hljs-string">"DATE"</span></span>,name) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span>(output) }</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">&gt;x&lt;-read.csv(<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/data/ibmDaily.csv"</span></span>,header=T) ibmRet&lt;-ret_f(x,<span class="hljs-string"><span class="hljs-string">"ibm"</span></span>) x&lt;-read.csv(<span class="hljs-string"><span class="hljs-string">"http://canisius.edu/~yany/data/^gspcDaily.csv"</span></span>,header=T) mktRet&lt;-ret_f(x,<span class="hljs-string"><span class="hljs-string">"mkt"</span></span>) final&lt;-merge(ibmRet,mktRet) head(final)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs"> DATE RET_IBM RET_MKT 1 1962-01-03 0.008742545 0.0023956877 2 1962-01-04 -0.009965497 -0.0068887673 3 1962-01-05 -0.019694350 -0.0138730891 4 1962-01-08 -0.018750380 -0.0077519519 5 1962-01-09 0.011829467 0.0004340133 6 1962-01-10 0.001798526 -0.0027476933</code> </pre><br>  الآن يمكن استدعاء الوظيفة بقيم الإدخال.  الهدف من البرنامج هو اختبار ما إذا كان يمكننا استخدام تباطؤ السوق لشرح ربحية IBM.  بنفس الطريقة ، نتحقق من شرح تأخر IBM في عائدات السوق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">library(lmtest) grangertest(RET_IBM ~ RET_MKT, order = 1, data =final)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: RET_IBM ~ Lags(RET_IBM, 1:1) + Lags(RET_MKT, 1:1) Model 2: RET_IBM ~ Lags(RET_IBM, 1:1) Res.Df Df F Pr(&gt;F) 1 14149 2 14150 -1 24.002 9.729e-07 *** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  أظهرت النتائج أنه يمكن استخدام S &amp; P500 لشرح ربحية IBM للفترة التالية ، حيث أنها ذات دلالة إحصائية عند 0.1٪.  سيتحقق الكود التالي لمعرفة ما إذا كان تأخر IBM يشرح التغيير في S &amp; P500: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">grangertest(RET_MKT ~ RET_IBM, order = 1, data =final)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">Granger causality <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Model 1: RET_MKT ~ Lags(RET_MKT, 1:1) + Lags(RET_IBM, 1:1) Model 2: RET_MKT ~ Lags(RET_MKT, 1:1) Res.Df Df F Pr(&gt;F) 1 14149 2 14150 -1 7.5378 0.006049 ** --- Signif. codes: 0 <span class="hljs-string"><span class="hljs-string">'***'</span></span> 0.001 <span class="hljs-string"><span class="hljs-string">'**'</span></span> 0.01 <span class="hljs-string"><span class="hljs-string">'*'</span></span> 0.05 <span class="hljs-string"><span class="hljs-string">'.'</span></span> 0.1 <span class="hljs-string"><span class="hljs-string">' '</span></span> 1</code> </pre><br>  تشير النتيجة إلى أنه خلال هذه الفترة ، يمكن استخدام عوائد IBM لشرح S &amp; P500 من الفترة التالية. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar428321/">https://habr.com/ru/post/ar428321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar428307/index.html">جافا تشالنجرز # 1: طريقة التحميل الزائد في JVM</a></li>
<li><a href="../ar428311/index.html">TrustZone: نظام تشغيل موثوق به وتطبيقاته</a></li>
<li><a href="../ar428313/index.html">يقوم Telegram على نظام MacOS [من المفترض] بتخزين المراسلات محليًا في شكل يمكن الوصول إليه</a></li>
<li><a href="../ar428315/index.html">5 مخاوف من المطورين التي تغلبنا عليها</a></li>
<li><a href="../ar428317/index.html">رد فعل الخطافات - فوز أم خسارة؟</a></li>
<li><a href="../ar428327/index.html">ما الذي تبحث عنه: لائحة eIDAS الإلكترونية للتعريف الإلكتروني</a></li>
<li><a href="../ar428329/index.html">تدريب التعزيز: تحليل ألعاب الفيديو</a></li>
<li><a href="../ar428333/index.html">نتائج RAIF Hackathon AI Hackathon لعام 2018</a></li>
<li><a href="../ar428335/index.html">تحديث اختصار سيري</a></li>
<li><a href="../ar428337/index.html">مسلية JavaScript: بدون أقواس متعرجة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>