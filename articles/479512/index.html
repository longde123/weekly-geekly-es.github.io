<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游쮫릞 久걾잺 游돜游낖 MVCC en PostgreSQL-4. Instant치neas 游녡游낖 游볹 仇勇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu칠s de haber discutido los problemas de aislamiento y haber hecho una digresi칩n sobre la estructura de datos de bajo nivel , la 칰ltima vez explora...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-4. Instant치neas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Despu칠s de haber discutido los problemas de <a href="https://habr.com/ru/company/postgrespro/blog/467437/">aislamiento</a> y haber hecho una digresi칩n sobre la <a href="https://habr.com/ru/company/postgrespro/blog/469087/">estructura de datos de bajo nivel</a> , la 칰ltima vez exploramos las <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versiones de fila</a> y observamos c칩mo las diferentes operaciones cambiaron los campos de encabezado de tupla. <br><br>  Ahora veremos c칩mo se obtienen instant치neas de datos consistentes de las tuplas. <br><br><h1>  쯈u칠 es una instant치nea de datos? </h1><br>  Las p치ginas de datos pueden contener f칤sicamente varias versiones de la misma fila.  Pero cada transacci칩n debe ver solo una versi칩n (o ninguna) de cada fila, de modo que todas ellas constituyan una imagen coherente de los datos (en el sentido de ACID) a partir de un cierto punto en el tiempo. <br><br>  El aislamiento en PosgreSQL se basa en instant치neas: cada transacci칩n funciona con su propia instant치nea de datos, que "contiene" datos que se confirmaron antes del momento en que se cre칩 la instant치nea y no "contiene" datos que a칰n no se confirmaron en ese momento.  Ya hemos <a href="https://habr.com/ru/company/postgrespro/blog/467437/">visto</a> que, aunque el aislamiento resultante parece m치s estricto de lo requerido por el est치ndar, todav칤a tiene anomal칤as. <br><a name="habracut"></a><br>  En el nivel de aislamiento de lectura confirmada, se crea una instant치nea al comienzo de cada declaraci칩n de transacci칩n.  Esta instant치nea est치 activa mientras se realiza la declaraci칩n.  En la figura, el momento en que se cre칩 la instant치nea (que, como recordamos, est치 determinada por el ID de la transacci칩n) se muestra en azul. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  En los niveles de Lectura repetible y Serializable, la instant치nea se crea una vez, al comienzo de la primera declaraci칩n de transacci칩n.  Dicha instant치nea permanece activa hasta el final de la transacci칩n. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilidad de tuplas en una instant치nea </h1><br><h2>  Reglas de visibilidad </h2><br>  Una instant치nea ciertamente no es una copia f칤sica de todas las tuplas necesarias.  Una instant치nea est치 realmente especificada por varios n칰meros, y la visibilidad de las tuplas en una instant치nea est치 determinada por las reglas. <br><br>  Si una tupla ser치 visible o no en una instant치nea depende de dos campos en el encabezado, a saber, <code>xmin</code> y <code>xmax</code> , es decir, los ID de las transacciones que crearon y eliminaron la tupla.  Los intervalos como este no se superponen y, por lo tanto, no m치s de una versi칩n representa una fila en cada instant치nea. <br><br>  Las reglas de visibilidad exactas son bastante complicadas y tienen en cuenta muchos casos diferentes y extremos. <br><blockquote>  Puede asegurarse f치cilmente de eso mirando src / backend / utils / time / tqual.c (en la versi칩n 12, la verificaci칩n se movi칩 a src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Para simplificar, podemos decir que una tupla es visible cuando en la instant치nea, los cambios realizados por la transacci칩n <code>xmin</code> son visibles, mientras que los realizados por la transacci칩n <code>xmax</code> no lo son (en otras palabras, ya est치 claro que la tupla fue creada, pero a칰n no est치 claro si se elimin칩). <br><br>  Con respecto a una transacci칩n, sus cambios son visibles en la instant치nea, ya sea si esa misma transacci칩n cre칩 la instant치nea (s칤 ve sus propios cambios a칰n no confirmados) o si la transacci칩n se confirm칩 antes de que se creara la instant치nea. <br><br>  Podemos representar gr치ficamente las transacciones por segmentos (desde la hora de inicio hasta la hora de confirmaci칩n): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Aqu칤: <br><br><ul><li>  Los cambios de la transacci칩n 2 ser치n visibles ya que se complet칩 antes de que se creara la instant치nea. </li><li>  Los cambios de la transacci칩n 1 no ser치n visibles ya que estaba activa en el momento en que se cre칩 la instant치nea. </li><li>  Los cambios de la transacci칩n 3 no ser치n visibles desde que comenz칩 despu칠s de que se cre칩 la instant치nea (independientemente de si se complet칩 o no). </li></ul><br>  Desafortunadamente, el sistema desconoce el tiempo de confirmaci칩n de las transacciones.  Solo se conoce su hora de inicio (que est치 determinada por el ID de la transacci칩n y marcada con una l칤nea discontinua en las figuras anteriores), pero el evento de finalizaci칩n no se escribe en ninguna parte. <br><br>  Todo lo que podemos hacer es averiguar el estado <em>actual</em> de las transacciones en la creaci칩n de la instant치nea.  Esta informaci칩n est치 disponible en la memoria compartida del servidor, en la estructura ProcArray, que contiene la lista de todas las sesiones activas y sus transacciones. <br><br>  Sin embargo, no podremos determinar si existe una transacci칩n activa en el momento en que se cre칩 la instant치nea.  Por lo tanto, una instant치nea tiene que almacenar una lista de todas las transacciones activas actuales. <br><br>  De lo anterior se deduce que en PostgreSQL, no es posible crear una instant치nea que muestre datos consistentes a partir de cierto tiempo hacia atr치s, <em>incluso si</em> todas las tuplas necesarias est치n disponibles en las p치ginas de la tabla.  A menudo surge una pregunta de por qu칠 PostgreSQL carece de consultas retrospectivas (o temporales; o flashback, como las llama Oracle), y esta es una de las razones. <br><blockquote>  Algo gracioso es que esta funcionalidad estuvo disponible por primera vez, pero luego se elimin칩 del DBMS.  Puedes leer sobre esto en el <a href="https://arxiv.org/pdf/1901.01973.pdf">art칤culo de Joseph M. Hellerstein</a> . <br></blockquote><br>  Entonces, la instant치nea est치 determinada por varios par치metros: <br><br><ul><li>  En el momento en que se cre칩 la instant치nea, m치s exactamente, el ID de la pr칩xima transacci칩n, a칰n no disponible en el sistema ( <code>snapshot.xmax</code> ). </li><li>  La lista de transacciones activas (en progreso) en el momento en que se cre칩 la <code>snapshot.xip</code> ( <code>snapshot.xip</code> ). </li></ul><br>  Por conveniencia y optimizaci칩n, el ID de la primera transacci칩n activa tambi칠n se almacena ( <code>snapshot.xmin</code> ).  Este valor tiene un sentido importante, que se discutir치 a continuaci칩n. <br><br>  Sin embargo, la instant치nea tambi칠n almacena algunos par치metros m치s, que no son importantes para nosotros. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Ejemplo </h2><br>  Para comprender c칩mo la instant치nea determina la visibilidad, reproduzcamos el ejemplo anterior con tres transacciones.  La tabla tendr치 tres filas, donde: <br><br><ul><li>  El primero fue agregado por una transacci칩n que comenz칩 antes de la creaci칩n de la instant치nea pero que se complet칩 despu칠s. </li><li>  El segundo fue agregado por una transacci칩n que comenz칩 y se complet칩 antes de la creaci칩n de la instant치nea. </li><li>  El tercero se agreg칩 despu칠s de la creaci칩n de la instant치nea. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  La primera transacci칩n (a칰n no completada): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  La segunda transacci칩n (completada antes de que se creara la instant치nea): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Crear una instant치nea en una transacci칩n en otra sesi칩n. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Confirmar la primera transacci칩n despu칠s de que se cre칩 la instant치nea: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y la tercera transacci칩n (apareci칩 despu칠s de que se cre칩 la instant치nea): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Evidentemente, solo una fila sigue siendo visible en nuestra instant치nea: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  La pregunta es c칩mo Postgres entiende esto. <br><br>  Todo est치 determinado por la instant치nea.  Ve치moslo: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Aqu칤 se enumeran <code>snapshot.xmin</code> , <code>snapshot.xmax</code> y <code>snapshot.xip</code> , delimitados por dos puntos ( <code>snapshot.xip</code> es un n칰mero en este caso, pero en general es una lista). <br><br>  De acuerdo con las reglas anteriores, en la instant치nea, esos cambios deben ser visibles que fueron realizados por transacciones con ID <code>xid</code> modo que <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> excepto aquellos que est치n en la lista <code>snapshot.xip</code> .  Veamos todas las filas de la tabla (en la nueva instant치nea): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  La primera fila no es visible: fue creada por una transacci칩n que est치 en la lista de transacciones activas ( <code>xip</code> ). <br>  La segunda fila es visible: fue creada por una transacci칩n que est치 en el rango de instant치neas. <br>  La tercera fila no es visible: fue creada por una transacci칩n que est치 fuera del rango de la instant치nea. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Cambios propios de la transacci칩n. </h1><br>  Determinar la visibilidad de los propios cambios de la transacci칩n complica un poco la situaci칩n.  En este caso, puede ser necesario ver solo una parte de dichos cambios.  Por ejemplo: en cualquier nivel de aislamiento, un cursor abierto en un momento determinado no debe ver los cambios realizados m치s tarde. <br><br>  Para este fin, un encabezado de tupla tiene un campo especial (representado en las pseudocolumnas <code>cmin</code> y <code>cmax</code> ), que muestra el n칰mero de orden dentro de la transacci칩n.  <code>cmin</code> es el n칰mero para la inserci칩n, y <code>cmax</code> - para la eliminaci칩n, pero para ahorrar espacio en el encabezado de la tupla, este es en realidad un campo en lugar de dos diferentes.  Se supone que una transacci칩n inserta y elimina con poca frecuencia la misma fila. <br><br>  Pero si esto sucede, se inserta un ID de comando combinado especial ( <code>combocid</code> ) en el mismo campo, y el proceso de fondo recuerda los <code>cmin</code> y <code>cmax</code> reales para este <code>combocid</code> .  Pero esto es completamente ex칩tico. <br><br>  Aqu칤 hay un ejemplo simple.  Comencemos una transacci칩n y agreguemos una fila a la tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Vamos a mostrar el contenido de la tabla, junto con el campo <code>cmin</code> (pero solo para las filas agregadas por la transacci칩n; para otros no tiene sentido): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Ahora abrimos un cursor para una consulta que devuelve el n칰mero de filas en la tabla. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Y despu칠s de eso agregamos otra fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  La consulta devuelve 4: la fila agregada despu칠s de abrir el cursor no entra en la instant치nea de datos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Por qu칠  Porque la instant치nea solo tiene en cuenta las tuplas con <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizonte de eventos </h1><br>  El ID de la primera transacci칩n activa ( <code>snapshot.xmin</code> ) tiene un sentido importante: determina el "horizonte de eventos" de la transacci칩n.  Es decir, m치s all치 de su horizonte, la transacci칩n siempre ve solo versiones de fila actualizadas. <br><br>  Realmente, una versi칩n de fila desactualizada (inactiva) debe ser visible solo cuando la actualizada fue creada por una transacci칩n a칰n no completada y, por lo tanto, a칰n no es visible.  Pero todas las transacciones "m치s all치 del horizonte" se completan con seguridad. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Puede ver el horizonte de transacciones en el cat치logo del sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Tambi칠n podemos definir el horizonte a nivel de la base de datos.  Para hacer esto, necesitamos tomar todas las instant치neas activas y encontrar las <code>xmin</code> m치s <code>xmin</code> entre ellas.  Y definir치 el horizonte, m치s all치 del cual las tuplas muertas en la base de datos nunca ser치n visibles para ninguna transacci칩n.  <em>Tales tuplas se pueden aspirar</em> , y esta es exactamente la raz칩n por la cual el concepto de horizonte es tan importante desde un punto de vista pr치ctico. <br><br>  Si una determinada transacci칩n retiene una instant치nea durante mucho tiempo, tambi칠n mantendr치 el horizonte de la base de datos.  Adem치s, solo la existencia de una transacci칩n incompleta mantendr치 el horizonte incluso si la transacci칩n en s칤 no contiene la instant치nea. <br><br>  Y esto significa que las tuplas muertas en el DB no se pueden aspirar.  Adem치s, es posible que una transacci칩n de "larga duraci칩n" no se cruce con los datos con otras transacciones, pero esto realmente no importa ya que todos comparten un horizonte de base de datos. <br><br>  Si ahora hacemos que un segmento represente instant치neas (desde <code>snapshot.xmin</code> a <code>snapshot.xmax</code> ) en lugar de transacciones, podemos visualizar la situaci칩n de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  En esta figura, la instant치nea m치s baja corresponde a una transacci칩n incompleta, y en las otras instant치neas, <code>snapshot.xmin</code> no puede ser mayor que el ID de la transacci칩n. <br><br>  En nuestro ejemplo, la transacci칩n se inici칩 con el nivel de aislamiento de lectura confirmada.  Aunque no tiene ninguna instant치nea de datos activa, sigue manteniendo el horizonte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Y solo despu칠s de la finalizaci칩n de la transacci칩n, el horizonte avanza, lo que permite aspirar las tuplas muertas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  En el caso de que la situaci칩n descrita realmente cause problemas y no haya forma de solucionarlo a nivel de aplicaci칩n, hay dos par치metros disponibles a partir de la versi칩n 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> determina la vida 칰til m치xima de la instant치nea.  Cuando transcurra este tiempo, el servidor ser치 elegible para aspirar tuplas muertas, y si una transacci칩n de "larga duraci칩n" a칰n las necesita, obtendr치 un error "instant치nea demasiado antigua". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> determina la vida 칰til m치xima de una transacci칩n inactiva.  Cuando transcurre este tiempo, la transacci칩n se cancela. </li></ul><br><h1>  Exportaci칩n de instant치neas </h1><br>  A veces surgen situaciones en las que se debe garantizar que varias transacciones concurrentes vean los mismos datos.  Un ejemplo es una utilidad <code>pg_dump</code> , que puede funcionar en modo paralelo: todos los procesos de trabajo deben ver la base de datos en el mismo estado para que la copia de seguridad sea coherente. <br><br>  Por supuesto, no podemos confiar en la creencia de que las transacciones ver치n los mismos datos solo porque se iniciaron "simult치neamente".  Para este fin, la exportaci칩n e importaci칩n de una instant치nea est치n disponibles. <br><br>  La funci칩n <code>pg_export_snapshot</code> devuelve el ID de la instant치nea, que se puede pasar a otra transacci칩n (usando herramientas fuera del DBMS). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  La otra transacci칩n puede importar la instant치nea utilizando el comando SET TRANSACTION SNAPSHOT antes de realizar su primera consulta.  El nivel de aislamiento de lectura repetible o serializable tambi칠n debe especificarse antes, ya que en el nivel de confirmaci칩n de lectura, las declaraciones utilizar치n sus propias instant치neas. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  La segunda transacci칩n ahora funcionar치 con la instant치nea de la primera y, por lo tanto, ver치 tres filas (en lugar de cero): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  La duraci칩n de una instant치nea exportada es la misma que la duraci칩n de la transacci칩n de exportaci칩n. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479512/">https://habr.com/ru/post/479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479498/index.html">C칩mo el tiempo lineal se convierte en Windows en O (n)</a></li>
<li><a href="../479502/index.html">쮺칩mo sobrevivir a la edad de hielo m치s severa en la historia de la Tierra?</a></li>
<li><a href="../479504/index.html">Cree un cliente ligero RDP basado en Raspberry Pi</a></li>
<li><a href="../479508/index.html">Antipatterns PostgreSQL: uniones da침inas y OR</a></li>
<li><a href="../479510/index.html">Revisi칩n de PocketBook X: un enorme lector de 10.3 pulgadas con una pantalla E Ink Carta Mobius y una carcasa de metal</a></li>
<li><a href="../479514/index.html">Privacidad por dise침o y privacidad por defecto (protecci칩n de datos dise침ada y privacidad predeterminada por GDPR)</a></li>
<li><a href="../479516/index.html">쯈u칠 es la entrop칤a en el software y c칩mo gestionarla?</a></li>
<li><a href="../479518/index.html">La comunicaci칩n dentro de un equipo remoto es nuestra experiencia.</a></li>
<li><a href="../479522/index.html">Editorial Peter. Venta de invierno</a></li>
<li><a href="../479524/index.html">Servicio de restauraci칩n activa o la historia de un proyecto industrial en Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>