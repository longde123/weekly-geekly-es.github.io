<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏻 ⛈️ 🕺🏼 MVCC en PostgreSQL-4. Instantáneas 👆🏼 🥦 ❄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Después de haber discutido los problemas de aislamiento y haber hecho una digresión sobre la estructura de datos de bajo nivel , la última vez explora...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC en PostgreSQL-4. Instantáneas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/">  Después de haber discutido los problemas de <a href="https://habr.com/ru/company/postgrespro/blog/467437/">aislamiento</a> y haber hecho una digresión sobre la <a href="https://habr.com/ru/company/postgrespro/blog/469087/">estructura de datos de bajo nivel</a> , la última vez exploramos las <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versiones de fila</a> y observamos cómo las diferentes operaciones cambiaron los campos de encabezado de tupla. <br><br>  Ahora veremos cómo se obtienen instantáneas de datos consistentes de las tuplas. <br><br><h1>  ¿Qué es una instantánea de datos? </h1><br>  Las páginas de datos pueden contener físicamente varias versiones de la misma fila.  Pero cada transacción debe ver solo una versión (o ninguna) de cada fila, de modo que todas ellas constituyan una imagen coherente de los datos (en el sentido de ACID) a partir de un cierto punto en el tiempo. <br><br>  El aislamiento en PosgreSQL se basa en instantáneas: cada transacción funciona con su propia instantánea de datos, que "contiene" datos que se confirmaron antes del momento en que se creó la instantánea y no "contiene" datos que aún no se confirmaron en ese momento.  Ya hemos <a href="https://habr.com/ru/company/postgrespro/blog/467437/">visto</a> que, aunque el aislamiento resultante parece más estricto de lo requerido por el estándar, todavía tiene anomalías. <br><a name="habracut"></a><br>  En el nivel de aislamiento de lectura confirmada, se crea una instantánea al comienzo de cada declaración de transacción.  Esta instantánea está activa mientras se realiza la declaración.  En la figura, el momento en que se creó la instantánea (que, como recordamos, está determinada por el ID de la transacción) se muestra en azul. <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br>  En los niveles de Lectura repetible y Serializable, la instantánea se crea una vez, al comienzo de la primera declaración de transacción.  Dicha instantánea permanece activa hasta el final de la transacción. <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1>  Visibilidad de tuplas en una instantánea </h1><br><h2>  Reglas de visibilidad </h2><br>  Una instantánea ciertamente no es una copia física de todas las tuplas necesarias.  Una instantánea está realmente especificada por varios números, y la visibilidad de las tuplas en una instantánea está determinada por las reglas. <br><br>  Si una tupla será visible o no en una instantánea depende de dos campos en el encabezado, a saber, <code>xmin</code> y <code>xmax</code> , es decir, los ID de las transacciones que crearon y eliminaron la tupla.  Los intervalos como este no se superponen y, por lo tanto, no más de una versión representa una fila en cada instantánea. <br><br>  Las reglas de visibilidad exactas son bastante complicadas y tienen en cuenta muchos casos diferentes y extremos. <br><blockquote>  Puede asegurarse fácilmente de eso mirando src / backend / utils / time / tqual.c (en la versión 12, la verificación se movió a src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Para simplificar, podemos decir que una tupla es visible cuando en la instantánea, los cambios realizados por la transacción <code>xmin</code> son visibles, mientras que los realizados por la transacción <code>xmax</code> no lo son (en otras palabras, ya está claro que la tupla fue creada, pero aún no está claro si se eliminó). <br><br>  Con respecto a una transacción, sus cambios son visibles en la instantánea, ya sea si esa misma transacción creó la instantánea (sí ve sus propios cambios aún no confirmados) o si la transacción se confirmó antes de que se creara la instantánea. <br><br>  Podemos representar gráficamente las transacciones por segmentos (desde la hora de inicio hasta la hora de confirmación): <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br>  Aquí: <br><br><ul><li>  Los cambios de la transacción 2 serán visibles ya que se completó antes de que se creara la instantánea. </li><li>  Los cambios de la transacción 1 no serán visibles ya que estaba activa en el momento en que se creó la instantánea. </li><li>  Los cambios de la transacción 3 no serán visibles desde que comenzó después de que se creó la instantánea (independientemente de si se completó o no). </li></ul><br>  Desafortunadamente, el sistema desconoce el tiempo de confirmación de las transacciones.  Solo se conoce su hora de inicio (que está determinada por el ID de la transacción y marcada con una línea discontinua en las figuras anteriores), pero el evento de finalización no se escribe en ninguna parte. <br><br>  Todo lo que podemos hacer es averiguar el estado <em>actual</em> de las transacciones en la creación de la instantánea.  Esta información está disponible en la memoria compartida del servidor, en la estructura ProcArray, que contiene la lista de todas las sesiones activas y sus transacciones. <br><br>  Sin embargo, no podremos determinar si existe una transacción activa en el momento en que se creó la instantánea.  Por lo tanto, una instantánea tiene que almacenar una lista de todas las transacciones activas actuales. <br><br>  De lo anterior se deduce que en PostgreSQL, no es posible crear una instantánea que muestre datos consistentes a partir de cierto tiempo hacia atrás, <em>incluso si</em> todas las tuplas necesarias están disponibles en las páginas de la tabla.  A menudo surge una pregunta de por qué PostgreSQL carece de consultas retrospectivas (o temporales; o flashback, como las llama Oracle), y esta es una de las razones. <br><blockquote>  Algo gracioso es que esta funcionalidad estuvo disponible por primera vez, pero luego se eliminó del DBMS.  Puedes leer sobre esto en el <a href="https://arxiv.org/pdf/1901.01973.pdf">artículo de Joseph M. Hellerstein</a> . <br></blockquote><br>  Entonces, la instantánea está determinada por varios parámetros: <br><br><ul><li>  En el momento en que se creó la instantánea, más exactamente, el ID de la próxima transacción, aún no disponible en el sistema ( <code>snapshot.xmax</code> ). </li><li>  La lista de transacciones activas (en progreso) en el momento en que se creó la <code>snapshot.xip</code> ( <code>snapshot.xip</code> ). </li></ul><br>  Por conveniencia y optimización, el ID de la primera transacción activa también se almacena ( <code>snapshot.xmin</code> ).  Este valor tiene un sentido importante, que se discutirá a continuación. <br><br>  Sin embargo, la instantánea también almacena algunos parámetros más, que no son importantes para nosotros. <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2>  Ejemplo </h2><br>  Para comprender cómo la instantánea determina la visibilidad, reproduzcamos el ejemplo anterior con tres transacciones.  La tabla tendrá tres filas, donde: <br><br><ul><li>  El primero fue agregado por una transacción que comenzó antes de la creación de la instantánea pero que se completó después. </li><li>  El segundo fue agregado por una transacción que comenzó y se completó antes de la creación de la instantánea. </li><li>  El tercero se agregó después de la creación de la instantánea. </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br>  La primera transacción (aún no completada): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  La segunda transacción (completada antes de que se creara la instantánea): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Crear una instantánea en una transacción en otra sesión. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Confirmar la primera transacción después de que se creó la instantánea: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Y la tercera transacción (apareció después de que se creó la instantánea): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Evidentemente, solo una fila sigue siendo visible en nuestra instantánea: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  La pregunta es cómo Postgres entiende esto. <br><br>  Todo está determinado por la instantánea.  Veámoslo: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Aquí se enumeran <code>snapshot.xmin</code> , <code>snapshot.xmax</code> y <code>snapshot.xip</code> , delimitados por dos puntos ( <code>snapshot.xip</code> es un número en este caso, pero en general es una lista). <br><br>  De acuerdo con las reglas anteriores, en la instantánea, esos cambios deben ser visibles que fueron realizados por transacciones con ID <code>xid</code> modo que <code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code> excepto aquellos que están en la lista <code>snapshot.xip</code> .  Veamos todas las filas de la tabla (en la nueva instantánea): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  La primera fila no es visible: fue creada por una transacción que está en la lista de transacciones activas ( <code>xip</code> ). <br>  La segunda fila es visible: fue creada por una transacción que está en el rango de instantáneas. <br>  La tercera fila no es visible: fue creada por una transacción que está fuera del rango de la instantánea. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Cambios propios de la transacción. </h1><br>  Determinar la visibilidad de los propios cambios de la transacción complica un poco la situación.  En este caso, puede ser necesario ver solo una parte de dichos cambios.  Por ejemplo: en cualquier nivel de aislamiento, un cursor abierto en un momento determinado no debe ver los cambios realizados más tarde. <br><br>  Para este fin, un encabezado de tupla tiene un campo especial (representado en las pseudocolumnas <code>cmin</code> y <code>cmax</code> ), que muestra el número de orden dentro de la transacción.  <code>cmin</code> es el número para la inserción, y <code>cmax</code> - para la eliminación, pero para ahorrar espacio en el encabezado de la tupla, este es en realidad un campo en lugar de dos diferentes.  Se supone que una transacción inserta y elimina con poca frecuencia la misma fila. <br><br>  Pero si esto sucede, se inserta un ID de comando combinado especial ( <code>combocid</code> ) en el mismo campo, y el proceso de fondo recuerda los <code>cmin</code> y <code>cmax</code> reales para este <code>combocid</code> .  Pero esto es completamente exótico. <br><br>  Aquí hay un ejemplo simple.  Comencemos una transacción y agreguemos una fila a la tabla: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Vamos a mostrar el contenido de la tabla, junto con el campo <code>cmin</code> (pero solo para las filas agregadas por la transacción; para otros no tiene sentido): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Ahora abrimos un cursor para una consulta que devuelve el número de filas en la tabla. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Y después de eso agregamos otra fila: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  La consulta devuelve 4: la fila agregada después de abrir el cursor no entra en la instantánea de datos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Por qué  Porque la instantánea solo tiene en cuenta las tuplas con <code>cmin &lt; 1</code> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizonte de eventos </h1><br>  El ID de la primera transacción activa ( <code>snapshot.xmin</code> ) tiene un sentido importante: determina el "horizonte de eventos" de la transacción.  Es decir, más allá de su horizonte, la transacción siempre ve solo versiones de fila actualizadas. <br><br>  Realmente, una versión de fila desactualizada (inactiva) debe ser visible solo cuando la actualizada fue creada por una transacción aún no completada y, por lo tanto, aún no es visible.  Pero todas las transacciones "más allá del horizonte" se completan con seguridad. <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br>  Puede ver el horizonte de transacciones en el catálogo del sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  También podemos definir el horizonte a nivel de la base de datos.  Para hacer esto, necesitamos tomar todas las instantáneas activas y encontrar las <code>xmin</code> más <code>xmin</code> entre ellas.  Y definirá el horizonte, más allá del cual las tuplas muertas en la base de datos nunca serán visibles para ninguna transacción.  <em>Tales tuplas se pueden aspirar</em> , y esta es exactamente la razón por la cual el concepto de horizonte es tan importante desde un punto de vista práctico. <br><br>  Si una determinada transacción retiene una instantánea durante mucho tiempo, también mantendrá el horizonte de la base de datos.  Además, solo la existencia de una transacción incompleta mantendrá el horizonte incluso si la transacción en sí no contiene la instantánea. <br><br>  Y esto significa que las tuplas muertas en el DB no se pueden aspirar.  Además, es posible que una transacción de "larga duración" no se cruce con los datos con otras transacciones, pero esto realmente no importa ya que todos comparten un horizonte de base de datos. <br><br>  Si ahora hacemos que un segmento represente instantáneas (desde <code>snapshot.xmin</code> a <code>snapshot.xmax</code> ) en lugar de transacciones, podemos visualizar la situación de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br>  En esta figura, la instantánea más baja corresponde a una transacción incompleta, y en las otras instantáneas, <code>snapshot.xmin</code> no puede ser mayor que el ID de la transacción. <br><br>  En nuestro ejemplo, la transacción se inició con el nivel de aislamiento de lectura confirmada.  Aunque no tiene ninguna instantánea de datos activa, sigue manteniendo el horizonte: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Y solo después de la finalización de la transacción, el horizonte avanza, lo que permite aspirar las tuplas muertas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  En el caso de que la situación descrita realmente cause problemas y no haya forma de solucionarlo a nivel de aplicación, hay dos parámetros disponibles a partir de la versión 9.6: <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em> determina la vida útil máxima de la instantánea.  Cuando transcurra este tiempo, el servidor será elegible para aspirar tuplas muertas, y si una transacción de "larga duración" aún las necesita, obtendrá un error "instantánea demasiado antigua". </li><li>  <em><code>idle_in_transaction_session_timeout</code></em> determina la vida útil máxima de una transacción inactiva.  Cuando transcurre este tiempo, la transacción se cancela. </li></ul><br><h1>  Exportación de instantáneas </h1><br>  A veces surgen situaciones en las que se debe garantizar que varias transacciones concurrentes vean los mismos datos.  Un ejemplo es una utilidad <code>pg_dump</code> , que puede funcionar en modo paralelo: todos los procesos de trabajo deben ver la base de datos en el mismo estado para que la copia de seguridad sea coherente. <br><br>  Por supuesto, no podemos confiar en la creencia de que las transacciones verán los mismos datos solo porque se iniciaron "simultáneamente".  Para este fin, la exportación e importación de una instantánea están disponibles. <br><br>  La función <code>pg_export_snapshot</code> devuelve el ID de la instantánea, que se puede pasar a otra transacción (usando herramientas fuera del DBMS). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  La otra transacción puede importar la instantánea utilizando el comando SET TRANSACTION SNAPSHOT antes de realizar su primera consulta.  El nivel de aislamiento de lectura repetible o serializable también debe especificarse antes, ya que en el nivel de confirmación de lectura, las declaraciones utilizarán sus propias instantáneas. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  La segunda transacción ahora funcionará con la instantánea de la primera y, por lo tanto, verá tres filas (en lugar de cero): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  La duración de una instantánea exportada es la misma que la duración de la transacción de exportación. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479512/">https://habr.com/ru/post/479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479498/index.html">Cómo el tiempo lineal se convierte en Windows en O (n²)</a></li>
<li><a href="../479502/index.html">¿Cómo sobrevivir a la edad de hielo más severa en la historia de la Tierra?</a></li>
<li><a href="../479504/index.html">Cree un cliente ligero RDP basado en Raspberry Pi</a></li>
<li><a href="../479508/index.html">Antipatterns PostgreSQL: uniones dañinas y OR</a></li>
<li><a href="../479510/index.html">Revisión de PocketBook X: un enorme lector de 10.3 pulgadas con una pantalla E Ink Carta Mobius y una carcasa de metal</a></li>
<li><a href="../479514/index.html">Privacidad por diseño y privacidad por defecto (protección de datos diseñada y privacidad predeterminada por GDPR)</a></li>
<li><a href="../479516/index.html">¿Qué es la entropía en el software y cómo gestionarla?</a></li>
<li><a href="../479518/index.html">La comunicación dentro de un equipo remoto es nuestra experiencia.</a></li>
<li><a href="../479522/index.html">Editorial Peter. Venta de invierno</a></li>
<li><a href="../479524/index.html">Servicio de restauración activa o la historia de un proyecto industrial en Innopolis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>