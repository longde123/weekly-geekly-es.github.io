<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèº ‚úäüèª üçπ Shader in Unity schreiben. GrabPass, PerRendererData üéê üìü üßñüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Ich m√∂chte meine Erfahrungen mit dem Schreiben von Shadern in Unity teilen. Beginnen wir mit dem Displacement / Refraction-Shader in 2D, betrac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shader in Unity schreiben. GrabPass, PerRendererData</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427357/">  Hallo!  Ich m√∂chte meine Erfahrungen mit dem Schreiben von Shadern in Unity teilen.  Beginnen wir mit dem Displacement / Refraction-Shader in 2D, betrachten wir die zum Schreiben verwendete Funktionalit√§t (GrabPass, PerRendererData) und achten wir auch auf die Probleme, die notwendigerweise auftreten werden. <br><br>  Die Informationen sind n√ºtzlich f√ºr diejenigen, die eine allgemeine Vorstellung von Shadern haben und versucht haben, diese zu erstellen, aber nicht mit den Funktionen von Unity vertraut sind und nicht wissen, an welche Seite sie sich wenden sollen.  Schauen Sie mal, vielleicht hilft Ihnen meine Erfahrung dabei, es herauszufinden. <br><br><img src="https://habrastorage.org/webt/7p/cy/pr/7pcyprnckvacvecylqvlu-8g68m.gif"><br><a name="habracut"></a><br>  Dies ist das Ergebnis, das wir erreichen wollen. <br><br><img src="https://habrastorage.org/webt/u5/wo/ll/u5woll2fo6nibjmd0lrgvszxvxk.gif" alt="Bild"><br><br><h2>  Vorbereitung </h2><br>  Erstellen Sie zun√§chst einen Shader, der einfach das angegebene Sprite zeichnet.  Er wird unsere Basis f√ºr weitere Manipulationen sein.  Es wird etwas hinzugef√ºgt, etwas im Gegenteil wird gel√∂scht.  Es unterscheidet sich vom Standard ‚ÄûSprites-Default‚Äú durch das Fehlen einiger Tags und Aktionen, die das Ergebnis nicht beeinflussen. <br><br><div class="spoiler">  <b class="spoiler_title">Shader-Code zum Rendern von Sprite</b> <div class="spoiler_text"><pre><code class="hljs pgsql">Shader "Displacement/Displacement_Wave" { Properties { [PerRendererData] _MainTex ("Main Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color ("Color" , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { "RenderType" = "Transparent" "Queue" = "Transparent" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; fixed4 _Color; sampler2D _MainTex; v2f vert (appdata v) { v2f o; o.uv = v.uv; o.color = v.color; o.vertex = UnityObjectToClipPos(v.vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { fixed4 texColor = tex2D(_MainTex, i.uv)*i.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texColor; } ENDCG } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Sprite zum Anzeigen</b> <div class="spoiler_text">  Der Hintergrund ist tats√§chlich transparent und absichtlich abgedunkelt. <br><br><img src="https://habrastorage.org/webt/7l/yu/in/7lyuingedtk8frmquebh2m0kgdy.jpeg" alt="Bild"><br></div></div><br>  Das resultierende Werkst√ºck. <br><br><img src="https://habrastorage.org/webt/yl/ir/9i/ylir9i7bz4ibkkbhag61q8v95ak.jpeg" alt="Bild"><br><br><h2>  Grabpass </h2><br>  Jetzt ist es unsere Aufgabe, √Ñnderungen am aktuellen Bild auf dem Bildschirm vorzunehmen, und daf√ºr m√ºssen wir ein Bild erhalten.  Und die <i>GrabPass-</i> Passage wird uns dabei helfen.  Diese Passage erfasst das Bildschirmbild in der <i>_GrabTexture-</i> Textur.  Die Textur enth√§lt nur das, was gezeichnet wurde, bevor unser Objekt mit diesem Shader gerendert wurde. <br><br>  Zus√§tzlich zur Textur selbst ben√∂tigen wir die Koordinaten des Scans, um die Pixelfarbe daraus zu erhalten.  F√ºgen Sie dazu den Fragment-Shader-Daten zus√§tzliche Texturkoordinaten hinzu.  Diese Koordinaten werden nicht normalisiert (Werte liegen nicht im Bereich von 0 bis 1) und beschreiben die Position eines Punktes im Raum der Kamera (Projektion). <br><br><pre> <code class="hljs pgsql">struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; <span class="hljs-type"><span class="hljs-type">float4</span></span> grabPos : TEXCOORD1; };</code> </pre> <br>  Und im Vertex-Shader f√ºllen Sie sie. <br><br><pre> <code class="hljs">o.grabPos = ComputeGrabScreenPos (o.vertex);</code> </pre> <br>  Um die Farbe von <i>_GrabTexture zu erhalten</i> , k√∂nnen wir die folgende Methode verwenden, wenn wir nicht normalisierte Koordinaten verwenden <br><br><pre> <code class="hljs lisp">tex2Dproj(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos)</code> </pre> <br>  Wir werden jedoch eine andere Methode verwenden und die Koordinaten selbst normalisieren, indem wir die Perspektiventeilung verwenden, d. H.  Aufteilung aller anderen in die w-Komponente. <br><br><pre> <code class="hljs lisp">tex2D(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy/i.grabPos.w)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">w Komponente</b> <div class="spoiler_text">  Die Unterteilung in eine w-Komponente ist nur bei Verwendung der Perspektive erforderlich. Bei der orthografischen Projektion ist dies immer 1. Tats√§chlich speichert <b>w</b> den Wert der Entfernung und zeigt auf die Kamera.  Es ist jedoch nicht die Tiefe - <b>z</b> , deren Wert im Bereich von 0 bis 1 liegen sollte. Die Arbeit mit der Tiefe verdient ein separates Thema, daher kehren wir zu unserem Shader zur√ºck. </div></div><br>  Die Perspektiventeilung kann auch im Vertex-Shader durchgef√ºhrt werden, und bereits vorbereitete Daten k√∂nnen an den Fragment-Shader √ºbertragen werden. <br><br><pre> <code class="hljs mel">v2f vert (appdata v) { v2f o; o.uv = v.uv; o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = v.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; o.vertex = UnityObjectToClipPos(v.vertex); o.grabPos = ComputeScreenPos (o.vertex); o.grabPos /= o.grabPos.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; }</code> </pre> <br>  F√ºgen Sie jeweils einen Fragment-Shader hinzu. <br><br><pre> <code class="hljs matlab">fixed4 frag (v2f <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) : SV_Target { fixed4 = grabColor = tex2d(_GrabTexture, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.grabPos.xy); fixed4 texColor = tex2D(_MainTex, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.uv)*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grabColor; }</code> </pre> <br>  Schalten Sie den angegebenen Mischmodus aus, weil  Jetzt implementieren wir unseren Mischmodus im Fragment-Shader. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Blend SrcAlpha OneMinusSrcAlpha Blend Off</span></span></code> </pre><br>  Und schauen Sie sich das Ergebnis von <i>GrabPass an</i> . <br><br><img src="https://habrastorage.org/webt/mh/ex/b_/mhexb_lek_zyrgsto6p0ki4rmoi.jpeg" alt="Bild"><br><br>  Nichts scheint passiert zu sein, ist es aber nicht.  Aus Gr√ºnden der √úbersichtlichkeit f√ºhren wir eine leichte Verschiebung ein. Dazu addieren wir den Wert der Variablen zu den Texturkoordinaten.  <i>F√ºgen</i> Sie eine neue <i>_DisplacementPower-</i> Eigenschaft hinzu, damit wir die Variable √§ndern k√∂nnen. <br><br><pre> <code class="hljs powershell">Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Color"</span></span> , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _DisplacementPower (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Pass { ... float _DisplacementPower; ... } }</code> </pre> <br>  Nehmen Sie erneut √Ñnderungen am Fragment-Shader vor. <br><br><pre> <code class="hljs lisp">fixed4 grabColor = tex2d(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy + _DisplaccementPower)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Op Hop und Ergebnis!  Bild mit einer Verschiebung. <br><br><img src="https://habrastorage.org/webt/ky/yl/9w/kyyl9w51dqeap4_wvxws1nod4fg.jpeg"><br><br>  Nach einer erfolgreichen Schicht k√∂nnen Sie zu einer komplexeren Verzerrung √ºbergehen.  Wir verwenden vorbereitete Texturen, die die Verschiebungskraft am angegebenen Punkt speichern.  Rote Farbe f√ºr den Versatzwert auf der x-Achse und gr√ºn auf der y-Achse. <br><br><div class="spoiler">  <b class="spoiler_title">Texturen zur Verzerrung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0f/fu/-e/0ffu-ezmyhr9lb3qofn9d99ese8.png"><br><img src="https://habrastorage.org/webt/ld/mf/no/ldmfnoicn2b7e7cmsbpeml716hs.png"><br></div></div><br>  Fangen wir an.  F√ºgen Sie eine neue Eigenschaft hinzu, um die Textur zu speichern. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">_DisplacementTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  Und eine Variable. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DisplacementTex;</code> </pre> <br>  Im Fragment-Shader erhalten wir die Versatzwerte aus der Textur und f√ºgen sie den Texturkoordinaten hinzu. <br><br><pre> <code class="hljs lisp">fixed4 displPos = tex2D(<span class="hljs-name"><span class="hljs-name">_DisplacementTex</span></span>, i.uv)<span class="hljs-comment"><span class="hljs-comment">; float2 offset = (displPos.xy*2 - 1) * _DisplacementPower * displPos.a; fixed4 grabColor = tex2D (_GrabTexture, i.grabPos.xy + offset);</span></span></code> </pre><br>  <i>Wenn Sie</i> nun die Werte des Parameters <i>_DisplacementPower √§ndern</i> , verschieben wir das Originalbild nicht nur, sondern verzerren es. <br><br><img src="https://habrastorage.org/webt/tu/pu/w3/tupuw3jqxaztn2jl19mdyhtvzwi.gif"><br><br><h3>  √úberlagerung </h3><br>  Jetzt gibt es auf dem Bildschirm nur noch eine Verzerrung des Raums, und das Sprite, das wir ganz am Anfang gezeigt haben, fehlt.  Wir werden es an seinen Platz zur√ºckbringen.  Dazu verwenden wir eine schwierige Farbmischung.  Nehmen Sie etwas anderes, wie den Overlay-Mischmodus.  Die Formel lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/wd/qr/z7/wdqrz7rv0skaotpofwwu4owvyxy.jpeg"><br><br>  wobei S das Originalbild ist, C korrigierend ist, dh unser Sprite, R ist das Ergebnis. <br><br>  √úbertragen Sie diese Formel auf unseren Shader. <br><br><pre> <code class="hljs mel">fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>*texColor : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(<span class="hljs-number"><span class="hljs-number">1</span></span>-texColor)*(<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>);</code> </pre><br>  Die Verwendung von bedingten Operatoren in einem Shader ist ein ziemlich verwirrendes Thema.  Viel h√§ngt von der Plattform und der verwendeten Grafik-API ab.  In einigen F√§llen wirken sich bedingte Anweisungen nicht auf die Leistung aus.  Aber es lohnt sich immer, einen Fallback zu haben.  Der bedingte Operator kann mithilfe von Mathematik und verf√ºgbaren Methoden ersetzt werden.  Wir verwenden die folgende Konstruktion <br><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = step ( y, x); r = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> * a + (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) * b;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Schrittfunktion</b> <div class="spoiler_text">  Die Schrittfunktion gibt 1 zur√ºck, wenn <b>x</b> gr√∂√üer oder gleich <b>y ist</b> .  Und 0, wenn <b>x</b> kleiner als <b>y ist</b> . <br><br>  Wenn zum Beispiel <b>x</b> = 1 und <b>y</b> = 0,5 ist, ist das Ergebnis von <b>c</b> 1. Und der folgende Ausdruck sieht so aus <br>  r = 1 * a + 0 * b <br>  Weil  Multiplizieren mit 0 ergibt 0, dann ist das Ergebnis nur der Wert von <b>a</b> . <br>  Andernfalls, wenn <b>c</b> 0 ist, <br>  r = 0 * a + 1 * b <br>  Und das Endergebnis wird <b>b sein</b> . <br></div></div><br>  Schreiben Sie die Farbe f√ºr den <i>Overlay-</i> Modus neu. <br><br><pre> <code class="hljs mel">fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>));</code> </pre> <br>  Ber√ºcksichtigen Sie unbedingt die Transparenz des Sprites.  Dazu verwenden wir eine lineare Interpolation zwischen den beiden Farben. <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a);</code> </pre> <br>  Vollfragment-Shader-Code. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  Und das Ergebnis unserer Arbeit. <br><br><img src="https://habrastorage.org/webt/ea/au/xy/eaauxypqmxxrbcjrkl4swnctjeg.gif"><br><br><h3>  GrabPass-Funktion </h3><br>  Es wurde oben erw√§hnt, dass der <i>GrabPass-</i> Pass <i>{}</i> den Inhalt des Bildschirms in einer <i>_GrabTexture-</i> Textur <i>erfasst</i> .  Gleichzeitig wird bei jedem Aufruf dieser Passage der Inhalt der Textur aktualisiert. <br>  Eine st√§ndige Aktualisierung kann vermieden werden, indem der Name der Textur angegeben wird, in der der Inhalt des Bildschirms erfasst wird. <br><pre> <code class="hljs objectivec">GrabPass{<span class="hljs-string"><span class="hljs-string">"_DisplacementGrabTexture"</span></span>}</code> </pre> <br>  Jetzt wird der Inhalt der Textur nur beim ersten Aufruf des GrabPass-Durchlaufs pro Frame aktualisiert.  Dies spart Ressourcen, wenn <i>viele</i> Objekte <i>GrabPass {} verwenden</i> .  Wenn sich jedoch zwei Objekte √ºberlappen, fallen Artefakte auf, da beide Objekte dasselbe Bild verwenden. <br><br>  Verwenden von GrabPass {"_ DisplacementGrabTexture"}. <br><br><img src="https://habrastorage.org/webt/9n/uv/n9/9nuvn9st0v_t9l7rwxspbmy8iww.jpeg"><br><br>  Verwenden von GrabPass {}. <br><br><img src="https://habrastorage.org/webt/sl/ai/4a/slai4akjk0suyfp43gptuyp3pfw.jpeg"><br><br><h2>  Animation </h2><br>  Jetzt ist es Zeit, unseren Effekt zu animieren.  Wir wollen die Verzerrungskraft sanft reduzieren, wenn die Druckwelle w√§chst, und ihre Ausl√∂schung simulieren.  Dazu m√ºssen wir die Eigenschaften des Materials √§ndern. <br><br><div class="spoiler">  <b class="spoiler_title">Skript f√ºr die Animation</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _elapsedTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SpriteRenderer _renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Duration; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve ScaleProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ScalePower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve PropertyProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PropertyPower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve AlphaProgress; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elapsedTime &lt; Duration) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> progress = _elapsedTime / Duration; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scale = ScaleProgress.Evaluate(progress) * ScalePower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = PropertyProgress.Evaluate(progress) * PropertyPower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alpha = AlphaProgress.Evaluate(progress); transform.localScale = scale; _renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = _renderer.color; color.a = alpha; _renderer.color = color; _elapsedTime += Time.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Und seine Einstellungen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cs/sm/9f/cssm9fqvoequsovfl8wlff72rxu.jpeg"><br></div></div><br>  Das Ergebnis der Animation. <br><br><img src="https://habrastorage.org/webt/5j/sm/ic/5jsmicvf7jepmp-adecch-jlwb8.gif"><br><br><h2>  Perrendererdata </h2><br>  Achten Sie auf die folgende Zeile. <br><br><pre> <code class="cs hljs">_renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property);</code> </pre> <br>  Hier √§ndern wir nicht nur eine der Eigenschaften des Materials, sondern erstellen eine Kopie des Quellmaterials (nur beim ersten Aufruf dieser Methode) und arbeiten damit.  Es ist eine ziemlich funktionierende Option, aber wenn sich mehr als ein Objekt auf der B√ºhne befindet, zum Beispiel tausend, f√ºhrt das Erstellen so vieler Kopien nicht zu etwas Gutem.  Es gibt eine bessere Option: Verwenden Sie dazu das Attribut <i>[PerRendererData]</i> im Shader und das <i>MaterialPropertyBlock-</i> Objekt im Skript. <br><br>  <i>F√ºgen Sie dazu der</i> Eigenschaft <i>_DisplacementPower</i> im Shader ein Attribut <i>hinzu</i> . <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplacementPower</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Range(-.<span class="hljs-number"><span class="hljs-number">1</span></span>,.<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Danach wird die Eigenschaft im Inspektor nicht mehr angezeigt, weil  Jetzt ist es f√ºr jedes Objekt individuell, wodurch die Werte festgelegt werden. <br><br><img src="https://habrastorage.org/webt/ni/g4/zu/nig4zujdlflr1xjm_ry-cwulane.jpeg"><br><br>  Wir kehren zum Skript zur√ºck und nehmen √Ñnderungen daran vor. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MaterialPropertyBlock _propertyBlock; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); _propertyBlock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialPropertyBlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//_renderer.material.SetFloat("_DisplacementPower", property); _renderer.GetPropertyBlock(_propertyBlock); _propertyBlock.SetFloat("_DisplacementPower", property); _renderer.SetPropertyBlock(_propertyBlock); ... }</span></span></code> </pre> <br>  Um nun die Eigenschaft zu √§ndern, aktualisieren wir den <i>MaterialPropertyBlock</i> unseres Objekts, ohne Kopien des Materials zu erstellen. <br><br><div class="spoiler">  <b class="spoiler_title">√úber SpriteRenderer</b> <div class="spoiler_text">  Schauen wir uns diese Zeile im Shader an. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  <i>SpriteRenderer funktioniert</i> √§hnlich mit Sprites.  Es setzt die <i>_MainTex-</i> Eigenschaft mithilfe von <i>MaterialPropertyBlock</i> auf <i>ihren</i> Wert.  Daher wird im Inspektor die Eigenschaft <i>_MainTex</i> f√ºr das Material nicht angezeigt, und in der <i>SpriteRenderer-</i> Komponente geben wir die ben√∂tigte Textur an.  Gleichzeitig k√∂nnen sich auf der B√ºhne viele verschiedene Sprites befinden, aber nur ein Material wird f√ºr das Rendern verwendet (wenn Sie es nicht selbst √§ndern). <br></div></div><br><h3>  PerRendererData-Funktion </h3><br>  Sie k√∂nnen <i>MaterialPropertyBlock</i> von fast allen Komponenten erhalten, die sich auf das Rendern beziehen.  Zum Beispiel <i>SpriteRenderer</i> , <i>ParticleRenderer</i> , <i>MeshRenderer</i> und andere <i>Renderer-</i> Komponenten.  Es gibt jedoch immer eine Ausnahme, dies ist ein <i>CanvasRenderer</i> .  Es ist unm√∂glich, Eigenschaften mit dieser Methode zu erhalten und zu √§ndern.  Wenn Sie ein 2D-Spiel mit UI-Komponenten schreiben, tritt dieses Problem beim Schreiben von Shadern auf. <br><br><h2>  Drehung </h2><br>  Ein unangenehmer Effekt tritt auf, wenn das Bild gedreht wird.  Dies macht sich am Beispiel einer Rundwelle besonders bemerkbar. <br><br>  Die rechte Welle beim Drehen (90 Grad) f√ºhrt zu einer weiteren Verzerrung. <br><br><img src="https://habrastorage.org/webt/ns/gy/2e/nsgy2effgwcv8d0kavaltwd2ofi.jpeg"><br><br>  Rot zeigt die Vektoren an, die von demselben Punkt in der Textur erhalten wurden, jedoch mit einer anderen Drehung dieser Textur.  Der Versatzwert bleibt gleich und ber√ºcksichtigt keine Drehung. <br><br>  Um dieses Problem zu l√∂sen, verwenden wir die Transformationsmatrix <i>unit_ObjectToWorld</i> .  Es wird helfen, unseren Vektor von lokalen Koordinaten zu Weltkoordinaten wiederzugeben. <br><br><pre> <code class="hljs pgsql">float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = mul( unity_ObjectToWorld, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>);</code> </pre> <br>  Die Matrix enth√§lt jedoch auch Daten zur Skalierung des Objekts. Wenn Sie also die St√§rke der Verzerrung angeben, m√ºssen Sie die Skalierung des Objekts selbst ber√ºcksichtigen. <br><br><pre> <code class="cs hljs">_propertyBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property/transform.localScale.x);</code> </pre> <br>  Die rechte Welle wird ebenfalls um 90 Grad gedreht, aber die Verzerrung wird jetzt korrekt berechnet. <br><br><img src="https://habrastorage.org/webt/g4/hc/gu/g4hcguat4nxvgm0b2jyylrqvlze.jpeg"><br><br><h2>  Clip </h2><br>  Unsere Textur hat gen√ºgend transparente Pixel (insbesondere wenn wir den <i>Rect-</i> Maschentyp verwenden).  Der Shader verarbeitet sie, was in diesem Fall keinen Sinn ergibt.  Daher werden wir versuchen, die Anzahl unn√∂tiger Berechnungen zu reduzieren.  Wir k√∂nnen die Verarbeitung transparenter Pixel mit der <i>Clip (x)</i> -Methode unterbrechen.  Wenn der √ºbergebene Parameter kleiner als Null ist, wird der Shader beendet.  Da der Alpha-Wert jedoch nicht kleiner als 0 sein kann, wird ein kleiner Wert davon abgezogen.  Es kann auch in Eigenschaften ( <i>Ausschnitt</i> ) <i>eingef√ºgt</i> und zum Abschneiden der transparenten Teile des Bildes verwendet werden.  In diesem Fall ben√∂tigen wir keinen separaten Parameter, daher verwenden wir nur die Zahl <b>0,01</b> . <br><br>  Vollfragment-Shader-Code. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; offset = mul( unity_ObjectToWorld,offset); fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">clip</span></span>(texColor.a - <span class="hljs-number"><span class="hljs-number">0.01</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  PS: Der Quellcode f√ºr den Shader und das Skript ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zu Git</a> .  Das Projekt hat auch einen kleinen Texturgenerator f√ºr Verzerrungen.  Der Kristall mit dem Sockel wurde aus dem Asset - 2D Game Kit - entnommen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427357/">https://habr.com/ru/post/de427357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427347/index.html">Migration auf die Google Cloud Platform (Google Cloud Platform - GCP)</a></li>
<li><a href="../de427349/index.html">Programmierer f√ºr die neue tinyAVR-Familie basierend auf dem billigen chinesischen Konverter CH340</a></li>
<li><a href="../de427351/index.html">Sicherheitswoche 40: Sicherheitsl√ºcken in CMS Drupal und mehr</a></li>
<li><a href="../de427353/index.html">Drohnen zeigen: wie wir einen Schwarm tanzender Hubschrauber koordiniert haben</a></li>
<li><a href="../de427355/index.html">CJM-Zusammenstellung, wichtige Art Director-F√§higkeiten und Benutzerverst√§ndnis</a></li>
<li><a href="../de427359/index.html">Wie ECS, C # Job System und SRP die Architektur √§ndern</a></li>
<li><a href="../de427361/index.html">Funktionen der Fensterfilterung auf FPGA</a></li>
<li><a href="../de427363/index.html">Implementierung von LoRaWAN in einem landwirtschaftlichen Unternehmen. Alles √ºber Konstruktion, Einf√ºhrung und L√∂sungen</a></li>
<li><a href="../de427365/index.html">Bericht von RedSlerm √ºber die √úberwachung (Monit, Zabbix)</a></li>
<li><a href="../de427367/index.html">BLACK HAT USA Konferenz. Wie ein Hollywood-Hacker √úberwachungskameras einsetzt. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>