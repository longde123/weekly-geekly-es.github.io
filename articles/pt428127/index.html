<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèª üë®üèø‚Äçü§ù‚Äçüë®üèª üòû Nginx cache: tudo novo - bem esquecido üîù ü§∞üèø üëäüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na vida de cada projeto, chega o momento em que o servidor deixa de atender aos requisitos de SLA e literalmente come√ßa a engasgar com a quantidade de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nginx cache: tudo novo - bem esquecido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428127/">  Na vida de cada projeto, chega o momento em que o servidor deixa de atender aos requisitos de SLA e literalmente come√ßa a engasgar com a quantidade de tr√°fego recebido.  Depois disso, come√ßa o longo processo de encontrar gargalos, consultas pesadas, √≠ndices criados incorretamente, dados n√£o armazenados em cache ou vice-versa, dados atualizados com freq√º√™ncia no cache e em outros lados obscuros do projeto. <br><br>  Mas o que fazer quando seu c√≥digo √© ‚Äúperfeito‚Äù, todas as solicita√ß√µes pesadas s√£o colocadas em segundo plano, tudo o que era poss√≠vel foi armazenado em cache e o servidor ainda n√£o atinge os indicadores de SLA de que precisamos?  Se poss√≠vel, √© claro que voc√™ pode comprar carros novos, distribuir parte do tr√°fego e esquecer o problema por um tempo. <br><br>  Mas se voc√™ acha que seu servidor √© capaz de mais ou se existe um par√¢metro m√°gico que acelera o site em 100 vezes, lembre-se do recurso nginx interno que permite armazenar em cache as respostas do back-end.  Vamos dar uma olhada no que √© e como ele pode ajudar a aumentar o n√∫mero de solicita√ß√µes processadas pelo servidor. <a name="habracut"></a><br><br>
<h3>  O que √© o cache do Nginx e como ele funciona? </h3><br>  O cache do Nginx pode reduzir significativamente o n√∫mero de solicita√ß√µes para o back-end.  Isso √© poss√≠vel salvando a resposta HTTP por um certo tempo e, ao acessar o recurso novamente, retornando-o do cache sem fazer proxy da solicita√ß√£o do back-end.  O armazenamento em cache, mesmo por um curto per√≠odo, aumentar√° significativamente o n√∫mero de solicita√ß√µes processadas pelo servidor. <br><br>  Antes de prosseguir com a configura√ß√£o do nginx, voc√™ precisa ter certeza de que ele foi criado com o m√≥dulo ‚Äúngx_http_proxy_module‚Äù, j√° que iremos configur√°-lo usando este m√≥dulo. <br><br>  Por conveni√™ncia, voc√™ pode colocar a configura√ß√£o em um arquivo separado, por exemplo, ‚Äú/etc/nginx/conf.d/cache.conf‚Äù.  Vamos dar uma olhada na diretiva proxy_cache_path, que permite definir as configura√ß√µes de armazenamento em cache. <br><br><pre><code class="hljs swift">proxy_cache_path /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> keys_zone=proxy_cache:15m max_size=1G;</code> </pre> <br>  ‚Äú/ Var / lib / nginx / proxy_cache‚Äù especifica o caminho de armazenamento em cache no servidor.  √â nesse diret√≥rio que o nginx salva os arquivos com a resposta do back-end.  Ao mesmo tempo, o nginx n√£o criar√° um diret√≥rio para o cache de forma independente. Voc√™ precisa cuidar disso sozinho. <br><br>  "N√≠veis = 1: 2" - define o n√≠vel de aninhamento de diret√≥rios com um cache.  Os n√≠veis de aninhamento s√£o indicados por ":"; nesse caso, ser√£o criados 2 diret√≥rios, no total s√£o permitidos 3 n√≠veis de aninhamento.  Para cada n√≠vel de aninhamento, valores de 1 a 2 est√£o dispon√≠veis, indicando como criar o nome do diret√≥rio. <br><br>  O ponto importante √© que o nome do diret√≥rio n√£o √© escolhido aleatoriamente, mas √© criado com base no nome do arquivo.  O nome do arquivo, por sua vez, √© o resultado da fun√ß√£o md5 da chave do cache; veremos a chave do cache um pouco mais tarde. <br><br>  Vamos ver na pr√°tica como o caminho para o arquivo de cache √© constru√≠do: <br><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache/<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">49</span></span>/07edcfe6974569ab4da6634ad4e5d492</code> </pre> <br>  O par√¢metro "Keys_zone = proxy_cache: 15m" define o nome da zona na mem√≥ria compartilhada, onde todas as chaves e informa√ß√µes ativas s√£o armazenadas.  Atrav√©s de:: indica o tamanho da mem√≥ria alocada em MB.  De acordo com o nginx, 1 MB √© suficiente para armazenar 8 mil chaves. <br><br>  "Max_size = 1G" define o tamanho m√°ximo do cache para todas as p√°ginas acima das quais o nginx cuidar√° da exclus√£o de dados menos necess√°rios. <br><br>  Tamb√©m √© poss√≠vel controlar o tempo de vida dos dados no cache, para isso basta definir o par√¢metro "inativo" da diretiva "proxy_cache_path", que √© de 10 minutos por padr√£o.  Se durante o tempo especificado no par√¢metro "inativo" n√£o houver chamadas para os dados do cache, esses dados ser√£o exclu√≠dos, mesmo que o cache ainda n√£o esteja "azedo". <br><br>  Como √© esse cache?  Na verdade, este √© um arquivo comum no servidor, cujo conte√∫do est√° escrito: <br><br>  Chave de cache; <br>  ‚Ä¢ cabe√ßalhos de cache; <br>  ‚Ä¢ resposta de conte√∫do do back-end. <br><br>  Se tudo estiver claro com os cabe√ßalhos e a resposta do back-end, haver√° v√°rias perguntas na "chave de cache".  Como √© constru√≠do e como pode ser gerenciado? <br><br>  Para descrever o modelo para criar uma chave de cache no nginx, existe uma diretiva proxy_cache_key, na qual uma cadeia de caracteres √© especificada como par√¢metro.  Uma string pode consistir em quaisquer vari√°veis ‚Äã‚Äãdispon√≠veis no nginx. <br><br>  Por exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$request_method</span></span><span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$orig_uri</span></span>:<span class="hljs-variable"><span class="hljs-variable">$cookie_some_cookie</span></span>:<span class="hljs-variable"><span class="hljs-variable">$arg_some_arg</span></span>;</code> </pre> <br>  O s√≠mbolo ‚Äú:‚Äù entre o par√¢metro cookie e o par√¢metro get √© usado para evitar colis√µes entre chaves de cache, voc√™ pode escolher qualquer outro s√≠mbolo de sua escolha.  Por padr√£o, o nginx usa a seguinte linha para gerar a chave: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>;</code> </pre> <br>  As seguintes diretivas devem ser observadas que ajudar√£o voc√™ a gerenciar seu cache com mais flexibilidade: <br><br>  <i>proxy_cache_valid</i> - especifica o tempo de armazenamento em cache da resposta.  √â poss√≠vel indicar o status espec√≠fico da resposta, por exemplo, 200, 302, 404, etc., ou especificar tudo de uma vez usando a constru√ß√£o "any".  Se apenas o tempo de armazenamento em cache for especificado, o nginx assumir√° o padr√£o de armazenar em cache apenas os status 200, 301 e 302. <br><br>  Um exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">15m</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">15s</span></span>;</code> </pre><br>  Neste exemplo, definimos a vida √∫til do cache como 15 minutos para os status 200, 301, 302 (o nginx os usa por padr√£o, pois n√£o especificamos um status espec√≠fico).  A pr√≥xima linha configurou o tempo de armazenamento em cache para 15 segundos, apenas para respostas com um status 404. <br><br>  <i>proxy_cache_lock</i> - Esta diretiva ajudar√° a evitar v√°rias passagens para o back-end imediatamente ap√≥s um conjunto de cache, apenas defina o valor na posi√ß√£o "ligado".  Todas as outras solicita√ß√µes aguardam uma resposta no cache ou um tempo limite para bloquear a solicita√ß√£o na p√°gina.  Assim, todos os tempos limite podem ser configurados. <br><br>  <i>proxy_cache_lock_age</i> - Permite definir um limite de tempo limite para uma resposta do servidor, ap√≥s o qual a pr√≥xima solicita√ß√£o ser√° enviada a ele depois que o cache for definido.  O padr√£o √© 5 segundos. <br><br>  <i>proxy_cache_lock_timeout</i> - Define o tempo de espera pelo bloqueio, ap√≥s o qual a solicita√ß√£o ser√° enviada ao back-end, mas a resposta n√£o ser√° armazenada em cache.  O padr√£o √© 5 segundos. <br><br>  <i>proxy_cache_use_stale</i> - Outra diretiva √∫til que permite configurar quando √© poss√≠vel usar um cache obsoleto. <br><br>  Um exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_use_stale</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout updating;</code> </pre> <br>  Nesse caso, ele usar√° um cache desatualizado em caso de erro de conex√£o, enviando uma solicita√ß√£o, lendo uma resposta do servidor, excedendo o limite de espera para enviar uma solicita√ß√£o, lendo uma resposta do servidor ou se os dados no cache forem atualizados no momento da solicita√ß√£o. <br><br>  <i>proxy_cache_bypass</i> - Especifica as condi√ß√µes sob as quais o nginx n√£o receber√° uma resposta do cache, mas redirecionar√° imediatamente a solicita√ß√£o para o back-end.  Se pelo menos um dos par√¢metros n√£o estiver vazio e n√£o for igual a "0".  Um exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_bypass</span></span> <span class="hljs-variable"><span class="hljs-variable">$cookie_nocache</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_nocache</span></span>;</code> </pre> <br>  <i>proxy_no_cache</i> - Define a condi√ß√£o sob a qual o nginx n√£o salvar√° a resposta do back-end no cache.  O princ√≠pio de opera√ß√£o √© o mesmo da diretiva proxy_cache_bypass. <br><br><h3>  Poss√≠veis problemas com o cache da p√°gina </h3><br>  Como mencionado acima, juntamente com o cache de uma resposta HTTP, o nginx salva os cabe√ßalhos recebidos do back-end.  Se o seu site usa uma sess√£o, o cookie da sess√£o tamb√©m ser√° armazenado em cache.  Todos os usu√°rios que visitarem a p√°gina que voc√™ teve sorte em armazenar em cache receber√£o seus dados pessoais armazenados na sess√£o. <br><br>  O pr√≥ximo desafio que voc√™ enfrentar√° √© o gerenciamento de cache.  Obviamente, voc√™ pode definir um tempo de cache insignificante de 2 a 5 minutos e isso ser√° suficiente na maioria dos casos.  Mas como isso n√£o √© aplic√°vel em todas as situa√ß√µes, reinventaremos nossa bicicleta.  Agora, as primeiras coisas primeiro. <br><br>  <b>Gerenciamento de preserva√ß√£o de cookies</b> <br><br>  O armazenamento em cache no lado nginx imp√µe algumas restri√ß√µes de design.  Por exemplo, n√£o podemos usar sess√µes em p√°ginas em cache, pois o usu√°rio n√£o acessa o back-end, outra limita√ß√£o √© a entrega de cookies pelo back-end.  Como o nginx armazena em cache todos os cabe√ßalhos, para evitar armazenar a sess√£o de outra pessoa no cache, precisamos proibir a entrega de cookies para p√°ginas em cache.  A diretiva proxy_ignore_headers nos ajudar√° com isso.  O argumento lista os cabe√ßalhos que devem ser ignorados no back-end. <br><br>  Um exemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_ignore_headers</span></span> <span class="hljs-string"><span class="hljs-string">"Set-Cookie"</span></span>;</code> </pre> <br>  Com essa linha, ignoramos a instala√ß√£o de cookies do servidor proxy, ou seja, o usu√°rio receber√° uma resposta sem o cabe√ßalho "Set-Cookies".  Consequentemente, tudo o que o back-end tentou gravar no cookie ser√° ignorado no lado do cliente, pois ele nem saber√° que algo foi planejado para ele.  Essa restri√ß√£o de cookies deve ser considerada ao desenvolver um aplicativo.  Por exemplo, para solicitar autoriza√ß√£o, voc√™ pode desativar a igni√ß√£o do cabe√ßalho para que o usu√°rio receba um cookie de sess√£o. <br><br>  Voc√™ tamb√©m deve levar em considera√ß√£o o tempo de vida da sess√£o, que pode ser visualizado no par√¢metro ‚Äú <i>session.gc_maxlifetime</i> ‚Äù da configura√ß√£o do php.ini.  Imagine que o usu√°rio fez login no site e come√ßou a visualizar o feed de not√≠cias, todos os dados j√° est√£o no cache nginx.  Depois de algum tempo, o usu√°rio percebe que sua autoriza√ß√£o desapareceu e ele novamente precisa passar pelo processo de autoriza√ß√£o, embora durante todo esse tempo estivesse no site, assistindo √†s not√≠cias.  Isso aconteceu porque em todas as solicita√ß√µes o nginx retornou o resultado do cache sem enviar uma solicita√ß√£o ao back-end.  Portanto, o back-end decidiu que o usu√°rio estava inativo e ap√≥s um tempo especificado em " <i>session.gc_maxlifetime</i> " excluiu o arquivo da sess√£o. <br><br>  Para impedir que isso aconte√ßa, podemos emular solicita√ß√µes de back-end.  Por exemplo, atrav√©s do ajax, envie uma solicita√ß√£o que ser√° garantida para passar para o back-end.  Para passar o cache nginx para o back-end, basta enviar uma solicita√ß√£o POST, voc√™ tamb√©m pode usar a regra da diretiva ‚Äúproxy_cache_bypass‚Äù ou simplesmente desativar o cache desta p√°gina.  A solicita√ß√£o n√£o precisa retribuir, pode ser um arquivo com uma √∫nica linha iniciando a sess√£o.  O objetivo dessa solicita√ß√£o √© prolongar a vida √∫til da sess√£o enquanto o usu√°rio estiver no site, e o nginx conscientemente fornece os dados em cache para todas as suas solicita√ß√µes. <br><br>  <b>Gerenciamento de libera√ß√£o de cache</b> <br><br>  Primeiro, voc√™ precisa determinar os requisitos, que objetivo estamos tentando alcan√ßar.  Digamos que nosso site tenha uma se√ß√£o com uma transmiss√£o de texto de eventos esportivos populares.  Ao carregar a p√°gina √© fornecida a partir do cache, todas as novas mensagens aparecem nos soquetes.  Para que o usu√°rio veja as mensagens atuais no hor√°rio atual na primeira inicializa√ß√£o, em vez de 15 minutos atr√°s, precisamos ser capazes de limpar independentemente o cache do nginx a qualquer momento.  Ao mesmo tempo, o nginx pode n√£o estar localizado na mesma m√°quina que o aplicativo.  Al√©m disso, um dos requisitos para uma redefini√ß√£o ser√° a capacidade de excluir o cache, em v√°rias p√°ginas ao mesmo tempo. <br><br>  Antes de come√ßar a escrever sua solu√ß√£o, vamos ver o que o nginx oferece imediatamente.  Para redefinir o cache, o nginx possui uma diretiva especial chamada ‚Äúproxy_cache_purge‚Äù, que registra a condi√ß√£o para redefinir o cache.  A condi√ß√£o √© na verdade uma linha normal que, se n√£o estiver vazia e n√£o "0", excluir√° o cache pela chave passada.  Considere um pequeno exemplo. <br><br><pre> <code class="hljs perl">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-keyword"><span class="hljs-keyword">m</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> $request_method $purge_method { PURGE <span class="hljs-number"><span class="hljs-number">1</span></span>; default <span class="hljs-number"><span class="hljs-number">0</span></span>; } server { ... location / { proxy_pass http:<span class="hljs-regexp"><span class="hljs-regexp">//backend</span></span>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }</code> </pre><br>  <i>Um exemplo √© retirado do site oficial da nginx.</i> <br><br>  A vari√°vel $ purge_method √© respons√°vel por liberar o cache, que √© uma condi√ß√£o para a diretiva proxy_cache_purge e √© definida como 0 por padr√£o.  Isso significa que o nginx funciona no modo "normal" (salva as respostas do back-end).  Mas se voc√™ alterar o m√©todo de solicita√ß√£o para "PURGE", em vez de fazer proxy da solicita√ß√£o de back-end ao salvar a resposta, a entrada do cache ser√° exclu√≠da usando a chave de cache correspondente.  Tamb√©m √© poss√≠vel especificar uma m√°scara de exclus√£o especificando um "*" no final da chave de cache.  Portanto, n√£o precisamos saber a localiza√ß√£o do cache no disco e o princ√≠pio de forma√ß√£o de chave, o nginx assume essas responsabilidades.  Mas tamb√©m h√° desvantagens nessa abordagem. <br><br><ul><li>  A diretiva proxy_cache_purge est√° dispon√≠vel como parte de uma assinatura comercial. </li><li>  S√≥ √© poss√≠vel excluir o cache no sentido dos ponteiros do mouse ou usando a m√°scara do formul√°rio {cache key} ‚Äú*‚Äù </li></ul><br>  Como os endere√ßos das p√°ginas em cache podem ser completamente diferentes, sem partes comuns, a abordagem com a m√°scara "*" e a diretiva "proxy_cache_purge" n√£o √© adequada para n√≥s.  Resta lembrar um pouco de teoria e descobrir seu ide favorito. <br><br>  Sabemos que o cache nginx √© um arquivo regular no servidor.  Especificamos de maneira independente o diret√≥rio para armazenar arquivos de cache na diretiva ‚Äúproxy_cache_path‚Äù, at√© especificamos a l√≥gica de formar o caminho para o arquivo deste diret√≥rio usando ‚Äúlevels‚Äù.  A √∫nica coisa que est√° faltando √© a forma√ß√£o correta da chave de armazenamento em cache.  Mas tamb√©m podemos v√™-lo na diretiva ‚Äúproxy_cache_key‚Äù.  Agora tudo o que precisamos fazer √©: <br><br><ul><li>  forme o caminho completo para a p√°gina, exatamente como especificado na diretiva proxy_cache_key; </li><li>  codifique a string resultante em md5; </li><li>  crie diret√≥rios aninhados usando a regra do par√¢metro "levels". </li><li>  E agora j√° temos o caminho completo para o arquivo de cache no servidor.  Agora, tudo o que resta para n√≥s √© excluir esse mesmo arquivo.  Desde a parte introdut√≥ria, sabemos que o nginx pode n√£o estar localizado na m√°quina do aplicativo, portanto, √© necess√°rio excluir v√°rios endere√ßos ao mesmo tempo.  Novamente, descrevemos o algoritmo: </li><li>  Os caminhos gerados para os arquivos de cache que escreveremos no arquivo; </li><li>  Vamos escrever um script bash simples que colocamos na m√°quina com o aplicativo.  Sua tarefa ser√° conectar via ssh ao servidor em que temos o cache do nginx e excluir todos os arquivos de cache especificados no arquivo gerado a partir da etapa 1; </li></ul><br>  Passamos da teoria √† pr√°tica, escreveremos um pequeno exemplo que ilustra nosso algoritmo de trabalho. <br><br>  Etapa 1. Gerando um arquivo com caminhos para o cache. <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$urls</span></span> = [ <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/111/1:2'</span></span>, <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/112/3:4'</span></span>, ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_nginx_cache_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span> { <span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span> = md5(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); <span class="hljs-variable"><span class="hljs-variable">$firstDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$secondDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/var/lib/nginx/proxy_cache/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$secondDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$nginxHash</span></span></span><span class="hljs-string">"</span></span>; } //        tmp <span class="hljs-variable"><span class="hljs-variable">$filePath</span></span> = tempnam(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'nginx_cache_'</span></span>); //      <span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span> = fopen(<span class="hljs-variable"><span class="hljs-variable">$filePath</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-variable"><span class="hljs-variable">$urls</span></span> as <span class="hljs-variable"><span class="hljs-variable">$url</span></span>) { //      <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> = to_nginx_cache_path(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); //       fwrite(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> . PHP_EOL); } //     fclose(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>); //  bash       exec(<span class="hljs-string"><span class="hljs-string">"/usr/local/bin/cache_remover </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$filePath</span></span></span><span class="hljs-string">"</span></span>);</code> </pre><br>  Observe que a vari√°vel $ urls cont√©m a URL das p√°ginas em cache, j√° no formato proxy_cache_key especificado na configura√ß√£o do nginx.  O URL atua como uma tag para as entidades exibidas na p√°gina.  Por exemplo, voc√™ pode criar uma tabela regular no banco de dados, onde cada entidade ser√° mapeada para uma p√°gina espec√≠fica na qual √© exibida.  Em seguida, ao alterar qualquer dado, podemos fazer uma sele√ß√£o na tabela e excluir o cache de todas as p√°ginas que precisamos. <br><br>  Etapa 2. Conecte-se ao servidor de cache e exclua os arquivos de cache. <br><br><pre> <code class="hljs smalltalk">#      ,      <span class="hljs-type"><span class="hljs-type">FILE_LIST</span></span>=`cat <span class="hljs-string"><span class="hljs-string">$1</span></span> | tr <span class="hljs-comment"><span class="hljs-comment">"\n"</span></span> <span class="hljs-comment"><span class="hljs-comment">" "</span></span>` #   ssh  <span class="hljs-type"><span class="hljs-type">SSH</span></span>=`which ssh` <span class="hljs-type"><span class="hljs-type">USER</span></span>=<span class="hljs-comment"><span class="hljs-comment">"root"</span></span> #         nginx <span class="hljs-type"><span class="hljs-type">HOST</span></span>=<span class="hljs-comment"><span class="hljs-comment">"10.10.1.0"</span></span> #   <span class="hljs-type"><span class="hljs-type">KEY</span></span>=<span class="hljs-comment"><span class="hljs-comment">"/var/keys/id_rsa"</span></span> # <span class="hljs-type"><span class="hljs-type">SSH</span></span> ,          <span class="hljs-string"><span class="hljs-string">$S</span></span>SH -i <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">KEY</span></span>} <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">USER</span></span>}@<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">HOST</span></span>} <span class="hljs-comment"><span class="hljs-comment">"rm -f ${FILE_LIST}"</span></span> #       rm -rf rm -f <span class="hljs-string"><span class="hljs-string">$1</span></span> #  </code> </pre><br>  Os exemplos acima s√£o apenas para orienta√ß√£o, n√£o os use na produ√ß√£o.  Nos exemplos, as verifica√ß√µes dos par√¢metros de entrada e das restri√ß√µes de comando s√£o omitidas.  Um dos problemas que voc√™ pode encontrar √© limitar o tamanho do argumento ao comando rm.  Ao testar no ambiente de desenvolvimento em pequenos volumes, isso pode ser facilmente esquecido e, na produ√ß√£o, voc√™ recebe o erro "rm: lista de argumentos muito longa". <br><br><h3>  Cache de bloco personalizado </h3><br>  Vamos resumir o que conseguimos fazer: <br><br><ul><li>  reduziu a carga no back-end; </li><li>  Aprenda a gerenciar o cache </li><li>  aprendeu a liberar o cache a qualquer momento. </li></ul><br>  Mas nem tudo √© t√£o bom quanto parece √† primeira vista.  Agora, provavelmente, se n√£o todo primeiro, ent√£o precisamente todo segundo site possui uma funcionalidade de registro / autoriza√ß√£o, ap√≥s a passagem pela qual queremos exibir o nome de usu√°rio em algum lugar do cabe√ßalho.  O bloco com o nome √© √∫nico e deve exibir o nome de usu√°rio sob o qual estamos autorizados.  Como o nginx salva a resposta do back-end e, no caso da p√°gina, √© o conte√∫do html da p√°gina, o bloco com dados pessoais tamb√©m ser√° armazenado em cache.  Todos os visitantes do site ver√£o o nome do primeiro usu√°rio que passou para o back-end para um conjunto de cache. <br>  Portanto, o back-end n√£o deve fornecer blocos nos quais as informa√ß√µes pessoais est√£o localizadas para que essas informa√ß√µes n√£o caiam no cache do nginx. <br><br>  √â necess√°rio considerar o carregamento alternativo dessas partes da p√°gina.  Como sempre, isso pode ser feito de v√°rias maneiras, por exemplo, depois de carregar a p√°gina, enviar uma solicita√ß√£o ajax e exibir o carregador no lugar do conte√∫do pessoal.  Outra maneira que consideraremos hoje √© usar tags ssi.  Vamos primeiro entender o que √© SSI e, em seguida, como podemos us√°-lo em conjunto com o cache nginx. <br><br><h3>  O que √© SSI e como funciona </h3><br>  SSI (inclus√µes do lado do servidor, inclus√µes do lado do servidor) √© um conjunto de comandos incorporados em uma p√°gina html que informa ao servidor o que fazer. <br><br>  Aqui est√° uma lista desses comandos (diretivas): <br><br>  If / elif / else / endif - O operador de ramifica√ß√£o; <br>  ‚Ä¢ eco - exibe os valores das vari√°veis; <br>  ‚Ä¢ incluir - Permite inserir o conte√∫do de outro arquivo no documento. <br>  Apenas a √∫ltima diretiva ser√° discutida.  A diretiva include possui dois par√¢metros: <br>  ‚Ä¢ arquivo - especifica o caminho para o arquivo no servidor.  Em rela√ß√£o ao diret√≥rio atual; <br>  ‚Ä¢ virtual - indica o caminho virtual para o documento no servidor. <br><br>  Estamos interessados ‚Äã‚Äãno par√¢metro "virtual", j√° que nem sempre √© conveniente especificar o caminho completo para o arquivo no servidor ou, no caso de uma arquitetura distribu√≠da, o arquivo no servidor simplesmente n√£o existe.  Diretiva de exemplo: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/user/personal_news/"--&gt;</span></span></code> </pre> <br>  Para que o nginx comece a processar inser√ß√µes ssi, √© necess√°rio modificar o local da seguinte maneira: <br><br><pre> <code class="hljs cs">location / { ssi <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ... }</code> </pre><br>  Agora todas as solicita√ß√µes processadas pelo local ‚Äú/‚Äù poder√£o executar inser√ß√µes ssi. <br><br>  Como o nosso pedido passar√° por todo esse esquema? <br><br><ul><li>  o cliente solicita a p√°gina; </li><li>  Nginx proxies a solicita√ß√£o para o back-end; </li><li>  o back-end fornece a p√°gina com inser√ß√µes ssi; </li><li>  o resultado √© armazenado no cache; </li><li>  O Nginx "pergunta" os blocos ausentes; </li><li>  A p√°gina resultante √© enviada ao cliente. </li></ul><br>  Como voc√™ pode ver nas etapas, as constru√ß√µes ssi entrar√£o no cache nginx, o que permitir√° n√£o armazenar em cache os blocos pessoais, e uma p√°gina html pronta com todas as inser√ß√µes ser√° enviada ao cliente.  Aqui nosso carregamento funciona, o nginx solicita independentemente os blocos de p√°ginas ausentes.  Mas, como qualquer outra solu√ß√£o, essa abordagem tem seus pr√≥s e contras.  Imagine que existem v√°rios blocos na p√°gina que devem ser exibidos de forma diferente, dependendo do usu√°rio, e cada um desses blocos ser√° substitu√≠do por uma inser√ß√£o ssi.  O Nginx, conforme o esperado, solicitar√° cada bloco desse tipo do back-end, ou seja, um pedido do usu√°rio gerar√° imediatamente v√°rios pedidos para o back-end, o que eu n√£o gostaria. <br><br><h3>  Livrar-se de solicita√ß√µes persistentes de back-end via ssi </h3><br>  Para resolver esse problema, o m√≥dulo nginx ‚Äúngx_http_memcached_module‚Äù nos ajudar√°.  O m√≥dulo permite receber valores do servidor em cache do memcached.  A escrita no m√≥dulo n√£o funcionar√°; o servidor de aplicativos deve cuidar disso.  Considere um pequeno exemplo de configura√ß√£o do nginx em conjunto com um m√≥dulo: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /page { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$memcached_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uri</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:11211</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">502</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> = <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; } }</code> </pre><br>  Na vari√°vel $ memcache_key, especificamos a chave pela qual o nginx tentar√° obter dados do memcache.  Os par√¢metros para conectar-se ao servidor memcache s√£o definidos na diretiva memcached_pass.  A conex√£o pode ser especificada de v√°rias maneiras: <br><br>  Nome de dom√≠nio; <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">memcached_pass</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cache</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span>;</code> </pre> <br>  ‚Ä¢ endere√ßo IP e porta; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> localhost:<span class="hljs-number"><span class="hljs-number">11211</span></span>;</code> </pre> <br>  Soquete unix; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> unix:/tmp/memcached.socket;</code> </pre> <br>  ‚Ä¢ diretiva a montante. <br><br><pre> <code class="hljs axapta">upstream cachestream { hash $request_uri consistent; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; } location / { ... memcached_pass cachestream; ... }</code> </pre><br>  Se o nginx conseguiu obter uma resposta do servidor de cache, ele a fornece ao cliente.  Se n√£o houver dados no cache, a solicita√ß√£o ser√° enviada ao back-end via "@fallback".  Essa pequena configura√ß√£o do m√≥dulo memcached no nginx nos ajudar√° a reduzir o n√∫mero de solicita√ß√µes de passagem para o back-end das inser√ß√µes ssi. <br><br>  Esperamos que este artigo seja √∫til e que possamos mostrar uma das maneiras de otimizar a carga no servidor, considerar os princ√≠pios b√°sicos da configura√ß√£o do cache do nginx e fechar os problemas que surgem ao us√°-lo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428127/">https://habr.com/ru/post/pt428127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428117/index.html">Processadores tensores gratuitos do Google na Nuvem Colaborativa</a></li>
<li><a href="../pt428119/index.html">"Classe-campos-proposta" ou "O que deu errado no commit do tc39"</a></li>
<li><a href="../pt428121/index.html">Stan Drapkin. Armadilhas de criptografia de alto n√≠vel no .NET</a></li>
<li><a href="../pt428123/index.html">Semana 41 da Seguran√ßa: Boas Novas</a></li>
<li><a href="../pt428125/index.html">Quem s√£o as an√°lises de produtos e por que elas s√£o necess√°rias em uma equipe?</a></li>
<li><a href="../pt428129/index.html">L√≥gica fuzzy simples colada ‚Äúdo que era‚Äù para um motor de turbina a g√°s</a></li>
<li><a href="../pt428131/index.html">Toda a verdade sobre o RTOS. Artigo 17. Grupos de Sinalizadores de Eventos: Introdu√ß√£o e Servi√ßos B√°sicos</a></li>
<li><a href="../pt428133/index.html">Hasura. Arquitetura GraphQL para SQL Server de alto desempenho</a></li>
<li><a href="../pt428135/index.html">Como configurar ou desativar o linting no editor de c√≥digo interno</a></li>
<li><a href="../pt428137/index.html">Olimp√≠ada, concurso de ideias, palestras sobre gerenciamento de projetos de TI e exibi√ß√£o de filmes: 10 pr√≥ximos eventos na ITMO University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>