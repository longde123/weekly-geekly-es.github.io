<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüîß üèùÔ∏è üîà Inventar la biblioteca vusb üëçüèø üëãüèº üë≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 Despu√©s de leer el t√≠tulo, puede surgir una pregunta l√≥gica: ¬øpor qu√© hoy en d√≠a estudiar la implementaci√≥n de software de USB de baj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inventar la biblioteca vusb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460815/"><h2 id="vvedenie">  Introduccion </h2><br><p>  Despu√©s de leer el t√≠tulo, puede surgir una pregunta l√≥gica: ¬øpor qu√© hoy en d√≠a estudiar la implementaci√≥n de software de USB de baja velocidad cuando hay un mont√≥n de controladores baratos con un m√≥dulo de hardware?  El hecho es que el m√≥dulo de hardware, al ocultar el nivel de intercambio de niveles l√≥gicos, convierte el protocolo USB en una especie de magia.  Para sentir c√≥mo funciona esta "magia", no hay nada mejor que reproducirla desde cero, comenzando desde el nivel m√°s bajo. </p><br><p>  Con este fin, intentaremos hacer un dispositivo que finja ser USB-HID basado en el controlador ATmega8.  A diferencia de la literatura generalizada, no pasaremos de la teor√≠a a la pr√°ctica, del nivel m√°s bajo al m√°s alto, de los voltajes l√≥gicos a las conclusiones, y terminaremos con la "invenci√≥n" del mismo vusb, despu√©s de cada paso verificando si el c√≥digo funciona como se esperaba.  Por separado, noto que no invento una alternativa a esta biblioteca, sino que reproduzco constantemente su c√≥digo fuente, preservando la estructura y los nombres originales tanto como sea posible, explicando por qu√© sirve esta o aquella secci√≥n.  Sin embargo, el estilo de escribir c√≥digo familiar para m√≠ es diferente del estilo de los autores vusb.  Inmediatamente, honestamente admito que, adem√°s del inter√©s altruista (para contar un tema dif√≠cil a otros), tambi√©n tengo un inter√©s ego√≠sta: estudiar el tema por mi cuenta y captar un m√°ximo de puntos sutiles para m√≠.  Tambi√©n se deduce que se puede pasar por alto alg√∫n punto importante o que alg√∫n tema no se revela completamente. </p><br><p>  Para una mejor percepci√≥n del c√≥digo, trat√© de resaltar las secciones modificadas con comentarios y eliminarlas de las secciones discutidas anteriormente.  En realidad, el c√≥digo fuente ser√° la principal fuente de informaci√≥n, y el texto explicar√° qu√© se hizo y por qu√©, as√≠ como qu√© resultado se espera. </p><br><p>  Tambi√©n noto que solo se considera USB de baja velocidad, incluso sin mencionar, lo que distingue a las variedades m√°s de alta velocidad. </p><a name="habracut"></a><br><h2 id="shag-0-zhelezo-i-prochaya-podgotovka">  Paso 0. Hierro y otra preparaci√≥n </h2><br><p>  Como prueba, tomemos una placa de depuraci√≥n casera basada en ATmega8 con cuarzo de 12 MHz.  No dar√© el esquema, es bastante est√°ndar (vea el sitio web oficial de vusb), lo √∫nico que vale la pena mencionar son las conclusiones utilizadas.  En mi caso, la salida D + corresponde a PD2, la salida D-PD3 y el suspensor se cuelga en PD4.  En principio, una resistencia pull-up podr√≠a conectarse a la alimentaci√≥n, pero el control manual parece un poco m√°s consistente con el est√°ndar. </p><br><p>  La alimentaci√≥n de 5 V se suministra desde el conector USB, sin embargo, no se esperan m√°s de 3,6 V en las l√≠neas de se√±al (¬øpor qu√© esto fue un misterio para m√≠?).  Por lo tanto, debe reducir la potencia del controlador o colocar los diodos zener en las l√≠neas de se√±al.  Eleg√≠ la segunda opci√≥n, pero en general no importa. </p><br><p>  Como estamos "inventando" la implementaci√≥n, ser√≠a bueno ver qu√© sucede en el cerebro del controlador, es decir, se necesita al menos alg√∫n tipo de informaci√≥n de depuraci√≥n.  En mi caso, estos son dos LED en PD6, PD7 y, lo m√°s importante, UART en PD0, PD1, configurados en 115200, para que pueda escuchar la conversaci√≥n del controlador a trav√©s de una pantalla normal u otro programa para trabajar con el puerto COM: </p><br><pre><code class="bash hljs">$ screen /dev/ttyUSB0 115200</code> </pre> <br><p>  Adem√°s, un wirehark con el m√≥dulo apropiado resultar√° ser una utilidad √∫til para la depuraci√≥n de USB (no siempre comienza desde la caja, pero resolver estos problemas se encuentra con bastante √©xito en Internet y no es la tarea de este art√≠culo). </p><br><p>  Aqu√≠ ser√≠a posible gastar otro kilobyte de texto en la descripci√≥n del programador, los archivos MAKE y otras cosas, pero esto apenas tiene sentido.  Del mismo modo, no me enfocar√© en configuraciones perif√©ricas que no est√©n relacionadas con USB.  Si alguien ni siquiera puede resolver esto, ¬øes demasiado pronto para meterse en las entra√±as del software USB? </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El c√≥digo fuente de todos los pasos est√° disponible en Github.</a> </p><br><h2 id="shag-1-prinimaem-hot-chto-to">  Paso 1. Acepta al menos algo </h2><br><p>  De acuerdo con la documentaci√≥n, USB admite varias velocidades fijas, de las cuales AVR extraer√° solo la m√°s baja: 1.5 megabits por segundo.  Est√° determinado por la resistencia pull-up y la comunicaci√≥n posterior.  Para nuestra frecuencia elegida, la resistencia debe conectar D- con una fuente de alimentaci√≥n de 3.3 V y tener un valor nominal de 1.5 kOhm, pero en la pr√°ctica se puede conectar con +5 V, y el valor nominal puede variar ligeramente.  Con una frecuencia de controlador de 12 MHz, solo 8 ciclos de reloj por bit.  Est√° claro que tal precisi√≥n y velocidad solo se pueden lograr en el ensamblador, por lo que abriremos el archivo drvasm.S  Esto tambi√©n implica la necesidad de usar una interrupci√≥n para captar el comienzo de un byte.  Me alegra que el primer byte transmitido por USB sea siempre el mismo, SYNC, as√≠ que si llegas al principio, est√° bien.  Como resultado, desde el comienzo del byte hasta su final, solo pasan 64 ciclos de controlador (de hecho, el margen es a√∫n m√°s peque√±o), por lo que no debe usar otras interrupciones que no sean USB. </p><br><p>  Inmediatamente ponga la configuraci√≥n en un archivo usbconfig.h separado.  Es all√≠ donde se establecer√°n los pines responsables del USB, as√≠ como los bits, constantes y registros utilizados. </p><br><blockquote>  <strong>Inserto te√≥rico</strong> <br>  La transferencia a trav√©s de USB se realiza en paquetes de varios bytes en cada uno.  El primer byte es siempre el byte de sincronizaci√≥n SYNC, igual a 0b10000000, el segundo es el identificador de byte del paquete PID.  La transferencia de cada byte va del bit menos significativo al m√°s significativo (esto no es del todo cierto, pero en vusb esta sutileza se ignora, dada en otra parte) usando la codificaci√≥n NRZI.  Este m√©todo consiste en el hecho de que un cero l√≥gico se transmite cambiando el nivel l√≥gico al opuesto, y una unidad l√≥gica se transmite sin cambio.  Adem√°s, se introduce protecci√≥n desde la desincronizaci√≥n (que no usaremos, pero debemos tener en cuenta) de la fuente de se√±al y el receptor: si hay seis unidades seguidas en la secuencia transmitida, es decir, el estado de los terminales no cambia durante seis per√≠odos consecutivos, se agrega una inversi√≥n forzada a la transmisi√≥n, como si cero se transmite.  Por lo tanto, el tama√±o del byte puede ser de 8 o 9 bits. <br>  Tambi√©n vale la pena mencionar que las l√≠neas de datos en USB son diferenciales, es decir, cuando D + es alto, D- es bajo (esto se llama estado K) y viceversa (estado J).  Esto se hace para una mejor inmunidad al ruido a alta frecuencia.  Es cierto que hay una excepci√≥n: la se√±al al final del paquete (se llama SE0) se transmite tirando ambas l√≠neas de se√±al al suelo (D + = D- = 0).  Hay dos se√±ales m√°s transmitidas al mantener un voltaje bajo en la l√≠nea D + y un alto voltaje en la l√≠nea D + para diferentes tiempos.  Si el tiempo es peque√±o (un byte de longitud o un poco m√°s largo), entonces es inactivo, una pausa entre paquetes y, si es grande, una se√±al de reinicio. </blockquote><p>  Entonces, la transmisi√≥n est√° en un par diferencial, sin contar el caso ex√≥tico de SE0, pero a√∫n no lo consideraremos.  Entonces, para determinar el estado del bus USB, solo necesitamos una l√≠nea, D + o D-.  En general, no hay diferencia cu√°l elegir, pero para ser definitivos, dejemos que D-sea. </p><br><p>  El comienzo del paquete se puede determinar al recibir el byte SYNC despu√©s de un largo inactivo.  El estado inactivo corresponde al log.1 en la l√≠nea D (tambi√©n es el estado J), y el byte SYNC es 0b100000, pero se transmite del bit menos significativo al m√°s significativo, adem√°s, est√° codificado en NRZI, es decir, cada cero significa inversi√≥n de se√±al, y uno significa manteniendo el mismo nivel.  Entonces la secuencia de estados D- ser√° la siguiente: </p><br><div class="scrollable-table"><table><thead><tr><th>  byte </th><th>  Inactivo </th><th>  SINC </th><th>  PID </th></tr></thead><tbody><tr><td>  USB </td><td>  1..1 </td><td>  00000001 </td><td>  ???????? </td></tr><tr><td>  D- </td><td>  1..1 </td><td>  01010100 </td><td>  ???????? </td></tr></tbody></table></div><br><p>  El comienzo del paquete es m√°s f√°cil de detectar en un flanco descendente, y configuraremos una interrupci√≥n en √©l.  Pero, ¬øqu√© sucede si el controlador est√° ocupado durante el inicio de la recepci√≥n y no puede ingresar a la interrupci√≥n de inmediato?  Para evitar perder el recuento de pistas en tal situaci√≥n, utilizamos el byte SYNC para el prop√≥sito previsto.  Consiste completamente en frentes en los l√≠mites de los bits, para que podamos esperar uno de ellos, luego otro medio bit, y pasar directamente al medio del siguiente.  Sin embargo, esperar un frente de "algo" no es una buena idea, porque no solo necesitamos meternos en la mitad del bit, sino tambi√©n saber en qu√© parte nos metimos en el marcador.  Y para esto, SYNC tambi√©n es adecuado: tiene dos bits cero seguidos al final (son estados K).  Aqu√≠ los atraparemos.  Entonces, en el archivo drvasm.S, aparece un fragmento de c√≥digo desde la entrada de interrupci√≥n hasta foundK.  Adem√°s, debido al tiempo para verificar el estado del puerto, para una transici√≥n incondicional, etc., llegamos a la marca no al comienzo del bit, sino solo en el medio.  Pero no tiene sentido comprobar el mismo bit, porque ya sabemos su significado.  Por lo tanto, esperamos 8 ciclos de reloj (hasta ahora vac√≠o nop'ami) y verificamos el siguiente bit.  Si tambi√©n es cero, entonces hemos encontrado el final de SYNC y podemos proceder a la recepci√≥n de bits significativos. </p><br><p>  En realidad, todo el c√≥digo adicional est√° destinado a leer dos bytes m√°s con salida posterior a UART.  Bueno, esperando el estado de SE0 para no entrar accidentalmente en el siguiente paquete. </p><br><p>  Ahora puede compilar el c√≥digo resultante y ver qu√© bytes acepta nuestro dispositivo.  Personalmente, tengo la siguiente secuencia: </p><br><pre> <code class="plaintext hljs">4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00</code> </pre> <br><p>  Recuerde, estamos generando datos sin procesar, excluyendo ceros incrementales y decodificaci√≥n NRZI.  Intentemos decodificar manualmente, comenzando con el bit bajo: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  4E </td><td></td></tr><tr><td>  NRZI </td><td>  01001110 </td><td>  0 (bit anterior) </td></tr><tr><td>  byte </td><td>  00101101 </td><td></td></tr><tr><td></td><td>  2D </td><td></td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  55 </td><td></td></tr><tr><td>  NRZI </td><td>  01010101 </td><td>  0 (bit anterior) </td></tr><tr><td>  byte </td><td>  00000000 </td><td></td></tr><tr><td></td><td>  00 </td><td></td></tr></tbody></table></div><br><p>  No tiene sentido decodificar ceros, ya que 16 valores id√©nticos seguidos no se pueden incluir en un paquete. </p><br><p>  Por lo tanto, pudimos escribir firmware que acepta los primeros dos bytes del paquete, aunque hasta ahora sin decodificar. </p><br><h2 id="shag-2-demo-versiya-nrzi">  Paso 2. Versi√≥n demo de NRZI </h2><br><p>  Para no volver a codificar manualmente, puede confiar esto al controlador en s√≠: la operaci√≥n XOR hace exactamente lo que necesita, aunque el resultado se invierte, as√≠ que agregue otra inversi√≥n despu√©s: </p><br><pre> <code class="plaintext hljs">mov temp, shift lsl shift eor temp, shift com temp rcall uart_hex</code> </pre> <br><p>  El resultado es bastante esperado: </p><br><pre> <code class="bash hljs">2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF</code> </pre> <br><h2 id="shag-3-izbavlyaemsya-ot-cikla-priema-bayta">  Paso 3. Desh√°gase del ciclo de recepci√≥n de bytes </h2><br><p>  Vamos a dar un peque√±o paso m√°s y expandir el ciclo de recibir el primer byte en un c√≥digo lineal.  Por lo tanto, se obtienen muchos nops, solo se necesita esperar al comienzo del siguiente bit.  En lugar de algunos de ellos, puede usar el decodificador NRZI, otros ser√°n √∫tiles m√°s adelante. </p><br><p>  El resultado de la opci√≥n anterior no es diferente. </p><br><h2 id="shag-4-chitaem-v-bufer">  Paso 4. Leer al b√∫fer </h2><br><p>  Leer en registros separados es, por supuesto, r√°pido y hermoso, pero cuando hay demasiados datos, es mejor usar una entrada de b√∫fer ubicada en alg√∫n lugar de la RAM.  Para hacer esto, declararemos una matriz de tama√±o suficiente en el principal, y en la interrupci√≥n escribiremos all√≠. <br>  Inserto te√≥rico </p><br><p>  La estructura de paquetes en USB est√° estandarizada y consta de las siguientes partes: byte SYNC, byte PID + CHECK (2 campos de 4 bits cada uno), campo de datos (a veces 11 bits, pero m√°s a menudo un n√∫mero arbitrario de bytes de 8 bits) y una suma de verificaci√≥n CRC de 5 ( para un campo de datos de 11 bits), o 16 (para el resto) bits.  Finalmente, la indicaci√≥n de fin de paquete (EOP) es de dos bits de pausa, pero ya no se trata de datos. </p><br><p>  Antes de trabajar con la matriz, a√∫n necesita configurar los registros, y liberar nop antes del primer bit no es suficiente para esto.  Por lo tanto, tendr√° que colocar la lectura de los primeros dos bits en la secci√≥n lineal del c√≥digo, entre los comandos de los cuales insertaremos el c√≥digo de inicializaci√≥n, y luego saltaremos a la mitad del ciclo de lectura, a la etiqueta rxbit2.  Hablando del tama√±o del b√∫fer.  Seg√∫n la documentaci√≥n, no se pueden transferir m√°s de 8 bytes de datos en un paquete.  Agregamos los bytes de servicio PID y CRC16, obtenemos un tama√±o de b√∫fer de 11 bytes.  El byte SYNC y el estado EOP no se escribir√°n.  No podremos controlar el intervalo de solicitudes del host, pero tampoco queremos perderlas, por lo que tomaremos un doble margen para la lectura.  Por ahora, no usaremos todo el b√∫fer, pero para no regresar en el futuro, es mejor asignar inmediatamente el volumen requerido. </p><br><h2 id="shag-5-rabotaem-s-buferom-po-chelovecheski">  Paso 5. Trabajando con el buffer humanamente </h2><br><p>  En lugar de leer directamente los primeros bytes de la matriz, escribimos un fragmento de c√≥digo que lee exactamente tantos bytes como realmente se escribi√≥ en la matriz.  Y al mismo tiempo agregue un separador entre paquetes. <br>  Ahora la salida se ve as√≠: </p><br><pre> <code class="bash hljs">&gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF</code> </pre> <br><h2 id="shag-6-dobavlyaem-dobavku-dobavochnyh-nuley">  Paso 6. Agregar un Aditivo Aditivo Cero </h2><br><p>  Finalmente, es hora de terminar de leer el flujo de bits al est√°ndar.  El √∫ltimo elemento sin el que logramos administrar con √©xito fue un cero falso, agregado despu√©s de cada seis unidades consecutivas.  Como tenemos la recepci√≥n de bytes desplegada en el cuerpo lineal del bucle, debe verificar despu√©s de cada bit, en los ocho lugares.  Considere los dos primeros bits como ejemplo: </p><br><pre> <code class="plaintext hljs">unstuff0: ;1 (  breq) andi x3, ~(1&lt;&lt;0) ;1 [15]  0-  .     mov x1, x2 ;1 [16]      () in x2, USBIN ;1 [17] &lt;-- 1-   .     ori shift, (1&lt;&lt;0) ;1 [18]  0-   .1      rjmp didUnstuff0 ;2 [20] ;&lt;---//---&gt; rxLoop: eor shift, x3 ;1 [0] in x1, USBIN ;1 [1] st y+, shift ;2 [3] ldi x3, 0xFF ;1 [4] nop ;1 [5] eor x2, x1 ;1 [6] bst x2, USBMINUS ;1 [7]     0-   shift bld shift, 0 ;1 [8] in x2, USBIN ;1 [9] &lt;--  1- (, ) andi x2, USBMASK ;1 [10] breq se0 ;1 [11] andi shift, 0xF9 ;1 [12] didUnstuff0: breq unstuff0 ;1 [13] eor x1, x2 ;1 [14]; bst x1, USBMINUS ;1 [15]     1-   shift bld shift, 1 ;1 [16] rxbit2: in x1, USBIN ;1 [17] &lt;--  2-  (, ) andi shift, 0xF3 ;1 [18] breq unstuff1 ;1 [19] didUnstuff1:</code> </pre> <br><p>  Para la conveniencia de la navegaci√≥n, las etiquetas de la derecha contar√°n las direcciones de los comandos descritos.  Tenga en cuenta que se introdujeron para contar los ciclos de reloj del controlador, por lo que no est√°n en orden.  El siguiente byte se lee en la etiqueta rxLoop, el byte anterior se invierte y se escribe en el b√∫fer [0, 3].  A continuaci√≥n, en la etiqueta [1], se lee el estado de la l√≠nea D, de acuerdo con XOR con el estado aceptado previamente, decodificamos NRZI (recuerdo que XOR ordinario agrega su inversi√≥n, para fijar cu√°l ingresamos al registro de m√°scara x3, inicializado con unidades 0xFF) y escribimos a 0- con un poco del registro de desplazamiento [7,8].  Entonces comienza la diversi√≥n: verificamos si el bit recibido fue el sexto sin cambios.  El bit constante recibido con D- corresponde a escribir cero (¬°no uno! Cambiaremos a uno al final, XOR) en el registro.  Por lo tanto, debe verificar si los bits 0, 7, 6, 5, 4, 3 son ceros.  Los dos bits restantes no importan, permanecieron del byte anterior y se verificaron antes.  Para deshacernos de ellos, cortamos el registro mediante la m√°scara [12], donde todos los bits de inter√©s para nosotros se establecen en 1: 0b11111001 = 0xF9.  Si despu√©s de aplicar la m√°scara todos los bits resultan ser ceros, la situaci√≥n de agregar un bit es fija y hay una transici√≥n a la etiqueta unstuff0.  Un bit m√°s [17] se lee all√≠ en lugar de lo que se ley√≥ previamente, en el intervalo entre otras operaciones, de un exceso [9].  Tambi√©n intercambiamos los registros de los valores actuales y anteriores x1, x2.  El hecho es que en cada bit el valor se lee en un registro, y luego XOR est√° con otro, despu√©s de lo cual se intercambian los registros.  En consecuencia, al leer el registro incremental, esta operaci√≥n tambi√©n debe realizarse.  Pero lo m√°s interesante es que en el registro de datos de turno escribimos no el cero, que recibimos honestamente, sino la unidad que el host intent√≥ transferir [18].  Esto se debe al hecho de que al recibir los siguientes bits, tambi√©n se tendr√° que tener en cuenta el valor cero, y si registramos cero, la comprobaci√≥n de m√°scara no podr√≠a descubrir que el bit adicional ya se ha tenido en cuenta.  Por lo tanto, en el registro de desplazamiento, todos los bits se invierten (en relaci√≥n con los transmitidos por el host) y el cero no.  Para evitar tal desorden en el b√∫fer, realizaremos una inversi√≥n inversa de acuerdo con XOR no con 0xFF [0], sino con 0xFE, es decir, un registro en el que el bit correspondiente se restablecer√° a 0 y, en consecuencia, no conducir√° a la inversi√≥n.  Para hacer esto, en la muestra [15] y restablezca el bit cero. </p><br><p>  Una situaci√≥n similar ocurre con los bits 1-5.  Digamos, el primer bit corresponde a la verificaci√≥n 1, 0, 7, 6, 5, 4, mientras que los bits 2, 3 se ignoran.  Esto corresponde a la m√°scara 0xF3. <br>  Pero el procesamiento de 6 y 7 bits es diferente: </p><br><pre> <code class="plaintext hljs">didUnstuff5: andi shift, 0x3F ;1 [45]   5-0 breq unstuff5 ;1 [46] ;&lt;---//---&gt; bld shift, 6 ;1 [52] didUnstuff6: cpi shift, 0x02 ;1 [53]   6-1 brlo unstuff6 ;1 [54] ;&lt;---//---&gt; bld shift, 7 ;1 [60] didUnstuff7: cpi shift, 0x04 ;1 [61]   7-2 brsh rxLoop ;3 [63] unstuff7:</code> </pre> <br><p>  La m√°scara para el sexto bit es el n√∫mero 0b01111110 (0x7E), pero no puede superponerlo en el registro de desplazamiento, ya que restablecer√° el bit 0, que debe escribirse en la matriz.  Adem√°s, en la cuenta regresiva [45], una m√°scara ya estaba superpuesta, restableciendo 7 bits.  Por lo tanto, es necesario procesar el bit extra si los bits 1-6 son iguales a cero, y el 0¬∫ no importa.  Es decir, el valor del registro debe ser 0 o 1, que se verifica perfectamente comparando "menos de 2" [53, 54]. </p><br><p>  Se us√≥ el mismo principio para el s√©ptimo bit: en lugar de aplicar la m√°scara 0xFC, se realiza una comprobaci√≥n para "menos de 4" [61, 63]. </p><br><h2 id="shag-7-sortiruem-pakety">  Paso 7. Ordena los paquetes </h2><br><p>  Como podemos recibir un paquete con el primer byte (PID) igual a 0x2D (SETUP), intentaremos ordenar el recibido.  Por cierto, ¬øpor qu√© llam√© al paquete 0x2D SETUP cuando parece ser ACK?  El hecho es que la transmisi√≥n USB del bit menos significativo al m√°s significativo se lleva a cabo dentro de cada campo, y no byte, mientras aceptamos byte por byte.  El primer campo significativo, PID, ocupa solo 4 bits, seguido de 4 bits m√°s de COMPROBACI√ìN, que representan una inversi√≥n bit a bit del campo PID.  Por lo tanto, el primer byte recibido no ser√° PID + CHECK, sino CHECK + PID.  Sin embargo, no hay mucha diferencia, ya que todos los valores se conocen de antemano, y es f√°cil reorganizar los mordiscos en algunos lugares.  Inmediatamente, escribiremos los c√≥digos principales que pueden sernos √∫tiles en el archivo usbconfig.h. </p><br><p>  Todav√≠a no hemos comenzado a agregar el c√≥digo de procesamiento PID, tenga en cuenta que debe ser r√°pido (es decir, en el ensamblador), pero no se requiere la alineaci√≥n por relojes, porque ya hemos aceptado el paquete.  Por lo tanto, posteriormente esta secci√≥n se transferir√° al archivo asmcommon.inc, que contendr√° el c√≥digo del ensamblador que no est√° vinculado a la frecuencia.  Mientras tanto, solo resalte el comentario. <br>  Ahora pasemos a ordenar los paquetes recibidos. </p><br><blockquote>  <strong>Inserto te√≥rico</strong> <br>  Los paquetes de datos en el bus USB se combinan en transacciones.  Cada transacci√≥n comienza con el env√≠o por parte del host de un paquete marcador especial que contiene informaci√≥n sobre lo que el host desea hacer con el dispositivo: configurar (CONFIGURAR), transmitir datos (OUT) o recibirlos (IN).  Despu√©s de que se transmite el paquete marcador, sigue una pausa de dos bits.  Esto es seguido por un paquete de datos (DATA0 o DATA1), que pueden ser enviados tanto por el host como por el dispositivo, dependiendo del paquete marcador.  A continuaci√≥n, otra pausa de dos bits de longitud y la respuesta es HANDSHAKE, un paquete de confirmaci√≥n (ACK, NAK, STALL, los consideraremos en otro momento). <br><div class="scrollable-table"><table><thead><tr><th>  CONFIGURACI√ìN </th><th></th><th>  DATA0 </th><th></th><th>  Apret√≥n de manos </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausa </td><td>  host-&gt; dispositivo </td><td>  pausa </td><td>  dispositivo-&gt; host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  Fuera </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Apret√≥n de manos </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausa </td><td>  host-&gt; dispositivo </td><td>  pausa </td><td>  dispositivo-&gt; host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  En </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Apret√≥n de manos </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausa </td><td>  dispositivo-&gt; host </td><td>  pausa </td><td>  host-&gt; dispositivo </td></tr></tbody></table></div><br><br>  Como el intercambio contin√∫a en las mismas l√≠neas, el host y el dispositivo tienen que cambiar constantemente entre transmisi√≥n y recepci√≥n.  Obviamente, el retraso de dos bits es precisamente para este prop√≥sito y se hace para que no comiencen a jugar push-push, mientras intentan transferir simult√°neamente algunos datos al bus. </blockquote><p>  Entonces, conocemos todos los tipos de paquetes necesarios para el intercambio.  Agregamos una verificaci√≥n del byte PID recibido para el cumplimiento de cada uno.  Por el momento, el dispositivo a√∫n no puede escribir paquetes tan primitivos como ACK en el bus, lo que significa que no puede decirle al host qu√© es.  Por lo tanto, no se pueden esperar comandos como IN.  Por lo tanto, solo verificaremos la recepci√≥n de los comandos SETUP y OUT, para lo cual indicaremos la inclusi√≥n de los LED correspondientes en las ramas correspondientes. </p><br><p>  Adem√°s, vale la pena enviar los registros m√°s all√° de la interrupci√≥n, en alg√∫n lugar principal. </p><br><p>  Destellamos el dispositivo con lo que sucedi√≥ despu√©s de hacer estos cambios y observamos la siguiente secuencia de bytes recibidos: </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00 2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00</code> </pre> <br><p>  Y adem√°s, ambos LED encendidos.  Entonces, atrapamos SETUP y OUT. </p><br><h2 id="shag-8-chitaem-adres-na-konverte">  Paso 8. Lea la direcci√≥n en el sobre </h2><br><blockquote>  <strong>Inserto te√≥rico</strong> <br>  Los paquetes de marcadores (SETUP, IN, OUT) sirven no solo para mostrar al dispositivo lo que quieren de √©l, sino tambi√©n para dirigirse a un dispositivo espec√≠fico en el bus y a un punto final espec√≠fico dentro de √©l.  Los puntos finales son necesarios para resaltar funcionalmente una subfunci√≥n particular de un dispositivo.  Pueden variar en frecuencia de sondeo, tipo de cambio y otros par√°metros.  Digamos, si el dispositivo parece ser un adaptador USB-COM, su tarea principal es recibir datos del bus y transferirlos al puerto (primer punto final) y recibir datos del puerto y enviarlos al bus (segundo).  En t√©rminos de significado, estos puntos est√°n destinados a un gran flujo de datos no estructurados.  Pero adem√°s de esto, de vez en cuando, el dispositivo debe intercambiar con el host el estado de las l√≠neas de control (todo tipo de RTS, DTR, etc.) y la configuraci√≥n de intercambio (velocidad, paridad).  Y aqu√≠, no se esperan grandes cantidades de datos.  Adem√°s, es conveniente cuando la informaci√≥n del servicio no se mezcla con los datos.  Por lo tanto, resulta conveniente usar al menos 3 puntos finales para el adaptador USB-COM.  En la pr√°ctica, por supuesto, sucede de diferentes maneras ... <br>  Una pregunta igualmente interesante es por qu√© se env√≠a su direcci√≥n al dispositivo, porque aparte de eso, todav√≠a no puede pegar nada en este puerto en particular.  Esto se hace para simplificar el desarrollo de los concentradores USB.  Pueden ser bastante "tontos" y simplemente transmitir se√±ales desde el host a todos los dispositivos sin preocuparse por la clasificaci√≥n.  Y el dispositivo lo resolver√°, procesar√° el paquete o lo ignorar√°. <br>  Entonces, tanto la direcci√≥n del dispositivo como la direcci√≥n del punto final est√°n contenidas en los paquetes de marcadores.  La estructura de dichos paquetes se da a continuaci√≥n: <br>  el campo <br><div class="scrollable-table"><table><thead><tr><th>  el campo </th><th>  SINC </th><th>  addr </th><th>  punto final </th><th>  CRC </th><th>  Eop </th></tr></thead><tbody><tr><td>  Bits USB </td><td>  0-7 </td><td>  0123456 </td><td>  0123 </td><td>  01234 </td><td>  01 </td></tr><tr><td>  bits recibidos </td><td></td><td>  0123456 </td><td>  7012 </td><td>  34567 </td><td></td></tr></tbody></table></div><br><br>      ,    -   ( -  PID = SETUP  OUT)   (IN)  ,     . </blockquote><p>     ,       (-)     (Handshake) : </p><br><ul><li>  :     ,     ,  NAK   </li><li>  -:   SETUP  OUT,  ,  IN ‚Äî ,  </li><li>   .   ,              ,        ,        </li></ul><br><p>       ¬´ ‚Äî  ¬ª    .         PID',      ,     .     ¬´PID¬ª  .       usbCurrentTok.   PID'   (DATA0, DATA1)   ,      .      ,   ?  :    ,    ( 0   usbCurrentTok     ),    ,     .       ( SE0)      ,  -  ,     D+, D- .        ,       SYNC,   . ,             ,          .    ¬´¬ª    ,        .          . </p><br><p>        ,         .       x3,          (,     ,     ,         ). </p><br><p>    ,   USB    ,      ,              .     ,  ,     ,          CRC (      ).      ,      [21].       0-    .      ,    [26]. ,        CRC,        . </p><br><h2 id="shag-9-bezotkaznyy-priem">  9.   </h2><br><p>       ,       ,    ¬´ ¬ª,   ACK.         NAK',     (    cnt ‚Äî         ).   USB     ,   ,            SYNC  PID.       Y,           cnt (         ).     ,        ‚Äî ACK.       x3      ‚Äî    1 ,           .     x3 (  r20)    20. </p><br><p>        (     SETUP,     ),   ACK'  ,    ,        ,      . ,              . </p><br><p>   ,       D+, D- (      ),    ‚Äî .      XOR  ,      , ,  ,    -  . </p><br><p>  ,     ,     ,      ,   . ,    ,        ,           .        .   vusb   :  txBitloop   2    ([00], [08]).    3 ,  6 .       ,             .      1    3    :      171.       (    171,        11 ,    ),    ‚Äî ,    .    cnt=4: </p><br><p> 4 ‚Äî 171 = -167 = (   ) 89 (+ ) <br> 89 ‚Äî 171 = -82 = (   ) 174 (+ ) <br> 174 ‚Äî 171 = 3.     ,     <br>       ,      . </p><br><p>  ,   3 ,      1.      6       ,    ,      x4.        D+, D-   ,     . . <br>          : </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 69|00|10|00|01|00|00|40|00</code> </pre> <br><p>    C3 .  ,       ,      UART   . ,  ,       IN ,       . ,    . </p><br><h2 id="shag-10-posylaem-hosta-nak">  10.   NAK </h2><br><p>    NAK    ,       .      ,      .       ,  -       . </p><br><p>      ,      .    ,  ,   -    ,     .        usbRxBuf,    .        ,   ‚Äî  ,     USB_BUFSIZE.        usbInputBufOffset,            .        . </p><br><p>   NAK    handleData      ,        [22].            (usbRxLen),     - .       (   ‚Äî    ),       usbRxLen,  ,      ‚Äî  usbRxToken,   SETUP  OUT - .   :        ,     ,   ACK . </p><br><p>                  .   ,     ,     -    ,  -,    .         ?    ,   ,    ,   ,    -    . </p><br><p>  ,     </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00</code> </pre> <br><p>     ,    NAK`,    ,     . </p><br><h2 id="shag-11-obrabatyvaem-zaprosy">  11.   </h2><br><p>     , ,        .       ‚Äî         .     ,      ,     , ,  ,     .            .        .         ,    USB,           usbPoll.  ‚Äî      ,     .    ‚Äî     .      SETUP ,     PID  CRC,    SETUP  5-  ,     16-.      3 ¬´¬ª . ¬´¬ª   PID      usbRxToken,  CRC   ,         ,  .        usbProcessRx,      ,       . </p><br><p>  ,   ,        ‚Äî  ,     SE0.   ,     USB      . </p><br><p>     .        SETUP,           .        .  SETUP    usbRequest_t    8 .      :  (    USB-)  ,     - .         ,     .           . <br>      , ,  ,  . </p><br><h2 id="shag-12-podrobnosti-setupa">  12.  SETUP' </h2><br><p> ,  ,      .     .     usbDriverSetup,         . ,      . ,      (    ,     ,            )   . ,           : ACK  NAK,        . </p><br><h2 id="shag-13-otpravlyaem-otvet">  13.   </h2><br><p>    ,      SETUP + DATAx,    DATAx   8 .        IN      DATAx,     .         ,     .        ,      ACK  NAK.           ,       .   ‚Äî    usbTxBuf,   ,   usbTxLen   .  low-speed USB          8  ( PID,    CRC),    usbTxLen      11.      PID,   ,      . ,     16,   , 0x0F,   .    PID      ,       .        IN,   ,       (handshake    ,    ). </p><br><p>      : <br>   SETUP + DATAx,    ACK  NAK      . , ,  usbPoll,   ,        (       PID=DATA1 (  DATA0  DATA1   ,     ,     DATA1).   CRC  .       ,    ,   -   .           ‚Äî 4 .  ,    3 ,   4.   ,   SYNC       .          ¬´   IN   NAK?¬ª     NAK.      ,     , DATA1   . </p><br><p>      ,     ‚Äî USBRQ_SET_ADDRESS (   ,    ).          .          (drvsdm.S,  make SE0).     ,              ,   ,      DATA1    ,  ,          . ,   ,           ,    ,           ,        .       ,         ,      . </p><br><h2 id="shag-14-sortiruem-standartnye-zaprosy">  14.    </h2><br><p>    ,        .   ,    USBRQ_GET_DESCRIPTOR  USBRQ_SET_ADDRESS, ,    .    usbDriverDescriptor,    .        ,   USBRQ_GET_DESCRIPTOR.  ,    , : </p><br><p> USBDESCR_DEVICE ‚Äî   :   USB (1.1   ),  , ,    . . <br> USBDESCR_CONFIG ‚Äî ,     ,    . . <br> USBDESCR_STRING ‚Äî   ,   . <br> ,   ,       USBDESCR_DEVICE,  ,        . </p><br><h2 id="shag-15-zapolnyaem-anketnye-dannye">  15.    </h2><br><p>       . -,     .      ,   - - , , HID,      ,        .     Vendor ID  Product ID,      USB,     .  ,  vusb            . </p><br><p>     , , - .    ,       ,    ,        (, )      usbMsgPtr,   ‚Äî   len,     usbMsgLen.      (     )  18 ,       8. ,    ,  3 .       - ,  STALL. </p><br><p>           usbDeviceRead.   ,       memcpy_P,             ,  , . </p><br><p>   ,      ,  ,      .    ,      ,        . </p><br><p>       ,     ,  . </p><br><blockquote> <strong> </strong> <br>  PID'  DATA0  DATA1       .  PID'     ,          ,  -       . </blockquote><p>       ,  DATA0 / DATA1    (        ),     , ,   3 ,    .     XOR    PID',   .      ,        ,   XOR'    .     PID  DATA1,   XOR    PID   ,   XOR  DATA0    . </p><br><p>      ,    ,     USBDESCR_CONFIG. </p><br><h2 id="shag-16-nakonec-to-ustroystvo">  16. - ! </h2><br><p>   USBDESCR_CONFIG      USBDESCR_DEVICE.     (   ,        )  .   , -     USB-,     ,   D+, D-. </p><br><p>        ,      : , ,   .    ,        (    ,    ).  ,      UTF-16,       .     USB     UTF-8  . </p><br><p>   vusb       ,     lsusb    .    VID, PID      ,        .         ,        VID, PID,     ‚Äî      . </p><br><p> ,         ,      (    ).       SETUP:   ,        ,     .   0,       ,    ‚Äî      . ,     ,       ,  . <br>        . </p><br><h2 id="shag-17-ustroystvo-stanovitsya-chelovechnee-hid">  17.    (HID) </h2><br><blockquote> <strong> </strong> <br> HID ‚Äî human interface device,   ,       ,     .    HID   ,       .  ,      ,   , , ,       .    ¬´¬ª     .      HID     ( low-speed      800   ),        . </blockquote><p>     HID     ,     USBDESCR_HID_REPORT.          vusb,      . ,   usbDriverSetup ( )   usbFunctionSetup ( ).  ,      SETUP,         OUT.      ,         , ,   usbFunctionWrite. </p><br><p>     ,  usbDeviceRead  usbFunctionRead,           .   ,    ,   usbFunctionSetup  (  ,   )   USB_FLG_USE_USER_RW,   usbDriverSetup   . </p><br><p>    ‚Äî      ‚Äî    usbFunctionWrite  usbFunctionRead.          .   ‚Äî      ,       . </p><br><p>       usbDriverSetup. </p><br><h2 id="shag-18-obschaemsya-s-zhelezkoy">  18.    </h2><br><p>  ,      ,        .     HID,    ,   ,      (        udev  - ).  ,        ,   .        ,   ,   ,     . <br> UPD:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ramzes2</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HIDAPI</a> </p><br><p>           . </p><br><h2 id="shag-19-sravnivaem-s-vusb">  19.   vusb </h2><br><p>     vusb              ,   . </p><br><p> drvasm.S   - usbdrvasm.S  asmcommon.inc,   -,   , usbdrvasm12.inc ‚Äî usbdrvasm20.inc. </p><br><p> main.c    main.c ( )  usbdrv.c (  vusb) <br> usbconfig.h      (     ),   ,  ,   usbconfig.h. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>      vusb,            ,   ,    .  ,    ,      . . ,     ,     ,    USB-HID.   ,   ,  ,            vusb,     ,  , ,      . </p><br><h2 id="ispolzovannaya-literatura-i-poleznye-ssylki">      </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.obdev.at/products/vusb/index.html</a> (  vusb) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html</a> <br>  ..  USB:     <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://radiohlam.ru/tag/usb/</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-1-vvodnaya.html</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://usb.fober.net/cat/teoriya/</a> </p><br><p> PS -     (,      )     ,   </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460815/">https://habr.com/ru/post/460815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460803/index.html">Lectura para el verano: libros para t√©cnicos</a></li>
<li><a href="../460805/index.html">C√≥mo transferir datos entre microcontroladores a 100 Mbps</a></li>
<li><a href="../460807/index.html">Mida siete veces, una vez que implemente la herramienta de BI</a></li>
<li><a href="../460811/index.html">Componentes comunes de diferentes equipos. Informe Yandex</a></li>
<li><a href="../460813/index.html">C√≥mo usar diagramas de Voronoi para controlar la IA</a></li>
<li><a href="../460819/index.html">WorldSkills: Revisi√≥n del participante de la Olimpiada.</a></li>
<li><a href="../460821/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 307 (15-21 de julio)</a></li>
<li><a href="../460823/index.html">Eventos digitales en Mosc√∫ del 22 al 28 de julio.</a></li>
<li><a href="../460825/index.html">Introducci√≥n a la API de captura de pantalla: escanee c√≥digos QR en un navegador</a></li>
<li><a href="../460827/index.html">Problema PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>