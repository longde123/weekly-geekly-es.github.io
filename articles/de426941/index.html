<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏾 ↖️ 😃 Zur Frage der Geschwindigkeit und Messung in Arduino 🚵🏽 👩‍🎤 Ⓜ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieses Problem trat bei der Untersuchung der Leistung von Arduino bei der Ausführung verschiedener Befehle auf (mehr dazu in einem separaten Beitrag)....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zur Frage der Geschwindigkeit und Messung in Arduino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426941/"><img src="https://habrastorage.org/webt/kx/oe/cl/kxoecl7ngezzej1ftzcleeswzde.jpeg"><br><br>  Dieses Problem trat bei der Untersuchung der Leistung von Arduino bei der Ausführung verschiedener Befehle auf (mehr dazu in einem separaten Beitrag).  Im Verlauf der Studie traten Zweifel an der Konstanz der Arbeitszeit einzelner Befehle auf, als sich der Wert der Operanden änderte (wie sich später herausstellte, nicht unangemessen) und beschlossen wurde, die Ausführungszeit eines separaten Befehls abzuschätzen.  Zu diesem Zweck wurde ein kleines Programm geschrieben (das sagte, die Skizze soll die Klasse verlassen), das auf den ersten Blick die Hypothese bestätigte.  Abschließend können Sie die Werte 16 und 20 beobachten, aber manchmal werden 28 und sogar 32 Mikrosekunden gefunden.  Wenn wir die empfangenen Daten mit 16 (MK-Taktfrequenz) multiplizieren, erhalten wir die Ausführungszeit in MK-Zyklen (von 256 bis 512).  Leider führt ein wiederholter Durchlauf des Hauptprogrammzyklus (mit denselben Anfangsdaten) unter Beibehaltung des Gesamtbildes bereits zu einer unterschiedlichen Verteilung der Ausführungszeit, sodass die tatsächlichen Zeitschwankungen nicht mit den Anfangsdaten zusammenhängen.  Die ursprüngliche Hypothese wird widerlegt, aber sie wird interessant und was genau mit einer solch signifikanten Streuung verbunden ist. <br><a name="habracut"></a><br>  Notwendiger Hinweis - Ich verstehe sehr gut, dass komplexere Programme verwendet werden sollten, um die Ausführungszeit von Befehlen zu messen. Für eine grobe Beurteilung ist jedoch eine, die später demonstriert wird, völlig ausreichend. <br><br>  Die Zeit ändert sich also und wir suchen nach den Ursachen für dieses Phänomen.  Zunächst achten wir auf die Vielzahl der erhaltenen Werte, sehen uns die Beschreibung der Arbeitsbibliothek im Zeitverlauf an und stellen fest, dass 4 µs ein Messquantum ist. Es ist daher besser, zu Quanten zu gehen und zu verstehen, dass wir 4 oder 5 (sehr oft) und 6 oder 7 oder erhalten 8 (sehr seltene) Einheiten.  Mit der ersten Hälfte ist alles einfach - wenn der gemessene Wert zwischen 4 und 5 Einheiten liegt, wird die Streuung unvermeidlich.  Wenn wir die Proben als unabhängig betrachten, können wir außerdem die Messgenauigkeit durch statistische Methoden erhöhen, was wir tun, um akzeptable Ergebnisse zu erzielen. <br><br>  Aber mit der zweiten Hälfte (6,7,8) ist es schlimmer.  Wir haben festgestellt, dass die Streuung nicht mit den Quelldaten korreliert, was bedeutet, dass dies eine Manifestation anderer Prozesse ist, die die Ausführungszeit von Befehlen beeinflussen.  Es ist zu beachten, dass Emissionen eher selten sind und keinen signifikanten Einfluss auf den berechneten Durchschnittswert haben.  Es wäre möglich, sie überhaupt zu vernachlässigen, aber das ist nicht unser Stil.  Im Allgemeinen habe ich im Laufe der jahrelangen Arbeit im Ingenieurwesen festgestellt, dass Sie keine Missverständnisse hinterlassen können, egal wie unbedeutend sie erscheinen, da sie eine widerliche Fähigkeit haben, im ungünstigsten Moment in den Rücken zu schlagen (na ja, oder wo sie sonst hin gelangen). <br><br>  Wir fangen an, <b>Hypothese 1 aufzustellen</b> - die bequemste (in Bezug auf Bequemlichkeit und Vielseitigkeit ist sie nach dem direkten Eingreifen des Erstellers an zweiter Stelle) - Softwareprobleme natürlich nicht meine, meine Programme scheitern nie, sondern verbundene Bibliotheken (Compiler, Betriebssystem, Browser usw.). - das Notwendige ersetzen).  Da ich das Programm im Emulator unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.tinkercad.com ausführe</a> , können Sie außerdem auf die Emulatorfehler verweisen und das Thema schließen, da uns die Quellen nicht zur Verfügung stehen.  Nachteile dieser Hypothese: <br><br><ol><li>  Von Zyklus zu Zyklus ändert sich der Ort der Abweichungen, was darauf hindeutet. </li><li>  Diese Seite unterstützt weiterhin AutoDesk, obwohl das Argument eher schwach ist. </li><li>  "Wir haben das Postulat akzeptiert, dass das, was passiert, keine Halluzination ist, sonst wäre es einfach uninteressant." </li></ol><br>  Die nächste Annahme ist der Einfluss einiger Hintergrundprozesse auf das Messergebnis.  Wir scheinen nichts anderes zu tun, als zu glauben, aber ... wir geben die Ergebnisse in seriell aus.  <b>Hypothese 2</b> entsteht - die Ausgabezeit wird manchmal (so seltsam ... aber es passiert) zur Ausführungszeit des Befehls hinzugefügt.  Es ist zwar zweifelhaft, wie viel diese Ausgabe vorhanden ist, aber dennoch - das Hinzufügen von Flush hat nicht geholfen, das Hinzufügen einer Verzögerung zum Vervollständigen der Ausgabe hat nicht geholfen und im Allgemeinen die Ausgabe aus der Schleife verschoben - ohnehin Zeitsprünge - dies ist definitiv nicht seriell. <br><br>  Nun, was bleibt, ist die Organisation des Zyklus selbst (von dem ein Schrecken ist, seine Dauer zu ändern, es ist nicht klar) und das ist alles ... obwohl micros () geblieben ist.  Ich meinte, dass die Ausführungszeit des ersten Aufrufs dieser Funktion und des zweiten gleich ist und wenn ich diese beiden Werte subtrahiere, bekomme ich Null, aber wenn diese Annahme falsch ist? <br><br>  Hypothese 3 - Manchmal dauert der zweite Aufruf der Zeitzählung länger als der erste, oder die mit der Zeitzählung verbundenen Aktionen wirken sich manchmal auf das Ergebnis aus.  Wir schauen uns den Quellcode der Funktion des Arbeitens mit der Zeit an (arduino-1.8.4 \ hardware \ arduino \ avr \ cores \ arduino \ wiring.c - Ich habe wiederholt meine Einstellung zu solchen Dingen zum Ausdruck gebracht, ich werde mich nicht wiederholen) und wir sehen, dass 1 von 256 Mal Zyklen der Hardwareerhöhung des jüngeren Teils des Zählers werden unterbrochen, um den älteren Teil des Zählers zu erhöhen. <br><br>  Unsere Zyklusausführungszeit beträgt 4 bis 5, sodass wir 170 * (4..5) / 256 = drei bis vier anomale Werte in einem Segment von 170 Messungen erwarten können.  Wir sehen aus - es sieht sehr ähnlich aus, es gibt wirklich 4 davon.  Um den ersten und den zweiten Grund zu trennen, führen wir Berechnungen nach dem kritischen Abschnitt mit verbotenen Unterbrechungen durch.  Das Ergebnis ändert sich nicht viel, Emissionen haben immer noch einen Platz, was bedeutet, dass Mikros zusätzliche Zeit einbringen ().  Hier können wir nichts tun, obwohl der Quellcode verfügbar ist, können wir ihn nicht ändern - Bibliotheken sind in den Binärdateien enthalten.  Natürlich können wir unsere eigenen Funktionen für die Arbeit mit der Zeit schreiben und ihr Verhalten beobachten, aber es gibt einen einfacheren Weg. <br><br>  Da die „lange“ Verarbeitung des Interrupts ein möglicher Grund für die Verlängerung der Dauer ist, schließen wir die Möglichkeit seines Auftretens während des Messvorgangs aus.  Warten Sie dazu auf seine Manifestation und führen Sie erst dann einen Messzyklus durch.  Da die Unterbrechung viel seltener auftritt als unser Messzyklus dauert, können wir ihre Abwesenheit garantieren.  Wir schreiben das entsprechende Fragment des Programms (unter Verwendung von <s>Dirty Hacks mit</s> Informationen, die aus dem Quellcode extrahiert wurden) und "das ist solche Straßenmagie", alles wird normal - wir messen die Ausführungszeit von 4 und 5 Quanten mit einem Durchschnittswert der Ausführungszeit der Additionsoperation mit PT von 166 Taktzyklen, die entspricht dem zuvor gemessenen Wert.  Die Hypothese kann als bestätigt angesehen werden. <br><br>  Eine weitere Frage bleibt offen - und was dauert bei Unterbrechungen so lange, was dauert es? <br>  (7.8) - (5) ~ 2 Quanten = * 4 = 8 ms * 16 = 128 Prozessorzyklen?  Wir wenden uns dem Quellcode zu (dh dem Assembler-Code, der vom Compiler auf godbolt.com generiert wurde) und sehen, dass der Interrupt selbst ungefähr 70 Zyklen ausgeführt wird, 60 davon konstant, und beim Lesen entstehen zusätzliche Kosten von 10 Zyklen, insgesamt 70, wenn er aktiviert wird Unterbrechung - weniger als empfangen, aber nah genug.  Wir führen den Unterschied auf den Unterschied zwischen Compilern oder Verwendungsmodi zurück. <br><br>  Nun können wir die tatsächliche Ausführungszeit des PT-Additionsbefehls mit verschiedenen Argumenten messen und sicherstellen, dass sich beim Ändern der Argumente wirklich viel ändert: von 136 Takten für 0,0 bis 190 für 0,63 (magische Zahl), und dies ist nur 162 für 10,63.  Mit einer Wahrscheinlichkeit von 99,9% ist dies auf die Notwendigkeit der Ausrichtung und die Merkmale ihrer Implementierung in dieser speziellen Bibliothek zurückzuführen, aber diese Studie geht eindeutig über den Rahmen des betrachteten Problems hinaus. <br><br><div class="spoiler">  <b class="spoiler_title">Anhang - Programmtext:</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> setup() { <span class="hljs-type"><span class="hljs-type">Serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">9600</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> t; //   <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { <span class="hljs-type"><span class="hljs-type">int</span></span> d[<span class="hljs-number"><span class="hljs-number">170</span></span>]; unsigned long <span class="hljs-type"><span class="hljs-type">time</span></span>,time1; <span class="hljs-type"><span class="hljs-type">float</span></span> dt=<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">170.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">170</span></span>; ++i) { { //       time1=micros(); long time2; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { time2=micros(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((time2 &amp; ~<span class="hljs-number"><span class="hljs-number">0xFF</span></span>) == (time1 &amp; ~<span class="hljs-number"><span class="hljs-number">0xFF</span></span>)); }; <span class="hljs-comment"><span class="hljs-comment">/**/</span></span> time1=micros(); //   <span class="hljs-comment"><span class="hljs-comment">/* cli(); //       -   */</span></span> t=<span class="hljs-number"><span class="hljs-number">10.63</span></span>; //     t=t+dt; //   <span class="hljs-comment"><span class="hljs-comment">/* sei(); //    */</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = micros(); //   time1=<span class="hljs-type"><span class="hljs-type">time</span></span>-time1; d[i]=time1/<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Serial.print(time1); //      Serial.flush(); //     Delay(20); //    */</span></span> }; //   ,     <span class="hljs-type"><span class="hljs-type">float</span></span> sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">170</span></span>; ++i) { sum+=d[i]; <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println(d[i]); }; <span class="hljs-type"><span class="hljs-type">Serial</span></span>.println((sum/<span class="hljs-number"><span class="hljs-number">170</span></span><span class="hljs-number"><span class="hljs-number">-2.11</span></span>)*<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">16</span></span>); //<span class="hljs-number"><span class="hljs-number">2.11</span></span> –     <span class="hljs-type"><span class="hljs-type">Serial</span></span>.flush(); //    ,     }</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426941/">https://habr.com/ru/post/de426941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426931/index.html">Wie man in 3 Jahren an der Côte d'Azur arbeitet und einen französischen Pass bekommt</a></li>
<li><a href="../de426933/index.html">Frontend-Design</a></li>
<li><a href="../de426935/index.html">+10 Regeln für sauberen Code vom Angular-Entwickler</a></li>
<li><a href="../de426937/index.html">Bionische Glieder lernen, Bier zu öffnen</a></li>
<li><a href="../de426939/index.html">Der Doktorand löste das Problem der Bestätigung des Quantencomputers</a></li>
<li><a href="../de426943/index.html">Die umfassendste russische Übersetzung des Harvard Programming Course CS50 2015, kostenlos auf YouTube</a></li>
<li><a href="../de426945/index.html">Was mir an Paul Allen gefallen hat</a></li>
<li><a href="../de426947/index.html">"Der Teufel hat mich gezogen, um im Büro zu arbeiten" - 10 Fragen an den Programmierer, 9. Auflage</a></li>
<li><a href="../de426949/index.html">THX Deep Note Sound neu erstellen</a></li>
<li><a href="../de426951/index.html">Altium Designer: Was tun, wenn ein Projekt kompliziert wird?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>