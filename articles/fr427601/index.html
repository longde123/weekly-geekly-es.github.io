<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèæ ü¶Ç üë®‚Äçüë®‚Äçüë¶ Cas 5 + 1 o√π la sp√©cification de l'API REST joue un r√¥le √©norme üì≠ üëáüèæ üéµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentrera sur l'√©criture et la prise en charge d'une sp√©cification utile et pertinente pour un projet d'API REST, ce qui permettra d'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cas 5 + 1 o√π la sp√©cification de l'API REST joue un r√¥le √©norme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> Cet article se concentrera sur l'√©criture et la prise en charge d'une sp√©cification utile et pertinente pour un projet d'API REST, ce qui permettra d'√©conomiser beaucoup de code suppl√©mentaire, ainsi que d'am√©liorer s√©rieusement l'int√©grit√©, la fiabilit√© et la transparence du projet dans son ensemble. </p><br><h3 id="chto-takoe-restful-api">  Qu'est-ce qu'une API RESTful? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  Ceci est un mythe. </p><br><p>  S√©rieusement, si vous pensez que votre projet a une API RESTful, vous vous trompez certainement.  L'id√©e de RESTful est de construire une API qui √† tous √©gards respecte les r√®gles et restrictions architecturales d√©crites par le style REST, mais en conditions r√©elles, cela est <em>presque impossible</em> . </p><a name="habracut"></a><br><p>  D'une part, REST contient trop de d√©finitions vagues et ambigu√´s.  Par exemple, certains termes des dictionnaires des m√©thodes HTTP et des codes d'√©tat ne sont pas utilis√©s dans la pratique pour leur usage pr√©vu, alors que beaucoup d'entre eux ne sont pas du tout utilis√©s. </p><br><p>  D'un autre c√¥t√©, REST cr√©e trop de restrictions.  Par exemple, l'utilisation atomique des ressources dans le monde r√©el n'est pas rationnelle pour les API utilis√©es par les applications mobiles.  Un refus total de stocker l'√©tat entre les requ√™tes est essentiellement une interdiction du m√©canisme des sessions utilisateur utilis√©es dans de nombreuses API. </p><br><p>  <strong>Mais attendez, tout n'est pas si mal!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  Pourquoi avons-nous besoin de la sp√©cification REST API? </h3><br><p>  Malgr√© ces lacunes, avec une approche raisonnable, REST reste toujours une excellente base pour concevoir des API vraiment cool.  Une telle API doit avoir une uniformit√© interne, une structure claire, une documentation pratique et une bonne couverture des tests unitaires.  Tout cela peut √™tre r√©alis√© en d√©veloppant une <strong>sp√©cification de</strong> qualit√© pour votre API. </p><br><p>  Le plus souvent, <em>la sp√©cification de l'</em> API REST <em>est</em> associ√©e √† sa <em>documentation</em> .  Contrairement √† la premi√®re (qui est une description formelle de votre API), la documentation est destin√©e √† √™tre lue par des personnes: par exemple, les d√©veloppeurs d'une application mobile ou Web utilisant votre API. </p><br><p>  Cependant, en plus de cr√©er r√©ellement de la documentation, une description correcte de l'API peut toujours apporter de nombreux avantages.  Dans l'article, je veux partager des exemples de la fa√ßon dont, en utilisant l'utilisation comp√©tente de la sp√©cification, vous pouvez: </p><br><ul><li>  rendre les tests unitaires plus simples et plus fiables; </li><li>  configurer le pr√©traitement et la validation des donn√©es d'entr√©e; </li><li>  automatiser la s√©rialisation et garantir l'int√©grit√© des r√©ponses; </li><li>  et m√™me profiter de la frappe statique. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  Le format g√©n√©ralement accept√© pour d√©crire l'API REST aujourd'hui est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>OpenAPI</strong></a> , √©galement connu sous le nom de <em>Swagger</em> .  Cette sp√©cification est un fichier unique au format JSON ou YAML, compos√© de trois sections: </p><br><ul><li>  un en-t√™te contenant le nom, la description et la version de l'API, ainsi que des informations suppl√©mentaires; </li><li>  une description de toutes les ressources, y compris leurs identifiants, les m√©thodes HTTP, tous les param√®tres d'entr√©e, ainsi que les codes et les formats du corps de r√©ponse, avec des liens vers les d√©finitions; </li><li>  toutes les d√©finitions d'objets au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JSON Schema</strong></a> qui peuvent √™tre utilis√©es √† la fois dans les param√®tres d'entr√©e et dans les r√©ponses. </li></ul><br><p>  OpenAPI a un s√©rieux inconv√©nient - la <em>complexit√© de la structure et, souvent, la redondance</em> .  Pour un petit projet, le contenu du fichier JSON de sp√©cification peut rapidement atteindre plusieurs milliers de lignes.  Il n'est pas possible de g√©rer ce fichier manuellement dans ce formulaire.  C'est une menace s√©rieuse pour l'id√©e m√™me de maintenir une sp√©cification √† jour √† mesure que l'API √©volue. </p><br><p>  Il existe de nombreux √©diteurs visuels qui vous permettent de d√©crire l'API et de former la sp√©cification OpenAPI r√©sultante.  √Ä leur tour, des services et des solutions cloud suppl√©mentaires sont bas√©s sur eux, par exemple <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet</em> et autres. </p><br><p>  Cependant, pour moi, ces services n'√©taient pas tr√®s pratiques en raison de la difficult√© de modifier rapidement la sp√©cification et de la combiner avec le processus d'√©criture de code.  Un autre inconv√©nient est la d√©pendance √† l'√©gard de l'ensemble des fonctions de chaque service particulier.  Par exemple, il est presque impossible de mettre en ≈ìuvre des tests unitaires √† part enti√®re uniquement au moyen d'un service cloud.  La g√©n√©ration de code et m√™me la cr√©ation de "plugs" pour les terminaux, bien que cela semble tr√®s possible, sont pratiquement inutiles dans la pratique. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  Dans cet article, j'utiliserai des exemples bas√©s sur le format de description de l'API REST native - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>tinyspec</strong></a> .  Le format est de petits fichiers qui d√©crivent les points de terminaison et les mod√®les de donn√©es utilis√©s dans le projet avec une syntaxe intuitive.  Les fichiers sont stock√©s √† c√¥t√© du code, ce qui vous permet de v√©rifier avec eux et de les modifier en cours d'√©criture.  Dans le m√™me temps, tinyspec est automatiquement compil√© dans une OpenAPI √† part enti√®re, qui peut √™tre imm√©diatement utilis√©e dans le projet.  Il est temps de vous dire exactement comment. </p><br><p>  Dans cet article, je donnerai des exemples de Node.js (koa, express) et Ruby on Rails, bien que ces pratiques s'appliquent √† la plupart des technologies, y compris Python, PHP et Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  Quand la sp√©cification est incroyablement utile </h2><br><h3 id="1-unit-testy-endpointov">  1. Tests unitaires des points finaux </h3><br><p>  <em>Le d√©veloppement bas√© sur le comportement (BDD) est</em> id√©al pour d√©velopper une API REST.  Le moyen le plus pratique d'√©crire des tests unitaires n'est pas pour des classes, mod√®les et contr√¥leurs individuels, mais pour des points de terminaison sp√©cifiques.  Dans chaque test, vous √©mulez une v√©ritable requ√™te HTTP et v√©rifiez la r√©ponse du serveur.  Dans Node.js, pour √©muler les demandes de test, il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">supertest</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://www.chaijs.com/plugins/chai-">chai-http</a> , dans Ruby on Rails - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">airborne</a> . </p><br><p> Supposons que nous ayons un sch√©ma d' <code>User</code> et un point de terminaison <code>GET /users</code> qui renvoie tous les utilisateurs.  Voici la syntaxe tinyspec qui d√©crit ceci: </p><br><ol><li>  Fichier <em>User.models.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  Fichier <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  Voici √† quoi ressemblera notre test: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Lorsque nous avons une sp√©cification qui d√©crit les formats de r√©ponse du serveur, nous pouvons simplifier le test et <em>v√©rifier</em> simplement <em>la r√©ponse par rapport √† cette sp√©cification</em> .  Pour ce faire, nous profiterons du fait que nos mod√®les tinyspec sont transform√©s en d√©finitions OpenAPI, qui √† leur tour correspondent au format de sch√©ma JSON. </p><br><p>  Tout <em>objet litt√©ral</em> en JS (ou <code>Hash</code> en Ruby, un <code>dict</code> en Python, <em>un tableau associatif</em> en PHP et m√™me une <code>Map</code> en Java) peut √™tre test√© pour la conformit√© avec un sch√©ma JSON.  Et il existe m√™me des plugins correspondants pour tester les frameworks, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jest-ajv</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chai-ajv-json-schema</a> (npm) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">json_matchers</a> (rubygem) pour RSpec. </p><br><p>  Avant d'utiliser les sch√©mas, vous devez les connecter au projet.  Tout d'abord, nous allons g√©n√©rer le fichier de sp√©cifications openapi.json bas√© sur tinyspec (cette action peut √™tre effectu√©e automatiquement avant chaque ex√©cution de test): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Maintenant, nous pouvons utiliser le JSON re√ßu dans le projet et en extraire la cl√© de <code>definitions</code> , qui contient tous les sch√©mas JSON.  Les sch√©mas peuvent contenir des r√©f√©rences crois√©es ( <code>$ref</code> ), par cons√©quent, si nous avons des sch√©mas imbriqu√©s (par exemple, <code>Blog {posts: Post[]}</code> ), nous devons les "d√©velopper" afin de les utiliser dans les validations.  Pour ce faire, nous utiliserons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code> peut g√©rer les liens <code>$ref</code> , mais n√©cessite des fichiers s√©par√©s avec des sch√©mas dans le syst√®me de fichiers d'une certaine mani√®re, donc vous devez d'abord "diviser" <code>swagger.json</code> en plusieurs petits fichiers (plus √† ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  Apr√®s cela, nous pouvons √©crire notre test comme ceci: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Remarque: l'√©criture de tests de cette mani√®re est incroyablement pratique.  Surtout si votre IDE prend en charge l'ex√©cution de tests et le d√©bogage (tels que WebStorm, RubyMine et Visual Studio).  Ainsi, vous ne pouvez pas utiliser d'autre logiciel du tout, et le cycle de d√©veloppement complet de l'API est r√©duit √† 3 √©tapes cons√©cutives: </p><br><ol><li>  conception des sp√©cifications (par exemple dans tinyspec); </li><li>  √©crire un ensemble complet de tests pour les points d'extr√©mit√© ajout√©s / modifi√©s; </li><li>  d√©velopper du code qui satisfait tous les tests. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Validation des entr√©es </h3><br><p>  OpenAPI d√©crit le format non seulement des r√©ponses, mais aussi des donn√©es d'entr√©e.  Cela nous permet de <em>valider les donn√©es</em> re√ßues du droit de l'utilisateur lors de la demande. </p><br><p>  Supposons que nous ayons la sp√©cification suivante qui d√©crit la mise √† jour des donn√©es utilisateur, ainsi que tous les champs qui peuvent √™tre modifi√©s: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Plus t√¥t, nous avons examin√© les plugins pour la validation dans les tests, mais pour les cas plus g√©n√©raux, il existe des modules de validation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajv</a> (npm) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">json-schema</a> (rubygem), utilisons-les et √©crivons un contr√¥leur avec validation. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  Ceci est un exemple pour <strong>Koa</strong> , le successeur d'Express, mais pour Express, le code sera similaire. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  Dans cet exemple, si les donn√©es d'entr√©e ne r√©pondent pas √† la sp√©cification, le serveur renverra une r√©ponse <code>500 Internal Server Error</code> au client.  Pour √©viter que cela ne se produise, nous pouvons intercepter l'erreur du validateur et former notre propre r√©ponse, qui contiendra des informations plus d√©taill√©es sur des champs sp√©cifiques qui n'ont pas r√©ussi le test, et √©galement <em>conforme √† la sp√©cification</em> . </p><br><p>  Ajoutez une description du mod√®le <code>FieldsValidationError</code> dans le fichier <code>FieldsValidationError</code> : </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  Et maintenant, nous l'indiquons comme l'une des r√©ponses possibles de notre point final: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  Cette approche vous permettra d'√©crire des tests unitaires qui v√©rifient l'exactitude de la formation d'erreurs avec des donn√©es incorrectes re√ßues du client. </p><br><h3 id="3-serializaciya-modeley">  3. S√©rialisation des mod√®les </h3><br><p>  Presque tous les frameworks de serveurs modernes utilisent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ORM d'une</a> mani√®re ou d'une autre.  Cela signifie que la plupart des ressources utilis√©es dans l'API √† l'int√©rieur du syst√®me sont pr√©sent√©es sous forme de mod√®les, leurs instances et collections. </p><br><p>  Le processus de g√©n√©ration d'une repr√©sentation JSON de ces entit√©s pour transmission dans la r√©ponse API est appel√© <em>s√©rialisation</em> .  Il existe un certain nombre de plugins pour diff√©rents frameworks qui ex√©cutent des fonctions de s√©rialisation, par exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sequelize-to-json</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">actes_as_api</a> (rubygem), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jsonapi-rails</a> (rubygem).  En fait, ces plugins permettent √† un mod√®le sp√©cifique de sp√©cifier une liste de champs qui doivent √™tre inclus dans l'objet JSON, ainsi que des r√®gles suppl√©mentaires, par exemple, pour les renommer ou calculer dynamiquement des valeurs. </p><br><p>  Les difficult√©s commencent lorsque nous devons avoir plusieurs repr√©sentations JSON diff√©rentes du m√™me mod√®le ou lorsqu'un objet contient des entit√©s imbriqu√©es - des associations.  Il existe un besoin d' <em>h√©ritage, de r√©utilisation et de liaison des s√©rialiseurs</em> . </p><br><p>  Diff√©rents modules r√©solvent ces probl√®mes de diff√©rentes mani√®res, mais r√©fl√©chissons, la sp√©cification peut-elle nous aider √† nouveau?  En effet, en fait, toutes les informations sur les exigences pour les repr√©sentations JSON, toutes les combinaisons possibles de champs, y compris les entit√©s imbriqu√©es, s'y trouvent d√©j√†.  Nous pouvons donc √©crire un s√©rialiseur automatique. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'attire</a> votre attention sur un petit module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sequelize-serialize</a> (npm), qui vous permet de le faire pour les mod√®les Sequelize.  Il prend une instance du mod√®le ou d'un tableau, ainsi que le circuit requis, et construit de mani√®re it√©rative un objet s√©rialis√©, en tenant compte de tous les champs requis et en utilisant des circuits imbriqu√©s pour les entit√©s associ√©es. </p><br><p>  Supposons donc que nous ayons besoin de renvoyer de l'API tous les utilisateurs qui ont des articles de blog, y compris des commentaires sur ces articles.  Nous d√©crivons cela en utilisant la sp√©cification suivante: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Nous pouvons maintenant cr√©er la requ√™te √† l'aide de Sequelize et renvoyer un objet s√©rialis√© qui correspond exactement √† la sp√©cification d√©crite ci-dessus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  C'est presque magique, non? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Typage statique </h3><br><p>  Si vous √™tes si cool que vous utilisez TypeScript ou Flow, vous vous √™tes peut-√™tre d√©j√† demand√©: <em>"Et mes chers types statiques?!"</em>  .  √Ä l'aide des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modules sw2dts</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">swagger-to-flowtype,</a> vous pouvez g√©n√©rer toutes les d√©finitions n√©cessaires bas√©es sur les sch√©mas JSON et les utiliser pour le typage statique des tests, des donn√©es d'entr√©e et des s√©rialiseurs. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Maintenant, nous pouvons utiliser des types dans les contr√¥leurs: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  Et dans les tests: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Veuillez noter que les d√©finitions de type g√©n√©r√©es peuvent √™tre utilis√©es non seulement dans le projet API lui-m√™me, mais √©galement dans les projets d'application client pour d√©crire les types de fonctions dans lesquelles l'API fonctionne.  Les d√©veloppeurs de clients angulaires seront particuli√®rement satisfaits de ce cadeau. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Conversion de type de cha√Æne de requ√™te </h3><br><p>  Si, pour une raison quelconque, votre API accepte les demandes avec le type MIME <code>application/x-www-form-urlencoded</code> et non <code>application/json</code> , le corps de la demande ressemblera √† ceci: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  Il en va de m√™me pour les param√®tres de requ√™te (par exemple, dans les requ√™tes GET).  Dans ce cas, le serveur Web ne pourra pas reconna√Ætre automatiquement les types - toutes les donn√©es seront sous forme de cha√Ænes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici une discussion</a> dans le r√©f√©rentiel du module qpm npm), donc apr√®s l'analyse, vous obtiendrez l'objet suivant: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  Dans ce cas, la demande ne sera pas valid√©e selon le sch√©ma, ce qui signifie qu'il faudra v√©rifier manuellement que chaque param√®tre a le format correct et l'amener au type souhait√©. </p><br><p>  Comme vous pouvez le deviner, cela peut √™tre fait en utilisant tous les m√™mes sch√©mas de notre sp√©cification.  Imaginez que nous ayons un tel point final et un tel sch√©ma: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Voici un exemple de demande √† un tel point de terminaison </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  <code>castQuery</code> une fonction <code>castQuery</code> , qui <code>castQuery</code> tous les param√®tres en types n√©cessaires pour nous.  Cela ressemblera √† ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Son impl√©mentation plus compl√®te avec prise en charge des sch√©mas, tableaux et types <code>null</code> imbriqu√©s est disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cast-with-schema</a> (npm).  Maintenant, nous pouvons l'utiliser dans notre code: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Remarquez comment des quatre lignes du code de point de terminaison, les trois sch√©mas d'utilisation de la sp√©cification. </p><br><h2 id="luchshie-praktiki">  Meilleures pratiques </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Sch√©mas distincts pour la cr√©ation et la modification </h3><br><p>  En r√®gle g√©n√©rale, les sch√©mas qui d√©crivent la r√©ponse du serveur sont diff√©rents de ceux qui d√©crivent l'entr√©e utilis√©e pour cr√©er et modifier des mod√®les.  Par exemple, la liste des champs disponibles pour les requ√™tes <code>POST</code> et <code>PATCH</code> doit √™tre strictement limit√©e, tandis que dans les requ√™tes <code>PATCH</code> , tous les champs du sch√©ma sont g√©n√©ralement rendus facultatifs.  Les sch√©mas qui d√©terminent la r√©ponse peuvent √™tre plus gratuits. </p><br><p>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©ration</a> automatique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des points de</a> terminaison <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tinyspec CRUDL</a> utilise les postfixes <code>New</code> et <code>Update</code> .  <code>User*</code> peuvent √™tre d√©finis comme suit: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Essayez de ne pas utiliser les m√™mes sch√©mas pour diff√©rents types d'actions afin d'√©viter des probl√®mes de s√©curit√© accidentels dus √† la r√©utilisation ou √† l'h√©ritage d'anciens sch√©mas. </p><br><h3 id="semantika-v-nazvaniyah-shem">  S√©mantique dans les noms de sch√©ma </h3><br><p>  Le contenu des m√™mes mod√®les peut varier selon diff√©rents points de terminaison.  Utilisez les suffixes <code>With*</code> et <code>For*</code> dans les noms de sch√©ma pour montrer en quoi ils diff√®rent et √† quoi ils servent.  Dans les mod√®les tinyspec, les mod√®les peuvent √©galement √™tre h√©rit√©s les uns des autres.  Par exemple: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  Les suffixes peuvent √™tre vari√©s et combin√©s.  L'essentiel est que leur nom refl√®te l'essence et simplifie la familiarit√© avec la documentation. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  S√©paration des points de terminaison par type de client </h3><br><p>  Souvent, les m√™mes points de terminaison renvoient des donn√©es diff√©rentes en fonction du type de client ou du r√¥le de l'utilisateur acc√©dant au point de terminaison.  Par exemple, les points de terminaison de <code>GET /users</code> et <code>GET /messages</code> peuvent √™tre tr√®s diff√©rents pour les utilisateurs de votre application mobile et pour les gestionnaires de back-office.  Dans le m√™me temps, la modification du nom du point de terminaison lui-m√™me peut √™tre trop compliqu√©e. </p><br><p>  Pour d√©crire plusieurs fois le m√™me point de terminaison, vous pouvez ajouter son type entre crochets apr√®s le chemin.  De plus, il est utile d'utiliser des balises: cela vous aidera √† diviser la documentation de vos points de terminaison en groupes, chacun √©tant con√ßu pour un groupe sp√©cifique de clients de votre API.  Par exemple: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  Documentation de l'API REST </h2><br><p>  Une fois que vous avez une sp√©cification au format tinyspec ou OpenAPI, vous pouvez g√©n√©rer une belle documentation en HTML et la publier pour le plus grand plaisir des d√©veloppeurs utilisant votre API. </p><br><p>  En plus des services cloud mentionn√©s pr√©c√©demment, il existe des outils CLI qui convertissent OpenAPI 2.0 en HTML et PDF, apr√®s quoi vous pouvez le t√©l√©charger sur n'importe quel h√©bergement statique.  Exemples: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bootprint-openapi</a> (npm, utilis√© par d√©faut dans tinyspec) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">swagger2markup-cli</a> (jar, il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple d'utilisation</a> , il sera utilis√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tinyspec Cloud</a> ) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">redoc-cli</a> (npm) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">widdershins</a> (npm) </li></ul><br><p>  <em>Connaissez-vous plus d'exemples?</em>  <em>Partagez-les dans les commentaires.</em> </p><br><p>  Malheureusement, OpenAPI 3.0, sorti il ‚Äã‚Äãy a un an, est toujours mal pris en charge, et je n'ai trouv√© aucun exemple de documentation digne de ce nom: ni parmi les solutions cloud, ni parmi les outils CLI.  Pour la m√™me raison, OpenAPI 3.0 n'est pas encore pris en charge dans tinyspec. </p><br><h3 id="publikaciya-v-github">  Publier sur GitHub </h3><br><p>  L'une des fa√ßons les plus simples de publier de la documentation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub Pages</a> .  Activez simplement la prise en charge des pages statiques pour le r√©pertoire <code>/docs</code> dans les param√®tres de votre r√©f√©rentiel et stockez la documentation HTML dans ce dossier. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  Vous pouvez ajouter une commande pour g√©n√©rer de la documentation via tinyspec ou un autre outil CLI dans les <code>scripts</code> dans <code>package.json</code> et mettre √† jour la documentation avec chaque commit: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Int√©gration continue </h3><br><p>  Vous pouvez inclure la g√©n√©ration de documentation dans le cycle CI et la publier, par exemple, dans Amazon S3 sous diff√©rentes adresses en fonction de l'environnement ou de la version de votre API, par exemple: <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Nuage de Tinyspec </h3><br><p>  Si vous avez aim√© la syntaxe tinyspec, vous pouvez vous inscrire en tant que premier adoptant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tinyspec.cloud</a> .  Nous allons construire sur sa base un service cloud et CLI pour la publication automatique de la documentation avec une large s√©lection de mod√®les et la possibilit√© de d√©velopper nos propres mod√®les. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  D√©velopper une API REST est peut-√™tre l'activit√© la plus agr√©able de toutes celles qui existent dans le processus de travail sur les services Web et mobiles modernes.  Il n'y a pas de zoo de navigateurs, de syst√®mes d'exploitation et de tailles d'√©cran, tout est enti√®rement sous notre contr√¥le - ¬´√† port√©e de main¬ª. </p><br><p>  Le maintien des sp√©cifications actuelles et des bonus sous la forme de diverses automatisations, qui sont fournies en m√™me temps, rendent ce processus encore plus agr√©able.  Une telle API devient structur√©e, transparente et fiable. </p><br><p>  <em>En effet, en fait, m√™me si nous sommes engag√©s dans la cr√©ation d'un mythe, alors pourquoi ne le rendons-nous pas beau?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427601/">https://habr.com/ru/post/fr427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427587/index.html">Java concentr√© pour un millier et demi de personnes. Comment √©tait Joker 2018</a></li>
<li><a href="../fr427589/index.html">Nous √©crivons un chat en ligne sur Websockets en utilisant Swoole</a></li>
<li><a href="../fr427591/index.html">L'architecture comme fardeau</a></li>
<li><a href="../fr427593/index.html">Quick Command Magic dans Vivaldi 2.1</a></li>
<li><a href="../fr427595/index.html">Essayez Micronaut ou Darling, j'ai r√©duit le cadre</a></li>
<li><a href="../fr427603/index.html">Comment enfin commencer √† √©crire des tests et ne pas le regretter</a></li>
<li><a href="../fr427605/index.html">Comment la plateforme de crowdsourcing Yandex aide √† former des drones et √† √©valuer la qualit√© de service</a></li>
<li><a href="../fr427607/index.html">Datacenter en Suisse: travailler comme sur des roulettes</a></li>
<li><a href="../fr427609/index.html">R√©solution de l'√©quation avec division enti√®re sans force brute</a></li>
<li><a href="../fr427611/index.html">L'histoire de la fa√ßon dont j'ai mis √† jour Yandex MapKit sur iOS ou des cartes, de l'argent, 2 mappits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>