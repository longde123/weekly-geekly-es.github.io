<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦈 ⚜️ 🐍 System.IO.Pipelines：.NET中的高性能IO 👌🏼 🕥 ✡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="System.IO.Pipelines是一个新的库，可简化.NET中的代码组织。 如果必须处理复杂的代码，很难确保高性能和准确性。 System.IO.Pipelines的任务是简化代码。 削减更多细节！ 



 该库的产生是.NET Core开发团队努力使Kestrel成为业界最快的Web服务器...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines：.NET中的高性能IO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423105/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">System.IO.Pipelines</a>是一个新的库，可简化.NET中的代码组织。 如果必须处理复杂的代码，很难确保高性能和准确性。  System.IO.Pipelines的任务是简化代码。 削减更多细节！ <br><br><img src="https://habrastorage.org/webt/nq/me/p-/nqmep-tqvyyv5nlkpcxjnmlw8z4.jpeg"><a name="habracut"></a><br><br> 该库的产生是.NET Core开发团队努力使Kestrel成为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">业界最快的Web服务器之一的结果</a> 。 它最初被认为是Kestrel实现的一部分，但已经发展成为可重用的API，在2.1版中可作为一流的BCL API（System.IO.Pipelines）使用。 <br><br><h2> 她能解决什么问题？ </h2><br> 为了正确分析来自流或套接字的数据，您需要编写大量标准代码。 同时，存在许多使代码本身及其支持复杂化的陷阱。 <br><br><h2> 今天出现了什么困难？ </h2><br> 让我们从一个简单的任务开始。 我们需要编写一个TCP服务器来从客户端接收行分隔的消息（\ n）。 <br><br><h2> 带有NetworkStream的TCP服务器 </h2><br> 偏差：如同在任何需要高性能的任务中一样，应根据应用程序的功能来考虑每种特定情况。 如果网络应用程序的规模不是很大，那么花资源来使用各种方法可能就没有意义，稍后将对此进行讨论。 <br><br> 使用管道之前的常规.NET代码如下所示： <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); <span class="hljs-comment"><span class="hljs-comment">// Process a single line from the buffer ProcessLine(buffer); }</span></span></code> </pre> <br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample1.cs</a> <br><br> 该代码可能会与本​​地测试一起使用，但是它有很多错误： <br><br><ul><li> 也许在一次调用ReadAsync之后，将不会收到整个消息（到该行的末尾）。 </li><li> 它忽略stream.ReadAsync（）方法的结果-实际传输到缓冲区的数据量。 </li><li> 该代码不处理在单个ReadAsync调用中接收多行。 </li></ul><br> 这些是最常见的流数据读取错误。 为了避免它们，您需要进行一些更改： <br><br><ul><li> 您需要缓冲传入的数据，直到找到新行。 </li><li> 有必要分析返回到缓冲区的所有行。 </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; var linePosition = -1; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample2.cs</a> <br><br> 我再说一遍：这可以在本地测试中使用，但是有时字符串长度超过1 Kb（1024字节）。 必须增加输入缓冲区的大小，直到找到新行。 <br><br> 此外，在处理长字符串时，我们会将缓冲区收集到数组中。 我们可以使用ArrayPool改进此过程，它可以避免在分析来自客户端的长行时重新分配缓冲区。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer var bytesRemaining = buffer.Length - bytesBuffered; if (bytesRemaining == 0) { // Double the buffer size and copy the previously buffered data into the new buffer var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length); // Return the old buffer to the pool ArrayPool&lt;byte&gt;.Shared.Return(buffer); buffer = newBuffer; bytesRemaining = buffer.Length - bytesBuffered; } var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining); if (bytesRead == 0) { // EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  <i>参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample3.cs</a></i> <br><br> 该代码可以工作，但是现在缓冲区大小已更改，因此出现了许多副本。 还使用更多的内存，因为逻辑不会在处理行后减少缓冲区。 为避免这种情况，您可以保存缓冲区列表，而不是每次字符串到达​​的长度大于1 Kb时都更改缓冲区的大小。 <br><br> 此外，在完全为空之前，我们不会增加1 KB的缓冲区大小。 这意味着我们将越来越小的缓冲区转移到ReadAsync，结果，对操作系统的调用次数将增加。 <br><br> 我们将尝试消除这种情况，并在现有缓冲区的大小小于512字节时立即分配一个新缓冲区： <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferSegment</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Buffer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Remaining =&gt; Buffer.Length - Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BufferSegment&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumedBufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferSegment { Buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>) }; segments.Add(segment); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer if (segment.Remaining &lt; minimumBufferSize) { // Allocate a new segment segment = new BufferSegment { Buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024) }; segments.Add(segment); } var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining); if (bytesRead == 0) { break; } // Keep track of the amount of buffered bytes segment.Count += bytesRead; while (true) { // Look for a EOL in the list of segments var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed); if (segmentIndex &gt;= 0) { // Process the line ProcessLine(segments, segmentIndex, segmentOffset); bytesConsumedBufferIndex = segmentOffset; bytesConsumed = segmentOffset + 1; } else { break; } } // Drop fully consumed segments from the list so we don't look at them again for (var i = bytesConsumedBufferIndex; i &gt;= 0; --i) { var consumedSegment = segments[i]; // Return all segments unless this is the current segment if (consumedSegment != segment) { ArrayPool&lt;byte&gt;.Shared.Return(consumedSegment.Buffer); segments.RemoveAt(i); } } } } (int segmentIndex, int segmentOffest) IndexOf(List&lt;BufferSegment&gt; segments, byte value, int startBufferIndex, int startSegmentOffset) { var first = true; for (var i = startBufferIndex; i &lt; segments.Count; ++i) { var segment = segments[i]; // Start from the correct offset var offset = first ? startSegmentOffset : 0; var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset); if (index &gt;= 0) { // Return the buffer index and the index within that segment where EOL was found return (i, index); } first = false; } return (-1, -1); }</span></span></code> </pre> <br>  <i>请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample4.cs</a></i> <br><br> 结果，代码非常复杂。 在搜索定界符期间，​​我们跟踪填充的缓冲区。 为此，请使用一个列表，该列表在搜索新的行分隔符时显示缓冲的数据。 结果，ProcessLine和IndexOf将接受List而不是字节[]，偏移量和计数。 解析逻辑将开始处理缓冲区的一个或多个段。 <br><br> 现在，服务器将处理部分消息，并使用共享内存来减少整体内存消耗。 但是，需要进行一些更改： <br><br><ol><li> 在ArrayPoolbyte中，我们仅使用Byte []-标准管理的数组。 换句话说，当执行ReadAsync或WriteAsync函数时，缓冲区的有效期与异步操作的时间（与操作系统自己的I / O API进行交互）有关。 由于固定的内存无法移动，因此会影响垃圾收集器的性能，并可能导致阵列碎片化。 您可能需要更改池的实现，具体取决于异步操作等待执行的时间。 </li><li> 通过中断读取和处理逻辑之间的链接可以提高吞吐量。 我们得到了批处理的效果，现在解析逻辑将能够读取大量数据，处理较大的缓冲区块，而不是分析单个行。 结果，代码变得更加复杂： <br><br><ul><li> 必须创建两个彼此独立工作的循环。 第一个将从套接字读取数据，第二个将分析缓冲区。 </li><li> 所需要的是一种告诉解析逻辑数据变得可用的方法。 </li><li> 还必须确定如果循环从套接字读取数据的速度过快会发生什么。 如果解析逻辑跟不上读取周期，我们需要一种调整读取周期的方法。 这通常称为“流量控制”或“流动阻力”。 </li><li> 我们必须确保数据安全传输。 现在，这组缓冲区在读取周期和解析周期中都被使用；它们在不同的线程上彼此独立工作。 </li><li> 内存管理逻辑还涉及两个不同的代码段：从缓冲池借用数据（从套接字读取数据），以及从缓冲池返回（这是解析逻辑）。 </li><li> 执行解析逻辑后，在返回缓冲区时必须格外小心。 否则，我们有机会返回仍将套接字读取逻辑写入其中的缓冲区。 </li></ul></li></ol><br> 复杂性开始蔓延（这远非所有情况！）。 要创建高性能网络，您需要编写非常复杂的代码。 <br><br>  System.IO.Pipelines的目的是简化此过程。 <br><br><h4>  TCP服务器和System.IO.Pipelines </h4><br> 让我们看看System.IO.Pipelines的工作原理： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Task writing = FillPipeAsync(socket, pipe.Writer); Task reading = ReadPipeAsync(pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.WhenAll(reading, writing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket, PipeWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Allocate at least 512 bytes from the PipeWriter Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize); try { int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } // Tell the PipeWriter how much was read from the Socket writer.Advance(bytesRead); } catch (Exception ex) { LogError(ex); break; } // Make the data available to the PipeReader FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // Tell the PipeReader that there's no more data coming writer.Complete(); } async Task ReadPipeAsync(PipeReader reader) { while (true) { ReadResult result = await reader.ReadAsync(); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; SequencePosition? position = null; do { // Look for a EOL in the buffer position = buffer.PositionOf((byte)'\n'); if (position != null) { // Process the line ProcessLine(buffer.Slice(0, position.Value)); // Skip the line + the \n character (basically position) buffer = buffer.Slice(buffer.GetPosition(1, position.Value)); } } while (position != null); // Tell the PipeReader how much of the buffer we have consumed reader.AdvanceTo(buffer.Start, buffer.End); // Stop reading if there's no more data coming if (result.IsCompleted) { break; } } // Mark the PipeReader as complete reader.Complete(); }</span></span></code> </pre> <br>  <i>请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample5.cs</a></i> <br><br> 我们的线路阅读器的流水线版本有两个循环： <br><br><ul><li>  FillPipeAsync从套接字读取并写入PipeWriter。 </li><li>  ReadPipeAsync从PipeReader读取并分析传入的行。 </li></ul><br> 与第一个示例不同，没有专门分配的缓冲区。 这是System.IO.Pipelines的主要功能之一。 所有缓冲区管理任务都将传输到PipeReader / PipeWriter实现。 <br><br> 该过程得以简化：我们仅将代码用于业务逻辑，而不是实现复杂的缓冲区管理。 <br><br> 在第一个循环中，首先调用PipeWriter.GetMemory（int）从主编写器获取一定数量的内存。 然后调用PipeWriter.Advance（int），它告诉PipeWriter实际将多少数据写入缓冲区。 接下来是对PipeWriter.FlushAsync（）的调用，以便PipeReader可以访问数据。 <br><br> 第二个循环使用由PipeWriter写入但最初从套接字接收的缓冲区。 当返回对PipeReader.ReadAsync（）的请求时，我们将获得一个ReadResult，其中包含两个重要消息：以ReadOnlySequence形式读取的数据以及逻辑数据类型IsCompleted，该逻辑数据类型告知读取器写入器是否已完成工作（EOF）。 找到行终止符（EOL）并分析了字符串后，我们会将缓冲区拆分为多个部分，以跳过已处理的片段。 此后，调用PipeReader.AdvanceTo，它告诉PipeReader已消耗了多少数据。 <br><br> 在每个周期结束时，阅读器和写入器均完成。 结果，主通道释放所有分配的内存。 <br><br><h2> 系统管道 </h2><br><h4> 部分阅读 </h4><br> 除了管理内存，System.IO.Pipelines还执行另一个重要功能：它扫描通道中的数据，但不使用它。 <br><br>  PipeReader具有两个主要的API：ReadAsync和AdvanceTo。  ReadAsync从通道接收数据，AdvanceTo告诉PipeReader读取器不再需要这些缓冲区，因此您可以摆脱它们（例如，将它们返回到主缓冲池）。 <br><br> 以下是HTTP分析器的示例，该分析器从部分通道数据缓冲区读取数据，直到接收到合适的起始行。 <br><br><img src="https://habrastorage.org/webt/9c/lp/d8/9clpd8h1r6b1m1jrwultkuggw6i.png"><br><br><h2>  ReadOnlySequenceT </h2><br> 通道实现存储在PipeWriter和PipeReader之间传递的相关缓冲区的列表。  PipeReader.ReadAsync公开ReadOnlySequence，它是一种新型的BCL，由一个或多个ReadOnlyMemory &lt;T&gt;段组成。 它类似于Span或Memory，它使我们有机会查看数组和字符串。 <br><br><img src="https://habrastorage.org/webt/79/y0/kw/79y0kwylohggq941soblji6qd2o.png"><br><br> 通道内部有指针，这些指针显示读取器和写入器在突出显示的常规数据集中的位置，并在写入和读取数据时对其进行更新。  SequencePosition是缓冲区的链接列表中的单个点，用于有效地分隔ReadOnlySequence &lt;T&gt;。 <br><br> 由于ReadOnlySequence &lt;T&gt;支持一个或多个段，因此高性能逻辑的标准操作是根据段数分隔快速路径和慢速路径。 <br><br> 例如，下面是一个将ASCII ReadOnlySequence转换为字符串的函数： <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsciiString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.IsSingleSegment) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.ASCII.GetString(buffer.First.Span); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Create((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buffer.Length, buffer, (span, sequence) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence) { Encoding.ASCII.GetChars(segment.Span, span); span = span.Slice(segment.Length); } }); }</code> </pre> <br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的sample6.cs</a> <br><br><h4> 流阻和流量控制 </h4><br> 理想情况下，读取和分析可以协同工作：读取流消耗来自网络的数据并将其放入缓冲区，而分析流创建合适的数据结构。 分析通常比从网络复制数据块花费更多的时间。 结果，读取流很容易使分析流超载。 因此，读取流将被迫减慢速度或消耗更多内存以保存分析流的数据。 为了确保最佳性能，需要在暂停频率和分配大量内存之间取得平衡。 <br><br> 为了解决此问题，管道具有两个数据流控制功能：PauseWriterThreshold和ResumeWriterThreshold。  PauseWriterThreshold确定在PipeWriter.FlushAsync暂停之前需要缓冲多少数据。  ResumeWriterThreshold确定记录器恢复操作之前读取器可以消耗多少内存。 <br><br><img src="https://habrastorage.org/webt/qf/yj/5u/qfyj5u6aahkadlp8nk1gtc9bqr4.png"><br><br> 当管道流中的数据量超过PauseWriterThreshold中设置的限制时，PipeWriter.FlushAsync将“锁定”，而当其下降到ResumeWriterThreshold中设置的限制以下时，“解锁”。 为了防止超出消耗限制，仅使用两个值。 <br><br><h4>  I / O调度 </h4><br> 使用异步/等待时，通常在池线程或当前的SynchronizationContext中调用后续操作。 <br><br> 在执行I / O时，仔细监视执行位置非常重要，以便更好地利用处理器缓存。 这对于Web服务器等高性能应用程序至关重要。  System.IO.Pipelines使用PipeScheduler确定在哪里执行异步回调。 这使您可以非常精确地控制将哪些流用于I / O。 <br><br> 实际应用程序的一个示例是Kestrel Libuv传输，其中在事件循环的专用通道上执行I / O回调。 <br><br><h2>  PipeReader模板还有其他好处。 </h2><br><ul><li> 一些基本系统支持“等待而不缓冲”：您不需要分配缓冲区，直到基本系统中出现可用数据为止。 因此，在具有epoll的Linux上，在数据准备就绪之前，您无法提供读取缓冲区。 这样可以避免出现许多线程在等待数据的情况，而您需要立即保留大量的内存。 </li><li> 默认管道使编写网络代码的单元测试变得容易：解析逻辑与网络代码分开，并且单元测试仅在存储器的缓冲区中运行此逻辑，而不是直接从网络使用它。 通过发送部分数据，还可以轻松测试复杂的模式。  ASP.NET Core使用它来测试Kestrel的http解析工具的各个方面。 </li><li> 允许用户代码使用主要OS缓冲区的系统（例如，已注册的Windows I / O API）最初适合使用管道，因为PipeReader实现始终提供缓冲区。 </li></ul><br><h4> 其他相关类型 </h4><br> 我们还向System.IO.Pipelines添加了许多新的简单BCL类型： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MemoryPoolT</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IMemoryOwnerT</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MemoryManagerT</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ArrayPoolT</a>是在.NET Core 1.0中添加的，而在.NET Core 2.1中，现在有一种适用于任何MemoryT的池的更通用的抽象表示。 我们得到了一个扩展点，使我们能够实施更高级的分发策略以及控制缓冲区管理（例如，使用预定义的缓冲区而不是专门管理的数组）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IBufferWriterT</a>是用于记录同步缓冲数据（由PipeWriter实现）的接收器。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IValueTaskSource</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ValueTaskT</a>自.NET Core 1.1发布以来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就</a>存在，但是在.NET Core 2.1中，它已经获得了非常有效的工具，这些工具可以提供不间断的异步操作而无需分发。 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 </li></ul><br><h2> 如何使用输送机？ </h2><br> 这些API位于nuget包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">System.IO.Pipelines中</a> 。 <br><br> 有关使用管道处理小写消息的示例.NET Server 2.1服务器应用程序（来自上面的示例），请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 可以使用dotnet run（或Visual Studio）启动它。 在该示例中，期望从端口8087上的套接字传输数据，然后将接收到的消息写入控制台。 您可以使用诸如netcat或putty之类的客户端连接到端口8087。 发送一个小写的消息，看看它如何工作。 <br><br> 当前，管道在Kestrel和SignalR上运行，我们希望将来它将在许多网络库和.NET社区的组件中找到更广泛的应用。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423105/">https://habr.com/ru/post/zh-CN423105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423093/index.html">我们增加了[可能] [几乎]是偶然的事实的随机性</a></li>
<li><a href="../zh-CN423095/index.html">Apple Presentation上的新功能</a></li>
<li><a href="../zh-CN423097/index.html">PostgreSQL战斗机的任务和解决方案</a></li>
<li><a href="../zh-CN423101/index.html">为Proxmox部署LINSTOR存储</a></li>
<li><a href="../zh-CN423103/index.html">Python播客：仅此而已</a></li>
<li><a href="../zh-CN423107/index.html">我们邀请您参加生产中的会议</a></li>
<li><a href="../zh-CN423109/index.html">苹果介绍了什么以及iOS开发人员对此有何看法</a></li>
<li><a href="../zh-CN423115/index.html">CSS背景图层混合模式改善了效果</a></li>
<li><a href="../zh-CN423117/index.html">寿命更长或年龄增长更慢：一种技术手段来延年益寿</a></li>
<li><a href="../zh-CN423119/index.html">DIY TTL街机机...在2018年</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>