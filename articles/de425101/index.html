<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 👴🏽 🍐 Docker + Laravel = ❤ 🥜 🥤 📏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich über meine Erfahrungen beim „Verpacken“ einer Laravel-Anwendung in einen Docker-Container sprechen, damit Frontend- und Ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker + Laravel = ❤</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425101/"><p><img src="https://habrastorage.org/getpro/habr/post_images/89c/b0e/91f/89cb0e91fd1efafb24b66b7ee44dc1b0.png" alt="Laravel-in-Docker"></p><br><p> In diesem Artikel werde ich über meine Erfahrungen beim „Verpacken“ einer Laravel-Anwendung in einen Docker-Container sprechen, damit Frontend- und Backend-Entwickler lokal damit arbeiten können und das Starten in der Produktion so einfach wie möglich war.  Außerdem führt CI automatisch statische Code-Analysatoren, <code>phpunit</code> Tests und Build-Images aus. </p><br><p>  "Und was ist eigentlich Komplexität?"  - Sie können sagen, und Sie werden teilweise recht haben.  Tatsache ist, dass sich in der russisch- und englischsprachigen Gemeinschaft ziemlich viele Diskussionen mit diesem Thema befassen, und ich würde fast alle untersuchten Themen bedingt in die folgenden Kategorien einteilen: </p><br><ul><li>  "Ich verwende Docker für die lokale Entwicklung. Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laradock eingesetzt</a> und kenne die Probleme nicht."  Cool, aber was ist mit dem Automatisierungs- und Produktionsstart? </li><li>  "Ich sammle einen Container <em>(Monolith)</em> basierend auf <code>fedora:latest</code> (~ 230 MB), lege alle Dienste (Nginx, DB, Cache usw.) darin ab und führe alles im Supervisor aus."  Auch ausgezeichnet, leicht zu starten, aber was ist mit der Ideologie von "einem Container - einem Prozess"?  Was ist mit Balancing und Prozessmanagement?  Wie groß ist das Bild? </li><li>  "Hier sind einige Konfigurationsstücke, die mit Auszügen aus Sh-Skripten gewürzt, magische Env-Werte hinzugefügt und verwendet werden."  Danke, aber was ist mit mindestens einem lebenden Beispiel, das ich gabeln und voll spielen könnte? </li></ul><br><p>  Alles, was Sie unten lesen, ist eine subjektive Erfahrung, die nicht vorgibt, die ultimative Wahrheit zu sein.  Wenn Sie Ergänzungen oder Hinweise auf Ungenauigkeiten haben - willkommen zu Kommentaren. </p><br><blockquote>  Für Ungeduldige - ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Repository</a> , Klon, mit dem Sie die Laravel-Anwendung mit einem Befehl starten können.  Es ist auch nicht schwierig, es auf demselben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rancher</a> auszuführen, die Container korrekt zu "verknüpfen" oder die Lebensmittelversion <code>docker-compose.yml</code> als Ausgangspunkt zu verwenden. </blockquote><a name="habracut"></a><br><h2 id="chast-teoreticheskaya">  Theoretischer Teil </h2><br><p>  Welche Werkzeuge werden wir in unserer Arbeit verwenden und worauf werden wir uns konzentrieren?  Zunächst müssen wir auf dem Host installiert werden: </p><br><ul><li>  <code>docker</code> - <code>18.06.1-ce</code> Zeitpunkt des Schreibens habe ich Version <code>18.06.1-ce</code> </li><li>  <code>docker-compose</code> - Es bewältigt das Verknüpfen von Containern und das Speichern der erforderlichen Umgebungswerte.  Version <code>1.22.0</code> </li><li>  <code>make</code> - Sie werden vielleicht überrascht sein, aber es passt perfekt in den Kontext der Arbeit mit Docker </li></ul><br><blockquote>  Sie können <code>docker</code> auf <code>debian</code> Systemen mit dem Befehl <code>curl -fsSL get.docker.com | sudo sh</code>  <code>curl -fsSL get.docker.com | sudo sh</code> , aber <code>docker-compose</code> besser mit <code>pip</code> zu installieren, da die neuesten Versionen in den Repositorys gespeichert sind ( <code>apt</code> Regel weit zurück). </blockquote><p>  Damit ist die Liste der Abhängigkeiten vervollständigt.  Was Sie verwenden, um mit dem Quellcode zu arbeiten - <code>phpstorm</code> , <code>netbeans</code> oder the dead <code>vim</code> - liegt ganz bei Ihnen. </p><br><p>  Als nächstes folgt eine spontane Qualitätssicherung im Zusammenhang mit <em>(ich habe keine Angst vor diesem Wort)</em> Bilddesign: </p><br><ul><li><p>  <strong>F: Grundbild - welches ist besser zu wählen?</strong> </p><br></li><li><p>  <strong>A:</strong> Derjenige, der "dünner" ist, ohne Schnickschnack.  Auf der Grundlage von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>alpine</code></a> <em>(~ 5 Mb) können</em> Sie sammeln, was Ihr Herz begehrt, aber höchstwahrscheinlich müssen Sie mit der Zusammenstellung von Diensten aus der Quelle spielen.  Als Alternative - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>jessie-slim</code></a> <em>(~ 30 Mb)</em> .  Oder verwenden Sie diejenige, die in Ihren Projekten am häufigsten verwendet wird. </p><br></li><li><p>  <strong>F: Warum ist das Bildgewicht wichtig?</strong> </p><br></li><li><p>  <strong>A:</strong> Verringerung des Verkehrsaufkommens, Verringerung der Wahrscheinlichkeit eines Fehlers beim Herunterladen (weniger Daten - weniger Wahrscheinlichkeit), Verringerung des verbrauchten Ortes.  Die Regel "Schwerkraft ist zuverlässig" (© "Snatch") funktioniert hier nicht sehr gut. </p><br></li><li><p>  <strong>F: Aber mein Freund <code>%friend_name%</code> sagt, dass ein "monolithisches" Bild mit all-all-Abhängigkeiten der beste Weg ist.</strong> </p><br></li><li><p>  <strong>A:</strong> Lass uns einfach zählen.  Die Anwendung hat 3 Abhängigkeiten - PG, Redis, PHP.  Und Sie wollten testen, wie es sich in Bundles verschiedener Versionen dieser Abhängigkeiten verhält.  PG - Versionen 9.6 und 10, Redis - 3.2 und 4.0, PHP - 7.0 und 7.2.  Falls jede Sucht ein eigenes Bild ist - Sie benötigen 6 davon, die Sie nicht einmal sammeln müssen -, ist alles fertig und liegt auf <code>hub.docker.com</code> .  Wenn aus ideologischen Gründen alle Abhängigkeiten in einem Container "verpackt" sind, müssen Sie ihn mit Stiften wieder zusammensetzen ... 8 Mal?  <code>opcache</code> Sie nun die Bedingung hinzu, dass Sie noch mit <code>opcache</code> spielen <code>opcache</code> .  Im Falle einer Zerlegung ist dies einfach eine Änderung der Tags der verwendeten Bilder.  Ein Monolith ist einfacher zu betreiben und zu warten, aber es ist der Weg ins Nirgendwo. </p><br></li><li><p>  <strong>F: Warum ist der Supervisor im Container böse?</strong> </p><br></li><li><p>  <strong>A:</strong> Weil <code>PID 1</code> .  Wenn Sie nicht viele Probleme mit Zombie-Prozessen haben möchten und bei Bedarf flexibel „Kapazität hinzufügen“ können, versuchen Sie, einen Prozess pro Container auszuführen.  Eine besondere Ausnahme ist <code>nginx</code> mit seinen Arbeitern und <code>php-fpm</code> , die die Fähigkeit haben, Prozesse zu produzieren, dies aber <code>php-fpm</code> müssen (außerdem sind sie nicht schlecht darin, auf <code>SIGTERM</code> zu reagieren und ihre Arbeiter ganz richtig zu "töten").  Wenn Sie alle Dämonen als Supervisor starten, sind Sie mit ziemlicher Sicherheit zu Problemen verurteilt.  In einigen Fällen ist es zwar schwierig, darauf zu verzichten, aber dies sind bereits Ausnahmen. </p><br></li></ul><br><p>  Nachdem wir uns für die wichtigsten Ansätze entschieden haben, fahren wir mit unserer Anwendung fort.  Es muss in der Lage sein: </p><br><ul><li>  <code>web|api</code> - Geben Sie mit <code>nginx</code> statisch an und generieren Sie mit <code>fpm</code> dynamischen Inhalt </li><li>  <code>scheduler</code> - Führen Sie den nativen Taskplaner aus </li><li>  <code>queue</code> - Verarbeitet Jobs aus Warteschlangen </li></ul><br><p>  Ein Basissatz, der bei Bedarf erweitert werden kann.  Kommen wir nun zu den Bildern, die wir sammeln müssen, damit unsere Anwendung „abhebt“ (ihre Codenamen sind in Klammern angegeben): </p><br><ul><li>  <code>PHP + PHP-FPM</code> ( <strong>App</strong> ) - die Umgebung, in der unser Code ausgeführt wird.  Da die Versionen von PHP und FPM für uns gleich sind, sammeln wir sie in einem Bild.  So ist die Verwaltung mit Konfigurationen einfacher und die Zusammensetzung der Pakete ist identisch.  Natürlich - FPM- und Anwendungsprozesse werden in verschiedenen Containern ausgeführt </li><li>  <code>nginx</code> ( <strong>nginx</strong> ) - das würde sich nicht um die Lieferung von Konfigurationen und optionalen Modulen für <code>nginx</code> kümmern - wir werden ein separates Bild damit sammeln.  Da es sich um einen separaten Dienst handelt, verfügt er über eine eigene Docker-Datei und einen eigenen Kontext </li><li>  Quellen der Anwendung ( <strong>Quellen</strong> ) - Die Quelle wird unter Verwendung eines separaten Abbilds geliefert, wobei das <code>volume</code> mit ihnen in einem Container mit der App bereitgestellt wird.  Das Basis-Image ist <code>alpine</code> , im Inneren befinden sich nur Quellen mit installierten Abhängigkeiten, die mithilfe von Webpack-Assets gesammelt wurden (Build-Artefakte). </li></ul><br><p>  Andere Entwicklungsdienste werden in Containern gestartet und von <code>hub.docker.com</code> .  In der Produktion hingegen werden sie auf separaten Servern in Clustern ausgeführt.  Wir müssen der Anwendung nur noch mitteilen <em>(über die Umgebung),</em> an welchen Adressen / Ports und mit welchen Details sie angeklopft werden müssen.  Noch cooler ist es, Service-Discovery für diesen Zweck zu verwenden, aber nicht um diese Zeit. </p><br><p>  Nachdem ich mich für den theoretischen Teil entschieden habe, schlage ich vor, mit dem nächsten Teil fortzufahren. </p><br><h2 id="chast-prakticheskaya">  Der praktische Teil </h2><br><p>  Ich schlage vor, Dateien im Repository wie folgt zu organisieren: </p><br><pre> <code class="hljs css">. ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker</span></span> #    <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>   │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> │  │  ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │  │  └── ... │  └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">sources</span></span> │    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Dockerfile</span></span> │    └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">src</span></span> #   │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">app</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">bootstrap</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span> │ ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">artisan</span></span> │ └── ... ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> # <span class="hljs-selector-tag"><span class="hljs-selector-tag">Compose-</span></span>    ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">Makefile</span></span> ├── <span class="hljs-selector-tag"><span class="hljs-selector-tag">CHANGELOG</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span> └── <span class="hljs-selector-tag"><span class="hljs-selector-tag">README</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.md</span></span></code> </pre> <br><blockquote>  Sie können sich mit der Struktur und den Dateien vertraut machen, indem Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Link</a> klicken. </blockquote><p>  Um einen Dienst zu erstellen, können Sie den folgenden Befehl verwenden: </p><br><pre> <code class="bash hljs">$ docker build \ --tag %local_image_name% \ -f ./docker/%service_directory%/Dockerfile ./docker/%service_directory%</code> </pre> <br><p>  Der einzige Unterschied besteht in der Zusammenstellung des Bildes mit den Quellen - dafür muss der Zusammenstellungskontext (extremes Argument) auf <code>./src</code> . </p><br><p>  Die Regeln für die Benennung von Bildern in der lokalen Registrierung empfehlen die Verwendung der Regeln, die <code>docker-compose</code> standardmäßig verwendet: <code>%root_directory_name%_%service_name%</code> .  Wenn das Projektverzeichnis <code>my-awesome-project</code> heißt und der Dienst <code>my-awesome-project_redis</code> ist es besser, den <code>my-awesome-project_redis</code> (lokal) für <code>my-awesome-project_redis</code> zu wählen. </p><br><blockquote>  Um den Erstellungsprozess zu beschleunigen, können Sie dem Docker anweisen, den Cache des zuvor zusammengestellten Images zu verwenden. Dazu wird die <code>--cache-from %full_registry_name%</code> .  Daher wird der Docker-Daemon vor dem Starten einer bestimmten Anweisung in der Docker-Datei nachsehen - hat sich diese geändert?  Wenn nicht (der Hash konvergiert), wird die Anweisung übersprungen, wobei die bereits vorbereitete Ebene aus dem Bild verwendet wird, die Sie als Cache verwenden sollen.  Dieses Ding ist nicht schlecht, also wird es den Prozess neu aufbauen, besonders wenn sich nichts geändert hat :) <br><br>  <code>ENTRYPOINT</code> die <code>ENTRYPOINT</code> Skripte zum Starten von Anwendungscontainern. </blockquote><p>  Das Image der Umgebung zum Starten der Anwendung (App) wurde unter Berücksichtigung der Tatsache erfasst, dass sie nicht nur in der Produktion funktioniert, sondern auch lokal. Entwickler müssen effektiv mit ihr interagieren.  Das Installieren und Entfernen von <code>composer</code> Abhängigkeiten, das Ausführen von Komponententests, Endprotokollen und die Verwendung bekannter Aliase ( <code>php /app/artisan</code> → <code>art</code> , <code>composer</code> → <code>c</code> ) sollte ohne Probleme sein.  Darüber hinaus werden damit auch <code>unit</code> Tests und statische Code-Analysatoren (in unserem Fall <code>phpstan</code> ) auf CI ausgeführt.  Aus diesem Grund enthält die <code>xdebug</code> Datei beispielsweise die <code>xdebug</code> Installationszeile, das Modul selbst ist jedoch nicht aktiviert (es wird nur mit CI aktiviert). </p><br><blockquote>  Auch für <code>composer</code> das Paket <code>hirak/prestissimo</code> , was die Installation aller Abhängigkeiten erheblich <code>hirak/prestissimo</code> . </blockquote><p>  Während der Produktion hängen wir den Inhalt des Verzeichnisses <code>/src</code> aus dem Image mit den darin enthaltenen Quellen (Quellen) in das Verzeichnis <code>/app</code> .  Für die Entwicklung "rollen" wir das lokale Verzeichnis mit Anwendungsquellen ( <code>-v "$(pwd)/src:/app:rw"</code> ). </p><br><p>  Und hier liegt eine Komplexität: Dies sind <strong>Zugriffsrechte auf Dateien</strong> , die aus dem Container erstellt werden.  Tatsache ist, dass die im Container ausgeführten Prozesse standardmäßig vom Stammverzeichnis ( <code>root:root</code> ), den von diesen Prozessen erstellten Dateien (Cache, Protokolle, Sitzungen usw.) ausgehen und daher nichts „lokal“ mit ihnen zu tun haben Sie können dies tun, ohne <code>sudo chown -R $(id -u):$(id -g) /path/to/sources</code> auszuführen. </p><br><p>  Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> als eine Lösung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fixuid</a> , aber diese Lösung ist unkompliziert.  Der beste Weg schien mir, <code>USER_ID</code> lokale <code>USER_ID</code> und ihre <code>GROUP_ID</code> im Container <code>USER_ID</code> und <a href="">Prozesse mit diesen Werten zu starten</a> .  Standardmäßig wurde durch Ersetzen der Werte <code>1000:1000</code> (die Standardwerte für den ersten lokalen Benutzer) der Aufruf <code>$(id -u):$(id -g)</code> , und Sie können sie <code>$ USER_ID=666 docker-compose up -d</code> jederzeit überschreiben ( <code>$ USER_ID=666 docker-compose up -d</code> ) oder <code>.env</code> die Docker-Compose-Datei in die <code>.env</code> Datei ein. </p><br><p>  Wenn <code>php-fpm</code> lokal gestartet wird <code>php-fpm</code> vergessen <code>php-fpm</code> nicht, den <code>opcache</code> zu deaktivieren - andernfalls gibt es eine Menge "Ja, was zur Hölle!"  Sie werden zur Verfügung gestellt. </p><br><p>  Für eine "direkte" Verbindung zu Redis und Postgres habe ich zusätzliche Ports "out" ( <code>15432</code> bzw. <code>15432</code> ) <code>15432</code> , sodass es im Prinzip keine Probleme gibt, "zu verbinden und zu sehen, was und wie es wirklich ist". </p><br><p>  Ich behalte den Container mit der Codenamen- <code>app</code> ( <code>--command keep-alive.sh</code> ), um bequem auf die Anwendung zugreifen zu können. </p><br><p>  Hier einige Beispiele zur Lösung alltäglicher Probleme mit <code>docker-compose</code> : </p><br><table><thead><tr><th>  Bedienung </th><th>  Befehl ausführen </th></tr></thead><tbody><tr><td>  Installieren Sie das <code>composer</code> Paket </td><td> <code>$ docker-compose exec app composer require package/name</code> </td> </tr><tr><td>  Phpunit ausführen </td><td> <code>$ docker-compose exec app php ./vendor/bin/phpunit --no-coverage</code> </td> </tr><tr><td>  Installieren Sie alle Knotenabhängigkeiten </td><td> <code>$ docker-compose run --rm node npm install</code> </td> </tr><tr><td>  Installieren Sie das Knotenpaket </td><td> <code>$ docker-compose run --rm node npm i package_name</code> </td> </tr><tr><td>  Starten eines Live-Wiederaufbaus von Assets </td><td> <code>$ docker-compose run --rm node npm run watch</code> </td> </tr></tbody></table><br><p>  Sie finden alle <strong><a href="">Startdetails in der Datei docker-compose.yml</a></strong> . </p><br><h4 id="coy-make-zhiv"><del>  Choi </del>  <code>make</code> lebendig! </h4><br><p>  Nach dem zweiten Mal wird es langweilig, jedes Mal dieselben Befehle einzugeben. Da Programmierer von Natur aus faule Wesen sind, sollten wir uns mit ihrer "Automatisierung" befassen.  Das <code>sh</code> einer Reihe von Skripten ist eine Option, aber nicht so attraktiv wie ein einzelnes <code>Makefile</code> , zumal seine Anwendbarkeit in der modernen Entwicklung stark unterschätzt wird. </p><br><blockquote>  Das vollständige russischsprachige Handbuch finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> . </blockquote><p>  Mal sehen, wie der <code>make</code> Lauf im Stammverzeichnis des Repositorys aussieht: </p><br><pre> <code class="bash hljs">[user@host ~/projects/app] $ make <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Show this <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> app-pull Application - pull latest Docker image (from remote registry) app Application - build Docker image locally app-push Application - tag and push Docker image into remote registry sources-pull Sources - pull latest Docker image (from remote registry) sources Sources - build Docker image locally sources-push Sources - tag and push Docker image into remote registry nginx-pull Nginx - pull latest Docker image (from remote registry) nginx Nginx - build Docker image locally nginx-push Nginx - tag and push Docker image into remote registry pull Pull all Docker images (from remote registry) build Build all Docker images push Tag and push all Docker images into remote registry login Log <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> to a remote Docker registry clean Remove images from <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> registry --------------- --------------- up Start all containers (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> background) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development down Stop all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers restart Restart all started <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> development containers shell Start shell into application container install Install application dependencies into application container watch Start watching assets <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> changes (node) init Make full application initialization (install, seed, build assets) <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Execute application tests Allowed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> overriding next properties: PULL_TAG - Tag <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pulling images before building own (<span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) PUBLISH_TAGS - Tags list <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building and pushing into remote registry (delimiter - single space, <span class="hljs-string"><span class="hljs-string">'latest'</span></span> by default) Usage example: make PULL_TAG=<span class="hljs-string"><span class="hljs-string">'v1.2.3'</span></span> PUBLISH_TAGS=<span class="hljs-string"><span class="hljs-string">'latest v1.2.3 test-tag'</span></span> app-push</code> </pre> <br><p>  Er ist sehr gut in süchtig machenden Zielen.  Um beispielsweise <code>docker-compose run --rm node npm run watch</code> zu starten ( <code>docker-compose run --rm node npm run watch</code> ), muss die Anwendung " <code>docker-compose run --rm node npm run watch</code> " werden - Sie müssen nur das <code>up</code> Ziel als abhängig angeben - und Sie müssen sich nicht darum kümmern, dies zu vergessen, bevor Sie <code>watch</code> aufrufen - <code>make</code> sich alles für Sie tun.  Gleiches gilt zum Beispiel für das Ausführen von Tests und statischen Analysatoren, bevor Änderungen vorgenommen werden. Führen Sie einen <code>make test</code> und die ganze Magie wird für Sie geschehen! </p><br><p>  Sie müssen sich <code>--cache-from</code> nicht darum kümmern, Bilder zusammenzustellen, herunterzuladen, <code>--cache-from</code> und so <code>--cache-from</code> alles anzugeben? </p><br><p>  Sie können den Inhalt des <code>Makefile</code> unter <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a></strong> anzeigen. </p><br><h2 id="chast-avtomaticheskaya">  Autoteil </h2><br><p>  Fahren wir mit dem letzten Teil dieses Artikels fort - dies ist die Automatisierung des Aktualisierungsprozesses von Bildern in der Docker-Registrierung.  Obwohl in meinem Beispiel GitLab CI verwendet wird, um die Idee auf einen anderen Integrationsdienst zu übertragen, denke ich, dass dies durchaus möglich sein wird. </p><br><p>  Zunächst bestimmen wir die Benennung der verwendeten Bild-Tags: </p><br><table><thead><tr><th>  Tag-Name </th><th>  Ziel </th></tr></thead><tbody><tr><td> <code>latest</code> </td> <td>  Bilder aus der Hauptniederlassung gesammelt. <br>  Der Status des Codes ist der neueste, aber noch nicht bereit, in die Version einzusteigen </td></tr><tr><td> <code>some-branch-name</code> </td> <td>  Bilder, die auf dem Brunch <code>some-branch-name</code> Zweignamens gesammelt wurden. <br>  Auf diese Weise können wir Änderungen in jeder Umgebung "einführen", die nur im Rahmen eines bestimmten Brunchs implementiert wurden, noch bevor sie mit dem <code>master</code> Light zusammengeführt werden. Es reicht aus, die Bilder mit diesem Tag zu "strecken". <br>  Und - ja, die Änderungen können sowohl den Code als auch die Bilder aller Dienste im Allgemeinen betreffen! </td></tr><tr><td> <code>vX.XX</code> </td> <td>  Eigentlich die Freigabe der Anwendung (zum Bereitstellen einer bestimmten Version) </td></tr><tr><td> <code>stable</code> </td> <td>  Alias ​​für das Tag mit der neuesten Version (zum Bereitstellen der neuesten stabilen Version) </td></tr></tbody></table><br><p>  Die Veröffentlichung erfolgt durch Veröffentlichung eines Tags in einem <code>vX.XX</code> Format. </p><br><p>  Um den Build zu beschleunigen, wird das Caching der Verzeichnisse <code>./src/vendor</code> und <code>./src/node_modules</code> + <code>--cache-from</code> für den <code>docker build</code> und besteht aus den folgenden Schritten: </p><br><table><thead><tr><th>  Künstlername </th><th>  Ziel </th></tr></thead><tbody><tr><td> <code>prepare</code> </td> <td>  Die Vorbereitungsphase - die Zusammenstellung von Bildern aller Dienste <strong>außer dem</strong> Bild mit der Quelle </td></tr><tr><td> <code>test</code> </td> <td>  Testen der Anwendung (Ausführen von <code>phpunit</code> , statische Code-Analysatoren) anhand von Bildern, <strong>die in der Vorbereitungsphase gesammelt wurden</strong> </td></tr><tr><td> <code>build</code> </td> <td>  Installieren aller <code>composer</code> Abhängigkeiten ( <code>--no-dev</code> ), Zusammenstellen von <code>assets</code> <code>webpack</code> und <code>webpack</code> Images mit dem Quellcode <strong>einschließlich der empfangenen Artefakte</strong> ( <code>vendor/*</code> , <code>app.js</code> , <code>app.css</code> ) </td></tr></tbody></table><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c2/873/625/8c2873625893ec1a0605e24bf85ef541.png" alt="Pipelines Screenshot"></p><br><blockquote>  Die Baugruppe auf dem Hauptzweig erzeugt <code>push</code> mit den <code>latest</code> und <code>master</code> Tags </blockquote><p>  Im Durchschnitt dauern alle Phasen der Montage <strong>4 Minuten</strong> , was ein ziemlich gutes Ergebnis ist (die parallele Ausführung von Aufgaben ist unser Alles). </p><br><p>  Unter <strong><a href="">diesem Link</a></strong> können Sie sich mit dem Inhalt der Konfiguration ( <strong><code>.gitlab-ci.yml</code></strong> ) des Kollektors vertraut machen. </p><br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Wie Sie sehen können, ist die Organisation der Arbeit mit einer PHP-Anwendung (am Beispiel von <code>Laravel</code> ) mit Docker nicht so schwierig.  Als Test können Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> <code>tarampampam/laravel-in-docker</code> und alle Vorkommen von <code>tarampampam/laravel-in-docker</code> durch Ihr eigenes ersetzen - probieren Sie alles "live" aus. </p><br><p>  Für den lokalen Start - führen Sie nur 2 Befehle aus: </p><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://gitlab.com/tarampampam/laravel-in-docker.git ./laravel-in-docker &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$_</span></span> $ make init</code> </pre> <br><p>  Öffnen Sie dann <code>http://127.0.0.1:9999</code> in Ihrem bevorzugten Browser. </p><br><p>  <strong><em>... die Gelegenheit nutzen</em></strong> </p><br><p>  <em>Im Moment arbeite ich am TL-Projekt "Autocode" und wir suchen talentierte PHP-Entwickler und Systemadministratoren (Entwicklungsbüro befindet sich in Jekaterinburg).</em>  <em>Wenn Sie sich als Erster oder Zweiter betrachten, schreiben Sie unseren HR-Brief mit dem Text "Ich möchte ein Entwicklungsteam sein, Lebenslauf:% link_on_summary%" an die E-Mail- <code>hr@avtocod.ru</code> . Wir helfen <code>hr@avtocod.ru</code> beim Umzug.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425101/">https://habr.com/ru/post/de425101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425089/index.html">IT in der Tierwelt: Ant Food Search und TCP / IP</a></li>
<li><a href="../de425091/index.html">Was zum Teufel ist mit den Beliebtheitswerten von Programmiersprachen los?</a></li>
<li><a href="../de425093/index.html">IoT-Lösungen für Wohnungsbau und kommunale Dienste: Was werden intelligente Zähler sein und wer sollte sie warten?</a></li>
<li><a href="../de425095/index.html">Offenes Webinar "Spiel" 2048 "</a></li>
<li><a href="../de425099/index.html">Was ich verstanden habe und auf welche Probleme ich beim Erstellen eines Hacker News-Klons gestoßen bin</a></li>
<li><a href="../de425103/index.html">Stoppen Sie Google Predators bei der Verfolgung Ihrer Kinder</a></li>
<li><a href="../de425105/index.html">Intel ME Manufacturing Mode - eine versteckte Bedrohung oder was steckt hinter der Sicherheitsanfälligkeit CVE-2018-4251 im MacBook?</a></li>
<li><a href="../de425107/index.html">Fintech Digest: Probleme der Biometrie auf Mobilgeräten, Leasing von Samsung-Handys, Wertpapiere in der Blockchain</a></li>
<li><a href="../de425109/index.html">Das Buch „Java in der Cloud. Frühlingsstiefel, Frühlingswolke, Wolkengießerei »</a></li>
<li><a href="../de425111/index.html">Werbetricks, die Sie Geld und Ansehen kosten können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>