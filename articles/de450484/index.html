<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßî üöó üöê Website-Animationsleistung üóúÔ∏è üìÇ üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung von Websites, die √ºber den Rahmen eines bedingten Bootstraps hinausgehen, stellen sich fr√ºher oder sp√§ter Fragen zur Leistung von ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Website-Animationsleistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450484/"><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="Bild"></p><br><p>  Bei der Entwicklung von Websites, die √ºber den Rahmen eines bedingten Bootstraps hinausgehen, stellen sich fr√ºher oder sp√§ter Fragen zur Leistung von Animationen.  Sie sind besonders wichtig in Design-Sites, wie sie in den Katalogen Awwwards, FWA, CSS Design Awards usw. enthalten sind.  In diesem Fall liegt die Aufgabe, bei Bedarf Animationen zu erstellen und gegebenenfalls zu optimieren, h√§ufig auf den Schultern nicht sehr erfahrener Entwickler, die nicht einmal wissen, wo sie anfangen sollen.  In der Regel f√ºhrt dies zu Hemmstellen, die nicht genutzt werden k√∂nnen, und zu einer anschlie√üenden negativen Einstellung gegen√ºber der gesamten Klasse solcher Projekte.  In diesem Artikel werden wir versuchen herauszufinden, wo die Grenze einer akzeptablen Animationsleistung liegt, welche Engp√§sse h√§ufig sind und wo in den Entwicklertools zuerst nachzuschauen ist. </p><a name="habracut"></a><br><p>  <em>Eine kleine Bemerkung: Da dieser Artikel eher f√ºr Anf√§nger gedacht ist und allgemeine Ans√§tze zur Optimierung von Animationen aufzeigen soll, werden viele Dinge in einer vereinfachten, nicht ganz akademischen Form gegeben.</em> </p><br><h2 id="kak-brauzer-otobrazhaet-stranicu">  Wie der Browser die Seite anzeigt </h2><br><p>  Zun√§chst ist es hilfreich zu verstehen, was passiert, wenn der Browser den aktuellen Status der Seite anzeigt.  Es gibt vier Hauptschritte: </p><br><ol><li>  Stilberechnung (der Browser analysiert CSS-Selektoren und legt fest, welche Stile auf welche angewendet werden sollen) </li><li>  Layouterstellung (das Seitenlayout wird tats√§chlich gebildet) </li><li>  Malen (erstellt Pixeldarstellungen von Elementen f√ºr das nachfolgende Rendern) </li><li>  Ebenenzusammensetzung (der Browser sammelt alles zusammen und zeigt es auf dem Bildschirm an) </li></ol><br><p>  Dar√ºber hinaus handelt der Browser immer in dieser Reihenfolge und geht bis zum Ende.  Wenn die Seite nach dem Laden zum ersten Mal angezeigt wird, werden alle vier Schritte ausgef√ºhrt.  In Zukunft k√∂nnen unsere Aktionen die Ausf√ºhrung einer von ihnen verursachen, aber gleichzeitig werden alle nachfolgenden ausgef√ºhrt.  Aber nicht die vorherigen. </p><br><p>  Wir werden die Engp√§sse jedes dieser Schritte weiter betrachten und jetzt eine dumme Frage auf den ersten Blick stellen, mit der theoretisch begonnen werden sollte ... </p><br><h2 id="tormozit-ili-ne-tormozit-vot-v-chem-vopros">  Ob es langsamer wird oder nicht, das ist die Frage ... </h2><br><p>  Sehr oft kann man Leute treffen, die mit einer deutlich langsamen Website nichts anfangen und sagen: "Aber meine Seitengeschwindigkeit gibt 100 Punkte, alles ist in Ordnung."  Oder umgekehrt, auf einer gut funktionierenden Site haben sich die Leute schon lange mit Optimierungen besch√§ftigt, weil einige Algorithmen auf der Grundlage einiger mysteri√∂ser Metriken ineffizient funktionieren.  Aber zwischen diesen Extremen sollte die Mitte des gesunden Menschenverstandes liegen, also wo ist es? </p><br><p><img src="https://habrastorage.org/webt/zv/su/nv/zvsunvxfwjqvs98q0_yhc9s5jry.jpeg" alt="Bild"></p><br><p>  Zu <del>  Zen kennenlernen </del>  Um zu verstehen, ob Sie Ihre Animationen optimieren m√ºssen, m√ºssen Sie einen tiefen philosophischen Gedanken verwirklichen: </p><br><blockquote>  Wenn Sie feststellen, dass die Site langsam ist, bedeutet dies, dass sie langsam ist.  Wenn Sie nicht sehen, dass die Site langsamer wird, wird sie nicht langsamer. </blockquote><p>  Aus irgendeinem Grund finden viele Leute diese Aussage sehr dumm, aber ist das so?  F√ºr den Endbenutzer ist Leistung keine Art von Metriken oder idealen Algorithmen mit strenger mathematischer Begr√ºndung.  Leistung ist f√ºr ihn eines von zwei Dingen: Sie verlangsamt sich oder verlangsamt sich nicht. </p><br><p>  Wie bestimmt er das?  Das Auge einer Person, die viel Zeit hinter dem Monitor verbringt, reagiert scharf auf einen R√ºckgang der Bilder pro Sekunde.  Dies verursacht ein seltsames Gef√ºhl von Unbehagen.  Dementsprechend ist es unsere Aufgabe als Entwickler, ein Absinken zu verhindern.  Ist der Benutzer daran gew√∂hnt, dass der Browser mit 60 fps arbeitet?  Dann machen wir alles, damit alles so bleibt.  Wir nehmen einen Laptop mit mittlerem Eisen und schauen.  Wir sehen viel weniger als 60 fps - wir optimieren.  Wir sehen ungef√§hr 60 - ber√ºhren Sie nichts.  Der Benutzer wird den Unterschied ohnehin nicht bemerken, und wir werden viel Zeit f√ºr die Optimierung aufwenden, um Optimierungen vorzunehmen. </p><br><blockquote>  F√ºhren Sie keine Optimierungen f√ºr Optimierungen durch. </blockquote><br><h2 id="165ms">  16,5 ms </h2><br><p>  Es ist nicht bequem, sich in fps auszudr√ºcken. Fahren wir also mit Millisekunden fort.  Mit einer einfachen Aufteilung von 1000 ms / 60 fps erhalten wir ungef√§hr 16,5 ms Zeit pro Frame. </p><br><p>  Was bedeutet das?  F√ºr 16,5 ms sollte der Browser den aktuellen Status der Seite mit der Animation anzeigen. Befolgen Sie dazu die oben beschriebenen Schritte. Gleichzeitig sollten Ressourcen f√ºr die Arbeit anderer Skripte, die Kommunikation mit dem Server usw. verbleiben.  Wenn mehr Zeit f√ºr die Anzeige des aktuellen Status der Seite aufgewendet wird, sehen wir die Verz√∂gerung durch unsere Augen.  Wenn es ungef√§hr 16 ms sind, gibt es kein Absinken, aber es ist wahrscheinlich, dass die Eisenladung sehr hoch ist, K√ºhler summen und Telefone sich erw√§rmen.  Daher m√ºssen wir sicherstellen, dass das Rendern eines Frames diesen Wert nicht zeitlich ann√§hert und noch besser nicht mehr als 10 ms betr√§gt, damit ein Leistungsspielraum entsteht.  Vergessen Sie nicht, dass Tests immer auf der mittleren Hardware durchgef√ºhrt werden. In den folgenden Beispielen werden beispielsweise Screenshots auf Pentium Silver mit integrierter Grafik erstellt. </p><br><blockquote>  Testen Sie die Hardware, √ºber die Ihre Benutzer mit gr√∂√üerer Wahrscheinlichkeit verf√ºgen.  Wenn Sie an Ihrem Arbeitsplatz einen Top-End-Prozessor und eine Mining-Farm unter dem Tisch haben, funktioniert alles gut f√ºr Sie, w√§hrend Ihre Benutzer mit Budget-Laptops sehr traurig sein k√∂nnen. </blockquote><p>  Um sich nicht nur auf Ihr gutes Auge und Ihre Intuition verlassen zu k√∂nnen, ist es hilfreich, die Entwicklertools zumindest auf einer grundlegenden Ebene zu beherrschen.  Sie geben nicht nur genaue Leistungsdaten an, sondern sagen Ihnen auch, wo Sie nach dem Problem suchen m√ºssen, wenn nicht alles sehr gut funktioniert. </p><br><h2 id="instrumenty-razrabotchika-v-google-chrome">  Entwicklertools in Google Chrome </h2><br><p>  Viele Programmierer sind h√§ufig mehr von Entwicklertools im Browser als von der Linux-Konsole betroffen.  Tats√§chlich gibt es aber nichts, vor dem man Angst haben muss.  Ja, es gibt viele Schaltfl√§chen, aber sie sind redundant, um unsere Probleme zu l√∂sen.  Jetzt werden wir sehen, wo es sich lohnt, zuerst darauf zu achten, was mit Animation zu tun ist und ob es √ºberhaupt notwendig ist, etwas zu tun. </p><br><p>  Wenn es um Leistung geht, verbringen wir die meiste Zeit auf der Registerkarte Leistung und dr√ºcken dieselbe Taste. </p><br><p><img src="https://habrastorage.org/webt/a_/wd/vn/a_wdvnjnvppuvnrzp_f4sxp4gb0.png" alt="Bild"></p><br><p>  Die Tastenkombination Strg-E oder die runde Taste links starten und beenden die Aufzeichnung des Geschehens.  Die Ergebnisse werden hier angezeigt.  Der Browser schreibt viele Dinge, aber es ist besser, sie einmal zu sehen, als sie oft zu lesen. Nehmen wir also eine Art Animation und schauen sie uns an.  Lassen Sie es f√ºr den Anfang eine einfache CSS-Animation sein.  Wenn Sie es im Vollbildmodus √∂ffnen, k√∂nnen Sie sehen, dass es mit auff√§lligen Staus funktioniert: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/Xwrqpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wir werden einige Sekunden im Vollbildmodus aufnehmen und sehen, was dort passiert: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="Bild"></p><br><p>  Der Browser zeichnet alles auf, was er tut.  Im oberen Teil des Fensters sehen wir ein FPS-Diagramm.  Es kann leicht verwendet werden, um eine Anomalie zu erkennen, wenn es w√§hrend der Arbeit mit der Seite stark langsamer wird.  Wenn Sie mit der Maus auf das Diagramm klicken und zur Seite ziehen oder das Rad drehen, k√∂nnen Sie diesen Zeitbereich ausw√§hlen. Detaillierte Informationen dazu werden unten angezeigt.  In unserem einfachen Beispiel gibt es keine Anomalien, aber es ist deutlich zu sehen, dass nicht alles sehr gleichm√§√üig funktioniert. </p><br><p>  Achten Sie sofort auf die <em>Frames-</em> Zeile, die Informationen √ºber die f√ºr jeden Frame aufgewendete Zeit enth√§lt.  Sie k√∂nnen feststellen, dass diese Zeit st√§ndig springt und 16 ms deutlich √ºberschreitet (in praktischen Beispielen werden wir diese Animation unten leicht verbessern). </p><br><p>  Als n√§chstes sehen wir mehrere Zeilen, in denen die Last in verschiedenen Farben angezeigt wird. Sie k√∂nnen sehen, wie viel Zeit der Browser f√ºr verschiedene Arten von Aktivit√§ten aufgewendet hat.  Unsere Animation ist einheitlich und f√ºr jedes Bild werden die gleichen Vorg√§nge ausgef√ºhrt, die durch Lila und Gr√ºn gekennzeichnet sind.  Wenn Sie die Maus √ºber die farbigen Bl√∂cke bewegen, wird deutlich, dass es sich um die eingangs erw√§hnten Elemente handelt. Der <em>neu berechnete Stil</em> und der <em>Aktualisierungsebenenbaum</em> sind lila und die <em>Farb-</em> und <em>zusammengesetzten Ebenen</em> sind gr√ºn. </p><br><p>  Betrachten Sie eine andere Animation.  Diesmal mit Skripten - ein einfacher Ger√§uschgenerator.  Dies ist ein ziemlich anschauliches Beispiel, obwohl es aus gestalterischer Sicht nicht von Interesse ist: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/QRLrBJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  M√∂glicherweise wurden gelbe Bl√∂cke hinzugef√ºgt, die die Ausf√ºhrung von Skripten anzeigen.  Wenn es viele Funktionsaufrufe gibt, wird f√ºr jeden Aufruf ein weiterer Block hinzugef√ºgt - aufgrund ihrer Gr√∂√üe ist es einfach, die "schwerste" Funktion zu finden, mit der wahrscheinlich die Optimierung beginnen sollte. </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="Bild"></p><br><p>  In diesem Beispiel schwankt die f√ºr einen Frame aufgewendete Zeit um 80 ms.  Aber was ist da, auch mit blo√üem Auge kann man deutlich sehen, wie alles abst√ºrzt.  In der folgenden <em>Zusammenfassung</em> sehen wir, dass Skripte die meiste Zeit in Anspruch nehmen.  Im Vergleich dazu sehen <em>Rendern</em> und <em>Malen</em> wie Fehler aus, die vernachl√§ssigt werden k√∂nnen.  Nat√ºrlich nicht immer, aber ziemlich oft. </p><br><p>  Wenn Sie auf den als <em>Funktionsaufruf</em> gekennzeichneten Block klicken, finden Sie unten einen Link zur Funktion im Skriptcode.  Wenn Sie es durchgehen, k√∂nnen Sie sehen, dass in diesem Beispiel alle Pixel auf dem Bildschirm durchlaufen werden.  Es w√§re logischer, eine solche Aufgabe mit Shadern zu erledigen, dann w√§re die Leistung um ein Vielfaches besser.  Aber wir werden es in praktischen Beispielen betrachten. </p><br><h2 id="chto-delat-esli">  Was tun, wenn ... </h2><br><p>  Wir haben gelernt, welche Schritte es gibt, wenn der aktuelle Status einer Seite in einem Browser angezeigt wird und wo zu sehen ist, welche am meisten Zeit in Anspruch nimmt.  Es ist Zeit, sich mit den h√§ufigsten Gr√ºnden vertraut zu machen, warum dieser oder jener Schritt zu viele Ressourcen erfordert, und ein paar Tipps zu geben, was in diesem oder jenem Fall zu tun ist. </p><br><h2 id="style-calculation">  Stilberechnung </h2><br><p>  Wenn Sie sehen, dass bereits in diesem Schritt Probleme beginnen - h√∂chstwahrscheinlich liegt der Punkt nicht einmal in der Animation, sondern in der Tatsache, dass zu viele Elemente auf der Seite vorhanden sind.  In Design-Sites ist dies ziemlich selten. Normalerweise ist ein solches Problem ein Satellit mit gro√üen Tabellen mit Tausenden von Elementen. Wenn Sie jedoch immer noch auf Folgendes sto√üen: </p><br><blockquote>  Reduzieren Sie die Anzahl der Elemente auf der Seite und vereinfachen Sie das Layout.  Achten Sie besonders darauf, Codeteile mit Wrappern zu wiederholen. Es ist wahrscheinlich, dass sie entfernt werden k√∂nnen. </blockquote><p>  Der zweite Grund, der mit dem ersten verbunden ist, sind komplexe CSS-Selektoren.  Wenn es auf kleinen Seiten durchaus m√∂glich ist, tiefes Verschachteln, knifflige Hacks mit benachbarten Elementen usw. zu verwenden, kann dies auf einer wirklich gro√üen Seite zu einer schlechten Leistung f√ºhren. </p><br><blockquote>  Vereinfachen Sie CSS-Selektoren und verwenden Sie BEM. </blockquote><br><h2 id="layout-creation">  Layouterstellung </h2><br><p>  Dieser Artikel ist bereits n√§her an Design und Animationen, interessante Dinge beginnen hier.  Das erste, was zu verstehen ist, ist, dass das gesamte Layout gebildet wird.  Wenn wir etwas √§ndern, wird es neu gebildet.  Aus diesem Grund k√∂nnen bereits kleine √Ñnderungen auf der gro√üen Seite bei diesem Schritt zu sp√ºrbaren Verz√∂gerungen f√ºhren. </p><br><p>  Die Hauptregel, die uns beim Erstellen von Animationen hilft, ist, die Umstrukturierung des Layouts nicht um jeden Preis zuzulassen.  Daher versuchen wir normalerweise nicht, es zu optimieren (und es gibt keine besonderen M√∂glichkeiten), n√§mlich wir versuchen, es zu vermeiden. </p><br><p>  Es gibt viele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaften</a> , die dazu f√ºhren k√∂nnen, dass das Layout neu erstellt wird. Sie k√∂nnen Listen im Internet finden, z. B. ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">csstriggers.com</a> nicht schlecht.  In Animationen finden Sie h√§ufiger Eigenschaften als in anderen: </p><br><pre><code class="plaintext hljs">display position / top / left / right / bottom width / height padding / margin border font-size / font-weight / line-height ...</code> </pre> <br><p>  M√∂glicherweise stellen Sie fest, dass alle diese Eigenschaften durch eines vereint sind: Sie beschreiben die geometrischen Eigenschaften der Elemente - Anzeigeparameter, Gr√∂√üe und physikalische Position.  Denken Sie also daran, worauf sie sich beziehen, anstatt sie alle auswendig zu lernen. </p><br><blockquote>  √Ñndern Sie nicht die geometrischen Eigenschaften von Elementen. Es ist besser, Transformation und Deckkraft zu verwenden. </blockquote><p>  Unabh√§ngig davon ist anzumerken, dass das √Ñndern des Hintergrunds des Elements auch zu diesem Schritt zur√ºckf√ºhrt.  Sie vergessen dies st√§ndig, daher heben wir in einer separaten Empfehlung hervor: </p><br><blockquote>  √Ñndern Sie nicht die Hintergrundelemente. </blockquote><p>  In einigen Browsern ( <del>  Ich werde in Firefox keinen Finger stecken </del>  ) Eine typische Verz√∂gerung von CSS-Animationen mit Transformationen kann auftreten, insbesondere wenn mehr als eine Animation pro Zeiteinheit ausgef√ºhrt wird.  √Ñu√üerlich mag dies nicht nur als Pause in ihrer Arbeit erscheinen, sondern auch als ‚ÄûZusammenbruch‚Äú der Animation am Anfang.  Es scheint, dass der Browser st√§ndig etwas neu berechnet.  Dieses Verhalten wird fast immer mithilfe der Eigenschaft " <em>Sichtbarkeit</em> der <em>R√ºckseite"</em> korrigiert. </p><br><blockquote>  F√ºgen Sie nach M√∂glichkeit die Sichtbarkeit der R√ºckseite hinzu: Versteckt den animierten Elementen. </blockquote><p>  Die Neuerstellung des Layouts wird auch durch unsere Aufrufe von Elementen aus Skripten verursacht.  Dar√ºber hinaus muss dies keine direkte √Ñnderung von CSS sein, sondern kann auch einige Eigenschaften und Methoden von Elementen ansprechen.  Die h√§ufigsten sind: </p><br><pre> <code class="plaintext hljs">offset*** client*** inner*** scroll***</code> </pre> <br><p>  In Animationen sollten Sie vorsichtig mit ihnen sein, weil  Wenn wir f√ºr eine gro√üe Anzahl von Elementen auf diese Eigenschaften und Methoden verweisen, f√ºhrt dies jedes Mal zu einer Umstrukturierung des Layouts. </p><br><blockquote>  Vermeiden Sie es, auf die genannten Eigenschaften und Methoden f√ºr einzelne Elemente in Schleifen zu verweisen. </blockquote><br><h2 id="painting-i-layer-composition">  Malerei und Schichtzusammensetzung </h2><br><p>  Wir werden diese beiden Schritte zusammen betrachten, als  Sie sind etwas verwandt und normalerweise, wenn es Probleme mit dem einen gibt, werden sie mit dem anderen sein.  Das √úberspringen dieser Schritte und das Vermeiden dieser Schritte funktioniert nicht. Daher versuchen wir, sie irgendwie zu optimieren. </p><br><p>  Der Browser bereitet nicht das Pixelbild der Seite vor, sondern in Teilen - den Ebenen.  Es kann viele geben.  Jede Ebene existiert wie f√ºr sich und wirkt sich nicht auf den Rest aus, wodurch die Grundlage f√ºr einige CSS-Hacks geschaffen wird.  Aber wir werden ein anderes Mal dar√ºber sprechen.  Dann wird das endg√ºltige Bild von diesen Ebenen gesammelt.  Im Zusammenhang mit Animationen ist es sehr n√ºtzlich, animierte Elemente in einer separaten Ebene zu platzieren, damit ihre √Ñnderungen nicht alles beeinflussen.  Es ist w√ºnschenswert, dass der Inhalt der Elemente klein ist.  Wir k√∂nnen dies mit der Eigenschaft <em>will-change</em> tun oder wie zuvor <em>transformieren: translateZ (0)</em> .  Das Einzige, woran Sie sich erinnern sollten, ist, dass Sie die Anzahl der Ebenen nicht unbegrenzt erh√∂hen k√∂nnen.  Irgendwann wird dies einen Streich spielen und die entgegengesetzte Leistung wird sinken.  Es gibt also zwei Tipps: </p><br><blockquote>  Verwenden Sie will-change oder transform: translateZ (0), um die animierten Elemente auf eine separate Ebene zu verschieben. </blockquote><p>  aber zur gleichen Zeit </p><br><blockquote>  √úbertreiben Sie es nicht mit diesem Gesch√§ft.  √úberpr√ºfen Sie in den Entwicklertools, ob es nicht schlimmer ist. </blockquote><p>  Sehr oft werden schwerwiegende Probleme durch Filter verursacht, die das Bild der Elemente irgendwie ver√§ndern.  Es k√∂nnen einfache CSS-Filter mit <em>Unsch√§rfe</em> oder verwirrte Optionen mit SVG sein, aber der Effekt ist der gleiche - ein sp√ºrbarer Leistungsabfall. </p><br><blockquote>  Verwenden Sie keine komplexen Filter.  Wenn Sie den beabsichtigten Effekt weiterhin ben√∂tigen, sollten Sie ihn in WebGL implementieren. </blockquote><br><h2 id="naskolko-eti-sovety-rabotayut">  Wie funktionieren diese Tipps? </h2><br><p>  Sie funktionieren, aber Sie m√ºssen kein Wunder von ihnen erwarten.  Im Internet sagen Neulinge manchmal: "Ich habe eine Willens√§nderung hinzugef√ºgt, aber nichts hat sich ge√§ndert."  Normalerweise bedeutet dies, dass das Hauptproblem an einem anderen Ort lag und diese Technik die Produktivit√§t so geringf√ºgig steigerte, dass sie unbemerkt blieb.  Aus diesem Grund ist es wichtig, die Tools des Entwicklers zu verwenden, um genau zu verstehen, wo der Engpass liegt, und nicht Zeit und M√ºhe zu investieren, um zu optimieren, was ohnehin gut funktioniert. </p><br><p>  Aus all dem k√∂nnen wir schlie√üen, dass es nicht viele M√∂glichkeiten gibt, das Rendern einer Seite zu beeinflussen, und dass die Auswirkungen nicht immer signifikant sind.  Diese Tricks sind keine Silberkugeln, sondern werden zum Polieren der Animation ben√∂tigt.  Wenn wir uns Websites mit wirklich schlechter Leistung ansehen, werden wir feststellen, dass in den allermeisten F√§llen unsere eigenen Skripte schuld sind und keine mysteri√∂sen Probleme beim CSS-Parsing irgendwo im Darm des Browsers. </p><br><h2 id="skripty">  Skripte ... </h2><br><p>  Wissen Sie, wo Probleme mit hemmenden Animationen am h√§ufigsten auftreten (nach meinen Beobachtungen)?  Hier aus diesem Entwicklungsansatz: </p><br><p><img src="https://habrastorage.org/webt/31/ov/_a/31ov_auhpakgnb4tu2mtfapgi7w.jpeg" alt="Bild"></p><br><p>  Es klingt albern, ist es aber.  St√§ndig gibt es L√∂sungen, die offensichtlich vollst√§ndig von irgendwoher kopiert wurden, ohne zu verstehen, was geschah.  Es kommt sogar vor, dass Sie die H√§lfte des Codes entfernen k√∂nnen und alles weiterhin funktioniert.  Oft ist der Code in den Antworten auf SO oder Toaster nicht f√ºr Ihre Produktion vorgesehen.  Das sollte offensichtlich sein.  Er zeigt die Idee, beantwortet die Frage, ist aber keineswegs die optimale endg√ºltige Option f√ºr Ihre spezifische Aufgabe. </p><br><blockquote>  Wenn Sie bereits kopieren, √ºberpr√ºfen Sie zumindest den Code auf unn√∂tige Aktionen. </blockquote><br><h2 id="requestanimationframe">  RequestAnimationFrame </h2><br><p>  Sie sprechen oft √ºber diese Methode und empfehlen, sie in Animationen anstelle von <em>setTimeout / setInterval</em> zu verwenden.  Dies ist sinnvoll, da diese Methoden die Eigenschaft haben, nicht mit den vom Browser neu gezeichneten Frames synchron zu sein, was zu kleinen Verz√∂gerungen f√ºhrt.  Es gibt jedoch zwei Punkte. </p><br><p>  Erstens, wenn mehr als ein Element auf der Seite animiert ist und wir requestAnimationFrame mehrmals aufrufen, f√ºhrt dies zu einem starken Absinken von fps.  Theoretisch sollte das nicht so sein, aber in der Praxis passiert alles einfach so.  Hier k√∂nnen Sie sich mit den Tests vertraut machen. </p><br><blockquote>  Kombinieren Sie alle Animationsr√ºckrufe zu einem requestAnimationFrame. </blockquote><p>  Der zweite Punkt h√§ngt eher mit der Situation zusammen, in der wir bereits umfangreiche Animationen haben, m√∂glicherweise mit der Verwendung von Canvas, die wir nicht entfernen k√∂nnen oder f√ºr die wir keine Zeit zum <em>Wiederherstellen haben</em> . Folgendes geschieht: <em>Nehmen</em> wir an, die Animation sollte in N Sekunden abgeschlossen sein und wir verwenden bereits <em>requestAnimationFrame</em> .  Die Berechnung des aktuellen Status erfordert jedoch viele Ressourcen, und wir sehen dieses Bild: Die Animation funktioniert reibungslos, wundersch√∂n, jedoch in 2N oder sogar 3N Sekunden.  Infolgedessen wird alles soooooooooo wahrgenommen.  Um dieses Verhalten irgendwie zu korrigieren, k√∂nnen Sie gegen alle Empfehlungen <em>versto√üen</em> und dabei <em>setInterval / setTimeout verwenden</em> und die Zust√§nde animierter Elemente an die physische Zeit und nicht an abstrakte Frames binden.  Infolgedessen erhalten wir eine formale Abnahme der fps, jedoch mit dem psychologischen Effekt von Produktivit√§tsgewinnen. </p><br><blockquote>  Bei extrem langsamen Animationen kann es sinnvoll sein, requestAnimationFrame zugunsten von setInterval / setTimeout abzulehnen. </blockquote><br><h2 id="canvas-i-sheydery">  Leinwand und Shader </h2><br><p>  Ein wesentlicher Teil der Animationen auf nicht standardm√§√üigen Websites bezieht sich auf die Leinwand.  Das ist verst√§ndlich, CSS ist eine begrenzte Sache, aber hier k√∂nnen wir die Fantasien jedes Designers verwirklichen.  Beachten Sie jedoch, dass die √ºbliche 2D-Leinwand bei weitem nicht die produktivste Technologie ist.  Wenn Sie anfangen, viele Elemente darauf zu zeichnen oder direkt mit Pixeln zu arbeiten, werden Sie schnell feststellen, dass fps sinkt oder dass das <em>Malen</em> und die <em>Komposition</em> von Ebenen ganz pl√∂tzlich sehr viel Zeit in Anspruch nehmen.  Dieses Problem ist im Beispiel deutlich zu sehen: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/vdYRoj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Schauen wir uns an, was der Browser macht (das neueste Google Chrome unter Linux): </p><br><p><img src="https://habrastorage.org/webt/na/ox/5k/naox5kmmcqfuosbsfhgozpq91zw.jpeg" alt="Bild"></p><br><p>  Beachten Sie, um wie viel sich der <em>Ebenenzusammensetzungsschritt</em> erweitert hat.  Es sieht ein wenig unlogisch aus, weil es nur ein Element gibt, was kann dort so lange zusammengebaut werden?  Bei Verwendung von 2D-Canvas ist dieses Verhalten jedoch nicht ungew√∂hnlich, und etwas, das damit zu tun hat, ist sehr problematisch.  Dies ist einer der Gr√ºnde, warum wir normalerweise WebGL verwenden. Es gibt keine derartigen Fragen. </p><br><blockquote>  Wenn Sie zwischen 2D-Zeichenfl√§che und WebGL w√§hlen k√∂nnen, w√§hlen Sie die zweite.  Dies gibt einen anf√§nglichen Leistungsbonus f√ºr dieselben Aufgaben. </blockquote><p>  Was ist normalerweise mit WebGL verbunden?  Mit Shadern.  Und das Debuggen von Shadern bereitet jedem Kopfschmerzen, der mit ihnen arbeitet.  Und die Entwicklertools hier sind praktisch machtlos.  Wenn die Shader zu viele Berechnungen enthalten, sehen wir in der folgenden Zusammenfassung normalerweise, dass die meiste Zeit "einfach" ist. Dies ist in der Tat die Ausf√ºhrung unserer Shader unabh√§ngig vom Browser, und wir k√∂nnen keine n√ºtzlichen Details erhalten. </p><br><p>  Es gibt verschiedene Empfehlungen, welche Funktionen den Shadern vorzuziehen sind, da sie angeblich besser optimiert sind.  Oder dass Blockierungsvorg√§nge vermieden werden sollten.  Dies ist alles wahr, aber nach meinen Beobachtungen sind Shader, die die Site zu stark verlangsamen, in den meisten F√§llen einfach sehr gro√üe Shader.  Wenn Sie 100 GLSL-Zeilen an einer Stelle geschrieben haben, funktioniert dies fast garantiert schlecht.  Und wenn es auch verschiedene verschachtelte Konstruktionen gibt, Schleifen, dann ist alles - Schreiben - weg.  Es ist schwierig, hier Empfehlungen abzugeben, es sei denn: </p><br><blockquote>  Wenn Sie w√§hrend der Arbeit festgestellt haben, dass alles komplizierter ist, als es urspr√ºnglich schien, und dass es viel Code geben wird und sich verlangsamen wird, ist es besser, dies so schnell wie m√∂glich mit dem Designer und dem Kunden zu besprechen und dar√ºber nachzudenken, was ge√§ndert werden kann. </blockquote><p>  Oft kann man zu dem Schluss kommen, dass ein vorbereitetes Video viel besser funktioniert als der Versuch, eine verwirrte Sache in Echtzeit zu rendern.  Denken Sie daran.  Ja, jeder m√∂chte sich zeigen, er m√∂chte angeben, "aber ich kann es so machen", aber die Endbenutzer nicht vergessen. </p><br><p>  Im Zusammenhang mit diesem Gedanken erinnere ich mich an die ‚ÄûKrankheit‚Äú, f√ºr die die ehemalige Olympiade besonders anf√§llig ist.  Aus irgendeinem Grund manifestiert es sich stark bei der Arbeit mit Leinwand.  Aus diesem Grund sollten Sie den Code dieser Personen immer sorgf√§ltig kopieren.  Sie versuchen, die ‚Äûrichtigen‚Äú mathematischen Algorithmen, komplexe physikalische Formeln, zu verwenden, um alle Bewegungen der Elemente mit gro√üer Genauigkeit zu berechnen, selbst wenn sie v√∂llig nutzlos sind.  Dies f√ºhrt zu einer Erh√∂hung der Prozessorlast und zu der Tatsache, dass unsere bedingten 10 ms keine Zeit haben, etwas zu z√§hlen.  In der Praxis kommt man oft mit ungef√§hren Formeln und schulischen Kenntnissen der Physik aus.  Es ist nicht notwendig, Dinge zu komplizieren, wir erstellen Websites, keine Software f√ºr ballistische Raketen. </p><br><blockquote>  Verwenden Sie einfache Algorithmen. </blockquote><p>  Es gibt noch einen anderen Trick namens <em>RayMarching</em> .  Einige Leute betrachten die Erzeugung verschiedener Effekte als Herausforderung, als Aufw√§rm√ºbung f√ºr den Geist, und manchmal sind die Ergebnisse sehr beeindruckend.  Zum Beispiel wird hier eine ganze Unterwasserwelt erzeugt (ich habe ein Video eingef√ºgt, da sich das Telefon / Laptop nach Berechnungen in Echtzeit selbst aufh√§ngen kann): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mQXUHTTq4E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Den Shader selbst finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  In der Praxis erfordert dies alles unglaubliche Ressourcen, um zu arbeiten.  Im Vollbildmodus haben wir 400-800 ms pro Frame (in diesem Beispiel k√∂nnen es im Allgemeinen bis zu 1500 ms sein): </p><br><p><img src="https://habrastorage.org/webt/pj/jj/pj/pjjjpj9fu4fcqkvtqg2bggwhqhc.jpeg" alt="Bild"></p><br><p>  Wenn Sie sich also dabei erwischt haben, auf einer Kampfseite so etwas zu tun, geben Sie sich eine Tastatur auf den Kopf, trinken Sie Tee und √ºberlegen Sie, wie Sie Effekte implementieren k√∂nnen. </p><br><blockquote>  Verwenden Sie RayMarching nicht. Dies ist ein sicherer Weg, um die Leistung zu beeintr√§chtigen. </blockquote><br><h2 id="prakticheskiy-primer">  Praktisches Beispiel </h2><br><p>  Es gibt oft nicht genug Beispiele in Artikeln √ºber Produktivit√§t, aber es kann schwierig sein, ein Wort zu nehmen.  Betrachten Sie also ein Paar.  Erinnern Sie sich an das erste Beispiel f√ºr einen CSS-Spinntunnel?  Der Browser hat viele Dinge getan: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="Bild"></p><br><p>  Wir wollen die Dinge etwas beschleunigen.  Wo soll ich anfangen?  Wir sehen lila Bl√∂cke, was bedeutet, dass der Browser das Layout st√§ndig neu erstellt.  Es gibt dort keine Skripte, aber es gibt CSS-Animationen, in denen sich etwas √§ndert.  Schauen wir uns ihren Code an: </p><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> rotate { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(0); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(360deg); } } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move-block { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(0); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color1; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(-@block-size * 6); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color2; } }</code> </pre> <br><p>  Transformationen machen uns keine Angst, aber wir sehen eine Ver√§nderung im Hintergrund der Elemente.  Wir erinnern uns, dass dies zu einer Umstrukturierung des Layouts f√ºhren kann, und wir denken, was in dieser Situation getan werden kann ... </p><br><p>  Das √Ñndern des Hintergrunds muss um jeden Preis entfernt werden. Basierend auf der allgemeinen Idee der Animation entscheiden wir, dass Sie einen radialen Farbverlauf dar√ºber legen k√∂nnen, der fast den gleichen Volumeneffekt erzeugt.  Jemand wird sagen, dass Farbverl√§ufe die Leistung beeintr√§chtigen, aber wir werden sie nicht √§ndern.  Lassen Sie es besser sein, wenn es sich stark auswirkt, als wenn wir einen ganzen Berg von Elementen haben, die sich st√§ndig stark auswirken.  Das Ergebnis ist: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/OYLZpx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mal sehen, was der Browser macht: </p><br><p><img src="https://habrastorage.org/webt/0i/hc/oh/0ihcohn8cxnwbrq78qgmo8b0-w4.jpeg" alt="Bild"></p><br><p>  Wow ... Anstelle einer Reihe von Aktionen sehen wir seltene Aufrufe der GPU und sonst nichts, w√§hrend die Animation selbst merklich fl√ºssiger zu arbeiten begann. </p><br><h2 id="esche-primer">  Ein weiteres Beispiel </h2><br><p>  Erinnern Sie sich daran, wie der Browser im Ger√§uschgenerator aussah: </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="Bild"></p><br><p>  Das Problem liegt definitiv in den Skripten.  Es ist ersichtlich, dass der "Render" -Block der gr√∂√üte ist.  Dies ist unsere Hauptfunktion zum Rendern des Bildes.  Schauen wir sie uns an: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageData = CTX.createImageData(CTX.canvas.width, CTX.canvas.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imageData.data.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = getRandom(); imageData.data[i] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } CTX.putImageData(imageData, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><p>  Es wird definitiv mit einzelnen Pixeln gearbeitet.  Das ist nicht sehr gesund.  Wir sagten, wenn m√∂glich, ist es besser, nicht 2d-canvas, sondern WebGL zu verwenden, und diese Aufgabe m√∂chte nur mit einem Shader parallelisiert werden.  Lass es uns tun: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/sfi0zy/embed/preview/VOZxGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Was wird das Ergebnis sein?  √úberzeugen Sie sich selbst: </p><br><p><img src="https://habrastorage.org/webt/3m/td/vh/3mtdvhlrjo4-cjuqmzieis4tr7w.jpeg" alt="Bild"></p><br><p>  Die Zeit f√ºr einen Frame verringerte sich auf fast 16 ms.  Nat√ºrlich ist dies nicht ideal, aber immer noch besser als 80 ms.  In komplexen sch√∂nen Animationen kann ein solcher Leistungsgewinn sehr sp√ºrbar sein.  Ich nutze diese Gelegenheit, um Anf√§ngern zu empfehlen, sich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung von Shadern in die Programmierung</a> und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung mit Beispielen</a> vertraut zu machen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  In diesem Artikel haben wir herausgefunden, wie die Leistung von Animationen optimiert werden kann, wie die Entwicklertools in Chrome in diesem Kontext verwendet werden und worauf zuerst zu achten ist.  Ich hoffe, diese Informationen sind f√ºr Entwickler n√ºtzlich, die zum ersten Mal mit solchen Aufgaben konfrontiert sind und nicht wissen, wo sie anfangen sollen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450484/">https://habr.com/ru/post/de450484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450472/index.html">Wie erstelle ich eine perfekte Roadmap?</a></li>
<li><a href="../de450474/index.html">Python-Einf√ºhrung</a></li>
<li><a href="../de450476/index.html">Wie wir ein Unternehmen in der EU registriert haben</a></li>
<li><a href="../de450478/index.html">Heutzutage funktionieren viele beliebte Add-Ons f√ºr Firefox aufgrund von Zertifikatsproblemen nicht mehr.</a></li>
<li><a href="../de450480/index.html">Wie Quantencomputer die Softwareentwicklung beeinflussen k√∂nnen</a></li>
<li><a href="../de450486/index.html">9. Check Point Erste Schritte R80.20. Anwendungssteuerung und URL-Filterung</a></li>
<li><a href="../de450488/index.html">Chock Norris Fakten Android App auf Kotlin</a></li>
<li><a href="../de450490/index.html">6,9-Milliarden-Dollar-Deal: Warum kauft ein GPU-Entwickler einen Netzwerkger√§tehersteller?</a></li>
<li><a href="../de450492/index.html">Sozialarbeit und offenes Design. Einf√ºhrung</a></li>
<li><a href="../de450494/index.html">Wie h√§ngt die √úbersetzung des Begriffs Trunk vom Switch-Anbieter ab?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>