<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüî¨ ‚òÅÔ∏è üï∂Ô∏è Fundamentos de Futex üë®‚Äçüë¶‚Äçüë¶ üçë üî¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - abreviatura de "Fast userpace mutex") es un mecanismo propuesto por los desarrolladores de Linux de IBM en 2002 y entr√≥ en el n√∫cleo a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fundamentos de Futex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  <b>Futex</b> (futex - abreviatura de "Fast userpace mutex") es un mecanismo propuesto por los desarrolladores de Linux de IBM en 2002 y entr√≥ en el n√∫cleo a finales de 2003.  La idea principal era proporcionar una forma m√°s eficiente de sincronizar hilos de usuario con un n√∫mero m√≠nimo de llamadas al n√∫cleo del sistema operativo. <br><br>  En este art√≠culo, revisaremos los futexes, trataremos de comprender los principios de su trabajo y tambi√©n los utilizaremos como ladrillos para construir objetos de sincronizaci√≥n de nivel superior (y que nos son familiares). <br><br>  Un punto importante: futexes es una herramienta de bajo nivel, vale la pena usarla directamente solo al desarrollar bibliotecas fundamentales, como la biblioteca est√°ndar C / C ++.  Es muy poco probable que necesite usar futexes en una aplicaci√≥n normal. <br><a name="habracut"></a><br><h3>  Motivaci√≥n </h3><br>  Antes del advenimiento de los futexes, era necesario hacer llamadas al sistema (usando, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">semop</a> ) cada vez para controlar el acceso a los recursos compartidos desde varios subprocesos, lo que, como saben, requiere muchos recursos, ya que cada llamada requiere cambiar el contexto del modo de usuario al modo kernel.  Con el aumento en el n√∫mero de n√∫cleos en los procesadores modernos y el aumento en el n√∫mero de hilos en el software de aplicaci√≥n, esto se ha convertido en un problema importante.  Es a√∫n m√°s "ofensivo", dado que todas estas llamadas no tienen ninguna funci√≥n aplicada, no implementan ninguna l√≥gica de negocios, sino que solo garantizan el correcto funcionamiento del resto del c√≥digo. <br><br>  La propuesta de agregar un nuevo concepto de "futex" al sistema operativo se bas√≥ en una simple observaci√≥n: en la mayor√≠a de los casos, un intento de capturar un objeto de sincronizaci√≥n es exitoso la primera vez.  Los programadores escriben software de tal manera que pase el menor tiempo posible desde bloquear un bloqueo hasta desbloquearlo, lo que significa que hay muchas posibilidades de que un intento de capturar otro hilo no encuentre obst√°culos.  Cuando un flujo alcanza un objeto de sincronizaci√≥n "libre", podemos capturarlo sin hacer una llamada al sistema utilizando operaciones at√≥micas relativamente baratas.  Y existe una gran posibilidad de que la operaci√≥n at√≥mica funcione con √©xito. <br><br>  En ese raro caso, cuando a√∫n intentamos acceder a un recurso bloqueado por otro hilo, una operaci√≥n at√≥mica devolver√° un error.  En este caso, tenemos dos opciones.  Podemos girar en alg√∫n bloqueo de giro del modo de usuario, esperando la liberaci√≥n del recurso (que consumir√° los recursos de la CPU), o pedirle al n√∫cleo que nos ponga en modo de suspensi√≥n, esperando la liberaci√≥n del recurso.  Aqu√≠ es donde los futexes entran en escena. <br><br><h3>  Uso simple de futexes: expectativa y despertar </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La llamada al sistema futex</a> combina una gran variedad de funcionalidades.  Aqu√≠ no consideraremos opciones complejas (algunas de ellas son tan elaboradas que ni siquiera se describen en la documentaci√≥n oficial), sino que nos centraremos en las operaciones FUTEX_WAIT y FUTEX_WAKE.  La descripci√≥n en la documentaci√≥n oficial servir√° como una buena base: <br><blockquote>  La llamada al sistema futex () proporciona a los programas un m√©todo para esperar a que se cumpla una determinada condici√≥n.  Normalmente, esta llamada al sistema utiliza una construcci√≥n de bloqueo en el contexto de la sincronizaci√≥n de memoria compartida.  Cuando se usan futexes, las operaciones de sincronizaci√≥n principales se realizan en el espacio del usuario.  Los programas de espacio de usuario ejecutan la llamada al sistema futex () solo cuando es necesario que el programa entre en modo de espera durante un largo tiempo hasta que la condici√≥n se vuelva verdadera.  Adem√°s, futex () se puede usar para activar procesos o subprocesos que esperan una condici√≥n espec√≠fica. </blockquote>  En pocas palabras, un futex es una construcci√≥n del n√∫cleo que ayuda al c√≥digo del usuario a sincronizar hilos cuando sucede algo.  Algunos procesos (o subprocesos) pueden esperar eventos en una llamada FUTEX_WAIT, mientras que otros pueden llamar a estos eventos con FUTEX_WAKE.  La espera funciona de manera eficiente: el kernel suspende los subprocesos de espera y no utiliza los recursos del procesador hasta que se despiertan cuando ocurre un evento esperado. <br><br>  T√≥mese el tiempo para leer la documentaci√≥n en su totalidad.  Bueno, o al menos lea las secciones sobre FUTEX_WAIT y FUTEX_WAKE. <br><br>  Veamos un <a href="">ejemplo simple</a> que demuestra el uso b√°sico de los futexes para coordinar el trabajo de dos procesos. <br><br>  Proceso hijo: <br><br><ol><li>  Espera 0xA en la ranura de memoria general </li><li>  Escribe el valor 0xB en este espacio </li></ol><br>  Proceso principal en este momento: <br><br><ol><li>  Escribe un valor 0xA en una ranura de memoria compartida </li><li>  Espera a que aparezca 0xB en √©l </li></ol><br>  Tal "apret√≥n de manos" entre dos procesos.  Aqu√≠ est√° el c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Preste atenci√≥n a las llamadas POSIX para asignar memoria compartida entre procesos.  No podr√≠amos usar la asignaci√≥n de memoria habitual aqu√≠, ya que incluso la misma direcci√≥n de punteros en diferentes procesos apuntar√≠a realmente a diferentes bloques de memoria (√∫nicos para cada proceso). <br><br>  Cabe se√±alar que este ejemplo se desv√≠a un poco de los c√°nones, porque el futex se cre√≥ originalmente para esperar un cambio en un cierto significado "de algo espec√≠fico a cualquier cosa", y no "de algo a algo espec√≠fico".  Di este ejemplo para demostrar tal posibilidad, y a continuaci√≥n consideraremos la versi√≥n b√°sica (en ella implementamos el mutex). <br><br>  Y aqu√≠ est√° el c√≥digo de funci√≥n wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  La tarea principal de esta funci√≥n (adem√°s, en realidad, la llamada al sistema futex) es un ciclo en el que corremos cuando nos despertamos en falso (no nos interesa).  Esto puede suceder cuando se instala un nuevo valor, pero no esperado por nosotros, en la ranura de memoria compartida.  Bueno, o en el caso de que otro proceso se haya despertado antes que el nuestro (esto no puede suceder en nuestro caso particular, pero de una manera m√°s general es posible). <br><br>  ¬°La sem√°ntica de Futex es bastante complicada!  La llamada FUTEX_WAIT volver√° inmediatamente si el valor en la direcci√≥n futex no es igual al argumento val valido.  En nuestro caso, esto puede suceder si el proceso secundario fue a esperar antes de que el padre escribiera el valor 0xA en la ranura.  El futex en este caso devuelve el valor EAGAIN. <br><br>  Y aqu√≠ est√° el c√≥digo de la funci√≥n wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Este es un contenedor de bloqueo sobre FUTEX_WAKE que funcionar√° r√°pidamente y devolver√° un valor, sin importar cu√°ntos oyentes lo esperen.  En nuestro ejemplo, esto se usa como parte de un "apret√≥n de manos", pero son posibles otros usos. <br><br><h3>  Los futexes son colas de kernel para c√≥digo personalizado. </h3><br>  En pocas palabras, un futex es una cola impulsada por el n√∫cleo para resolver tareas de c√≥digo personalizado.  Permite que el c√≥digo de usuario solicite al n√∫cleo que suspenda la ejecuci√≥n de su subproceso hasta que se produzca un evento, y al otro subproceso al mismo tiempo para se√±alar este evento y activar todos los subprocesos que lo esperan.  Anteriormente mencionamos la capacidad de organizar un bloqueo de giro en modo de usuario, esperando que se cumpla alguna condici√≥n.  Sin embargo, la cola en el n√∫cleo es una alternativa mucho mejor, ya que nos salva de miles de millones de instrucciones de procesador desperdiciadas ejecutadas en un ciclo de espera. <br><br>  Aqu√≠ est√° el diagrama del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Descripci√≥n general y actualizaci√≥n de futex"</a> en LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="imagen"><br><br>  En el c√≥digo del kernel de Linux, los futexes se implementan en el archivo kernel / futex.c.  El kernel almacena una tabla hash donde las claves son direcciones, para encontrar r√°pidamente la cola deseada y agregarle el proceso de llamada.  Todo, por supuesto, no es tan simple: despu√©s de todo, el n√∫cleo mismo necesita sincronizar el acceso a los datos internos, adem√°s de admitir todo tipo de opciones adicionales para futeksov. <br><br><h3>  Espera por tiempo limitado con FUTEX_WAIT </h3><br>  La llamada al sistema futex tiene un par√°metro de tiempo de espera que permite al usuario especificar cu√°nto tiempo est√°n listos para esperar.  Aqu√≠ hay un <a href="">ejemplo</a> completo donde se implementa esto, pero aqu√≠ est√° la parte clave: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Si la espera se retrasa 500 ms, entonces la funci√≥n futex finalizar√°, y en la pr√≥xima iteraci√≥n del ciclo podemos reaccionar de alguna manera a esto (mostrar algo en la pantalla, escribir en el registro, continuar la espera o detener). <br><br><h3>  Usando un futex para implementar un mutex </h3><br>  Comenzamos este art√≠culo con el hecho de que los futexes son de uso pr√°ctico en la implementaci√≥n de objetos de sincronizaci√≥n de nivel superior.  Intentemos usarlos (as√≠ como los at√≥micos) para implementar el mutex cl√°sico.  La implementaci√≥n a continuaci√≥n se basa en el c√≥digo del art√≠culo "Futexes are Tricky" escrito por Ulrich Drepper. <br><br>  Para este ejemplo, uso C ++, principalmente por la capacidad de usar at√≥micos del est√°ndar C ++ 11.  Puede encontrar el c√≥digo completo <a href="">aqu√≠</a> , pero la parte m√°s importante es: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  En este c√≥digo, la funci√≥n cmpxhg es un contenedor simple para un uso m√°s conveniente de los √°tomos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Este ejemplo de c√≥digo contiene muchos comentarios que explican la l√≥gica de su funcionamiento.  Esto no afectar√°, porque existe un riesgo significativo de que desee escribir una versi√≥n un poco m√°s simple pero completamente incorrecta.  En cuanto a este c√≥digo, tampoco es perfecto en todo.  Por ejemplo, intenta hacer una suposici√≥n sobre un dispositivo interno del tipo std :: atomic, enviando su contenido a int * para pasar a la llamada futex.  Este generalmente no es el caso.  El c√≥digo se compila y se ejecuta en Linux x64, pero no tenemos garant√≠a de compatibilidad con otras plataformas.  Para obtenerlo, necesitamos agregar una capa de dependencia de plataforma para los √°tomos.  Como este no es el tema de este art√≠culo (y tambi√©n porque es muy poco probable que mezcle futexes en el mismo m√≥dulo C ++), omitiremos esta implementaci√≥n.  ¬°Esto es solo una demostraci√≥n! <br><br><h3>  Mutexes Glibc y cerraduras de bajo nivel </h3><br>  Entonces llegamos al punto donde glibc implementa hilos POSIX, parte del cual es el tipo pthread_mutex_t.  Como dije al comienzo de este art√≠culo, los futexes no son lo que un desarrollador ordinario necesitar√°.  Los utilizan las bibliotecas de tiempo de ejecuci√≥n o algo muy especializado para implementar primitivas de sincronizaci√≥n de nivel superior.  En este contexto, es interesante observar la implementaci√≥n del mutex para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NPTL</a> .  En el c√≥digo glibc, este es el archivo nptl / pthread_mutex_lock.c. <br><br>  El c√≥digo es bastante complicado debido a la necesidad de admitir varios tipos de mutexes, pero podemos encontrar bloques bastante familiares si lo desea.  Tambi√©n puede echar un vistazo a los archivos sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h y nptl / lowlevellock.c.  El c√≥digo es algo confuso, pero a√∫n as√≠ la combinaci√≥n de comparar e intercambiar y llamadas futex es f√°cil. <br><br>  El comentario inicial del archivo systeds / nptl / lowlevellock.h ya debe ser bien entendido por usted: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Ir en tiempo de ejecuci√≥n futexes </h3><br>  Rantime Go no usa libc (en la mayor√≠a de los casos).  Por lo tanto, no puede confiar en la implementaci√≥n de hilos POSIX.  En cambio, llama directamente a las llamadas del sistema de nivel inferior.  Esto lo convierte en un buen ejemplo de uso de futexes.  Como no hay forma de llamar a pthread_mutex_t, debe escribir su propio reemplazo.  Veamos c√≥mo se hace esto, comencemos con el tipo sync.Mutex visible para el usuario (en src / sync / mutex.go). <br><br>  El m√©todo de bloqueo de este tipo intenta utilizar la operaci√≥n de intercambio at√≥mico para capturar r√°pidamente el bloqueo.  Si resulta que necesita esperar, llama a runtime_SemacquireMutex, que llama a runtime.lock.  Esta funci√≥n se define en src / runtime / lock_futex.go y declara varias constantes que pueden resultarle familiares: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock tambi√©n est√° tratando de capturar el bloqueo usando una funci√≥n at√≥mica.  Esto tiene sentido, ya que runtime.lock se llama en muchos lugares del tiempo de ejecuci√≥n Go, pero me parece que ser√≠a posible optimizar de alguna manera el c√≥digo eliminando dos llamadas consecutivas de la funci√≥n at√≥mica al llamar a runtime.lock desde Mutex.lock. <br><br>  Si resulta que necesita esperar, se llama a la funci√≥n dependiente de la plataforma futexsleep, que se define para Linux en el archivo src / runtime / os_linux.go.  Esta funci√≥n realiza una llamada al sistema futex con el c√≥digo FUTEX_WAIT_PRIVATE (en este caso, esto es adecuado, ya que el tiempo de ejecuci√≥n Go vive en un proceso). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418705/">https://habr.com/ru/post/es418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418691/index.html">Ganadero: Kubernetes en 5 minutos sobre metal desnudo.</a></li>
<li><a href="../es418693/index.html">¬øPor qu√© es tan dif√≠cil detectar la felicidad en el cerebro?</a></li>
<li><a href="../es418695/index.html">Guerras contra la pirater√≠a: el imperio contraataca</a></li>
<li><a href="../es418699/index.html">Creaci√≥n de una m√°quina arcade emulador. Parte 3</a></li>
<li><a href="../es418701/index.html">Estudiamos analizadores sint√°cticos para el idioma ruso</a></li>
<li><a href="../es418707/index.html">KDispatcher: bus de eventos ligero y conveniente para el uso diario</a></li>
<li><a href="../es418709/index.html">Necesidad de forzarse: controladores y barreras de interfaz</a></li>
<li><a href="../es418711/index.html">Token Managed Registers 1.0</a></li>
<li><a href="../es418713/index.html">Juego para mejorar la calidad de Wikipedia</a></li>
<li><a href="../es418715/index.html">¬øQu√© tan eficiente es el sistema de archivos virtuales procfs? ¬øEs posible optimizarlo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>