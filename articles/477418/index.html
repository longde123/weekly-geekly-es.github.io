<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèº üêò üë®üèº‚Äçüîß Refracci√≥n de tres lados en tres pasos. üè∞ üôçüèª üí¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando renderiza un objeto 3D, siempre necesita agregarle material para que sea visible y se vea de la manera deseada; no importa si haces esto en pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refracci√≥n de tres lados en tres pasos.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477418/"><p>  Cuando renderiza un objeto 3D, siempre necesita agregarle material para que sea visible y se vea de la manera deseada;  no importa si haces esto en programas especiales o en tiempo real a trav√©s de WebGL. </p><br><p>  La mayor parte del material se puede simular usando las herramientas integradas de bibliotecas como Three.js, pero en este tutorial le mostrar√© c√≥mo hacer que los objetos se vean como vidrio en tres pasos usando, lo adivin√≥, Three.js. </p><a name="habracut"></a><br><h1 id="shag-1-nastroyka-i-frontalnye-otrazheniya">  Paso 1: configuraci√≥n y reflejos frontales </h1><br><p>  En este ejemplo, usar√© la geometr√≠a del diamante, pero puedes usar un cubo simple o cualquier otra forma. </p><br><p> Configuremos nuestro proyecto.  Necesitamos un visualizador, una escena, una c√°mara y geometr√≠a.  Para visualizar nuestra superficie, necesitamos material.  La creaci√≥n de este material ser√° el objetivo principal de la lecci√≥n.  Entonces, creemos un nuevo objeto SharedMaterial con sombreadores de v√©rtices y fragmentos. </p><br><p>  Contrariamente a sus expectativas, nuestro material no ser√° transparente, de hecho, distorsionaremos lo que estar√° detr√°s del diamante.  Para hacer esto, necesitaremos visualizar la escena (sin diamante) en la textura.  Solo renderizo un plano del tama√±o de todo el alcance usando una c√°mara ortogonal, pero tambi√©n puede renderizar una escena con otros objetos.  La forma m√°s f√°cil de separar la superficie de fondo del diamante en Three.js es usar Capas. </p><br><pre><code class="plaintext hljs">this.orthoCamera = new THREE.OrthographicCamera( width / - 2,width / 2, height / 2, height / - 2, 1, 1000 ); //    1  (0    ) this.orthoCamera.layers.set(1); const tex = await loadTexture('texture.jpg'); this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial({map: tex})); this.quad.scale.set(width, height, 1); //      1  this.quad.layers.set(1); this.scene.add(this.quad);</code> </pre> <br><p>  Nuestro ciclo de visualizaci√≥n se ver√° as√≠: </p><br><pre> <code class="plaintext hljs">this.envFBO = new THREE.WebGLRenderTarget(width, height); this.renderer.autoClear = false; render() { requestAnimationFrame( this.render ); this.renderer.clear(); //    fbo this.renderer.setRenderTarget(this.envFbo); this.renderer.render( this.scene, this.orthoCamera ); //      this.renderer.setRenderTarget(null); this.renderer.render( this.scene, this.orthoCamera ); this.renderer.clearDepth(); //      this.renderer.render( this.scene, this.camera ); };</code> </pre> <br><p>  Genial, es hora de una peque√±a excursi√≥n a la teor√≠a.  Los materiales transparentes como el vidrio son visibles porque refractan la luz.  Esto se debe a que la luz atraviesa el vidrio m√°s lentamente que a trav√©s del aire, y cuando el haz de luz colisiona con dicho objeto en √°ngulo, la diferencia de velocidad hace que la luz cambie de direcci√≥n.  Este cambio de direcci√≥n es lo que se entiende por refracci√≥n. </p><br><p><img src="https://habrastorage.org/webt/_4/o7/hf/_4o7hfjpgetrsynhrjlxdvnl8bq.png"></p><br><p>  Para repetir esto en c√≥digo, necesitamos saber el √°ngulo entre el vector de direcci√≥n de la mirada y la superficie normal.  Cambiemos el sombreador de v√©rtices para contar estos vectores. </p><br><pre> <code class="plaintext hljs">varying vec3 eyeVector; varying vec3 worldNormal; void main() { vec4 worldPosition = modelMatrix * vec4( position, 1.0); eyeVector = normalize(worldPos.xyz - cameraPosition); worldNormal = normalize( modelViewMatrix * vec4(normal, 0.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</code> </pre> <br><p>  En el sombreador de fragmentos, ahora podemos usar <code>eyeVector</code> y <code>worldNormal</code> como los dos primeros par√°metros en la funci√≥n de <em><code>refract</code></em> integrada en <em><code>refract</code></em> .  El tercer par√°metro es la relaci√≥n de los √≠ndices de refracci√≥n, es decir, el √≠ndice de refracci√≥n (IOR) de nuestro medio denso de vidrio.  En nuestro caso, ser√° 1.0 / 1.5, pero puede cambiar este valor para lograr el resultado deseado.  Por ejemplo, el √≠ndice de refracci√≥n del agua es 1.33, y el del diamante es 2.42. </p><br><pre> <code class="plaintext hljs">uniform sampler2D envMap; uniform vec2 resolution; varying vec3 worldNormal; varying vec3 viewDirection; void main() { // get screen coordinates vec2 uv = gl_FragCoord.xy / resolution; vec3 normal = worldNormal; // calculate refraction and add to the screen coordinates vec3 refracted = refract(eyeVector, normal, 1.0/ior); uv += refracted.xy; // sample the background texture vec4 tex = texture2D(envMap, uv); vec4 output = tex; gl_FragColor = vec4(output.rgb, 1.0); }</code> </pre> <br><p>  <a href="https://codesandbox.io/embed/multi-side-refraction-step-13-pzxf9%3Ffontsize%3D14%26hidenavigation%3D1%26theme%3Ddark">https://codesandbox.io/embed/multi-side-refraction-step-13-pzxf9?fontsize=14&amp;hidenavigation=1&amp;theme=dark</a> </p><br><p>  Genial  Hemos escrito con √©xito un sombreador.  Pero el diamante es apenas visible ... En parte porque procesamos solo una propiedad del vidrio.  No toda la luz pasar√° a trav√©s de ella y ser√° refractada; de hecho, parte se reflejar√°.  ¬°Veamos c√≥mo lograr esto! </p><br><h1 id="shag-2-otrazheniya-i-uravnenie-frenelya">  Paso 2: Reflexiones y la ecuaci√≥n de Fresnel </h1><br><p>  En aras de la simplificaci√≥n, en esta lecci√≥n no calcularemos las refracciones reales, sino que simplemente usaremos el blanco para la luz refractada.  Vamos m√°s all√°: ¬øc√≥mo saber cu√°ndo reflexionar y cu√°ndo refractar?  En teor√≠a, esto depende del √≠ndice de refracci√≥n del material: cuando el √°ngulo entre el vector incidente y la superficie normal es mayor que el valor umbral, la luz se reflejar√°. </p><br><p><img src="https://habrastorage.org/webt/0-/t_/2z/0-t_2zkuxkmtvjcp6wurrxcsu3o.png"></p><br><p>  En el sombreador de fragmentos, utilizaremos la ecuaci√≥n de Fresnel para calcular las proporciones entre los rayos reflejados y refractados.  Desafortunadamente, glsl no tiene esta ecuaci√≥n, puede copiarla desde aqu√≠: </p><br><pre> <code class="plaintext hljs">float Fresnel(vec3 eyeVector, vec3 worldNormal) { return pow( 1.0 + dot( eyeVector, worldNormal), 3.0 ); }</code> </pre> <br><p>  Simplemente podemos mezclar el color de textura del rayo refractado con el color blanco reflejado usando la proporci√≥n que acabamos de calcular. </p><br><pre> <code class="plaintext hljs">uniform sampler2D envMap; uniform vec2 resolution; varying vec3 worldNormal; varying vec3 viewDirection; float Fresnel(vec3 eyeVector, vec3 worldNormal) { return pow( 1.0 + dot( eyeVector, worldNormal), 3.0 ); } void main() { // get screen coordinates vec2 uv = gl_FragCoord.xy / resolution; vec3 normal = worldNormal; // calculate refraction and add to the screen coordinates vec3 refracted = refract(eyeVector, normal, 1.0/ior); uv += refracted.xy; // sample the background texture vec4 tex = texture2D(envMap, uv); vec4 output = tex; // calculate the Fresnel ratio float f = Fresnel(eyeVector, normal); // mix the refraction color and reflection color output.rgb = mix(output.rgb, vec3(1.0), f); gl_FragColor = vec4(output.rgb, 1.0); }</code> </pre> <br><p>  <a href="https://codesandbox.io/embed/multi-side-refraction-step-23-3vdty%3Ffontsize%3D14%26hidenavigation%3D1%26theme%3Ddark">https://codesandbox.io/embed/multi-side-refraction-step-23-3vdty?fontsize=14&amp;hidenavigation=1&amp;theme=dark</a> </p><br><p>  Ya se ve mucho mejor, pero falta algo m√°s ... Exactamente, no vemos la parte posterior del objeto transparente.  ¬°Vamos a arreglarlo! </p><br><h1 id="shag-3-mnogostoronnee-prelomlenie">  Paso 3: refracci√≥n multilateral </h1><br><p>  Teniendo en cuenta lo que ya hemos aprendido sobre las refracciones y los reflejos, se puede entender que la luz puede ir y venir dentro de un objeto muchas veces antes de abandonarlo. <br>  Para lograr el resultado correcto, desde un punto de vista f√≠sico, tendremos que rastrear cada rayo, pero, desafortunadamente, tales c√°lculos son demasiado pesados ‚Äã‚Äãpara la visualizaci√≥n en tiempo real.  Entonces, en cambio, le mostrar√© c√≥mo usar la aproximaci√≥n para al menos mostrar los bordes ocultos del diamante. <br>  Necesitaremos un mapa normal y caras frontales y posteriores en un sombreador de fragmentos.  Como no podemos visualizar ambos lados al mismo tiempo, primero necesitamos obtener los bordes posteriores como una textura. </p><br><p><img src="https://habrastorage.org/webt/mt/7w/7o/mt7w7ogayxholyesxv3m3extrni.jpeg"></p><br><p>  Cree un nuevo <code>ShaderMaterial</code> como en el primer paso, pero ahora representaremos el mapa normal en <code>gl_FragColor</code> . </p><br><pre> <code class="plaintext hljs">varying vec3 worldNormal; void main() { gl_FragColor = vec4(worldNormal, 1.0); }</code> </pre> <br><p>  A continuaci√≥n, actualizamos el ciclo de visualizaci√≥n y agregamos el procesamiento de las caras posteriores. </p><br><pre> <code class="plaintext hljs">this.backfaceFbo = new THREE.WebGLRenderTarget(width, height); ... render() { requestAnimationFrame( this.render ); this.renderer.clear(); // render background to fbo this.renderer.setRenderTarget(this.envFbo); this.renderer.render( this.scene, this.orthoCamera ); // render diamond back faces to fbo this.mesh.material = this.backfaceMaterial; this.renderer.setRenderTarget(this.backfaceFbo); this.renderer.clearDepth(); this.renderer.render( this.scene, this.camera ); // render background to screen this.renderer.setRenderTarget(null); this.renderer.render( this.scene, this.orthoCamera ); this.renderer.clearDepth(); // render diamond with refraction material to screen this.mesh.material = this.refractionMaterial; this.renderer.render( this.scene, this.camera ); };</code> </pre> <br><p>  Ahora usamos una textura con normales en el material. </p><br><pre> <code class="plaintext hljs">vec3 backfaceNormal = texture2D(backfaceMap, uv).rgb;</code> </pre> <br><p>  Y finalmente, las normales de las caras frontal y posterior son compatibles. </p><br><pre> <code class="plaintext hljs">float a = 0.33; vec3 normal = worldNormal * (1.0 - a) - backfaceNormal * a;</code> </pre> <br><p>  En esta ecuaci√≥n, a es solo una cantidad escalar que muestra cu√°ntas normales de los bordes finales utilizar. </p><br><p>  <a href="https://codesandbox.io/embed/multi-side-refraction-step-33-ljnqj%3Ffontsize%3D14%26hidenavigation%3D1%26theme%3Ddark">https://codesandbox.io/embed/multi-side-refraction-step-33-ljnqj?fontsize=14&amp;hidenavigation=1&amp;theme=dark</a> </p><br><p>  Result√≥!  Todos los lados del diamante son visibles solo con la ayuda de reflejos y refracciones, que agregamos al material. </p><br><h1 id="ogranicheniya">  Limitaciones </h1><br><p>  Como ya he explicado, no es muy posible obtener materiales transparentes en tiempo real que sean f√≠sicamente correctos utilizando este m√©todo.  Otro problema es visualizar varios objetos de vidrio uno frente al otro.  Como visualizamos el fondo solo una vez, no funcionar√° verlo a trav√©s de una serie de objetos.  Y finalmente, los reflejos en el campo de visibilidad que demostr√© aqu√≠ no funcionar√°n normalmente en los bordes de la pantalla, porque los rayos pueden refractarse con valores que van m√°s all√° de los bordes del plano, y no podremos captar estos casos al convertir la escena en una textura. </p><br><p>  Por supuesto, hay formas de sortear estas limitaciones, pero no todas ser√°n excelentes soluciones de WebGL. </p><br><p>  Espero que hayas disfrutado este tutorial y hayas aprendido algo nuevo.  ¬°Me pregunto qu√© har√°s con √©l ahora!  Av√≠same en <a href="https://twitter.com/jesper_vos">Twitter</a>  ¬°Y si√©ntase libre de preguntarme sobre todo! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477418/">https://habr.com/ru/post/477418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477404/index.html">El problema de crear y eliminar objetos con frecuencia en C ++</a></li>
<li><a href="../477406/index.html">Soporte t√©cnico y soporte. Gran investigaci√≥n sobre el mercado laboral y los salarios. ¬øQu√© ha cambiado en 2 a√±os?</a></li>
<li><a href="../477408/index.html">Tutorial JavaFX: dise√±os avanzados</a></li>
<li><a href="../477414/index.html">Ingeniero de datos: la profesi√≥n m√°s sexy del siglo XXI</a></li>
<li><a href="../477416/index.html">¬øCu√°ndo es perjudicial para el hach√≠s?</a></li>
<li><a href="../477426/index.html">Si hubiera ciudades en Marte ... ¬øQu√© har√≠a la gente con HighLoad ++ all√≠?</a></li>
<li><a href="../477428/index.html">Red bayesiana, monedas y la crisis global</a></li>
<li><a href="../477430/index.html">La historia de un solo servidor con enfriamiento pasivo</a></li>
<li><a href="../477434/index.html">Malla de servicio para microservicios. Parte II, los fundamentos de trabajar con Istio</a></li>
<li><a href="../477436/index.html">C√≥mo escribir una calculadora simple cliente-servidor (JavaFX + EJB + WildFly)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>