<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äç‚öñÔ∏è üóúÔ∏è üèø Memo. AVR Buzic ‚è∫Ô∏è üé£ üôéüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Essenz 
 Ich habe bereits eine Reihe verschiedener elektronischer Hobbyger√§te entwickelt und habe eine merkw√ºrdige Eigenschaft: Wenn sich auf dem Boar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memo. AVR Buzic</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402329/"><img src="https://habrastorage.org/files/a62/a7b/0f9/a62a7b0f93e34b378c415b8d4b1873bb.jpg"><br><h3>  Essenz </h3><br>  Ich habe bereits eine Reihe verschiedener elektronischer Hobbyger√§te entwickelt und habe eine merkw√ºrdige Eigenschaft: Wenn sich auf dem Board ein piezoelektrischer Soundemitter (Summer) befindet, leide ich nach Abschluss der Hauptarbeit an dem Projekt unter Unsinn und lasse ihn verschiedene Melodien spielen (so viel wie m√∂glich) )  Es ist besonders n√ºtzlich, am Ende eines l√§ngeren Prozesses eine Melodie einzuf√ºgen, um die Aufmerksamkeit auf sich zu ziehen.  Ich habe es zum Beispiel verwendet, als ich eine provisorische Belichtungskamera gebaut habe, um den Fotolack usw. zu beleuchten. <br><br>  Als ich jedoch nach Beispielen f√ºr die Frequenzerzeugung f√ºr AVR im Netzwerk suchte, stie√ü ich aus irgendeinem Grund auf monstr√∂se oder unzureichend pr√§zise Projekte, bei denen die Erzeugung von Schallfrequenzen rein programmatisch implementiert wurde.  Und dann habe ich beschlossen, es selbst herauszufinden ... <br><a name="habracut"></a><br><h3>  Lyrischer Exkurs </h3><br>  Mein Hobby umfasst die Erstellung verschiedener Ger√§te auf Mikrocontrollern, da dies nicht mit meinem prof.  Aktivit√§t (Softwareentwicklung) halte ich f√ºr einen absoluten Autodidakt und bin in der Elektronik nicht zu stark.  Tats√§chlich bevorzuge ich PIC-Mikrocontroller, aber es ist einfach so passiert, dass ich eine bestimmte Anzahl von Atmel AVR-Mikrocontrollern (jetzt Microchip) angesammelt habe.  Machen Sie sofort eine Reservierung, dass ich nie AVR in meinen H√§nden hatte, d. H.  Dies ist mein erstes Projekt auf der Atmel MCU, n√§mlich Atmega48pa.  Das Projekt selbst f√ºhrt eine gewisse Nutzlast aus, aber hier werde ich nur einen Teil davon beschreiben, der sich auf die Erzeugung von Schallfrequenzen bezieht.  Den Test zur Erzeugung von Frequenzen habe ich "buzic" genannt, als Abk√ºrzung f√ºr Summer's Music.  Ja, ich h√§tte es fast vergessen: Auf Habr gibt es einen Benutzer mit dem Spitznamen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">buzic</a> . Ich wollte sofort warnen, dass dieses Memo in keiner Weise f√ºr ihn gilt, und f√ºr den Fall, dass ich mich sofort f√ºr die Verwendung der Buchstabenkombination "Buzic" entschuldige. <br><br><h3>  Also lass uns gehen </h3><br>  Ich habe eine gro√üe Anzahl von Beispielen aus dem Netzwerk kennengelernt - alle basieren entweder auf dem einfachsten Zyklus im Hauptteil der Firmware oder auf der Unterbrechung des Timers.  Aber alle verwenden denselben Ansatz, um Frequenz zu erzeugen: <br><br><ol><li>  F√ºhren Sie dem Fu√ü des Mikrocontrollers einen hohen F√ºllstand zu </li><li>  eine Verz√∂gerung machen </li><li>  Zuf√ºhren Sie den Fu√ü des Mikrocontrollers tief </li></ol><br>  √Ñndern der Verz√∂gerungen und Timer-Einstellungen - Passen Sie die Frequenz an. <br><br>  Dieser Ansatz passte mir nicht sehr, weil  Ich hatte keine Lust, Code f√ºr die manuelle Steuerung des Fu√ües des Mikrocontrollers zu schreiben.  Ich m√∂chte, dass der ‚ÄûStein‚Äú die Schallfrequenz f√ºr mich erzeugt, und ich stelle nur die Werte bestimmter Register ein und √§ndere sie dadurch (Frequenz). <br><br>  Beim Studium des Datenblattes (im Folgenden als DS bezeichnet) habe ich immer noch den ben√∂tigten Timer-Modus gefunden - und dieser Modus ist, wie Sie vielleicht vermutet haben, der CTC-Modus (Clear Timer on Compare Match).  Da die Funktion der Musikwiedergabe, gelinde gesagt, nicht die Hauptfunktionalit√§t ist, habe ich es vorgezogen, Timer 2 daf√ºr auszuw√§hlen (Absatz 22 der SD). <br><br>  Jeder wei√ü, dass praktisch jeder Mikrocontroller √ºber einen PWM-Signalerzeugungsmodus verf√ºgt, der auf Timern implementiert ist und vollst√§ndig aus Hardware besteht.  Aber f√ºr diese Aufgabe ist PWM nicht geeignet, weil  In der Hardware wird nur eine Frequenz generiert.  Deshalb brauchen wir PFM (Pulsfrequenzmodulation).  Eine gewisse √Ñhnlichkeit von PFM besteht im CTC-Timer-Modus (Abschnitt 22.7.2 LH). <br><br><h3>  CTC-Modus </h3><br>  Timer 2 im Atmega48pa-Mikrocontroller ist 8-Bit, dh er ‚Äûtickt‚Äú von 0 bis 255 und geht dann in einem Kreis.  Der Timer kann √ºbrigens in eine andere Richtung gehen, in unserem Fall jedoch nicht.  Die n√§chste erforderliche Komponente ist die Vergleichseinheit.  Dieses Modul ist der Initiator aller Ereignisse, die sich auf den Timer beziehen.  Ereignisse k√∂nnen unterschiedlich sein - wie Unterbrechungen, √Ñnderungen des Pegels bestimmter Beine des Mikrocontrollers usw. (Offensichtlich interessieren wir uns f√ºr die zweite).  Wie Sie sich vorstellen k√∂nnen, wird das Vergleichsmodul nicht nur benannt, sondern es vergleicht einen bestimmten vom Firmware-Entwickler ausgew√§hlten Wert mit dem aktuellen Timer-Wert.  Wenn der Timer-Wert den von uns festgelegten Wert erreicht, tritt ein Ereignis auf.  Ereignisse k√∂nnen auch auftreten, wenn der Timer √ºberl√§uft oder w√§hrend eines Zur√ºcksetzens.  <b>Ok, wir sind zu dem Schluss gekommen, dass es f√ºr uns zu bestimmten Zeiten g√ºnstig ist, dass der Timer zusammen mit dem Vergleichsmodul den Pegel am Fu√ü des Mikrocontrollers unabh√§ngig in die entgegengesetzte Richtung √§ndert und so Impulse erzeugt.</b> <br><br>  Die zweite Aufgabe besteht darin, die Intervalle zwischen diesen Impulsen einzustellen - d.h.  Steuern Sie die H√§ufigkeit der Erzeugung.  Die ganze Einzigartigkeit des CTC-Modus liegt in der Tatsache, dass in diesem Modus der Timer nicht bis zum Ende (255) l√§uft, sondern zur√ºckgesetzt wird, wenn der eingestellte Wert erreicht ist.  Dementsprechend k√∂nnen wir durch √Ñndern dieses Werts tats√§chlich die Frequenz steuern.  Wenn wir beispielsweise den Wert des Vergleichsmoduls auf 10 setzen, tritt die Pegel√§nderung am Fu√ü des Mikrocontrollers 20-mal h√§ufiger auf als wenn wir ihn (den Wert des Vergleichsmoduls) auf 200 setzen. <b>Jetzt k√∂nnen wir die Frequenz steuern!</b> <br><br><img src="https://habrastorage.org/files/d45/90e/b7a/d4590eb7acd543a59fc71057cc6ae5b5.png"><br><br><h3>  Eisen </h3><br><img src="https://habrastorage.org/files/8f9/dbb/8f5/8f9dbb8f514f4819863dff1a4dff4690.png"><br>  Die Pinbelegung des Mikrocontrollers zeigt, dass wir unseren Summer entweder an das Bein von PB3 (OC2A) oder an das Bein von PD3 (OC2B) anschlie√üen m√ºssen, weil  OC2A und OC2B bedeuten genau, dass Timer 2 auf diesen Beinen Signale erzeugen kann. <br><br>  Das Schema, das ich normalerweise verwende, um den Summer anzuschlie√üen, ist: <br><img src="https://habrastorage.org/files/8c8/a1e/7c6/8c8a1e7c67cf433989b5b94b89fa3e55.png"><br><br>  <b>Und so haben wir das Ger√§t zusammengebaut.</b> <br><br><h3>  Register </h3><br>  Im vorherigen Absatz haben wir uns f√ºr die Wahl des Beins entschieden - dies ist PB3 (OC2A), wir werden damit arbeiten.  Wenn Sie PD3 ben√∂tigen, ist f√ºr sie alles gleich, was aus der Geschichte deutlich hervorgeht. <br><br>  Wir werden unseren Timer 2 konfigurieren, indem wir 3 Register √§ndern: <br><ol><li>  TCCR2A - Moduseinstellungen und Verhaltensauswahl </li><li>  TCCR2B - Moduseinstellungen und Timer-Frequenzteiler (auch FOC-Bits - wir verwenden sie nicht) </li><li>  OCR2A (OCR2B f√ºr den PD3-Beinfall) - Wert des Vergleichsmoduls </li></ol><br><br>  Betrachten Sie zuerst die Register TCCR2A und TCCR2B <br><img src="https://habrastorage.org/files/37b/def/522/37bdef52208b48b381b06405d9eddcb5.png"><br>  Wie Sie sehen k√∂nnen, haben wir 3 Gruppen von Bits, die f√ºr uns von Bedeutung sind - dies sind Bits der Serien COM2xx, WGM2x und CS2x <br>  Das erste, was wir √§ndern m√ºssen, ist WGM2x - dies ist die Hauptsache f√ºr die Auswahl des Generierungsmodus - diese Bits werden zur Auswahl unseres CTC-Modus verwendet. <br><br><img src="https://habrastorage.org/files/f34/28d/3e3/f3428d3e3ecc4e1aafcef3c82b061d23.png"><br>  <i>Hinweis: In LH sollte der Tippfehler in "Update von OCR0x at" offensichtlich OCR2x sein</i> <br><br>  Das hei√üt,  Der Code sieht folgenderma√üen aus: <br><pre><code class="cpp hljs">TCCR2A = _BV(WGM21) ;</code> </pre> <br>  Wie Sie sehen k√∂nnen, wird TCCR2B noch nicht verwendet.  WGM22 sollte Null sein, ist aber bereits Null. <br><br>  Der n√§chste Schritt ist die Konfiguration der COM2xx-Bits, genauer gesagt COM2Ax - weil  Wir arbeiten mit dem Bein PB3 (f√ºr PD3 werden COM2Bx auf die gleiche Weise verwendet).  Was mit unserem PB3-Bein passieren wird, h√§ngt von ihnen ab. <br><br>  Die COM2xx-Bits h√§ngen von dem Modus ab, den wir mit den WGM2x-Bits ausgew√§hlt haben, daher m√ºssen wir den entsprechenden Abschnitt in der linken Seite finden.  Weil  wir haben den CTC-Modus, d.h.  nicht PWM, dann suchen wir nach einer Platte "Compare Output Mode, non-PWM", hier ist es: <br><img src="https://habrastorage.org/files/771/054/3e2/7710543e25404353b1c1056cd3a58483.png"><br>  Hier m√ºssen Sie ‚ÄûToggle‚Äú ausw√§hlen, damit sich der Pegel am Bein in das Gegenteil √§ndert, wenn der Timer den eingestellten Wert erreicht.  St√§ndige Pegel√§nderung und implementiert die Erzeugung der Frequenz, die wir ben√∂tigen. <br><br>  Weil  Die COM2xx-Bits befinden sich ebenfalls im TCCR2A-Register - nur es √§ndert sich: <br><pre> <code class="cpp hljs">TCCR2A = _BV(COM2A0) | _BV(WGM21) ;</code> </pre><br>  Nat√ºrlich m√ºssen Sie auch den Frequenzteiler mit CS2x-Bits ausw√§hlen und nat√ºrlich den PB3-Fu√ü auf den Ausgang setzen ... aber wir werden es noch nicht tun, damit wir beim Einschalten des MK kein durchdringendes Kreischen bei einer unverst√§ndlichen Frequenz bekommen, sondern wenn wir alle anderen Einstellungen und Einstellungen vornehmen Zum Verlassen den Fu√ü einschalten - wird unten beschrieben. <br><br>  Lassen Sie uns also unsere Initialisierung vollst√§ndig betrachten: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; //set bit - using bitwise OR operator #define sbi(x,y) x |= _BV(y) //clear bit - using bitwise AND operator #define cbi(x,y) x &amp;= ~(_BV(y)) #define BUZ_PIN PB3 void timer2_buzzer_init() { // PB3 cbi(PORTB, BUZ_PIN); // PB3  ,    cbi(DDRB, BUZ_PIN); //  TCCR2A = _BV(COM2A0) | _BV(WGM21) ; //   (      ) OCR2A = 0; }</span></span></span></span></code> </pre><br>  Ich habe die Makros cbi und sbi (irgendwo im Netzwerk ausspioniert) verwendet, um einzelne Bits zu setzen, und habe es so belassen.  Diese Makros wurden nat√ºrlich in die Header-Datei eingef√ºgt, aber der √úbersichtlichkeit halber habe ich sie hier eingef√ºgt. <br><br><h3>  Berechnung der H√§ufigkeit und Dauer von Noten </h3><br>  Jetzt kommen wir zum Kern des Problems.  Vor einiger Zeit versuchten Bekannte von Musikern, eine bestimmte Menge an Informationen √ºber ein musikalisches Personal in das Gehirn meines Programmierers zu bringen, mein Gehirn kochte fast, aber ich brachte dennoch ein n√ºtzliches Korn aus diesen Gespr√§chen heraus. <br>  Ich warne Sie sofort - gro√üe Ungenauigkeiten sind m√∂glich. <br><ol><li>  Jede Ma√ünahme besteht aus 4 Vierteln </li><li>  Jede Melodie hat ein Tempo - d.h.  die Anzahl solcher Viertel pro Minute </li><li>  Jede Note kann als ganzer Takt sowie als Teil 1/2, 1/3, 1/4 usw. gespielt werden. </li><li>  Jede Note hat nat√ºrlich eine bestimmte Frequenz </li></ol><br>  Wir haben den h√§ufigsten Fall untersucht, tats√§chlich ist dort zumindest f√ºr mich alles komplizierter, so dass ich dieses Thema im Rahmen dieser Geschichte nicht diskutieren werde. <br><br>  Okay, wir werden mit dem arbeiten, was wir haben.  F√ºr uns ist es am wichtigsten, die Frequenz der Note (tats√§chlich den Wert des OCR2A-Registers) und ihre Dauer beispielsweise in Millisekunden zu ermitteln.  Dementsprechend m√ºssen einige Berechnungen durchgef√ºhrt werden. <br><br>  Weil  Wir befinden uns im Rahmen einer Programmiersprache. Melodien lassen sich am einfachsten in einem Array speichern.  Die logischste M√∂glichkeit, jedes Element des Arrays im Format festzulegen, ist Note + Dauer.  Es ist notwendig, die Gr√∂√üe des Elements in Bytes zu berechnen, da wir unter dem Mikrocontroller schreiben und es hier mit Ressourcen eng ist - das bedeutet, dass die Gr√∂√üe des Elements in Bytes angemessen sein muss. <br><br><h4>  Frequenz </h4><br>  Beginnen wir mit der Frequenz.  Weil  Wir haben 8-Bit-Timer 2, das OCR2A-Vergleichsregister ist ebenfalls 8-Bit.  Das hei√üt, unser Element des Melodie-Arrays besteht bereits aus mindestens 2 Bytes, da Sie die Dauer noch speichern m√ºssen.  Tats√§chlich sind 2 Bytes die Grenze f√ºr diese Art von Handwerk.  Wir bekommen immer noch keinen guten Sound, um es milde auszudr√ºcken, und mehr Bytes auszugeben ist unvern√ºnftig.  <b>Also haben wir bei 2 Bytes angehalten.</b> <br><br>  <b>Beim Z√§hlen der Frequenz tritt tats√§chlich ein weiteres gro√ües Problem auf.</b> <br>  Wenn Sie sich die Frequenzen der Noten ansehen, werden Sie feststellen, dass sie in Oktaven unterteilt sind. <br><img src="https://habrastorage.org/files/240/294/17a/24029417a547408aa6806c9ddf66d593.jpg"><br>  F√ºr die meisten einfachen Melodien reichen 3 Oktaven aus, aber ich habe mich entschlossen, 6 auszuweichen und zu implementieren: gro√ü, klein und die n√§chsten 4. <br><br>  Lassen Sie uns nun von der Musik abschweifen und zur√ºck in die Welt der Mikrocontroller-Programmierung eintauchen. <br>  Jeder Timer im AVR (und die √ºberwiegende Mehrheit der anderen MK) ist an die Frequenz des MK selbst gebunden.  Die Frequenz des Quarzes in meiner Schaltung betr√§gt 16 MHz.  Die gleiche Frequenz wird von der F_CPU "define" als gleich 16000000 in meinem Fall bestimmt. Im TCCR2B-Register k√∂nnen wir Frequenzteiler so ausw√§hlen, dass unser Timer 2 nicht mit einer rasenden Geschwindigkeit von 16000000 Mal pro Sekunde "tickt", sondern etwas langsamer.  Der Frequenzteiler wird wie oben erw√§hnt durch CS2x-Bits ausgew√§hlt. <br><br><img src="https://habrastorage.org/files/9bd/ca6/247/9bdca624740e4dd787574c6604291dc3.png"><br>  <i>Hinweis: Offensichtlich sollte in LH ein Tippfehler anstelle von "CA2x" CS2x sein</i> <br><br>  Es stellt sich die Frage, wie der Teiler konfiguriert werden soll. <br><br>  Dazu m√ºssen Sie wissen, wie die Werte f√ºr das OCR2A-Register berechnet werden.  Und die Berechnung ist ganz einfach: <br>  <b>OCR2A = F_CPU / (Quarzfrequenzteiler * 2) / Notenfrequenz</b> <br>  Nehmen Sie zum Beispiel die Notiz VOR der ersten Oktave und dem Divisor 256 (CS22 = 1, CS21 = 1, CS20 = 0): <br>  OCR2A = 16000000 / (256 * 2) / 261 = 119 <br><br>  Ich werde gleich erkl√§ren, woher die Multiplikation mit 2 stammt. Tatsache ist, dass wir den Umschaltmodus mit den COM2Ax-Registern ausgew√§hlt haben. Dies bedeutet, dass die √Ñnderung der Pegel am Fu√ü von niedrig nach hoch (oder umgekehrt) und zur√ºck in zwei Durchg√§ngen des Timers erfolgt: zuerst Der Timer erreicht den Wert von OCR2A und √§ndert den Fu√ü des Mikrocontrollers, z. B. von 1 auf 0, wird zur√ºckgesetzt und √§ndert erst in der zweiten Runde 0 zur√ºck auf 1. Daher m√ºssen 2 Runden des Timers f√ºr jede volle Welle jeweils den Divisor mit 2 multipliziert werden, andernfalls erhalten wir nur die H√§lfte der H√§ufigkeit unserer Notiz. <br><br>  Daher das oben erw√§hnte Ungl√ºck ... <br><br>  Wenn wir die Note VOR der gro√üen Oktave nehmen und den Divisor 256 verlassen: <br>  OCR2A = 16000000 / (256 * 2) / 65 = 480 !!! <br>  <b>480 - Diese Zahl ist eindeutig gr√∂√üer als 255 und passt physikalisch nicht in das 8-Bit-OCR2A-Register.</b> <br><br>  Was tun?  Nat√ºrlich den Teiler √§ndern, aber wenn wir den Teiler 1024 setzen, dann wird mit einer gro√üen Oktave alles in Ordnung sein.  Probleme beginnen mit den oberen Oktaven: <br>  LA 4. Oktave - OCR2A = 16000000 / (1024 * 2) / 3520 = 4 <br>  Eine scharfe vierte Oktave - OCR2A = 16000000 / (1024 * 2) / 3729 = 4 <br>  <b>Die OCR2A-Werte unterscheiden sich nicht mehr, was bedeutet, dass auch der Klang nicht mehr anders ist.</b> <br><br>  <b>Es gibt nur einen Ausweg: F√ºr die Frequenz der Noten m√ºssen Sie nicht nur die Werte des OCR2A-Registers speichern, sondern auch die Bits des Quarzfrequenzteilers.</b>  <b>Weil</b>  <b>F√ºr verschiedene Oktaven gibt es einen unterschiedlichen Wert des Quarzfrequenzteilers, den wir im TCCR2B-Register einstellen m√ºssen!</b> <br><br>  Jetzt passt alles zusammen - und ich erkl√§rte schlie√ülich, warum wir den Divisorwert in der Funktion timer2_buzzer_init () nicht sofort eingeben konnten. <br><br>  Leider ist der Frequenzteiler 3 weitere Bits.  Und sie m√ºssen im zweiten Byte des Elements des Melodie-Arrays aufgenommen werden. <br><br><div class="spoiler">  <b class="spoiler_title">Es lebe die Makros</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_MASK (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_1024 (_BV(CS20) | _BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_256 (_BV(CS21) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_128 (_BV(CS20) | _BV(CS22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_64 _BV(CS22) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIV_32 (_BV(CS20) | _BV(CS21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_1024( x ) ((F_CPU / (1024 * 2) / x) | (DIV_1024 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_256( x ) ((F_CPU / (256 * 2) / x) | (DIV_256 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_128( x ) ((F_CPU / (128 * 2) / x) | (DIV_128 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_64( x ) ((F_CPU / (64 * 2) / x) | (DIV_64 &lt;&lt; 8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE_32( x ) ((F_CPU / (32 * 2) / x) | (DIV_32 &lt;&lt; 8)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  #define DOB NOTE_1024( 65 ) #define DO_B NOTE_1024( 69 ) #define REB NOTE_1024 ( 73 ) #define RE_B NOTE_1024 ( 78 ) #define MIB NOTE_1024 ( 82 ) #define FAB NOTE_1024 ( 87 ) #define FA_B NOTE_1024 ( 93 ) #define SOLB NOTE_1024 ( 98 ) #define SOL_B NOTE_1024 ( 104 ) #define LAB NOTE_1024 ( 110 ) #define LA_B NOTE_1024 ( 116 ) #define SIB NOTE_1024 ( 123 ) //  #define DOS NOTE_256( 131 ) #define DO_S NOTE_256( 138 ) #define RES NOTE_256 ( 146 ) #define RE_S NOTE_256 ( 155 ) #define MIS NOTE_256 ( 164 ) #define FAS NOTE_256 ( 174 ) #define FA_S NOTE_256 ( 185 ) #define SOLS NOTE_256 ( 196 ) #define SOL_S NOTE_256 ( 207 ) #define LAS NOTE_256 ( 219 ) #define LA_S NOTE_256 ( 233 ) #define SIS NOTE_256 ( 246 ) //  #define DO1 NOTE_256( 261 ) #define DO_1 NOTE_256( 277 ) #define RE1 NOTE_256 ( 293 ) #define RE_1 NOTE_256 ( 310 ) #define MI1 NOTE_256 ( 329 ) #define FA1 NOTE_256 ( 348 ) #define FA_1 NOTE_256 ( 369 ) #define SOL1 NOTE_256 ( 391 ) #define SOL_1 NOTE_256 ( 414 ) #define LA1 NOTE_256 ( 439 ) #define LA_1 NOTE_256 ( 465 ) #define SI1 NOTE_256 ( 493 ) //  #define DO2 NOTE_128( 522 ) #define DO_2 NOTE_128( 553 ) #define RE2 NOTE_128 ( 586 ) #define RE_2 NOTE_128 ( 621 ) #define MI2 NOTE_128 ( 658 ) #define FA2 NOTE_128 ( 697 ) #define FA_2 NOTE_128 ( 738 ) #define SOL2 NOTE_128 ( 782 ) #define SOL_2 NOTE_128 ( 829 ) #define LA2 NOTE_128 ( 878 ) #define LA_2 NOTE_128 ( 930 ) #define SI2 NOTE_128 ( 985 ) //  #define DO3 NOTE_64( 1047 ) #define DO_3 NOTE_64( 1109 ) #define RE3 NOTE_64 ( 1175 ) #define RE_3 NOTE_64 ( 1245 ) #define MI3 NOTE_64 ( 1319 ) #define FA3 NOTE_64 ( 1397 ) #define FA_3 NOTE_64 ( 1480 ) #define SOL3 NOTE_64 ( 1568 ) #define SOL_3 NOTE_64 ( 1661 ) #define LA3 NOTE_64 ( 1760 ) #define LA_3 NOTE_64 ( 1865 ) #define SI3 NOTE_64 ( 1976 ) //  #define DO4 NOTE_32( 2093 ) #define DO_4 NOTE_32( 2217 ) #define RE4 NOTE_32 ( 2349 ) #define RE_4 NOTE_32 ( 2489 ) #define MI4 NOTE_32 ( 2637 ) #define FA4 NOTE_32 ( 2794 ) #define FA_4 NOTE_32 ( 2960 ) #define SOL4 NOTE_32 ( 3136 ) #define SOL_4 NOTE_32 ( 3322 ) #define LA4 NOTE_32 ( 3520 ) #define LA_4 NOTE_32 ( 3729 ) #define SI4 NOTE_32 ( 3951 )</span></span></span></span></code> </pre><br></div></div><br><br>  Und f√ºr die Dauer der Note haben wir nur noch 5 Bits, also berechnen wir die Dauer. <br><br><h4>  Dauer </h4><br>  Zuerst m√ºssen Sie den Tempowert in tempor√§re Einheiten √ºbersetzen (z. B. in Millisekunden) - ich habe es so gemacht: <br>  <b>Dauer eines musikalischen Taktes in ms = (60.000 ms * 4 Viertel) / Tempowert.</b> <br><br>  Wenn wir also √ºber Beat-Parts sprechen, muss dieser Wert geteilt werden, und zuerst dachte ich, dass die √ºbliche Linksverschiebung f√ºr die Teiler ausreichen w√ºrde.  Das hei√üt,  Der Code war folgender: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / _BV((note &gt;&gt; <span class="hljs-number"><span class="hljs-number">11</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>)); }</code> </pre> <br><br>  Das hei√üt,  Ich habe 3 Bits (von den restlichen 5) verwendet und Teile des musikalischen Beats von Grad 2 bis zu 1/128 bekommen.  Aber als ich einen Freund gab, der mich bat, einen Klingelton auf mein St√ºck Eisen zu schreiben, gab es Fragen, warum es kein 1/3 oder 1/6 gibt, und ich fing an zu √ºberlegen ... <br><br>  Am Ende habe ich ein kniffliges System entwickelt, um solche Dauern zu erhalten.  Ein Bit von den verbleibenden 2x - Ich habe das Vorzeichen der Multiplikation mit 3 f√ºr den nach der Verschiebung erhaltenen Taktteiler ausgegeben.  Und das letzte Bit gibt an, ob es notwendig ist, 1 zu subtrahieren. Dies ist schwer zu beschreiben, es ist einfacher, den Code zu sehen: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> calc_note_delay(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> precalced_tempo, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> note) { note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> divider = _BV(note &amp; <span class="hljs-number"><span class="hljs-number">0b00111</span></span>); note &gt;&gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; divider *= ((note &amp; <span class="hljs-number"><span class="hljs-number">0b01</span></span>) ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); divider -= (note &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider); }</code> </pre> <br>  Dann habe ich alle m√∂glichen (au√üer denen, die weniger als 1/128 sind) Noten ‚Äûdefiniert‚Äú. <br><div class="spoiler">  <b class="spoiler_title">Hier sind sie</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MINUS_1 0b10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_MUL_3 0b01000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N2 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N3 (2 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N4 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N5 (1 | DEL_MINUS_1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N6 (1 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N7 (3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N8 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N11 (2 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N12 (2 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N15 (4 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N16 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N23 (3 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N24 (3 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N31 (5 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N32 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N47 (4 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N48 (4 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N63 (6 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N64 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N95 (5 | DEL_MUL_3 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N96 (5 | DEL_MUL_3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N127 (7 | DEL_MINUS_1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEL_1N128 7</span></span></code> </pre><br></div></div><br><br><h4>  Alles zusammenf√ºgen </h4><br>  Insgesamt haben wir das folgende Format f√ºr das Element unseres Klingelton-Arrays. <br><br><ul><li>  1 Bit: Verz√∂gerungsteiler - 1 </li><li>  1 Bit: Verz√∂gerungsteiler * 3 </li><li>  3bit: Verz√∂gerungsteilerverschiebung </li><li>  3bit: CPU-Taktteiler </li><li>  8 Bit: OCR2A-Wert </li></ul><br>  Nur 16 Bit. <br><br>  Lieber Leser, wenn Sie m√∂chten, k√∂nnen Sie sich das Format selbst einfallen lassen, vielleicht wird etwas Gro√üartigeres als meins geboren. <br><br>  Wir haben vergessen, eine leere Notiz hinzuzuf√ºgen, d. H.  Stille.  Und schlie√ülich habe ich erkl√§rt, warum wir in der Funktion timer2_buzzer_init () ganz am Anfang das PB3-Bein speziell auf den Eingang und nicht auf den Ausgang gesetzt haben.  Wenn Sie das Register DDRB √§ndern, wird die Wiedergabe von "Stille" oder der gesamten Komposition ein- und ausgeschaltet.  Weil  Wir k√∂nnen keine Noten mit dem Wert 0 haben - es wird eine "leere" Note sein. <br><br>  Definieren Sie die fehlenden Makros und die Funktion zum Aktivieren der Klangerzeugung: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EMPTY_NOTE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOTE(delay, note) (uint16_t)((delay </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 11) | note) ........ ........ ........ void play_music_note(uint16_t note) { if (note) { TCCR2B = (note &gt;&gt; 8) &amp; DIV_MASK; OCR2A = note &amp; 0xff; sbi(DDRB, BUZ_PIN); } else cbi(DDRB, BUZ_PIN); }</span></span></span></span></code> </pre><br>  Jetzt zeige ich Ihnen, wie ein nach diesem Prinzip geschriebener Klingelton aussieht: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> king[] PROGMEM = { NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N2, SI3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, LA_3), NOTE(DEL_1N4, EMPTY_NOTE), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, FA3), NOTE(DEL_1N2, LA3), NOTE(DEL_1N4, MI3), NOTE(DEL_1N4, FA_3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, LA3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, MI4), NOTE(DEL_1N4, RE4), NOTE(DEL_1N4, SI3), NOTE(DEL_1N4, SOL3), NOTE(DEL_1N4, SI3), NOTE(DEL_1N2, RE4), NOTE(DEL_1N2, EMPTY_NOTE), };</code> </pre><br><br><h3>  Klingelton abspielen </h3><br>  Wir haben noch eine Aufgabe - die Melodie zu spielen.  Dazu m√ºssen wir das Klingelton-Array "durchlaufen", den entsprechenden Pausen standhalten und die Frequenzen der Noten umschalten.  Nat√ºrlich brauchen wir einen anderen Timer, der √ºbrigens f√ºr andere allgemeine Aufgaben verwendet werden kann, wie ich es normalerweise tue.  Dar√ºber hinaus k√∂nnen Sie entweder in der Unterbrechung dieses Timers oder in der Hauptschleife zwischen Array-Elementen wechseln und den Timer zur Berechnung der Zeit verwenden.  In diesem Beispiel habe ich die 2. Option verwendet. <br><br>  Wie Sie wissen, enth√§lt der Hauptteil eines Programms f√ºr MK eine Endlosschleife: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">//   } return 0; }</span></span></code> </pre><br>  Darin werden wir entlang unseres Arrays "rennen".  Wir ben√∂tigen jedoch eine √§hnliche Funktion wie GetTickCount von WinApi, die die Anzahl der Millisekunden unter Windows-Betriebssystemen zur√ºckgibt.  Aber nat√ºrlich gibt es in der Welt von MK keine solchen Funktionen "out of the box", also m√ºssen wir sie selbst schreiben. <br><br><h4>  Timer 1 </h4><br>  Zur Berechnung der Zeitintervalle (ich schreibe absichtlich keine Millisekunden, sp√§ter werden Sie verstehen, warum) habe ich Timer 1 in Verbindung mit dem bereits bekannten CTC-Modus verwendet.  Timer 1 ist ein 16-Bit-Timer, was bedeutet, dass der Wert des Vergleichsmoduls daf√ºr bereits durch 2 8-Bit-Register OCR1AH ‚Äã‚Äãund OCR1AL angezeigt wird - f√ºr die hohen bzw. niedrigen Bytes.  Ich m√∂chte die Arbeit mit Timer 1 nicht im Detail beschreiben, da dies nicht f√ºr das Hauptthema dieses Memos gilt.  Deshalb werde ich Ihnen nur in 2 Worten sagen. <br><br>  Wir brauchen eigentlich 3 Funktionen: <br><ul><li>  Timer-Initialisierung </li><li>  Timer-Interrupt-Handler </li><li>  Funktion, die die Anzahl der Zeitintervalle zur√ºckgibt. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code C-Datei</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/atomic.h&gt; #include "timer1_ticks.h" volatile unsigned long timer1_ticks; //  ISR (TIMER1_COMPA_vect) { timer1_ticks++; } void timer1_ticks_init() { //   // CTC ,     8 TCCR1B |= (1 &lt;&lt; WGM12) | (1 &lt;&lt; CS11); //     OCR1AH = (uint8_t)(CTC_MATCH_OVERFLOW &gt;&gt; 8); OCR1AL = (uint8_t) CTC_MATCH_OVERFLOW; //    TIMSK1 |= (1 &lt;&lt; OCIE1A); } unsigned long ticks() { unsigned long ticks_return; //  ,   ticks_return   //     ATOMIC_BLOCK(ATOMIC_FORCEON) { ticks_return = timer1_ticks; } return ticks_return; }</span></span></span></span></code> </pre><br></div></div><br><br>  Bevor ich die Header-Datei mit einer bestimmten Konstante CTC_MATCH_OVERFLOW zeige, m√ºssen wir in der Zeit zur√ºck zum <b>Abschnitt ‚ÄûDauer‚Äú gehen</b> und das f√ºr die Melodie wichtigste Makro bestimmen, das das Tempo der Melodie berechnet.  Ich habe lange gewartet, um es festzustellen, da es direkt mit dem Player verbunden ist und daher mit Timer 1. <br>  In erster N√§herung sah es so aus (siehe Berechnungen im Abschnitt "Dauer"): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * 4 / x)</span></span></code> </pre><br>  Den Wert, den wir am Ausgang erhalten, m√ºssen wir anschlie√üend das erste Argument in die Funktion <b>calc_note_delay einsetzen</b> .  Schauen Sie sich nun die Funktion calc_note_delay genauer an, n√§mlich die Zeile: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (precalced_tempo / divider);</code> </pre><br>  Wir sehen, dass der durch Berechnung des TEMPO-Makros erhaltene Wert durch einen bestimmten Divisor geteilt wird.  Denken Sie daran, dass der maximale Divisor, den wir definiert haben, <b>DEL_1N128 ist</b> , d. H.  Der Divisor wird 128 sein. <br><br>  Nehmen wir nun den gemeinsamen Tempo-Wert von 240 und f√ºhren einige einfache Berechnungen durch: <br>  <b>60000 * 4/240 = 1000</b> <br>  Oh Horror!  Wir haben nur 1000, da dieser Wert immer noch durch 128 geteilt wird, laufen wir Gefahr, bei hohen Raten auf 0 zu rutschen.  <b>Dies ist die zweite Ausgabe der Dauer.</b> <br><br>  Wie kann man es l√∂sen?  Um den Bereich der Tempowerte zu erweitern, m√ºssen wir nat√ºrlich die Anzahl erh√∂hen, die durch die Berechnung des TEMPO-Makros erhalten wird.  Dies kann nur auf eine Weise erfolgen - um Millisekunden zu vermeiden und die Zeit in bestimmten Zeitintervallen zu z√§hlen.  Jetzt verstehen Sie, warum ich es die ganze Zeit vermieden habe, ‚ÄûMillisekunden‚Äú in der Geschichte zu erw√§hnen.  Definieren wir ein anderes Makro: <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4</span></span></code> </pre> <br>  Sei es unser Teiler der Millisekunde - dividiere die Millisekunde zum Beispiel durch 4 (250 Œºs). <br>  Dann m√ºssen Sie das TEMPO-Makro √§ndern: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPO( x ) (60000 * MS_DIVIDER * 4 / x)</span></span></code> </pre> <br><br>  Jetzt werde ich mit gutem Gewissen die Header-Datei f√ºr die Arbeit mit Timer 1 geben: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMER1_TICKS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MS_DIVIDER 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CTC_MATCH_OVERFLOW ((F_CPU / 1000) / (8 * MS_DIVIDER)) void timer1_ticks_init(); unsigned long ticks(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// TIMER1_TICKS_H_INCLUDED</span></span></span></span></code> </pre> <br>  Jetzt k√∂nnen wir durch √Ñndern von MS_DIVIDER den Bereich f√ºr unsere Aufgaben anpassen - ich habe 4 in meinem Code - dies war genug f√ºr meine Aufgaben.  <b>Achtung: Wenn Sie noch Aufgaben haben, die an Timer 1 gebunden sind, vergessen Sie nicht, die Zeitsteuerungswerte f√ºr diese mit MS_DIVIDER zu multiplizieren / zu dividieren.</b> <br><br><h4>  Plattenspieler </h4><br>  Jetzt schreiben wir unseren Player.  Ich denke, aus dem Code und den Kommentaren wird alles klar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ timer1_ticks_init(); <span class="hljs-comment"><span class="hljs-comment">//   sei(); timer2_buzzer_init(); //    MS_DIVIDER long time_since = ticks(); //       MS_DIVIDER uint16_t note_delay = 0; //     uint16_t note_pos = 0; //  uint16_t length = sizeof(king) / sizeof(king[0]); //     uint16_t tempo = TEMPO(240); for(;;) { unsigned long time_current = ticks(); if (time_current - time_since &gt; note_delay) { //   uint16_t note = pgm_read_word(&amp;king[note_pos]); //   play_music_note(note); //    note_delay = calc_note_delay(tempo, note); //  if (++note_pos &gt;= length) note_pos = 0; time_since = time_current; } } return 0; }</span></span></code> </pre><br><br><h3>  Fazit </h3><br>  Ich hoffe, dass dieses Memo f√ºr einen angesehenen Leser und mich selbst n√ºtzlich sein wird, um nicht alle Nuancen des Musikspielens zu vergessen, falls ich die AVR-Mikrocontroller wieder in die Hand nehme. <br><br>  Nun, traditionell der Video- und Quellcode (ich habe ihn in der Code Blocks-Umgebung entwickelt, also keine Angst vor obskuren Dateien): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/j60UCr2q0Ak" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de402329/">https://habr.com/ru/post/de402329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de402319/index.html">Die Jagiellonian University entwickelt eine Traineranwendung mit den Funktionen von IBM Watson</a></li>
<li><a href="../de402321/index.html">Livall Review: Ein intelligenter Helm mit Controller, Mikrofon und nativer Anwendung</a></li>
<li><a href="../de402323/index.html">"Also work": Die Kunst, Musik zu h√∂ren</a></li>
<li><a href="../de402325/index.html">"D√ºnne Welt." Kapitel 7</a></li>
<li><a href="../de402327/index.html">WayRay gibt strategische Partnerschaft mit Banma Technologies mit Investitionsunterst√ºtzung durch die Alibaba Group bekannt</a></li>
<li><a href="../de402345/index.html">Daten zur Artenvielfalt</a></li>
<li><a href="../de402347/index.html">Eine Auswahl an Sportkopfh√∂rern bis zu 2500 Rubel</a></li>
<li><a href="../de402351/index.html">Weltweites Internet: Japan und Singapur</a></li>
<li><a href="../de402355/index.html">Quantenschach</a></li>
<li><a href="../de402357/index.html">Kann ich Adobe Premiere und Sony Vegas durch kostenlose Video-Editoren ersetzen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>