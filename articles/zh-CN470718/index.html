<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍣 ⛳️ 🕵🏼 人类语言中的“代数效应” 🍺 😄 🕺🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="译者评论：这是React贡献者Dan Abramov的一篇很棒的文章的翻译。 他的示例是为JS编写的，但是对于开发人员来说，无论使用哪种语言，它们都同样清楚。 这个想法是所有人共同的。 

 您听说过代数效应吗？ 


 我最初试图弄清他们是谁，以及为什么他们应该让我兴奋的尝试都没有成功。 我找到了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>人类语言中的“代数效应”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470718/"> 译者评论：这是React贡献者Dan Abramov的一篇很棒的文章的翻译。 他的示例是为JS编写的，但是对于开发人员来说，无论使用哪种语言，它们都同样清楚。 这个想法是所有人共同的。 <br><br><h3> 您听说过代数效应吗？ </h3><br><p> 我最初试图弄清他们是谁，以及为什么他们应该让我兴奋的尝试都没有成功。 我找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了几个</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> ，但它们使我更加困惑。  （由于某种原因，我在阅读学术文章时睡着了。） </p><br><p> 但是我的同事塞巴斯蒂安<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继续</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">称</a>他们为我们在React中所做的某些事情的心理模型。  （Sebastian在React团队中工作，并提出了很多想法，包括Hooks和Suspense。）在某个时候，它成为React团队的本地模因，我们的许多对话以以下内容结束： </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/xm/oi/xbxmoi1bn7whmzill63sq1yz1tw.jpeg"></div><br><p> 事实证明，代数效应是一个很酷的概念，它并不像我最初阅读这些PDF时所看到的那样可怕。 如果您仅使用React，则不需要了解它们，但如果您像我一样有兴趣，请继续阅读。 </p><a name="habracut"></a><br><p>  （免责声明：我不是编程语言领域的研究人员，可能在我的解释中搞砸了。因此，如果我错了，请告诉我！） </p><br><h3> 还处于生产初期 </h3><br><p>代数效应目前是编程语言研究领域的实验性概念。 这意味着与<code>if</code> ， <code>for</code>甚至<code>async/await</code>表达式不同，您很可能现在无法在生产环境中使用它们。 它们仅由专门为研究此思想而创建的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几种</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语言</a>支持。 它们在OCaml中的实施方面正在取得进展，该进展仍在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进行中</a> 。 换句话说，注意但不要用手触摸。 </p><br><h3> 为什么要打扰我？ </h3><br><p> 想象一下，您正在使用<code>goto</code>编写代码，并且有人在告诉您<code>if</code>和<code>for</code>构造的存在。 或者，也许您陷入了回调地狱，有人向您显示<code>async/await</code> 。 很酷，不是吗？ </p><br><p> 如果您是喜欢在编程流行几年之前学习编程创新的人，那么也许是时候对代数效应感兴趣了。 虽然没有必要。 这就是1999年谈论<code>async/await</code>的方式。 </p><br><h3> 那么，这些是什么样的效果？ </h3><br><p> 名称可能有点混乱，但是想法很简单。 如果您熟悉<code>try/catch</code>块，您将很快了解代数效应。 </p><br><p> 让我们回想一下<code>try/catch</code> 。 假设您有一个引发异常的函数。 在它和<code>catch</code>之间也许有几个嵌套的调用： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'  '</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">",   : "</span></span>, err); }</code> </pre> <br><p> 我们在<code>getName</code>内抛出了一个异常，但是它通过<code>makeFriends</code> “弹出”到最近的<code>catch</code> 。 这是<code>try/catch</code>的主要属性。  <strong>不需要中间代码即可处理错误。</strong> </p><br><p> 与C之类的语言中的错误代码不同，使用<code>try/catch</code>您不必手动在每个中间级别传递错误来处理顶级错误。 异常自动弹出。 </p><br><p> 这与代数效应有什么关系？ </p><br><p> 在上面的示例中，一旦看到错误，我们将无法继续执行程序。 当我们发现自己处于<code>catch</code> ，正常的程序执行将停止。 </p><br><p> 都结束了 为时已晚。 我们能做的最好的事情就是从失败中恢复过来，也许以某种方式重复我们所做的事情，但是我们不能神奇地“回到”我们曾经做过的事情。 借助代数效应，我们可以做到。 </p><br><p> 这是一个用假设的JavaScript方言编写的示例（我们将它称为ES2025为好玩），它使我们能够在丢失了<code>user.name</code>之后<em>继续</em>工作： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  （我向2025年以来在Internet上搜索“ ES2025”并加入本文的所有读者致歉。如果到那时，代数效应将成为JavaScript的一部分，我将很乐意更新本文！） </p><br><p> 除了使用<code>throw</code>我们使用假设关键字<code>perform</code> 。 同样，我们使用假设的<code>try/handle</code>代替<code>try/catch</code> 。 确切的<strong>语法在这里无关紧要</strong> -我只是想出了一些办法来说明这个想法。 </p><br><p> 那么这是怎么回事？ 让我们仔细看看。 </p><br><p> 我们不会抛出错误，而是<em>执行效果</em> 。 正如我们可以<em>抛出</em>任何对象一样，在这里我们可以传递一些值进行<em>处理</em> 。 在此示例中，我传递了一个字符串，但它可以是对象或任何其他数据类型： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }</code> </pre> <br><p> 当我们抛出异常时，引擎会在调用堆栈中查找最接近的<code>try/catch</code>处理程序。 类似地，当我们执行一个<em>effect时</em> ，引擎将在栈顶寻找最接近的<code>try/handle</code> effect处理程序： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br><p> 这种效果使我们可以决定未指定名称时如何处理情况。 这里的新<code>resume with</code> （与例外相比）是假设的<code>resume with</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p> 这是您无法使用<code>try/catch</code> 。 它使我们<strong>可以返回执行效果的地方，并将内容从处理程序中传回</strong> 。  ：-O </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// 1.     name = perform 'ask_name'; // 4. ...     (name   ' ') } return name; } // ... try { makeFriends(arya, gendry); } handle(effect) { // 2.    ( try/catch)  (effect === 'ask_name') { // 3. ,      (    try/catch!) resume with ' '; } }</span></span></code> </pre><br><p> 花费一些时间才能感到舒适，但是从概念上讲，这与<code>try/catch</code>并返回没有太大区别。 </p><br><p> 但是请注意，代数效应是一个比<code>try/catch</code>更强大的工具。 错误恢复只是许多可能的用例之一。 我从这个例子开始只是因为它对我来说是最容易理解的。 </p><br><br><h3> 功能没有颜色 </h3><br><p> 代数效应对异步代码具有有趣的含义。 </p><br><p> 在具有<code>async/await</code>语言中<code>async/await</code>函数通常<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">具有“颜色”</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语</a> ）。 例如，在JavaScript中，我们不能仅使<code>getName</code>异步而不用async感染<code>makeFriends</code>及其调用函数。 如果部分代码有时需要同步，有时需要异步，这可能是一个很大的痛苦。 </p><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ... async getName(user) { // ... } //       ... async function makeFriends(user1, user2) { user1.friendNames.add(await getName(user2)); user2.friendNames.add(await getName(user1)); } //   ... async getName(user) { // ... }</span></span></code> </pre><br><p>  JavaScript生成器以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类似的</a>方式工作：如果您使用生成器，则所有中间代码也应了解生成器。 </p><br><p> 好吧，这和它有什么关系？ </p><br><p> 一会儿，让我们忘记异步/等待，回到我们的示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p> 如果我们的效果处理程序无法同步返回“备用名称”怎么办？ 如果我们想从数据库中获取该怎么办？ </p><br><p> 事实证明，我们可以从效果处理程序异步调用<code>resume with</code>而无需对<code>getName</code>或<code>makeFriends</code>进行任何更改： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><p> 在此示例中，我们仅在一秒钟后调用<code>resume with</code> 。 您可以考虑<code>resume with</code>回调进行<code>resume with</code>回调只能调用一次。  （您也可以通过将其称为“一次性<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">限时延续</a> ”向朋友炫耀（“ <i>限界延续</i> ”一词尚未获得稳定的俄语翻译-大约翻译）。） </p><br><p> 现在，代数效应的机理应该更清晰一些。 当我们抛出错误时，JavaScript引擎通过破坏进程中的局部变量来旋转堆栈。 但是，当我们<em>执行该</em>效果时，我们的假设引擎会使用我们函数的其余部分创建一个回调（实际上是一个“连续框架”，大约为Transl。），然后<code>resume with</code>调用该函数。 </p><br><p> 再次提醒您：仅针对本文完全发明了特定的语法和特定的关键字。 关键不在于此，而在于力学。 </p><br><br><h3> 清洁注意事项 </h3><br><p> 值得注意的是，代数效应是功能编程研究的结果。 他们解决的某些问题仅是函数式编程所独有的。 例如，在不允许任意副作用的语言（例如Haskell）中，应使用诸如monad之类的概念在程序中拖动效果。 如果您曾经阅读过monad教程，那么您就会知道它可能很难理解。 代数效应有助于以更少的精力完成类似的任务。 </p><br><p> 这就是为什么大多数关于代数效应的讨论对我来说是完全不可理解的。  （我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不知道Haskell</a>和他的“朋友”。）但是，我认为，即使在JavaScript这样的不洁语言中，代数效应也可以成为将代码中“内容”与“方式”分开的非常强大的工具。 </p><br><p> 它们允许您编写描述您正在做<em>什么的</em>代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = perform OpenDirectory(dir); perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating files in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.files) { perform HandleFile(file); } perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating subdirectories in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.dir) { <span class="hljs-comment"><span class="hljs-comment">//           enumerateFiles(directory); } perform Log('Done'); }</span></span></code> </pre> <br><p> 然后，用描述“如何”执行的操作将其包装： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> files = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { myLoggingLibrary.log(effect.message); resume; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> OpenDirectory) { myFileSystemImpl.openDir(effect.dirName, (contents) =&gt; { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> contents; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HandleFile) { files.push(effect.fileName); resume; } } <span class="hljs-comment"><span class="hljs-comment">//  `files`    </span></span></code> </pre><br><p> 这意味着这些部分可以成为一个库： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyLoggingLibrary } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-log'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } withMyLoggingLibrary(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { withMyFileSystem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ourProgram(); }); });</code> </pre><br><p> 与异步/等待或生成器不同，代数效应不需要“中间”函数的复杂化。 我们对<code>enumerateFiles</code>调用可能在我们的程序中很深，但是只要有一个可以在上面某个地方执行的每种效果的效果处理程序，我们的代码就会继续起作用。 </p><br><p> 效果处理程序使我们能够将程序逻辑与效果的特定实现分开，而无需不必要的舞步和样板代码。 例如，我们可以完全重新定义测试中的行为，以便使用伪造的文件系统并制作日志快照，而不是在控制台上显示它们： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withFakeFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fake-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withLogSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logs = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { logs.push(effect.message); resume; } } <span class="hljs-comment"><span class="hljs-comment">// Snapshot  . expect(logs).toMatchSnapshot(); } test('my program', () =&gt; { const fakeFiles = [ /* ... */ ]; withFakeFileSystem(fakeFiles, () =&gt; { withLogSnapshot(() =&gt; { ourProgram(); }); }); });</span></span></code> </pre><br><p> 由于函数没有“颜色”（中间代码不必了解效果），并且可以组成效果处理程序（它们可以嵌套），因此可以使用它们创建非常有表现力的抽象。 </p><br><br><h3> 类型注 </h3><br><p> 由于代数效应来自静态类型的语言，因此有关它们的大多数争论都集中在如何用类型表示它们上。 这无疑是重要的，但也会使对该概念的理解复杂化。 这就是为什么本文根本不讨论类型的原因。 但是，我应该注意，通常函数可以执行效果的事实将以其类型的签名进行编码。 因此，当发生无法预料的效果或无法追踪效果来自何处时，您将受到保护。 </p><br><p> 在这里，您可以说技术代数效应会“赋予颜色”静态类型化语言中的函数，因为效果是类型签名的一部分。 真的是 但是，将中间函数的类型注释固定为包括新的效果本身并不是语义上的更改-与添加异步或将函数转换为生成器不同。 类型推断还可以帮助避免级联更改的需要。 一个重要的区别是，您可以通过插入空的存根或临时实现（例如，对异步效果的同步调用）来“抑制”效果，这在必要时可以防止其对外部代码的影响-或将其转变为另一种效果。 </p><br><br><h3> 我需要JavaScript中的代数效应吗？ </h3><br><p> 老实说，我不知道。 它们非常强大，可以说它们对于像JavaScript这样的语言来说太强大了。 </p><br><p> 我认为它们对于可变性很少且标准库完全支持效果的语言非常有用。 如果您首先执行<code>perform Timeout(1000), perform Fetch('http://google.com')</code>并<code>perform ReadFile('file.txt')</code> ，并且您的语言具有“模式匹配”和静态类型的效果，那么这可能是一个非常不错的编程环境。 </p><br><p> 也许这种语言甚至可以用JavaScript编译！ </p><br><br><h3> 这与React有什么关系？ </h3><br><p> 不是很大 您甚至可以说我在地球仪上拔了一只猫头鹰。 </p><br><p> 如果您观看了我关于时间片和暂停的讨论，那么第二部分将包括从缓存中读取数据的组件： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovieDetails</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ? const movie = movieCache.read(id); }</span></span></code> </pre><br><p>  （该报告使用的API稍有不同，但这不是重点。） </p><br><p> 该代码基于名为“ <code>Suspense</code> ”的数据样本的React函数，该函数目前正在积极开发中。 当然，这里有趣的是，数据可能还没有保存在movieCache中-在这种情况下，我们需要先做一些事情，因为我们无法继续执行。 从技术上讲，在这种情况下，对read（）的调用会抛出Promise（是的，抛出Promise-您必须吞下这个事实）。 这将暂停执行。  React截获了这个Promise，并记住在抛出的Promise完成后有必要重复渲染组件树。 </p><br><p> 尽管此技巧的创建是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">受</a>他们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启发</a> ，但它本身并不是代数效应。 这个技巧达到了相同的目的：调用堆栈下面的某些代码暂时不如调用堆栈中的更高代码（在这种情况下为React），而所有中间函数都不必知道它，也不必被异步或生成器“毒化”。 当然，我们不能“实际”恢复用JavaScript执行，但是从React的角度来看，在Promise许可后重新显示组件树几乎是相同的。 当您的编程模型假定幂等时，您可以作弊！ </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">钩子</a>是另一个可以使您想起代数效应的示例。 人们问的第一个问题是：useState在哪里调用“知道”它指的是哪个组件？ </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LikeButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  useState ,    ? const [isLiked, setIsLiked] = useState(false); }</span></span></code> </pre><br><p> 我已经在本文末尾解释了这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一点</a> ：在React对象中，有一个可变的状态“当前分派器”，它指示您当前正在使用的实现（例如，在<code>react-dom</code> ）。 同样，有一个当前的组件属性指向LikeButton内部数据结构。 这是useState找出要做什么的方式。 </p><br><p> 在习惯之前，人们经常认为它有一个明显的原因，看起来像是肮脏的骇客。 依靠一般的可变状态是错误的。  （注意：您认为在JavaScript引擎中如何实现try / catch？） </p><br><p> 但是，从概念上讲，您可以将useState（）视为执行State（）的结果，该状态在组件执行时由React处理。 这“解释了” React（组件调用的东西）可以为其提供状态的原因（它在调用堆栈中较高，因此它可以提供效果处理程序）。 实际上，显式<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">状态实现</a>是我遇到的关于代数效应的教科书中最常见的示例之一。 </p><br><p> 同样，这当然不是React实际的工作方式，因为我们在JavaScript中没有代数效应。 取而代之的是，有一个隐藏的字段供我们保存当前组件，还有一个字段通过useState实现指向当前的“调度程序”。 作为性能优化，甚至有单独的useState实现用于<a href="">安装和更新</a> 。 但是，如果您现在对这段代码感到非常困惑，那么可以考虑将它们视为普通的效果处理程序。 </p><br><p> 综上所述，我们可以说在JavaScript中， <code>throw</code>可以作为I / O效果的第一近似值（前提是该代码可以在以后安全地重新执行，并且只要不与CPU绑定即可），并且变量字段“在try /中恢复的“ dispatcher”最终可以用作同步效果处理程序的近似值。 </p><br><p> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用generators</a>获得质量更高的效果实现，但这意味着您必须放弃JavaScript函数的“透明”性质，并且必须使用generators进行所有操作。 这就是“嗯，那是...” </p><br><h3> 在哪里找到更多 </h3><br><p> 就个人而言，我很惊讶我获得了多少代数效应。 我总是尽力理解诸如monad之类的抽象概念，但是代数效应只是产生并“打开”了头部。 我希望本文能帮助他们“加入”您的行列。 </p><br><p> 我不知道它们是否会开始大量使用。 我认为，如果他们在2025年之前不扎根任何一种主要语言，我将感到失望。 提醒我检查五年！ </p><br><p> 我相信您可以对它们做更多的事情，但是要真正开始编写代码并使用它们，要感受到它们的力量确实很难。 如果这篇文章引起了您的好奇心，这里有一些其他资源，您可以在其中更详细地阅读： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/ocamllabs/ocaml-effects-tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.janestreet.com/tech-talks/effective-programming</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.youtube.com/watch?v=hrBq8R_kxI0</a> </li></ul><br><p> 许多人还指出，如果您省略了打字方面（就像我在本文中所做的那样），则可以在Common Lisp的条件系统中找到这种技术的较早使用。      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a>  ,   ,   call/cc          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470718/">https://habr.com/ru/post/zh-CN470718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470696/index.html">Kaldi为什么对语音识别有好处？ （更新12.25.2019）</a></li>
<li><a href="../zh-CN470700/index.html">桌面 金属的 无声的 你的</a></li>
<li><a href="../zh-CN470706/index.html">Python + Keras + LSTM：半小时内完成文本翻译</a></li>
<li><a href="../zh-CN470710/index.html">机器学习助您一臂之力。 第二部分</a></li>
<li><a href="../zh-CN470714/index.html">我如何参加数字突破决赛</a></li>
<li><a href="../zh-CN470720/index.html">如何使用Python on Ontology编写智能合约？ 第2部分：存储API</a></li>
<li><a href="../zh-CN470722/index.html">如何使用Python on Ontology编写智能合约？ 第3部分：运行时API</a></li>
<li><a href="../zh-CN470726/index.html">如何在日常工作中不致溺水，或我们在压力测试期间比较AWR转储的经验</a></li>
<li><a href="../zh-CN470728/index.html">Azure PowerShell：大部分无害</a></li>
<li><a href="../zh-CN470730/index.html">Azure PowerShell：“几乎无害”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>