<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßü üë©üèª‚Äçü§ù‚Äçüë®üèæ üßùüèø Collecteur d'ordures. Cours complet + transfert de BOTR üñ±Ô∏è ü§úüèø üë©üèº‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, vous trouverez deux sources d'informations √† la fois: 


1. Cours complet de ramassage des ordures en russe: CLRium # 6 ( atelier ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Collecteur d'ordures. Cours complet + transfert de BOTR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463293/"><p>  Dans cet article, vous trouverez deux sources d'informations √† la fois: </p><br><ol><li>  Cours complet de ramassage des ordures en russe: CLRium # 6 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">atelier actuel ici</a> ) </li><li>  Traduction d'un article de BOTR "Garbage Collector Device" par Maoni Stevens. </li></ol><br><p><img src="https://habrastorage.org/webt/q2/r5/db/q2r5dbgih_azfbdvqe1dxcxsgp8.jpeg"></p><a name="habracut"></a><br><h2 id="1-clrium-5-polnyy-kurs-po-garbage-collector">  1. CLRium # 5: Cours complet de ramassage des ordures </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/gx/ef/-t/gxef-ta_pk2ywxouxlgj8zjhhra.png"></a> </p><br><h2 id="2-ustroystvo-sborschika-musora-by-maoni-stephens-maoni0httpsgithubcommaoni0">  2. Dispositif de ramassage des ordures par Maoni Stephens ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@ maoni0</a> ) </h2><br><p>  Remarque: pour en savoir plus sur la collecte des ordures en g√©n√©ral, consultez <em>le manuel de collecte des ordures</em> ;  des informations sp√©cialis√©es sur le garbage collector dans le CLR sont fournies dans le livre <em>Pro .NET Memory Management</em> .  Des liens vers les deux ressources sont fournis √† la fin du document. </p><br><h3 id="arhitektura-komponentov">  Architecture des composants </h3><br><p>  La collecte des ordures est associ√©e √† deux composants: un distributeur et un collecteur.  L'allocateur est responsable d'allouer de la m√©moire et d'appeler le collecteur si n√©cessaire.  Le collecteur collecte les d√©chets ou la m√©moire des objets qui ne sont plus utilis√©s par le programme. </p><br><p>  Il existe d'autres fa√ßons d'appeler le collecteur, par exemple manuellement, √† l'aide de GC.Collect.  En outre, le thread de finalisation peut recevoir une notification asynchrone indiquant que la m√©moire est √©puis√©e (ce qui entra√Ænera le collecteur). </p><br><h3 id="ustroystvo-raspredelitelya">  Dispositif distributeur </h3><br><p>  Le distributeur est appel√© par les composants auxiliaires du runtime avec les informations suivantes: </p><br><ul><li>  la taille n√©cessaire de la parcelle attribu√©e; </li><li>  contexte d'allocation de m√©moire pour le thread d'ex√©cution; </li><li>  des drapeaux qui indiquent, par exemple, si l'objet est finalisable. </li></ul><br><p>  Le garbage collector ne fournit pas de m√©thodes de traitement sp√©ciales pour diff√©rents types d'objets.  Il re√ßoit des informations sur la taille de l'objet √† partir de l'ex√©cution. </p><br><p>  Selon la taille, le collecteur divise les objets en deux cat√©gories: petit (&lt;85 000 octets) et grand (&gt; = 85 000 octets).  En g√©n√©ral, l'assemblage de petits et grands objets peut se produire de la m√™me mani√®re.  Cependant, le collecteur les s√©pare par taille, car la compression de gros objets n√©cessite beaucoup de ressources. </p><br><p>  Le garbage collector alloue de la m√©moire √† l'allocateur en fonction des contextes d'allocation.  La taille du contexte d'allocation est d√©termin√©e par les blocs de m√©moire allou√©s. </p><br><ul><li><p>  <strong>Les contextes de s√©lection</strong> sont de petites zones d'un segment de segment de m√©moire sp√©cifique, chacune √©tant destin√©e √† un flux d'ex√©cution sp√©cifique.  Sur une machine avec un processeur (c'est-√†-dire 1 processeur logique), un seul contexte d'allocation de m√©moire est utilis√© pour les objets de g√©n√©ration 0. </p><br></li><li><p>  <strong>Bloc de m√©moire allou√©e</strong> - la quantit√© de m√©moire allou√©e par l'allocateur chaque fois qu'il a besoin de plus de m√©moire pour positionner un objet √† l'int√©rieur de la zone.  La taille de bloc est g√©n√©ralement de 8 Ko et la taille moyenne des objets g√©r√©s est de 35 octets.  Par cons√©quent, dans un bloc, vous pouvez placer de nombreux objets. </p><br></li></ul><br><p>  Les grands objets n'utilisent pas de contextes et de blocs.  Un grand objet peut √™tre plus grand que ces petits morceaux de m√©moire.  De plus, les avantages de l'utilisation de ces zones (d√©crites ci-dessous) ne sont visibles que lorsque vous travaillez avec de petits objets.  L'espace pour les grands objets est allou√© directement dans le segment de segment de m√©moire. </p><br><p>  Le distributeur est con√ßu pour que: </p><br><ul><li><p> <strong>appeler le garbage collector si n√©cessaire: l'</strong> allocateur appelle le collecteur lorsque la quantit√© de m√©moire allou√©e aux objets d√©passe la valeur de seuil (d√©finie par le collecteur), ou si l'allocateur ne peut plus allouer de m√©moire dans ce segment.  Les seuils et les segments contr√¥l√©s seront d√©crits en d√©tail plus loin. </p><br></li><li><p>  <strong>enregistrer l'emplacement des objets: les</strong> objets situ√©s ensemble dans un segment du tas sont stock√©s √† des adresses virtuelles proches les unes des autres. </p><br></li><li><p>  <strong>utiliser efficacement le cache: l'</strong> allocateur alloue de la m√©moire en <em>blocs</em> , et non pour chaque objet.  Il met √† z√©ro autant de m√©moire pour pr√©parer le cache du processeur, car certains objets y seront plac√©s directement.  Le bloc de m√©moire allou√© est g√©n√©ralement de 8 Ko. </p><br></li><li><p>  <strong>limiter efficacement la zone allou√©e au thread d'ex√©cution: la</strong> proximit√© des contextes et des blocs de m√©moire allou√©s au thread garantit qu'un seul thread √©crira des donn√©es dans l'espace allou√©.  Par cons√©quent, il n'est pas n√©cessaire de limiter l'allocation de m√©moire tant que l'espace dans le contexte d'allocation actuel n'est pas termin√©. </p><br></li><li><p>  <strong>assurer l'int√©grit√© de la m√©moire:</strong> le garbage collector remet toujours √† z√©ro la m√©moire pour les objets nouvellement allou√©s afin que leurs liens ne pointent pas vers des sections de m√©moire arbitraires. </p><br></li><li><p>  <strong>assurer la continuit√© du tas: l'</strong> allocateur cr√©e un objet libre √† partir de la m√©moire restante dans chaque bloc allou√©.  Par exemple, si 30 octets restent dans le bloc et 40 octets sont n√©cessaires pour h√©berger l'objet suivant, l'allocateur transformera ces 30 octets en un objet libre et demandera un nouveau bloc de m√©moire. </p><br></li></ul><br><h2>  API </h2><br><pre><code class="plaintext hljs">Object* GCHeap::Alloc(size_t size,  DWORD); Object* GCHeap::Alloc(alloc_context* acontext, size_t size,  DWORD);</code> </pre> <br><p>  √Ä l'aide de ces fonctions, vous pouvez allouer de la m√©moire pour des objets petits et grands.  Il existe une fonction pour allouer de l'espace directement sur le tas de gros objets (LOH): </p><br><pre> <code class="plaintext hljs"> Object* GCHeap::AllocLHeap(size_t size,  DWORD);</code> </pre> <br><h3 id="ustroystvo-sborschika">  Dispositif collecteur </h3><br><h4 id="zadachi-sborschika-musora">  T√¢ches de garbage collector </h4><br><p>  GC est con√ßu pour une gestion efficace de la m√©moire.  Les d√©veloppeurs qui √©crivent du code manag√© peuvent l'utiliser sans trop d'effort.  La bonne gouvernance signifie: </p><br><ul><li>  le ramasse-miettes doit se produire suffisamment souvent pour ne pas encombrer le tas g√©r√© d'un grand nombre (par rapport ou en quantit√© absolue) d'objets inutilis√©s (poubelles) pour lesquels de la m√©moire est allou√©e; </li><li>  le ramasse-miettes doit se produire aussi rarement que possible afin de ne pas perdre de temps processeur utile, m√™me si un ramassage plus fr√©quent permettra une utilisation moindre de la m√©moire; </li><li>  le ramasse-miettes devrait √™tre productif, car si, √† la suite de l'assemblage, seul un petit morceau de m√©moire √©tait lib√©r√©, l'assemblage et le temps processeur utilis√© √©taient en vain; </li><li>  la collecte des ordures doit √™tre rapide, car de nombreuses charges de travail n√©cessitent un court d√©lai; </li><li>  les d√©veloppeurs qui √©crivent du code manag√© n'ont pas besoin d'en savoir beaucoup sur la collecte des ordures pour parvenir √† une utilisation efficace de la m√©moire (par rapport √† leur charge de travail); </li><li>  Le garbage collector doit s'adapter √† la nature diff√©rente de l'utilisation de la m√©moire. </li></ul><br><h4 id="logicheskoe-opisanie-upravlyaemoy-kuchi">  Description logique du tas g√©r√© </h4><br><p>  Le garbage collector CLR collecte les objets qui sont logiquement s√©par√©s par g√©n√©ration.  Apr√®s avoir assembl√© des objets dans la g√©n√©ration <em>N</em> , les objets restants sont marqu√©s comme appartenant √† la g√©n√©ration <em>N + 1</em> .  Ce processus est appel√© la promotion des objets √† travers les g√©n√©rations.  Il existe des exceptions dans ce processus lorsqu'il est n√©cessaire de transf√©rer un objet vers une g√©n√©ration inf√©rieure ou de ne pas l'avancer du tout. </p><br><p>  Dans le cas de petits objets, le tas est divis√© en trois g√©n√©rations: gen0, gen1 et gen2.  Pour les gros objets, il n'y a qu'une seule g√©n√©ration - gen3.  Gen0 et gen1 sont appel√©es g√©n√©rations √©ph√©m√®res (les objets y vivent peu de temps). </p><br><p>  Pour un tas de petits objets, le nombre de g√©n√©ration signifie leur √¢ge.  Par exemple, gen0 est la plus jeune g√©n√©ration.  Cela ne signifie pas que tous les objets de gen0 sont plus jeunes que les objets de gen1 ou gen2.  Il existe des exceptions d√©crites ci-dessous.  Assembler une g√©n√©ration signifie assembler des objets dans cette g√©n√©ration, ainsi que dans toutes ses g√©n√©rations plus jeunes. </p><br><p>  Th√©oriquement, l'assemblage de grands et petits objets peut se produire de la m√™me mani√®re.  Cependant, comme la compression de gros objets n√©cessite beaucoup de ressources, leur assemblage se d√©roule de mani√®re diff√©rente.  Les objets volumineux sont contenus uniquement dans gen2 et ne sont collect√©s que lors du ramasse-miettes de cette g√©n√©ration pour des raisons de performances.  Gen2 et gen3 peuvent √™tre volumineux, et la construction d'un objet dans les g√©n√©rations √©ph√©m√®res (gen0 et gen1) ne devrait pas √™tre trop gourmande en ressources. </p><br><p>  Les objets sont plac√©s dans la plus jeune g√©n√©ration.  Pour les petits objets, c'est gen0 et pour les gros objets, gen3. </p><br><h4 id="fizicheskoe-opisanie-upravlyaemoy-kuchi">  Description physique du tas g√©r√© </h4><br><p>  Un tas g√©r√© se compose d'un ensemble de segments.  Un segment est un bloc de m√©moire continu que le syst√®me d'exploitation transmet au garbage collector.  Les segments de tas sont divis√©s en petites et grandes sections pour accueillir de petits et grands objets.  Les segments de chaque tas sont connect√©s ensemble.  Au moins un segment pour un petit objet et un pour un grand sont r√©serv√©s lors du chargement du CLR. </p><br><p>  Dans chaque tas de petits objets, il n'y a qu'un seul segment √©ph√©m√®re, o√π se trouvent les g√©n√©rations gen0 et gen1.  Ce segment peut contenir ou non des objets de g√©n√©ration gen2.  En plus des segments √©ph√©m√®res, un ou plusieurs segments suppl√©mentaires peuvent exister, qui seront des segments gen2, car ils contiennent des objets de g√©n√©ration 2. </p><br><p>  Une pile de gros objets se compose d'un ou plusieurs segments. </p><br><p>  Le segment de segment de m√©moire est rempli d'adresses inf√©rieures √† sup√©rieures.  Cela signifie que les objets situ√©s aux adresses inf√©rieures du segment sont plus anciens que ceux situ√©s aux personnes √¢g√©es.  Il existe √©galement des exceptions d√©crites ci-dessous. </p><br><p>  Les segments de segment sont allou√©s selon les besoins.  S'ils ne contiennent pas d'objets utilis√©s, les segments sont supprim√©s.  Cependant, le segment initial sur le tas existe toujours.  Un segment est allou√© √† la fois pour chaque segment.  Dans le cas de petits objets, cela se produit lors de la r√©cup√©ration de place, et pour les gros objets, lors de l'allocation de m√©moire pour eux.  Un tel sch√©ma augmente la productivit√©, car les gros objets ne sont assembl√©s que dans la g√©n√©ration 2 (ce qui n√©cessite beaucoup de ressources). </p><br><p>  Les segments de tas sont r√©unis dans des s√©lections.  Le dernier segment de la cha√Æne est toujours √©ph√©m√®re.  Les segments dans lesquels tous les objets sont collect√©s peuvent √™tre r√©utilis√©s, par exemple, comme √©ph√©m√®res.  La r√©utilisation des segments ne s'applique qu'aux tas de petits objets.  Pour accueillir de gros objets √† chaque fois, l'ensemble des gros objets est pris en compte.  Les petits objets ne sont plac√©s que dans des segments √©ph√©m√®res. </p><br><h4 id="porogovoe-znachenie-obyoma-vydelennoy-pamyati">  Valeur seuil de la m√©moire allou√©e </h4><br><p>  Il s'agit d'un concept logique li√© √† la taille de chaque g√©n√©ration.  S'il est d√©pass√©, la g√©n√©ration commence la r√©cup√©ration de place. </p><br><p>  La valeur de seuil pour une g√©n√©ration particuli√®re est d√©finie en fonction du nombre d'objets survivants dans cette g√©n√©ration.  Si ce montant est √©lev√©, la valeur seuil devient plus √©lev√©e.  Il est pr√©vu que le rapport des objets utilis√©s et inutilis√©s sera meilleur lors de la session de r√©cup√©ration de place de la prochaine g√©n√©ration. </p><br><h2>  S√©lection de g√©n√©ration pour la collecte des ordures </h2><br><p>  Lorsqu'il est activ√©, le collecteur doit d√©terminer dans quelle g√©n√©ration construire.  Outre la valeur seuil, d'autres facteurs influencent ce choix: </p><br><ul><li>  fragmentation d'une g√©n√©ration - si une g√©n√©ration est tr√®s fragment√©e, la collecte des ordures m√©nag√®res est susceptible d'√™tre productive; </li><li>  si la m√©moire de la machine est trop occup√©e, le collecteur peut effectuer un nettoyage plus approfondi, si un tel nettoyage est plus susceptible de lib√©rer de l'espace et d'√©viter un √©change de page inutile (m√©moire dans toute la machine); </li><li>  si un segment √©ph√©m√®re manque d'espace, le collecteur peut effectuer un nettoyage plus approfondi dans ce segment (collecter plus d'objets de g√©n√©ration 1) pour √©viter d'allouer un nouveau segment de segment. </li></ul><br><h3 id="process-sborki-musora">  Processus de collecte des ordures </h3><br><h4 id="etap-markirovki">  √âtape de marquage </h4><br><p>  Pendant cette phase, le CLR devrait trouver tous les objets vivants. </p><br><p>  L'avantage d'un collecteur prenant en charge les g√©n√©rations est sa capacit√© √† nettoyer les d√©chets uniquement dans une partie du tas, au lieu d'observer constamment tous les objets.  En collectant les ordures dans les g√©n√©rations √©ph√©m√®res, le collecteur doit obtenir des informations de l'environnement d'ex√©cution sur les objets de ces g√©n√©rations qui sont encore utilis√©s par le programme.  De plus, les objets des g√©n√©rations plus √¢g√©es peuvent utiliser des objets des g√©n√©rations plus jeunes en se r√©f√©rant √† eux. </p><br><p>  Pour marquer les anciens objets en r√©f√©ren√ßant de nouveaux, le garbage collector utilise des bits sp√©ciaux.  Les bits sont d√©finis par le m√©canisme du compilateur JIT pendant les op√©rations d'affectation.  Si l'objet appartient √† la g√©n√©ration √©ph√©m√®re, le compilateur JIT d√©finira l'octet contenant le bit indiquant la position initiale.  En collectant les ordures dans les g√©n√©rations √©ph√©m√®res, le collecteur peut utiliser ces bits pour l'ensemble du tas restant et afficher uniquement les objets auxquels ces bits correspondent. </p><br><h4 id="etap-planirovaniya">  √âtape de planification </h4><br><p>  √Ä ce stade, la compression est mod√©lis√©e pour d√©terminer son efficacit√©.  Si le r√©sultat est productif, le collecteur commence la compression r√©elle.  Sinon, il fait juste le m√©nage. </p><br><h4 id="etap-peremescheniya">  √âtape en mouvement </h4><br><p>  Si le collecteur effectue une compression, cela entra√Ænera le d√©placement des objets.  Dans ce cas, vous devez mettre √† jour les liens vers ces objets.  Pendant la phase de d√©placement, le collecteur doit trouver tous les liens pointant vers des objets dans les g√©n√©rations o√π le garbage collection a lieu.  En revanche, lors de l'√©tape de marquage, le collecteur ne marque que les objets vivants, il n'a donc pas besoin de prendre en compte les maillons faibles. </p><br><h4 id="etap-szhatiya">  √âtape de compression </h4><br><p>  Cette √©tape est assez simple, car le collectionneur a d√©j√† d√©termin√© de nouvelles adresses pour les objets en mouvement lors de la phase de planification.  Une fois compress√©s, les objets seront copi√©s vers ces adresses. </p><br><h4 id="etap-uborki">  √âtape de nettoyage </h4><br><p>  Au cours de cette phase, le collectionneur recherche l'espace inutilis√© entre les objets vivants.  Au lieu de cet espace, il cr√©e des objets libres.  Les objets non utilis√©s √† proximit√© deviennent un objet libre.  Tous les objets libres sont plac√©s dans la <em>liste des objets libres</em> . </p><br><h3 id="code-flow">  Flux de code </h3><br><p>  Termes: </p><br><ul><li>  <strong>WKS GC:</strong> garbage collection en mode station de travail </li><li>  <strong>SVR GC:</strong> garbage collection en mode serveur </li></ul><br><h4 id="funkcionalnoe-povedenie">  Comportement fonctionnel </h4><br><h5 id="wks-gc-bez-parallelnoy-sborki-musora">  GC WKS sans garbage collection parall√®le </h5><br><ol><li>  Le thread utilisateur a utilis√© toute la m√©moire qui lui est allou√©e et appelle le garbage collector. </li><li>  Le collecteur appelle <code>SuspendEE</code> pour suspendre tous les threads g√©r√©s. </li><li>  Le collectionneur choisit une g√©n√©ration pour le nettoyage. </li><li>  Le marquage des objets commence. </li><li>  Le collecteur passe √† l'√©tape de planification et d√©termine le besoin de compression. </li><li>  Si n√©cessaire, le collecteur d√©place les objets et effectue la compression.  Dans un autre cas, il fait juste le m√©nage. </li><li>  Le collecteur appelle <code>RestartEE</code> pour red√©marrer les threads g√©r√©s. </li><li>  Les threads utilisateur continuent de fonctionner. </li></ol><br><h5 id="wks-gc-s-parallelnoy-sborkoy-musora">  GC WKS avec garbage collection parall√®le </h5><br><p>  Cet algorithme d√©crit la r√©cup√©ration de place en arri√®re-plan. </p><br><ol><li>  Le thread utilisateur a utilis√© toute la m√©moire qui lui est allou√©e et appelle le garbage collector. </li><li>  Le collecteur appelle <code>SuspendEE</code> pour suspendre tous les threads g√©r√©s. </li><li>  Le collecteur d√©termine s'il faut ex√©cuter la r√©cup√©ration de place en arri√®re-plan. </li><li>  Si c'est le cas, le thread de r√©cup√©ration de place en arri√®re-plan est activ√©.  Ce thread appelle <code>RestartEE</code> pour reprendre les threads g√©r√©s. </li><li>  L'allocation de m√©moire pour les processus g√©r√©s se poursuit en m√™me temps que la r√©cup√©ration de place en arri√®re-plan. </li><li>  Un thread utilisateur peut utiliser toute la m√©moire qui lui est allou√©e et d√©marrer le garbage collection √©ph√©m√®re (√©galement appel√© garbage collection haute priorit√©).  Il fonctionne de la m√™me mani√®re qu'en mode station de travail sans r√©cup√©ration de place parall√®le. </li><li>  Le <code>SuspendEE</code> r√©cup√©ration de place en arri√®re-plan appelle √† nouveau <code>SuspendEE</code> pour terminer le marquage, puis appelle <code>RestartEE</code> pour d√©marrer un nettoyage parall√®le avec les threads utilisateur en cours d'ex√©cution. </li><li>  La collecte des ordures en arri√®re-plan est termin√©e. </li></ol><br><h5 id="svr-gc-bez-parallelnoy-sborki-musora">  SVR GC sans garbage collection parall√®le </h5><br><ol><li>  Le thread utilisateur a utilis√© toute la m√©moire qui lui est allou√©e et appelle le garbage collector. </li><li>  Les threads de r√©cup√©ration de place en mode serveur sont activ√©s et provoquent la <code>SuspendEE</code> de l'ex√©cution des threads g√©r√©s par SuspendEE. </li><li>  Les flux de r√©cup√©ration de place en mode serveur effectuent les m√™mes op√©rations qu'en mode station de travail sans r√©cup√©ration de place parall√®le. </li><li>  Les threads de r√©cup√©ration de place en mode serveur <code>RestartEE</code> pour d√©marrer les threads g√©r√©s. </li><li>  Les threads utilisateur continuent de fonctionner. </li></ol><br><h5 id="svr-gc-s-parallelnoy-sborkoy-musora">  GC SVR avec ramasse-miettes parall√®le </h5><br><p>  L'algorithme est le m√™me que dans le cas de la r√©cup√©ration de place parall√®le en mode poste de travail, seul l'assemblage non phonon est effectu√© dans les threads du serveur. </p><br><h2 id="fizicheskaya-arhitektura">  Architecture physique </h2><br><p>  Cette section vous aidera √† comprendre le flux de code. </p><br><p>  Lorsque le thread utilisateur manque de m√©moire, il peut obtenir de l'espace libre √† l'aide de la fonction <code>try_allocate_more_space</code> . </p><br><p>  La fonction <code>try_allocate_more_space</code> appelle <code>GarbageCollectGeneration</code> lorsque vous devez d√©marrer le garbage collector. </p><br><p>  Si le garbage collection en mode station de travail n'est pas parall√®le, <code>GarbageCollectGeneration</code> est ex√©cut√© dans le thread utilisateur appel√© par le garbage collector.  Le flux de code est le suivant: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); gc1(); } gc1() { mark_phase(); plan_phase(); } plan_phase() { //   ,   //    if (compact) { relocate_phase(); compact_phase(); } else make_free_lists(); }</code> </pre> <br><p>  Si la r√©cup√©ration de place parall√®le est effectu√©e en mode station de travail (par d√©faut), le flux de code pour la r√©cup√©ration de place en arri√®re-plan ressemble √† ceci: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); //     //      do_background_gc(); } do_background_gc() { init_background_gc(); start_c_gc (); //           . wait_to_proceed(); } bgc_thread_function() { while (1) { //    //  gc1(); } } gc1() { background_mark_phase(); background_sweep(); }</code> </pre> <br><h1>  Liens vers les ressources </h1><br><ul><li>  <a href="">Impl√©mentation du GC .NET CLR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Manuel de collecte des ordures: l'art de la gestion automatique de la m√©moire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Collecte des ordures (Wikipedia)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion de la m√©moire Pro .NET</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463293/">https://habr.com/ru/post/fr463293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463279/index.html">PHP Digest n ¬∞ 162 (du 1er au 12 ao√ªt 2019)</a></li>
<li><a href="../fr463281/index.html">Pourquoi il y a peu d'applications innovantes sur Google Play ou pourquoi parfois la programmation est magique</a></li>
<li><a href="../fr463285/index.html">ShIoTiny: n≈ìuds, liens et √©v√©nements ou caract√©ristiques des programmes de dessin</a></li>
<li><a href="../fr463289/index.html">Discrete Math for WMS: Clustering Stock Lots</a></li>
<li><a href="../fr463291/index.html">D√©s ou os</a></li>
<li><a href="../fr463295/index.html">C ++ et CMake - Brothers Forever, Partie II</a></li>
<li><a href="../fr463297/index.html">Fid√©lit√© √† votre go√ªt</a></li>
<li><a href="../fr463299/index.html">Trucs et astuces Kubernetes: comment augmenter la productivit√©</a></li>
<li><a href="../fr463301/index.html">Gonkey - Outil de test de microservices</a></li>
<li><a href="../fr463303/index.html">Facebook arr√™te enfin de cibler les annonces pour les num√©ros de t√©l√©phone que les gens saisissent pour 2FA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>