<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ£Ô∏è ‚ú°Ô∏è üôÜüèΩ Resolviendo un Crackme simple para Sega Mega Drive üëè ü¶ã üôçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos 





 A pesar de mi amplia experiencia en la reversi√≥n de juegos para Sega Mega Drive , nunca decid√≠ usarlo, y no se me aparecieron en I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolviendo un Crackme simple para Sega Mega Drive</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448500/"><p>  Hola a todos </p><br><p><img src="https://habrastorage.org/webt/nk/ln/db/nklndblpn-preue7wy68pyj3c98.gif"></p><br><p> A pesar de mi amplia experiencia en la reversi√≥n de juegos para <code>Sega Mega Drive</code> , nunca decid√≠ usarlo, y no se me aparecieron en Internet.  Pero, el otro d√≠a hab√≠a un crackie divertido que quer√≠a resolver.  Comparto contigo la decisi√≥n ... <a name="habracut"></a></p><br><h2 id="opisanie">  Descripci√≥n </h2><br><p>  La descripci√≥n de la tarea y el ron en s√≠ se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">descargar aqu√≠</a> . </p><br><p>  A pesar de que la lista de recursos dice Hydra, el est√°ndar de facto entre las herramientas para depurar y revertir juegos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Sega</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Smd Ida Tools</a> .  Tiene todo lo que necesitas para resolver esta crema: </p><br><ul><li>  Cargador de ron para Ida </li><li>  Depurador </li><li>  Ver y cambiar la memoria RAM / VDP </li><li>  Mostrar informaci√≥n casi completa sobre VDP </li></ul><br><p>  Colocamos la √∫ltima versi√≥n en los complementos de Ide y comenzamos a ver lo que tenemos. </p><br><h2 id="reshenie">  Soluci√≥n </h2><br><p>  El lanzamiento de cualquier juego de Shogi comienza con la ejecuci√≥n del vector <code>Reset</code> .  Se puede encontrar un puntero en el segundo DWORD desde el comienzo del ron. </p><br><p><img src="https://habrastorage.org/webt/fa/6z/9i/fa6z9iin5fkmohq7xh8v8drs9vy.png"></p><br><p><img src="https://habrastorage.org/webt/hx/p-/g1/hxp-g1qdzxt0dgiw52xmngr4two.png"></p><br><p>  Vemos un par de funciones no identificadas que comienzan en la direcci√≥n <code>0x27A</code> .  Veamos que hay ah√≠. </p><br><h3 id="sub_2ea">  sub_2EA () </h3><br><p><img src="https://habrastorage.org/webt/uq/jb/on/uqjbonknltijbascror2nutymey.png"></p><br><p>  Desde mi propia experiencia, dir√© que esto generalmente parece ser la funci√≥n de esperar a que se complete la interrupci√≥n de <code>VBLANK</code> .  Veamos d√≥nde m√°s hay llamadas a la variable <code>byte_FF0026</code> : </p><br><p><img src="https://habrastorage.org/webt/-l/vf/fk/-lvffkgtxhng4fqfudhrquvrple.png"></p><br><p>  Vemos que el bit cero se establece en la interrupci√≥n <code>VBLANK</code> .  Entonces llamamos a la variable <code>vblank_ready</code> , y la funci√≥n donde se verifica es <code>wait_for_vblank</code> . </p><br><h3 id="sub_60e">  sub_60E () </h3><br><p>  A continuaci√≥n, la funci√≥n <code>sub_60E</code> se llama por c√≥digo.  Veamos que hay ah√≠: </p><br><p><img src="https://habrastorage.org/webt/75/ly/-t/75ly-ttb7wf5tmesip19y13lsdm.png"></p><br><p>  Lo que el primer comando escribe en <code>VDP_CTRL</code> es el comando de control <code>VDP</code> .  Para saber qu√© est√° haciendo, nos paramos sobre este comando y presionamos la tecla <code>J</code> : </p><br><p><img src="https://habrastorage.org/webt/5i/k9/vx/5ik9vx8gfpxa3l1v6z30y8qvjbg.png"></p><br><p>  Vemos que la entrada en <code>CRAM</code> (el lugar donde se almacenan las paletas) se inicializa.  Esto significa que todo el c√≥digo de funci√≥n posterior simplemente establece alg√∫n tipo de paleta inicial.  En consecuencia, la funci√≥n se puede llamar <code>init_cram</code> . </p><br><h3 id="sub_71a">  sub_71A () </h3><br><p><img src="https://habrastorage.org/webt/bn/q4/8l/bnq48l58l4kkamx9q_14q2fpvke.png"></p><br><p>  Vemos que alg√∫n comando se transfiere nuevamente a <code>VDP_CTRL</code> , luego presione nuevamente <code>J</code> y descubrimos que este comando inicializa la grabaci√≥n en la memoria de video: </p><br><p><img src="https://habrastorage.org/webt/ta/no/y-/tanoy-xupd7d8e_tc3hcyvsveqw.png"></p><br><p>  Adem√°s, para entender lo que se transfiere all√≠ a la memoria de video, no tiene sentido.  Por lo tanto, simplemente llamamos a la funci√≥n <code>load_vdp_data</code> . </p><br><h3 id="sub_c60">  sub_C60 () </h3><br><p>  Casi lo mismo sucede aqu√≠ que en la funci√≥n anterior, por lo tanto, sin entrar en detalles, simplemente llamamos a la funci√≥n <code>load_vdp_data2</code> . </p><br><h3 id="sub_8da">  sub_8DA () </h3><br><p>  Ya hay m√°s c√≥digo.  Y adem√°s, se llama a otra funci√≥n en esta funci√≥n.  Miremos all√≠, en <code>sub_D08</code> . </p><br><h4 id="sub_d08">  sub_D08 () </h4><br><p><img src="https://habrastorage.org/webt/5a/y3/du/5ay3du514ne0gmrqxhns5em-z9g.png"></p><br><p>  Vemos que en el registro <code>D0</code> <code>VDP_CTRL</code> el comando para <code>VDP_CTRL</code> , en <code>D1</code> , el valor con el que se rellenar√° <code>VRAM</code> , y en <code>D2</code> y <code>D3</code> , el ancho y la altura del relleno (porque resulta dos ciclos: interno y externo).  Llame a la funci√≥n fill_vram_by_addr. </p><br><h3 id="sub_8da-1">  sub_8DA () </h3><br><p>  Volvemos a la funci√≥n anterior.  Una vez que el valor en el registro <code>D0</code> se transmite como un comando para <code>VDP_CTRL</code> , presione la tecla <code>J</code> en el valor.  Obtenemos: </p><br><p><img src="https://habrastorage.org/webt/hf/7s/rv/hf7srvlttesquvkffg504tnagpm.png"></p><br><p>  Nuevamente, desde la experiencia de revertir juegos a Sega, puedo decir que este comando inicializa la grabaci√≥n de mosaicos de mapeo.  Las direcciones que comienzan en <code>$Fxxx</code> , <code>$Exxx</code> , <code>$Dxxx</code> , <code>$Cxxx</code> en el 90% de los casos ser√°n direcciones de regiones con estas mismas asignaciones.  ¬øQu√© son las asignaciones? <br>  estos son los valores con los que puede especificar d√≥nde mostrar este o aquel mosaico en la pantalla (un mosaico es un cuadrado de <code>8x8</code> p√≠xeles). </p><br><p>  Entonces la funci√≥n se puede llamar como <code>init_tile_mappings</code> . </p><br><h3 id="sub_cdc">  sub_CDC () </h3><br><p><img src="https://habrastorage.org/webt/yj/qn/xd/yjqnxdamdbrodnxbxpwfnhwun6k.png"></p><br><p>  El primer comando inicializa el registro en la direcci√≥n <code>$F000</code> .  Una nota: entre las direcciones de la " <em>asignaci√≥n</em> ", todav√≠a hay una regi√≥n donde se almacena la tabla de sprites (estas son sus posiciones, mosaicos a los que apuntan, etc.) Averig√ºe qu√© regi√≥n es responsable de lo que se puede depurar.  Pero por ahora, no necesitamos esto, as√≠ que llamemos a la funci√≥n <code>init_other_mappings</code> . </p><br><p>  Adem√°s, vemos que en esta funci√≥n se inicializan dos variables: <code>word_FF000A</code> y <code>word_FF000C</code> .  Seg√∫n mi propia experiencia (s√≠, √©l decide), dir√© que si hay dos variables cercanas en el espacio de direcciones y est√°n asociadas con el mapeo, en la mayor√≠a de los casos ser√°n las coordenadas de alg√∫n objeto (por ejemplo, un sprite).  Por lo tanto, sugiero llamarlos <code>sprite_pos_x</code> y <code>sprite_pos_y</code> .  El error en <code>x</code> e <code>y</code> permisible ya que  Adem√°s, bajo depuraci√≥n ser√° f√°cil de arreglar. </p><br><h2 id="vblank">  VBLANK </h2><br><p>  Como el bucle va m√°s all√° en el c√≥digo, podemos suponer que hemos finalizado la inicializaci√≥n b√°sica.  Ahora puedes ver la interrupci√≥n de <code>VBLANK</code> . </p><br><p><img src="https://habrastorage.org/webt/of/vd/3a/ofvd3ajtvedulgj6neviw_ynidw.png"></p><br><p>  Vemos que dos variables se est√°n incrementando (lo cual es extra√±o, en la lista de enlaces a cada una de ellas est√° absolutamente vac√≠o).  Pero, dado que se actualizan una vez por fotograma, puede llamarlos <code>timer1</code> y <code>timer2</code> . </p><br><p>  A continuaci√≥n, se <code>sub_2FE</code> funci√≥n <code>sub_2FE</code> .  Veamos que hay ah√≠: </p><br><h3 id="sub_2fe">  sub_2FE () </h3><br><p><img src="https://habrastorage.org/webt/dl/i0/zn/dli0zn0zzns8ue4t9632kszcbca.png"></p><br><p>  Y all√≠: trabaje con el puerto <code>IO_CT1_DATA</code> (responsable del primer joystick).  La direcci√≥n del puerto se carga en el registro <code>A0</code> y se pasa a la funci√≥n <code>sub_310</code> .  Vamos alli: </p><br><h4 id="sub_310">  sub_310 () </h4><br><p><img src="https://habrastorage.org/webt/do/n9/jl/don9jltuiqzuw-xg1klhngrmcbg.png"></p><br><p>  Mi experiencia me ayuda de nuevo.  Si ve el c√≥digo que funciona con el joystick y dos variables en la memoria, una almacena las <code>pressed keys</code> y la segunda contiene las <code>held keys</code> , es decir.  solo presion√© y sostuve las teclas.  Entonces llamemos a estas variables : <code>pressed_keys</code> y <code>held_keys</code> .  Y luego la funci√≥n se puede llamar como <code>update_joypad_state</code> . </p><br><h3 id="sub_2fe-1">  sub_2FE () </h3><br><p>  Llame a la funci√≥n como <code>read_joypad</code> . </p><br><h2 id="cikl-obrabotchika">  Lazo del controlador </h2><br><p>  Ahora todo se ve mucho m√°s claro: </p><br><p><img src="https://habrastorage.org/webt/zy/tv/9k/zytv9kt67reri1ncyx2ic62vdoe.png"></p><br><p>  Entonces, este ciclo responde a las teclas presionadas y realiza las acciones correspondientes.  Veamos cada una de las funciones llamadas en el bucle. </p><br><h3 id="sub_4d4">  sub_4D4 () </h3><br><p><img src="https://habrastorage.org/webt/w4/8j/le/w48jlep4xhckziprf9-lxhpy36s.png"></p><br><p>  Hay mucho c√≥digo  Comencemos con la primera funci√≥n llamada: <code>sub_60C</code> . </p><br><h4 id="sub_60c">  sub_60C () </h4><br><p>  Ella no hace nada, puede parecerlo al principio.  Acabo de regresar de la funci√≥n actual es <code>rts</code> .  Pero porque  solo se producen saltos ( <code>bsr</code> ) en √©l, lo que significa que <code>rts</code> nos devolver√° al ciclo del controlador.  <code>retn_to_loop</code> esta funci√≥n como <code>retn_to_loop</code> . </p><br><h3 id="sub_4d4-1">  sub_4D4 () </h3><br><p>  A continuaci√≥n, vemos la llamada a la variable <code>word_FF000E</code> .  No se usa en ninguna parte excepto por la funci√≥n actual y, al principio, el prop√≥sito de la misma no estaba claro para m√≠.  Pero, si observa detenidamente, podemos suponer que esta variable es necesaria solo por un peque√±o retraso entre el procesamiento de las pulsaciones de teclas.  ( <em>Ya est√° mal implementado en este ron, pero creo que sin esta variable ser√≠a mucho peor</em> ). </p><br><p><img src="https://habrastorage.org/webt/uz/s9/vz/uzs9vzbt_i6qy-fudyxdmrac-am.png"></p><br><p>  A continuaci√≥n, tenemos una gran cantidad de c√≥digo que de alguna manera procesa las <code>sprite_pos_y</code> <code>sprite_pos_x</code> y <code>sprite_pos_y</code> , que solo pueden hablar de una cosa: esto es necesario para mostrar el sprite de selecci√≥n alrededor del car√°cter seleccionado en el alfabeto. </p><br><p>  As√≠ que ahora puede nombrar la funci√≥n de forma <code>update_selection</code> como <code>update_selection</code> .  Sigamos adelante. </p><br><p><img src="https://habrastorage.org/webt/xd/ng/lv/xdnglvnasqphjlqa02sf35kwsse.png"></p><br><p>  El c√≥digo verifica si los bits de algunas teclas presionadas est√°n configurados y llama a ciertas funciones.  Miremos a ellos. </p><br><h4 id="sub_d28">  sub_D28 () </h4><br><p><img src="https://habrastorage.org/webt/ct/os/xa/ctosxa-j_4h-pqzqh0sqrqzywek.png"></p><br><p>  Alg√∫n tipo de magia cham√°nica.  Primero, la <code>WORD</code> se toma de la variable <code>word_FF0018</code> , luego se ejecuta una instrucci√≥n interesante: </p><br><pre> <code class="dos hljs">bsr.w *+<span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Este comando simplemente salta a las instrucciones que lo siguen. </p><br><p>  Lo siguiente es otra magia: </p><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">move</span></span>.l d0,(sp) rts</code> </pre> <br><p>  El valor en el registro <code>D0</code> se coloca en la parte superior de la pila.  Vale la pena se√±alar que, para Shogi, as√≠ como para algunos <code>x86</code> , la direcci√≥n de retorno de la funci√≥n cuando se llama se coloca en la parte superior de la pila.  En consecuencia, la primera instrucci√≥n coloca alguna direcci√≥n en la parte superior, y la segunda la levanta de la pila y hace una transici√≥n a lo largo de ella.  <u>Buen truco</u> </p><br><p>  Ahora necesita comprender cu√°l es este valor en la variable, que luego pasa.  Pero primero, llamemos a esta variable <code>jmp_addr</code> . </p><br><p>  Y las funciones se llamar√°n as√≠: </p><br><ul><li>  <code>sub_D38</code> : <code>goto_to_d0</code> </li><li>  <code>sub_D28</code> : <code>jump_to_var_addr</code> </li></ul><br><h3 id="jmp_addr">  jmp_addr </h3><br><p>  Averig√ºe d√≥nde se rellena esta variable.  Nos fijamos en la lista de referencias: </p><br><p><img src="https://habrastorage.org/webt/hn/uo/jl/hnuojlnhvgflvbd369lwlnhwlr0.png"></p><br><p>  Solo hay un lugar para escribir en esta variable.  Miremoslo. </p><br><h4 id="sub_3a4">  sub_3A4 () </h4><br><p><img src="https://habrastorage.org/webt/tw/bv/oe/twbvoexaffcrvzhk4vxrhrumtem.png"></p><br><p>  Aqu√≠, dependiendo de la coordenada del sprite (recuerde que esta es probablemente la direcci√≥n del car√°cter seleccionado), se ingresa este o aquel valor.  Vemos la siguiente secci√≥n de c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/sy/lz/pk/sylzpkcjv9ietp31t1j0itpol7g.png"></p><br><p>  El valor existente se desplaza a la derecha 4 bits, se coloca un nuevo valor en el byte bajo y el resultado se ingresa nuevamente en la variable.  En teor√≠a, nuestra variable <code>jmp_addr</code> almacena los caracteres que podemos ingresar en la pantalla de ingreso de teclas.  Tenga en cuenta tambi√©n que el tama√±o de la variable es <code>WORD</code> . </p><br><p>  De hecho, la funci√≥n <code>sub_3A4</code> puede llamarse <code>update_jmp_addr</code> . </p><br><h3 id="sub_414">  sub_414 () </h3><br><p>  Ahora solo nos queda una funci√≥n en el bucle, que no se reconoce.  Y se llama <code>sub_414</code> . </p><br><p><img src="https://habrastorage.org/webt/yz/ik/7r/yzik7r22zmhp2u-5hk0-0busyjy.png"></p><br><p>  Su c√≥digo se parece al c√≥digo de la funci√≥n <code>update_jmp_addr</code> , solo que al final tenemos una <code>sub_45E</code> funci√≥n <code>sub_45E</code> .  Miremos all√≠. </p><br><h4 id="sub_45e">  sub_45E () </h4><br><p><img src="https://habrastorage.org/webt/u4/-b/yl/u4-bylf_dl1ewl1ajhhtkqsqgn0.png"></p><br><p>  Vemos que el n√∫mero <code>#$4B1E2003</code> ingresa en el registro <code>D0</code> , que luego se env√≠a a <code>VDP_CTRL</code> , lo que significa que estamos tratando con otro comando de control <code>VDP</code> .  Presionamos <code>J</code> , recibimos un comando de registro en la regi√≥n con el mapeo <code>$Cxxx</code> . </p><br><p>  A continuaci√≥n, el c√≥digo funciona con la variable <code>byte_FF0014</code> , que no se usa en ninguna parte excepto la funci√≥n actual.  Si observa detenidamente c√≥mo se usa, notar√° que el n√∫mero m√°ximo que se puede instalar es <code>4</code> .  Supongo que esta es la longitud actual de la clave ingresada.  Vamos a verlo </p><br><h4 id="zapuskaem-otladchik">  Ejecute el depurador </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Usar√©</a> el depurador de <code>Smd Ida Tools</code> , pero, de hecho, algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Gens KMod</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Gens ReRecording</a> ser√°n suficientes.  Lo principal es que hay una funci√≥n con la visualizaci√≥n de direcciones en la memoria. </p><br><p><img src="https://habrastorage.org/webt/bx/p2/j9/bxp2j9ejyp85pohlubxrdda4c5a.png"></p><br><p>  Mi teor√≠a ha sido confirmada.  Entonces la variable <code>byte_FF0014</code> ahora se puede <code>key_length</code> . </p><br><p>  Hay otra variable: <code>dword_FF0010</code> , que tambi√©n se usa solo en la funci√≥n actual, y su contenido, despu√©s de agregarlo al comando inicial en <code>D0</code> (recuerdo que este era el n√∫mero <code>#$4B1E2003</code> ), se env√≠a a <code>VDP_CTRL</code> .  Sin pensarlo <code>add_to_vdp_cmd</code> , llam√© a la variable <code>add_to_vdp_cmd</code> . </p><br><p>  Entonces, ¬øqu√© hace esta funci√≥n?  Tengo la suposici√≥n de que ella dibuja el personaje introducido.  Comprobar esto es simple: iniciando el depurador y comparando el estado antes de llamar a la funci√≥n <code>sub_45E</code> y despu√©s: </p><br><p>  Para: </p><br><p><img src="https://habrastorage.org/webt/av/dl/et/avdletevo4p-evvc7gy6_e87djm.png"></p><br><p>  Despu√©s: </p><br><p><img src="https://habrastorage.org/webt/hf/ot/pi/hfotpiwid000obmkv6fnni67eqy.png"></p><br><p>  Ten√≠a raz√≥n: esta funci√≥n dibuja el car√°cter introducido.  Lo llamamos <code>do_draw_input_char</code> , y la funci√≥n que lo llama ( <code>sub_414</code> ) es <code>draw_input_char</code> . </p><br><h2 id="chto-teper">  Que ahora </h2><br><p>  Veamos por ahora que la variable que llamamos <code>jmp_addr</code> realmente almacena la clave ingresada.  Utilizaremos el mismo <code>Memory Watch</code> : </p><br><p><img src="https://habrastorage.org/webt/zy/vv/iq/zyvviqmu_r_ewas7ks1jhdj8w3o.png"></p><br><p>  Como puede ver, la conjetura era cierta.  ¬øQu√© nos da esto?  Podemos saltar a cualquier direcci√≥n.  Pero cual?  En la lista de funciones, todas se ordenan despu√©s de todo: </p><br><p><img src="https://habrastorage.org/webt/fd/wb/_7/fdwb_7otp3ztohkcacuoooyv5xw.png"></p><br><p>  Luego comenc√© a desplazarme por el c√≥digo hasta que encontr√© esto: </p><br><p><img src="https://habrastorage.org/webt/wo/r5/4n/wor54nhofpzrmlsz4dils09j62s.png"></p><br><p>  El ojo entrenado vio la secuencia de <code>$4E, $75</code> al final de los bytes no asignados.  Este es el c√≥digo de operaci√≥n de la instrucci√≥n <code>rts</code> , es decir  volver de la funci√≥n.  Entonces estos bytes no asignados pueden ser el c√≥digo de alguna funci√≥n.  Intentemos designarlos como un c√≥digo, presione <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/bd/vz/2i/bdvz2imlo3ifuxfkdizq0sxstxu.png"></p><br><p>  Obviamente, este es un c√≥digo de funci√≥n.  Tambi√©n puede presionar <code>P</code> para que el c√≥digo sea una funci√≥n.  Recuerda este nombre: <code>sub_D3C</code> . </p><br><p>  Entonces surge el pensamiento: ¬øqu√© <code>sub_D3C</code> si saltas en <code>sub_D3C</code> ?  Suena bien, aunque un solo salto aqu√≠ obviamente no ser√° suficiente, porque  no hab√≠a m√°s enlaces a la variable <code>word_FF0020</code> . </p><br><p>  Entonces se me ocurri√≥ otra idea: ¬øqu√© pasar√≠a si busc√°ramos otro c√≥digo sin asignar?  Abra el cuadro de di√°logo <code>Binary search</code> (Alt + B), ingrese la secuencia <code>4E 75</code> en √©l, marque la casilla <code>Find all occurrences</code> : </p><br><p><img src="https://habrastorage.org/webt/qy/tv/t3/qytvt3-qvf6eu1dpdsqs-senvaw.png"></p><br><p>  Haga <code></code> en <code></code> para comenzar la b√∫squeda, obtenemos los siguientes resultados. </p><br><p><img src="https://habrastorage.org/webt/ne/xp/y4/nexpy4fvlcfvberh_eyjof2jvf8.png"></p><br><p>  Al menos dos lugares m√°s en el ron pueden contener un c√≥digo de funci√≥n, debe verificarlos.  Hacemos clic en la primera de las opciones, nos desplazamos un poco hacia arriba y nuevamente vemos una secuencia de bytes indefinidos.  ¬øDenotarlos como una funci√≥n?  Si!  Presione <code>P</code> donde comienzan los bytes: </p><br><p><img src="https://habrastorage.org/webt/h-/as/yb/h-asybpa2wcjjtm1ry1cnqrc8iq.png"></p><br><p>  Genial!  Ahora tenemos la funci√≥n <code>sub_34C</code> .  Intentamos repetir lo mismo con la √∫ltima de las opciones encontradas, y ... tenemos un fastidio.  Hay tantos bytes antes de <code>4E 75</code> que no est√° claro d√≥nde comienza la funci√≥n.  Y, obviamente, no todos estos bytes anteriores son c√≥digo, porque  muchos bytes duplicados </p><br><h3 id="opredelyaem-nachalo-funkcii">  Determinar el comienzo de la funci√≥n. </h3><br><p>  Ser√° m√°s f√°cil para nosotros encontrar el comienzo de la funci√≥n si encontramos d√≥nde terminan los datos.  Como hacerlo  En realidad no es nada complicado: </p><br><ol><li>  Giramos antes del comienzo de los datos (habr√° un enlace a ellos desde el c√≥digo) </li><li>  Seguimos el enlace y buscamos un ciclo en el que deber√≠a aparecer el tama√±o de estos datos </li><li>  Marcar la matriz </li></ol><br><p>  Entonces, realizamos el primer p√°rrafo ...: </p><br><p><img src="https://habrastorage.org/webt/qn/ks/hu/qnkshuhax6mtxdttfgdtgzxoxuw.png"></p><br><p>  ... e inmediatamente vemos que en un ciclo de nuestra matriz se copian 4 bytes de datos a la vez (porque <code>move.l</code> ) a <code>VDP_DATA</code> .  A continuaci√≥n vemos el n√∫mero <code>2047</code> .  Al principio, puede parecer que el tama√±o final de la matriz es <code>2047 * 4</code> , pero el bucle basado en <code>dbf</code> ejecuta una iteraci√≥n <code>+1</code> m√°s, porque  El √∫ltimo valor comparado no es <code>0</code> , sino <code>-1</code> . </p><br><p>  Total: el tama√±o de la matriz es <code>2048 * 4 = 8192</code> .  Denota bytes como una matriz.  Para hacer esto, haga clic en <code>*</code> y especifique el tama√±o: </p><br><p><img src="https://habrastorage.org/webt/yg/7n/cs/yg7ncsvz4ehn1vo3v_hbnnmhkj8.png"></p><br><p>  Giramos hasta el final de la matriz, y vemos all√≠ bytes, que son exactamente los bytes del c√≥digo: </p><br><p><img src="https://habrastorage.org/webt/fl/jg/we/fljgwe4yhiykcwtks1stu4p2zoa.png"></p><br><p><img src="https://habrastorage.org/webt/wv/lz/ok/wvlzokzal1zgivxim4rwzmzu9i8.png"></p><br><p>  Ahora tenemos la funci√≥n <code>sub_2D86</code> , ¬°y tenemos todo para resolver esta grieta!  Veamos qu√© hace la funci√≥n reci√©n creada. </p><br><h3 id="sub_2d86">  sub_2D86 () </h3><br><p>  Y simplemente coloca el valor <code>#$4147</code> en el registro <code>D1</code> y llama a la funci√≥n <code>sub_34C</code> .  M√≠rala a ella. </p><br><h4 id="sub_34c">  sub_34C () </h4><br><p><img src="https://habrastorage.org/webt/gh/t1/pq/ght1pqqu3aazeufyhrdc88d46my.png"></p><br><p>  Vemos que aqu√≠ se <code>word_FF0020</code> el valor de la variable <code>word_FF0020</code> .  Si observa los enlaces, veremos otro lugar donde se est√° llevando a cabo el registro en esta variable, y este ser√° exactamente el lugar donde quer√≠a saltar a trav√©s de la variable <code>jmp_addr</code> .  Esto confirma el presentimiento de que definitivamente necesitas saltar a <code>sub_D3C</code> . </p><br><p>  Pero lo que sucedi√≥ despu√©s fue demasiado flojo para que lo entendiera, as√≠ que arroj√© el ron a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">GHIDRA</a> , encontr√© esta funci√≥n y mir√© el c√≥digo descompilado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ushort in_D1w; <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(in_D1w ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,in_D1w ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Vemos que <code>in_D1w</code> la variable con el nombre extra√±o <code>in_D1w</code> , y tambi√©n la variable <code>DAT_00ff0020</code> , que con su direcci√≥n se parece a la <code>word_FF0020</code> mencionada <code>word_FF0020</code> . </p><br><p>  <code>in_D1w</code> nos dice que este valor se toma del registro <code>D1</code> , o m√°s bien de su mitad WORD m√°s joven, y establece el registro <code>D1</code> funci√≥n que lo pasa.  ¬øRecuerdas <code>#$4147</code> ?  Por lo tanto, debe designar este registro como argumento de entrada para la funci√≥n. </p><br><p>  Para hacer esto, en la ventana con el c√≥digo descompilado, haga clic con el bot√≥n derecho en el nombre de la funci√≥n y seleccione el elemento de men√∫ <code>Edit Function Signature</code> : </p><br><p><img src="https://habrastorage.org/webt/qg/ee/nn/qgeenn-klxvb-utqj3fphg6woi8.png"></p><br><p>  Para indicar que la funci√≥n lleva un argumento a trav√©s de un registro espec√≠fico, es decir, no mediante el m√©todo est√°ndar para la convenci√≥n de llamada actual, debe marcar la <code>Use Custom Storage</code> y hacer clic en el icono con un <u>signo m√°s</u> : </p><br><p><img src="https://habrastorage.org/webt/zj/b0/kv/zjb0kvz41lnxumb9dqr5zqutmje.png"></p><br><p>  Aparece una posici√≥n para el nuevo argumento de entrada.  Hacemos doble clic en √©l y obtenemos un cuadro de di√°logo que indica el tipo y el medio del argumento: </p><br><p><img src="https://habrastorage.org/webt/7r/sl/n-/7rsln-dem8qbsqt4zh5bi2xaukc.png"></p><br><p>  En el c√≥digo descompilado, vemos que <code>in_D1w</code> es del tipo <code>ushort</code> , lo que significa que lo especificaremos en el campo de tipo.  Luego haga clic en el bot√≥n <code>Add</code> : </p><br><p><img src="https://habrastorage.org/webt/5v/vn/2h/5vvn2hkjpomj4fwk4bjxj5bxj_q.png"></p><br><p>  Aparecer√° una posici√≥n para indicar el medio del argumento, debemos especificar el registro <code>D1w</code> en <code>Location</code> y hacer <code>OK</code> en <code>OK</code> : </p><br><p><img src="https://habrastorage.org/webt/cj/3a/za/cj3azab2pkoqgcasbeh1o7vw5tk.png"></p><br><p>  El c√≥digo descompilado tomar√° la forma: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FUN_0000034c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ushort param_1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> sVar1; ushort *puVar2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span>) == <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span>) &amp;&amp; ((ushort)(param_1 ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span>) == <span class="hljs-number"><span class="hljs-number">0x4e50</span></span>)) { write_volatile_4(<span class="hljs-number"><span class="hljs-number">0xc00004</span></span>,<span class="hljs-number"><span class="hljs-number">0x4c060003</span></span>); sVar1 = <span class="hljs-number"><span class="hljs-number">0x22</span></span>; puVar2 = &amp;DAT_00002d94; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { write_volatile_2(VDP_DATA,param_1 ^ DAT_00ff0020 ^ *puVar2); sVar1 = sVar1 + <span class="hljs-number"><span class="hljs-number">-1</span></span>; puVar2 = puVar2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sVar1 != <span class="hljs-number"><span class="hljs-number">-1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  <code>param_1</code> que nuestro valor <code>param_1</code> es constante, pasado por la funci√≥n de llamada y es igual a <code>#$4147</code> .  Entonces, ¬øcu√°l deber√≠a ser el valor de <code>DAT_00ff0020</code> ?  Consideramos: </p><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> = <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ DAT_00ff0020 ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> = <span class="hljs-number"><span class="hljs-number">0x4e50</span></span></code> </pre> <br><p>  Porque  <code>xor</code> : la operaci√≥n es reversible, todos los n√∫meros constantes pueden pelearse entre s√≠ y obtener el valor deseado de la variable <code>DAT_00ff0020</code> . </p><br><pre> <code class="cpp hljs">DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5e4e</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x5a5a</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span> DAT_00ff0020 = <span class="hljs-number"><span class="hljs-number">0x4147</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4a44</span></span> ^ <span class="hljs-number"><span class="hljs-number">0x4e50</span></span> = <span class="hljs-number"><span class="hljs-number">0x4553</span></span></code> </pre> <br><p>  Resulta que el valor de la variable debe ser <code>0x4553</code> .  Parece que ya vi un lugar donde se establece ese valor ... </p><br><p><img src="https://habrastorage.org/webt/p_/mq/go/p_mqgo48sih6pijb1ks6aiq1fpy.png"></p><br><h2 id="vyvody-i-reshenie">  Conclusiones y decisi√≥n. </h2><br><p>  Llegamos a los siguientes resultados: </p><br><ol><li>  Primero debe saltar a la direcci√≥n <code>0x0D3C</code> , para esto debe ingresar el c√≥digo <code>0D3C</code> </li><li>  Salte a la funci√≥n en <code>0x2D86</code> , que establece el valor de <code>D1</code> para registrar <code>#$4147</code> , para esto debe ingresar el c√≥digo <code>2D86</code> </li></ol><br><p>  Experimentalmente, descubrimos la tecla que debe presionarse para verificar la tecla ingresada: <code>B</code>  Intentamos: </p><br><p><img src="https://habrastorage.org/webt/x9/6o/tf/x96otfmozj0tgnjmc6_hs6glcpi.png"></p><br><p>  Gracias </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448500/">https://habr.com/ru/post/448500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448488/index.html">Miedo y asco DevSecOps</a></li>
<li><a href="../448490/index.html">C√≥mo comenzar la transformaci√≥n de DevOps</a></li>
<li><a href="../448492/index.html">¬øQu√© es DevOps?</a></li>
<li><a href="../448496/index.html">.NET Core en Linux, DevOps a caballo</a></li>
<li><a href="../448498/index.html">"Rusia 404": ¬øCu√°nto Internet libre queda para vivir?</a></li>
<li><a href="../448504/index.html">Recogieron para todos "Habrom" el libro de referencia "Por qui√©n fue emitido ..." para pasaportes. Descargar a la salud</a></li>
<li><a href="../448506/index.html">The Matrix tiene 20 a√±os: c√≥mo Wachowski hizo cyberpunk, lo que determin√≥ la agenda de toda una generaci√≥n</a></li>
<li><a href="../448510/index.html">Acer en 2019: ¬øy si eliminas todas las moscas de las computadoras port√°tiles para juegos?</a></li>
<li><a href="../448516/index.html">Evolucione o cree una base para robots en la plataforma ARDUINO, y manejamos sensores y video a una computadora a trav√©s de un tel√©fono inteligente</a></li>
<li><a href="../448518/index.html">¬øC√≥mo ver un agujero negro?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>