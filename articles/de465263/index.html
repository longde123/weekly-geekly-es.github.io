<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ üèÆ üí¨ Sperren in PostgreSQL: 3. Sperrt andere Objekte üíº ‚úåüèª üöµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits √ºber einige Sperren auf Objektebene gesprochen (insbesondere √ºber Sperren f√ºr Beziehungen) sowie √ºber Sperren auf Zeilenebene , ihre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sperren in PostgreSQL: 3. Sperrt andere Objekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/">  Wir haben bereits √ºber einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren auf Objektebene gesprochen</a> (insbesondere √ºber Sperren f√ºr Beziehungen) sowie √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sperren auf Zeilenebene</a> , ihre Beziehung zu Objektsperren und die Warteschlange, was nicht immer ehrlich ist. <br><br>  Heute haben wir ein Durcheinander.  Beginnen wir mit <strong>Deadlocks</strong> (eigentlich wollte ich das letzte Mal dar√ºber sprechen, aber dieser Artikel stellte sich als unangemessen lang heraus), dann werden wir die verbleibenden <strong>Objektsperren</strong> durchgehen und abschlie√üend √ºber <strong>Pr√§dikatsperren</strong> sprechen. <br><br><h1>  Deadlocks </h1><br>  Bei Verwendung von Sperren ist eine <em>Deadlock-</em> (oder <em>Deadlock-</em> ) Situation m√∂glich.  Es tritt auf, wenn eine Transaktion versucht, eine Ressource zu erfassen, die bereits von einer anderen Transaktion erfasst wurde, w√§hrend eine andere Transaktion versucht, eine Ressource zu erfassen, die von der ersten Transaktion erfasst wurde.  Dies ist in der linken Abbildung unten dargestellt: Durchgezogene Pfeile zeigen erfasste Ressourcen an, gestrichelte Pfeile zeigen Versuche an, eine bereits belegte Ressource zu erfassen. <br><br>  Es ist praktisch, einen Deadlock zu visualisieren, indem Sie ein Diagramm der Erwartungen erstellen.  Dazu entfernen wir bestimmte Ressourcen und belassen nur Transaktionen, wobei wir notieren, welche Transaktion wartet.  Wenn das Diagramm eine Kontur hat (von oben k√∂nnen Sie es durch die Pfeile erreichen), ist dies ein Deadlock. <br><br><img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br><a name="habracut"></a><br>  Nat√ºrlich ist ein Deadlock nicht nur f√ºr zwei Transaktionen m√∂glich, sondern auch f√ºr eine gr√∂√üere Anzahl. <br><br>  Wenn ein Deadlock auftritt, k√∂nnen die daran beteiligten Transaktionen nichts dagegen tun - sie warten auf unbestimmte Zeit.  Daher verfolgen alle DBMS und auch PostgreSQL automatisch Deadlocks. <br><br>  Das √úberpr√ºfen erfordert jedoch bestimmte Anstrengungen, die ich nicht unternehmen m√∂chte, wenn eine neue Sperre angefordert wird (schlie√ülich sind Deadlocks ziemlich selten).  Wenn der Prozess versucht, die Sperre zu erfassen, und dies nicht kann, tritt er in die Warteschlange ein und schl√§ft ein, startet den Timer jedoch auf den im Parameter <em>deadlock_timeout</em> angegebenen Wert (standardm√§√üig 1 Sekunde).  Wenn die Ressource fr√ºher freigegeben wurde, haben wir bei der √úberpr√ºfung gespart.  Wenn <em>das</em> Warten nach <em>deadlock_timeout</em> fortgesetzt wird, wird der Wartevorgang aktiviert und eine √úberpr√ºfung eingeleitet. <br><br>  Wenn die Pr√ºfung (die darin besteht, ein Diagramm der Erwartungen zu erstellen und darin nach Konturen zu suchen) keine Deadlocks ergab, schl√§ft der Prozess weiter - jetzt bereits bis zum bitteren Ende. <br><br><blockquote>  Zu Beginn der Kommentare wurde mir zu Recht vorgeworfen, nichts √ºber den Parameter <em>lock_timeout gesagt zu haben</em> , der auf einen Operator einwirkt und eine unbegrenzt lange Wartezeit vermeidet: Wenn die Sperre nicht in der angegebenen Zeit abgerufen werden konnte, endet die Anweisung mit dem Fehler lock_not_available.  Es sollte nicht mit dem Parameter <em>statement_timeout</em> verwechselt werden, der die Gesamtausf√ºhrungszeit der Anweisung begrenzt, unabh√§ngig davon, ob sie eine Sperre erwartet oder nur den Job ausf√ºhrt. <br></blockquote><br>  Wenn ein Deadlock erkannt wird, wird eine der Transaktionen (in den meisten F√§llen die, die die Pr√ºfung initiiert hat) zwangsweise beendet.  In diesem Fall werden die von ihm erfassten Sperren freigegeben und die verbleibenden Transaktionen k√∂nnen weiterhin ausgef√ºhrt werden. <br><br>  Deadlocks bedeuten normalerweise, dass die Anwendung nicht richtig gestaltet ist.  Es gibt zwei M√∂glichkeiten, solche Situationen zu erkennen: Erstens werden Nachrichten im Serverprotokoll angezeigt, und zweitens erh√∂ht sich der Wert von pg_stat_database.deadlocks. <br><br><h2>  Deadlock-Beispiel </h2><br>  Eine h√§ufige Ursache f√ºr Deadlocks ist die unterschiedliche Reihenfolge, in der Zeilen in Tabellen gesperrt werden. <br>  Ein einfaches Beispiel.  Die erste Transaktion beabsichtigt, 100 Rubel vom ersten Konto auf das zweite Konto zu √ºbertragen.  Dazu reduziert sie zun√§chst die erste Z√§hlung: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Gleichzeitig beabsichtigt die zweite Transaktion, 10 Rubel vom zweiten Konto auf das erste Konto zu √ºbertragen.  Sie beginnt mit der Reduzierung der zweiten Anzahl: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br>  Jetzt versucht die erste Transaktion, das zweite Konto zu erh√∂hen, stellt jedoch fest, dass die Zeile gesperrt ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Dann versucht die zweite Transaktion, das erste Konto zu erh√∂hen, wird aber ebenfalls gesperrt. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Es gibt eine zyklische Erwartung, die niemals von alleine enden wird.  Nach einer Sekunde initiiert die erste Transaktion, die keinen Zugriff auf die Ressource hat, eine Deadlock-Pr√ºfung und bricht den Server ab. <br><br><pre> <code class="plaintext hljs">ERROR: deadlock detected DETAIL: Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513. Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477. HINT: See server log for query details. CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Jetzt kann die zweite Transaktion fortgesetzt werden. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Die richtige Methode zum Ausf√ºhren solcher Vorg√§nge besteht darin, Ressourcen in derselben Reihenfolge zu blockieren.  In diesem Fall k√∂nnen Sie beispielsweise Konten in aufsteigender Reihenfolge ihrer Nummern sperren. <br><br><h2>  Deadlock f√ºr zwei UPDATE-Befehle </h2><br>  Manchmal kann es zu einem Stillstand kommen, bei dem es anscheinend nicht so sein sollte.  Zum Beispiel ist es bequem und vertraut, SQL-Befehle als atomar zu betrachten, aber UPDATE zu verwenden - dieser Befehl blockiert Zeilen, wenn sie aktualisiert werden.  Dies geschieht nicht sofort.  Wenn ein Befehl die Zeilen in einer Reihenfolge und der andere in einer anderen Reihenfolge aktualisiert, sind sie m√∂glicherweise blockiert. <br><br>  Es ist unwahrscheinlich, dass es zu einer solchen Situation kommt, aber es kann sich trotzdem erf√ºllen.  F√ºr die Wiedergabe erstellen wir einen Index f√ºr die Betragsspalte, der in absteigender Reihenfolge des Betrags erstellt wird: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(amount <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre><br>  Um Zeit zu haben, um zu sehen, was passiert, schreiben wir eine Funktion, die den √ºbertragenen Wert f√ºr eine Sekunde langsam, langsam erh√∂ht: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> inc_slow(n <span class="hljs-type"><span class="hljs-type">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> pg_sleep(</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> n + </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100.00</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Wir brauchen auch die pgrowlocks-Erweiterung. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks;</code> </pre><br>  Der erste UPDATE-Befehl aktualisiert die gesamte Tabelle.  Der Ausf√ºhrungsplan ist offensichtlich - ein sequentieller Scan: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------- | Update on accounts | -&gt; Seq Scan on accounts | (2 rows)</code> </pre><br>  Da die Versionen der Zeilen auf der Seite unserer Tabelle in aufsteigender Reihenfolge der Summe sind (genau so, wie wir sie hinzugef√ºgt haben), werden sie in derselben Reihenfolge aktualisiert.  Wir starten das Update, um zu funktionieren. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><br>  In der Zwischenzeit werden wir in einer anderen Sitzung die Verwendung des sequentiellen Scannens verbieten: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  In diesem Fall entscheidet sich der Scheduler, den Index-Scan f√ºr die folgende UPDATE-Anweisung zu verwenden: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| QUERY PLAN || -------------------------------------------------------- || Update on accounts || -&gt; Index Scan using accounts_amount_idx on accounts || Index Cond: (amount &gt; 100.00) || (3 rows)</code> </pre><br>  Die zweite und dritte Zeile fallen unter die Bedingung, und da der Index in absteigender Reihenfolge erstellt wird, werden die Zeilen in umgekehrter Reihenfolge aktualisiert. <br><br>  Wir starten das n√§chste Update. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><br>  Ein kurzer Blick auf die tabellarische Seite zeigt, dass es dem ersten Operator bereits gelungen ist, die erste Zeile (0,1) und die zweite - die letzte (0,3) zu aktualisieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Eine weitere Sekunde vergeht.  Der erste Operator hat die zweite Zeile aktualisiert, und der zweite m√∂chte dies tun, kann dies jedoch nicht. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,2) locker | 530699 &lt;-    multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 3 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Jetzt m√∂chte die erste Anweisung die letzte Zeile der Tabelle aktualisieren, ist aber bereits von der zweiten gesperrt.  Hier ist die Sackgasse. <br><br>  Eine der Transaktionen wird abgebrochen: <br><br><pre> <code class="plaintext hljs">|| ERROR: deadlock detected || DETAIL: Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513. || Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549. || HINT: See server log for query details. || CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Und der andere vervollst√§ndigt die Ausf√ºhrung: <br><br><pre> <code class="plaintext hljs">| UPDATE 3</code> </pre><br><blockquote>  Interessante Details zum Erkennen und Verhindern von Deadlocks finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README Lock Manager</a> . <br></blockquote><br>  Hier dreht sich alles um Deadlocks, und wir fahren mit den verbleibenden Objektsperren fort. <br><br><img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br><br><h1>  Nicht-Beziehungssperren </h1><br>  Wenn Sie eine Ressource sperren m√∂chten, die f√ºr das Verst√§ndnis von PostgreSQL keine <em>Beziehung darstellt</em> , werden Objektsperren verwendet.  Eine solche Ressource kann fast alles sein: Tabellenbereiche, Abonnements, Schemata, Rollen, aufgez√§hlte Datentypen ... Grob gesagt alles, was im Systemkatalog enthalten ist. <br><br>  Schauen wir uns ein einfaches Beispiel an.  Wir starten die Transaktion und erstellen eine Tabelle darin: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> example(n <span class="hljs-type"><span class="hljs-type">integer</span></span>);</code> </pre><br>  Nun wollen wir sehen, welche Objektsperren in pg_locks angezeigt wurden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> datname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dbname, classid, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.classid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> classname, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> l.locktype = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> database | dbname | classid | classname | objid | mode | granted ----------+--------+---------+--------------+-------+-----------------+--------- 0 | | 1260 | pg_authid | 16384 | AccessShareLock | t 16386 | test | 2615 | pg_namespace | 2200 | AccessShareLock | t (2 rows)</code> </pre><br>  Um zu verstehen, was genau hier blockiert ist, m√ºssen Sie sich drei Felder ansehen: Datenbank, Klasse und Objekt.  Beginnen wir mit der ersten Zeile. <br><br>  Datenbank ist die OID der Datenbank, zu der die gesperrte Ressource geh√∂rt.  In unserem Fall gibt es in dieser Spalte Null.  Dies bedeutet, dass es sich um ein globales Objekt handelt, das keiner bestimmten Basis angeh√∂rt. <br><br>  Classid enth√§lt die OID von pg_class, die dem Namen der Systemkatalogtabelle entspricht, die den Ressourcentyp bestimmt.  In unserem Fall ist pg_authid, dh die Rolle ist die Ressource (Benutzer). <br><br>  Objid enth√§lt die OID aus der Systemkatalogtabelle, die uns die Klassen-ID angegeben hat. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rolname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_authid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">16384</span></span>;</code> </pre><pre> <code class="plaintext hljs"> rolname --------- student (1 row)</code> </pre><br>  Somit ist die Studentenrolle blockiert, von der aus wir arbeiten. <br><br>  Nun besch√§ftigen wir uns mit der zweiten Zeile.  Die Datenbank wird angezeigt, und dies ist die Testdatenbank, mit der wir verbunden sind. <br><br>  Classid zeigt auf die Tabelle pg_namespace, die die Schemas enth√§lt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_namespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">2200</span></span>;</code> </pre><pre> <code class="plaintext hljs"> nspname --------- public (1 row)</code> </pre><br>  Somit ist das √∂ffentliche Schema blockiert. <br><br>  Wir haben also gesehen, dass beim Erstellen eines Objekts die Eigent√ºmerrolle und das Schema, in dem das Objekt erstellt wird, blockiert sind (im freigegebenen Modus).  Was logisch ist: Andernfalls k√∂nnte jemand die Rolle oder das Schema entfernen, w√§hrend die Transaktion noch nicht abgeschlossen ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Beziehungserweiterungssperre </h1><br>  Wenn die Anzahl der Zeilen in einer Beziehung (dh in einer Tabelle, einem Index oder einer materialisierten Ansicht) zunimmt, kann PostgreSQL den freien Speicherplatz auf den vorhandenen Seiten zum Einf√ºgen verwenden, aber nat√ºrlich m√ºssen Sie irgendwann neue Seiten hinzuf√ºgen.  Physikalisch werden sie am Ende der entsprechenden Datei hinzugef√ºgt.  Dies wird als <em>Erweiterung der Beziehung verstanden</em> . <br><br>  Um zu verhindern, dass zwei Prozesse gleichzeitig Seiten hinzuf√ºgen, wird dieser Prozess durch eine spezielle Sperre vom Typ verl√§ngern gesch√ºtzt.  Dieselbe Sperre wird beim Bereinigen von Indizes verwendet, damit andere Prozesse beim Scannen keine Seiten hinzuf√ºgen k√∂nnen. <br><br>  Nat√ºrlich wird diese Sperre aufgehoben, ohne auf das Ende der Transaktion zu warten. <br><br><blockquote>  Bisher wurden Tabellen jeweils nur um eine Seite erweitert.  Dies verursachte Probleme, wenn mehrere Prozesse gleichzeitig Zeilen einf√ºgten. Daher wurden in PostgreSQL 9.6 mehrere Seiten gleichzeitig zu den Tabellen hinzugef√ºgt (proportional zur Anzahl der Prozesse, die auf das Sperren warten, jedoch nicht mehr als 512). <br></blockquote><br><h1>  Seitensperre </h1><br>  In nur einem Fall wird eine Sperre auf Seitenebene angewendet (mit Ausnahme der Pr√§dikatsperren, die sp√§ter erl√§utert werden). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit GIN-Indizes</a> k√∂nnen Sie die Suche in zusammengesetzten Werten beschleunigen, z. B. in W√∂rtern in Textdokumenten (oder in Elementen in Arrays).  In erster N√§herung k√∂nnen solche Indizes als regul√§rer B-Baum dargestellt werden, in dem nicht die Dokumente selbst gespeichert sind, sondern einzelne W√∂rter dieser Dokumente.  Daher muss beim Hinzuf√ºgen eines neuen Dokuments der Index ziemlich stark neu erstellt werden, wobei jedes im Dokument enthaltene Wort eingef√ºgt wird. <br><br>  Um die Leistung zu verbessern, verf√ºgen GIN-Indizes √ºber eine Funktion zum verz√∂gerten Einf√ºgen, die durch die Speicheroption fastupdate aktiviert wird.  Neue W√∂rter werden zuerst schnell zur ungeordneten ausstehenden Liste hinzugef√ºgt, und nach einiger Zeit wird alles, was sich angesammelt hat, in die Hauptindexstruktur verschoben.  Einsparungen sind auf die Tatsache zur√ºckzuf√ºhren, dass verschiedene Dokumente wahrscheinlich doppelte W√∂rter enthalten. <br><br>  Um zu verhindern, dass mehrere Prozesse gleichzeitig von der Warteliste in den Hauptindex verschoben werden, wird die Index-Metaseite f√ºr die Dauer der √úbertragung im exklusiven Modus blockiert.  Dies beeintr√§chtigt die Verwendung des Index im normalen Modus nicht. <br><br><h1>  Hinweisschl√∂sser </h1><br>  Im Gegensatz zu anderen Sperren (z. B. Beziehungssperren) werden Beratungssperren niemals automatisch festgelegt, sondern vom Anwendungsentwickler verwaltet.  Sie sind beispielsweise dann bequem zu verwenden, wenn eine Anwendung f√ºr einen bestimmten Zweck eine Blockierungslogik ben√∂tigt, die nicht in die Standardlogik gew√∂hnlicher Sperren passt. <br><br>  Angenommen, wir haben eine bedingte Ressource, die keinem Datenbankobjekt entspricht (das wir mit Befehlen wie SELECT FOR oder LOCK TABLE blockieren k√∂nnten).  Sie m√ºssen eine numerische Kennung daf√ºr erstellen.  Wenn die Ressource einen eindeutigen Namen hat, k√∂nnen Sie einfach einen Hash-Code daraus entnehmen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 243773337 (1 row)</code> </pre><br>  So erfassen wir das Schloss: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Wie √ºblich sind Sperrinformationen in pg_locks verf√ºgbar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Damit eine Sperre tats√§chlich funktioniert, m√ºssen auch andere Prozesse eine Sperre erhalten, bevor sie auf die Ressource zugreifen k√∂nnen.  Die Einhaltung dieser Regel sollte nat√ºrlich durch den Antrag sichergestellt werden. <br><br>  Im obigen Beispiel ist die Sperre bis zum Ende der Sitzung g√ºltig und nicht wie √ºblich bis zur Transaktion. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Es muss ausdr√ºcklich freigegeben werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_unlock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Es gibt eine Vielzahl von Funktionen f√ºr die Arbeit mit Hinweisschl√∂ssern f√ºr alle Gelegenheiten: <br><br><ul><li>  pg_advisory_lock_shared behandelt eine gemeinsam genutzte Sperre. </li><li>  pg_advisory_xact_lock (und pg_advisory_xact_lock_shared) erhalten eine Sperre bis zum Ende der Transaktion. </li><li>  pg_try_advisory_lock (sowie pg_try_advisory_xact_lock und pg_try_advisory_xact_lock_shared) erwartet keine Sperre, gibt jedoch einen falschen Wert zur√ºck, wenn die Sperre nicht sofort abgerufen werden konnte. </li></ul><br>  Die Try-Funktionen bieten zus√§tzlich zu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem vorherigen Artikel</a> aufgef√ºhrten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> weitere M√∂glichkeit, nicht auf eine Sperre zu warten. <br><br><h1>  Pr√§dikatsperren </h1><br>  Der Begriff <em>Pr√§dikatsperre</em> tauchte vor langer Zeit bei den ersten Versuchen auf, eine vollst√§ndige Isolation basierend auf Sperren in fr√ºhen DBMS zu implementieren (die Ebene ist serialisierbar, obwohl der SQL-Standard zu diesem Zeitpunkt noch nicht existierte).  Das Problem, das dann auftrat, war, dass selbst das Blockieren aller gelesenen und ge√§nderten Zeilen keine vollst√§ndige Isolation bietet: In der Tabelle werden m√∂glicherweise <em>neue</em> Zeilen angezeigt, die unter denselben Auswahlbedingungen liegen, was zu <em>Phantomen f√ºhrt</em> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel zur Isolierung</a> ). . <br><br>  Die Idee von Pr√§dikatsperren bestand darin, Pr√§dikate und keine Zeilen zu blockieren.  Wenn beim Ausf√ºhren einer Abfrage mit der Bedingung <em>a</em> &gt; 10 das Pr√§dikat <em>a</em> &gt; 10 blockiert wird, werden der Tabelle keine neuen Zeilen hinzugef√ºgt, die unter die Bedingung fallen, und Phantome werden vermieden.  Das Problem ist, dass dies im allgemeinen Fall eine rechenintensive Aufgabe ist;  In der Praxis kann es nur f√ºr Pr√§dikate gel√∂st werden, die eine sehr einfache Form haben. <br><br>  In PostgreSQL wird die serialisierbare Schicht zus√§tzlich zur vorhandenen Snapshot-basierten Isolation anders implementiert.  Der Begriff <em>Pr√§dikatsperre</em> bleibt erhalten, aber seine Bedeutung hat sich radikal ge√§ndert.  Tats√§chlich blockieren solche ‚ÄûSperren‚Äú nichts, sondern werden verwendet, um Datenabh√§ngigkeiten zwischen Transaktionen zu verfolgen. <br><br>  Es ist erwiesen, dass eine auf Bildern basierende Isolation eine <em>Anomalie inkonsistenter Aufzeichnung</em> und eine <em>Anomalie nur einer Lesetransaktion</em> zul√§sst, aber keine anderen Anomalien m√∂glich sind.  Um zu verstehen, dass es sich um eine der beiden aufgef√ºhrten Anomalien handelt, k√∂nnen wir die Abh√§ngigkeiten zwischen Transaktionen analysieren und bestimmte Muster darin finden. <br><br>  Wir interessieren uns f√ºr zwei Arten von Abh√§ngigkeiten: <br><br><ul><li>  Eine Transaktion liest eine Zeile, die dann von einer anderen Transaktion ge√§ndert wird (RW-Abh√§ngigkeit). </li><li>  Eine Transaktion √§ndert die Zeile, die eine andere Transaktion dann liest (WR-Abh√§ngigkeit). </li></ul><br>  WR-Abh√§ngigkeiten k√∂nnen mit vorhandenen herk√∂mmlichen Sperren verfolgt werden, RW-Abh√§ngigkeiten m√ºssen jedoch nur zus√§tzlich verfolgt werden. <br><br>  Ich wiederhole noch einmal: Trotz des Namens blockieren Pr√§dikatsperren nichts.  Wenn eine Transaktion festgeschrieben wird, wird stattdessen eine Pr√ºfung durchgef√ºhrt. Wenn eine ‚Äûschlechte‚Äú Folge von Abh√§ngigkeiten festgestellt wird, die auf eine Anomalie hinweisen kann, wird die Transaktion unterbrochen. <br><br>  Mal sehen, wie die Installation von Pr√§dikatsperren erfolgt.  Erstellen Sie dazu eine Tabelle mit einer ausreichend gro√üen Anzahl von Zeilen und einem Index. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pred(n <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> gn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> pred;</code> </pre><br>  Wenn die Abfrage durch sequentielles Scannen der gesamten Tabelle ausgef√ºhrt wird, wird die Pr√§dikatsperre f√ºr die gesamte Tabelle festgelegt (auch wenn nicht alle Zeilen unter die Filterbedingungen fallen). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 12763 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------------------------------------------- | Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1) | Filter: (n &gt; 100) | Rows Removed by Filter: 100 | Planning Time: 0.190 ms | Execution Time: 15.244 ms | (5 rows)</code> </pre><br>  Alle Pr√§dikatsperren werden immer in einem speziellen SIReadLock-Modus (Serializable Isolation Read) erfasst: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+----------+------+------- relation | pred | | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Wenn die Abfrage jedoch mithilfe der Indexpr√ºfung ausgef√ºhrt wird, √§ndert sich die Situation zum Besseren.  Wenn wir √ºber den B-Baum sprechen, reicht es aus, die Sperre f√ºr die Zeilen der Lesetabelle und f√ºr die Blattseiten des Index zu setzen. Dadurch blockieren wir nicht nur bestimmte Werte, sondern auch den gesamten gelesenen Bereich. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001)) | Heap Fetches: 2 | Planning Time: 0.096 ms | Execution Time: 0.153 ms | (5 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- tuple | pred | 3 | 236 tuple | pred | 3 | 235 page | pred_n_idx | 22 | (3 rows)</code> </pre><br>  M√∂glicherweise stellen Sie mehrere Schwierigkeiten fest. <br><br>  Zun√§chst wird f√ºr jede gelesene Version der Zeile eine separate Sperre erstellt. M√∂glicherweise gibt es jedoch viele solcher Versionen.  Die Gesamtzahl der Pr√§dikatsperren im System wird durch das Produkt der Parameterwerte <em>max_pred_locks_per_transaction</em> √ó <em>max_connections begrenzt</em> (die Standardwerte sind 64 bzw. 100).  Der Speicher f√ºr solche Sperren wird beim Serverstart zugewiesen.  Der Versuch, diese Anzahl zu √ºberschreiten, f√ºhrt zu Fehlern. <br><br>  Daher wird f√ºr Pr√§dikatsperren (und nur f√ºr sie!) Eine <em>Stufenerh√∂hung</em> verwendet.  Vor PostgreSQL 10 gab es Einschr√§nkungen, die fest im Code verankert waren, und beginnend damit k√∂nnen Sie die Parameter steuern, indem Sie den Pegel erh√∂hen.  Wenn die Anzahl der Zeilenversionssperren <em>pro Zeile</em> gr√∂√üer als <em>max_pred_locks_per_page ist</em> , werden diese Sperren durch eine Sperre auf <em>Seitenebene</em> ersetzt.  Hier ist ein Beispiel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> max_pred_locks_per_page;</code> </pre><pre> <code class="plaintext hljs"> max_pred_locks_per_page ------------------------- 2 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002)) | Heap Fetches: 3 | Planning Time: 0.069 ms | Execution Time: 0.057 ms | (5 rows)</code> </pre><br>  Anstelle von drei Tupel-Sperren sehen wir einen Seitentyp: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 22 | (2 rows)</code> </pre><br>  Wenn die Anzahl der einer einzelnen Beziehung zugeordneten <em>Seitensperren max_pred_locks_per_relation</em> √ºberschreitet, werden diese Sperren durch eine Sperre auf Beziehungsebene ersetzt. <br><br>  Es gibt keine anderen Ebenen: Pr√§dikatsperren werden nur f√ºr Relationen, Seiten oder Zeilenversionen und immer im SIReadLock-Modus erfasst. <br><br>  Nat√ºrlich f√ºhrt eine Erh√∂hung der Sperrenstufe zwangsl√§ufig dazu, dass eine gr√∂√üere Anzahl von Transaktionen f√§lschlicherweise zu einem Serialisierungsfehler f√ºhrt und infolgedessen der Durchsatz des Systems abnimmt.  Hier m√ºssen Sie nach einem Gleichgewicht zwischen Speicherverbrauch und Leistung suchen. <br><br>  Die zweite Schwierigkeit besteht darin, dass sich bei verschiedenen Operationen mit dem Index (z. B. aufgrund der Aufteilung der Indexseiten beim Einf√ºgen neuer Zeilen) die Anzahl der Blattseiten, die den Lesebereich abdecken, √§ndern kann.  Die Umsetzung ber√ºcksichtigt jedoch: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 211 | page | pred_n_idx | 212 | page | pred_n_idx | 22 | (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Pr√§dikatsperren werden √ºbrigens nicht immer unmittelbar nach Abschluss der Transaktion entfernt, da sie zur Verfolgung der Abh√§ngigkeiten zwischen <em>mehreren</em> Transaktionen ben√∂tigt werden.  In jedem Fall werden sie jedoch automatisch verwaltet. <br><br>  Nicht alle Indextypen in PostgreSQL unterst√ºtzen Pr√§dikatsperren.  Bisher konnten sich nur B-B√§ume damit r√ºhmen, aber in PostgreSQL 11 verbesserte sich die Situation: Hash-Indizes, GiST und GIN wurden der Liste hinzugef√ºgt.  Wenn der Indexzugriff verwendet wird und der Index nicht mit Pr√§dikatsperren funktioniert, ist der gesamte Index an die Sperre gebunden.  Dies erh√∂ht nat√ºrlich auch die Anzahl falscher Transaktionsunterbrechungen. <br><br>  Abschlie√üend stelle ich fest, dass es bei Verwendung von Pr√§dikatsperren eine Einschr√§nkung gibt, dass <em>alle</em> Transaktionen auf der Ebene der Serialisierbarkeit ausgef√ºhrt werden m√ºssen, um eine vollst√§ndige Isolation zu gew√§hrleisten.  Wenn eine Transaktion eine andere Ebene verwendet, werden Pr√§dikatsperren einfach nicht gesetzt (und √ºberpr√ºft). <br><br><blockquote>  Traditionell hinterlasse ich einen Link zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README f√ºr Pr√§dikatsperren</a> , von dem aus Sie mit dem Studium des Quellcodes beginnen k√∂nnen. <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465263/">https://habr.com/ru/post/de465263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465251/index.html">Der Sommer ist fast vorbei. Es sind fast keine Daten durchgesickert</a></li>
<li><a href="../de465255/index.html">Implementierung des WCF-Verbindungspools f√ºr .Net Core mithilfe von HttpClientFactory</a></li>
<li><a href="../de465257/index.html">"Vorsicht, FAS!": McDonald's Tricks, g√∂ttliches D√∂ner, falsches Clooney und etwas Stra√üenmagie</a></li>
<li><a href="../de465259/index.html">ValueTask <TResult> - warum, warum und wie?</a></li>
<li><a href="../de465261/index.html">Die magische Kraft von Makros oder wie man einem AVR-Assembler-Programmierer das Leben leichter macht</a></li>
<li><a href="../de465267/index.html">TypeScript Ausdruck Magie</a></li>
<li><a href="../de465269/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 26. DNS und DHCP</a></li>
<li><a href="../de465271/index.html">Hacker stehlen und waschen Geld durch Lieferservice und Hotelreservierung.</a></li>
<li><a href="../de465273/index.html">Wie Microgaming-Softwareentwickler Benutzer vor Hacks sch√ºtzen</a></li>
<li><a href="../de465275/index.html">Alice bekommt Geschicklichkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>