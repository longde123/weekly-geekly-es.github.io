<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì≥ ü§òüèª üë©üèæ‚Äçü§ù‚Äçüë®üèª Innovaciones de JavaScript: resultados de Google I / O 2019. Parte 1 üßíüèΩ üñïüèº üîå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya primera parte de la traducci√≥n publicamos hoy, est√° dedicado a las nuevas caracter√≠sticas est√°ndar de JavaScript que se discutieron ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Innovaciones de JavaScript: resultados de Google I / O 2019. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464129/">  El material, cuya primera parte de la traducci√≥n publicamos hoy, est√° dedicado a las nuevas caracter√≠sticas est√°ndar de JavaScript que se discutieron en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google I / O 2019</a> .  En particular, aqu√≠ hablaremos sobre expresiones regulares, sobre campos de clase, sobre c√≥mo trabajar con cadenas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/h9/k-/lh/h9k-lhwr73vkp2jrbj6onwpliay.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">Verificaciones de expresiones regulares</font> </h2><br>  Las expresiones regulares (Expresi√≥n regular, para abreviar: RegEx o RegExp) es una poderosa tecnolog√≠a de procesamiento de cadenas que se implementa en muchos lenguajes de programaci√≥n.  Las expresiones regulares son muy √∫tiles en casos donde necesita, por ejemplo, buscar fragmentos de cadenas por patrones complejos.  Hasta hace poco, la implementaci√≥n de JavaScript de expresiones regulares ten√≠a todo menos mirar hacia atr√°s. <br><br>  Para entender qu√© es una verificaci√≥n retrospectiva, primero hablemos de los lookaheads que ya son compatibles con JavaScript. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La segunda parte</a> <br><a name="habracut"></a><br><h3>  <font color="#3AC1EF">‚ñç Verificaci√≥n anticipada</font> </h3><br>  La sintaxis de las comprobaciones iniciales en las expresiones regulares le permite buscar fragmentos de cadenas cuando se sabe que hay otros fragmentos a la derecha de ellas.  Por ejemplo, cuando trabaje con la cadena <code>MangoJuice, VanillaShake, GrapeJuice</code> puede usar la sintaxis de una verificaci√≥n <code>MangoJuice, VanillaShake, GrapeJuice</code> positiva para encontrar las palabras seguidas inmediatamente por la palabra <code>Juice</code> .  En nuestro caso, estas son las palabras <code>Mango</code> y <code>Grape</code> . <br><br>  Hay dos tipos de cheques principales.  Estas son miradas positivas y negativas. <br><br><h4>  Comprobaci√≥n de plomo positiva </h4><br>  Se utiliza una verificaci√≥n inicial positiva para buscar l√≠neas a la derecha de las cuales hay otras l√≠neas conocidas previamente.  As√≠ es como se ve la sintaxis de expresi√≥n regular utilizada para esta verificaci√≥n: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?=Juice)/</code> </pre> <br>  Esta plantilla le permite seleccionar palabras que consisten en letras min√∫sculas o may√∫sculas, seguidas de la palabra <code>Juice</code> .  No confunda las estructuras que describen controles iniciales y retrospectivos con grupos de captura.  Aunque las condiciones de estas comprobaciones se escriben entre par√©ntesis, el sistema no las captura.  Veamos un ejemplo de una verificaci√≥n de plomo positiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/[a-zA-Z]+(?=Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Mango", "Grape"]</span></span></code> </pre> <br><h4>  Verificaci√≥n de plomo negativo </h4><br>  Si consideramos, utilizando la l√≠nea anterior, el mecanismo de acci√≥n de las comprobaciones iniciales negativas, resulta que le permiten encontrar palabras a la derecha de las cuales no hay palabra <code>Juice</code> .  La sintaxis de las comprobaciones iniciales negativas es similar a la sintaxis de las comprobaciones positivas.  Sin embargo, hay una caracter√≠stica, ¬°que el s√≠mbolo <code>=</code> (igual) cambia a un s√≠mbolo <code>!</code>  (signo de exclamaci√≥n)  As√≠ es como se ve: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?!Juice)/</code> </pre> <br>  Esta expresi√≥n regular le permite seleccionar todas las palabras a la derecha de las cuales no hay palabra <code>Juice</code> .  Pero al aplicar dicha plantilla, se seleccionar√°n todas las palabras en la l√≠nea ( <code>MangoJuice, VanillaShake, GrapeJuice</code> ).  El hecho es que, seg√∫n el sistema, ni una sola palabra termina aqu√≠ con <code>Juice</code> .  Como resultado, para lograr el resultado deseado, debe aclarar la expresi√≥n regular y reescribirla as√≠: <br><br><pre> <code class="javascript hljs">/(Mango|Vanilla|Grape)(?!Juice)/</code> </pre> <br>  El uso de esta plantilla le permite seleccionar las palabras <code>Mango</code> , o <code>Vanilla</code> , o <code>Grape</code> , despu√©s de lo cual no hay palabra <code>Juice</code> .  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(Mango|Vanilla|Grape)(?!Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Vanilla"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Verificaci√≥n retrospectiva</font> </h3><br>  Por analog√≠a con la sintaxis de las comprobaciones iniciales, la sintaxis de las comprobaciones retrospectivas le permite seleccionar secuencias de caracteres solo si a la izquierda de estas secuencias hay un patr√≥n dado.  Por ejemplo, al procesar la cadena <code>FrozenBananas, DriedApples, FrozenFish</code> podemos usar una verificaci√≥n retrospectiva positiva para encontrar palabras a la izquierda de las cuales est√° la palabra <code>Frozen</code> .  En nuestro caso, las palabras <code>Bananas</code> y <code>Fish</code> corresponden a esta condici√≥n. <br><br>  Existen, como es el caso de las verificaciones iniciales, verificaciones retrospectivas positivas (retrospectiva positiva) y verificaciones retrospectivas negativas (retrospectiva negativa o negativa). <br><br><h4>  Revisi√≥n retrospectiva positiva </h4><br>  Las comprobaciones retrospectivas positivas se utilizan para buscar patrones a la izquierda de los cuales hay otros patrones.  Aqu√≠ hay un ejemplo de la sintaxis utilizada para describir tales comprobaciones: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Aqu√≠ <code>&lt;</code> usa el s√≠mbolo <code>&lt;</code> , que no estaba en la descripci√≥n de las comprobaciones iniciales.  Adem√°s, la condici√≥n en la expresi√≥n regular se encuentra no a la derecha de la plantilla que nos interesa, sino a la izquierda.  Usando la plantilla anterior, puede seleccionar todas las palabras que comienzan con <code>Frozen</code> .  Considere un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Frozen)[a-zA-Z]+/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Bananas", "Fish"]</span></span></code> </pre> <br><h4>  Verificaci√≥n retrospectiva negativa </h4><br>  El mecanismo de comprobaciones retrospectivas negativas le permite buscar patrones en las l√≠neas a la izquierda de las cuales no hay un patr√≥n especificado.  Por ejemplo, si necesita seleccionar palabras que no comienzan con <code>Frozen</code> en la l√≠nea <code>FrozenBananas, DriedApples, FrozenFish</code> , puede intentar usar esta expresi√≥n regular: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Pero, dado que el uso de esta construcci√≥n conducir√° a la selecci√≥n de todas las palabras de la cadena, ya que ninguna de ellas comienza con <code>Frozen</code> , la expresi√≥n regular debe aclararse: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)(Bananas|Apples|Fish)</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Frozen)(Bananas|Apples|Fish)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Apples"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Soporte</font> </h3><br>  Esta y otras secciones similares proporcionar√°n informaci√≥n sobre la etapa de armonizaci√≥n de las caracter√≠sticas descritas de JS en el Comit√© T√©cnico 39 (Comit√© T√©cnico 39, TC39), que es responsable en ECMA International de respaldar las especificaciones de ECMAScript.  Dichas secciones tambi√©n proporcionar√°n datos sobre las versiones de Chrome y Node.js (y, a veces, sobre la versi√≥n de Firefox), comenzando con las cuales puede utilizar las funciones correspondientes. <br><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Etapa 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">62+</a> </li><li>  Nodo: 8.10.0+ </li></ul><br><h2>  <font color="#3AC1EF">Campos de clase</font> </h2><br>  Un campo de clase es una nueva construcci√≥n de sintaxis utilizada para definir las propiedades de las instancias de clase (objetos) fuera del constructor de la clase.  Hay dos tipos de campos de clase: campos de clase p√∫blica y campos de clase privada. <br><br><h3>  <font color="#3AC1EF">‚ñç Campos de clase p√∫blica</font> </h3><br>  Hasta hace poco, las propiedades de los objetos ten√≠an que definirse dentro del constructor de la clase.  Estas propiedades eran p√∫blicas (p√∫blicas).  Esto significa que se puede acceder a ellos trabajando con una instancia de la clase (objeto).  Aqu√≠ hay un ejemplo de declarar una propiedad p√∫blica: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'Tommy'</span></span>;    } }</code> </pre> <br>  Cuando era necesario crear una clase que extendiera cierta clase padre, era necesario llamar a <code>super()</code> en el constructor de la clase hija.  Esto ten√≠a que hacerse antes de que sus propias propiedades pudieran agregarse a la clase secundaria.  As√≠ es como se ve: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//  super   `this`          this.sound = 'Woof! Woof!';    }    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Gracias a la aparici√≥n de la sintaxis de los campos p√∫blicos de una clase, es posible describir los campos de clase fuera del constructor.  El sistema realizar√° una llamada impl√≠cita a <code>super()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Cuando se llama impl√≠citamente a <code>super()</code> , todos los argumentos proporcionados por el usuario al crear la instancia de clase se le pasan (este es el comportamiento est√°ndar de JavaScript, no hay nada especial en los campos de clase privada).  Si el constructor de la clase padre necesita argumentos preparados de una manera especial, debe llamar a <code>super()</code> usted mismo.  Eche un vistazo a los resultados de la llamada al constructor impl√≠cito de la clase principal al crear una instancia de la clase secundaria. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( ...args ) {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'Animal args:'</span></span>, args );    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog( 'Tommy', 'Loves', 'Toys!' ); tommy.makeSound(); // Animal args: [ 'Tommy', 'Loves', 'Toys!' ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Campos de clase privada</font> </h3><br>  Como sabes, en JavaScript no hay modificadores de acceso a campos de clase como <code>public</code> , <code>private</code> o <code>protected</code> .  Todas las propiedades de los objetos son p√∫blicas de forma predeterminada.  Esto significa que el acceso a ellos es ilimitado.  Lo m√°s parecido a hacer que una propiedad de un objeto sea similar a una propiedad privada es usar el tipo de datos <code>Symbol</code> .  Esto le permite ocultar las propiedades de los objetos del mundo exterior.  Es posible que haya utilizado nombres de propiedades con el prefijo <code>_</code> (gui√≥n bajo) para indicar que las propiedades correspondientes deben considerarse destinadas solo para su uso dentro del objeto.  Sin embargo, esta es solo una especie de notificaci√≥n para aquellos que utilizar√°n la instalaci√≥n.  Esto no resuelve el problema de la restricci√≥n real del acceso a las propiedades. <br><br>  Gracias al mecanismo de los campos privados de clases, es posible hacer que las propiedades de la clase sean accesibles solo dentro de esta clase.  Esto lleva al hecho de que no se puede acceder desde el exterior y trabajar con una instancia de la clase (objeto).  Tome el ejemplo anterior e intente acceder a la propiedad de la clase desde afuera, cuando se utiliz√≥ el prefijo <code>_</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    _sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//            makeSound() {        console.log( this._sound );    } } //    const tommy = new Dog(); console.log( tommy._sound ); // Woof! Woof!</span></span></code> </pre> <br>  Como puede ver, usar el prefijo <code>_</code> no resuelve nuestro problema.  Los campos privados de clases se pueden declarar de la misma manera que los campos p√∫blicos, pero en lugar de un prefijo en forma de gui√≥n bajo, debe agregar un prefijo en forma de signo de <code>#</code> ( <code>#</code> ) a sus nombres.  Un intento de acceso no autorizado a la propiedad privada del objeto declarada de esta manera dar√° como resultado el siguiente error: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>: Undefined private field</code> </pre> <br>  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  -      makeSound() {        console.log( this.#sound );    } } //    const tommy = new Dog(); tommy.makeSound() // Woof! Woof! //console.log( tommy.#sound ); // SyntaxError</span></span></code> </pre> <br>  Tenga en cuenta que solo se puede acceder a las propiedades privadas desde la clase en la que se declaran.  Como resultado, las clases descendientes no pueden usar directamente propiedades similares de la clase padre. <br><br>  Los campos privados (y p√∫blicos) se pueden declarar sin escribir ciertos valores en ellos: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #name;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( name ) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name = name;    }    showName() {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name );    } } <span class="hljs-comment"><span class="hljs-comment">//    const tommy = new Dog( 'Tommy' ); tommy.showName(); // Tommy</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Soporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Etapa 3</a> </li><li>  Chrome: 74+ </li><li>  Nodo: 12+ </li></ul><br><h2>  <font color="#3AC1EF">M√©todo de cadena .matchAll ()</font> </h2><br>  El prototipo de tipo de datos de <code>String</code> tiene un m√©todo <code>.match()</code> que devuelve una matriz de fragmentos de cadena que coinciden con la condici√≥n especificada por la expresi√≥n regular.  Aqu√≠ hay un ejemplo usando este m√©todo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : ["EEE", "CCC", "FAFAFA", "F00", "000"]</span></span></code> </pre> <br>  Sin embargo, cuando se utiliza este m√©todo, no se proporciona informaci√≥n adicional (como √≠ndices) sobre los fragmentos encontrados de la cadena.  Si elimina el indicador <code>g</code> de la expresi√≥n regular pasada al m√©todo <code>.match()</code> , devolver√° una matriz que contendr√° informaci√≥n adicional sobre los resultados de b√∫squeda.  Sin embargo, con este enfoque, solo se encontrar√° el primer fragmento de la cadena que coincida con la expresi√≥n regular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Para obtener algo similar, pero para varios fragmentos de una cadena, deber√° usar el m√©todo de expresi√≥n regular <code>.exec()</code> .  Las construcciones que se necesitan para esto son m√°s complicadas que aquella en la que se usar√≠a un m√©todo de cadena √∫nica para obtener resultados similares.  En particular, aqu√≠ necesitamos un <code>while</code> que se ejecutar√° hasta que <code>.exec()</code> devuelva <code>null</code> .  Con este enfoque, tenga en cuenta que <code>.exec()</code> no devuelve un iterador. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        , // Uncaught ReferenceError: match is not defined while( match = matchColorRegExp.exec( colors ) ) {  console.log( match ); } // : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Para resolver estos problemas, ahora podemos usar el m√©todo de cadena <code>.matchAll()</code> , que devuelve un iterador.  Cada llamada al m√©todo <code>.next()</code> de este iterador <code>.next()</code> siguiente elemento de los resultados de b√∫squeda.  Como resultado, el ejemplo anterior se puede reescribir de la siguiente manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( ...colors.matchAll( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Soporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">etapa 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">73+</a> </li><li>  Nodo: 12+ </li><li>  Firefox: 67+ </li></ul><br><h2>  <font color="#3AC1EF">Grupos nombrados en expresiones regulares</font> </h2><br>  El concepto de grupos en la implementaci√≥n de JavaScript de los mecanismos de expresi√≥n regular es ligeramente diferente de la implementaci√≥n de un concepto similar en otros lenguajes.  Es decir, cuando, usando JavaScript, la plantilla RegEx se coloca entre par√©ntesis (excepto cuando los par√©ntesis se usan para verificaciones retrospectivas o avanzadas), la plantilla se convierte en un grupo. <br><br>  Los fragmentos de la cadena capturados por el grupo se reflejar√°n en los resultados de la aplicaci√≥n de la expresi√≥n regular. <br><br>  En el ejemplo anterior, podr√≠a ver que el primer elemento de la matriz con los resultados de b√∫squeda es el que coincide con la expresi√≥n regular completa, y el segundo es el que corresponde al grupo.  Aqu√≠ est√° este elemento de matriz: <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">"#EEE"</span></span>, <span class="hljs-string"><span class="hljs-string">"EEE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;colors&gt;"</span></span>]</code> </pre> <br>  Si hay varios grupos en la expresi√≥n regular, entrar√°n en los resultados del procesamiento de la cadena en el orden de su descripci√≥n en la expresi√≥n regular.  Considere un ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is ([az]+) ([az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp );<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-comment"><span class="hljs-comment">//   result  null -   console.log( { firstName: result[1], lastName: result[2] } ); // : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: undefined] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Aqu√≠ puede ver que la primera l√≠nea de la salida es la l√≠nea completa correspondiente a la expresi√≥n regular.  El segundo y tercer elemento representan lo que fue capturado por los grupos. <br><br>  El uso de grupos con nombre le permite guardar qu√© grupos est√°n capturando dentro del objeto de <code>groups</code> , cuyos nombres de propiedad corresponden a los nombres asignados a los grupos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is (?&lt;firstName&gt;[az]+) (?&lt;lastName&gt;[az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result.groups ); <span class="hljs-comment"><span class="hljs-comment">// : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: {firstName: "John", lastName: "Doe"}] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Cabe se√±alar que los grupos con nombre funcionan bien junto con el m√©todo <code>.matchAll()</code> . <br><br><h3>  <font color="#3AC1EF">‚Üí Soporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Etapa 4</a> </li><li>  Chrome: 64+ </li><li>  Nodo: 10+ </li></ul><br>  Continuar√° ... <br><br>  <b>Estimados lectores!</b>  ¬øHas utilizado alguna de las innovaciones de JavaScript descritas aqu√≠? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464129/">https://habr.com/ru/post/464129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464117/index.html">Visitando a Vladimir Likhachev, padre de Nikolai Likhachev, mejor conocido como Chris Kaspersky</a></li>
<li><a href="../464119/index.html">Frontend Weekly Digest (12-18 de agosto de 2019)</a></li>
<li><a href="../464121/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 376 (12 al 18 de agosto de 2019)</a></li>
<li><a href="../464125/index.html">Historia secreta de Internet en la pol√≠tica de privacidad de 4.000 palabras de Google</a></li>
<li><a href="../464127/index.html">Desarrollo de favicons animados.</a></li>
<li><a href="../464131/index.html">Innovaciones de JavaScript: resultados de Google I / O 2019. Parte 2</a></li>
<li><a href="../464133/index.html">El rendimiento no se trata solo de CPU: crear sus propios perfiladores para Python</a></li>
<li><a href="../464137/index.html">Soporte t√©cnico Miran: c√≥mo funciona</a></li>
<li><a href="../464141/index.html">Fantas√≠as sobre el tema de las metaclases en C #</a></li>
<li><a href="../464143/index.html">Cura personal contra el c√°ncer. C√≥mo los genes del paciente afectan el √©xito del tratamiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>