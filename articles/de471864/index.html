<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¶ üå•Ô∏è üï∫üèª PEG-Parser-Generierung ‚òîÔ∏è üôÖüèΩ üöµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem ich nun die Grundlagen eines propriet√§ren Parsers skizziert habe, k√∂nnen wir seine Methoden, wie versprochen, aus der Grammatik generieren. Ic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PEG-Parser-Generierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471864/"><p> Nachdem ich nun die Grundlagen eines propriet√§ren Parsers skizziert habe, k√∂nnen wir seine Methoden, wie versprochen, aus der Grammatik generieren.  Ich werde auch zeigen, wie man einen Packrat-Parser mit dem <code>@memoize</code> Dekorator <code>@memoize</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik f√ºr PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p>  Letztes Mal haben wir uns einige Parser-Methoden angesehen.  Mit einigen Einschr√§nkungen, die wir etwas sp√§ter entfernen werden, k√∂nnen sie einfach automatisch aus der Grammatik generiert werden. </p><a name="habracut"></a><br><p>  Wir brauchen zwei Dinge: etwas, das die Grammatik liest und eine geeignete Datenstruktur aufbaut;  und etwas, das diese Datenstruktur √ºbernimmt und einen Parser generiert.  Wir brauchen auch andere Hilfsmethoden, aber sie sind nicht interessant, deshalb werde ich sie weglassen. </p><br><p>  Wir erstellen also einen einfachen Compiler-Compiler.  Ich werde die grammatikalische Notation ein wenig vereinfachen, insofern wir nur Regeln und Alternativen haben;  Dies ist eigentlich genug f√ºr die Spielzeuggrammatik, die ich in den vorherigen Teilen verwendet habe: </p><br><pre> <code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  Mit der vollst√§ndigen Notation k√∂nnen wir die Grammatik beschreiben als: </p><br><pre> <code class="plaintext hljs">grammar: rule+ ENDMARKER rule: NAME ':' alternative ('|' alternative)* NEWLINE alternative: item+ item: NAME | STRING</code> </pre> <br><p>  Dies ist unsere erste Meta-Grammatik (Grammatik f√ºr Grammatiken), und unser Parser-Generator wird ein Meta-Compiler sein (ein Compiler ist ein Programm, das Programme von einer Sprache in eine andere √ºbersetzt; ein Meta-Compiler ist ein Compiler, bei dem die Eingabe eine Grammatik ist, und Die Ausgabe ist ein Parser. </p><br><p>  Eine einfache M√∂glichkeit, eine Meta-Grammatik zu beschreiben, besteht darin, nur die integrierten Datentypen zu verwenden: Der rechte Teil der Regel ist eine Liste von Elementlisten, von denen jedes nur eine Zeichenfolge sein kann.  (√úbrigens k√∂nnen wir <code>NAME</code> und <code>STRING</code> trennen, indem wir pr√ºfen, ob das erste Zeichen ein Anf√ºhrungszeichen ist.) </p><br><p>  F√ºr Regeln verwende ich die einfache <code>Rule</code> , und die gesamte Grammatik ist eine Liste solcher Objekte.  Hier ist die <code>__repr__</code> Ausnahme von <code>__repr__</code> und <code>__eq__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, alts)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.alts = alts</code> </pre> <br><p>  Und hier ist die <code>GrammarParser</code> Klasse, die es verwendet: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GrammarParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grammar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rule := self.rule(): rules = [rule] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rule := self.rule(): rules.append(rule) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.expect(ENDMARKER): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rules <span class="hljs-comment"><span class="hljs-comment"># &lt;------------- final result self.reset(pos) return None def rule(self): pos = self.mark() if name := self.expect(NAME): if self.expect(":"): if alt := self.alternative(): alts = [alt] apos = self.mark() while (self.expect("|") and (alt := self.alternative())): alts.append(alt) apos = self.mark() self.reset(apos) if self.expect(NEWLINE): return Rule(name.string, alts) self.reset(pos) return None def alternative(self): items = [] while item := self.item(): items.append(item) return items def item(self): if name := self.expect(NAME): return name.string if string := self.expect(STRING): return string.string return None</span></span></code> </pre> <br><p>  <code>ENDMARKER</code> auf die Verwendung von <code>ENDMARKER</code> .  Dort stelle ich sicher, dass nach der letzten Regel nichts mehr √ºbrig bleibt (und dies kann passieren, wenn die Grammatik einen Tippfehler enth√§lt).  Ich habe auch auf die Stelle hingewiesen, an der die <code>grammar()</code> -Methode eine Liste von Regeln zur√ºckgibt.  Alles andere ist der <code>ToyParser</code> Klasse aus dem letzten Artikel sehr √§hnlich, daher werde ich nicht weiter darauf <code>ToyParser</code> .  <code>alts</code> nur, dass <code>item()</code> eine Zeichenfolge zur√ºckgibt, <code>alternative()</code> eine Liste von Zeichenfolgen zur√ºckgibt und die Variable <code>alts</code> in <code>rule()</code> eine Liste von Zeichenfolgen sammelt.  Anschlie√üend kombiniert die Methode <code>rule()</code> den Namen der Regel (Zeichenfolge) und konvertiert sie in ein <code>Rule</code> . </p><br><p>  Wenn wir diesen Algorithmus auf unsere Spielzeuggrammatik anwenden, gibt die <code>grammar()</code> -Methode die folgende Liste von Regeln zur√ºck: </p><br><pre> <code class="plaintext hljs">[ Rule('statement', [['assignment'], ['expr'], ['if_statement']]), Rule('expr', [['term', "'+'", 'expr'], ['term', "'-'", 'term'], ['term']]), Rule('term', [['atom', "'*'", 'term'], ['atom', "'/'", 'atom'], ['atom']]), Rule('atom', [['NAME'], ['NUMBER'], ["'('", 'expr', "')'"]]), Rule('assignment', [['target', "'='", 'expr']]), Rule('target', [['NAME']]), Rule('if_statement', [["'if'", 'expr', "':'", 'statement']]), ]</code> </pre> <br><p>  Nachdem wir den Parsing-Teil unseres Meta-Compilers haben, erstellen wir einen Code-Generator.  Zusammen bilden sie einen elementaren Meta-Compiler: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_parser_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rules)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">f"class ToyParser(Parser):"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: print() print(<span class="hljs-string"><span class="hljs-string">f" @memoize"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" def </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name}</span></span></span><span class="hljs-string">(self):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" pos = self.mark()"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: items = [] print(<span class="hljs-string"><span class="hljs-string">f" if (True"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> alt: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">"'"</span></span>): print(<span class="hljs-string"><span class="hljs-string">f" and self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: var = item.lower() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items: var += str(len(items)) items.append(var) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.isupper(): print(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">())"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" ):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"return Node(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name!r}</span></span></span><span class="hljs-string">, [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">', '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.join(items)}</span></span></span><span class="hljs-string">])"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" self.reset(pos)"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" return None"</span></span>)</code> </pre> <br><p>  Dieser Code ist ziemlich h√§sslich, aber er funktioniert (irgendwie), und in Zukunft werde ich ihn trotzdem umschreiben. </p><br><p>  Einige Zeilen in der <code>for alt in rule.alts</code> m√∂glicherweise erkl√§rt werden: F√ºr jedes Element in der Alternative w√§hlen wir eine von drei Optionen: </p><br><ul><li>  Wenn das Element ein String-Literal ist, zum Beispiel <code>'+'</code> , generieren wir <code>self.expect('+')</code> </li><li>  Wenn das Element vollst√§ndig in Gro√übuchstaben geschrieben ist, z. B. <code>NAME</code> , generieren wir <code>(name := self.expect(NAME))</code> </li><li>  Andernfalls generieren wir zum Beispiel, wenn es <code>expr</code> , <code>(expr := self.expr())</code> </li></ul><br><p>  Wenn in einer Variante mehrere Elemente mit demselben Namen vorhanden sind (z. B. <code>term '-' term</code> ), f√ºgen wir der zweiten eine Ziffer hinzu.  Es gibt hier auch einen kleinen Fehler, den ich in der n√§chsten Folge korrigieren werde. </p><br><p>  Hier ist ein kleiner Teil des Ergebnisses seiner Arbeit (die ganze Klasse w√§re sehr langweilig).  Machen Sie sich keine Sorgen √ºber den redundanten <code>if (True and</code> ... <code>)</code> Code, der ben√∂tigt wird, damit jede generierte Bedingung mit <code>and</code> .  Der Python-Byte-Compiler optimiert dies. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> @memoize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (assignment := self.assignment()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [assignment]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (expr := self.expr()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [expr]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (if_statement := self.if_statement()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [if_statement]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ...</code> </pre> <br><p>  <code>@memoize</code> auf den <code>@memoize</code> Dekorateur: Ich habe ihn eingef√ºhrt, um zu einem anderen Thema <code>@memoize</code> : Verwenden von Memoization, um den generierten Parser schnell genug zu machen. </p><br><p>  Hier ist die Funktion <code>memoize()</code> , die diesen Dekorator implementiert: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Wie in anderen Dekoratoren enth√§lt es eine verschachtelte Funktion, die eine dekorierte Funktion ersetzt (oder umschlie√üt), z. B. die <code>statement()</code> -Methode der <code>ToyParser</code> Klasse.  Da es sich bei der <code>ToyParser</code> Funktion um eine Methode handelt, ist der Wrapper auch eine Methode: Das erste Argument hei√üt <code>self</code> und bezieht sich auf die <code>ToyParser</code> Instanz, f√ºr die die dekorierte Methode aufgerufen wird. </p><br><p>  Der Wrapper speichert das Ergebnis des Methodenaufrufs f√ºr jede Eingabeposition zwischen - daher wird er als Packrat-Parser bezeichnet!  [ca.  trans.  packrat ist ein "Dieb", aber dieser Begriff wird nicht in russischsprachigen Quellen √ºbersetzt.] Cache ist ein W√∂rterbuch mit W√∂rterb√ºchern, das in einer <code>Parser</code> Instanz gespeichert ist.  Der Schl√ºssel des externen W√∂rterbuchs ist die Position im Eingabedatenstrom.  Ich habe auch <code>self.memos = {}</code> zu <code>Parser .__ init__()</code> hinzugef√ºgt, um es zu initialisieren.  Interne W√∂rterb√ºcher werden nach Bedarf hinzugef√ºgt.  Ihre Schl√ºssel bestehen aus einer Methode und ihren Argumenten.  (Das aktuelle Design enth√§lt keine Argumente, aber wir k√∂nnten uns die Funktion "accept <code>expect()</code> merken, die <code>expect()</code> hat, was ziemlich trivial ist.) </p><br><p>  Das Ergebnis der Parser-Methode wird in Form eines Tupels dargestellt, da es tats√§chlich zwei Werte gibt: das Ergebnis selbst (f√ºr unsere generierten Methoden ist dies der <code>Node</code> f√ºr die √úbereinstimmungsregel) und einen Zeiger auf die aktuelle Position im Eingabestream, die wir von <code>self.mark()</code> .  Daher zwischenspeichern wir sowohl den R√ºckgabewert ( <code>res</code> ) als auch die neue Position ( <code>endpos</code> ) im internen W√∂rterbuch mit gespeicherten Werten.  Bei nachfolgenden Aufrufen derselben Analysemethode mit denselben Argumenten an derselben Eingabeposition werden sie aus dem Cache √ºbernommen.  Bewegen Sie dazu einfach den Zeiger mit <code>self.reset()</code> auf die Eingabeposition und schauen Sie in den Cache. </p><br><p>  Es ist auch wichtig, negative Ergebnisse zwischenzuspeichern - tats√§chlich sind die meisten Anrufe negativ.  In diesem Fall ist der R√ºckgabewert <code>None</code> und die Eingabeposition √§ndert sich nicht.  Sie k√∂nnen <code>assert</code> hinzuf√ºgen, um dies zu √ºberpr√ºfen. </p><br><p>  Hinweis  In Python ist es √ºblich, einen Cache in einer lokalen Variablen in der Funktion <code>memoize()</code> zu implementieren.  In unserem Fall funktioniert dies nicht: Wie ich am Ende des Debuggens herausgefunden habe, muss jede <code>Parser</code> Instanz einen eigenen Cache haben.  Sie k√∂nnen jedoch verschachtelte W√∂rterb√ºcher <code>pos</code> , indem Sie ( <code>pos</code> , <code>func</code> , <code>args</code> ) als Schl√ºssel verwenden. </p><br><p>  N√§chste Woche werde ich Code und Traces vorbereiten, um zu zeigen, wie all dies beim Parsen eines Beispielprogramms tats√§chlich zusammengestellt und ausgef√ºhrt wird.  Ich bin immer noch auf der Suche nach einer besseren M√∂glichkeit, die Zusammenarbeit von Tokenisierungspuffer, Parser und Cache zu visualisieren.  Vielleicht kann ich ein animiertes GIF in ASCII erstellen, anstatt nur die Trace-Listen als Text anzuzeigen. </p><br><p>  Lizenz f√ºr diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471864/">https://habr.com/ru/post/de471864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471854/index.html">Hitzetod 5G</a></li>
<li><a href="../de471856/index.html">Wir l√∂sen alle 42 Versionen des Harry-Potter-Trank-Puzzles</a></li>
<li><a href="../de471858/index.html">RabbitMQ vs. Kafka: Failover und Hochverf√ºgbarkeit in Clustern</a></li>
<li><a href="../de471860/index.html">Peg Parser</a></li>
<li><a href="../de471862/index.html">PEG-Parser-Implementierung</a></li>
<li><a href="../de471866/index.html">PEG-Parser-Visualisierung</a></li>
<li><a href="../de471868/index.html">Genetik der Liebe: Konflikt zwischen den Geschlechtern als Grundlage f√ºr die Zusammenarbeit bei Paaren monogamer V√∂gel</a></li>
<li><a href="../de471870/index.html">Effektive Nutzung von libdispatch</a></li>
<li><a href="../de471872/index.html">Schnittstellen in C # 8: Gef√§hrliche Annahmen in der Standardimplementierung</a></li>
<li><a href="../de471874/index.html">Wie wir die √úberpr√ºfungsrichtlinien umgangen und einen Server auf dem Telefon gestartet haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>