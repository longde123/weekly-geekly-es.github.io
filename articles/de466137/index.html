<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçï üõÄüèΩ üßëüèº‚Äçü§ù‚Äçüßëüèº System.IO. Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung ü§ë üëó üå§Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Seit der Ver√∂ffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen. Und solche coolen Innovationen wie Span und Memory sind ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO. Pipelines - ein wenig bekanntes Tool f√ºr Liebhaber hoher Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Hallo Leser.  Seit der Ver√∂ffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen.  Und solche coolen Innovationen wie Span und Memory sind bereits weithin bekannt. Sie k√∂nnen viel dar√ºber lesen, sehen und h√∂ren.  Leider erhielt die Bibliothek mit dem Namen System.IO. Pipeslines nicht die gleiche Aufmerksamkeit.  Fast alles, was es zu diesem Thema gibt, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der einzige Beitrag</a> , der auf vielen Ressourcen √ºbersetzt und kopiert wurde.  Es sollte mehr Informationen √ºber diese Technologie geben, um sie aus verschiedenen Blickwinkeln betrachten zu k√∂nnen. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Ziel dieser Bibliothek ist es daher, die Verarbeitung von Streaming-Daten zu beschleunigen.  Es wurde urspr√ºnglich vom Entwicklungsteam von Kestrel (einem plattform√ºbergreifenden Webserver f√ºr ASP.NET Core) erstellt und verwendet. Derzeit ist es f√ºr Sterbliche √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nuget-Paket</a> verf√ºgbar. <br><br>  Bevor wir uns mit dem Thema befassen, k√∂nnen wir uns den Bibliotheksmechanismus als ein verbessertes Analogon von MemoryStream vorstellen.  Das Problem mit dem urspr√ºnglichen MemoryStream ist eine √ºberm√§√üige Anzahl von Kopien. Dies ist offensichtlich, wenn Sie sich daran erinnern, dass ein privates Byte-Array in MemoryStream als Puffer verwendet wird.  In den <a href="">Lese-</a> und <a href="">Schreibmethoden</a> k√∂nnen Sie beispielsweise das Kopieren der Daten deutlich sehen.  Daher wird f√ºr das Objekt, das in den Stream geschrieben werden soll, eine Kopie im internen Puffer erstellt, und w√§hrend des Lesens wird eine Kopie der internen Kopie an den Verbraucher zur√ºckgegeben.  Es klingt nicht nach der rationalsten Nutzung des Ged√§chtnisses. <br><br>  System.IO.Pipelines zielt nicht darauf ab, alle Streams zu ersetzen, sondern ist ein zus√§tzliches Tool im Arsenal eines Entwicklers, der Hochleistungscode schreibt.  Ich schlage vor, dass Sie sich mit den grundlegenden Methoden und Klassen vertraut machen, deren Implementierungsdetails anzeigen und grundlegende Beispiele analysieren. <br><br>  Beginnen wir mit den Interna und Implementierungsdetails und betrachten gleichzeitig einfache Codefragmente.  Danach wird klar, wie es funktioniert und wie es verwendet werden sollte.  Bei der Arbeit mit System.IO.Pipelines ist zu beachten, dass das Grundkonzept darin besteht, dass alle Lese- / Schreibvorg√§nge ohne zus√§tzliche Zuordnungen erfolgen sollten.  Einige auf den ersten Blick attraktive Methoden widersprechen dieser Regel.  Dementsprechend beginnt der Code, den Sie so stark beschleunigen m√∂chten, Speicher f√ºr neue und neue Daten zuzuweisen, wodurch der Garbage Collector geladen wird. <br><br>  Die Interna der Bibliothek nutzen die umfangreichsten M√∂glichkeiten der neuesten Versionen der Sprache und Laufzeit - Span, Memory, Objektpools, ValueTask usw.  Es lohnt sich, dort zumindest nach einem gro√üartigen Beispiel f√ºr die Verwendung dieser Funktionen in der Produktion zu suchen. <br><br>  Zu einer Zeit waren einige Entwickler mit der Implementierung von Streams in C # nicht zufrieden, da eine Klasse sowohl zum Lesen als auch zum Schreiben verwendet wurde.  Aber wie sie sagen, k√∂nnen Sie keine Methoden aus einer Klasse werfen.  Auch wenn der Stream das Lesen / Schreiben / Suchen nicht unterst√ºtzt, werden die Eigenschaften CanRead, CanWrite und CanSeek verwendet.  Es sieht aus wie eine kleine Kr√ºcke.  Aber jetzt werden die Dinge anders. <br><br>  F√ºr die Arbeit mit Pipelines werden zwei Klassen verwendet: <a href="">PipeWriter</a> und <a href="">PipeReader</a> .  Diese Klassen enthalten ungef√§hr 50 Codezeilen und sind Pseudofassaden (nicht die klassischste ihrer Inkarnationen, da sie eine einzelne Klasse verbergen, nicht viel) f√ºr die Klasse <a href="">Pipe</a> , die die gesamte grundlegende Logik f√ºr die Arbeit mit Daten enth√§lt.  Diese Klasse enth√§lt 5 √∂ffentliche Mitglieder: 2 Konstruktoren, 2 Nur-Get-Eigenschaften - Reader und Writer, die Reset () -Methode, die interne Felder auf ihren Ausgangszustand zur√ºcksetzt, damit die Klasse wiederverwendet werden kann.  Die √ºbrigen Arbeitsmethoden sind intern und werden √ºber Pseudofassaden aufgerufen. <br><br><h2>  Beginnen wir mit der Pipe-Klasse </h2><br>  Die Klasseninstanz belegt 320 Bytes, was ziemlich viel ist (fast ein Drittel eines Kilobytes, 2 solcher Objekte konnten nicht in den Speicher von Manchester Mark I passen).  Daher ist es eine schlechte Idee, eine gro√üe Menge seiner Instanzen zuzuweisen.  Dar√ºber hinaus ist das Objekt f√ºr den Langzeitgebrauch vorgesehen.  Die Verwendung von Pools liefert auch ein Argument f√ºr diese Aussage.  Die im Pool verwendeten Objekte bleiben f√ºr immer erhalten (f√ºr die Standard-Pool-Implementierung). <br>  Beachten Sie, dass die Klasse als versiegelt markiert und threadsicher ist - viele Abschnitte des Codes sind ein kritischer Abschnitt und in Sperren eingeschlossen. <br><br>  Um diese Klasse zu verwenden, sollten Sie eine Instanz der Pipe-Klasse erstellen und die Objekte PipeReader und PipeWriter mit den genannten Eigenschaften abrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Einfache Initialisierung</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Betrachten Sie die Methoden zum Arbeiten mit Rohren: <br>  Schreiben mit PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br><br>  Lesen mit PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erw√§hnten Beitrag angegeben</a> , verwendet die Klasse eine einfach verkn√ºpfte Liste von Puffern.  Offensichtlich werden sie jedoch nicht zwischen PipeReader und PipeWriter √ºbertragen - die gesamte Logik befindet sich in einer Klasse.  Diese Liste wird sowohl zum Lesen als auch zum Schreiben verwendet.  Dar√ºber hinaus werden die zur√ºckgegebenen Daten in dieser Liste gespeichert (daher wird kein Kopieren durchgef√ºhrt). <br><br>  Es gibt auch Objekte, die den Beginn der zu lesenden Daten (ReadHead und Index), das Ende der zu lesenden Daten (ReadTail und Index) und den Beginn des zu schreibenden Speicherplatzes (WriteHead und die Anzahl der geschriebenen gepufferten Bytes) angeben.  Hier sind ReadHead, ReadTail und WriteHead bestimmte Elemente (Segmente) der internen Liste von Segmenten, und der Index gibt eine bestimmte Position innerhalb des Segments an.  Somit kann die Aufzeichnung von der Mitte eines Segments aus beginnen, ein ganzes n√§chstes Segment erfassen und in der Mitte des dritten Segments enden.  Diese Zeiger werden auf verschiedene Arten verschoben. <br><br><h2>  Erste Schritte mit PipeWriter-Methoden </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (ReadOnlyMemory &lt;Byte&gt; -Quelle, CancellationToken CancellationToken)</a> </h3><br>  Das wird auf den ersten Blick als attraktiv bezeichnet.  Es hat eine sehr geeignete und modische Signatur - akzeptiert ReadOnlyMemory, asynchron.  Und viele m√∂gen versucht sein, sich besonders daran zu erinnern, dass Span und Memory so schnell und cool sind.  Aber schmeichel dir nicht.  Diese Methode kopiert lediglich das an sie √ºbergebene ReadOnlyMemory in die interne Liste.  Mit "Kopieren" ist ein Aufruf der CopyTo () -Methode gemeint, bei dem nicht nur das Objekt selbst kopiert wird.  Alle Daten, die wir aufzeichnen m√∂chten, werden kopiert, wodurch der Speicher geladen wird.  Diese Methode sollte nur erw√§hnt werden, um sicherzustellen, dass es besser ist, sie nicht zu verwenden.  Nun, und vielleicht f√ºr einige seltene Situationen ist dieses Verhalten angemessen. <br>  Der Hauptteil der Methode ist ein kritischer Abschnitt. Der Zugriff darauf wird √ºber einen Monitor synchronisiert. <br><br>  Dann kann sich die Frage stellen, wie man etwas schreibt, wenn nicht mit der naheliegendsten und einzig geeigneten Methode <br><br><h3>  # 2 <a href="">Speicher &lt;Byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Die Methode verwendet einen Parameter eines Integer-Typs.  Darin m√ºssen wir angeben, wie viele Bytes wir in die Pipeline schreiben m√∂chten (welche Gr√∂√üe des Puffers wir wollen).  Diese Methode pr√ºft, ob in dem in _writingHeadMemory gespeicherten aktuellen Speicherfragment gen√ºgend Speicherplatz zum Schreiben vorhanden ist.  Wenn dies ausreicht, wird _writingHeadMemory als Speicher zur√ºckgegeben.  Andernfalls wird f√ºr die in den Puffer geschriebenen Daten, f√ºr die die FlushAsync-Methode nicht aufgerufen wurde, ein anderes BufferSegment aufgerufen, das mit dem vorherigen verbunden ist (hier ist unsere interne Liste).  Wenn _writingHeadMemory null ist, wird es mit einem neuen BufferSegment initialisiert.  Die Zuweisung des Puffers ist ein kritischer Abschnitt und erfolgt unter Verriegelung. <br><br>  Ich schlage vor, ein solches Beispiel anzuschauen.  Auf den ersten Blick scheint es, dass der Compiler (oder die Laufzeit) den D√§mon verf√ºhrt hat. <br><br><div class="spoiler">  <b class="spoiler_title">Teufelei</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Aber alles in diesem Beispiel ist verst√§ndlich und einfach. <br>  Beim Erstellen einer Pipe-Instanz k√∂nnen wir das <a href="">PipeOptions-</a> Objekt im Konstruktor mit Optionen zum Erstellen √ºbergeben. <br><br>  PipeOptions verf√ºgt √ºber ein Standardfeld f√ºr die minimale Segmentgr√∂√üe.  Vor nicht allzu langer Zeit war es 2048, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Commit</a> hat diesen Wert auf 4096 aktualisiert. Zum Zeitpunkt des Schreibens dieses Artikels befand sich die 4096-Version im Nuget-Paket vor der Ver√∂ffentlichung, die letzte Release-Version hatte einen Wert von 2048. Dies erkl√§rt den Verhalten des ersten Beispiels.  Wenn Sie eine kleinere Gr√∂√üe f√ºr den Standardpuffer verwenden m√∂chten, k√∂nnen Sie diese in einer Instanz des Typs PipeOptions angeben. <br><br>  Im zweiten Beispiel, in dem die Mindestgr√∂√üe angegeben ist, stimmt die L√§nge ohnehin nicht √ºberein.  Dies geschieht, weil die Erstellung eines neuen BufferSegments mithilfe von Pools erfolgt.  Eine der Optionen in PipeOptions ist der Speicherpool.  Danach wird der angegebene Pool verwendet, um ein neues Segment zu erstellen.  Wenn Sie keinen Speicherpool angegeben haben, wird der Standard-ArrayPool verwendet, der, wie Sie wissen, mehrere Buckets f√ºr Arrays unterschiedlicher Gr√∂√üe enth√§lt (jeder n√§chste ist zweimal gr√∂√üer als der vorherige) und wenn er f√ºr einen bestimmten angefordert wird Gr√∂√üe sucht es nach einem Eimer mit Arrays geeigneter Gr√∂√üe (dh dem n√§chstgr√∂√üeren oder gleich gro√üen).  Dementsprechend ist der neue Puffer mit ziemlicher Sicherheit gr√∂√üer als von Ihnen angefordert.  Die minimale Arraygr√∂√üe im Standard-ArrayPool (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) betr√§gt 16. Aber keine Sorge, dies ist ein Pool von Arrays.  Dementsprechend √ºbt das Array in den allermeisten F√§llen keinen Druck auf den Garbage Collector aus und wird sp√§ter wiederverwendet. <br><br><h3>  # 2.5 <a href="">Span &lt;Byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Es funktioniert √§hnlich und gibt Span from Memory. <br><br>  Daher sind GetMemory () oder GetSpan () die Hauptmethoden zum Schreiben.  Sie geben uns ein Objekt, an das wir schreiben k√∂nnen.  Dazu m√ºssen wir keinen Speicher f√ºr neue Arrays von Werten zuweisen, sondern k√∂nnen direkt in die Pipe schreiben.  Welche verwendet werden soll, h√§ngt haupts√§chlich von der verwendeten API und der Methodenasynchronit√§t ab.  In Anbetracht des Vorstehenden stellt sich jedoch eine Frage.  Woher wei√ü der Leser, wie viel wir geschrieben haben?  Wenn wir immer eine bestimmte Implementierung des Pools verwenden w√ºrden, die ein Array mit genau der gew√ºnschten Gr√∂√üe ergibt, k√∂nnte der Leser den gesamten Puffer auf einmal lesen.  Wie wir bereits gesagt haben, wird uns jedoch ein Puffer mit einer hohen Wahrscheinlichkeit einer gr√∂√üeren Gr√∂√üe zugewiesen.  Dies f√ºhrt zu der folgenden f√ºr den Betrieb erforderlichen Methode. <br><br><h3>  # 3 <a href="">void Advance (int Bytes)</a> </h3><br>  Eine schrecklich einfache Methode.  Es wird die Anzahl der als Argument geschriebenen Bytes verwendet.  Sie erh√∂hen die internen Z√§hler - _unflushedBytes und _writingHeadBytesBuffered, deren Namen f√ºr sich selbst sprechen.  Au√üerdem wird _writingHeadMemory genau auf die Anzahl der geschriebenen Bytes gek√ºrzt (Slices) (mithilfe der Slice-Methode).  Daher m√ºssen Sie nach dem Aufrufen dieser Methode einen neuen Speicherblock in Form von Memory oder Span anfordern. Sie k√∂nnen nicht in den vorherigen schreiben.  Und der gesamte K√∂rper der Methode ist ein kritischer Abschnitt und l√§uft unter einem Schloss. <br><br>  Es scheint, dass der Leser danach Daten empfangen kann.  Es ist jedoch noch ein Schritt erforderlich. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken CancellationToken)</a> </h3><br>  Die Methode wird aufgerufen, nachdem wir die erforderlichen Daten in den empfangenen Speicher (GetMemory) geschrieben und angegeben haben, wie viel wir dort geschrieben haben (Advance).  Die Methode gibt ValueTask zur√ºck, ist jedoch nicht asynchron (im Gegensatz zu ihrem Nachkommen StreamPipeWriter).  ValueTask ist ein spezieller Typ (schreibgesch√ºtzte Struktur), der verwendet wird, wenn die meisten Aufrufe nicht asynchron sind. Das hei√üt, alle erforderlichen Daten sind zum Zeitpunkt des Aufrufs verf√ºgbar und die Methode wird synchron beendet.  In sich selbst enth√§lt es entweder Daten oder Task (falls es nicht synchron funktioniert hat).  Dies h√§ngt von der Eigenschaft _writerAwaitable.IsCompleted ab.  Wenn wir nach √Ñnderungen am Status dieses _writerAwaitable suchen, werden wir feststellen, dass dies geschieht, wenn die Menge der nicht verbrauchten Daten (dies ist nicht genau die gleiche wie die sp√§ter untersuchten nicht erl√§uterten Daten) einen bestimmten Schwellenwert √ºberschreitet (_pauseWriterThreshold).  Der Standardwert ist 16 Segmentgr√∂√üen.  Falls gew√ºnscht, kann der Wert in PipeOptions ge√§ndert werden.  Diese Methode startet auch die Fortsetzung der ReadAsync-Methode, falls eine blockiert wurde. <br><br>  Gibt ein FlushResult zur√ºck, das zwei Eigenschaften enth√§lt - IsCanceled und IsCompleted.  IsCanceled gibt an, ob Flush abgebrochen wurde (CancelPendingFlush () -Aufruf).  IsCompleted gibt an, ob der PipeReader abgeschlossen wurde (durch Aufrufen der Methoden Complete () oder CompleteAsync ()). <br>  Der Hauptteil der Methode wird unter dem Schloss ausgef√ºhrt. <br><br>  Andere Methoden von PipeWriter sind aus Sicht der Implementierung nicht interessant und werden viel seltener verwendet, daher wird nur eine kurze Beschreibung gegeben. <br><br><h3>  # 5 void Complete (Ausnahme Ausnahme = null) oder ValueTask CompleteAsync (Ausnahme Ausnahme = null) </h3><br>  Markiert das zum Schreiben geschlossene Rohr.  Eine Ausnahme wird ausgel√∂st, wenn versucht wird, die Schreibmethoden nach Abschluss zu verwenden.  Wenn PipeReader bereits abgeschlossen wurde, wird auch die gesamte Pipe-Instanz abgeschlossen.  Die meiste Arbeit wird unter dem Schloss erledigt. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Wie der Name schon sagt, wird die aktuelle FlushAsync () -Operation abgebrochen.  Es gibt ein Schloss. <br><br><h3>  # 7 void OnReaderCompleted (Aktion &lt;Ausnahme, Objekt&gt; R√ºckruf, Objektstatus) </h3><br>  F√ºhrt den √ºbergebenen Delegaten aus, wenn der Reader abgeschlossen ist.  Es gibt auch ein Schloss. <br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> wird derzeit geschrieben, dass diese Methode bei einigen PipeWriter-Implementierungen m√∂glicherweise nicht aufgerufen wird und in Zukunft entfernt wird.  Daher sollten Sie keine Logik an diese Methoden binden. <br><br><h2>  Es ist Zeit f√ºr PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (CancellationToken-Token)</a> </h3><br>  Hier wird wie in FlushAsync () ValueTask zur√ºckgegeben, was darauf hindeutet, dass die Methode gr√∂√ütenteils synchron ist, aber nicht immer.  H√§ngt vom Status von _readerAwaitable ab.  Wie bei FlushAsync m√ºssen Sie feststellen, wann _readerAwaitable auf unvollst√§ndig gesetzt ist.  Dies geschieht, wenn PipeReader alles aus der internen Liste gelesen hat (oder Daten enth√§lt, die als gepr√ºft markiert wurden und Sie weitere Daten ben√∂tigen, um fortzufahren).  Was in der Tat offensichtlich ist.  Dementsprechend k√∂nnen wir den Schluss ziehen, dass es w√ºnschenswert ist, Pipe genau auf Ihre Arbeit abzustimmen und alle Optionen sorgf√§ltig auf der Grundlage empirisch identifizierter Statistiken festzulegen.  Durch eine ordnungsgem√§√üe Konfiguration wird die Wahrscheinlichkeit eines asynchronen Ausf√ºhrungszweigs verringert und eine effizientere Datenverarbeitung erm√∂glicht.  Fast der gesamte Code in der gesamten Methode ist von einer Sperre umgeben. <br><br>  Gibt ein mysteri√∂ses <a href="">ReadResult zur√ºck</a> .  Tats√§chlich ist es nur ein Puffer + Flags, der den Status des Vorgangs anzeigt (IsCanceled - ob ReadAsync abgebrochen wurde und IsCompleted angibt, ob der PipeWriter geschlossen wurde).  IsCompleted ist ein Wert, der angibt, ob die Methoden PipeWriter Complete () oder CompleteAsync () aufgerufen wurden.  Wenn diese Methoden mit einer √ºbergebenen Ausnahme aufgerufen wurden, wird sie beim Versuch des Lesens ausgel√∂st. <br><br>  Und wieder hat der Puffer einen mysteri√∂sen Typ - <a href="">ReadOnlySequence</a> .  Dies ist wiederum das Objekt f√ºr den Inhalt von Segmenten <a href="">(ReadOnlySequenceSegment)</a> des Anfangs- und des End + Start- und Endindex innerhalb der entsprechenden Segmente.  Was eigentlich der Struktur der Pipe-Klasse selbst √§hnelt.  BufferSegment wird √ºbrigens von ReadOnlySequenceSegment geerbt, was darauf hindeutet, dass BufferSegment in dieser Sequenz verwendet wird.  Dank dieser Funktion k√∂nnen Sie unn√∂tige Speicherzuweisungen f√ºr die Daten√ºbertragung vom Schreiber zum Leser vermeiden. <br>  ReadOnlySpan kann zur weiteren Verarbeitung aus dem Puffer abgerufen werden.  Um das Bild zu vervollst√§ndigen, k√∂nnen Sie √ºberpr√ºfen, ob der Puffer einen einzelnen ReadOnlySpan enth√§lt.  Wenn es enth√§lt, m√ºssen wir die Auflistung nicht von einem Element aus durchlaufen, und wir k√∂nnen sie mit der First-Eigenschaft abrufen.  Andernfalls m√ºssen alle Segmente im Puffer √ºberpr√ºft und jeweils ReadOnlySpan verarbeitet werden. <br><br>  Diskussionsthema - in der ReadOnlySequence-Klasse werden nullf√§hige Referenztypen aktiv verwendet und es gibt goto (nicht f√ºr die Verschachtelung tiefer Schleifen und nicht im generierten Code) - insbesondere <a href="">hier</a> . <br><br>  Nach der Verarbeitung m√ºssen Sie der Pipe-Instanz signalisieren, dass wir die Daten gelesen haben. <br><br><h3>  # 2 <a href="">bool TryRead (Ergebnis von ReadResult)</a> </h3><br>  Synchrone Version.  Erm√∂glicht das Abrufen des Ergebnisses, falls vorhanden.  Andernfalls wird im Gegensatz zu ReadAsync nicht blockiert und false zur√ºckgegeben.  Auch der Code dieser Methode befindet sich im Schloss. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition verbraucht, SequencePosition untersucht)</a> </h3><br>  Bei dieser Methode k√∂nnen Sie angeben, wie viele Bytes wir untersuchen und verbrauchen.  Daten, die untersucht, aber nicht verbraucht wurden, werden beim n√§chsten Lesen zur√ºckgegeben.  Diese Funktion mag auf den ersten Blick seltsam erscheinen, aber bei der Verarbeitung eines Bytestroms ist es selten erforderlich, jedes Byte einzeln zu verarbeiten.  Normalerweise werden Daten mithilfe von Nachrichten ausgetauscht.  Es kann vorkommen, dass der Leser beim Lesen eine ganze Nachricht und einen Teil der zweiten Nachricht erhalten hat.  Das Ganze muss verarbeitet werden, und ein Teil des zweiten sollte f√ºr die Zukunft √ºbrig bleiben, damit er mit dem verbleibenden Teil einhergeht.  Die AdvanceTo-Methode verwendet eine SequencePosition, bei der es sich tats√§chlich um ein Segment + Index handelt.  Wenn Sie alles verarbeiten, was ReadAsync gelesen hat, k√∂nnen Sie buffer.End angeben.  Andernfalls m√ºssen Sie explizit eine Position erstellen, die das Segment und den Index angibt, an dem die Verarbeitung gestoppt wurde.  Schloss ist unter der Haube. <br>  Wenn die Menge der nicht verbrauchten Informationen unter dem angegebenen Schwellenwert (_resumeWriterThreshold) liegt, wird die Fortsetzung von PipeWriter gestartet, wenn diese blockiert wurde.  Standardm√§√üig betr√§gt dieser Schwellenwert 8 Segmentvolumes (die H√§lfte des Blockierungsschwellenwerts). <br><br><h3>  # 4 void Complete (Ausnahme Ausnahme = null) </h3><br>  Vervollst√§ndigt den PipeReader.  Wenn der PipeWriter zu diesem Zeitpunkt abgeschlossen ist, wird die gesamte Pipe-Instanz abgeschlossen.  Innen verschlie√üen. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Erm√∂glicht das Abbrechen des derzeit ausstehenden Messwerts.  Sperren <br><br><h3>  # 6 void OnWriterCompleted (Aktion &lt;Ausnahme, Objekt&gt; R√ºckruf, Objektstatus) </h3><br>  Hier k√∂nnen Sie den Delegaten angeben, der nach Abschluss des PipeWriter ausgef√ºhrt werden soll. <br>  Wie bei der √§hnlichen Methode von PipeWriter gibt es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> dasselbe Tag, das entfernt wird.  Schloss ist unter der Haube. <br><br><h2>  Beispiel </h2><br>  Die folgende Auflistung zeigt ein Beispiel f√ºr die Arbeit mit Rohren. <br>  Seit der Einf√ºhrung von .NET Core Span und Memory wurden viele Klassen f√ºr die Arbeit mit Daten durch √úberladungen mit diesen Typen erg√§nzt.  Das allgemeine Interaktionsschema ist also ungef√§hr das gleiche.  In meinem Beispiel habe ich Pipelines verwendet, um mit Pipes zu arbeiten (ich mag √§hnliche W√∂rter) - Betriebssystemobjekte f√ºr die Interprozesskommunikation.  Die Pipes-API wurde gerade entsprechend erweitert, um Daten in Span und Memory zu lesen.  Die asynchrone Version verwendet Speicher, da die asynchrone Methode mithilfe einer automatisch generierten Finite-State-Maschine, in der alle lokalen Variablen und Methodenparameter gespeichert sind, in eine Vorlagenmethode konvertiert wird. Da Span ref readonly struct ist, kann sie nicht platziert werden Der Heap, der Span in einer asynchronen Methode verwendet, ist nicht m√∂glich.  Es gibt aber auch eine synchrone Version der Methode, mit der Sie Span verwenden k√∂nnen.  In meinem Beispiel habe ich beide ausprobiert und es stellte sich heraus, dass sich die synchrone Version in dieser Situation besser zeigt.  Bei Verwendung wird weniger Speicherbereinigung durchgef√ºhrt und die Datenverarbeitung ist schneller.  Dies lag jedoch nur daran, dass sich viele Daten in der Pipe befanden (die Daten waren immer verf√ºgbar).  In der Situation, in der es zum Zeitpunkt der Beantragung des n√§chsten Stapels wahrscheinlich keine Daten gibt, sollten Sie die asynchrone Version verwenden, um den Prozessorleerlauf nicht zu belasten. <br>  Das Beispiel enth√§lt Kommentare, die einige Punkte erl√§utern.  Ich mache Sie darauf aufmerksam, dass trotz der Tatsache, dass die Fragmente des Programms, die f√ºr das Lesen aus der Pipe und die Verarbeitung verantwortlich sind, beim Schreiben in eine Datei getrennt werden, die Daten genau von der Stelle gelesen werden, an der sie beim Lesen von der geschrieben wurden Rohr. <br><br><div class="spoiler">  <b class="spoiler_title">Jahre der Evolution f√ºr eine leistungsstarke Funktion - asynchrone Hauptleitung</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466137/">https://habr.com/ru/post/de466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466121/index.html">Klangerzeugung auf AVR-Mikrocontrollern mithilfe der Wavetable-Methode mit Polyphonieunterst√ºtzung</a></li>
<li><a href="../de466123/index.html">Wachstum. Gewicht. Drei Nachbarn</a></li>
<li><a href="../de466127/index.html">KKW Kola oder am Reaktor stehen</a></li>
<li><a href="../de466129/index.html">Effizienz des Transports mit Benzin, Batterien und Wasserstoff</a></li>
<li><a href="../de466135/index.html">Megapack: Wie Factorio-Entwickler es geschafft haben, das 200-Spieler-Multiplayer-Problem zu l√∂sen</a></li>
<li><a href="../de466139/index.html">Angewandte Technologie auf den Ruinen des Blockchain-Fiebers oder den praktischen Vorteilen der Ressourcenzuweisung</a></li>
<li><a href="../de466143/index.html">Wie haben wir Kartoncode oder die Scratch-Version des Brettspiels Golem Battle erstellt?</a></li>
<li><a href="../de466147/index.html">Reactive Data Display Manager. Einf√ºhrung</a></li>
<li><a href="../de466149/index.html">Erstellen eines Konnektorsymbols mit ‚Äûdynamischem‚Äú Text in OrCAD</a></li>
<li><a href="../de466151/index.html">Untersuchung: seltsame Programme im Register der inl√§ndischen Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>