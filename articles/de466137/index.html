<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍕 🛀🏽 🧑🏼‍🤝‍🧑🏼 System.IO. Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung 🤑 👗 🌤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Seit der Veröffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen. Und solche coolen Innovationen wie Span und Memory sind ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO. Pipelines - ein wenig bekanntes Tool für Liebhaber hoher Leistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Hallo Leser.  Seit der Veröffentlichung von .NET Core 2.1 ist ziemlich viel Zeit vergangen.  Und solche coolen Innovationen wie Span und Memory sind bereits weithin bekannt. Sie können viel darüber lesen, sehen und hören.  Leider erhielt die Bibliothek mit dem Namen System.IO. Pipeslines nicht die gleiche Aufmerksamkeit.  Fast alles, was es zu diesem Thema gibt, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der einzige Beitrag</a> , der auf vielen Ressourcen übersetzt und kopiert wurde.  Es sollte mehr Informationen über diese Technologie geben, um sie aus verschiedenen Blickwinkeln betrachten zu können. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Einführung </h2><br>  Ziel dieser Bibliothek ist es daher, die Verarbeitung von Streaming-Daten zu beschleunigen.  Es wurde ursprünglich vom Entwicklungsteam von Kestrel (einem plattformübergreifenden Webserver für ASP.NET Core) erstellt und verwendet. Derzeit ist es für Sterbliche über ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nuget-Paket</a> verfügbar. <br><br>  Bevor wir uns mit dem Thema befassen, können wir uns den Bibliotheksmechanismus als ein verbessertes Analogon von MemoryStream vorstellen.  Das Problem mit dem ursprünglichen MemoryStream ist eine übermäßige Anzahl von Kopien. Dies ist offensichtlich, wenn Sie sich daran erinnern, dass ein privates Byte-Array in MemoryStream als Puffer verwendet wird.  In den <a href="">Lese-</a> und <a href="">Schreibmethoden</a> können Sie beispielsweise das Kopieren der Daten deutlich sehen.  Daher wird für das Objekt, das in den Stream geschrieben werden soll, eine Kopie im internen Puffer erstellt, und während des Lesens wird eine Kopie der internen Kopie an den Verbraucher zurückgegeben.  Es klingt nicht nach der rationalsten Nutzung des Gedächtnisses. <br><br>  System.IO.Pipelines zielt nicht darauf ab, alle Streams zu ersetzen, sondern ist ein zusätzliches Tool im Arsenal eines Entwicklers, der Hochleistungscode schreibt.  Ich schlage vor, dass Sie sich mit den grundlegenden Methoden und Klassen vertraut machen, deren Implementierungsdetails anzeigen und grundlegende Beispiele analysieren. <br><br>  Beginnen wir mit den Interna und Implementierungsdetails und betrachten gleichzeitig einfache Codefragmente.  Danach wird klar, wie es funktioniert und wie es verwendet werden sollte.  Bei der Arbeit mit System.IO.Pipelines ist zu beachten, dass das Grundkonzept darin besteht, dass alle Lese- / Schreibvorgänge ohne zusätzliche Zuordnungen erfolgen sollten.  Einige auf den ersten Blick attraktive Methoden widersprechen dieser Regel.  Dementsprechend beginnt der Code, den Sie so stark beschleunigen möchten, Speicher für neue und neue Daten zuzuweisen, wodurch der Garbage Collector geladen wird. <br><br>  Die Interna der Bibliothek nutzen die umfangreichsten Möglichkeiten der neuesten Versionen der Sprache und Laufzeit - Span, Memory, Objektpools, ValueTask usw.  Es lohnt sich, dort zumindest nach einem großartigen Beispiel für die Verwendung dieser Funktionen in der Produktion zu suchen. <br><br>  Zu einer Zeit waren einige Entwickler mit der Implementierung von Streams in C # nicht zufrieden, da eine Klasse sowohl zum Lesen als auch zum Schreiben verwendet wurde.  Aber wie sie sagen, können Sie keine Methoden aus einer Klasse werfen.  Auch wenn der Stream das Lesen / Schreiben / Suchen nicht unterstützt, werden die Eigenschaften CanRead, CanWrite und CanSeek verwendet.  Es sieht aus wie eine kleine Krücke.  Aber jetzt werden die Dinge anders. <br><br>  Für die Arbeit mit Pipelines werden zwei Klassen verwendet: <a href="">PipeWriter</a> und <a href="">PipeReader</a> .  Diese Klassen enthalten ungefähr 50 Codezeilen und sind Pseudofassaden (nicht die klassischste ihrer Inkarnationen, da sie eine einzelne Klasse verbergen, nicht viel) für die Klasse <a href="">Pipe</a> , die die gesamte grundlegende Logik für die Arbeit mit Daten enthält.  Diese Klasse enthält 5 öffentliche Mitglieder: 2 Konstruktoren, 2 Nur-Get-Eigenschaften - Reader und Writer, die Reset () -Methode, die interne Felder auf ihren Ausgangszustand zurücksetzt, damit die Klasse wiederverwendet werden kann.  Die übrigen Arbeitsmethoden sind intern und werden über Pseudofassaden aufgerufen. <br><br><h2>  Beginnen wir mit der Pipe-Klasse </h2><br>  Die Klasseninstanz belegt 320 Bytes, was ziemlich viel ist (fast ein Drittel eines Kilobytes, 2 solcher Objekte konnten nicht in den Speicher von Manchester Mark I passen).  Daher ist es eine schlechte Idee, eine große Menge seiner Instanzen zuzuweisen.  Darüber hinaus ist das Objekt für den Langzeitgebrauch vorgesehen.  Die Verwendung von Pools liefert auch ein Argument für diese Aussage.  Die im Pool verwendeten Objekte bleiben für immer erhalten (für die Standard-Pool-Implementierung). <br>  Beachten Sie, dass die Klasse als versiegelt markiert und threadsicher ist - viele Abschnitte des Codes sind ein kritischer Abschnitt und in Sperren eingeschlossen. <br><br>  Um diese Klasse zu verwenden, sollten Sie eine Instanz der Pipe-Klasse erstellen und die Objekte PipeReader und PipeWriter mit den genannten Eigenschaften abrufen. <br><br><div class="spoiler">  <b class="spoiler_title">Einfache Initialisierung</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Betrachten Sie die Methoden zum Arbeiten mit Rohren: <br>  Schreiben mit PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br><br>  Lesen mit PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erwähnten Beitrag angegeben</a> , verwendet die Klasse eine einfach verknüpfte Liste von Puffern.  Offensichtlich werden sie jedoch nicht zwischen PipeReader und PipeWriter übertragen - die gesamte Logik befindet sich in einer Klasse.  Diese Liste wird sowohl zum Lesen als auch zum Schreiben verwendet.  Darüber hinaus werden die zurückgegebenen Daten in dieser Liste gespeichert (daher wird kein Kopieren durchgeführt). <br><br>  Es gibt auch Objekte, die den Beginn der zu lesenden Daten (ReadHead und Index), das Ende der zu lesenden Daten (ReadTail und Index) und den Beginn des zu schreibenden Speicherplatzes (WriteHead und die Anzahl der geschriebenen gepufferten Bytes) angeben.  Hier sind ReadHead, ReadTail und WriteHead bestimmte Elemente (Segmente) der internen Liste von Segmenten, und der Index gibt eine bestimmte Position innerhalb des Segments an.  Somit kann die Aufzeichnung von der Mitte eines Segments aus beginnen, ein ganzes nächstes Segment erfassen und in der Mitte des dritten Segments enden.  Diese Zeiger werden auf verschiedene Arten verschoben. <br><br><h2>  Erste Schritte mit PipeWriter-Methoden </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (ReadOnlyMemory &lt;Byte&gt; -Quelle, CancellationToken CancellationToken)</a> </h3><br>  Das wird auf den ersten Blick als attraktiv bezeichnet.  Es hat eine sehr geeignete und modische Signatur - akzeptiert ReadOnlyMemory, asynchron.  Und viele mögen versucht sein, sich besonders daran zu erinnern, dass Span und Memory so schnell und cool sind.  Aber schmeichel dir nicht.  Diese Methode kopiert lediglich das an sie übergebene ReadOnlyMemory in die interne Liste.  Mit "Kopieren" ist ein Aufruf der CopyTo () -Methode gemeint, bei dem nicht nur das Objekt selbst kopiert wird.  Alle Daten, die wir aufzeichnen möchten, werden kopiert, wodurch der Speicher geladen wird.  Diese Methode sollte nur erwähnt werden, um sicherzustellen, dass es besser ist, sie nicht zu verwenden.  Nun, und vielleicht für einige seltene Situationen ist dieses Verhalten angemessen. <br>  Der Hauptteil der Methode ist ein kritischer Abschnitt. Der Zugriff darauf wird über einen Monitor synchronisiert. <br><br>  Dann kann sich die Frage stellen, wie man etwas schreibt, wenn nicht mit der naheliegendsten und einzig geeigneten Methode <br><br><h3>  # 2 <a href="">Speicher &lt;Byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Die Methode verwendet einen Parameter eines Integer-Typs.  Darin müssen wir angeben, wie viele Bytes wir in die Pipeline schreiben möchten (welche Größe des Puffers wir wollen).  Diese Methode prüft, ob in dem in _writingHeadMemory gespeicherten aktuellen Speicherfragment genügend Speicherplatz zum Schreiben vorhanden ist.  Wenn dies ausreicht, wird _writingHeadMemory als Speicher zurückgegeben.  Andernfalls wird für die in den Puffer geschriebenen Daten, für die die FlushAsync-Methode nicht aufgerufen wurde, ein anderes BufferSegment aufgerufen, das mit dem vorherigen verbunden ist (hier ist unsere interne Liste).  Wenn _writingHeadMemory null ist, wird es mit einem neuen BufferSegment initialisiert.  Die Zuweisung des Puffers ist ein kritischer Abschnitt und erfolgt unter Verriegelung. <br><br>  Ich schlage vor, ein solches Beispiel anzuschauen.  Auf den ersten Blick scheint es, dass der Compiler (oder die Laufzeit) den Dämon verführt hat. <br><br><div class="spoiler">  <b class="spoiler_title">Teufelei</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Aber alles in diesem Beispiel ist verständlich und einfach. <br>  Beim Erstellen einer Pipe-Instanz können wir das <a href="">PipeOptions-</a> Objekt im Konstruktor mit Optionen zum Erstellen übergeben. <br><br>  PipeOptions verfügt über ein Standardfeld für die minimale Segmentgröße.  Vor nicht allzu langer Zeit war es 2048, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Commit</a> hat diesen Wert auf 4096 aktualisiert. Zum Zeitpunkt des Schreibens dieses Artikels befand sich die 4096-Version im Nuget-Paket vor der Veröffentlichung, die letzte Release-Version hatte einen Wert von 2048. Dies erklärt den Verhalten des ersten Beispiels.  Wenn Sie eine kleinere Größe für den Standardpuffer verwenden möchten, können Sie diese in einer Instanz des Typs PipeOptions angeben. <br><br>  Im zweiten Beispiel, in dem die Mindestgröße angegeben ist, stimmt die Länge ohnehin nicht überein.  Dies geschieht, weil die Erstellung eines neuen BufferSegments mithilfe von Pools erfolgt.  Eine der Optionen in PipeOptions ist der Speicherpool.  Danach wird der angegebene Pool verwendet, um ein neues Segment zu erstellen.  Wenn Sie keinen Speicherpool angegeben haben, wird der Standard-ArrayPool verwendet, der, wie Sie wissen, mehrere Buckets für Arrays unterschiedlicher Größe enthält (jeder nächste ist zweimal größer als der vorherige) und wenn er für einen bestimmten angefordert wird Größe sucht es nach einem Eimer mit Arrays geeigneter Größe (dh dem nächstgrößeren oder gleich großen).  Dementsprechend ist der neue Puffer mit ziemlicher Sicherheit größer als von Ihnen angefordert.  Die minimale Arraygröße im Standard-ArrayPool (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) beträgt 16. Aber keine Sorge, dies ist ein Pool von Arrays.  Dementsprechend übt das Array in den allermeisten Fällen keinen Druck auf den Garbage Collector aus und wird später wiederverwendet. <br><br><h3>  # 2.5 <a href="">Span &lt;Byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Es funktioniert ähnlich und gibt Span from Memory. <br><br>  Daher sind GetMemory () oder GetSpan () die Hauptmethoden zum Schreiben.  Sie geben uns ein Objekt, an das wir schreiben können.  Dazu müssen wir keinen Speicher für neue Arrays von Werten zuweisen, sondern können direkt in die Pipe schreiben.  Welche verwendet werden soll, hängt hauptsächlich von der verwendeten API und der Methodenasynchronität ab.  In Anbetracht des Vorstehenden stellt sich jedoch eine Frage.  Woher weiß der Leser, wie viel wir geschrieben haben?  Wenn wir immer eine bestimmte Implementierung des Pools verwenden würden, die ein Array mit genau der gewünschten Größe ergibt, könnte der Leser den gesamten Puffer auf einmal lesen.  Wie wir bereits gesagt haben, wird uns jedoch ein Puffer mit einer hohen Wahrscheinlichkeit einer größeren Größe zugewiesen.  Dies führt zu der folgenden für den Betrieb erforderlichen Methode. <br><br><h3>  # 3 <a href="">void Advance (int Bytes)</a> </h3><br>  Eine schrecklich einfache Methode.  Es wird die Anzahl der als Argument geschriebenen Bytes verwendet.  Sie erhöhen die internen Zähler - _unflushedBytes und _writingHeadBytesBuffered, deren Namen für sich selbst sprechen.  Außerdem wird _writingHeadMemory genau auf die Anzahl der geschriebenen Bytes gekürzt (Slices) (mithilfe der Slice-Methode).  Daher müssen Sie nach dem Aufrufen dieser Methode einen neuen Speicherblock in Form von Memory oder Span anfordern. Sie können nicht in den vorherigen schreiben.  Und der gesamte Körper der Methode ist ein kritischer Abschnitt und läuft unter einem Schloss. <br><br>  Es scheint, dass der Leser danach Daten empfangen kann.  Es ist jedoch noch ein Schritt erforderlich. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken CancellationToken)</a> </h3><br>  Die Methode wird aufgerufen, nachdem wir die erforderlichen Daten in den empfangenen Speicher (GetMemory) geschrieben und angegeben haben, wie viel wir dort geschrieben haben (Advance).  Die Methode gibt ValueTask zurück, ist jedoch nicht asynchron (im Gegensatz zu ihrem Nachkommen StreamPipeWriter).  ValueTask ist ein spezieller Typ (schreibgeschützte Struktur), der verwendet wird, wenn die meisten Aufrufe nicht asynchron sind. Das heißt, alle erforderlichen Daten sind zum Zeitpunkt des Aufrufs verfügbar und die Methode wird synchron beendet.  In sich selbst enthält es entweder Daten oder Task (falls es nicht synchron funktioniert hat).  Dies hängt von der Eigenschaft _writerAwaitable.IsCompleted ab.  Wenn wir nach Änderungen am Status dieses _writerAwaitable suchen, werden wir feststellen, dass dies geschieht, wenn die Menge der nicht verbrauchten Daten (dies ist nicht genau die gleiche wie die später untersuchten nicht erläuterten Daten) einen bestimmten Schwellenwert überschreitet (_pauseWriterThreshold).  Der Standardwert ist 16 Segmentgrößen.  Falls gewünscht, kann der Wert in PipeOptions geändert werden.  Diese Methode startet auch die Fortsetzung der ReadAsync-Methode, falls eine blockiert wurde. <br><br>  Gibt ein FlushResult zurück, das zwei Eigenschaften enthält - IsCanceled und IsCompleted.  IsCanceled gibt an, ob Flush abgebrochen wurde (CancelPendingFlush () -Aufruf).  IsCompleted gibt an, ob der PipeReader abgeschlossen wurde (durch Aufrufen der Methoden Complete () oder CompleteAsync ()). <br>  Der Hauptteil der Methode wird unter dem Schloss ausgeführt. <br><br>  Andere Methoden von PipeWriter sind aus Sicht der Implementierung nicht interessant und werden viel seltener verwendet, daher wird nur eine kurze Beschreibung gegeben. <br><br><h3>  # 5 void Complete (Ausnahme Ausnahme = null) oder ValueTask CompleteAsync (Ausnahme Ausnahme = null) </h3><br>  Markiert das zum Schreiben geschlossene Rohr.  Eine Ausnahme wird ausgelöst, wenn versucht wird, die Schreibmethoden nach Abschluss zu verwenden.  Wenn PipeReader bereits abgeschlossen wurde, wird auch die gesamte Pipe-Instanz abgeschlossen.  Die meiste Arbeit wird unter dem Schloss erledigt. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Wie der Name schon sagt, wird die aktuelle FlushAsync () -Operation abgebrochen.  Es gibt ein Schloss. <br><br><h3>  # 7 void OnReaderCompleted (Aktion &lt;Ausnahme, Objekt&gt; Rückruf, Objektstatus) </h3><br>  Führt den übergebenen Delegaten aus, wenn der Reader abgeschlossen ist.  Es gibt auch ein Schloss. <br>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> wird derzeit geschrieben, dass diese Methode bei einigen PipeWriter-Implementierungen möglicherweise nicht aufgerufen wird und in Zukunft entfernt wird.  Daher sollten Sie keine Logik an diese Methoden binden. <br><br><h2>  Es ist Zeit für PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (CancellationToken-Token)</a> </h3><br>  Hier wird wie in FlushAsync () ValueTask zurückgegeben, was darauf hindeutet, dass die Methode größtenteils synchron ist, aber nicht immer.  Hängt vom Status von _readerAwaitable ab.  Wie bei FlushAsync müssen Sie feststellen, wann _readerAwaitable auf unvollständig gesetzt ist.  Dies geschieht, wenn PipeReader alles aus der internen Liste gelesen hat (oder Daten enthält, die als geprüft markiert wurden und Sie weitere Daten benötigen, um fortzufahren).  Was in der Tat offensichtlich ist.  Dementsprechend können wir den Schluss ziehen, dass es wünschenswert ist, Pipe genau auf Ihre Arbeit abzustimmen und alle Optionen sorgfältig auf der Grundlage empirisch identifizierter Statistiken festzulegen.  Durch eine ordnungsgemäße Konfiguration wird die Wahrscheinlichkeit eines asynchronen Ausführungszweigs verringert und eine effizientere Datenverarbeitung ermöglicht.  Fast der gesamte Code in der gesamten Methode ist von einer Sperre umgeben. <br><br>  Gibt ein mysteriöses <a href="">ReadResult zurück</a> .  Tatsächlich ist es nur ein Puffer + Flags, der den Status des Vorgangs anzeigt (IsCanceled - ob ReadAsync abgebrochen wurde und IsCompleted angibt, ob der PipeWriter geschlossen wurde).  IsCompleted ist ein Wert, der angibt, ob die Methoden PipeWriter Complete () oder CompleteAsync () aufgerufen wurden.  Wenn diese Methoden mit einer übergebenen Ausnahme aufgerufen wurden, wird sie beim Versuch des Lesens ausgelöst. <br><br>  Und wieder hat der Puffer einen mysteriösen Typ - <a href="">ReadOnlySequence</a> .  Dies ist wiederum das Objekt für den Inhalt von Segmenten <a href="">(ReadOnlySequenceSegment)</a> des Anfangs- und des End + Start- und Endindex innerhalb der entsprechenden Segmente.  Was eigentlich der Struktur der Pipe-Klasse selbst ähnelt.  BufferSegment wird übrigens von ReadOnlySequenceSegment geerbt, was darauf hindeutet, dass BufferSegment in dieser Sequenz verwendet wird.  Dank dieser Funktion können Sie unnötige Speicherzuweisungen für die Datenübertragung vom Schreiber zum Leser vermeiden. <br>  ReadOnlySpan kann zur weiteren Verarbeitung aus dem Puffer abgerufen werden.  Um das Bild zu vervollständigen, können Sie überprüfen, ob der Puffer einen einzelnen ReadOnlySpan enthält.  Wenn es enthält, müssen wir die Auflistung nicht von einem Element aus durchlaufen, und wir können sie mit der First-Eigenschaft abrufen.  Andernfalls müssen alle Segmente im Puffer überprüft und jeweils ReadOnlySpan verarbeitet werden. <br><br>  Diskussionsthema - in der ReadOnlySequence-Klasse werden nullfähige Referenztypen aktiv verwendet und es gibt goto (nicht für die Verschachtelung tiefer Schleifen und nicht im generierten Code) - insbesondere <a href="">hier</a> . <br><br>  Nach der Verarbeitung müssen Sie der Pipe-Instanz signalisieren, dass wir die Daten gelesen haben. <br><br><h3>  # 2 <a href="">bool TryRead (Ergebnis von ReadResult)</a> </h3><br>  Synchrone Version.  Ermöglicht das Abrufen des Ergebnisses, falls vorhanden.  Andernfalls wird im Gegensatz zu ReadAsync nicht blockiert und false zurückgegeben.  Auch der Code dieser Methode befindet sich im Schloss. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition verbraucht, SequencePosition untersucht)</a> </h3><br>  Bei dieser Methode können Sie angeben, wie viele Bytes wir untersuchen und verbrauchen.  Daten, die untersucht, aber nicht verbraucht wurden, werden beim nächsten Lesen zurückgegeben.  Diese Funktion mag auf den ersten Blick seltsam erscheinen, aber bei der Verarbeitung eines Bytestroms ist es selten erforderlich, jedes Byte einzeln zu verarbeiten.  Normalerweise werden Daten mithilfe von Nachrichten ausgetauscht.  Es kann vorkommen, dass der Leser beim Lesen eine ganze Nachricht und einen Teil der zweiten Nachricht erhalten hat.  Das Ganze muss verarbeitet werden, und ein Teil des zweiten sollte für die Zukunft übrig bleiben, damit er mit dem verbleibenden Teil einhergeht.  Die AdvanceTo-Methode verwendet eine SequencePosition, bei der es sich tatsächlich um ein Segment + Index handelt.  Wenn Sie alles verarbeiten, was ReadAsync gelesen hat, können Sie buffer.End angeben.  Andernfalls müssen Sie explizit eine Position erstellen, die das Segment und den Index angibt, an dem die Verarbeitung gestoppt wurde.  Schloss ist unter der Haube. <br>  Wenn die Menge der nicht verbrauchten Informationen unter dem angegebenen Schwellenwert (_resumeWriterThreshold) liegt, wird die Fortsetzung von PipeWriter gestartet, wenn diese blockiert wurde.  Standardmäßig beträgt dieser Schwellenwert 8 Segmentvolumes (die Hälfte des Blockierungsschwellenwerts). <br><br><h3>  # 4 void Complete (Ausnahme Ausnahme = null) </h3><br>  Vervollständigt den PipeReader.  Wenn der PipeWriter zu diesem Zeitpunkt abgeschlossen ist, wird die gesamte Pipe-Instanz abgeschlossen.  Innen verschließen. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Ermöglicht das Abbrechen des derzeit ausstehenden Messwerts.  Sperren <br><br><h3>  # 6 void OnWriterCompleted (Aktion &lt;Ausnahme, Objekt&gt; Rückruf, Objektstatus) </h3><br>  Hier können Sie den Delegaten angeben, der nach Abschluss des PipeWriter ausgeführt werden soll. <br>  Wie bei der ähnlichen Methode von PipeWriter gibt es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> dasselbe Tag, das entfernt wird.  Schloss ist unter der Haube. <br><br><h2>  Beispiel </h2><br>  Die folgende Auflistung zeigt ein Beispiel für die Arbeit mit Rohren. <br>  Seit der Einführung von .NET Core Span und Memory wurden viele Klassen für die Arbeit mit Daten durch Überladungen mit diesen Typen ergänzt.  Das allgemeine Interaktionsschema ist also ungefähr das gleiche.  In meinem Beispiel habe ich Pipelines verwendet, um mit Pipes zu arbeiten (ich mag ähnliche Wörter) - Betriebssystemobjekte für die Interprozesskommunikation.  Die Pipes-API wurde gerade entsprechend erweitert, um Daten in Span und Memory zu lesen.  Die asynchrone Version verwendet Speicher, da die asynchrone Methode mithilfe einer automatisch generierten Finite-State-Maschine, in der alle lokalen Variablen und Methodenparameter gespeichert sind, in eine Vorlagenmethode konvertiert wird. Da Span ref readonly struct ist, kann sie nicht platziert werden Der Heap, der Span in einer asynchronen Methode verwendet, ist nicht möglich.  Es gibt aber auch eine synchrone Version der Methode, mit der Sie Span verwenden können.  In meinem Beispiel habe ich beide ausprobiert und es stellte sich heraus, dass sich die synchrone Version in dieser Situation besser zeigt.  Bei Verwendung wird weniger Speicherbereinigung durchgeführt und die Datenverarbeitung ist schneller.  Dies lag jedoch nur daran, dass sich viele Daten in der Pipe befanden (die Daten waren immer verfügbar).  In der Situation, in der es zum Zeitpunkt der Beantragung des nächsten Stapels wahrscheinlich keine Daten gibt, sollten Sie die asynchrone Version verwenden, um den Prozessorleerlauf nicht zu belasten. <br>  Das Beispiel enthält Kommentare, die einige Punkte erläutern.  Ich mache Sie darauf aufmerksam, dass trotz der Tatsache, dass die Fragmente des Programms, die für das Lesen aus der Pipe und die Verarbeitung verantwortlich sind, beim Schreiben in eine Datei getrennt werden, die Daten genau von der Stelle gelesen werden, an der sie beim Lesen von der geschrieben wurden Rohr. <br><br><div class="spoiler">  <b class="spoiler_title">Jahre der Evolution für eine leistungsstarke Funktion - asynchrone Hauptleitung</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprozessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466137/">https://habr.com/ru/post/de466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466121/index.html">Klangerzeugung auf AVR-Mikrocontrollern mithilfe der Wavetable-Methode mit Polyphonieunterstützung</a></li>
<li><a href="../de466123/index.html">Wachstum. Gewicht. Drei Nachbarn</a></li>
<li><a href="../de466127/index.html">KKW Kola oder am Reaktor stehen</a></li>
<li><a href="../de466129/index.html">Effizienz des Transports mit Benzin, Batterien und Wasserstoff</a></li>
<li><a href="../de466135/index.html">Megapack: Wie Factorio-Entwickler es geschafft haben, das 200-Spieler-Multiplayer-Problem zu lösen</a></li>
<li><a href="../de466139/index.html">Angewandte Technologie auf den Ruinen des Blockchain-Fiebers oder den praktischen Vorteilen der Ressourcenzuweisung</a></li>
<li><a href="../de466143/index.html">Wie haben wir Kartoncode oder die Scratch-Version des Brettspiels Golem Battle erstellt?</a></li>
<li><a href="../de466147/index.html">Reactive Data Display Manager. Einführung</a></li>
<li><a href="../de466149/index.html">Erstellen eines Konnektorsymbols mit „dynamischem“ Text in OrCAD</a></li>
<li><a href="../de466151/index.html">Untersuchung: seltsame Programme im Register der inländischen Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>