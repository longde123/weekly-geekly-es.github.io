<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏼 👨‍🏭 👩🏽‍🏫 Guía de Kubernetes, Parte 2: Crear y trabajar con un clúster 💦 🛰️ 🧕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La última vez, examinamos dos enfoques para trabajar con microservicios. En particular, uno de ellos implica el uso de contenedores Docker, en los que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guía de Kubernetes, Parte 2: Crear y trabajar con un clúster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438984/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La última</a> vez, examinamos dos enfoques para trabajar con microservicios.  En particular, uno de ellos implica el uso de contenedores Docker, en los que puede ejecutar el código de microservicios y programas auxiliares.  Hoy, utilizando nuestras imágenes de contenedor existentes, trabajaremos con Kubernetes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/13/lv/dr/13lvdrwhhap-ouchegvweul0fg0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Introduciendo Kubernetes</font> </h2><br>  Lo prometo, y no exagero en absoluto cuando lees este artículo, pregúntate: "¿Por qué Kubernetes no se llama Supernetes?" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9f9/e76/d769f9e7670a725759dd7415949177a0.png"></div><br>  <i><font color="#999999">Supernetes</font></i> <br><br>  Si leyó la parte anterior de este material, sabrá que allí analizamos muchas cosas relacionadas con la preparación de aplicaciones para la contenedorización y el trabajo con contenedores Docker.  Puede parecerle que lo más difícil le espera ahora, pero, de hecho, de lo que vamos a hablar aquí es mucho más simple de lo que ya hemos descubierto.  La única razón por la que aprender Kubernetes puede parecer una tarea desalentadora para alguien es la cantidad de información adicional que necesita para comprender a Kubernetes y usarlo de manera efectiva.  Ya hemos discutido toda la "información adicional" necesaria para el desarrollo exitoso de Kubernetes. <br><br><h3>  <font color="#3AC1EF">▍¿Qué es Kubernetes?</font> </h3><br>  En la primera parte de este artículo, después de lanzar microservicios en contenedores, se le pidió que pensara sobre el tema de escalar aplicaciones en contenedores. <br>  Sugiero reflexionar sobre esto juntos, en el formato de preguntas y respuestas: <br><br>  <b>Pregunta:</b> ¿Cómo se escalan las aplicaciones en contenedores? <br>  <b>Respuesta:</b> Inicie contenedores adicionales. <br><br>  <b>Pregunta:</b> ¿Y cómo se distribuye la carga entre ellos?  ¿Qué sucede si un determinado servidor ya se utiliza al máximo y el contenedor debe implementarse en otro servidor?  ¿Cómo encontrar la forma más eficiente de usar hardware? <br>  <b>Respuesta:</b> Entonces ... buscaré en Internet ... <br><br>  <b>Pregunta:</b> ¿Cómo actualizar programas sin interrumpir el sistema?  Y, si la actualización contiene un error, ¿cómo volver a la versión de trabajo de la aplicación? <br><br>  De hecho, es la tecnología de Kubernetes la que da respuestas dignas a estas y muchas otras preguntas.  Trataré de reducir la definición de Kubernetes a una oración: "Kubernetes es un sistema de gestión de contenedores que abstrae la infraestructura subyacente (el entorno en el que se ejecutan los contenedores)". <br><br>  Creo que ahora no tiene muy claro el concepto de "gestión de contenedores", aunque ya lo hemos mencionado.  A continuación consideraremos esta tecnología en la práctica.  Sin embargo, el concepto de "abstraer la infraestructura básica" se encuentra por primera vez.  Por lo tanto, ahora lo consideraremos. <br><br><h3>  <font color="#3AC1EF">▍Abstracción de infraestructura básica</font> </h3><br>  Kubernetes permite que las aplicaciones se alejen de la infraestructura, brindándonos una API simple a la que puede enviar solicitudes.  Kubernetes intenta cumplir con estas solicitudes utilizando todas sus capacidades.  Por ejemplo, en un lenguaje normal, una solicitud similar se puede describir de la siguiente manera: "Kubernetes, expanda 4 contenedores de imágenes X".  Después de recibir el comando, Kubernetes encontrará nodos que no estén demasiado ocupados (también se denominan "nodos", del "nodo" en inglés), en los que puede implementar nuevos contenedores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/735/b88/a2a/735b88a2a717e9c01bfc197f3c1b20fd.png"></div><br>  <i><font color="#999999">Solicitud del servidor API</font></i> <br><br>  ¿Qué significa esto para el desarrollador?  Esto significa que no necesita preocuparse por la cantidad de nodos, por dónde exactamente se lanzan los contenedores o cómo interactúan.  No tiene que lidiar con la optimización del hardware o preocuparse por los nodos que podrían estar funcionando mal (y algo similar, de acuerdo con la ley de Murphy, ciertamente sucederá), ya que, si es necesario, se pueden agregar nuevos nodos al clúster de Kubernetes.  Si algo está mal con algunos nodos existentes, Kubernetes desplegará contenedores en aquellos nodos que todavía están en buen estado. <br><br>  Gran parte de lo que se muestra en la figura anterior ya le es familiar.  Pero también hay algo nuevo: <br><br><ul><li>  Servidor API  Hacer llamadas a este servidor es la única forma de interactuar con el clúster que tenemos, ya sea que estemos hablando de iniciar o detener contenedores, verificar el estado del sistema, trabajar con registros o realizar otras acciones. </li><li>  Kubelet  Este es un agente que monitorea los contenedores dentro del nodo e interactúa con el nodo principal. </li></ul><br>  Tenga en cuenta que en un par de oraciones anteriores usamos el término "contenedor", pero aquí sería más correcto usar el término "pod".  Estas entidades a menudo se llaman "pods" en las publicaciones en idioma ruso, y algunas veces "pods", en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> , aclarando el concepto de "pod", hablan de una "bandada de ballenas" (pod of whales) o "pea pod" pero nadie los llama "bandadas" o "vainas".  Hablando de ellos, usaremos la palabra "debajo".  Ahora puede considerarlos contenedores, hablaremos más sobre las vainas a continuación. <br><br>  Nos detendremos en esto por ahora, ya que podemos hablar de todo esto más adelante, y, además, hay muchos buenos materiales sobre la teoría de Kubernetes.  Por ejemplo, esta es documentación oficial, aunque no es fácil de leer, o libros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> . <br><br><h3>  <font color="#3AC1EF">▍ Estandarización del trabajo con proveedores de servicios en la nube</font> </h3><br>  Otra fortaleza de Kubernetes radica en el hecho de que esta tecnología contribuye a la estandarización del trabajo con proveedores de servicios en la nube (Cloud Service Provider, CSP).  Esta es una declaración audaz.  Considere el siguiente ejemplo.  Un especialista que conoce bien Azure o Google Cloud Platform tiene que trabajar en un proyecto diseñado para un entorno en la nube completamente nuevo para él, con el que no está familiarizado.  En esta situación, muchas cosas pueden salir mal.  Por ejemplo, los plazos para la entrega del proyecto pueden retrasarse, la empresa cliente del proyecto puede necesitar alquilar más recursos en la nube de lo planeado, y así sucesivamente. <br><br>  Al usar Kubernetes, tal problema simplemente no puede surgir, ya que, independientemente del proveedor de servicios en la nube en particular del que estamos hablando, trabajar con Kubernetes siempre se ve igual.  El desarrollador, en un estilo declarativo, le dice al servidor API lo que necesita, y Kubernetes trabaja con los recursos del sistema, lo que le permite ignorar los detalles de la implementación de este sistema. <br><br>  Deténgase un poco en esta idea, ya que esta es una oportunidad muy poderosa de Kubernetes.  Para las empresas, esto significa que sus decisiones no están vinculadas a un CSP específico.  Si una empresa encuentra una mejor oferta en el mercado de servicios en la nube, puede aprovechar esta oferta libremente al cambiar a un nuevo proveedor.  Además, la experiencia adquirida por los especialistas de la compañía no se pierde en ningún lado. <br><br>  Ahora hablemos sobre el uso práctico de Kubernetes <br><br><h2>  <font color="#3AC1EF">Práctica de Kubernetes: vainas</font> </h2><br>  Configuramos el lanzamiento de microservicios en contenedores, el proceso de configuración fue bastante tedioso, pero logramos llegar a un sistema que funcionara.  Además, como ya se mencionó, nuestra solución no escala bien y no es resistente a fallas.  Resolveremos estos problemas con Kubernetes.  A continuación, llevaremos nuestro sistema a un formulario correspondiente al siguiente esquema.  A saber, los contenedores serán gestionados por Kubernetes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br>  <i><font color="#999999">Los microservicios funcionan en un clúster gestionado por Kubernetes</font></i> <br><br>  Aquí, utilizaremos Minikube para la implementación local del clúster y para probar las capacidades de Kubernetes, aunque todo lo que haremos aquí se puede hacer utilizando plataformas en la nube como Azure o Google Cloud Platform. <br><br><h3>  <font color="#3AC1EF">▍Instalación e inicio de Minikube</font> </h3><br>  Para instalar Minikube, siga las instrucciones que se encuentran en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> .  Durante la instalación de Minikube, también instalará Kubectl.  Este es un cliente que permite realizar solicitudes al servidor API de Kubernetes. <br><br>  Para iniciar Minikube, ejecute el <code>minikube start</code> y, una vez que se complete, ejecute el <code>kubectl get nodes</code> .  Como resultado, debería ver algo como lo siguiente: <br><br><pre> <code class="plaintext hljs">kubectl get nodes NAME       STATUS ROLES     AGE VERSION minikube   Ready &lt;none&gt;    11m v1.9.0</code> </pre> <br>  Minikube pone a nuestra disposición un clúster que consta de un solo nodo.  Es cierto, esto nos queda bastante bien.  Aquellos que trabajan con Kubernetes no necesitan preocuparse exactamente por cuántos nodos hay en el clúster, ya que Kubernetes le permite abstraerse de dichos detalles. <br><br>  Ahora hablemos de las vainas. <br><br><h3>  <font color="#3AC1EF">▍Pods</font> </h3><br>  Realmente me gustan los contenedores, y probablemente también te gusten ahora.  ¿Por qué Kubernetes nos ofrece utilizar pods, entidades que son las unidades informáticas mínimas desplegables en este sistema?  ¿Bajo qué funciones realiza?  El hecho es que el hogar puede incluir uno o más contenedores que comparten el mismo tiempo de ejecución. <br><br>  Pero, ¿es necesario llevar a cabo, por ejemplo, dos contenedores en un hogar?  Cómo decirlo ... Por lo general, solo hay un contenedor por contenedor, y eso es lo que vamos a hacer.  Pero para aquellos casos en los que, por ejemplo, dos contenedores necesitan acceso compartido al mismo almacén de datos, o si están conectados mediante la técnica de comunicación entre procesos, o si están estrechamente conectados por alguna otra razón, todo esto puede realizarse ejecutándolos en un hogar.  Otra posibilidad en la que las cápsulas difieren es que no tienen que usar contenedores Docker.  Si es necesario, aquí puede aplicar otras tecnologías para la contenedorización de aplicaciones, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rkt</a> . <br><br>  El siguiente diagrama muestra las propiedades de hogar numeradas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f6/2a4/bb1/4f62a4bb18bddccc49a9d224a4aa919d.png"></div><br>  <i><font color="#999999">Propiedades del hogar</font></i> <br><br>  Considere estas propiedades. <br><br><ol><li>  Cada pod en un clúster de Kubernetes tiene una dirección IP única. </li><li>  Un hogar puede contener muchos recipientes.  Comparten los números de puerto disponibles, es decir, pueden intercambiar información entre ellos a través de <code>localhost</code> (naturalmente, no pueden usar los mismos puertos).  La interacción con los contenedores ubicados en otros pods se organiza utilizando las direcciones IP de estos pods. </li><li>  Los contenedores en pods comparten volúmenes de almacenamiento de datos, dirección IP, números de puerto, espacio de nombres IPC. </li></ol><br>  Cabe señalar que los contenedores tienen sus propios sistemas de archivos aislados, pero pueden compartir datos utilizando el recurso de Kubernetes llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Volumen</a> . <br><br>  Para nosotros, lo que ya se ha dicho sobre los hogares es suficiente para seguir dominando los Kubernetes.  Lea más sobre ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><h3>  <font color="#3AC1EF">▍ Descripción del hogar</font> </h3><br>  El siguiente es un archivo de manifiesto para la aplicación <code>sa-frontend</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                            # 1 metadata: name: sa-frontend                                  # 2 spec:                                                # 3 containers:   - image: rinormaloku/sentiment-analysis-frontend # 4     name: sa-frontend                              # 5     ports:       - containerPort: 80</code> </pre> <br>  Vamos a explicar algunos de los parámetros especificados en él. <br><br><ol><li>  <code>Kind</code> : especifica el tipo de recurso de Kubernetes que queremos crear.  En nuestro caso, este es <code>Pod</code> . </li><li>  <code>Name</code> : nombre del recurso.  Lo llamamos <code>sa-frontend</code> . </li><li>  <code>Spec</code> : un objeto que describe el estado deseado del recurso.  La propiedad más importante aquí es la variedad de contenedores. </li><li>  <code>Image</code> : la imagen del contenedor que queremos ejecutar en este pod. </li><li>  <code>Name</code> : un nombre único para el contenedor debajo. </li><li>  <code>ContainerPort</code> : el puerto en el que el contenedor está escuchando.  Este parámetro puede considerarse una indicación para quién lee este archivo (si omite este parámetro, esto no limitará el acceso al puerto). </li></ol><br><h3>  <font color="#3AC1EF">▍Creando un hogar SA-Frontend</font> </h3><br>  El archivo de descripción del pod del que hablamos se puede encontrar en <code>resource-manifests/sa-frontend-pod.yaml</code> .  Debe ir a esta carpeta utilizando las herramientas del terminal o, cuando llame al comando apropiado, especifique la ruta completa al archivo.  Aquí está este comando y un ejemplo de una reacción del sistema: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod.yaml pod "sa-frontend" created</code> </pre> <br>  Para saber si funciona bajo, ejecute el siguiente comando: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s</code> </pre> <br>  Si el estado del hogar durante la ejecución de este comando es <code>ContainerCreating</code> , puede ejecutar el mismo comando con el <code>--watch</code> .  Debido a esto, cuando el hogar está en el estado En <code>Running</code> , la información sobre esto se mostrará automáticamente. <br><br><h3>  <font color="#3AC1EF">▍Acceso a la aplicación desde el exterior</font> </h3><br>  Para organizar el acceso a la aplicación desde el exterior, será correcto crear un recurso Kubernetes del tipo de Servicio, del que hablaremos a continuación, pero aquí, por brevedad, utilizaremos un reenvío de puertos simple: <br><br><pre> <code class="plaintext hljs">kubectl port-forward sa-frontend 88:80 Forwarding from 127.0.0.1:88 -&gt; 80</code> </pre> <br>  Si ahora utiliza un navegador en <code>127.0.0.1:88</code> , puede ver la página de la aplicación React. <br><br><h3>  <font color="#3AC1EF">Approach Enfoque de escala incorrecto</font> </h3><br>  Ya hemos dicho que una de las capacidades de Kubernetes es el escalado de aplicaciones.  Para experimentar esta oportunidad, ejecutaremos otra debajo.  Cree una descripción de otro recurso <code>Pod</code> colocando el siguiente código en el archivo <code>sa-frontend-pod2.yaml</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                           metadata: name: sa-frontend2      #   spec:                                                containers:   - image: rinormaloku/sentiment-analysis-frontend     name: sa-frontend                                  ports:       - containerPort: 80</code> </pre> <br>  Como puede ver, si compara esta descripción con lo que examinamos anteriormente, el único cambio es el valor de la propiedad <code>Name</code> . <br><br>  Cree uno nuevo en: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod2.yaml pod "sa-frontend2" created</code> </pre> <br>  Asegúrese de que se esté ejecutando: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s sa-frontend2                  1/1 Running 0 7s</code> </pre> <br>  ¡Ahora tenemos dos hogares!  Es cierto, no hay nada especial para disfrutar aquí.  Tenga en cuenta que la solución al problema de escalado de la aplicación que se muestra aquí tiene muchos inconvenientes.  Hablaremos sobre cómo hacerlo correctamente en la sección sobre otro recurso de Kubernetes llamado Implementación. <br><br>  Ahora considere lo que obtuvimos después de lanzar dos hogares idénticos.  A saber, el servidor web Nginx ahora se ejecuta en dos pods diferentes.  En este sentido, podemos hacer dos preguntas: <br><br><ol><li>  ¿Cómo dar acceso a estos servidores desde el exterior, por URL? </li><li>  ¿Cómo organizar el equilibrio de carga entre ellos? </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/3a9/6f4/1ff3a96f4b930fe55727d1063b3c117b.png"></div><br>  <i><font color="#999999">Enfoque de escala incorrecto</font></i> <br><br>  Entre las herramientas de Kubernetes hay recursos del formulario Servicio.  Hablemos de ellos. <br><br><h2>  <font color="#3AC1EF">Práctica Kubernetes: Servicios</font> </h2><br>  Los servicios de Kubernetes actúan como puntos de acceso a conjuntos de hogares que proporcionan la misma funcionalidad que estos hogares.  Los servicios realizan la solución de tareas difíciles de trabajar con hogares y equilibrar la carga entre ellos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/95f/bd8/bbd95fbd8562bed4a09ab4930a20f98d.png"></div><br>  <i><font color="#999999">El servicio Kubernetes sirve direcciones IP</font></i> <br><br>  En nuestro clúster de Kubernetes habrá pods que implementarán diferentes funciones.  Esta es una aplicación front-end, una aplicación web Spring y una aplicación Flask escrita en Python.  Esto plantea la cuestión de cómo el servicio debe comprender con qué tipo de pods necesita trabajar, es decir, cómo averiguar sobre la base de qué información el sistema debe generar una lista de puntos finales para los pods. <br><br>  Esto se hace con otra abstracción de Kubernetes llamada Label.  El trabajo con etiquetas consta de dos etapas: <br><br><ol><li>  La asignación de etiquetas dará el servicio para trabajar. </li><li>  Aplicando un "selector" al servicio, que determina a qué pods se asignan las etiquetas, el servicio funcionará. </li></ol><br>  Quizás sea más fácil imaginarlo como ilustración que describirlo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb9/fcf/f0c/bb9fcff0cded591f1a5ab8a0b825245a.png"></div><br>  <i><font color="#999999">Pods etiquetados y sus archivos de manifiesto</font></i> <br><br>  Vemos aquí dos hogares que, utilizando la <code>app: sa-frontend</code> construcción de <code>app: sa-frontend</code> , se les asignan las mismas etiquetas.  El servicio está interesado en las cápsulas con tales marcas. <br><br><h3>  <font color="#3AC1EF">▍Etiquetas</font> </h3><br>  Las etiquetas ofrecen a los desarrolladores una forma sencilla de organizar los recursos de Kubernetes.  Son pares clave-valor; puede asignarlos a cualquier recurso.  Modifique los archivos de descripción del hogar de la aplicación frontend y llévelos a la vista que se muestra en la figura anterior.  Después de eso, guarde estos archivos y ejecute los siguientes comandos: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-pod.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend" configured kubectl apply -f sa-frontend-pod2.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend2" configured</code> </pre> <br>  Cuando se ejecutan estos comandos, el sistema emitirá advertencias (no nos conviene que usemos <code>apply</code> lugar de <code>create</code> , entendemos esto), pero, después de una advertencia, informa que los pods correspondientes están configurados.  Podemos verificar si las etiquetas fueron asignadas, filtrando los registros para los que queremos mostrar información: <br><br><pre> <code class="plaintext hljs">kubectl get pod -l app=sa-frontend NAME           READY STATUS    RESTARTS AGE sa-frontend    1/1 Running   0 2h sa-frontend2   1/1 Running   0 2h</code> </pre> <br>  Otra forma de verificar que las etiquetas hayan sido asignadas es adjuntar la tecla <code>--show-labels</code> al comando anterior.  Debido a esto, la información sobre sus pods también incluirá datos sobre sus marcas. <br><br>  Ahora se han asignado etiquetas y estamos listos para configurar el servicio para trabajar con ellas.  Por lo tanto, tomaremos la descripción de un servicio como <code>LoadBalancer</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/081/7e9/e0f0817e9fc090628aa1d0d89577ce80.gif"></div><br>  <i><font color="#999999">Balanceo de carga usando un servicio como LoadBalancer</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Descripción del servicio</font> </h3><br>  Aquí hay una descripción YAML de un servicio como <code>LoadBalancer</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service              # 1 metadata: name: sa-frontend-lb spec: type: LoadBalancer       # 2 ports: - port: 80               # 3   protocol: TCP          # 4   targetPort: 80         # 5 selector:                # 6   app: sa-frontend       # 7</code> </pre> <br>  Explica este texto: <br><br><ol><li>  <code>Kind</code> : creamos un servicio, un recurso de <code>Service</code> . </li><li>  <code>Type</code> : el tipo de recurso indicado en su especificación.  Elegimos el tipo <code>LoadBalancer</code> , porque con este servicio queremos resolver el problema de equilibrar la carga entre los hogares. </li><li>  <code>Port</code> : puerto en el que el servicio acepta solicitudes. </li><li>  <code>Protocol</code> : el protocolo utilizado por el servicio. </li><li>  <code>TargetPort</code> : puerto al que se redirigen las solicitudes entrantes. </li><li>  <code>Selector</code> : un objeto que contiene información sobre con qué pods debería trabajar el servicio. </li><li>  <code>app: sa-frontend</code> : esta propiedad indica con qué pods funcionará el servicio.  A saber, estos son los pods a los que se ha asignado la etiqueta <code>app: sa-frontend</code> . </li></ol><br>  Para crear un servicio, debe ejecutar el siguiente comando: <br><br><pre> <code class="plaintext hljs">kubectl create -f service-sa-frontend-lb.yaml service "sa-frontend-lb" created</code> </pre> <br>  Puede verificar el estado del servicio de la siguiente manera: <br><br><pre> <code class="plaintext hljs">kubectl get svc NAME             TYPE CLUSTER-IP      EXTERNAL-IP PORT(S) AGE sa-frontend-lb   LoadBalancer 10.101.244.40   &lt;pending&gt; 80:30708/TCP 7m</code> </pre> <br>  Aquí puede ver que la propiedad <code>EXTERNAL-IP</code> está en el estado <code>&lt;pending&gt;</code> , pero no puede esperar a que cambie.  Esto se debe al hecho de que usamos Minikube.  Si creamos un servicio similar mientras trabajamos con un determinado proveedor de servicios en la nube, como Azure o Google Cloud Platform, entonces el servicio tendría una dirección IP pública que permitiría acceder desde Internet. <br><br>  A pesar de esto, Minikube no nos permitirá perder el tiempo, dándonos un comando útil para la depuración local del sistema: <br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb Opening kubernetes service default/sa-frontend-lb in default browser...</code> </pre> <br>  Gracias a este comando, se lanzará un navegador que accederá al servicio.  Después de que el servicio recibe la solicitud, la redirigirá a uno de los hogares (no importa en cuál de ellos estará).  Esta abstracción nos permite percibir un grupo de hogares como una entidad única y trabajar con ellos, utilizando el servicio como un único punto de acceso a ellos. <br><br>  En esta sección, hablamos sobre cómo asignar etiquetas a los recursos, cómo usarlos al configurar servicios como selectores.  Aquí describimos y creamos un servicio como <code>LoadBalancer</code> .  Gracias a esto, resolvimos el problema de escalar la aplicación (el escalado consiste en agregar nuevos hogares con las etiquetas correspondientes al clúster) y organizar el equilibrio de carga entre los hogares utilizando el servicio como punto de entrada. <br><br><h2>  <font color="#3AC1EF">Práctica de Kubernetes: implementaciones</font> </h2><br>  La implementación es una abstracción de Kubernetes que nos permite controlar lo que siempre está presente en el ciclo de vida de la aplicación.  Se trata de gestionar los cambios de la aplicación.  Las aplicaciones que no cambian son, por así decirlo, aplicaciones "muertas".  Si la aplicación "vive", entonces puede encontrar el hecho de que sus requisitos cambian periódicamente, su código se expande, este código se empaqueta y se implementa.  Además, se pueden cometer errores en cada paso del proceso. <br><br>  Un recurso del tipo Implementación le permite automatizar el proceso de transición de una versión de una aplicación a otra.  Esto se hace sin interrumpir el sistema, y ​​si se produce un error durante este proceso, tendremos la oportunidad de volver rápidamente a la versión anterior y funcional de la aplicación. <br><br><h3>  <font color="#3AC1EF">▍Uso de implementaciones</font> </h3><br>  Ahora el clúster tiene dos hogares y un servicio que les da acceso desde el exterior y equilibra la carga en ellos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/426/651/0c4/4266510c40a1faa6086178e5db23d20c.png"></div><br>  <i><font color="#999999">Estado actual del clúster</font></i> <br><br>  Hablamos sobre el hecho de que ejecutar dos hogares diferentes con la misma funcionalidad no es una buena idea.  Al utilizar dicho esquema, tenemos que trabajar con cada hogar individualmente, creando, actualizando, eliminando cada hogar específico, observando su estado.  Con este enfoque, no hay necesidad de hablar sobre una actualización rápida del sistema o la reversión rápida de una actualización fallida.  No estamos satisfechos con este estado de cosas, por lo tanto, vamos a recurrir a la posibilidad de un recurso de implementación, que tiene como objetivo resolver los problemas anteriores. <br><br>  Antes de continuar con el trabajo, formulemos sus objetivos, que nos darán pautas que serán útiles al analizar el archivo de manifiesto de implementación.  Entonces, esto es lo que necesitamos: <br><br><ol><li>  Queremos poder crear dos hogares basados ​​en un contenedor <code>rinormaloku/sentiment-analysis-frontend</code> . </li><li>  Necesitamos un sistema de implementación de aplicaciones que le permita funcionar sin interrupciones cuando se actualiza. </li><li>  Queremos que se asigne la etiqueta de la <code>app: sa-frontend</code> , que permitirá que el servicio <code>sa-frontend-lb</code> detecte estos pods. </li></ol><br>  Ahora expresaremos estos requisitos como una descripción del recurso de implementación. <br><br><h3>  <font color="#3AC1EF">▍ Descripción de la implementación</font> </h3><br>  Aquí hay una descripción de YAML de un recurso de tipo Implementación, que se creó teniendo en cuenta los requisitos del sistema anteriores: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment                                          # 1 metadata: name: sa-frontend spec: replicas: 2                                             # 2 minReadySeconds: 15 strategy:   type: RollingUpdate                                   # 3   rollingUpdate:     maxUnavailable: 1                                   # 4     maxSurge: 1                                         # 5 template:                                               # 6   metadata:     labels:       app: sa-frontend                                  # 7   spec:     containers:       - image: rinormaloku/sentiment-analysis-frontend         imagePullPolicy: Always                         # 8         name: sa-frontend         ports:           - containerPort: 80</code> </pre> <br>  Analicemos esta descripción: <br><br><ol><li>  <code>Kind</code> : aquí dice que estamos describiendo un recurso de la vista <code>Deployment</code> . </li><li>  <code>Replicas</code> : una propiedad del objeto de especificación de implementación que define cuántas instancias (réplicas) de hogares se ejecutan. </li><li>  <code>Type</code> : describe la estrategia utilizada en esta implementación al cambiar de la versión actual a una nueva.  <code>RollingUpdate</code> estrategia <code>RollingUpdate</code> proporciona cero tiempo de inactividad del sistema durante las actualizaciones. </li><li>  <code>MaxUnavailable</code> : esta es una propiedad del objeto <code>RollingUpdate</code> , que establece el número máximo de hogares no disponibles (en comparación con el número deseado de hogares) al realizar una actualización secuencial del sistema.  En nuestro despliegue, que implica la presencia de 2 réplicas, el valor de esta propiedad indica que después de completar un pod, se ejecutará otro, lo que hace que la aplicación esté disponible durante la actualización. </li><li>  <code>MaxSurge</code> : esta es una propiedad del objeto <code>RollingUpdate</code> que describe el número máximo de hogares que se pueden agregar a una implementación (en comparación con un número determinado de hogares).  En nuestro caso, su valor, 1, significa que, al cambiar a una nueva versión del programa, podemos agregar otro sub al clúster, lo que conducirá al hecho de que se pueden iniciar hasta tres hogares simultáneamente. </li><li>  <code>Template</code> : este objeto define la plantilla de hogar que el recurso de <code>Deployment</code> descrito usará para crear nuevos hogares.  Probablemente encuentre esta configuración familiar. </li><li>  <code>app: sa-frontend</code> : etiqueta para hogares creados de acuerdo con un patrón dado. </li><li>  <code>ImagePullPolicy</code> : define el orden de trabajo con imágenes.  En nuestro caso, esta propiedad se establece en <code>Always</code> , es decir, durante cada implementación, la imagen correspondiente se descargará del repositorio. </li></ol><br>  Habiendo examinado todo esto, pasemos a practicar.  Ejecute la implementación: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml deployment "sa-frontend" created</code> </pre> <br>  Verifique el estado del sistema: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                           READY STATUS RESTARTS AGE sa-frontend                    1/1 Running 0 2d sa-frontend-5d5987746c-ml6m4   1/1 Running 0 1m sa-frontend-5d5987746c-mzsgg   1/1 Running 0 1m sa-frontend2                   1/1 Running 0 2d</code> </pre> <br>  Como puede ver, ahora tenemos 4 vainas.  Dos de ellos fueron creados utilizando el recurso de implementación, dos más son los que nosotros mismos creamos.  Ahora puede eliminar los pods que creamos nosotros mismos utilizando comandos del siguiente tipo: <br><br><pre> <code class="plaintext hljs">kubectl delete pod &lt;pod-name&gt;</code> </pre> <br>  Por cierto, aquí hay una tarea para trabajo independiente.  Elimine uno de los hogares creados con el recurso de implementación y supervise el sistema.  Piense en las razones de lo que está sucediendo antes de seguir leyendo. <br><br>  Al eliminar un hogar, el recurso de implementación descubre que el estado actual del sistema (1 sub) es diferente del deseado (2 sub), por lo que se inicia otro sub. <br><br>  ¿Cuál es el uso de los recursos de implementación, además del hecho de que cuando se usa, el sistema se mantiene en el estado correcto?  Considere las fortalezas de estos recursos. <br><br><h3>  <font color="#3AC1EF">▍ Realizar implementaciones con cero tiempo de inactividad del sistema</font> </h3><br>  Supongamos que un gerente de producto se acerca y nos informa que el cliente para el que creamos este producto quiere un botón verde en la aplicación del cliente.  Los desarrolladores implementan este requisito y nos dan lo único que necesitamos de ellos: un contenedor de imágenes llamado <code>rinormaloku/sentiment-analysis-frontend:green</code> .  Ahora llega nuestro momento.  Nosotros, el equipo de DevOps, necesitamos implementar el sistema actualizado y garantizar un tiempo de inactividad cero.  Ahora veamos si los esfuerzos para desarrollar y configurar el recurso de implementación están justificados. <br><br>  Edite el archivo <code>sa-frontend-deployment.yaml</code> , reemplazando el nombre del contenedor de imágenes por uno nuevo, con <code>rinormaloku/sentiment-analysis-frontend:green</code> , luego guarde este archivo como <code>sa-frontend-deployment-green.yaml</code> y ejecute el siguiente comando: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment-green.yaml --record deployment "sa-frontend" configured</code> </pre> <br>  Verifique el estado del sistema con el siguiente comando: <br><br><pre> <code class="plaintext hljs">kubectl rollout status deployment sa-frontend Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 of 2 updated replicas are available... deployment "sa-frontend" successfully rolled out</code> </pre> <br>  De acuerdo con los datos que se muestran en respuesta a este comando, podemos concluir que la implementación de la actualización fue exitosa.  Durante la actualización, las réplicas antiguas, una a la vez, fueron reemplazadas por otras nuevas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto significa que nuestra aplicación, durante el proceso de actualización, siempre estuvo disponible. </font><font style="vertical-align: inherit;">Antes de continuar, asegurémonos de que las aplicaciones estén realmente actualizadas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificación de implementación </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para ver cómo se ve la aplicación en el navegador, utilizaremos el comando que ya conoce: </font></font><br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En respuesta a esto, se iniciará un navegador y se abrirá la página de la aplicación. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/777/489/902/777489902694f46438ceae41ce59db9b.png"></div><br> <i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Botón verde</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como puede ver, el botón realmente se volvió verde, lo que significa que la actualización del sistema fue realmente exitosa.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaciones del sistema detrás de escena de acuerdo con el esquema RollingUpdate </font></font></h4><br>  ,     <code>kubectl apply -f sa-frontend-deployment-green.yaml --record</code> , Kubernetes   ,     ,    .         ,       ,    <code>rinormaloku/sentiment-analysis-frontend:green</code> .       ,    ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/7ee/290/4657ee29097dc99e4fa2a0ebd9180e7a.png"></div><br> <i><font color="#999999">     </font></i> <br><br>  <code>RollingUpdate</code>       ,  ,     <code>maxUnavailable: 1</code>  <code>maxSurge: 1</code> .  ,   Deployment ,     ,    ,     .  ,    ,    ,         . <br><br>         Deployment.     ,   .      . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>   ,   ,   . «!  !    !», —  .        . ,   ,      : <br><br><pre> <code class="plaintext hljs">kubectl rollout history deployment sa-frontend deployments "sa-frontend" REVISION  CHANGE-CAUSE 1         &lt;none&gt;    2         kubectl.exe apply --filename=sa-frontend-deployment-green.yaml --record=true</code> </pre> <br>          : «,    ,    ?». <br><br> «.  ,   ?», —   . <br><br>  ,         ,     : <br><br><pre> <code class="plaintext hljs">kubectl rollout undo deployment sa-frontend --to-revision=1 deployment "sa-frontend" rolled back</code> </pre> <br>      .   ,      . <br><br>       . <br><br>       . <br><br> ! <br><br>   ,  .   Kubernetes         ,  ,      . ,   ! <br><br>           . ,       .  <code>CHANGE-CAUSE</code>      <code>&lt;none&gt;</code> ,    — <code>kubectl.exe apply –filename=sa-frontend-deployment-green.yaml –record=true</code> ? <br><br>   ,         -- <code>record</code>     ,    . <br><br>       ,   ,  ,      . <br><br><h2> <font color="#3AC1EF">   Kubernetes:    </font> </h2><br>      Kubernetes,    ,     .      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cb/af4/880/7cbaf4880d435df50761d22508f61e83.png"></div><br> <i><font color="#999999">  </font></i> <br><br>       . <br><br><h3> <font color="#3AC1EF">▍  sa-logic</font> </h3><br>        <code>resource-manifests</code>    : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-logic-deployment.yaml --record deployment "sa-logic" created</code> </pre> <br>  <code>sa-logic</code>   .     Python-.    <code>app: sa-logic</code> .          <code>sa-logic</code> ,   .   <code>sa-logic-deployment.yaml</code>     . <br><br>  -,        ,      —  <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍ sa-logic</font> </h3><br>   ,       Service.   ,   Java-,        <code>sa-webapp</code> ,      ,  Python-.  ,    ,       ,     Python-,   .     ,  ,  ,  . <br><br>      , ,    ,       ,   .  ,      <code>sa-logic</code>   ,       <code>sa-logic</code> . <br><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-logic.yaml service "sa-logic" created</code> </pre> <br>    ,        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/79b/3e3/69379b3e373ad1bc728242db341411ab.png"></div><br> <i><font color="#999999">  </font></i> <br><br>   <code>sa-logic</code> ,   <code>sa-webapp</code> ,    ,    . <br><br>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍  sa-webapp</font> </h3><br>      ,          Deployment    - . ,     <code>sa-web-app-deployment.yaml</code> ,      : <br><br><pre> <code class="plaintext hljs">- image: rinormaloku/sentiment-analysis-web-app imagePullPolicy: Always name: sa-web-app env:   - name: SA_LOGIC_API_URL     value: "http://sa-logic" ports:   - containerPort: 8080</code> </pre> <br>     <code>env</code> ?  ,   ,  ,   <code>SA_LOGIC_API_URL</code>   <code>http://sa-logic</code> .   ,    ,       .    ? <br><br>             kube-dns. <br><br><h3> <font color="#3AC1EF">▍DNS-  Kubernetes</font> </h3><br>  Kubernetes   ,   <code>kube-dns</code> .        DNS-.     <code>kube-dns</code>   ,     DNS-    . <br><br>  ,      <code>sa-logic</code> ,   IP-.  <code>kube-dns</code>        IP- .        <code>http://sa-logic</code>  IP-. <br><br>      Deployment <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍  sa-webapp</font> </h3><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-web-app-deployment.yaml --record deployment "sa-web-app" created</code> </pre> <br>         <code>sa-webapp</code>   ,   .   React-    ,       <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍ sa-webapp</font> </h3><br>     <code>service-sa-web-app-lb.yaml</code> ,  ,  ,    ,   . ,   ,   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-web-app-lb.yaml service "sa-web-app-lb" created</code> </pre> <br>    . ,     ,      . ,     <code>sa-frontend</code> ,        Java- <code>sa-webapp</code> ,    <code>http://localhost:8080/sentiment</code> .      ,       ,   <code>sa-webapp</code> ,    React-  ,     Java-. <br><br>           ,     . ,          —  ,    ,     . <br><br>  ,       : <br><br><ol><li>  IP-   <code>sa-webapp</code> ,   : <br><br> <code>minikube service list <br> |-------------|----------------------|-----------------------------| <br> |  NAMESPACE  | NAME         | URL       | <br> |-------------|----------------------|-----------------------------| <br> | default     | kubernetes         | No node port       | <br> | default     | sa-frontend-lb       | http://192.168.99.100:30708 | <br> | default     | sa-logic         | No node port       | <br> | default     | sa-web-app-lb        | http://192.168.99.100:31691 | <br> | kube-system | kube-dns             | No node port | <br> | kube-system | kubernetes-dashboard | http://192.168.99.100:30000 | <br> |-------------|----------------------|-----------------------------|</code> </li> <li>   IP-   <code>sa-frontend/src/App.js</code> .   ,     : <br><br><pre> <code class="plaintext hljs">analyzeSentence() {       fetch('http://192.168.99.100:31691/sentiment', { /*    */})           .then(response =&gt; response.json())           .then(data =&gt; this.setState(data));   }</code> </pre> </li><li>  React-,       <code>sa-frontend</code>    <code>npm run build</code> . </li><li>   : <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend:minikube.</code> </pre> </li><li>     Docker Hub: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend:minikube</code> </pre> </li><li>   <code>sa-frontend-deployment.yaml</code> ,       . </li><li>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml</code> </pre> </li></ol><br>     ,   , ,      ,    <code>minikube service sa-frontend-lb</code> .  ,   - . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>   Kubernetes     ,        ,   ,   ,     .  Kubernetes   ,     ,           .    Kubernetes  Supernetes. <br><br>    ,   : <br><br><ul><li> ,    ,   React, Java  Python. </li><li>    Docker,  ,        <code>Dockerfile</code> . </li><li>    ,  ,  Docker Hub. </li></ul><br>  ,     Kubernetes: <br><br><ul><li>  </li><li>  </li><li>  </li><li>           </li><li>   </li></ul><br>      ,   ,   Kubernetes. <br><br>  <b>Estimados lectores!</b>    Kubernetes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438984/">https://habr.com/ru/post/438984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438974/index.html">La realidad virtual ayuda a lidiar con los trastornos mentales</a></li>
<li><a href="../438976/index.html">El libro "Primavera. Todos los patrones de diseño »</a></li>
<li><a href="../438978/index.html">¡Aprendiendo siempre y en todas partes! Podcasts para desarrolladores en inglés</a></li>
<li><a href="../438980/index.html">Spring Boot 2: ¿qué hay de nuevo?</a></li>
<li><a href="../438982/index.html">Guía de Kubernetes, Parte 1: Aplicaciones, microservicios y contenedores</a></li>
<li><a href="../438986/index.html">React Tutorial Parte 14: Taller sobre componentes basados ​​en la clase, estado de los componentes</a></li>
<li><a href="../438988/index.html">Tutorial de React Parte 15: Talleres estatales de componentes</a></li>
<li><a href="../438992/index.html">Diario del desarrollador o malas decisiones</a></li>
<li><a href="../438994/index.html">Intel Xeon W-3175X, un baterista de moda. Prueba</a></li>
<li><a href="../438996/index.html">Red de la empresa y MitM. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>