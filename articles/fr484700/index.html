<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™‰ï¸ ğŸ‘¨ğŸ»â€ğŸŒ¾ ğŸ¦„ Java 14: aperÃ§u des enregistrements ğŸ”¥ ğŸ˜œ ğŸ’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BientÃ´t, une nouvelle fonctionnalitÃ© de syntaxe apparaÃ®tra dans les prochains enregistrements Java 14 . AprÃ¨s avoir Ã©tudiÃ© l' aperÃ§u , qui dÃ©crit briÃ¨...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java 14: aperÃ§u des enregistrements</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484700/"><p>  BientÃ´t, une nouvelle fonctionnalitÃ© de syntaxe apparaÃ®tra dans les <a href="https://openjdk.java.net/projects/jdk/14/">prochains</a> enregistrements <a href="https://openjdk.java.net/projects/jdk/14/">Java 14</a> .  AprÃ¨s avoir Ã©tudiÃ© l' <a href="https://openjdk.java.net/jeps/359">aperÃ§u</a> , qui dÃ©crit briÃ¨vement Ã  quoi ressemblent les enregistrements et avec Â«ce qu'ils mangentÂ», j'ai osÃ© adapter le document en russe pour Habr.  Peu importe - bienvenue au chat. </p><a name="habracut"></a><br><h3>  RÃ©sumÃ© </h3><br>  Les entrÃ©es vous permettent d'Ã©tendre les capacitÃ©s de Java.  Ils fournissent une syntaxe concise pour dÃ©clarer des classes qui sont de simples porteurs d'ensembles de donnÃ©es persistants et immuables. <br><br><h3>  Raisons et objectifs </h3><br>  Les plaintes selon lesquelles Â«Java est trop verbeuxÂ» et que vous devez Â«cÃ©rÃ©monieÂ» avec lui sont assez courantes.  La raison en est que les classes sont conÃ§ues uniquement pour stocker un certain ensemble de donnÃ©es.  Pour Ã©crire correctement une telle classe, vous devez Ã©crire beaucoup de code formel, rÃ©pÃ©titif et sujet aux erreurs: constructeurs, getters et setters, equals (), hashCode (), toString (), etc.  Les dÃ©veloppeurs trichent parfois et ne redÃ©finissent pas equals () et hashCode (), ce qui peut entraÃ®ner un comportement inhabituel ou des problÃ¨mes de dÃ©bogage.  Ou, lorsque les dÃ©veloppeurs ne veulent pas dÃ©clarer une autre classe, ils prescrivent une alternative, mais pas tout Ã  fait appropriÃ©e, simplement parce qu'elle a la Â«forme correcteÂ». <br><br>  Les environnements de dÃ©veloppement aideront Ã  enregistrer la plupart du code dans la classe, mais n'aideront pas le dÃ©veloppeur Ã  lire ce code pour naviguer rapidement parmi des dizaines de lignes de code standard et comprendre que cette classe est un support de donnÃ©es ordinaire.  Les ensembles de donnÃ©es standard de modÃ©lisation de code Java doivent Ãªtre simples Ã  Ã©crire, Ã  comprendre et Ã  valider. <br><br>  Ã€ premiÃ¨re vue, il peut sembler que les enregistrements visent Ã  rÃ©duire le code du modÃ¨le.  Nous y mettons l'objectif sÃ©mantique: <i>Â«modÃ©liser les donnÃ©es en tant que donnÃ©esÂ»</i> (modÃ©liser les donnÃ©es en tant que donnÃ©es).  Si la sÃ©mantique est correcte, le code du modÃ¨le fera tout par lui-mÃªme sans la participation du dÃ©veloppeur.  AprÃ¨s tout, dÃ©clarer des ensembles de donnÃ©es persistants devrait Ãªtre facile, clair et concis. <br><br><h3>  Des objectifs qui n'Ã©taient pas </h3><br>  Nous ne nous sommes pas fixÃ© pour objectif de Â«dÃ©clarer la guerreÂ» au code passe-partout.  En particulier, nous n'avions pas l'intention de rÃ©soudre le problÃ¨me des classes mutables en utilisant la convention de dÃ©nomination des composants JavaBean.  Bien que les propriÃ©tÃ©s, la mÃ©taprogrammation et la gÃ©nÃ©ration de code basÃ© sur des annotations soient souvent suggÃ©rÃ©es comme des Â«solutionsÂ» Ã  ce problÃ¨me, l'ajout de ces fonctionnalitÃ©s n'Ã©tait pas non plus notre objectif. <br><br><h3>  La description </h3><br>  Les entrÃ©es sont un nouveau type de dÃ©claration de type en Java.  Comme enum, l'Ã©criture est une classe fonctionnellement limitÃ©e.  Il annonce sa vue et fournit une API qui s'appuie sur cette vue.  Les entrÃ©es ne sÃ©parent pas l'API de la prÃ©sentation et, Ã  leur tour, sont concises. <br><br>  L'entrÃ©e contient un nom et une description de l'Ã©tat.  La description de l'Ã©tat dÃ©clare les composants de cet enregistrement.  Facultativement, l'enregistrement peut avoir un corps.  Par exemple: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">record </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Les enregistrements sÃ©mantiques Ã©tant de simples supports de donnÃ©es, ils reÃ§oivent automatiquement des Ã©lÃ©ments standard: <br><br><ul><li>  Champ final privÃ© pour chaque composante d'Ã©tat; </li><li>  Une mÃ©thode de lecture publique pour chaque composant d'Ã©tat avec le mÃªme nom et type que le composant; </li><li>  Un constructeur public correspondant Ã  la signature d'enregistrement;  il initialise chaque champ Ã  partir de l'argument correspondant; </li><li>  Les implÃ©mentations de equals () et hashCode (), qui disent que deux enregistrements sont Ã©gaux s'ils sont du mÃªme type et contiennent le mÃªme Ã©tat; </li><li>  Une implÃ©mentation de toString (), qui comprend une reprÃ©sentation sous forme de chaÃ®ne de tous les composants d'enregistrement avec leurs noms. </li></ul><br>  En d'autres termes, la prÃ©sentation du dossier est entiÃ¨rement basÃ©e sur une description de l'Ã©tat.  En outre, en fonction de l'Ã©tat de l'enregistrement, la formation de equals (), hashCode () et toString () se produit. <br><br><h3>  Limitations </h3><br>  Les enregistrements ne peuvent hÃ©riter d'aucune autre classe et ne peuvent pas dÃ©clarer de champs d'objet, Ã  l'exception des champs finaux privÃ©s qui correspondent aux composants d'Ã©tat.  Tous les autres champs dÃ©clarÃ©s doivent Ãªtre statiques.  Ces limitations garantissent que la description de l'Ã©tat dÃ©finit en soi la vue. <br><br>  Les inscriptions sont finales et ne peuvent Ãªtre abstraites.  Ces restrictions indiquent que l'API d'enregistrement est dÃ©finie uniquement par une description d'Ã©tat et ne peut pas Ãªtre Ã©tendue ultÃ©rieurement avec une autre classe ou un autre enregistrement. <br><br>  Les composants d'enregistrement sont finaux.  Cette restriction met en Å“uvre le principe Â«inchangÃ© par dÃ©fautÂ», qui est largement utilisÃ© pour les ensembles de donnÃ©es. <br><br>  En plus des limitations mentionnÃ©es ci-dessus, les enregistrements se comportent comme des classes ordinaires: ils peuvent Ãªtre dÃ©clarÃ©s comme de niveau supÃ©rieur ou imbriquÃ©s, ils peuvent Ãªtre gÃ©nÃ©riques, ils peuvent implÃ©menter des interfaces.  Les enregistrements sont crÃ©Ã©s en appelant le nouvel opÃ©rateur.  Le corps d'Ã©criture peut dÃ©clarer des mÃ©thodes statiques, des champs statiques, des blocs d'initialisation statiques, des constructeurs, des mÃ©thodes d'instance, des blocs d'initialisation d'instance et des types imbriquÃ©s.  Un enregistrement et des composants d'Ã©tat individuels peuvent Ãªtre annotÃ©s.  Si l'enregistrement est imbriquÃ©, il est statique;  cela Ã©limine la situation avec des instances imbriquÃ©es qui pourraient automatiquement ajouter un Ã©tat Ã  l'enregistrement. <br><br><h3>  EntrÃ©es explicitement dÃ©clarÃ©es </h3><br>  Bien que l'implÃ©mentation standard des getters, ainsi que les mÃ©thodes equals (), hashCode () et toString (), soit acceptable dans la plupart des cas d'utilisation, le dÃ©veloppeur a la possibilitÃ© de remplacer l'implÃ©mentation standard.  Cependant, vous devez Ãªtre particuliÃ¨rement prudent lorsque vous remplacez les mÃ©thodes equals / hashCode. <br><br>  Une attention particuliÃ¨re est portÃ©e Ã  la dÃ©claration explicite du constructeur canonique, dont la signature correspond Ã  la description de l'Ã©tat de l'enregistrement.  Un constructeur peut Ãªtre dÃ©clarÃ© sans liste formelle de paramÃ¨tres: dans ce cas, il est supposÃ© qu'il coÃ¯ncide avec la description de l'Ã©tat, et tous les champs d'enregistrement sont implicitement initialisÃ©s par la fermeture standard du corps du constructeur des paramÃ¨tres formels correspondants (this. X = x) Ã  la sortie.  Cela permet au constructeur canonique de vÃ©rifier et d'ajuster uniquement ses paramÃ¨tres, ainsi que de sauter l'initialisation explicite du champ.  Par exemple: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">record </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Range { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lo &gt; hi) <span class="hljs-comment"><span class="hljs-comment">/* referring here to the implicit constructor parameters */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(String.format(<span class="hljs-string"><span class="hljs-string">"(%d,%d)"</span></span>, lo, hi)); } }</code> </pre> <br><h3>  La grammaire </h3><br><pre> <code class="java hljs">RecordDeclaration: {ClassModifier} record TypeIdentifier [TypeParameters] (RecordComponents) [SuperInterfaces] [RecordBody] RecordComponents: {RecordComponent {, RecordComponent}} RecordComponent: {Annotation} UnannType Identifier RecordBody: { {RecordBodyDeclaration} } RecordBodyDeclaration: ClassBodyDeclaration RecordConstructorDeclaration RecordConstructorDeclaration: {Annotation} {ConstructorModifier} [TypeParameters] SimpleTypeName [Throws] ConstructorBody</code> </pre><br><h3>  Annotations pour l'enregistrement des composants </h3><br>  Les annotations d'annotation peuvent Ãªtre appliquÃ©es aux composants d'enregistrement si elles s'appliquent aux composants, paramÃ¨tres, champs ou mÃ©thodes.  Les annotations publicitaires qui s'appliquent Ã  l'un de ces composants s'appliquent aux dÃ©clarations implicites de tous les Ã©lÃ©ments requis. <br><br>  Les annotations de type qui modifient les types de composants d'enregistrement s'Ã©tendent aux types dans les dÃ©clarations implicites des Ã©lÃ©ments requis (par exemple, les paramÃ¨tres du constructeur, les dÃ©clarations de champ et les mÃ©thodes).  Les dÃ©clarations explicites des Ã©lÃ©ments requis doivent correspondre exactement au type du composant correspondant de l'enregistrement, sans inclure les annotations de type. <br><br><h3>  API de rÃ©flexion </h3><br>  Les mÃ©thodes publiques suivantes seront ajoutÃ©es Ã  <i>java.lang.Class</i> : <br><br><ul><li>  <i>RecordComponent [] getRecordComponents ()</i> </li><li>  <i>boolÃ©en isRecord ()</i> </li></ul><br>  La mÃ©thode <i>getRecordComponents ()</i> renvoie un tableau <i>java.lang.reflect.RecordComponent</i> , oÃ¹ <i>java.lang.reflect.RecordComponent</i> est une nouvelle classe. <br><br>  Les Ã©lÃ©ments de ce tableau correspondent aux composants de l'enregistrement et vont dans le mÃªme ordre dans lequel ils sont dÃ©clarÃ©s dans l'enregistrement.  Des informations supplÃ©mentaires peuvent Ãªtre extraites de chaque <i>RecordComponent</i> dans le tableau, y compris le nom, le type, le gÃ©nÃ©rique, ainsi que sa valeur. <br><br>  La mÃ©thode <i>isRecord ()</i> renvoie <i>true</i> si cette classe est dÃ©clarÃ©e en tant <i>qu'enregistrement</i> .  (Similaire Ã  la mÃ©thode <i>isEnum ()</i> ). <br><br><h3>  Alternatives </h3><br>  Les enregistrements peuvent Ãªtre dÃ©finis comme la forme conditionnelle des tuples.  Au lieu d'enregistrements, nous pouvons utiliser des tuples structurels.  Bien que les tuples offrent des moyens plus lÃ©gers d'exprimer certains ensembles de donnÃ©es, le rÃ©sultat est souvent moins informatif: <br><br><ul><li>  Le principe principal de la philosophie Java est que les <b>noms comptent</b> .  Les classes et leurs Ã©lÃ©ments portent des noms pertinents pour leur contenu, contrairement aux tuples et Ã  leurs composants.  Autrement dit, la classe <i>Person</i> avec les propriÃ©tÃ©s <i>firstName</i> et <i>lastName</i> est plus comprÃ©hensible et fiable que le tuple anonyme de <i>String</i> et <i>String</i> . </li><li>  Les classes prennent en charge la validation d'Ã©tat via leurs constructeurs, contrairement aux tuples.  Certains ensembles de donnÃ©es, tels que les plages numÃ©riques, ont des invariants qui peuvent Ãªtre rÃ©fÃ©rencÃ©s ultÃ©rieurement s'ils sont utilisÃ©s par le constructeur; </li><li>  Les classes peuvent avoir un comportement basÃ© sur leur Ã©tat;  la combinaison de l'Ã©tat et du comportement rend le comportement lui-mÃªme plus explicite et accessible.  Les tuples, n'Ã©tant qu'un ensemble de donnÃ©es, n'offrent pas une telle opportunitÃ©. </li></ul><br><h3>  DÃ©pendances </h3><br>  Les enregistrements vont bien avec les <a href="https://openjdk.java.net/jeps/360">types isolÃ©s (JEP 360)</a> ;  avec les types isolÃ©s, les enregistrements forment une construction, souvent appelÃ©e <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">types de donnÃ©es algÃ©briques.</a>  De plus, les entrÃ©es elles-mÃªmes permettent <a href="https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html">la correspondance de modÃ¨les</a> .  Ã‰tant donnÃ© que les enregistrements associent leurs API Ã  des descriptions d'Ã©tat, nous pouvons finalement obtenir des modÃ¨les de dÃ©construction pour les enregistrements et utiliser les informations des classes isolÃ©es dans une <i>instruction switch</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484700/">https://habr.com/ru/post/fr484700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484678/index.html">ConfÃ©rences ouvertes aux laboratoires de recherche JetBrains</a></li>
<li><a href="../fr484680/index.html">Traduction du livre d'Andrew Un, Passion for Machine Learning, Chapter 33</a></li>
<li><a href="../fr484686/index.html">Pourquoi les rÃ©sistances sont-elles indiquÃ©es par leur couleur?</a></li>
<li><a href="../fr484688/index.html">Nous approchons de la limite de la puissance de calcul - nous avons besoin de nouveaux programmeurs</a></li>
<li><a href="../fr484690/index.html">SÃ©minaire, confÃ©rence, mitap: Ã©tudier les statistiques de 18 000 Ã©vÃ©nements</a></li>
<li><a href="../fr484702/index.html">Alternatives Ã  Prestashop en 2020: les meilleures plateformes de commerce Ã©lectronique</a></li>
<li><a href="../fr484706/index.html">S'entraÃ®ner Ã  travailler avec des pneus personnalisÃ©s du complexe Redd</a></li>
<li><a href="../fr484708/index.html">Richard Hamming "Chapitre inexistant": Comment savons-nous ce que nous savons (version complÃ¨te)</a></li>
<li><a href="../fr484710/index.html">Enfreindre les rÃ¨gles de la collecte des ordures Unity</a></li>
<li><a href="../fr484712/index.html">CompatibilitÃ© binaire Reaktive: comment nous la fournissons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>