<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📩 🕵️ 👩🏿‍🤝‍👨🏻 Pemikiran fungsional. Bagian 3 🥔 🍀 🕛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian ketiga dari serangkaian artikel tentang pemrograman fungsional telah berhenti. Hari ini kita akan berbicara tentang semua jenis paradigma ini d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran fungsional. Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/422115/"><p>  Bagian ketiga dari serangkaian artikel tentang pemrograman fungsional telah berhenti.  Hari ini kita akan berbicara tentang semua jenis paradigma ini dan menunjukkan contoh penggunaannya.  Informasi lebih lanjut tentang tipe primitif, tipe umum, dan banyak lagi yang lainnya! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketiga</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keempat</a></strong> </li></ul><br><p>  Sekarang setelah kita memahami beberapa fungsi, kita akan melihat bagaimana tipe berinteraksi dengan fungsi seperti domain dan rentang.  Artikel ini hanya review.  Untuk perendaman lebih dalam dalam jenis ada serangkaian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"memahami tipe F #"</a> . </p><br><p> Untuk memulai, kita perlu sedikit pemahaman yang lebih baik tentang jenis notasi.  Kami melihat notasi panah " <code>-&gt;</code> " yang memisahkan domain dan jangkauan.  Jadi tanda tangan fungsi selalu terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p>  Beberapa contoh fungsi lainnya: </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p>  Jika Anda menjalankan kode ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jendela interaktif</a> , Anda dapat melihat tanda tangan berikut: </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p>  Artinya: </p><br><ul><li>  <code>intToString</code> memiliki domain tipe <code>int</code> , yang memetakan ke berbagai jenis <code>string</code> . </li><li>  <code>stringToInt</code> memiliki domain tipe <code>string</code> , yang memetakan ke berbagai tipe <code>int</code> . </li></ul><br><h2>  Tipe primitif </h2><br><p>  Ada tipe primitif yang diharapkan: string, int, float, bool, char, byte, dll., Serta banyak turunan lainnya dari sistem tipe .NET. </p><br><p>  Beberapa lagi contoh fungsi dengan tipe primitif: </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p>  dan tanda tangan mereka: </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2>  Ketikkan Anotasi </h2><br><p>  Dalam contoh-contoh sebelumnya, kompiler F # dengan benar menentukan jenis parameter dan hasil.  Tetapi ini tidak selalu terjadi.  Jika Anda mencoba menjalankan kode berikut, Anda akan mendapatkan kesalahan kompilasi: </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p>  Kompiler tidak mengetahui tipe argumen "x", dan karena itu, ia tidak tahu apakah "Panjang" adalah metode yang valid.  Dalam kebanyakan kasus, ini dapat diperbaiki dengan meneruskan "ketik anotasi" ke kompiler F #.  Kemudian dia akan tahu tipe mana yang digunakan.  Dalam versi tetap, kami menunjukkan bahwa tipe "x" adalah string. </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  Kawat gigi di sekitar parameter <code>x:string</code> itu penting.  Jika dilewati, kompiler akan memutuskan bahwa string adalah nilai balik!  Yaitu, titik dua terbuka digunakan untuk menunjukkan tipe nilai pengembalian, seperti yang ditunjukkan pada contoh berikut. </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p>  Kami menunjukkan bahwa parameter <code>x</code> adalah string, dan nilai kembali adalah bilangan bulat. </p><br><h2>  Tipe Fungsi sebagai Parameter </h2><br><p>  Fungsi yang mengambil fungsi lain sebagai parameter atau mengembalikan fungsi disebut <strong>fungsi urutan lebih tinggi</strong> ( <strong>fungsi urutan lebih tinggi</strong> kadang disingkat menjadi HOF).  Mereka digunakan sebagai abstraksi untuk mengatur perilaku umum mungkin.  Jenis fungsi ini sangat umum di F #, kebanyakan perpustakaan standar menggunakannya. </p><br><p>  Pertimbangkan fungsi <code>evalWith5ThenAdd2</code> , yang mengambil fungsi sebagai parameter, dan kemudian menghitung fungsi ini dari 5 dan menambahkan 2 ke hasilnya: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p>  Tanda tangan dari fungsi ini terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  Anda dapat melihat bahwa domain adalah <code>(int-&gt;int)</code> dan jangkauannya adalah <code>int</code> .  Apa artinya ini?  Ini berarti bahwa parameter input bukan nilai sederhana, tetapi fungsi dari banyak fungsi dari <code>int</code> ke <code>int</code> .  Nilai output bukan fungsi, tetapi hanya sebuah <code>int</code> . </p><br><p>  Mari kita coba: </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p>  dan dapatkan: </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p>  " <code>add1</code> " adalah fungsi yang memetakan <code>int</code> ke <code>int</code> , seperti yang kita lihat dari tanda tangan.  Ini adalah parameter yang valid untuk <code>evalWith5ThenAdd2</code> , dan hasilnya adalah 8. </p><br><p>  Ngomong-ngomong, kata khusus " <code>it</code> " digunakan untuk menunjukkan nilai yang dihitung terakhir, dalam hal ini adalah hasil yang kami tunggu-tunggu.  Ini bukan kata kunci, itu hanya konvensi penamaan. </p><br><p>  Kasus lain: </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p>  memberi: </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p>  " <code>times3</code> " juga merupakan fungsi yang memetakan <code>int</code> ke <code>int</code> , seperti yang dapat dilihat dari tanda tangan.  Ini juga merupakan parameter yang valid untuk <code>evalWith5ThenAdd2</code> .  Hasil perhitungannya adalah 17. </p><br><p>  Harap dicatat bahwa data input adalah tipe sensitif.  Jika fungsi yang dilewati menggunakan <code>float</code> , bukan <code>int</code> , maka tidak ada yang berfungsi.  Sebagai contoh, jika kita memiliki: </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p>  Kompiler, ketika mencoba mengkompilasi, akan mengembalikan kesalahan: </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p>  melaporkan bahwa fungsi input harus berupa fungsi tipe <code>int-&gt;int</code> . </p><br><h3>  Berfungsi sebagai Output </h3><br><p>  Fungsi nilai juga bisa merupakan hasil dari fungsi.  Misalnya, fungsi berikut akan menghasilkan fungsi "penambah" yang akan menambah nilai input. </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p>  Tanda tangannya: </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p>  berarti generator mengambil <code>int</code> dan menciptakan fungsi ("penambah") yang memetakan <code>ints</code> ke <code>ints</code> .  Mari kita lihat cara kerjanya: </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p>  Dua fungsi adder dibuat.  Yang pertama membuat fungsi yang menambahkan 1 ke input, yang kedua menambahkan 2. Perhatikan bahwa tanda tangan persis seperti yang kami harapkan. </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p>  Sekarang Anda dapat menggunakan fungsi yang dihasilkan seperti biasa, mereka tidak berbeda dengan fungsi yang didefinisikan secara eksplisit: </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3>  Menggunakan anotasi jenis untuk membatasi jenis fungsi </h3><br><p>  Pada contoh pertama, kami melihat sebuah fungsi: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  Dalam contoh ini, F # dapat menyimpulkan bahwa " <code>fn</code> " mengubah <code>int</code> menjadi <code>int</code> , sehingga tanda tangannya akan menjadi <code>int-&gt;int</code> . </p><br><p>  Tapi apa tanda tangan "fn" dalam kasus berikut? </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p>  Jelas bahwa " <code>fn</code> " adalah jenis fungsi yang mengambil <code>int</code> , tetapi apa yang dikembalikan?  Kompiler tidak dapat menjawab pertanyaan ini.  Dalam kasus seperti itu, jika menjadi perlu untuk menunjukkan jenis fungsi, Anda dapat menambahkan jenis anotasi untuk parameter fungsi, serta untuk tipe primitif. </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p>  Selain itu, Anda dapat menentukan jenis pengembalian. </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p>  Karena  fungsi utama mengembalikan <code>string</code> , fungsi " <code>fn</code> " juga dipaksa untuk mengembalikan <code>string</code> .  Dengan demikian, tidak perlu secara eksplisit menentukan jenis " <code>fn</code> ". </p><br><h2>  Ketik "unit" </h2><br><p>  Dalam proses pemrograman, kami terkadang ingin fungsi melakukan sesuatu tanpa mengembalikan apa pun.  Pertimbangkan fungsi " <code>printInt</code> ".  Fungsi ini benar-benar tidak menghasilkan apa-apa.  Ini hanya mencetak string ke konsol sebagai efek samping dari eksekusi. </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p>  Apa tanda tangannya? </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Apa itu " <code>unit</code> "? </p><br><p>  Bahkan jika fungsi tidak mengembalikan nilai, ia masih membutuhkan jangkauan.  Tidak ada fungsi "void" di dunia matematika.  Setiap fungsi harus mengembalikan sesuatu, karena fungsinya adalah pemetaan, dan pemetaan itu harus menampilkan sesuatu! </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p>  Jadi, dalam F #, fungsi seperti ini mengembalikan tipe khusus hasil yang disebut " <code>unit</code> ".  Ini hanya berisi satu nilai, dilambangkan dengan " <code>()</code> ".  Anda mungkin berpikir bahwa <code>unit</code> dan <code>()</code> adalah sesuatu seperti "void" dan "null" dari C #, masing-masing.  Tetapi tidak seperti mereka, <code>unit</code> adalah tipe nyata, dan <code>()</code> sebenarnya.  Untuk memverifikasi ini, lakukan saja: </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p>  Tanda tangan berikut akan diterima: </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p>  Yang menunjukkan bahwa label " <code>whatIsThis</code> " adalah tipe <code>unit</code> dan dikaitkan dengan nilai <code>()</code> . </p><br><p>  Sekarang, kembali ke tanda tangan " <code>printInt</code> ", kita dapat memahami arti dari entri ini: </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Tanda tangan ini mengatakan bahwa <code>printInt</code> memiliki domain <code>int</code> , yang diterjemahkan menjadi sesuatu yang tidak menarik bagi kami. </p><br><h3>  Fungsi tanpa parameter </h3><br><p>  Sekarang kita mengerti <code>unit</code> , dapatkah kita memprediksi kemunculannya dalam konteks yang berbeda?  Sebagai contoh, cobalah untuk membuat fungsi yang dapat digunakan kembali "hello world".  Karena tidak ada input atau output, kita dapat mengharapkan <code>unit -&gt; unit</code> tanda tangan <code>unit -&gt; unit</code> .  Mari kita lihat: </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p>  Hasil: </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>Tidak</em> seperti yang kami harapkan.  "Hello world" langsung ditampilkan, dan hasilnya bukan fungsi, tetapi nilai sederhana dari unit tipe.  Kita dapat mengatakan bahwa ini adalah nilai sederhana, karena, seperti yang kita lihat sebelumnya, ia memiliki tanda tangan dari formulir: </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p>  Dalam contoh ini, kita melihat bahwa <code>printHello</code> benar-benar <em>nilai sederhana</em> <code>()</code> .  Ini bukan fungsi yang bisa kita panggil nanti. </p><br><p>  Apa perbedaan antara <code>printInt</code> dan <code>printHello</code> ?  Dalam hal <code>printInt</code> nilainya tidak dapat ditentukan sampai kita mengetahui nilai parameter <code>x</code> , jadi definisi tersebut adalah fungsi.  Dalam hal <code>printHello</code> tidak ada parameter, sehingga sisi kanan dapat ditentukan di tempatnya.  Dan itu sama dengan <code>()</code> dengan efek samping berupa output ke konsol. </p><br><p>  Anda dapat membuat fungsi benar-benar dapat digunakan kembali tanpa parameter, memaksa definisi untuk memiliki argumen <code>unit</code> : </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p>  Sekarang tanda tangannya sama dengan: </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p>  dan untuk menyebutnya, kita harus meneruskan <code>()</code> sebagai parameter: </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3>  Memperkuat tipe unit dengan fungsi abaikan </h3><br><p>  Dalam beberapa kasus, kompiler memerlukan tipe <code>unit</code> dan komplain.  Misalnya, kedua kasus berikut ini akan menyebabkan kesalahan kompiler: </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p>  Untuk membantu dalam situasi ini, ada fungsi <code>ignore</code> khusus yang mengambil apa saja dan mengembalikan <code>unit</code> .  Versi kode ini yang benar adalah: </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2>  Jenis Generik </h2><br><p>  Dalam kebanyakan kasus, jika tipe parameter fungsi bisa tipe apa saja, kita perlu mengatakan sesuatu tentangnya.  F # menggunakan .NET generics untuk situasi seperti itu. </p><br><p>  Misalnya, fungsi berikut mengonversi parameter ke string dengan menambahkan beberapa teks: </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p>  Apa pun jenis parameternya, semua objek dapat dilakukan di <code>ToString()</code> . </p><br><p>  Tanda tangan: </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  Apa tipe <code>'a</code> ?  Dalam F #, ini adalah cara untuk menunjukkan tipe generik yang tidak diketahui pada waktu kompilasi.  Apostrof sebelum "a" berarti jenisnya generik.  Setara dengan tanda tangan ini dalam C #: </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p>  Harus dipahami bahwa fungsi F # ini masih memiliki pengetikan yang kuat bahkan dengan tipe generik.  Itu <em>tidak</em> menerima parameter tipe <code>Object</code> .  Pengetikan yang kuat itu baik karena memungkinkan Anda untuk menjaga keamanan tipenya saat menyusun fungsi. </p><br><p>  Fungsi yang sama digunakan untuk <code>int</code> , <code>float</code> , dan <code>string</code> . </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p>  Jika ada dua parameter umum, maka kompiler akan memberi mereka dua nama berbeda: <code>'a</code> untuk yang pertama, <code>'b</code> untuk yang kedua, dll.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p>  Akan ada dua jenis generik dalam tanda tangan ini: <code>'a</code> dan <code>'b</code> : </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p>  Di sisi lain, kompiler mengenali ketika hanya satu jenis generik diperlukan.  Dalam contoh berikut, <code>x</code> dan <code>y</code> harus dari jenis yang sama: </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p>  Jadi, tanda tangan fungsi memiliki tipe generik yang sama untuk kedua parameter: </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p>  Parameter umum juga sangat penting ketika datang ke daftar dan struktur abstrak lainnya, dan kita akan melihat banyak dari mereka dalam contoh berikut. </p><br><h2>  Jenis lainnya </h2><br><p>  Sejauh ini, hanya tipe dasar yang telah dibahas.  Tipe-tipe ini dapat digabungkan dengan berbagai cara menjadi tipe yang lebih kompleks.  Analisis penuh mereka nantinya akan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seri lain</a> , tetapi sementara itu, dan di sini kita akan secara singkat menganalisis mereka, sehingga Anda dapat mengenalinya dalam tanda tangan fungsi. </p><br><ul><li>  <strong>Tuples</strong>  Ini adalah pasangan, rangkap tiga, dll., Terdiri dari jenis lain.  Sebagai contoh, <code>("hello", 1)</code> adalah tuple berdasarkan <code>string</code> dan <code>int</code> .  Tanda koma adalah ciri khas tupel, jika koma terlihat di suatu tempat dalam F #, ini hampir dijamin menjadi bagian dari tupel. <br>  Dalam tanda tangan fungsi, tupel ditulis sebagai "produk" dari dua jenis yang terlibat.  Dalam hal ini, tupel akan bertipe: </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>Koleksi</strong>  Yang paling umum adalah daftar (daftar), seq (urutan) dan array.  Daftar dan array berukuran tetap, sementara urutan berpotensi tak terbatas (di belakang layar, urutan adalah <code>IEnumrable</code> sama).  Dalam tanda tangan fungsi, mereka memiliki kata kunci sendiri: " <code>list</code> ", " <code>seq</code> " dan " <code>[]</code> " untuk array. </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>Opsi (tipe opsional)</strong> .  Ini adalah pembungkus sederhana di atas objek yang mungkin hilang.  Ada dua opsi: <code>Some</code> (ketika nilai ada) dan <code>None</code> (ketika nilai tidak).  Dalam tanda tangan fungsi, mereka memiliki kata kunci " <code>option</code> " sendiri: </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>Asosiasi yang ditandai (serikat terdiskriminasi)</strong> .  Mereka dibangun dari banyak variasi tipe lain.  Kami melihat beberapa contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"mengapa menggunakan F #?"</a>  .  Dalam tanda tangan fungsi, mereka dirujuk berdasarkan nama tipe, mereka tidak memiliki kata kunci khusus. </li><li>  <strong>Jenis rekaman (catatan)</strong> .  Jenis-jenis seperti struktur atau baris basis data, satu set nilai bernama.  Kami juga melihat beberapa contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"mengapa menggunakan F #?"</a>  .  Dalam tanda tangan fungsi, mereka dipanggil dengan nama tipe dan juga tidak memiliki kata kunci sendiri. </li></ul><br><h2>  Uji pemahaman Anda tentang jenis </h2><br><p>  Berikut adalah beberapa ekspresi untuk menguji pemahaman Anda tentang tanda tangan fungsi.  Untuk memeriksa, jalankan saja di jendela interaktif! </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1>  Sumber Daya Tambahan </h1><br><p>  Ada banyak tutorial untuk F #, termasuk materi untuk mereka yang datang dengan pengalaman C # atau Java.  Tautan berikut mungkin berguna saat Anda masuk lebih dalam ke F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk Kesenangan dan Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar X dalam Y Menit: F #</a> </li></ul><br><p>  Beberapa cara lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mulai belajar F #</a> juga dijelaskan. </p><br><p>  Akhirnya, komunitas F # sangat ramah pemula.  Ada obrolan yang sangat aktif di Slack, didukung oleh F # Software Foundation, dengan kamar pemula yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung dengan bebas</a> .  Kami sangat menyarankan Anda melakukan ini! </p><br><p>  Jangan lupa untuk mengunjungi situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas berbahasa Rusia F #</a> !  Jika Anda memiliki pertanyaan tentang belajar bahasa, dengan senang hati kami akan membahasnya di ruang obrolan: </p><br><ul><li>  kamar <code>#ru_general</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol di Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol dalam gitter</a> </li></ul><br><h2>  Tentang penulis terjemahan </h2><br><p>  Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Perubahan terjemahan dan editorial dilakukan oleh upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas pengembang F # berbahasa Rusia</a> .  Kami juga berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@schvepsss</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@shwars</em></a> karena telah menyiapkan artikel ini untuk dipublikasikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422115/">https://habr.com/ru/post/id422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422099/index.html">Operator besar akan menghasilkan "Hukum Musim Semi" dengan menyediakan layanan hosting untuk operator kecil</a></li>
<li><a href="../id422103/index.html">Mengapa seorang programmer harus bisa menulis dengan baik</a></li>
<li><a href="../id422107/index.html">Meningkatkan pengembangan: dari mulai hingga ratusan insinyur</a></li>
<li><a href="../id422109/index.html">Firefox akan memblokir pelacakan pengguna secara default</a></li>
<li><a href="../id422113/index.html">Fintech Digest: Bank Sentral akan melacak korban hacker, Rusia akan menerima peringkat kredit, Yahoo Finance dan perdagangan crypto</a></li>
<li><a href="../id422119/index.html">Toolkit Pengembang Game Indie</a></li>
<li><a href="../id422121/index.html">Bagaimana berangkat ke Jerman untuk belajar dan bekerja pada contoh emigrasi saya</a></li>
<li><a href="../id422123/index.html">Cara berhenti gagal dan mulai melakukan kilas balik normal</a></li>
<li><a href="../id422125/index.html">SENS Diagnostics. Biomarker agregat protein</a></li>
<li><a href="../id422127/index.html">Persetan dengan alasan. Terkadang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>