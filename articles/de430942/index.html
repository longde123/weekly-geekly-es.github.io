<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≤ üè≠ üèîÔ∏è Julia. Skripte und Parsing-Befehlszeilenargumente üôÜüèæ üïµüèº üïú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir besch√§ftigen uns weiterhin mit der Programmiersprache Julia. Da f√ºr eine Sprache, die sich auf Datenanalyse und -verarbeitung konzentriert, ledigl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia. Skripte und Parsing-Befehlszeilenargumente</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430942/"><p><img src="https://habrastorage.org/webt/pi/ts/0a/pits0aw00iivzdctpqqr82w5hww.png"><br>  Wir besch√§ftigen uns weiterhin mit der Programmiersprache Julia.  Da f√ºr eine Sprache, die sich auf Datenanalyse und -verarbeitung konzentriert, lediglich ein Stapelbetriebsmodus erforderlich ist, sollten Sie die Funktionen zum Implementieren von Skripten in der Sprache Julia und zum √úbergeben von Argumenten √ºber die Befehlszeile ber√ºcksichtigen.  Dieses Thema mag f√ºr jemanden banal erscheinen, aber angesichts der Neuheit der Sprache hoffe ich, dass ein kleiner √úberblick √ºber die in Julia vorgestellten Methoden zum Parsen von Befehlszeilenargumenten und -bibliotheken weiterhin n√ºtzlich ist. </p><a name="habracut"></a><br><p>  Zun√§chst ein paar Worte dar√ºber, wie das Skript aufgebaut ist.  Jedes Skript beginnt mit einer Zeile in einem speziellen Format, das den Interpreter angibt.  Die Zeile beginnt mit einer Sequenz namens Shebang.  F√ºr Julia lautet diese Zeile: </p><br><pre><code class="plaintext hljs">#!/usr/bin/env julia</code> </pre> <br><p>  Nat√ºrlich k√∂nnen Sie dies nicht tun, aber dann m√ºssen Sie das Skript mit dem folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">julia .jl</code> </pre> <br><p>  Au√üerdem muss jedes Skript mit einem Zeilenumbruchzeichen enden.  Dies ist eine Anforderung des POSIX-Standards, der sich aus der Definition einer Zeichenfolge als Folge von Zeichen ergibt, die durch ein Zeilenumbruchzeichen abgeschlossen werden. </p><br><p>  Damit das Skript direkt ausgef√ºhrt werden kann, muss es das <code>executable</code> Attribut haben.  Sie k√∂nnen ein solches Attribut im Terminal mit dem folgenden Befehl hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">chmod +x .jl</code> </pre> <br><p>  Diese Regeln gelten f√ºr alle modernen Betriebssysteme, au√üer m√∂glicherweise MS Windows. </p><br><h2 id="massiv-args">  ARGS-Array </h2><br><p>  Fahren wir mit der ersten Option zum √úbergeben von Parametern fort.  Befehlszeilenargumente sind im Julia-Skript √ºber die Array-Konstante Base.ARGS verf√ºgbar.  Bereiten wir das einfachste Skript vor: </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia @show typeof(ARGS) @show ARGS</code> </pre> <br><p>  Dieses Skript druckt einfach den Typ und den Inhalt des ARGS-Arrays auf die Konsole. </p><br><p>  Sehr oft wird der Dateiname als Befehlszeilenargumente √ºbergeben.  Und hier gibt es eine Besonderheit bei der Verarbeitung einer als Argument √ºbergebenen Dateivorlage.  F√ºhren Sie beispielsweise unser Skript mit dem Befehl <code>./args.jl *.jl</code> und erhalten Sie: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl *.jl typeof(ARGS) = Array{String,1} ARGS = ["argparse.jl", "args.jl", "docopt.jl"]</code> </pre><br><p>  Und jetzt √§ndern wir den Befehlszeilenparameter ein wenig und umgeben die Maske mit Anf√ºhrungszeichen: <br>  <code>./args.jl "*.jl"</code> .  Als Ergebnis erhalten wir: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl "*.jl" typeof(ARGS) = Array{String,1} ARGS = ["*.jl"]</code> </pre> <br><p>  Wir sehen den offensichtlichen Unterschied.  Im ersten Fall haben wir ein Array mit den Namen aller Dateien erhalten, die sich im selben Verzeichnis befinden.  Im zweiten Fall ist dies nur dieselbe Maske, die als Argument an die Befehlszeile √ºbergeben wurde.  Der Grund f√ºr dieses unterschiedliche Verhalten des Skripts liegt darin, dass der Bash-Interpreter (sowie diejenigen in seiner N√§he), von denen aus das Skript ausgef√ºhrt wurde, Dateinamenvorlagen erkennt.  Weitere finden Sie in der Suchmaschine f√ºr "Bash Pattern Matching" oder "Bash Wildcards".  Und alles in allem hei√üt es Globs. </p><br><p>  Unter den Vorlagen ist es m√∂glich, mehrere Zeichen zu maskieren - *, ein Zeichen zu maskieren -? .. Suche nach Bereich [...] und sogar die M√∂glichkeit, komplexe Kombinationen anzugeben: </p><br><pre> <code class="plaintext hljs">&gt;./args.jl {args,doc}* typeof(ARGS) = Array{String,1} ARGS = ["args.jl", "docopt.jl"]</code> </pre> <br><p>  Weitere Informationen finden Sie in der Zusammenfassung der GNU / Linux-Befehlszeilentools. </p><br><p>  Wenn wir aus irgendeinem Grund den von bash bereitgestellten Globs-Mechanismus nicht verwenden m√∂chten, k√∂nnen Sie Dateien anhand der Maske bereits im Skript mithilfe des Globs.jl-Pakets finden. <br>  Der folgende Code konvertiert alles, was in der Argumentzeichenfolge gefunden wird, in ein einzelnes Array von Dateinamen.  Das hei√üt, unabh√§ngig davon, ob der Benutzer die Maske in Anf√ºhrungszeichen ohne Anf√ºhrungszeichen angegeben oder einfach die Namen vorhandener oder nicht vorhandener Dateien aufgelistet hat, verbleiben nur die Namen der tats√§chlichen Dateien oder Verzeichnisse im resultierenden <code>filelist</code> . </p><br><pre> <code class="plaintext hljs">using Glob filelist = unique(collect(Iterators.flatten(map(arg -&gt; glob(arg), ARGS))))</code> </pre> <br><p>  Diese einfachen Beispiele sind in der Tat eine Demonstration der Verwendung des ARGS-Arrays, bei dem der Programmierer die gesamte Logik zum Parsen von Argumenten implementiert.  Dieser Ansatz wird h√§ufig verwendet, wenn die Argumentation √§u√üerst einfach ist.  Zum Beispiel eine Liste von Dateinamen.  Oder eine oder zwei Optionen, die durch einfache Zeichenfolgenoperationen behandelt werden k√∂nnen.  Der Zugriff auf ARGS-Elemente ist der gleiche wie auf Elemente eines anderen Arrays.  Denken Sie nur daran, dass der Index des ersten Elements des Arrays in Julia 1 ist. </p><br><h2 id="paket-argparsejl">  Paket ArgParse.jl </h2><br><p>  Es ist ein flexibles Tool zum Beschreiben von Attributen und Optionen der Befehlszeile, ohne dass eine Parsing-Logik implementiert werden muss. <br>  Wir werden ein leicht modifiziertes Beispiel aus der Paketdokumentation verwenden - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://carlobaldassi.github.io/ArgParse.jl/stable/</a> : </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia using ArgParse function parse_commandline() s = ArgParseSettings() @add_arg_table s begin "--opt1" help = "an option with an argument" "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0 "--flag1" help = "an option without argument, ie a flag" action = :store_true "arg1" help = "a positional argument" required = true end return parse_args(s) end function main() @show parsed_args = parse_commandline() println("Parsed args:") for (arg,val) in parsed_args print(" $arg =&gt; ") show(val) println() end end main()</code> </pre> <br><p>  Wenn wir dieses Skript ohne Argumente ausf√ºhren, erhalten wir die Ausgabe von Referenzinformationen zu ihrer Zusammensetzung: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl required argument arg1 was not provided usage: argparse.jl [--opt1 OPT1] [-o OPT2] [--flag1] arg1</code> </pre> <br><p>  Dar√ºber hinaus sehen wir in eckigen Klammern optionale Argumente.  W√§hrend das als <code>arg1</code> gekennzeichnete <code>arg1</code> ( <code>arg1</code> was wir es ersetzen) obligatorisch ist. </p><br><p>  F√ºhren Sie es erneut aus, geben Sie jedoch das erforderliche Attribut <code>arg1</code> . </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl test parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;false,"arg1"=&gt;"test","opt1"=&gt;nothing,"opt2"=&gt;0) Parsed args: flag1 =&gt; false arg1 =&gt; "test" opt1 =&gt; nothing opt2 =&gt; 0</code> </pre> <br><p>  Wir k√∂nnen sehen, dass <code>parsed_args</code> ein assoziatives Array ist, bei dem die Schl√ºssel die Namen der Attribute gem√§√ü der in der Funktion <code>parse_commandline</code> abgegebenen Deklaration sind und deren Werte standardm√§√üig festgelegt oder als Werte der Befehlszeilenargumente √ºbergeben wurden.  Dar√ºber hinaus sind die Werte von dem Typ, der in der Deklaration explizit angegeben wird. </p><br><p>  Argumente werden mit dem Makro <code>@add_arg_table</code> .  Es ist m√∂glich, Optionen zu deklarieren: </p><br><pre> <code class="plaintext hljs"> "--opt2", "-o" help = "another option with an argument" arg_type = Int default = 0</code> </pre> <br><p>  Oder Argumente </p><br><pre> <code class="plaintext hljs"> "arg1" help = "a positional argument" required = true</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Optionen angegeben werden, die die vollst√§ndige und die kurze Form angeben (gleichzeitig <code>--opt2</code> und <code>-o</code> ).  Oder nur in einer einzigen Form.  Der Typ wird im Feld <code>arg_type</code> angegeben.  Der Standardwert kann mit <code>default = ...</code> eingestellt werden <code>default = ...</code>  Eine Alternative zum Standardwert besteht darin, ein Argument zu erfordern - <code>required = true</code> . <br>  Es ist m√∂glich, eine automatische Aktion zu deklarieren, z. B. je nach Vorhandensein oder Fehlen eines Arguments <code>true</code> oder <code>false</code> zuzuweisen.  Dies geschieht mit <code>action = :store_true</code> </p><br><pre> <code class="plaintext hljs"> "--flag1" help = "an option without argument, ie a flag" action = :store_true</code> </pre> <br><p>  Das <code>help</code> enth√§lt den Text, der in der Eingabeaufforderung in der Befehlszeile angezeigt wird. <br>  Wenn wir beim Start alle Attribute angeben, erhalten wir: </p><br><pre> <code class="plaintext hljs">&gt;./argparse.jl --opt1 "2+2" --opt2 "4" somearg --flag parsed_args = parse_commandline() = Dict{String,Any}("flag1"=&gt;true,"arg1"=&gt;"somearg","opt1"=&gt;"2+2","opt2"=&gt;4) Parsed args: flag1 =&gt; true arg1 =&gt; "somearg" opt1 =&gt; "2+2" opt2 =&gt; 4</code> </pre> <br><p>  Zum Debuggen von der Atom / Juno-IDE k√∂nnen Sie in den ersten Zeilen des Skripts den folgenden, etwas schmutzigen, aber funktionierenden Code hinzuf√ºgen, um das ARGS-Array zu initialisieren. </p><br><pre> <code class="plaintext hljs">if (Base.source_path() != Base.basename(@__FILE__)) vcat(Base.ARGS, ["--opt1", "2+2", "--opt2", "4", "somearg", "--flag"] ) end</code> </pre> <br><p>  Das Makro <code>@__FILE__</code> ist der Name der Datei, in der das Makro bereitgestellt wird.  Dieser Name f√ºr REPL unterscheidet sich vom Namen der aktuellen Programmdatei, die √ºber <code>Base.source_path()</code> abgerufen wurde.  Es ist unm√∂glich, die <code>Base.ARGS</code> Array- <code>Base.ARGS</code> anderen Wert zu initialisieren. <code>Base.ARGS</code> k√∂nnen Sie jedoch neue Zeilen hinzuf√ºgen, da das Array selbst keine Konstante ist.  Ein Array ist eine Spalte f√ºr Julia, daher verwenden wir <code>vcat</code> (vertikale Verkettung). </p><br><p>  In den Einstellungen des Juno-Editors k√∂nnen Sie jedoch die Argumente f√ºr die Ausf√ºhrung des Skripts festlegen.  Sie m√ºssen jedoch jedes Mal f√ºr jedes debuggte Skript einzeln ge√§ndert werden. </p><br><h2 id="paket-docoptjl">  Paket DocOpt.jl </h2><br><p>  Diese Option ist eine Implementierung des docopt-Markup-Sprachansatzes - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://docopt.org/</a> .  Die Hauptidee dieser Sprache ist eine deklarative Beschreibung von Optionen und Argumenten in einer Form, die auch eine interne Beschreibung eines Skripts sein kann.  Eine spezielle Vorlagensprache wird verwendet. </p><br><p>  Wir werden ein Beispiel aus der Dokumentation f√ºr dieses Paket <a href="">https://github.com/docopt/DocOpt.jl verwenden</a> </p><br><pre> <code class="plaintext hljs">#!/usr/bin/env julia doc = """Naval Fate. Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version Options: -h --help Show this screen. --version Show version. --speed=&lt;kn&gt; Speed in knots [default: 10]. --moored Moored (anchored) mine. --drifting Drifting mine. """ using DocOpt # import docopt function args = docopt(doc, version=v"2.0.0") @show args</code> </pre> <br><p>  Die Notation <code>doc = ...</code> ist die Erstellung der Julia- <code>doc</code> , die die gesamte Deklaration f√ºr docopt enth√§lt.  Das Ergebnis der Ausf√ºhrung in der Befehlszeile ohne Argumente lautet: </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;] naval_fate.jl ship shoot &lt;x&gt; &lt;y&gt; naval_fate.jl mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting] naval_fate.jl -h | --help naval_fate.jl --version</code> </pre><br><p>  Wenn wir den Hinweis verwenden und versuchen, ein neues Schiff zu erstellen, erhalten wir einen Ausdruck des assoziativen <code>args</code> Arrays, das durch das Parsen der Befehlszeile generiert wurde </p><br><pre> <code class="plaintext hljs">&gt;./docopt.jl ship new Bystriy args = Dict{String,Any}( "remove"=&gt;false, "--help"=&gt;false, "&lt;name&gt;"=&gt;["Bystriy"], "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "ship"=&gt;true, "new"=&gt;true, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing, "--speed"=&gt;"10")</code> </pre> <br><p>  Die <code>docopt</code> Funktion <code>docopt</code> wie <code>docopt</code> deklariert: </p><br><pre> <code class="plaintext hljs">docopt(doc::AbstractString, argv=ARGS; help=true, version=nothing, options_first=false, exit_on_error=true)</code> </pre> <br><p>  Die benannten Argumente <code>help</code> , <code>version</code> , <code>oprtions_first</code> , <code>exit_on_error</code> geben <code>exit_on_error</code> das Verhalten des Argumentbefehlsparsers an.  Im Falle von Fehlern - um die Ausf√ºhrung abzuschlie√üen, geben Sie in der Versionsanforderung den hier ersetzten Wert <code>version=‚Ä¶</code> in der Anforderung <code>-h</code> zur√ºck - geben Sie Hilfe aus.  <code>options_first</code> verwendet, um anzugeben, dass Optionen vor Positionsargumenten stehen sollen. </p><br><p>  Schauen wir uns nun diese deklarative Sprache und die Reaktion des Argumentparsers auf die eingegebenen Werte genauer an. </p><br><p>  Die Deklaration beginnt mit einem beliebigen Text, der zus√§tzlich zum Text f√ºr die Befehlszeile Teil der Dokumentation des Skripts selbst sein kann.  Das Dienstwort "Verwendung:" deklariert Verwendungsmuster f√ºr dieses Skript. </p><br><pre> <code class="plaintext hljs">Usage: naval_fate.jl ship new &lt;name&gt;... naval_fate.jl ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]</code> </pre> <br><p>  Argumente werden in der Form <code>&lt;name&gt;</code> , <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> deklariert.  Beachten Sie, dass diese Argumente in dem zuvor erhaltenen assoziativen Array <code>args</code> als Schl√ºssel fungieren.  Wir haben das <code>./docopt.jl ship new Bystriy</code> , um <code>./docopt.jl ship new Bystriy</code> , sodass wir die folgenden explizit initialisierten Werte erhalten haben: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  Entsprechend der docopt-Sprache werden optionale Elemente in eckigen Klammern angegeben.  Zum Beispiel <code>[--speed=&lt;kn&gt;]</code> .  Obligatorische Elemente sind in Klammern angegeben, jedoch unter bestimmten Bedingungen.  Zum Beispiel <code>(set|remove)</code> legt die Anforderung f√ºr einen von ihnen fest.  Wenn das Element ohne Klammern angegeben wird, z. B. <code>naval_fate.jl --version</code> , hei√üt es, dass in dieser bestimmten Ausf√ºhrungsoption <code>--version</code> eine erforderliche Option ist. </p><br><p>  Der n√§chste Abschnitt ist der Abschnitt mit der Optionsbeschreibung.  Es beginnt mit dem Wort "Optionen:" <br>  Optionen werden jeweils in einer separaten Zeile deklariert.  Einr√ºckungen links vom Zeilenanfang sind wichtig.  F√ºr jede Option k√∂nnen Sie das vollst√§ndige und das kurze Formular angeben.  Sowie die Beschreibung der Option, die im Tooltip angezeigt wird.  In diesem Fall sind die Optionen <code>-h | --help, --version</code>  <code>-h | --help, --version</code> automatisch erkannt.  Die Antwort darauf wird durch die Argumente an die <code>docopt</code> Funktion gegeben.  Interessant zu ber√ºcksichtigen ist die Erkl√§rung: </p><br><pre> <code class="plaintext hljs"> --speed=&lt;kn&gt; Speed in knots [default: 10].</code> </pre> <br><p>  Hier definiert die Form <code>...=&lt;kn&gt;</code> das Vorhandensein eines Wertes und <code>[default: 10]</code> definiert den Standardwert.  Wir wenden uns wieder den Werten zu, die in <code>args</code> : </p><br><pre> <code class="plaintext hljs">"--speed"=&gt;"10"</code> </pre> <br><p>  Der grundlegende Unterschied zum ArgParse-Paket besteht beispielsweise darin, dass die Werte nicht eingegeben werden.  Das hei√üt, der <code>default: 10</code> wird als Zeichenfolge "10" festgelegt. <br>  Bei den anderen Argumenten, die als Ergebnis der Analyse der Argumente in Argumenten dargestellt werden, sollten Sie auf ihre Werte achten: </p><br><pre> <code class="plaintext hljs"> "remove"=&gt;false, "--help"=&gt;false, "--drifting"=&gt;false, "mine"=&gt;false, "move"=&gt;false, "--version"=&gt;false, "--moored"=&gt;false, "&lt;x&gt;"=&gt;nothing, "shoot"=&gt;false, "set"=&gt;false, "&lt;y&gt;"=&gt;nothing,</code> </pre> <br><p>  Das hei√üt, absolut alle Elemente der Vorlage, die in der docopt-Deklaration f√ºr alle Anwendungsf√§lle angegeben sind, werden als Ergebnis einer Analyse mit den urspr√ºnglichen Namen dargestellt.  Alle optionalen Argumente, die nicht in der Befehlszeile vorhanden waren, sind hier falsch.  Die Argumente <code>&lt;x&gt;</code> , <code>&lt;y&gt;</code> ebenfalls in der Startzeile und haben den Wert nichts.  Andere Argumente, f√ºr die das Analysemuster √ºbereinstimmte, erhielten wahre Werte: </p><br><pre> <code class="plaintext hljs"> "ship"=&gt;true, "new"=&gt;true,</code> </pre> <br><p>  Und wir haben bereits spezifische Werte f√ºr die folgenden Elemente der Vorlage erhalten: </p><br><pre> <code class="plaintext hljs"> "&lt;name&gt;"=&gt;["Bystriy"], "--speed"=&gt;"10"</code> </pre> <br><p>  Der erste Wert wurde explizit in der Befehlszeile als Argumentersetzung festgelegt, und der zweite Wert war eine Option mit einem Standardwert. <br></p><p>  Beachten Sie auch, dass der Name des aktuellen Skripts automatisch berechnet werden kann. <br>  Zum Beispiel k√∂nnen wir eingeben: </p><br><pre> <code class="plaintext hljs">doc = """Naval Fate. Usage: $(Base.basename(@__FILE__)) ship new &lt;name&gt;‚Ä¶ """</code> </pre> <br><p>  Eine zus√§tzliche Empfehlung zum Platzieren des Befehlszeilenargument-Parsers besteht darin, ihn ganz am Anfang der Datei zu platzieren.  Ein unangenehmes Merkmal von Julia ist im Moment eine ziemlich lange Verbindung von Modulen.  Zum Beispiel <code>using Plots; using DataFrames</code>  <code>using Plots; using DataFrames</code> kann ein Skript <code>using Plots; using DataFrames</code> werden, das einige Sekunden wartet.  Dies ist kein Problem f√ºr serverseitige Skripts mit einem Ladevorgang, aber es √§rgert Benutzer, die nur einen Hinweis f√ºr Befehlszeilenargumente sehen m√∂chten.  Aus diesem Grund m√ºssen Sie zuerst Hilfe ausgeben und die Befehlszeilenargumente √ºberpr√ºfen. Anschlie√üend m√ºssen Sie die f√ºr die Arbeit erforderlichen Bibliotheken herunterladen. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel gibt nicht vor, alle Methoden zum Parsen von Argumenten in Julia zu ber√ºcksichtigen.  Die betrachteten Optionen decken jedoch tats√§chlich drei m√∂gliche Optionen ab.  Vollst√§ndig manuelle Analyse des <code>ARGS</code> Arrays.  Streng deklarierte, aber automatisch analysierte Argumente in ArgParse.  Und eine vollst√§ndig deklarative, wenn auch nicht strenge Form von docopt.  Die Wahl des Anwendungsfalls h√§ngt vollst√§ndig von der Komplexit√§t der analysierten Argumente ab.  Die Option mit docopt scheint am einfachsten zu verwenden, erfordert jedoch eine explizite Typkonvertierung f√ºr die Werte der empfangenen Argumente.  Wenn das Skript jedoch nichts anderes als den Dateinamen akzeptiert, k√∂nnen Sie die Hilfe mit der √ºblichen <code>println("Run me with file name")</code> und die Dateinamen wie gezeigt direkt aus <code>ARGS</code> analysieren im ersten Abschnitt. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="">https://github.com/vtjnash/Glob.jl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://argparsejl.readthedocs.io/en/latest/argparse.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/carlobaldassi/ArgParse.jl/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://docopt.org/</a> </li><li>  <a href="">https://github.com/docopt/DocOpt.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430942/">https://habr.com/ru/post/de430942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430932/index.html">Hacker haben einer russischen Bank mehr als 21 Millionen Rubel gestohlen</a></li>
<li><a href="../de430934/index.html">Asterisk Dialplan-Erweiterungsmaskengenerator</a></li>
<li><a href="../de430936/index.html">DEFCON 21. DNS-Konferenzen k√∂nnen gesundheitssch√§dlich sein. Teil 2</a></li>
<li><a href="../de430938/index.html">So erhalten Sie die ersten Auftr√§ge im Design, wenn kein Portfolio und keine Erfahrung vorhanden sind</a></li>
<li><a href="../de430940/index.html">SDK f√ºr Sie, SDK f√ºr mich, SDK f√ºr alle! Wie erstelle ich ein SDK und warum wird es ben√∂tigt?</a></li>
<li><a href="../de430944/index.html">Die NASA hat die Teilnehmer f√ºr ihren Mini-Moon-Rover-Wettbewerb ausgew√§hlt</a></li>
<li><a href="../de430948/index.html">Das Kommunikationsministerium schl√§gt vor, die Kontrolle √ºber personenbezogene Daten zu versch√§rfen</a></li>
<li><a href="../de430950/index.html">Modernes Bauen</a></li>
<li><a href="../de430952/index.html">Elektroautos und Hybridautos m√ºssen zus√§tzliche Ger√§usche machen: Warum wird das ben√∂tigt?</a></li>
<li><a href="../de430954/index.html">Qt Everywhere: WebAssembly und WebGL-Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>