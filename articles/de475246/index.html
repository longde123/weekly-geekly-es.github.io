<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèæ üòÄ üÖ±Ô∏è Asynchrone Python-Programmierung: Ein kurzer √úberblick ü§∞üèΩ üåå üë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn es um die Programmausf√ºhrung geht, bedeutet ‚Äûasynchrone Ausf√ºhrung‚Äú eine Situation, in der das Programm nicht auf den Abschluss eines bestimmten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Python-Programmierung: Ein kurzer √úberblick</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/475246/">  Wenn es um die Programmausf√ºhrung geht, bedeutet ‚Äûasynchrone Ausf√ºhrung‚Äú eine Situation, in der das Programm nicht auf den Abschluss eines bestimmten Prozesses wartet, sondern unabh√§ngig davon weiterarbeitet.  Ein Beispiel f√ºr asynchrone Programmierung ist ein Dienstprogramm, das asynchron arbeitet und in eine Protokolldatei schreibt.  Obwohl ein solches Dienstprogramm m√∂glicherweise fehlschl√§gt (z. B. weil nicht gen√ºgend Speicherplatz vorhanden ist), funktioniert es in den meisten F√§llen ordnungsgem√§√ü und kann in verschiedenen Programmen verwendet werden.  Sie k√∂nnen sie anrufen, die Daten f√ºr die Aufzeichnung weitergeben und danach ihre eigene Arbeit fortsetzen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ep/bw/pt/epbwpti391hcs-adu7jr0hcpqrm.jpeg"></a> <br><br>  Die Verwendung asynchroner Mechanismen beim Schreiben eines bestimmten Programms bedeutet, dass dieses Programm schneller ausgef√ºhrt wird als ohne Verwendung solcher Mechanismen.  Gleichzeitig sollte das, was asynchron gestartet werden soll, wie z. B. ein Dienstprogramm f√ºr die Protokollierung, unter Ber√ºcksichtigung von Notf√§llen geschrieben werden.  Beispielsweise kann ein Dienstprogramm zur Protokollierung, wenn der Speicherplatz knapp wird, die Protokollierung einfach stoppen und das Hauptprogramm nicht mit einem Fehler "abst√ºrzen". <br><br>  Bei der asynchronen Codeausf√ºhrung wird dieser Code normalerweise in einem separaten Thread ausgef√ºhrt.  Dies ist - wenn wir √ºber ein System mit einem Single-Core-Prozessor sprechen.  Auf Systemen mit Mehrkernprozessoren kann ein solcher Code durchaus von einem Prozess ausgef√ºhrt werden, der einen separaten Kern verwendet.  Ein Single-Core-Prozessor kann zu einem bestimmten Zeitpunkt nur einen Befehl lesen und ausf√ºhren.  Es ist wie B√ºcher zu lesen.  Sie k√∂nnen nicht zwei B√ºcher gleichzeitig lesen. <br><br>  Wenn Sie ein Buch lesen und jemand anderes Ihnen ein anderes Buch gibt, k√∂nnen Sie dieses zweite Buch nehmen und anfangen, es zu lesen.  Aber der erste muss verschoben werden.  Die Ausf√ºhrung von Code mit mehreren Threads erfolgt nach demselben Prinzip.  Und wenn mehrere Ihrer Exemplare mehrere B√ºcher gleichzeitig lesen w√ºrden, w√ºrde dies der Funktionsweise von Multiprozessorsystemen √§hneln. <br><a name="habracut"></a><br>  Wenn es auf einem Single-Core-Prozessor sehr schnell ist, zwischen Aufgaben zu wechseln, die unterschiedliche Rechenleistung erfordern (z. B. zwischen bestimmten Berechnungen und dem Lesen von Daten von einer Festplatte), hat man m√∂glicherweise das Gef√ºhl, dass ein einzelner Prozessorkern mehrere Aufgaben gleichzeitig ausf√ºhrt.  Dies passiert beispielsweise, wenn Sie versuchen, mehrere Websites gleichzeitig in einem Browser zu √∂ffnen.  Wenn der Browser zum Laden jeder Seite einen separaten Stream verwendet, erfolgt alles viel schneller als wenn diese Seiten einzeln geladen w√ºrden.  Das Laden einer Seite ist keine so schwierige Aufgabe, dass die Ressourcen des Systems nicht voll ausgesch√∂pft werden. Infolgedessen ist das gleichzeitige Starten mehrerer solcher Aufgaben ein sehr effektiver Schritt. <br><br><h2>  <font color="#3AC1EF">Asynchrone Python-Programmierung</font> </h2><br>  Urspr√ºnglich verwendete Python Generator-basierte Coroutinen, um asynchrone Programmieraufgaben zu l√∂sen.  Dann erschien in Python 3.4 das <code>asyncio</code> Modul (manchmal wird sein Name als asynchrone <code>asyncio</code> geschrieben), das asynchrone Programmiermechanismen implementiert.  In Python 3.5 wurde das async / await-Konstrukt eingef√ºhrt. <br><br>  Um eine asynchrone Entwicklung in Python durchf√ºhren zu k√∂nnen, m√ºssen Sie sich mit einigen Konzepten befassen.  Das sind Coroutine und Aufgabe. <br><br><h2>  <font color="#3AC1EF">Coroutinen</font> </h2><br>  Normalerweise ist Coroutine eine asynchrone Funktion.  Coroutine kann auch ein Objekt sein, das von einer Coroutine-Funktion zur√ºckgegeben wird. <br><br>  Wenn beim Deklarieren einer Funktion angegeben wird, dass sie asynchron ist, k√∂nnen Sie sie mit dem Schl√ºsselwort <code>await</code> aufrufen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre> <br>  Solch eine Konstruktion bedeutet, dass das Programm ausgef√ºhrt wird, bis es auf einen Warte-Ausdruck st√∂√üt, wonach es die Funktion aufruft und ihre Ausf√ºhrung anh√§lt, bis die Arbeit der aufgerufenen Funktion abgeschlossen ist.  Danach k√∂nnen auch andere Coroutinen starten. <br><br>  Das Anhalten eines Programms bedeutet, dass die Steuerung zur Ereignisschleife zur√ºckkehrt.  Bei Verwendung des <code>asyncio</code> Moduls f√ºhrt die Ereignisschleife alle asynchronen Aufgaben, E / A- <code>asyncio</code> und Unterprozesse aus.  In den meisten F√§llen werden Tasks zum Ausf√ºhren von corutin verwendet. <br><br><h2>  <font color="#3AC1EF">Die Aufgaben</font> </h2><br>  Mit Aufgaben k√∂nnen Sie Coroutinen in einer Ereignisschleife ausf√ºhren.  Dies vereinfacht die Ausf√ºhrungskontrolle mehrerer Coroutinen.  Hier ist ein Beispiel, das Koroutinen und Aufgaben verwendet.  Beachten Sie, dass Entit√§ten, die mit dem Konstrukt <code>async def</code> deklariert wurden, Coroutinen sind.  Dieses Beispiel stammt aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen</a> Python- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">say_after</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delay, what)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(delay)    print(what) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    task1 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>))    task2 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>))    print(<span class="hljs-string"><span class="hljs-string">f"started at </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{time.strftime(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'%X'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">"</span></span>)    <span class="hljs-comment"><span class="hljs-comment">#     (      #  2 .)    await task1    await task2    print(f"finished at {time.strftime('%X')}") asyncio.run(main())</span></span></code> </pre> <br>  Die Funktion <code>say_after()</code> hat das <code>async</code> Pr√§fix, daher haben wir eine Coroutine.  Wenn wir ein wenig von diesem Beispiel abweichen, k√∂nnen wir sagen, dass diese Funktion folgenderma√üen aufgerufen werden kann: <br><br><pre> <code class="python hljs">    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>)</code> </pre> <br>  Bei diesem Ansatz werden die Coroutinen jedoch nacheinander aufgerufen und es dauert ungef√§hr 3 Sekunden, bis sie abgeschlossen sind.  In unserem Beispiel werden sie wettbewerbsf√§hig eingef√ºhrt.  F√ºr jeden von ihnen wird eine Aufgabe verwendet.  Dadurch betr√§gt die Ausf√ºhrungszeit des gesamten Programms ca. 2 Sekunden.  Damit ein solches Programm funktioniert, reicht es nicht aus, die <code>main()</code> Funktion mit dem <code>async</code> .  In solchen Situationen m√ºssen Sie das <code>asyncio</code> Modul verwenden. <br><br>  Wenn Sie den Beispielcode ausf√ºhren, wird auf dem Bildschirm ein Text √§hnlich dem folgenden angezeigt: <br><br><pre> <code class="python hljs">started at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">39</span></span> hello world finished at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span></code> </pre> <br>  Beachten Sie, dass sich die Zeitstempel in der ersten und letzten Zeile um 2 Sekunden unterscheiden.  Wenn Sie dieses Beispiel mit einem sequentiellen Aufruf von corutin ausf√ºhren, betr√§gt die Differenz zwischen den Zeitstempeln 3 Sekunden. <br><br><h2>  <font color="#3AC1EF">Beispiel</font> </h2><br>  In diesem Beispiel wird die Anzahl der Operationen bestimmt, die erforderlich sind, um die Summe von zehn Elementen einer Folge von Zahlen zu berechnen.  Die Berechnungen beginnen am Ende der Sequenz.  Eine rekursive Funktion beginnt mit der Nummer 10 und ruft sich dann selbst mit den Nummern 9 und 8 auf. Dabei wird addiert, was zur√ºckgegeben wird.  Dies wird fortgesetzt, bis die Berechnungen abgeschlossen sind.  Als Ergebnis stellt sich beispielsweise heraus, dass die Summe einer Folge von Zahlen von 1 bis 10 55 ist. Gleichzeitig ist unsere Funktion sehr ineffizient, hier wird die <code>time.sleep(0.1)</code> verwendet. <br><br>  Hier ist der Funktionscode: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n start=time.time() <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count count = <span class="hljs-number"><span class="hljs-number">0</span></span> result = fib(<span class="hljs-number"><span class="hljs-number">10</span></span>) print(result,count) print(time.time()-start)</code> </pre> <br>  Was passiert, wenn Sie diesen Code mithilfe asynchroner Mechanismen umschreiben und <code>asyncio.gather</code> das Konstrukt <code>asyncio.gather</code> anwenden, das f√ºr die Ausf√ºhrung von zwei Aufgaben verantwortlich ist und auf deren Abschluss wartet? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio,time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    event_loop = asyncio.get_event_loop()    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        task1 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>))        task2 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.gather(task1,task2)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task1.result()+task2.result()    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n</code> </pre> <br>  Tats√§chlich arbeitet dieses Beispiel sogar ein wenig langsamer als das vorherige, da alles in einem Thread ausgef√ºhrt wird und Aufrufe von <code>create_task</code> , <code>gather</code> und anderen auf diese Weise eine zus√§tzliche Belastung des Systems verursachen.  Der Zweck dieses Beispiels besteht jedoch darin, die F√§higkeit zu demonstrieren, an mehreren Aufgaben teilzunehmen und auf deren Abschluss zu warten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es gibt Situationen, in denen die Verwendung von Tasks und Corutin sehr n√ºtzlich ist: Wenn ein Programm beispielsweise eine Mischung aus Eingabe-Ausgabe und Berechnungen enth√§lt oder wenn verschiedene Berechnungen in demselben Programm ausgef√ºhrt werden, k√∂nnen Sie diese Probleme l√∂sen, indem Sie Code in einem Konkurrenzprogramm ausf√ºhren im sequentiellen Modus.  Dies hilft, die Zeit zu verk√ºrzen, die das Programm ben√∂tigt, um bestimmte Aktionen auszuf√ºhren.  Dies erlaubt jedoch beispielsweise nicht die gleichzeitige Ausf√ºhrung von Berechnungen.  Multiprocessing wird verwendet, um solche Berechnungen zu organisieren.  Dies ist ein eigenst√§ndiges gro√ües Thema. <br><br>  <b>Sehr geehrte Leser!</b>  Wie schreibt man asynchronen Python-Code? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475246/">https://habr.com/ru/post/de475246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475236/index.html">Ignoriere niemals wieder das Verst√§rkungstraining.</a></li>
<li><a href="../de475238/index.html">Blade Runner Timeline - November 2019. Hat sich die Prognose erf√ºllt?</a></li>
<li><a href="../de475240/index.html">Verwendung strenger Module in gro√üen Python-Projekten: Instagram-Erfahrung. Teil 1</a></li>
<li><a href="../de475242/index.html">Verwendung strenger Module in gro√üen Python-Projekten: Instagram-Erfahrung. Teil 2</a></li>
<li><a href="../de475244/index.html">Erwartete neue JavaScript-Funktionen, die Sie kennen sollten</a></li>
<li><a href="../de475248/index.html">Die Verwendung von Polyfills beim Schreiben browser√ºbergreifender Anwendungen</a></li>
<li><a href="../de475250/index.html">Als Redash ein Problem bemerkte und behebte, das zu einer Verschlechterung der Python-Code-Leistung f√ºhrte</a></li>
<li><a href="../de475254/index.html">AERODISK vAIR-Architektur oder Merkmale der nationalen Clusterbildung</a></li>
<li><a href="../de475260/index.html">Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zur√ºckgibt</a></li>
<li><a href="../de475262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 388 (4. - 10. November 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>