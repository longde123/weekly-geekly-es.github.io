<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏾 😀 🅱️ Asynchrone Python-Programmierung: Ein kurzer Überblick 🤰🏽 🌌 👨🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn es um die Programmausführung geht, bedeutet „asynchrone Ausführung“ eine Situation, in der das Programm nicht auf den Abschluss eines bestimmten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Python-Programmierung: Ein kurzer Überblick</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/475246/">  Wenn es um die Programmausführung geht, bedeutet „asynchrone Ausführung“ eine Situation, in der das Programm nicht auf den Abschluss eines bestimmten Prozesses wartet, sondern unabhängig davon weiterarbeitet.  Ein Beispiel für asynchrone Programmierung ist ein Dienstprogramm, das asynchron arbeitet und in eine Protokolldatei schreibt.  Obwohl ein solches Dienstprogramm möglicherweise fehlschlägt (z. B. weil nicht genügend Speicherplatz vorhanden ist), funktioniert es in den meisten Fällen ordnungsgemäß und kann in verschiedenen Programmen verwendet werden.  Sie können sie anrufen, die Daten für die Aufzeichnung weitergeben und danach ihre eigene Arbeit fortsetzen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ep/bw/pt/epbwpti391hcs-adu7jr0hcpqrm.jpeg"></a> <br><br>  Die Verwendung asynchroner Mechanismen beim Schreiben eines bestimmten Programms bedeutet, dass dieses Programm schneller ausgeführt wird als ohne Verwendung solcher Mechanismen.  Gleichzeitig sollte das, was asynchron gestartet werden soll, wie z. B. ein Dienstprogramm für die Protokollierung, unter Berücksichtigung von Notfällen geschrieben werden.  Beispielsweise kann ein Dienstprogramm zur Protokollierung, wenn der Speicherplatz knapp wird, die Protokollierung einfach stoppen und das Hauptprogramm nicht mit einem Fehler "abstürzen". <br><br>  Bei der asynchronen Codeausführung wird dieser Code normalerweise in einem separaten Thread ausgeführt.  Dies ist - wenn wir über ein System mit einem Single-Core-Prozessor sprechen.  Auf Systemen mit Mehrkernprozessoren kann ein solcher Code durchaus von einem Prozess ausgeführt werden, der einen separaten Kern verwendet.  Ein Single-Core-Prozessor kann zu einem bestimmten Zeitpunkt nur einen Befehl lesen und ausführen.  Es ist wie Bücher zu lesen.  Sie können nicht zwei Bücher gleichzeitig lesen. <br><br>  Wenn Sie ein Buch lesen und jemand anderes Ihnen ein anderes Buch gibt, können Sie dieses zweite Buch nehmen und anfangen, es zu lesen.  Aber der erste muss verschoben werden.  Die Ausführung von Code mit mehreren Threads erfolgt nach demselben Prinzip.  Und wenn mehrere Ihrer Exemplare mehrere Bücher gleichzeitig lesen würden, würde dies der Funktionsweise von Multiprozessorsystemen ähneln. <br><a name="habracut"></a><br>  Wenn es auf einem Single-Core-Prozessor sehr schnell ist, zwischen Aufgaben zu wechseln, die unterschiedliche Rechenleistung erfordern (z. B. zwischen bestimmten Berechnungen und dem Lesen von Daten von einer Festplatte), hat man möglicherweise das Gefühl, dass ein einzelner Prozessorkern mehrere Aufgaben gleichzeitig ausführt.  Dies passiert beispielsweise, wenn Sie versuchen, mehrere Websites gleichzeitig in einem Browser zu öffnen.  Wenn der Browser zum Laden jeder Seite einen separaten Stream verwendet, erfolgt alles viel schneller als wenn diese Seiten einzeln geladen würden.  Das Laden einer Seite ist keine so schwierige Aufgabe, dass die Ressourcen des Systems nicht voll ausgeschöpft werden. Infolgedessen ist das gleichzeitige Starten mehrerer solcher Aufgaben ein sehr effektiver Schritt. <br><br><h2>  <font color="#3AC1EF">Asynchrone Python-Programmierung</font> </h2><br>  Ursprünglich verwendete Python Generator-basierte Coroutinen, um asynchrone Programmieraufgaben zu lösen.  Dann erschien in Python 3.4 das <code>asyncio</code> Modul (manchmal wird sein Name als asynchrone <code>asyncio</code> geschrieben), das asynchrone Programmiermechanismen implementiert.  In Python 3.5 wurde das async / await-Konstrukt eingeführt. <br><br>  Um eine asynchrone Entwicklung in Python durchführen zu können, müssen Sie sich mit einigen Konzepten befassen.  Das sind Coroutine und Aufgabe. <br><br><h2>  <font color="#3AC1EF">Coroutinen</font> </h2><br>  Normalerweise ist Coroutine eine asynchrone Funktion.  Coroutine kann auch ein Objekt sein, das von einer Coroutine-Funktion zurückgegeben wird. <br><br>  Wenn beim Deklarieren einer Funktion angegeben wird, dass sie asynchron ist, können Sie sie mit dem Schlüsselwort <code>await</code> aufrufen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre> <br>  Solch eine Konstruktion bedeutet, dass das Programm ausgeführt wird, bis es auf einen Warte-Ausdruck stößt, wonach es die Funktion aufruft und ihre Ausführung anhält, bis die Arbeit der aufgerufenen Funktion abgeschlossen ist.  Danach können auch andere Coroutinen starten. <br><br>  Das Anhalten eines Programms bedeutet, dass die Steuerung zur Ereignisschleife zurückkehrt.  Bei Verwendung des <code>asyncio</code> Moduls führt die Ereignisschleife alle asynchronen Aufgaben, E / A- <code>asyncio</code> und Unterprozesse aus.  In den meisten Fällen werden Tasks zum Ausführen von corutin verwendet. <br><br><h2>  <font color="#3AC1EF">Die Aufgaben</font> </h2><br>  Mit Aufgaben können Sie Coroutinen in einer Ereignisschleife ausführen.  Dies vereinfacht die Ausführungskontrolle mehrerer Coroutinen.  Hier ist ein Beispiel, das Koroutinen und Aufgaben verwendet.  Beachten Sie, dass Entitäten, die mit dem Konstrukt <code>async def</code> deklariert wurden, Coroutinen sind.  Dieses Beispiel stammt aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen</a> Python- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">say_after</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delay, what)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(delay)    print(what) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    task1 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>))    task2 = asyncio.create_task(        say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>))    print(<span class="hljs-string"><span class="hljs-string">f"started at </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{time.strftime(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'%X'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">"</span></span>)    <span class="hljs-comment"><span class="hljs-comment">#     (      #  2 .)    await task1    await task2    print(f"finished at {time.strftime('%X')}") asyncio.run(main())</span></span></code> </pre> <br>  Die Funktion <code>say_after()</code> hat das <code>async</code> Präfix, daher haben wir eine Coroutine.  Wenn wir ein wenig von diesem Beispiel abweichen, können wir sagen, dass diese Funktion folgendermaßen aufgerufen werden kann: <br><br><pre> <code class="python hljs">    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'hello'</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> say_after(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>)</code> </pre> <br>  Bei diesem Ansatz werden die Coroutinen jedoch nacheinander aufgerufen und es dauert ungefähr 3 Sekunden, bis sie abgeschlossen sind.  In unserem Beispiel werden sie wettbewerbsfähig eingeführt.  Für jeden von ihnen wird eine Aufgabe verwendet.  Dadurch beträgt die Ausführungszeit des gesamten Programms ca. 2 Sekunden.  Damit ein solches Programm funktioniert, reicht es nicht aus, die <code>main()</code> Funktion mit dem <code>async</code> .  In solchen Situationen müssen Sie das <code>asyncio</code> Modul verwenden. <br><br>  Wenn Sie den Beispielcode ausführen, wird auf dem Bildschirm ein Text ähnlich dem folgenden angezeigt: <br><br><pre> <code class="python hljs">started at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">39</span></span> hello world finished at <span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span></code> </pre> <br>  Beachten Sie, dass sich die Zeitstempel in der ersten und letzten Zeile um 2 Sekunden unterscheiden.  Wenn Sie dieses Beispiel mit einem sequentiellen Aufruf von corutin ausführen, beträgt die Differenz zwischen den Zeitstempeln 3 Sekunden. <br><br><h2>  <font color="#3AC1EF">Beispiel</font> </h2><br>  In diesem Beispiel wird die Anzahl der Operationen bestimmt, die erforderlich sind, um die Summe von zehn Elementen einer Folge von Zahlen zu berechnen.  Die Berechnungen beginnen am Ende der Sequenz.  Eine rekursive Funktion beginnt mit der Nummer 10 und ruft sich dann selbst mit den Nummern 9 und 8 auf. Dabei wird addiert, was zurückgegeben wird.  Dies wird fortgesetzt, bis die Berechnungen abgeschlossen sind.  Als Ergebnis stellt sich beispielsweise heraus, dass die Summe einer Folge von Zahlen von 1 bis 10 55 ist. Gleichzeitig ist unsere Funktion sehr ineffizient, hier wird die <code>time.sleep(0.1)</code> verwendet. <br><br>  Hier ist der Funktionscode: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n start=time.time() <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count count = <span class="hljs-number"><span class="hljs-number">0</span></span> result = fib(<span class="hljs-number"><span class="hljs-number">10</span></span>) print(result,count) print(time.time()-start)</code> </pre> <br>  Was passiert, wenn Sie diesen Code mithilfe asynchroner Mechanismen umschreiben und <code>asyncio.gather</code> das Konstrukt <code>asyncio.gather</code> anwenden, das für die Ausführung von zwei Aufgaben verantwortlich ist und auf deren Abschluss wartet? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio,time <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> count    count=count+<span class="hljs-number"><span class="hljs-number">1</span></span>    time.sleep(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)    event_loop = asyncio.get_event_loop()    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>:        task1 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>))        task2 = asyncio.create_task(fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.gather(task1,task2)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task1.result()+task2.result()    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n</code> </pre> <br>  Tatsächlich arbeitet dieses Beispiel sogar ein wenig langsamer als das vorherige, da alles in einem Thread ausgeführt wird und Aufrufe von <code>create_task</code> , <code>gather</code> und anderen auf diese Weise eine zusätzliche Belastung des Systems verursachen.  Der Zweck dieses Beispiels besteht jedoch darin, die Fähigkeit zu demonstrieren, an mehreren Aufgaben teilzunehmen und auf deren Abschluss zu warten. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es gibt Situationen, in denen die Verwendung von Tasks und Corutin sehr nützlich ist: Wenn ein Programm beispielsweise eine Mischung aus Eingabe-Ausgabe und Berechnungen enthält oder wenn verschiedene Berechnungen in demselben Programm ausgeführt werden, können Sie diese Probleme lösen, indem Sie Code in einem Konkurrenzprogramm ausführen im sequentiellen Modus.  Dies hilft, die Zeit zu verkürzen, die das Programm benötigt, um bestimmte Aktionen auszuführen.  Dies erlaubt jedoch beispielsweise nicht die gleichzeitige Ausführung von Berechnungen.  Multiprocessing wird verwendet, um solche Berechnungen zu organisieren.  Dies ist ein eigenständiges großes Thema. <br><br>  <b>Sehr geehrte Leser!</b>  Wie schreibt man asynchronen Python-Code? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475246/">https://habr.com/ru/post/de475246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475236/index.html">Ignoriere niemals wieder das Verstärkungstraining.</a></li>
<li><a href="../de475238/index.html">Blade Runner Timeline - November 2019. Hat sich die Prognose erfüllt?</a></li>
<li><a href="../de475240/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 1</a></li>
<li><a href="../de475242/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 2</a></li>
<li><a href="../de475244/index.html">Erwartete neue JavaScript-Funktionen, die Sie kennen sollten</a></li>
<li><a href="../de475248/index.html">Die Verwendung von Polyfills beim Schreiben browserübergreifender Anwendungen</a></li>
<li><a href="../de475250/index.html">Als Redash ein Problem bemerkte und behebte, das zu einer Verschlechterung der Python-Code-Leistung führte</a></li>
<li><a href="../de475254/index.html">AERODISK vAIR-Architektur oder Merkmale der nationalen Clusterbildung</a></li>
<li><a href="../de475260/index.html">Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zurückgibt</a></li>
<li><a href="../de475262/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 388 (4. - 10. November 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>