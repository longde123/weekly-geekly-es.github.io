<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë üë®üèº‚Äçüç≥ üéÄ Classifique grandes quantidades de dados no Apache Spark usando modelos arbitr√°rios de aprendizado de m√°quina ‚ùáÔ∏è üö≤ ü§æ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 2: Solu√ß√£o 
 Ol√° novamente! Hoje, continuarei minha hist√≥ria sobre como classificamos grandes quantidades de dados no Apache Spark usando modelo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classifique grandes quantidades de dados no Apache Spark usando modelos arbitr√°rios de aprendizado de m√°quina</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Parte 2: Solu√ß√£o </h2><br>  Ol√° novamente!  Hoje, continuarei minha hist√≥ria sobre como classificamos grandes quantidades de dados no Apache Spark usando modelos arbitr√°rios de aprendizado de m√°quina.  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte do artigo,</a> examinamos a declara√ß√£o do problema em si, bem como os principais problemas que surgem ao organizar a intera√ß√£o entre o cluster no qual os dados iniciais s√£o armazenados e processados ‚Äã‚Äãe o servi√ßo de classifica√ß√£o externa.  Na segunda parte, consideraremos uma das op√ß√µes para resolver esse problema usando a abordagem de Fluxos Reativos e sua implementa√ß√£o usando a biblioteca akka-streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Conceito de fluxos reativos </h3><br>  Para resolver os problemas descritos na primeira parte, voc√™ pode usar a abordagem, chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fluxos Reativos</a> .  Ele permite controlar o processo de transfer√™ncia de fluxos de dados entre os est√°gios do processamento, operando em velocidades diferentes e independentemente um do outro, sem a necessidade de buffer.  Se um dos est√°gios de processamento for mais lento que o anterior, ser√° necess√°rio sinalizar o est√°gio mais r√°pido sobre a quantidade de dados de entrada que est√° pronto para processar no momento.  Essa intera√ß√£o √© chamada de contrapress√£o.  Consiste no fato de que os est√°gios mais r√°pidos processam exatamente quantos elementos s√£o necess√°rios para o est√°gio mais lento, e n√£o mais, e liberam recursos de computa√ß√£o. <br><br>  Em geral, o Reactive Streams √© uma especifica√ß√£o para implementar o modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Publisher-Subscriber</a> .  Esta especifica√ß√£o define um conjunto de quatro interfaces (Publicador, Assinante, Processador e Assinatura) e um contrato para seus m√©todos. <br><br>  Vamos considerar essas interfaces com mais detalhes: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Existem dois lados no modelo do Publisher-Subscriber: transmitir e receber.  Ao implementar o Reactive Streams, a classe que implementa a interface do Publisher √© respons√°vel pela transfer√™ncia de dados e o Assinante √© respons√°vel pelo recebimento.  Para estabelecer uma comunica√ß√£o entre eles, o Assinante deve ser registrado no Publisher chamando seu m√©todo de assinatura.  De acordo com a especifica√ß√£o, ap√≥s registrar um Assinante, o Publisher deve chamar seus m√©todos na seguinte ordem: <br><br><ol><li>  onSubscribe.  Esse m√©todo √© chamado imediatamente ap√≥s o registro do Assinante no Publisher.  Como par√¢metro, um objeto de Assinatura √© passado a ele pelo qual o Assinante solicitar√° dados do Publisher.  Este objeto deve ser armazenado e chamado apenas no contexto deste Assinante. </li><li>  Depois que o Assinante solicitou dados do Publisher chamando o m√©todo de solicita√ß√£o no objeto de Assinatura correspondente, o Publisher pode chamar o m√©todo Subscriber onNext, passando o pr√≥ximo elemento. </li><li>  O Assinante pode chamar periodicamente o m√©todo de solicita√ß√£o na Assinatura, mas o Publisher n√£o pode chamar o m√©todo onNext mais do que o total solicitado pelo m√©todo de solicita√ß√£o. </li><li>  Se o fluxo de dados for finito, depois de passar todos os elementos pelo m√©todo onNext, o Publisher dever√° chamar o m√©todo onComplete. </li><li>  Se um erro ocorreu no Publisher e o processamento posterior dos elementos n√£o for poss√≠vel, ele dever√° chamar o m√©todo onError </li><li>  Ap√≥s chamar os m√©todos onComplete ou onError, a intera√ß√£o adicional do Publisher com o Assinante deve ser exclu√≠da. </li></ol><br>  As chamadas de m√©todo podem ser consideradas como o envio de sinais entre o Publicador e o Assinante.  O Assinante sinaliza ao Publisher quantos elementos ele est√° pronto para processar e o Publisher, por sua vez, sinaliza para ele que existe o pr√≥ximo elemento, ou que n√£o h√° mais elementos ou que ocorreu algum erro. <br><br>  Para excluir outra influ√™ncia do Publicador e do Assinante, as chamadas para todos os m√©todos que implementam interfaces do Reactive Streams devem ser n√£o-bloqueantes.  Nesse caso, a intera√ß√£o entre eles ser√° completamente ass√≠ncrona. <br><br>  Mais detalhes sobre a especifica√ß√£o para interfaces de fluxos reativos podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Assim, vinculando os iteradores originais e resultantes atrav√©s da convers√£o para o Publisher e o Subscriber, respectivamente, podemos resolver os problemas identificados na parte anterior do artigo.  O problema do estouro de buffer entre os est√°gios √© resolvido solicitando um certo n√∫mero de elementos pelo Assinante.  O problema da conclus√£o com ou sem √™xito √© resolvido enviando sinais para o Assinante atrav√©s dos m√©todos onComplete ou onError, respectivamente.  O Publisher se torna respons√°vel pelo envio desses sinais, que no nosso caso devem controlar quantas solicita√ß√µes HTTP foram enviadas e quantas delas receberam respostas.  Depois de receber a √∫ltima resposta e processar todos os resultados que vierem nela, ele dever√° enviar um sinal onComplete.  Caso uma das solicita√ß√µes falhe, ela deve enviar um sinal onError e parar de enviar outros elementos para o Assinante, al√©m de subtrair elementos do iterador original. <br><br>  O iterador resultante deve ser implementado como um Assinante.  Nesse caso, n√£o podemos ficar sem um buffer no qual os elementos ser√£o gravados quando o m√©todo onNext for chamado da interface do Assinante e subtra√≠do usando os m√©todos hasNext e next da interface do Iterator.  Como uma implementa√ß√£o de buffer, voc√™ pode usar uma fila de bloqueio, por exemplo, LinkedBlockedQueue. <br><br>  Um leitor atento far√° a pergunta imediatamente: por que a fila de bloqueio √© porque, de acordo com a especifica√ß√£o de Fluxos Reativos, a implementa√ß√£o de todos os m√©todos deve ser sem bloqueio?  Mas est√° tudo bem aqui: como estamos solicitando ao Publisher um n√∫mero estritamente definido de elementos, o m√©todo onNext ser√° chamado n√£o mais que esse n√∫mero de vezes, e a fila sempre poder√° adicionar um novo elemento sem bloquear. <br><br>  Por outro lado, o bloqueio pode ocorrer quando o m√©todo hasNext √© chamado no caso de uma fila vazia.  No entanto, est√° tudo bem: o m√©todo hasNext n√£o faz parte do contrato da interface do Assinante, √© definido na interface do Iterator, que, como explicamos anteriormente, √© uma estrutura de dados de bloqueio.  Ao chamar o pr√≥ximo m√©todo, subtra√≠mos o pr√≥ximo elemento da fila e, quando seu tamanho se torna menor que um determinado limite, precisaremos solicitar a pr√≥xima parte dos elementos atrav√©s de uma chamada para o m√©todo de solicita√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Figura 7. Intera√ß√£o ass√≠ncrona com um servi√ßo externo usando a abordagem Reactive Streams</i> <br><br>  Obviamente, nesse caso, n√£o vamos nos livrar completamente do bloqueio de chamadas.  Isso √© causado por uma incompatibilidade de paradigmas entre fluxos Reativos, que assumem intera√ß√£o completamente ass√≠ncrona, e um iterador, que deve chamar trueN ou false ao chamar o m√©todo hasNext.  No entanto, diferentemente da intera√ß√£o s√≠ncrona com um servi√ßo externo, o tempo de inatividade devido a bloqueios pode ser reduzido significativamente, aumentando a carga geral dos n√∫cleos do processador. <br><br>  Seria conveniente se os desenvolvedores do Apache Spark em vers√µes futuras implementassem um an√°logo do m√©todo mapPartitions, que funciona com o Publisher e o Subscriber.  Isso permitiria uma intera√ß√£o completamente ass√≠ncrona, eliminando assim a possibilidade de bloquear threads. <br><br><h3>  Akka-streams e akka-http como uma implementa√ß√£o da especifica√ß√£o Reactive Streams </h3><br>  Atualmente, j√° existem mais de uma d√∫zia de implementa√ß√µes da especifica√ß√£o Reactive Streams.  Uma dessas implementa√ß√µes √© o m√≥dulo akka-streams da biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">akka</a> .  No mundo da JVM, a akka se estabeleceu como um dos meios mais eficazes para escrever sistemas paralelos e distribu√≠dos.  Isso √© alcan√ßado devido ao fato de que o princ√≠pio b√°sico estabelecido em sua base √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o modelo de ator</a> , que permite escrever aplicativos altamente competitivos sem controle direto dos encadeamentos e de seus pools. <br><br>  Muita literatura foi escrita sobre a implementa√ß√£o do conceito de atores em akka, ent√£o n√£o vamos parar por aqui (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">akka</a> √© uma fonte muito boa de informa√ß√µes, eu tamb√©m recomendo o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">akka no</a> livro de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a√ß√£o</a> ).  Aqui, examinaremos mais de perto o lado tecnol√≥gico da implementa√ß√£o sob a JVM. <br><br>  Em geral, os atores n√£o existem por si mesmos, mas formam um sistema hier√°rquico.  Para criar um sistema ator, voc√™ precisa alocar recursos para ele. Portanto, a primeira etapa ao trabalhar com akka √© criar uma inst√¢ncia do objeto ActorSystem.  Quando o ActorSystem √© iniciado, √© criado um pool de encadeamentos separado, chamado expedidor, no qual todo o c√≥digo definido nos atores √© executado.  Normalmente, um √∫nico encadeamento executa o c√≥digo de v√°rios atores; no entanto, se necess√°rio, voc√™ pode configurar um expedidor separado para um grupo espec√≠fico de atores (por exemplo, para atores interagindo diretamente com uma API de bloqueio). <br><br>  Uma das tarefas mais comuns resolvidas usando atores √© o processamento seq√ºencial de fluxos de dados.  Anteriormente, para isso, era necess√°rio criar cadeias de atores manualmente e garantir que n√£o houvesse gargalos entre eles (por exemplo, se um ator processar mensagens mais rapidamente que o seguinte, ele poder√° ter um estouro da fila de mensagens recebidas, levando a um erro OutOfMemoryError). <br><br>  A partir da vers√£o 2.4, o m√≥dulo akka-streams foi adicionado ao akka, o que permite definir declarativamente o processo de processamento de dados e, em seguida, criar os atores necess√°rios para sua execu√ß√£o.  O Akka-streams tamb√©m implementa o princ√≠pio da contrapress√£o, que elimina a possibilidade de transbordar a fila de mensagens recebidas para todos os atores envolvidos no processamento. <br><br>  Os principais elementos para definir o esquema de processamento de fluxo de dados nos akka-streams s√£o Source, Flow e Sink.  Ao combin√°-los, obtemos um Gr√°fico Execut√°vel.  Para iniciar o processo de processamento, √© usado um materializador, que cria atores trabalhando de acordo com o gr√°fico definido por n√≥s (a interface do Materializer e sua implementa√ß√£o ActorMaterializer). <br><br>  Vamos considerar os est√°gios Fonte, Fluxo e Pia com mais detalhes.  Fonte define a fonte de dados.  O Akka-streams suporta mais de uma d√∫zia de maneiras diferentes de criar fontes, incluindo a partir de um iterador: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  A fonte tamb√©m pode ser obtida convertendo uma fonte existente: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Se a transforma√ß√£o for uma opera√ß√£o n√£o trivial, poder√° ser representada como uma entidade de Fluxo.  O Akka-streams suporta muitas maneiras diferentes de criar o Flow.  A maneira mais f√°cil √© criar a partir de uma fun√ß√£o: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  Combinando Fonte e Fluxo, obtemos uma nova Fonte. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  O coletor √© usado como o est√°gio final do processamento de dados.  Como no caso do Source, o akka-streams fornece mais de uma d√∫zia de op√ß√µes diferentes de coletor, por exemplo, o Sink.foreach executa uma determinada opera√ß√£o para cada elemento, o Sink.seq coleta todos os elementos em uma cole√ß√£o, etc. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Source, Flow e Sink s√£o parametrizados pelos tipos de elementos de entrada e / ou sa√≠da, respectivamente.  Al√©m disso, cada est√°gio do processamento pode ter algum resultado do seu trabalho.  Para isso, Source, Flow e Sink tamb√©m s√£o parametrizados por um tipo adicional que determina o resultado da opera√ß√£o.  Esse tipo √© chamado de tipo de valor materializado.  Se a opera√ß√£o n√£o implica a presen√ßa de um resultado adicional de seu trabalho, por exemplo, quando definimos o Flow por meio de uma fun√ß√£o, o tipo NotUsed √© usado como o valor materializado. <br><br>  Combinando a fonte, o fluxo e o coletor necess√°rios, obtemos o RunnableGraph.  √â parametrizado por um tipo, que determina o tipo de valor obtido como resultado da execu√ß√£o deste gr√°fico.  Se necess√°rio, ao combinar os est√°gios, √© poss√≠vel especificar o resultado de qual dos est√°gios ser√° o resultado de todo o gr√°fico de opera√ß√µes.  Por padr√£o, o resultado do est√°gio Origem √© obtido: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  No entanto, se o resultado do est√°gio Sink for mais importante para n√≥s, devemos indicar explicitamente isso: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Depois de definirmos o gr√°fico de opera√ß√µes, devemos execut√°-lo.  Para fazer isso, runnableGraph precisa chamar o m√©todo run.  Como par√¢metro, esse m√©todo utiliza um objeto ActorMaterializer (que tamb√©m pode estar em um escopo impl√≠cito), respons√°vel pela cria√ß√£o de atores que executam opera√ß√µes.  Normalmente, um ActorMaterializer √© criado imediatamente ap√≥s a cria√ß√£o de um ActorSystem, anexado ao seu ciclo de vida, e o utiliza para criar atores.  Considere um exemplo: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(‚Äúsystem name‚Äù) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  No caso de combina√ß√µes simples, voc√™ pode fazer isso sem criar um RunnableGraph separado, mas simplesmente conectar o Source ao Sink e inici√°-los chamando o m√©todo runWith no Source.  Este m√©todo tamb√©m pressup√µe que um objeto ActorMaterializer esteja presente no escopo impl√≠cito.  Al√©m disso, neste caso, ser√° utilizado o valor materializado definido no Sink.  Por exemplo, usando o c√≥digo a seguir, podemos converter Origem em Publisher da especifica√ß√£o de Fluxos Reativos: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Portanto, agora mostramos como voc√™ pode obter o Reactive Streams Publisher criando uma Origem a partir do iterador de origem e realizando algumas transforma√ß√µes em seus elementos.  Agora podemos associ√°-lo a um Assinante que fornece dados ao iterador resultante.  Resta considerar a √∫ltima pergunta: como organizar a intera√ß√£o HTTP com um servi√ßo externo. <br><br>  A estrutura do akka inclui o m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://doc.akka.io/docs/akka-">akka-http</a> , que permite organizar a comunica√ß√£o ass√≠ncrona e sem bloqueio por HTTP.  Al√©m disso, este m√≥dulo √© constru√≠do com base nos fluxos akka, que permitem adicionar a intera√ß√£o HTTP como uma etapa adicional no gr√°fico das opera√ß√µes de processamento de fluxo de dados. <br><br>  Para conectar-se a servi√ßos externos, o akka-http fornece tr√™s interfaces diferentes. <br><br><ol><li>  API em n√≠vel de solicita√ß√£o - √© a op√ß√£o mais simples para solicita√ß√µes √∫nicas a uma m√°quina arbitr√°ria.  Nesse n√≠vel, as conex√µes HTTP s√£o gerenciadas completamente automaticamente e, em cada solicita√ß√£o, √© necess√°rio transferir o endere√ßo completo da m√°quina para a qual a solicita√ß√£o est√° indo. </li><li>  API em n√≠vel de host - adequada quando sabemos qual porta em qual m√°quina estaremos acessando.  Nesse caso, o akka-http assume o controle do conjunto de conex√µes HTTP e, em solicita√ß√µes, basta especificar o caminho relativo para o recurso solicitado. </li><li>  API no n√≠vel da conex√£o - permite obter controle total sobre o gerenciamento de conex√µes HTTP, ou seja, abrir, fechar e distribuir solicita√ß√µes nas conex√µes. </li></ol><br>  No nosso caso, o endere√ßo do servi√ßo de classifica√ß√£o √© conhecido por n√≥s com anteced√™ncia, portanto, √© necess√°rio organizar a intera√ß√£o HTTP somente com esta m√°quina espec√≠fica.  Portanto, a API em n√≠vel de host √© melhor para n√≥s.  Agora, vamos ver como o pool de conex√µes HTTP √© criado ao us√°-lo: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Ao chamar Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) no ActorSystem, que est√° em um escopo impl√≠cito, os recursos s√£o alocados para criar um pool de conex√µes, mas as conex√µes em si n√£o s√£o estabelecidas.  Como resultado dessa chamada, o Flow √© retornado, que recebe um par de uma solicita√ß√£o HTTP e algum objeto de identifica√ß√£o de ID como entrada.  O objeto de identifica√ß√£o √© necess√°rio para corresponder a solicita√ß√£o com a resposta correspondente devido ao fato de a chamada HTTP no akka-http ser uma opera√ß√£o ass√≠ncrona e a ordem na qual as respostas s√£o recebidas n√£o corresponde necessariamente √† ordem na qual as solicita√ß√µes s√£o enviadas.  Portanto, na sa√≠da, o Flow fornece alguns resultados da consulta e o objeto de identifica√ß√£o correspondente. <br><br>  Diretamente, as conex√µes HTTP s√£o estabelecidas quando um gr√°fico (incluindo este fluxo) √© iniciado (materializado).  O Akka-http √© implementado de forma que, n√£o importa quantas vezes os gr√°ficos que cont√™m o httpFlow tenham sido materializados, em um ActorSystem sempre haver√° um pool comum de conex√µes HTTP que ser√° usado por todas as materializa√ß√µes.  Isso permite que voc√™ controle melhor o uso dos recursos de rede e evite sobrecarreg√°-los. <br><br>  Portanto, o ciclo de vida do conjunto de conex√µes HTTP est√° vinculado ao ActorSystem.  Como j√° mencionado, o ciclo de vida do conjunto de encadeamentos tamb√©m √© anexado a ele, no qual as opera√ß√µes definidas nos atores s√£o executadas (ou, no nosso caso, definidas como os est√°gios akka-streams e akka-http).  Portanto, para obter a m√°xima efici√™ncia, precisamos reutilizar uma inst√¢ncia do ActorSystem no mesmo processo da JVM. <br><br><h3>  Juntando tudo isso: um exemplo de implementa√ß√£o de intera√ß√£o com o servi√ßo de classifica√ß√£o </h3><br>  Portanto, agora podemos avan√ßar para o processo de classifica√ß√£o de grandes volumes de dados distribu√≠dos no Apache Spark usando intera√ß√£o ass√≠ncrona com servi√ßos externos.  O esquema geral dessa intera√ß√£o j√° foi mostrado na Figura 7. <br><br>  Suponha que tenhamos alguns conjuntos de dados [Recursos] definidos.  Aplicando a opera√ß√£o mapPartitions a ele, devemos obter um Dataset, no qual cada ID do conjunto de origem √© carimbado com um determinado valor obtido como resultado da classifica√ß√£o (Dataset [Score]).  Para organizar o processamento ass√≠ncrono nos executores, devemos agrupar a fonte e os iteradores resultantes no Publisher e Subscriber, respectivamente, da especifica√ß√£o de Fluxos reativos e vincul√°-los. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(‚ÄúscoreService. batchesRequestCount‚Äù)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  Nesta implementa√ß√£o, √© levado em considera√ß√£o que o servi√ßo de classifica√ß√£o de uma chamada pode processar um grupo de vetores de recursos de uma s√≥ vez; portanto, o resultado da classifica√ß√£o ap√≥s uma chamada tamb√©m estar√° dispon√≠vel imediatamente para todo o grupo.  Portanto, como um tipo de par√¢metro para o Publisher, n√£o temos apenas a Pontua√ß√£o, como seria de esperar, mas tamb√©m Iter√°vel [Pontua√ß√£o].  Assim, enviamos os resultados da classifica√ß√£o para esse grupo ao iterador resultante (que tamb√©m √© um Assinante) por uma √∫nica chamada ao m√©todo onNext.  Isso √© muito mais eficiente do que chamar onNext para cada elemento.  Agora vamos analisar esse c√≥digo com mais detalhes. <br><br><ol><li>  Determinamos a estrutura dos dados de entrada e sa√≠da.  Como entrada, teremos um monte de algum identificador de identifica√ß√£o com um vetor de recurso e, como sa√≠da, teremos um monte de identificador com um valor num√©rico obtido como resultado da classifica√ß√£o. </li><li>  Determinamos o n√∫mero de grupos que o Assinante solicitar√° ao Publicador por vez.  Como sup√µe-se que esses valores estejam no buffer e esperem at√© serem lidos no iterador resultante, esse valor depende da quantidade de mem√≥ria alocada ao executor. </li><li>  Crie o Publisher a partir do iterador de origem.  Ele ser√° respons√°vel por interagir com o servi√ßo de classifica√ß√£o.  A fun√ß√£o createPublisher √© discutida abaixo. </li><li>  Crie um Assinante, que ser√° o iterador resultante.  O c√≥digo da classe IteratorSubscriber tamb√©m √© fornecido abaixo. </li><li>  Registrando o Assinante no Publisher. </li><li>  Retorne IteratorSubscriber como resultado da opera√ß√£o mapPartitions. </li></ol><br>  Agora considere a implementa√ß√£o da fun√ß√£o createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, ‚Äì Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber ‚Äì  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    ‚Äì         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desenvolvedor Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Engenheiro de Sistemas</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413141/">https://habr.com/ru/post/pt413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413129/index.html">25 erros de um programador iniciante</a></li>
<li><a href="../pt413133/index.html">Antipadr√µes populares: pagina√ß√£o</a></li>
<li><a href="../pt413135/index.html">Designa√ß√£o de teste de revis√£o de c√≥digo de desenvolvedores junior react</a></li>
<li><a href="../pt413137/index.html">Classifique grandes quantidades de dados no Apache Spark usando modelos arbitr√°rios de aprendizado de m√°quina</a></li>
<li><a href="../pt413139/index.html">Carros el√©tricos: a revolu√ß√£o est√° chegando</a></li>
<li><a href="../pt413143/index.html">Bobby Urban Lite: A nova mochila urbana da XD Design</a></li>
<li><a href="../pt413145/index.html">Analista ajuda empresas a ganhar dinheiro</a></li>
<li><a href="../pt413147/index.html">√â poss√≠vel usar o Tibero em vez do Oracle. E √© necess√°rio</a></li>
<li><a href="../pt413149/index.html">Data warehouse distribu√≠do no conceito Data Lake: por onde come√ßar</a></li>
<li><a href="../pt413151/index.html">A NSA prop√¥s um padr√£o de criptografia para dispositivos IoT, mas a ISO o rejeitou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>