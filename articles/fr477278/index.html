<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèø ü•à üåÄ Tests frontaux üêâ üêò üê∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une strat√©gie efficace pour les tests de code automatis√©s est extr√™mement importante pour assurer le travail rapide et de haute qualit√© des √©quipes de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests frontaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477278/">  Une strat√©gie efficace pour les tests de code automatis√©s est extr√™mement importante pour assurer le travail rapide et de haute qualit√© des √©quipes de programmeurs impliqu√©s dans le support et le d√©veloppement de projets Web.  L'auteur de l'article dit que dans l'entreprise <a href="https://www.stackpath.com/">StackPath</a> , dans laquelle il travaille, maintenant tout fonctionne <a href="https://www.stackpath.com/">bien</a> avec les tests.  Ils ont de nombreux outils pour v√©rifier le code.  Mais √† partir d'une telle vari√©t√©, vous devez choisir ce qui convient le mieux dans chaque cas.  Il s'agit d'un probl√®me distinct.  Et une fois les outils n√©cessaires s√©lectionn√©s, vous devez toujours prendre une d√©cision sur l'ordre de leur utilisation. <br> <a href="https://habr.com/ru/company/ruvds/blog/477278/"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/f09/0a3/1bdf090a307b28098ab0758186db9d2c.svg" alt="image"></a> <br>  L'auteur de l'article dit que StackPath est satisfait du niveau de confiance dans la qualit√© du code qui a √©t√© atteint gr√¢ce au syst√®me de test appliqu√©.  Ici, il souhaite partager une description des principes de test d√©velopp√©s par l'entreprise et parler des outils utilis√©s. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Principes de test</font> </h2><br>  Avant de parler d'outils sp√©cifiques, il convient de r√©fl√©chir √† la r√©ponse √† la question de savoir quels sont les bons tests.  Avant de commencer √† travailler sur notre <a href="https://control.stackpath.com/">portail</a> pour les clients, nous avons formul√© et √©crit les principes que nous aimerions suivre lors de la cr√©ation de tests.  Ce que nous avons fait en premier lieu est exactement ce qui nous a aid√©s dans le choix des outils. <br><br>  Voici les quatre principes en question. <br><br><h3>  <font color="#3AC1EF">‚ñç Principe num√©ro 1.</font>  <font color="#3AC1EF">Les tests doivent √™tre compris comme des t√¢ches d'optimisation</font> </h3><br>  Une strat√©gie de test efficace consiste √† r√©soudre le probl√®me de maximiser une certaine valeur (dans ce cas, le niveau de confiance que l'application fonctionnera correctement) et de minimiser certains co√ªts (ici les "co√ªts" sont repr√©sent√©s par le temps n√©cessaire pour prendre en charge et ex√©cuter les tests).  Lors de la r√©daction des tests, nous posons souvent les questions suivantes li√©es au principe d√©crit ci-dessus: <br><br><ul><li>  Quelle est la probabilit√© que ce test trouve une erreur? </li><li>  Ce test am√©liore-t-il notre syst√®me de test et les co√ªts des ressources n√©cessaires pour l'√©crire valent-ils les avantages qui en d√©coulent? </li><li>  Est-il possible d'obtenir le m√™me niveau de confiance dans l'entit√© test√©e que ce test donne en cr√©ant un autre test plus facile √† √©crire, √† maintenir et √† ex√©cuter? </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Principe n ¬∞ 2.</font>  <font color="#3AC1EF">La surutilisation de mox doit √™tre √©vit√©e.</font> </h3><br>  L'une de mes explications pr√©f√©r√©es du terme ¬´mok¬ª a √©t√© donn√©e dans <a href="http://blog.testdouble.com/talks/2018-03-06-please-dont-mock-me/">cette</a> pr√©sentation de la conf√©rence Assert.js 2018. L'orateur a ouvert la question plus profond√©ment que je ne vais l'ouvrir ici.  Dans le discours, la cr√©ation de mokas est compar√©e √† des ¬´trous de poing en r√©alit√©¬ª.  Et je pense que c'est une fa√ßon tr√®s visuelle de percevoir les moks.  Bien qu'il y ait des mokas dans nos tests, nous comparons la diminution du ¬´co√ªt¬ª des tests que les mokas fournissent en raison de la simplification du processus d'√©criture et d'ex√©cution des tests, avec la diminution de la valeur des tests qui fait qu'un autre trou est fait dans la r√©alit√©. <br><br>  Auparavant, nos programmeurs s'appuyaient fortement sur des tests unitaires √©crits afin que toutes les d√©pendances enfants soient remplac√©es par des mokas √† l'aide de l'API de rendu <a href="https://airbnb.io/enzyme/docs/api/shallow.html">enzymatique</a> peu profond.  Les entit√©s rendues de cette mani√®re ont ensuite √©t√© v√©rifi√©es √† l'aide d'instantan√©s <a href="https://jestjs.io/docs/en/snapshot-testing">Jest</a> .  Tous ces tests ont √©t√© √©crits en utilisant un mod√®le similaire: <br><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'renders '</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = shallow();   <span class="hljs-comment"><span class="hljs-comment">//  ,              expect(wrapper).toMatchSnapshot(); });</span></span></code> </pre> <br>  Ces tests sont remplis de r√©alit√© dans de nombreux endroits.  Cette approche permet d'obtenir tr√®s facilement une couverture de code √† 100% avec des tests.  Lorsque vous √©crivez de tels tests, vous devez penser tr√®s peu, mais si vous ne v√©rifiez pas tous les nombreux points d'int√©gration, ces tests ne sont pas particuli√®rement utiles.  Tous les tests peuvent r√©ussir, mais cela ne donne pas beaucoup de confiance dans le fonctionnement de l'application.  Et pire encore, tous les mokas ont un ¬´prix¬ª cach√© que vous devez payer une fois les tests √©crits. <br><br><h3>  <font color="#3AC1EF">‚ñç Principe n ¬∞ 3.</font>  <font color="#3AC1EF">Les tests devraient faciliter la refactorisation du code, pas la compliquer.</font> </h3><br>  Des tests comme celui montr√© ci-dessus compliquent la refactorisation.  Si je trouve que dans de nombreux endroits du projet, il y a du code en double, et apr√®s un certain temps je formate ce code en tant que composant s√©par√©, alors tous les tests pour les composants dans lesquels j'utiliserai ce nouveau composant √©choueront.  Les composants d√©riv√©s √† l'aide de la technique de rendu peu profond sont d√©j√† autre chose.  L√† o√π j'avais l'habitude de r√©p√©ter le balisage, il y a maintenant un nouveau composant. <br><br>  Une refactorisation plus complexe, qui implique l'ajout de certains composants √† un projet et la suppression de plusieurs composants, cr√©e encore plus de confusion.  Le fait est que vous devez ajouter de nouveaux tests au syst√®me et en supprimer les tests inutiles.  La r√©g√©n√©ration d'instantan√©s est une t√¢che simple, mais quelle est la valeur de ces tests?  M√™me s'ils sont capables de trouver une erreur, il vaudrait mieux qu'ils l'aient manqu√© dans une s√©rie de changements de snapshots et simplement v√©rifi√© de nouveaux snapshots sans y passer trop de temps. <br><br>  Par cons√©quent, ces tests ne permettent pas particuli√®rement de refactoriser.  Id√©alement, aucun test ne devrait √©chouer si j'effectue une refactorisation, apr√®s quoi ce que l'utilisateur voit et ce avec quoi il interagit n'a pas chang√©.  Et vice versa - si je modifie ce que l'utilisateur contacte, au moins un test devrait √©chouer.  Si les tests suivent ces deux r√®gles, ils sont un excellent outil pour garantir que quelque chose que les utilisateurs rencontrent ne change pas pendant la refactorisation. <br><br><h3>  <font color="#3AC1EF">‚ñç Principe n ¬∞ 4.</font>  <font color="#3AC1EF">Les tests doivent reproduire le fonctionnement des utilisateurs r√©els avec l'application</font> </h3><br>  J'aimerais que les tests √©chouent uniquement si quelque chose a chang√© avec lequel l'utilisateur interagit.  Cela signifie que les tests doivent fonctionner avec l'application de la m√™me mani√®re que les utilisateurs travaillent avec elle.  Par exemple, un test doit vraiment interagir avec les √©l√©ments du formulaire et, comme un utilisateur, doit saisir du texte dans les champs de saisie de texte.  Les tests ne doivent pas acc√©der aux composants et appeler ind√©pendamment les m√©thodes de leur cycle de vie, ne doivent pas √©crire quelque chose dans l'√©tat des composants, ou faire quelque chose qui repose sur les subtilit√©s de l'impl√©mentation des composants.  √âtant donn√© que, finalement, je souhaite v√©rifier la partie du syst√®me qui est en contact avec l'utilisateur, il est logique de s'efforcer de faire en sorte que les tests, lorsqu'ils interagissent avec le syst√®me, reproduisent les actions des utilisateurs r√©els aussi pr√®s que possible. <br><br><h2>  <font color="#3AC1EF">Outils de test</font> </h2><br>  Maintenant que nous avons d√©fini les objectifs que nous voulons atteindre, parlons des outils que nous avons choisis pour cela. <br><br><h3>  <font color="#3AC1EF">‚ñçTypeScript</font> </h3><br>  Notre base de code utilise TypeScript.  Nos services backend sont √©crits en Go et interagissent les uns avec les autres √† l'aide de gRPC.  Cela nous permet de g√©n√©rer des clients gRPC typ√©s pour une utilisation sur un serveur GraphQL.  Les r√©solveurs de serveur GraphQL sont typ√©s √† l'aide de types g√©n√©r√©s √† l'aide de <a href="https://github.com/dotansimha/graphql-code-generator">graphql-code-generator</a> .  Et enfin, nos requ√™tes, mutations, ainsi que les composants d'abonnement et les hooks sont enti√®rement typ√©s.  Une couverture compl√®te de notre base de code avec des types √©limine toute une classe d'erreurs caus√©es par le fait que le formulaire de donn√©es n'est pas ce que le programmeur attend.  La g√©n√©ration de types √† partir des fichiers de sch√©ma et de protobuf garantit que l'ensemble de notre syst√®me, dans toutes les parties de la pile de technologies utilis√©es, reste homog√®ne. <br><br><h3>  <font color="#3AC1EF">EstJest (test unitaire)</font> </h3><br>  Comme framework pour tester le code, nous utilisons <a href="https://jestjs.io/">Jest</a> et <a href="https://testing-library.com/docs/react-testing-library/intro">@ testing-library / react</a> .  Dans les tests cr√©√©s √† l'aide de ces outils, nous testons des fonctions ou des composants ind√©pendamment du reste du syst√®me.  Nous testons g√©n√©ralement les fonctions et les composants qui sont le plus souvent utilis√©s dans une application, ou ceux qui ont de nombreuses fa√ßons d'ex√©cuter du code.  Ces chemins sont difficiles √† v√©rifier pendant l'int√©gration ou les tests de bout en bout (E2E). <br><br>  Les tests unitaires sont pour nous un moyen de tester de petites pi√®ces.  Les tests d'int√©gration et de bout en bout font un excellent travail de v√©rification du syst√®me √† plus grande √©chelle, vous permettant de v√©rifier le niveau g√©n√©ral d'int√©grit√© de l'application.  Mais parfois, vous devez vous assurer que les petits d√©tails fonctionnent, et l'√©criture de tests d'int√©gration pour toutes les utilisations possibles du code est trop co√ªteuse. <br><br>  Par exemple, nous devons v√©rifier que la navigation au clavier fonctionne dans le composant responsable de l'utilisation de la liste d√©roulante.  Mais en m√™me temps, nous ne voudrions pas v√©rifier toutes les variantes possibles d'un tel comportement lors du test de l'application enti√®re.  Par cons√©quent, nous testons soigneusement la navigation de mani√®re isol√©e et lorsque nous testons des pages √† l'aide du composant appropri√©, nous ne pr√™tons attention qu'√† la v√©rification des interactions de niveau sup√©rieur. <br><br><h2>  <font color="#3AC1EF">Outils de test</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçCypress (tests d'int√©gration)</font> </h3><br>  Les tests d'int√©gration cr√©√©s √† l'aide de <a href="https://www.cypress.io/">Cypress</a> sont au c≈ìur de notre syst√®me de test.  Lorsque nous avons commenc√© √† cr√©er le portail StackPath, ce sont les premiers tests que nous avons √©crits, car ils sont tr√®s pr√©cieux avec tr√®s peu de frais g√©n√©raux pour leur cr√©ation.  Cypress affiche l'int√©gralit√© de notre application dans un navigateur et ex√©cute des scripts de test.  L'ensemble de notre frontend fonctionne exactement de la m√™me mani√®re que lorsque les utilisateurs travaillent avec.  Certes, la couche r√©seau du syst√®me est remplac√©e par mokami.  Chaque requ√™te r√©seau qui parviendrait normalement au serveur GraphQL renvoie des donn√©es conditionnelles √† l'application. <br><br>  L'utilisation de simulations pour simuler la couche r√©seau d'une application pr√©sente de nombreux atouts: <br><br><ul><li>  Les tests sont plus rapides.  M√™me si le backend du projet est extr√™mement rapide, le temps n√©cessaire pour renvoyer les r√©ponses aux requ√™tes faites pendant toute la suite de tests peut √™tre assez important.  Et si Moki est responsable du retour des r√©ponses, les r√©ponses sont retourn√©es instantan√©ment. </li><li>  Les tests deviennent de plus en plus fiables.  L'une des difficult√©s pour effectuer des tests complets de bout en bout d'un projet est qu'il est n√©cessaire de prendre en compte l'√©tat variable des donn√©es du r√©seau et du serveur, qui peut changer.  Si l'acc√®s r√©el au r√©seau est simul√© √† l'aide de moxas, cette variabilit√© dispara√Æt. </li><li>  Il est facile de reproduire des situations qui n√©cessitent la r√©p√©tition exacte de certaines conditions.  Par exemple, dans un syst√®me r√©el, il sera difficile de faire √©chouer certaines requ√™tes de mani√®re stable.  Si vous devez v√©rifier la bonne r√©action de l'application aux demandes infructueuses, alors moki vous permet facilement de reproduire les situations d'urgence. </li></ul><br>  Bien que le remplacement de l'ensemble du backend par mok semble une t√¢che ardue, toutes les donn√©es conditionnelles sont typ√©es √† l'aide des m√™mes types TypeScript g√©n√©r√©s que ceux utilis√©s dans l'application.  C'est-√†-dire que ces donn√©es, au moins - en termes de structure, sont garanties d'√™tre √©quivalentes √† ce qu'un backend normal retournerait.  Au cours de la plupart des tests, nous avons tol√©r√© les inconv√©nients de l'utilisation de mooks plut√¥t que de vrais appels de serveur. <br><br>  De plus, les programmeurs sont tr√®s heureux de travailler avec Cypress.  Les tests s'ex√©cutent dans le Cypress Test Runner.  Les descriptions des tests s'affichent √† gauche et l'application de test s'ex√©cute dans l'√©l√©ment <code>iframe</code> principal.  Apr√®s avoir commenc√© le test, vous pouvez √©tudier ses diff√©rentes √©tapes et d√©couvrir comment l'application s'est comport√©e √† un moment ou √† un autre.  √âtant donn√© que l'outil d'ex√©cution des tests s'ex√©cute dans le navigateur lui-m√™me, vous pouvez utiliser les outils du navigateur du d√©veloppeur pour d√©boguer les tests. <br><br>  Lors de l'√©criture de tests frontaux, il arrive souvent que cela prenne beaucoup de temps pour comparer ce que fait le test avec l'√©tat du DOM √† un certain moment du test.  Cypress simplifie consid√©rablement cette t√¢che, car le d√©veloppeur peut voir tout ce qui se passe avec l'application test√©e.  <a href="">Voici un</a> clip vid√©o qui le d√©montre. <br><br>  Ces tests illustrent parfaitement nos principes de test.  Le rapport de leur valeur √† leur "prix" nous convient.  Les tests reproduisent de mani√®re tr√®s similaire les actions de l'utilisateur r√©el interagissant avec l'application.  Et seule la couche r√©seau du projet a √©t√© remplac√©e par mokami. <br><br><h3>  <font color="#3AC1EF">‚ñçCypress (test de bout en bout)</font> </h3><br>  Nos tests E2E sont √©galement √©crits en utilisant Cypress, mais en eux nous n'utilisons pas moki ni pour simuler le niveau r√©seau d'un projet ni pour simuler quoi que ce soit d'autre.  Lors des tests, l'application acc√®de au vrai serveur GraphQL, qui fonctionne avec des instances r√©elles de services backend. <br><br>  Les tests de bout en bout sont extr√™mement pr√©cieux pour nous.  Le fait est que ce sont les r√©sultats de ces tests qui nous permettent de savoir si quelque chose fonctionne comme pr√©vu ou ne fonctionne pas.  Aucune maquette n'est utilis√©e lors de ces tests, par cons√©quent, l'application fonctionne exactement de la m√™me mani√®re que lorsqu'elle est utilis√©e par de vrais clients.  Cependant, il convient de noter que les tests de bout en bout sont ¬´plus chers¬ª que les autres.  Ils sont plus lents, plus difficiles √† √©crire, compte tenu de la possibilit√© d'√©checs √† court terme lors de leur mise en ≈ìuvre.  Des travaux suppl√©mentaires sont n√©cessaires pour garantir que le syst√®me reste dans un √©tat connu avant d'ex√©cuter les tests. <br><br>  Les tests doivent g√©n√©ralement √™tre ex√©cut√©s √† un moment o√π le syst√®me est dans un √©tat connu.  Une fois le test termin√©, le syst√®me passe √† un autre √©tat connu.  Dans le cas des tests d'int√©gration, il n'est pas difficile d'obtenir ce comportement du syst√®me, car les appels √† l'API sont remplac√©s par des mokas, et, par cons√©quent, chaque test s'ex√©cute dans des conditions pr√©d√©termin√©es contr√¥l√©es par le programmeur.  Mais dans le cas des tests E2E, il est d√©j√† plus difficile de le faire, car l'entrep√¥t de donn√©es du serveur contient des informations qui peuvent changer pendant le test.  Par cons√©quent, le d√©veloppeur doit trouver un moyen de s'assurer que lorsque le test commencera, le syst√®me sera dans un √©tat pr√©c√©demment connu. <br><br>  Au d√©but de l'ex√©cution de test de bout en bout, nous ex√©cutons un script qui, en effectuant des appels directs √† l'API, cr√©e un nouveau compte avec des piles, des sites, des charges de travail, des moniteurs, etc.  Chaque session de test implique l'utilisation d'une nouvelle instance d'un tel compte, mais tout le reste de temps en temps reste inchang√©.  Le script, apr√®s avoir fait tout ce qui est n√©cessaire, forme un fichier contenant les donn√©es utilis√©es pour ex√©cuter les tests (il contient g√©n√©ralement des informations sur les identificateurs d'instance et les domaines).  En cons√©quence, il s'av√®re que le script vous permet de mettre le syst√®me dans un √©tat pr√©c√©demment connu avant d'ex√©cuter les tests. <br><br>  √âtant donn√© que les tests de bout en bout sont ¬´plus chers¬ª que les autres types de tests, nous, par rapport aux tests d'int√©gration, √©crivons moins de tests de bout en bout.  Nous nous effor√ßons de nous assurer que les tests couvrent les fonctionnalit√©s essentielles des applications.  Par exemple, cela consiste √† enregistrer des utilisateurs et leur connexion, √† cr√©er et √† configurer un site / une charge de travail, etc.  Gr√¢ce √† des tests d'int√©gration approfondis, nous savons qu'en g√©n√©ral, notre frontend est fonctionnel.  Mais des tests de bout en bout ne sont n√©cessaires que pour s'assurer que lors de la connexion du frontend au backend, il ne se passe rien que les autres tests ne puissent pas d√©tecter. <br><br><h2>  <font color="#3AC1EF">Inconv√©nients de notre strat√©gie de test compl√®te</font> </h2><br>  Bien que nous soyons tr√®s satisfaits des tests et de la stabilit√© de l'application, l'utilisation d'une strat√©gie de test compl√®te comme la n√¥tre pr√©sente √©galement des inconv√©nients. <br><br>  Pour commencer, l'application d'une telle strat√©gie de test signifie que tous les membres de l'√©quipe doivent √™tre familiers avec de nombreux outils de test, et pas seulement avec un.  Tout le monde a besoin de conna√Ætre Jest, @ testing-library / react et Cypress.  Mais en m√™me temps, les d√©veloppeurs n'ont pas seulement besoin de conna√Ætre ces outils.  Ils doivent √©galement √™tre en mesure de d√©cider dans quelle situation celle-ci doit √™tre utilis√©e.  Vaut-il la peine de tester une nouvelle opportunit√© d'√©crire un test de bout en bout, ou le test d'int√©gration est-il suffisant?  Est-il n√©cessaire, en plus du test de bout en bout ou d'int√©gration, d'√©crire un test unitaire pour v√©rifier les petits d√©tails de l'impl√©mentation de cette nouvelle fonctionnalit√©? <br><br>  Sans aucun doute, cela, pour ainsi dire, ¬´charge la t√™te¬ª de nos programmeurs, tout en utilisant le seul outil qu'ils ne subiraient pas une telle charge.  Habituellement, nous commen√ßons par des tests d'int√©gration, et apr√®s cela, si nous constatons que la fonctionnalit√© √† l'√©tude est particuli√®rement importante et d√©pend fortement de la partie serveur du projet, nous ajoutons le test de bout en bout appropri√©.  Ou nous commen√ßons par des tests unitaires, en faisant cela si nous pensons qu'un test unitaire ne sera pas en mesure de v√©rifier toutes les subtilit√©s de la mise en ≈ìuvre d'un certain m√©canisme. <br><br>  Bien s√ªr, nous sommes toujours confront√©s √† des situations o√π il n'est pas clair par o√π commencer.  Mais, comme nous devons constamment prendre des d√©cisions concernant les tests, certains mod√®les de situations courantes commencent √† √©merger.  Par exemple, nous testons g√©n√©ralement les syst√®mes de validation des formulaires √† l'aide de tests unitaires.  Cela est d√ª au fait que pendant le test, vous devez v√©rifier de nombreux sc√©narios diff√©rents.  Dans le m√™me temps, tout le monde dans l'√©quipe le sait et ne perd pas de temps √† planifier une strat√©gie de test lorsque l'un d'eux a besoin de tester le syst√®me de validation de formulaire. <br><br>  Un autre inconv√©nient de l'approche que nous utilisons est la complication de la collecte de donn√©es sur la couverture du code par des tests.  Bien que cela soit possible, c'est beaucoup plus compliqu√© que dans une situation o√π l'on est utilis√© pour tester un projet.  Bien que la recherche d'un nombre important de couvertures de code par des tests puisse entra√Æner une d√©t√©rioration de la qualit√© des tests, ces informations sont pr√©cieuses pour trouver des ¬´trous¬ª dans la suite de tests utilis√©e.  Le probl√®me de l'utilisation de plusieurs outils de test est que, pour comprendre quelle partie du code n'a pas √©t√© test√©e, vous devez combiner les rapports sur la couverture du code avec les tests re√ßus de diff√©rents syst√®mes.  C'est possible, mais c'est certainement beaucoup plus difficile que de lire un rapport g√©n√©r√© par n'importe quel moyen de test. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Lors de l'utilisation de nombreux outils de test, nous avons √©t√© confront√©s √† des t√¢ches difficiles.  Mais chacun de ces outils sert son propre objectif.  Au final, nous pensons avoir fait ce qu'il fallait en les incluant dans notre syst√®me de test de code.  Tests d'int√©gration - c'est l√† qu'il est pr√©f√©rable de commencer √† cr√©er un syst√®me de test au d√©but du travail sur une nouvelle application ou lors de l'√©quipement des tests d'un projet existant.  Il sera utile d'essayer d'ajouter des tests de bout en bout au projet le plus t√¥t possible, en v√©rifiant les caract√©ristiques les plus importantes du projet. <br><br>  Lorsque la suite de tests contient des tests d'int√©gration et de bout en bout, cela devrait conduire au fait que le d√©veloppeur recevra un certain niveau de confiance dans la sant√© de l'application lorsque des modifications y seront apport√©es.  Si, au cours des travaux sur le projet, des erreurs ont commenc√© √† appara√Ætre qui ne sont pas d√©tect√©es par les tests, il convient de d√©terminer quels tests pourraient d√©tecter ces erreurs et si l'apparition d'erreurs indique des d√©fauts dans l'ensemble du syst√®me de test utilis√© dans le projet. <br><br>  Bien s√ªr, nous ne sommes pas imm√©diatement arriv√©s √† notre syst√®me de test actuel.  De plus, nous nous attendons √† ce que ce syst√®me, √† mesure que notre projet se d√©veloppe, se d√©veloppe.  Mais maintenant, nous aimons vraiment notre approche des tests. <br><br>  <b>Chers lecteurs!</b>  Quelles strat√©gies suivez-vous dans les tests frontaux?  Quels outils de test frontaux utilisez-vous? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477278/">https://habr.com/ru/post/fr477278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477266/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 390 (18-24 novembre 2019)</a></li>
<li><a href="../fr477268/index.html">Optimisation de la solution de recherche sur github</a></li>
<li><a href="../fr477272/index.html">Premi√®re introduction √† AssemblyScript</a></li>
<li><a href="../fr477274/index.html">Comment se d√©barrasser du code CSS inutilis√©? Partie 1</a></li>
<li><a href="../fr477276/index.html">Comment se d√©barrasser du code CSS inutilis√©? 2e partie</a></li>
<li><a href="../fr477282/index.html">Profiling Go code de projet et r√©solution des probl√®mes d'allocation de m√©moire</a></li>
<li><a href="../fr477284/index.html">Pourquoi JavaScript est-il requis en mode strict?</a></li>
<li><a href="../fr477286/index.html">Axios ou Fetch: quoi utiliser en 2019?</a></li>
<li><a href="../fr477288/index.html">John Lewis √† la conf√©rence Undoing Aging 2018</a></li>
<li><a href="../fr477290/index.html">√âv√©nements num√©riques √† Moscou du 25 novembre au 1er d√©cembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>