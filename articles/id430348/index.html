<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏿 👩‍👧 👸🏾 OpenSceneGraph: Mengenkripsi Mesin OpenGL State 🤰🏻 🤛🏼 🙍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Sebagai aturan, ketika bekerja dengan parameter rendering, OpenGL bertindak sebagai mesin status. Status render adalah kumpulan atribut ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Mengenkripsi Mesin OpenGL State</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430348/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Sebagai aturan, ketika bekerja dengan parameter rendering, OpenGL bertindak sebagai mesin status.  Status render adalah kumpulan atribut status, seperti sumber cahaya, bahan, tekstur, dan mode tampilan, dihidupkan dan dimatikan oleh fungsi glEnable () dan glDisable ().  Ketika negara tertentu diatur, ia tetap berlaku sampai beberapa fungsi lain mengubahnya.  Pipa OpenGL mendukung tumpukan keadaan untuk menyimpan dan memulihkan keadaan pada waktu tertentu.  Mesin negara memberi pengembang kendali penuh atas status rendering saat ini dan yang disimpan pada stack. <br><br>  Namun, pendekatan ini tidak nyaman ketika bekerja dengan OSG.  Untuk alasan ini, mesin status OpenGL dienkapsulasi oleh kelas osg :: StateSet, yang menangani masalah stack negara dan mengaturnya dalam proses melintasi grafik adegan. <br><a name="habracut"></a><br>  Sebuah instance dari kelas osg :: StateSet berisi subset dari berbagai status rendering dan dapat menerapkannya ke osg :: Node adegan node dan osg :: Objek geometris yang dapat digambar menggunakan metode setStateSet () <br><br><pre><code class="cpp hljs">osg::StateSet *stateset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::StateSet; node-&gt;setStateSet(stateset);</code> </pre> <br>  Cara yang lebih aman adalah dengan menggunakan metode getOrCreateStateSet (), yang menjamin kembalinya keadaan yang benar dan lampirannya ke node atau objek yang dapat digambar <br><br><pre> <code class="cpp hljs">osg::StateSet *stateset = node-&gt;getOrCreateStateSet();</code> </pre><br>  Osg :: Node dan osg :: Kelas Drawable mengontrol variabel anggota osg :: StateSet melalui penunjuk pintar osg :: ref_ptr &lt;&gt;.  Ini berarti bahwa satu set negara dapat dibagi antara beberapa objek dalam adegan dan akan dihancurkan hanya ketika semua objek ini dihancurkan. <br><br><h1>  1. Atribut dan mode </h1><br>  OSG mendefinisikan kelas osg :: StateAttribute untuk menyimpan atribut rendering.  Ini adalah kelas dasar virtual yang diwarisi oleh berbagai atribut render seperti cahaya, material, dan kabut. <br><br>  Mode rendering berfungsi seperti sakelar yang dapat dihidupkan dan dimatikan.  Selain itu, mereka terkait dengan enumerator, yang digunakan untuk menunjukkan jenis mode OpenGL.  Terkadang mode rendering dikaitkan dengan atribut, misalnya, mode GL_LIGHTING mencakup variabel untuk sumber cahaya yang dikirim ke pipa OpenGL ketika dihidupkan, dan mematikan pencahayaan jika tidak. <br><br>  Kelas osg :: StateSet membagi atribut dan mode menjadi dua kelompok: tekstur dan non-tekstur.  Ini memiliki beberapa metode publik untuk menambahkan atribut dan mode non-tekstur ke serangkaian negara: <br><br><ol><li>  setAttribute () - Menambahkan objek bertipe osg :: StateAttribute ke set state.  Atribut dengan tipe yang sama tidak dapat hidup berdampingan di set status yang sama.  Setpoint sebelumnya akan ditimpa dengan yang baru. <br></li><li>  setMode () - melampirkan enumerator mode ke set negara dan menetapkan nilainya ke osg :: StateAttribute :: ON atau osg :: StateAttribute :: OFF, yang berarti mengaktifkan atau menonaktifkan mode. <br></li><li>  setAttributeAndModes () - melampirkan atribut render dan mode yang terkait dan menetapkan nilai switch (default ke ON).  Harus diingat bahwa tidak setiap atribut memiliki mode yang sesuai, tetapi Anda dapat menggunakan metode ini dalam hal apa pun. <br></li></ol><br>  Untuk mengatur atribut dan mode yang terkait, Anda dapat menggunakan kode ini <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(attr, osg::StateAttribute::ON);</code> </pre><br>  Untuk mengatur atribut tekstur, parameter tambahan harus diberikan untuk menunjukkan tekstur yang harus diterapkan.  Osg :: StateSet menyediakan beberapa metode publik lainnya untuk ini, seperti setTextureAttribute (), setTextureMode (), dan setTextureAttributeAndModes () <br><br><pre> <code class="cpp hljs">stateset-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, textattr, osg::StateAttribute::ON);</code> </pre><br>  menerapkan atribut textattr ke tekstur dengan pengidentifikasi 0. <br><br><h1>  2. Mengatur mode tampilan poligon untuk node pemandangan </h1><br>  Kami menggambarkan teori di atas dengan contoh praktis - mengubah mode rasterisasi poligon OpenGL menggunakan kelas osg :: PolygonMode, yang diturunkan dari osg :: StateAttribute.  Kelas ini mengenkapsulasi fungsi glPolygonMode () dan menyediakan antarmuka untuk mengatur mode tampilan poligon untuk node adegan tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh polygonmode</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::PolygonMode&gt; pm = new osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Di sini kita mengunggah model cessna kita tercinta dan menerapkan transformasi padanya, kita mendapatkan dua contoh model cessna.  Untuk salah satu dari mereka, di sebelah kiri, kami menerapkan atribut yang mengatur mode tampilan wireframe poligon <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PolygonMode&gt; pm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get());</code> </pre><br><img src="https://habrastorage.org/webt/pg/v5/ew/pgv5ewaulc_tfjztw5h8gyyap1i.png"><br><br>  Jika kita beralih ke spesifikasi OpenGL, kita dapat dengan mudah membayangkan opsi tampilan poligon apa yang akan tersedia bagi kita ketika menggunakan setMode () dalam kasus khusus ini.  Parameter pertama dapat mengambil nilai osg :: PolygonMode :: FRONT, BACK dan FRONT_AND_BACK, sesuai dengan enumerator OpenGL GL_FRONT, GL_BACK, GL_FRONT_AND_BACK.  Parameter kedua dapat mengambil nilai osg :: PolygonMode :: POINT, LINE dan FILL, yang sesuai dengan GL_POINT, GL_LINE dan GL_FILL.  Tidak ada trik lain, seperti yang sering terjadi ketika mengembangkan OpenGL murni, tidak diperlukan di sini - OSG menangani sebagian besar pekerjaan.  Mode tampilan poligon tidak memiliki mode terkait dan tidak perlu memanggil pasangan glEnable () / glDisable ().  Metode setAttributeAndModes () akan berfungsi dengan baik dalam kasus ini juga, tetapi nilai parameter ketiga tidak akan berguna. <br><br><h1>  3. Warisan status render.  Menerapkan Atribut dan Mode </h1><br>  Himpunan status simpul mempengaruhi simpul saat ini dan semua anak-anaknya.  Misalnya, atribut osg :: PolygonMode yang ditetapkan untuk transform1 dari contoh sebelumnya akan diterapkan ke semua anak dari simpul ini.  Namun, simpul anak dapat mengesampingkan atribut induk, yaitu, keadaan rendering akan diwarisi dari simpul induk jika simpul anak tidak mengubah perilaku. <br><br>  Terkadang Anda perlu mendefinisikan kembali perilaku simpul dalam hal penggunaan atribut.  Misalnya, di sebagian besar editor 3D, pengguna dapat memuat beberapa model dan mengubah mode tampilan untuk semua model yang dimuat pada waktu yang sama, terlepas dari bagaimana mereka ditampilkan sebelumnya.  Dengan kata lain, semua model dalam editor harus mewarisi atribut tunggal, terlepas dari bagaimana mereka ditetapkan sebelumnya untuk masing-masing model.  Di OSG, ini dapat diimplementasikan menggunakan flag osg :: StateAttribute :: OVERRIDE, misalnya <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttribute(attr, osg::StateAttribute::OVERRIDE);</code> </pre><br>  Saat mengatur mode dan mode dengan atribut, operator ATAU bitwise digunakan <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttributeAndModes(attr, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);</code> </pre><br>  Selain itu, atribut juga dapat dilindungi dari penggantian - untuk ini, atribut harus ditandai dengan osg :: StateAttribute :: flag PROTECTED. <br><br>  Ada flag ketiga, osg :: StateAttribute :: INHERIT, yang digunakan untuk menunjukkan bahwa atribut ini harus diwarisi dari kumpulan state dari node induk. <br><br>  Berikut adalah contoh singkat menggunakan flag OVERRIDE dan PROTECTED.  Node root akan diatur ke OVERRIDE untuk memaksa semua node turunan mewarisi atribut dan modenya.  Dalam kasus ini, child node akan mencoba mengubah statusnya dengan atau tanpa bantuan flag PROTECTED, yang akan menghasilkan hasil yang berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Mewarisi contoh teks</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/glider.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-0.5f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(0.5f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/lf/8h/u4/lf8hu4n3ii1bor6lgsktbischd0.png"><br><br>  Untuk memahami apa yang terjadi, Anda perlu melihat seperti apa tampilan glider yang biasanya menyala dengan mengunduh osgviewer OSG penuh waktu <br><br><pre> <code class="bash hljs">$ osgviewer glider.osg</code> </pre><br>  Dalam contoh ini, kami mencoba mengubah mode pencahayaan untuk node transform1 dan transform2 dengan sepenuhnya mematikan pencahayaan. <br><br><pre> <code class="cpp hljs">transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  Dalam hal ini, kita menyalakan mode pencahayaan untuk simpul root, dan menggunakan bendera OVERRIDE untuk semua simpul turunannya, sehingga mereka mewarisi keadaan simpul akar.  Namun, trnsform2 menggunakan flag PROTECTED untuk mencegah pengaturan simpul root mempengaruhi. <br><br><pre> <code class="cpp hljs">transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  Akibatnya, terlepas dari kenyataan bahwa kami mematikan pencahayaan di node transform1, hang glider kiri masih menyala, karena pengaturan root scene memblokir upaya kami untuk mematikan pencahayaan untuk itu.  Glider hang kanan ditampilkan tanpa pencahayaan (kelihatannya lebih cerah hanya karena dibanjiri dengan warna yang sederhana tanpa memberikan pencahayaan), karena transform2 dilindungi dari mewarisi atribut dari node root. <br><br><h1>  4. Daftar Atribut OpenGL yang Didukung di OpenSceneGraph </h1><br>  OSG mendukung hampir semua atribut dan mode rendering yang didukung oleh OpenGL melalui kelas-kelas yang diturunkan dari osg :: StateAttribute.  Tabel menunjukkan semua parameter mesin status OpenGL yang tersedia dari engine. <br><table><thead><tr><th>  ID jenis atribut </th><th>  Nama kelas </th><th>  Mode terkait </th><th>  Fungsi OpenGL Setara </th></tr></thead><tbody><tr><td>  ALPHEFUNC </td><td>  osg :: AlphaFunc </td><td>  GL_ALPHA_TEST </td><td>  glAlphaFunc () </td></tr><tr><td>  BLENDFUNC </td><td>  osg :: BlendFunc </td><td>  GL_BLEND </td><td>  glBlendFunc () dan glBlendFuncSeparate () </td></tr><tr><td>  KLIPPLAN </td><td>  osg :: ClipPlane </td><td>  GL_CLIP_PLANEi (i dari 1 hingga 5) </td><td>  glClipPlane () </td></tr><tr><td>  Colormask </td><td>  osg :: ColorMask </td><td>  - </td><td>  glColorMask () </td></tr><tr><td>  CULLFACE </td><td>  osg :: CullFace </td><td>  GL_CULLFACE </td><td>  glCullFace () </td></tr><tr><td>  Kedalaman </td><td>  osg :: Kedalaman </td><td>  GL_DEPTH_TEST </td><td>  glDepthFunc (), glDepthRange () dan glDepthMask () </td></tr><tr><td>  KABUT </td><td>  osg :: Kabut </td><td>  GL_FOG </td><td>  glFog () </td></tr><tr><td>  FRONTFACE </td><td>  osg :: FrontFace </td><td>  - </td><td>  glFrontFace () </td></tr><tr><td>  Ringan </td><td>  osg :: Cahaya </td><td>  GL_LIGHTi (i dari 1 hingga 7) </td><td>  glLight () </td></tr><tr><td>  LIGHTMODEL </td><td>  osg :: LightModel </td><td>  - </td><td>  glLightModel () </td></tr><tr><td>  LINESTRIPPLE </td><td>  osg :: LineStripple </td><td>  GL_LINE_STRIPPLE </td><td>  glLineStripple () </td></tr><tr><td>  LINEWIDTH </td><td>  osg :: LineWidth </td><td>  - </td><td>  glLineWidht () </td></tr><tr><td>  LOGICOP </td><td>  osg :: LogicOp </td><td>  GL_COLOR_LOGIC_OP </td><td>  glLogicOp () </td></tr><tr><td>  BAHAN </td><td>  osg :: Bahan </td><td>  - </td><td>  glMaterial () dan glColorMaterial () </td></tr><tr><td>  TITIK </td><td>  osg :: Poin </td><td>  GL_POINT_SMOOTH </td><td>  glPointParameter () </td></tr><tr><td>  POINTSPRITE </td><td>  osg :: PointSprite </td><td>  GL_POINT_SPRITE_ARB </td><td>  Fungsi untuk bekerja dengan sprite OpenGL </td></tr><tr><td>  POLYGONMODE </td><td>  osg :: PolygonMode </td><td>  - </td><td>  glPolygonMode () </td></tr><tr><td>  POLYGONOFFSET </td><td>  osg :: PolygonOffset </td><td>  GL_POLYGON_OFFSET_POINT </td><td>  glPolygonOffset () </td></tr><tr><td>  POLYGONSTRIPPLE </td><td>  osg :: PolygonStripple </td><td>  GL_POLYGON_STRIPPLE </td><td>  glPolygonStripple () </td></tr><tr><td>  GUNTING </td><td>  osg :: Gunting </td><td>  GL_SCISSOR_TEST </td><td>  glScissor () </td></tr><tr><td>  SHADEMODEL </td><td>  osg :: ShadeModel </td><td>  - </td><td>  glShadeModel () </td></tr><tr><td>  STENCIL </td><td>  osg :: Stensil </td><td>  GL_STENCIL_TEST </td><td>  glStencilFunc (), glStencilOp () dan glStencilMask () </td></tr><tr><td>  Texenv </td><td>  osg :: TexEnv </td><td>  - </td><td>  glTexEnv () </td></tr><tr><td>  Texgen </td><td>  osg :: TexGen </td><td>  GL_TEXTURE_GEN_S </td><td>  glTexGen () </td></tr></tbody></table><br>  Kolom ID tipe atribut menunjukkan pengidentifikasi OSG spesifik yang mengidentifikasi atribut ini di enumerator dari osg :: StateAttribute class.  Ini dapat digunakan dalam metode getAttribute untuk mendapatkan nilai atribut tertentu. <br><br><pre> <code class="cpp hljs">osg::PolygonMode *pm = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::PolygonMode *&gt;(stateset-&gt;getAttribute(osg::StateAttribute::POLYGONMODE));</code> </pre><br>  Pointer yang valid menunjukkan bahwa atribut telah ditetapkan sebelumnya.  Jika tidak, metode ini akan berbohong NULL.  Anda juga bisa mendapatkan nilai mode saat ini menggunakan panggilan <br><br><pre> <code class="cpp hljs">osg::StateAttribute::GLModeValue value = stateset-&gt;getMode(GL_LIGHTING);</code> </pre><br>  Di sini enumerator GL_LIGHTING digunakan untuk mengaktifkan / menonaktifkan pencahayaan di seluruh adegan. <br><br><h1>  5. Menerapkan kabut ke model di tempat kejadian </h1><br>  Mari kita kutip efek kabut sebagai cara ideal untuk menunjukkan cara bekerja dengan berbagai atribut dan mode rendering.  OpenGL menggunakan satu persamaan linear dan dua eksponensial yang menggambarkan model kabut, didukung oleh kelas osg :: Fog. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kabut teks</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Fog&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Fog&gt; fog = new osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(500.0f); fog-&gt;setEnd(2500.0f); fog-&gt;setColor(osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/lz.osg"); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get()); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pertama, buat atribut kabut.  Kami menggunakan model linier, sesuaikan rentang tampilan kabut dengan jarak ke model <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Fog&gt; fog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(<span class="hljs-number"><span class="hljs-number">500.0f</span></span>); fog-&gt;setEnd(<span class="hljs-number"><span class="hljs-number">2500.0f</span></span>); fog-&gt;setColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Kami memuat sampel lansekap lz.osg dan menerapkan atribut ini padanya <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/lz.osg"</span></span>); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get());</code> </pre><br>  Di jendela penampil, kita melihat lanskap buram, dan kita bisa melihat bagaimana kepadatan kabut berubah tergantung pada jarak ke model <br><br><img src="https://habrastorage.org/webt/gq/8f/fu/gq8ffuswpsbsl1-xxqzprwvprle.png"><br><br><img src="https://habrastorage.org/webt/3z/st/f6/3zstf6mlxlvenapqhvj3zsxyh2i.png"><br><br><img src="https://habrastorage.org/webt/k-/mc/cj/k-mccjrssmakzwwrht-b5azkzg4.png"><br><br><h1>  6. Bekerja dengan sumber cahaya dan pencahayaan </h1><br>  Seperti halnya OpenGL, OSG mendukung hingga delapan sumber cahaya untuk secara langsung bertemu objek pemandangan.  Seperti OpenGL, OSG tidak secara otomatis menghitung bayangan.  Sinar cahaya datang dari sumber-sumber dalam garis lurus, dipantulkan dari objek dan disebarkan oleh mereka, setelah itu mereka dilihat oleh mata penonton.  Untuk pemrosesan pencahayaan berkualitas tinggi, perlu mengatur sifat material, geometri objek normal, dll. <br><br>  Osg :: Light class menyediakan metode untuk mengendalikan sumber cahaya, termasuk: setLightNum () dan getLightNum () - untuk bekerja dengan jumlah sumber;  setAmbient () dan getAmbient () untuk mengontrol komponen di sekitarnya;  setDiffuse () dan getDiffuse () - untuk bekerja dengan komponen yang tersebar, dll. <br><br>  OSG juga menjelaskan kelas osg :: LightSource untuk menambahkan sumber cahaya ke TKP.  Ini memberikan metode setLight () dan merupakan simpul daun dari grafik adegan dengan atribut tunggal.  Semua node lain dari grafik adegan dipengaruhi oleh sumber cahaya jika mode yang sesuai untuk GL_LIGHTi diatur.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1 osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum( 1 ); ... //       osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight( light.get() ); ... //             root-&gt;addChild( lightSource.get() ); root-&gt;getOrCreateStateSet()-&gt;setMode( GL_LIGHT1, osg::StateAttribute::ON );</span></span></code> </pre><br>  Solusi lain yang lebih nyaman adalah metode setStateSetModes (), dengan mana sumber cahaya dengan nomor yang diinginkan secara otomatis dilampirkan ke node root <br><br><pre> <code class="cpp hljs">root-&gt;addChild( lightSource.get() ); lightSource-&gt;setStateSetModes( root-&gt;getOrCreateStateSet(), osg::StateAttribute::ON );</code> </pre><br>  Anda dapat menambahkan node anak ke sumber cahaya, tetapi ini tidak berarti sama sekali, Anda akan menerangi subgraph yang terkait dengannya entah bagaimana dengan cara yang khusus.  Ini akan diproses sebagai geometri, diwakili oleh bentuk fisik sumber cahaya. <br><br>  Osg :: LightSource node dapat dilampirkan ke node transformasi, dan, misalnya, sumber cahaya titik dapat dipindahkan di ruang angkasa.  Ini dapat dinonaktifkan dengan mengatur sistem koordinat absolut untuk sumber cahaya. <br><br><pre> <code class="cpp hljs">lightSource-&gt;setReferenceFrame( osg::LightSource::ABSOLUTE_RF );</code> </pre><br><h1>  7. Membuat sumber cahaya di tempat kejadian </h1><br>  Secara default, OSG secara otomatis mengatur sumber cahaya ke angka 0, yang memancarkan cahaya arah seragam ke tempat kejadian.  Namun, kapan saja Anda dapat menambahkan beberapa sumber cahaya tambahan, dan bahkan mengendalikannya menggunakan node transformasi koordinat.  Hanya sumber posisi (sumber titik) yang dapat dipindahkan.  Cahaya directional hanya memiliki arah (aliran sinar paralel yang datang dari tak terbatas) dan tidak terikat pada posisi tertentu di atas panggung.  OpenGL dan OSG menggunakan komponen keempat dari parameter posisi untuk menentukan jenis sumber cahaya.  Jika 0, maka cahaya dianggap sebagai diarahkan;  dengan nilai 1 - posisi. <br><br>  Pertimbangkan contoh kecil bekerja dengan pencahayaan. <br><br><div class="spoiler">  <b class="spoiler_title">Judul spoiler</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osg/LightSource&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLightSource(int num, const osg::Vec3 &amp;trans, const osg::Vec4 &amp;color) { osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = new osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); return sourceTrans.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); osg::Node *light0 = createLightSource(0, osg::Vec3(-20.0f, 0.0f, 0.0f), osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::Node *light1 = createLightSource(1, osg::Vec3(0.0f, -20.0f, 0.0f), osg::Vec4(0.0f, 1.0f, 1.0f, 1.0f)); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Untuk membuat sumber cahaya, kami memiliki fungsi terpisah <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLightSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;trans, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec4 &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release(); }</code> </pre><br>  Dalam fungsi ini, pertama-tama kita menentukan parameter pencahayaan yang diberikan oleh sumber, sehingga menciptakan atribut GL_LIGHTi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; <span class="hljs-comment"><span class="hljs-comment">//    light-&gt;setLightNum(num); //   light-&gt;setDiffuse(color); //  .     ,    light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f));</span></span></code> </pre><br>  Setelah itu, sumber cahaya dibuat dimana atribut ini diberikan. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light);</code> </pre><br>  Kami membuat dan mengkonfigurasi node transformasi, melewati sumber cahaya kami sebagai node anak <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get());</code> </pre><br>  Kembalikan pointer ke node transformasi <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release();</code> </pre><br>  Dalam tubuh program utama, kami memuat model tiga dimensi (sekali lagi, cessna favorit kami) <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get());</code> </pre><br>  Kami membuat dua sumber cahaya dengan angka 0 dan 1. Yang pertama akan bersinar kuning, yang kedua - biru-hijau <br><br><pre> <code class="cpp hljs">osg::Node *light0 = createLightSource(<span class="hljs-number"><span class="hljs-number">0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::Node *light1 = createLightSource(<span class="hljs-number"><span class="hljs-number">1</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Kami memberi tahu mesin status OpenGL bahwa perlu menyalakan 0 dan 1 sumber cahaya dan menambahkan sumber yang kami buat ke tempat kejadian <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1);</code> </pre><br>  Setelah menginisialisasi dan memulai penampil, kami mendapatkan gambar <br><br><img src="https://habrastorage.org/webt/0s/or/ph/0sorphad56jc2zc8iwfb591qcxk.png"><br><br><h1>  Kesimpulan </h1><br>  Sangat tersentuh oleh perhatian orang-orang yang tertarik pada siklus ini.  Tindakan ini tidak dimulai dengan banyak, tetapi saya merasa bahwa masyarakat membutuhkan artikel.  Terima kasih atas semua jenis umpan balik positif. <br><br>  Hari ini saya mencoba mempertimbangkan, sekali lagi, hal-hal yang agak mendasar dari mesin OSG.  Tidak yakin apa yang keluar keren.  Tetapi sejauh ini saya menetapkan hal-hal yang sangat primitif, di mana saya sendiri memahaminya.  Saya memeriksa semua contoh secara pribadi, repositori saya tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Terima kasih, kawan-kawan terkasih, saya akan berusaha menjaga agar kisah ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terus berlanjut</a> ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430348/">https://habr.com/ru/post/id430348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430336/index.html">Sebagai seorang programmer, ia mengambil mesin baru</a></li>
<li><a href="../id430340/index.html">Kami sedang menunggu headphone Apple: AirPods 2019 dan perkiraan anak pertama yang berukuran penuh</a></li>
<li><a href="../id430342/index.html">Goldratt dan pengisian bahan bakar</a></li>
<li><a href="../id430344/index.html">Dell XPS 15 9575: Laptop konversi yang kuat dan portabel untuk pekerjaan serius</a></li>
<li><a href="../id430346/index.html">Scrum dan Agile tidak akan menyelamatkan proyek Anda dari kegagalan</a></li>
<li><a href="../id430352/index.html">Sertifikat SSL pertama menggunakan karakter cyrillic</a></li>
<li><a href="../id430354/index.html">Apa yang di depan China dari yang lain?</a></li>
<li><a href="../id430356/index.html">Acara digital di Moskow dari 19 hingga 25 November</a></li>
<li><a href="../id430358/index.html">Pelajaran terbuka "Pembenaran kegiatan teknis"</a></li>
<li><a href="../id430360/index.html">Mengapa dan untuk siapa terjemahan mesin cocok?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>