<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚕️ 💿 👨🏽‍🔬 Alat pengembang Node.js. Panggilan prosedur jarak jauh pada soket web 💒 🛕 🏂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cerita-cerita horor sering bercerita tentang teknologi websocket, misalnya, bahwa itu tidak didukung oleh browser web, atau bahwa penyedia / admin men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alat pengembang Node.js. Panggilan prosedur jarak jauh pada soket web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459978/"> Cerita-cerita horor sering bercerita tentang teknologi websocket, misalnya, bahwa itu tidak didukung oleh browser web, atau bahwa penyedia / admin menekan lalu lintas websocket - oleh karena itu tidak dapat digunakan dalam aplikasi.  Di sisi lain, pengembang tidak selalu melihat jebakan yang dimiliki teknologi websocket, seperti teknologi lainnya.  Mengenai batasan yang dituduhkan, saya akan katakan segera bahwa 96,8% browser web mendukung teknologi websocket saat ini.  Anda dapat mengatakan bahwa sisa 3,2% terlalu banyak, ini adalah jutaan pengguna.  Saya sepenuhnya setuju dengan Anda.  Hanya semuanya yang diketahui perbandingannya.  XmlHttpRequest yang sama, yang telah digunakan semua orang di Ajax selama bertahun-tahun, mendukung 97,17% browser web (tidak lebih, kan?), Dan mengambil secara umum, 93,08% browser web.  Tidak seperti websocket, persentase seperti itu (dan sebelumnya itu bahkan lebih rendah) tidak menghentikan siapa pun untuk waktu yang lama ketika menggunakan teknologi Ajax.  Jadi menggunakan fallback pada polling panjang saat ini tidak masuk akal.  Jika hanya karena browser web yang tidak mendukung websocket adalah browser web yang sama yang tidak mendukung XmlHttpRequest, dan pada kenyataannya tidak akan terjadi penurunan. <br><br>  Kisah horor kedua, pelarangan websocket dari penyedia atau admin jaringan perusahaan, juga tidak masuk akal, karena sekarang semua orang menggunakan protokol https, dan tidak mungkin untuk memahami bahwa koneksi websocket terbuka (tanpa melanggar https). <br><br>  Adapun batasan nyata dan cara untuk mengatasinya, saya akan kirim dalam posting ini, pada contoh pengembangan area web admin aplikasi. <br><a name="habracut"></a><br>  Jadi, objek WebSocket di browser web, sejujurnya, memiliki serangkaian metode yang sangat ringkas: kirim () dan tutup (), serta addEventListener (), hapusEventListener () dan dispatchEvent () metode yang diwarisi dari objek EventTarget.  Oleh karena itu, pengembang harus menggunakan perpustakaan (biasanya) atau secara mandiri (hampir tidak mungkin) untuk menyelesaikan beberapa masalah. <br><br>  Mari kita mulai dengan tugas yang paling bisa dimengerti.  Koneksi ke server terputus secara berkala.  Menghubungkan kembali cukup mudah.  Tetapi jika Anda ingat bahwa pesan dari klien dan server terus berjalan saat ini, semuanya menjadi segera dan jauh lebih rumit.  Secara umum, pesan dapat hilang jika mekanisme konfirmasi untuk pesan yang diterima tidak disediakan, atau dikirim kembali (bahkan beberapa kali) jika mekanisme konfirmasi diberikan, tetapi kegagalan terjadi tepat pada saat setelah penerimaan dan sebelum pesan dikonfirmasi. <br><br>  Jika Anda memerlukan pengiriman pesan terjamin dan / atau pengiriman pesan tanpa perlu, maka ada protokol khusus untuk mengimplementasikan ini, misalnya, AMQP dan MQTT, yang bekerja dengan transportasi websocket.  Tetapi hari ini kita tidak akan mempertimbangkannya. <br><br>  Sebagian besar pustaka untuk bekerja dengan dukungan websocket transparan untuk pemrogram menghubungkan kembali ke server.  Menggunakan perpustakaan seperti itu selalu lebih dapat diandalkan daripada mengembangkan implementasi Anda. <br><br>  Selanjutnya, Anda perlu mengimplementasikan infrastruktur untuk mengirim dan menerima pesan asinkron.  Untuk melakukan ini, gunakan event handler onmessage "telanjang" tanpa ikatan tambahan, tugas tanpa pamrih.  Infrastruktur semacam itu dapat, misalnya, panggilan prosedur jarak jauh (RPC).  Id id diperkenalkan ke dalam spesifikasi json-rpc, khusus untuk bekerja dengan transport websocket, yang memungkinkan Anda untuk memetakan panggilan prosedur jarak jauh oleh klien ke pesan respon dari server web.  Saya lebih suka protokol ini daripada semua kemungkinan lain, tetapi sejauh ini saya belum menemukan implementasi protokol ini yang sukses untuk bagian server pada node.js. <br><br>  Dan akhirnya, Anda perlu menerapkan penskalaan.  Ingatlah bahwa koneksi antara klien dan server terjadi secara berkala.  Jika kekuatan satu server tidak cukup bagi kami, kami dapat meningkatkan beberapa server lagi.  Dalam hal ini, setelah koneksi terputus, koneksi ke server yang sama tidak dijamin.  Biasanya, server redis atau sekelompok server redis digunakan untuk mengoordinasikan beberapa server websocket. <br><br>  Dan, sayangnya, cepat atau lambat kita akan mengalami kinerja sistem, karena kemampuan node.js dalam jumlah koneksi websocket yang secara bersamaan terbuka (jangan bingung dengan kinerja) secara signifikan lebih rendah daripada dengan server khusus seperti antrian pesan dan broker.  Dan perlunya pertukaran silang antara semua contoh server websocket melalui cluster server redis, setelah beberapa titik kritis, tidak akan memberikan peningkatan yang signifikan dalam jumlah koneksi terbuka.  Cara untuk mengatasi masalah ini adalah dengan menggunakan server khusus, seperti AMQP dan MQTT, yang berfungsi, termasuk dengan transportasi websocket.  Tetapi hari ini kita tidak akan mempertimbangkannya. <br><br>  Seperti yang dapat Anda lihat dari daftar tugas yang terdaftar, bersepeda sambil bekerja dengan websocket sangat memakan waktu, dan bahkan tidak mungkin jika Anda perlu skala solusi ke beberapa server websocket. <br><br>  Oleh karena itu, saya mengusulkan untuk mempertimbangkan beberapa perpustakaan populer yang mengimplementasikan pekerjaan dengan websocket. <br><br>  Saya akan segera mengecualikan dari perpustakaan yang menerapkan mundur secara eksklusif pada moda transportasi yang sudah usang, karena hari ini fungsi ini tidak relevan, dan perpustakaan yang menerapkan fungsionalitas yang lebih luas, sebagai aturan, juga menerapkan mundur pada moda transportasi yang usang. <br><br>  Saya akan mulai dengan perpustakaan paling populer - socket.io.  Sekarang Anda dapat mendengar pendapatnya, kemungkinan besar adil, bahwa perpustakaan ini lambat dan mahal dalam hal sumber daya.  Kemungkinan besar, dan itu bekerja lebih lambat dari websocket asli.  Namun, saat ini perpustakaan ini merupakan perpustakaan yang paling berkembang.  Dan, sekali lagi, ketika bekerja dengan websocket, faktor pembatas utama bukanlah kecepatan, tetapi jumlah koneksi yang terbuka secara simultan dengan klien unik.  Dan pertanyaan ini sebaiknya diselesaikan dengan membuat koneksi dengan klien ke server khusus. <br><br>  Jadi, soket.io mengimplementasikan pemulihan yang andal ketika memutuskan sambungan dari server dan melakukan penskalaan menggunakan server atau sekelompok server redis.  socket.io, pada kenyataannya, mengimplementasikan protokol pengiriman pesannya sendiri, yang memungkinkan Anda untuk mengimplementasikan pengiriman pesan antara klien dan server tanpa terikat dengan bahasa pemrograman tertentu. <br><br>  Fitur yang menarik dari socket.io adalah konfirmasi pemrosesan acara, di mana objek sewenang-wenang dapat dikembalikan dari server ke klien, yang memungkinkan untuk panggilan prosedur jarak jauh (meskipun tidak sesuai dengan standar json-rpc). <br><br>  Juga, pendahuluan, saya memeriksa dua perpustakaan yang lebih menarik, yang akan saya diskusikan secara singkat di bawah ini. <br><br>  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">faye faye.jcoglan.com</a> .  Ini mengimplementasikan protokol bayeux, yang dikembangkan dalam proyek CometD dan mengimplementasikan langganan / distribusi pesan ke saluran pesan.  Proyek ini juga mendukung penskalaan menggunakan server atau sekelompok server redis.  Upaya untuk menemukan cara menerapkan RPC tidak berhasil karena tidak cocok dengan skema protokol bayeux. <br><br>  Dalam proyek socketcluster <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">socketcluster.io</a> , penekanannya adalah pada penskalaan server websocket.  Pada saat yang sama, cluster server websocket tidak dibuat atas dasar server redis, seperti pada dua pustaka yang disebutkan pertama, tetapi atas dasar node.js.  Dalam hal ini, ketika mengerahkan kluster, perlu untuk meluncurkan infrastruktur perantara dan pekerja yang agak rumit. <br><br>  Sekarang mari kita beralih ke implementasi RPC di socket.io.  Seperti yang saya katakan di atas, perpustakaan ini telah menerapkan kemampuan untuk bertukar objek antara klien dan server: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remoteCall = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, data, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>).createServer(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(server, { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span> }); io.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, (socket) =&gt; { socket.on(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data, callback) =&gt; { handleRemoteCall(socket, data, callback); }); }); server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'dashboard backend listening on *:5000'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleRemoteCall = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">socket, data, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response =... callback(response) }</code> </pre><br>  Ini adalah skema umum.  Sekarang kita akan mempertimbangkan masing-masing bagian dalam kaitannya dengan aplikasi tertentu.  Untuk membangun panel admin, saya menggunakan perpustakaan react-admin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/marmelab/react-admin</a> .  Pertukaran data dengan server di perpustakaan ini diimplementasikan menggunakan penyedia data, yang memiliki skema yang sangat nyaman, hampir semacam standar.  Misalnya, untuk mendapatkan daftar, metode ini disebut: <br><br><pre> <code class="javascript hljs">dataProvider( <span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, { <span class="hljs-attr"><span class="hljs-attr">pagination</span></span>: { <span class="hljs-attr"><span class="hljs-attr">page</span></span>: {int}, <span class="hljs-attr"><span class="hljs-attr">perPage</span></span>: {int} }, <span class="hljs-attr"><span class="hljs-attr">sort</span></span>: { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: {string}, <span class="hljs-attr"><span class="hljs-attr">order</span></span>: {string} }, <span class="hljs-attr"><span class="hljs-attr">filter</span></span>: { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> } }</code> </pre><br>  Metode ini dalam respons asinkron mengembalikan objek: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: [  ], <span class="hljs-attr"><span class="hljs-attr">total</span></span>:      }</code> </pre><br>  Saat ini terdapat sejumlah implementasi penyedia data reaksi-admin yang mengesankan untuk berbagai server dan kerangka kerja (mis. Firebase, spring boot, graphql, dll.).  Dalam kasus RPC, implementasi ternyata yang paling ringkas, karena objek ditransfer dalam bentuk aslinya ke panggilan fungsi emit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'socket.io-client'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = io({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/ws'</span></span>, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>] }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (action, collection, payload = {}) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { socket.emit(<span class="hljs-string"><span class="hljs-string">'remote-call'</span></span>, {action, collection, payload}, (response) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.error) { reject(response); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resolve(response); } }); });</code> </pre><br>  Sayangnya, sedikit lebih banyak pekerjaan yang harus dilakukan di sisi server.  Untuk mengatur pemetaan fungsi yang menangani panggilan jarak jauh, router yang mirip dengan express.js dikembangkan.  Hanya alih-alih tanda tangan middleware (req, res, next) implementasi bergantung pada tanda tangan (socket, payload, callback).  Hasilnya, kita semua mendapatkan kode yang biasa: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./router'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = Router(); router.use(<span class="hljs-string"><span class="hljs-string">'GET_LIST'</span></span>, (socket, payload, callback) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limit = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(payload.pagination.perPage); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Number</span></span></span></span><span class="hljs-function"><span class="hljs-params">(payload.pagination.page</span></span></span><span class="hljs-function">) - 1) * </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">limit</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{data: users.slice(offset, offset + limit </span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">}); }); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">router</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'GET_ONE'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (socket, payload, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id]}); }); router.use(<span class="hljs-string"><span class="hljs-string">'UPDATE'</span></span>, (socket, payload, callback) =&gt; { users[payload.id] = payload.data <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: users[payload.id] }); }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = router; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; i++) { users.push({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: i, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`name of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>}); }</code> </pre><br>  Rincian implementasi router dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori proyek.</a> <br><br>  Yang tersisa adalah menetapkan penyedia untuk komponen Admin: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Admin, Resource, EditGuesser } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-admin'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserList <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./UserList'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataProvider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wsProvider'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> &lt;Admin dataProvider={dataProvider}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Resource</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{UserList}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{EditGuesser}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Admin</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App;</code> </pre><br><br>  Tautan yang bermanfaat <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.www.infoq.com/articles/Web-Sockets-Proxy-Servers</a> <br><br>  apapacy@gmail.com <br>  14 Juli 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459978/">https://habr.com/ru/post/id459978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459964/index.html">8 trik UI sederhana untuk membuat desain prototipe dinamis tanpa menggunakan animasi</a></li>
<li><a href="../id459968/index.html">Apa yang sebenarnya terjadi pada Boeing Malaysia yang hilang (bagian 3/3)</a></li>
<li><a href="../id459970/index.html">Janji. Semua gelisah</a></li>
<li><a href="../id459972/index.html">Pengembangan untuk Docker. Lingkungan lokal. Bagian 1</a></li>
<li><a href="../id459976/index.html">Nemesida WAF Free Build Baru untuk NGINX</a></li>
<li><a href="../id459980/index.html">Huruf Nigeria berteknologi tinggi</a></li>
<li><a href="../id459982/index.html">Analisis Roslyn. Cara menulis kode dengan cepat dan akurat</a></li>
<li><a href="../id459984/index.html">Membangun infrastruktur sebagai kode dengan GitLab dan Ansible</a></li>
<li><a href="../id459988/index.html">Anjing itu makan di jaringan saraf</a></li>
<li><a href="../id459990/index.html">Immersion in Move - Bahasa pemrograman blockchain Libra Facebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>