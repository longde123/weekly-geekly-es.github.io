<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§î ü¶ã üì° Desincronizaci√≥n asincr√≥nica: antipatrones en el trabajo con async / await en .NET ‚èπÔ∏è üëØ üë©üèΩ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øCu√°l de nosotros no corta? Regularmente encuentro errores en el c√≥digo asincr√≥nico y los hago yo mismo. Para detener esta rueda de Samsara, estoy com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desincronizaci√≥n asincr√≥nica: antipatrones en el trabajo con async / await en .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/435666/"><p>  ¬øCu√°l de nosotros no corta?  Regularmente encuentro errores en el c√≥digo asincr√≥nico y los hago yo mismo.  Para detener esta rueda de Samsara, estoy compartiendo contigo las jambas m√°s t√≠picas de las que a veces son bastante dif√≠ciles de atrapar y arreglar. </p><br><img src="https://habrastorage.org/webt/os/oz/lt/osozltujeowuulzfvdaxvehuvpg.png"><br><a name="habracut"></a><br><blockquote>  Este texto est√° inspirado en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog de Stephen Clary</a> , un hombre que sabe todo sobre competitividad, asincron√≠a, multiproceso y otras palabras de miedo.  Es autor del libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Concurrency in C # Cookbook</a> , que ha recopilado una gran cantidad de patrones para trabajar con la competencia. </blockquote><br><h2>  Punto muerto asincr√≥nico cl√°sico </h2><br><p>  Para comprender el punto muerto as√≠ncrono, vale la pena averiguar qu√© subproceso ejecuta el m√©todo invocado usando la palabra clave wait. </p><br><p>  Primero, el m√©todo profundizar√° en la cadena de llamadas de los m√©todos as√≠ncronos hasta que encuentre una fuente de asincron√≠a.  C√≥mo se implementa exactamente la fuente de asincron√≠a es un tema que est√° m√°s all√° del alcance de este art√≠culo.  Ahora, para simplificar, asumimos que esta es una operaci√≥n que no requiere un flujo de trabajo mientras se espera su resultado, por ejemplo, una solicitud de base de datos o una solicitud HTTP.  El inicio sincr√≥nico de una operaci√≥n de este tipo significa que mientras se espera su resultado en el sistema habr√° al menos un hilo que se queda dormido que consume recursos pero no hace ning√∫n trabajo √∫til. </p><br><p> En una llamada asincr√≥nica, rompemos el flujo de ejecuci√≥n de los comandos en el "antes" y el "despu√©s" de la operaci√≥n asincr√≥nica, y en .NET no hay garant√≠as de que el c√≥digo que est√° despu√©s de esperar se ejecute en el mismo hilo que el c√≥digo antes de esperar.  En la mayor√≠a de los casos, esto no es necesario, pero ¬øqu√© hacer cuando tal comportamiento es vital para que el programa funcione?  Necesita usar <code>SynchronizationContext</code> .  Este es un mecanismo que le permite imponer ciertas restricciones en los hilos en los que se ejecuta el c√≥digo.  A continuaci√≥n, trataremos con dos contextos de sincronizaci√≥n ( <code>WindowsFormsSynchronizationContext</code> y <code>AspNetSynchronizationContext</code> ), pero Alex Davis escribe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su libro</a> que hay una docena de ellos en .NET.  Acerca de <code>SynchronizationContext</code> bien escrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ el</a> autor ha implementado el suyo, por lo que tiene un gran respeto. </p><br><p>  Entonces, tan pronto como el c√≥digo llega al origen de la asincron√≠a, guarda el contexto de sincronizaci√≥n, que estaba en la propiedad de hilo est√°tico de <code>SynchronizationContext.Current</code> , entonces la operaci√≥n asincr√≥nica comienza y libera el hilo actual.  En otras palabras, mientras esperamos la finalizaci√≥n de la operaci√≥n asincr√≥nica, no bloqueamos un solo subproceso y este es el principal beneficio de la operaci√≥n asincr√≥nica en comparaci√≥n con la sincr√≥nica.  Despu√©s de completar la operaci√≥n asincr√≥nica, debemos seguir las instrucciones que se encuentran despu√©s de la fuente asincr√≥nica, y aqu√≠, para decidir en qu√© hilo ejecutar el c√≥digo despu√©s de la operaci√≥n asincr√≥nica, debemos consultar el contexto de sincronizaci√≥n guardado anteriormente.  Como √©l dice, lo haremos.  √âl le dir√° que ejecute en el mismo hilo que el c√≥digo antes de esperar - ejecutaremos en el mismo hilo, no lo dir√° - tomaremos el primer hilo del grupo. </p><br><p>  Pero, ¬øqu√© sucede si, en este caso particular, es importante para nosotros que el c√≥digo despu√©s de esperar se ejecute en cualquier subproceso libre del grupo de subprocesos?  Debe usar el mantra <code>ConfigureAwait(false)</code> .  El valor falso pasado al par√°metro <code>continueOnCapturedContext</code> le dice al sistema que se puede usar cualquier subproceso del grupo.  Y qu√© sucede si en el momento de la ejecuci√≥n del m√©todo con wait no hab√≠a ning√∫n contexto de sincronizaci√≥n ( <code>SynchronizationContext.Current == null</code> ), como por ejemplo en una aplicaci√≥n de consola.  En este caso, no tenemos restricciones en el subproceso en el que se debe ejecutar el c√≥digo despu√©s de esperar y el sistema tomar√° el primer subproceso del grupo, como en el caso de <code>ConfigureAwait(false)</code> . </p><br><p>  Entonces, ¬øqu√© es un punto muerto as√≠ncrono? </p><br><h4>  Punto muerto en WPF y WinForms </h4><br><p>  La diferencia entre las aplicaciones WPF y WinForms es el contexto de sincronizaci√≥n.  El contexto de sincronizaci√≥n de WPF y WinForms tiene un hilo especial: el hilo de la interfaz de usuario.  Hay un subproceso de interfaz de usuario por <code>SynchronizationContext</code> y solo desde este subproceso pueden interactuar con los elementos de la interfaz de usuario.  De manera predeterminada, el c√≥digo que comenz√≥ a funcionar en el subproceso de la interfaz de usuario reanuda la operaci√≥n despu√©s de una operaci√≥n asincr√≥nica en √©l. </p><br>  Ahora veamos un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br>  Qu√© sucede cuando llamas a <code>StartWork().Wait()</code> : <br><br><ol><li>  El hilo de llamada (y este es el hilo de la interfaz de usuario) ir√° al m√©todo <code>StartWork</code> e <code>StartWork</code> a la instrucci√≥n <code>await Task.Delay(100)</code> . </li><li>  El subproceso de la interfaz de usuario iniciar√° la <code>Task.Delay(100)</code> asincr√≥nica <code>Task.Delay(100)</code> , y devolver√° el control al m√©todo <code>Button_Click</code> , y all√≠ el m√©todo <code>Wait()</code> de la clase <code>Task</code> lo esperar√°.  Cuando se llama al m√©todo <code>Wait()</code> , el subproceso de la interfaz de usuario se bloquear√° hasta el final de la operaci√≥n asincr√≥nica, y esperamos que tan pronto como se complete, el subproceso de la interfaz de usuario recoja inmediatamente la ejecuci√≥n y avance m√°s en el c√≥digo, sin embargo, no todo ser√° as√≠. </li><li>  Tan pronto como se <code>Task.Delay(100)</code> , el subproceso de la interfaz de usuario primero deber√° continuar ejecutando el m√©todo <code>StartWork()</code> y para esto necesita exactamente el subproceso en el que comenz√≥ la ejecuci√≥n.  Pero el hilo de la interfaz de usuario ahora est√° esperando el resultado de la operaci√≥n. </li><li>  <code>StartWork()</code> : <code>StartWork()</code> no puede continuar la ejecuci√≥n y devolver el resultado, y <code>Button_Click</code> est√° esperando el mismo resultado, y debido a que la ejecuci√≥n comenz√≥ en el hilo de la interfaz de usuario, la aplicaci√≥n simplemente se cuelga sin la posibilidad de continuar trabajando. </li></ol><br>  Esta situaci√≥n se puede tratar simplemente cambiando la llamada a <code>Task.Delay(100)</code> a <code>Task.Delay(100).ConfigureAwait(false)</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, System.Windows.RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { StartWork().Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the instruction following await"</span></span>; }</code> </pre><br><p>  Este c√≥digo funcionar√° sin puntos muertos, ya que ahora se puede usar un subproceso del grupo para completar el m√©todo <code>StartWork()</code> , en lugar de un subproceso de interfaz de usuario bloqueado.  Stephen Clary recomienda usar <code>ConfigureAwait(false)</code> en todos los "m√©todos de biblioteca" en su blog, pero enfatiza espec√≠ficamente que usar <code>ConfigureAwait(false)</code> para tratar puntos muertos no es una buena pr√°ctica.  En cambio, aconseja NO usar m√©todos de bloqueo como <code>Wait()</code> , <code>Result</code> , <code>GetAwaiter().GetResult()</code> y <code>GetAwaiter().GetResult()</code> todos los m√©todos para usar async / wait, si es posible (el llamado principio Async all-way). </p><br><h4>  Punto muerto en ASP.NET </h4><br><p>  ASP.NET tambi√©n tiene un contexto de sincronizaci√≥n, pero tiene limitaciones ligeramente diferentes.  Le permite usar solo un subproceso por solicitud a la vez y tambi√©n requiere que el c√≥digo despu√©s de esperar se ejecute en el mismo subproceso que el c√≥digo antes de esperar. </p><br>  Un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HomeController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deadlock</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartWork().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Just to illustrate the code following await"</span></span>; } }</code> </pre><br><p>  Este c√≥digo tambi√©n provocar√° un punto muerto, ya que en el momento de la llamada a <code>StartWork().Wait()</code> √∫nico subproceso permitido se bloquear√° y esperar√° a que <code>StartWork()</code> operaci√≥n <code>StartWork()</code> , y nunca terminar√°, ya que el subproceso en el que la ejecuci√≥n debe continuar est√° ocupado esperando </p><br><p>  Todo esto se soluciona con el mismo <code>ConfigureAwait(false)</code> . </p><br><h4>  Punto muerto en ASP.NET Core (en realidad no) </h4><br><p>  Ahora intentemos ejecutar el c√≥digo del ejemplo para ASP.NET en el proyecto para ASP.NET Core.  Si hacemos esto, veremos que no habr√° punto muerto.  Esto se debe a que ASP.NET Core <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no tiene un contexto de sincronizaci√≥n</a> .  Genial  ¬øY ahora puede cubrir el c√≥digo con llamadas de bloqueo y no tener miedo a los puntos muertos?  Estrictamente hablando, s√≠, pero recuerde que esto hace que el hilo se duerma mientras espera, es decir, el hilo consume recursos, pero no hace ning√∫n trabajo √∫til. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/qe/hc/pvqehcevrmzzqhylr7vtedbqwtc.png"></div><br><br><p></p><blockquote>  <b>Recuerde que el uso de llamadas bloqueadas elimina todas las ventajas de la programaci√≥n asincr√≥nica convirti√©ndola en s√≠ncrona</b> .  S√≠, a veces sin usar <code>Wait()</code> no funcionar√° escribir un programa, pero la raz√≥n debe ser seria. </blockquote><br><h2>  Uso err√≥neo de Task.Run () </h2><br><p>  El m√©todo <code>Task.Run()</code> se cre√≥ para iniciar operaciones en un nuevo hilo.  Como corresponde a un m√©todo escrito en un patr√≥n TAP, devuelve <code>Task</code> o <code>Task&lt;T&gt;</code> y las personas que se enfrentan a async / wait por primera vez tienen un gran deseo de envolver el c√≥digo sincr√≥nico en <code>Task.Run()</code> y eliminar el resultado de este m√©todo.  El c√≥digo parec√≠a volverse as√≠ncrono, pero de hecho, nada ha cambiado.  Veamos qu√© sucede con este uso de <code>Task.Run()</code> . </p><br>  Un ejemplo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Run(() =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside before sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Inside after sleep: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"After: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br>  El resultado de este c√≥digo ser√°: <br><br><pre> <code class="plaintext hljs">Before: 1 Inside before sleep: 3 Inside after sleep: 3 After: 3</code> </pre><br><p>  Aqu√≠ <code>Thread.Sleep(1000)</code> es alg√∫n tipo de operaci√≥n s√≠ncrona que requiere un subproceso para completarse.  Supongamos que queremos hacer que nuestra soluci√≥n sea asincr√≥nica y para que esta operaci√≥n pueda ser sacrificada, la <code>Task.Run()</code> en <code>Task.Run()</code> . </p><br><p>  Tan pronto como el c√≥digo llega al m√©todo <code>Task.Run()</code> , se toma otro subproceso del grupo de subprocesos y se ejecuta el c√≥digo que pasamos a <code>Task.Run()</code> .  El hilo viejo, como corresponde a un hilo decente, regresa al grupo y espera a que lo llamen nuevamente para hacer el trabajo.  El nuevo subproceso ejecuta el c√≥digo transmitido, alcanza la operaci√≥n sincr√≥nica, lo ejecuta sincr√≥nicamente (espera hasta que se complete la operaci√≥n) y avanza a lo largo del c√≥digo.  En otras palabras, la operaci√≥n permaneci√≥ sincr√≥nica: nosotros, como antes, usamos el flujo durante la ejecuci√≥n de la operaci√≥n sincr√≥nica.  La √∫nica diferencia es que pasamos tiempo cambiando de contexto al llamar a <code>Task.Run()</code> y regresar a <code>ExecuteOperation()</code> .  Todo se ha vuelto un poco peor. </p><br><p>  Debe entenderse que a pesar del hecho de que en las l√≠neas <code>Inside after sleep: 3</code> y <code>After: 3</code> vemos el mismo Id de la secuencia, el contexto de ejecuci√≥n es completamente diferente en estos lugares.  ASP.NET es simplemente m√°s inteligente que nosotros e intenta ahorrar recursos al cambiar el contexto del c√≥digo dentro de <code>Task.Run()</code> a c√≥digo externo.  Aqu√≠ decidi√≥ no cambiar al menos el flujo de ejecuci√≥n. </p><br><p>  En tales casos, no tiene sentido usar <code>Task.Run()</code> .  En cambio, Clary <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aconseja</a> que todas las operaciones sean as√≠ncronas, es decir, en nuestro caso, reemplazar <code>Thread.Sleep(1000)</code> con <code>Task.Delay(1000)</code> , pero esto, por supuesto, no siempre es posible.  ¬øQu√© hacer en los casos en que usamos bibliotecas de terceros que no podemos o no queremos reescribir y hacer asincr√≥nicas hasta el final, pero por una raz√≥n u otra necesitamos el m√©todo as√≠ncrono?  Es mejor usar <code>Task.FromResult()</code> para ajustar el resultado de los m√©todos del proveedor en Task.  Esto, por supuesto, no har√° que el c√≥digo sea as√≠ncrono, pero al menos ahorraremos en el cambio de contexto. </p><br><p></p><blockquote>  <b>¬øPor qu√© entonces usar Task.Run ()?</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La respuesta es simple:</a> para operaciones vinculadas a la CPU, cuando necesita mantener la capacidad de respuesta de la interfaz de usuario o paralelizar los c√°lculos.  Debe decirse aqu√≠ que las operaciones vinculadas a la CPU son de naturaleza s√≠ncrona.  Fue para lanzar operaciones sincr√≥nicas en un estilo asincr√≥nico que se invent√≥ <code>Task.Run()</code> . </blockquote><br><h2>  Mal uso del vac√≠o as√≠ncrono </h2><br>  Se ha agregado la capacidad de escribir m√©todos asincr√≥nicos que devuelven <code>void</code> para escribir controladores de eventos asincr√≥nicos.  Veamos por qu√© pueden causar confusi√≥n si se usan para otros fines: <br><br><ol><li>  No puedes esperar el resultado. </li><li>  El manejo de excepciones a trav√©s de try-catch no es compatible. </li><li>  Es imposible combinar llamadas a trav√©s de <code>Task.WhenAll()</code> , <code>Task.WhenAny()</code> y otros m√©todos similares. </li></ol><br><p>  De todas estas razones, el punto m√°s interesante es el manejo de excepciones.  El hecho es que en los m√©todos as√≠ncronos que devuelven <code>Task</code> o <code>Task&lt;T&gt;</code> , las excepciones se capturan y se envuelven en un objeto <code>Task</code> , que luego se pasar√° al m√©todo de llamada.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su art√≠culo de MSDN,</a> Clary escribe que, dado que no existe un valor de retorno en los m√©todos de as√≠ncrono nulo, no hay nada para incluir las excepciones y se lanzan directamente en el contexto de la sincronizaci√≥n.  El resultado es una excepci√≥n no controlada debido a que el proceso se bloquea, teniendo tiempo para, quiz√°s, escribir un error en la consola.  Puede obtener y reservar tales excepciones suscribi√©ndose al evento <code>AppDomain.UnhandledException</code> , pero ya no podr√° detener el bloqueo del proceso incluso en el controlador de este evento.  Este comportamiento es t√≠pico solo para el controlador de eventos, pero no para el m√©todo habitual, del cual esperamos la posibilidad de manejo de excepciones est√°ndar a trav√©s de try-catch. </p><br>  Por ejemplo, si escribe as√≠ en una aplicaci√≥n ASP.NET Core, se garantiza que el proceso caer√°: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowInAsyncVoid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThrowAsynchronously(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThrowAsynchronously</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Obviously, something happened"</span></span>); }</code> </pre><br><p>  Pero vale la pena cambiar el tipo de <code>ThrowAsynchronously</code> m√©todo <code>ThrowAsynchronously</code> a <code>Task</code> (sin siquiera agregar la palabra clave <code>ThrowAsynchronously</code> ) y el controlador de errores est√°ndar ASP.NET Core <code>ThrowAsynchronously</code> la excepci√≥n, y el proceso continuar√° vivo a pesar de la ejecuci√≥n. </p><br><p></p><blockquote>  <b>Tenga cuidado con los m√©todos async-void</b> : pueden ponerlo en el proceso. </blockquote><br><h2>  esperar en un m√©todo de una sola l√≠nea </h2><br><p>  El √∫ltimo antipatr√≥n no da tanto miedo como los anteriores.  La conclusi√≥n es que no tiene sentido usar async / await en m√©todos que, por ejemplo, simplemente reenv√≠an el resultado de otro m√©todo async m√°s all√°, con la posible excepci√≥n de usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">await en el uso</a> . </p><br>  En lugar de este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br>  ser√≠a completamente posible (y preferiblemente) escribir: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethodAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><p>  Por que funciona  Porque la palabra clave de espera se puede aplicar a objetos similares a Tarea, y no a m√©todos marcados con la palabra clave as√≠ncrona.  A su vez, la palabra clave as√≠ncrona solo le dice al compilador que este m√©todo debe implementarse en una m√°quina de estado, y todos los valores devueltos deben incluirse en una <code>Task</code> (o en otro objeto similar a la Tarea). </p><br><p>  En otras palabras, el resultado de la primera versi√≥n del m√©todo es <code>Task</code> , que se <code>Completed</code> tan pronto como <code>Task.Delay(1000)</code> la espera de <code>Task.Delay(1000)</code> , y el resultado de la segunda versi√≥n del m√©todo es <code>Task</code> , devuelto por <code>Task.Delay(1000)</code> , que se <code>Completed</code> tan pronto como pasen 1000 milisegundos . </p><br><p>  Como puede ver, ambas versiones son equivalentes, pero al mismo tiempo, la primera requiere muchos m√°s recursos para crear un "kit de cuerpo" as√≠ncrono. </p><br><p></p><blockquote>  Alex Davis escribe que el <b>costo de invocar directamente el m√©todo asincr√≥nico puede ser diez veces el costo de invocar el m√©todo sincr√≥nico</b> , por lo que hay algo por lo que tratar. </blockquote><br><br>  <b>UPD:</b> <br>  Como los comentarios se√±alan correctamente, cortar async / esperar de los m√©todos de una sola l√≠nea conduce a efectos secundarios negativos.  Por ejemplo, al lanzar una excepci√≥n, el m√©todo que arroja la tarea no ser√° visible en la pila.  Por lo tanto, <b>no se recomienda eliminar los valores predeterminados de manera predeterminada</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La publicaci√≥n de Clary</a> con an√°lisis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435666/">https://habr.com/ru/post/es435666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435652/index.html">C√≥mo no contrase√±as en scripts de Python</a></li>
<li><a href="../es435654/index.html">Errores de las propiedades CSS personalizadas</a></li>
<li><a href="../es435656/index.html">Scooter Rolls Royce - Ninebot KickScooter ES4 de Segway</a></li>
<li><a href="../es435662/index.html">"Fiabilidad y fiabilidad como en Google", y no solo: traducci√≥n del art√≠culo "C√°lculo de la fiabilidad del servicio"</a></li>
<li><a href="../es435664/index.html">Falsificaci√≥n de motores de b√∫squeda de Google</a></li>
<li><a href="../es435668/index.html">Otra ley de la primavera: el diputado propuso permitir a la polic√≠a rastrear la ubicaci√≥n de los ni√±os mediante geolocalizaci√≥n</a></li>
<li><a href="../es435670/index.html">Algoritmo supremo: distribuci√≥n de algoritmos por nivel de dificultad</a></li>
<li><a href="../es435672/index.html">C√≥mo volver a capacitarse en inteligencia empresarial</a></li>
<li><a href="../es435678/index.html">No conf√≠e en la informaci√≥n de la memoria en el Administrador de tareas</a></li>
<li><a href="../es435680/index.html">AWS mostr√≥ el dedo medio de c√≥digo abierto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>