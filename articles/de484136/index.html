<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≠ üò≤ üíÄ Python (+ numba) ist schneller als C - wirklich?! Teil 1. Theorie üëÆ üë®üèΩ‚Äçüéì üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lange Zeit wollte ich einen Artikel √ºber Numba schreiben und seine Geschwindigkeit mit Si vergleichen. Haskell-Artikel ‚Äû Schneller als C ++; langsamer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python (+ numba) ist schneller als C - wirklich?! Teil 1. Theorie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484136/"><p>  Lange Zeit wollte ich einen Artikel √ºber Numba schreiben und seine Geschwindigkeit mit Si vergleichen.  Haskell-Artikel ‚Äû <a href="https://habr.com/ru/post/483864/">Schneller als C ++;</a>  <a href="https://habr.com/ru/post/483864/">langsamer als PHP</a> ‚Äú.  In den Kommentaren zu diesem Artikel wurde die numba-Bibliothek erw√§hnt, mit der sich die Geschwindigkeit der Codeausf√ºhrung in Python auf magische Weise der Geschwindigkeit in s ann√§hern l√§sst.  In diesem Artikel wird nach einem kurzen R√ºckblick auf numba (Teil 1) eine etwas detailliertere Analyse dieser Situation ( <a href="https://habr.com/ru/post/484142/">Teil 2</a> ) gegeben. </p><br><p><img src="https://habrastorage.org/webt/a8/i_/ej/a8i_ejoqo5krkvtbdxo7fahp3p8.jpeg"></p><a name="habracut"></a><br><p> Der Hauptnachteil einer Python ist ihre Geschwindigkeit.  Das √úbertakten von Pythons mit unterschiedlichem Erfolg begann fast in den ersten Tagen seines Bestehens: <a href="https://ru.wikipedia.org/wiki/Shedskin" rel="nofollow">Schuppen</a> , <a href="https://en.wikipedia.org/wiki/Psyco" rel="nofollow">Psyco</a> , <a href="https://ru.wikipedia.org/wiki/Unladen_Swallow" rel="nofollow">unbeladenes Flachwasser</a> , <a href="https://github.com/iskandr/parakeet" rel="nofollow">Sittich</a> , <a href="https://ru.wikipedia.org/wiki/Nuitka" rel="nofollow">Theano</a> , <a href="https://pythran.readthedocs.io/en/latest/" rel="nofollow">Nuitka</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">Pythran</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">Cython</a> , <a href="https://ru.wikipedia.org/wiki/PyPy" rel="nofollow">Pypy</a> , <a href="https://en.wikipedia.org/wiki/Numba" rel="nofollow">Numba</a> . <br><img src="https://habrastorage.org/webt/yy/4u/gr/yy4ugrto-i7axd0v6ds5cj58lmk.png"><br>  Bisher sind die letzten drei am gefragtesten.  <code>Cython</code> (nicht zu verwechseln mit Cpython) - ist semantisch ganz anders als regul√§res Python.  In der Tat ist dies eine separate Sprache - eine Mischung aus C und Python.  <code>pypy</code> (eine alternative Implementierung des Python-√úbersetzers mit jit-Kompilierung) und <code>numba</code> (eine Bibliothek zur Code-Kompilierung in llvm) gingen unterschiedliche Wege.  <code>pypy</code> erkl√§rte zun√§chst die Unterst√ºtzung f√ºr alle Python-Konstrukte.  In numba gingen sie davon aus, dass es am h√§ufigsten cpu-gebundene mathematische Berechnungen erfordert, sie identifizierten den Teil der mit Berechnungen verbundenen Sprache und begannen, sie zu √ºbertakten, wodurch die "Abdeckung" allm√§hlich zunahm (zum Beispiel gab es bis vor kurzem keine Unterst√ºtzung f√ºr Leitungen) , jetzt ist sie erschienen).  Dementsprechend wird nicht das gesamte Programm in <code>numba</code> √ºbertaktet, sondern es werden <em>separate Funktionen verwendet</em> . Auf diese Weise k√∂nnen Sie hohe Geschwindigkeit und Abw√§rtskompatibilit√§t mit Bibliotheken <code>numba</code> , die <code>numba</code> (noch) nicht unterst√ºtzt.  Numpy wird (mit geringf√ºgigen Einschr√§nkungen) sowohl in <code>pypy</code> als auch in <code>numba</code> . </p><br><p><img src="https://habrastorage.org/webt/c0/7l/_y/c07l_ygigxdy7wsfwnyn_nfm2v4.png" width="30%" align="right">  Meine Bekanntschaft mit Numba begann 2015 mit dieser Frage zum Stackoverflow √ºber die Geschwindigkeit der Matrixmultiplikation in Python: <a href="https://stackoverflow.com/questions/27809511/efficient-outer-product-in-python" rel="nofollow">Effizientes Au√üenprodukt in Python</a> </p><br><p>  Seitdem sind viele Ereignisse in jeder der Bibliotheken aufgetreten, aber das Bild in Bezug auf <code>numba</code> / <code>numba</code> / <code>pypy</code> sich <code>numba</code> nicht ge√§ndert: <code>numba</code> √ºberholt <code>cython</code> durch die Verwendung nativer Prozessoranweisungen ( <code>cython</code> kann nicht jit) und <code>pypy</code> - aufgrund einer effizienteren Ausf√ºhrung von llvm-Bytecode . </p><br><p>  Numba ist n√ºtzlich f√ºr mich bei der Arbeit (Verarbeitung hyperspektraler Bilder) und im Unterricht (numerische Integration, L√∂sen von Differentialgleichungen). </p><br><h4 id="kak-ustanovit">  wie man einstellt </h4><br><p>  Vor ein paar Jahren gab es Probleme mit der Installation, jetzt wurde alles gel√∂st: Es l√§sst sich sowohl durch <code>pip install numba</code> als auch durch <code>conda install numba</code> gleich gut <code>conda install numba</code> .  llvm wird automatisch angezogen und installiert. </p><br><h4 id="kak-uskoryat">  wie man beschleunigt </h4><br><p>  Um eine Funktion zu beschleunigen, m√ºssen Sie den njit-Dekorator eingeben, bevor Sie ihn definieren: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> njit @njit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> s = <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): s += sqrt(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s</code> </pre> <br><p>  Beschleunigung von <strong>40</strong> mal. </p><br><p>  Die Wurzel wird ben√∂tigt, da sonst numba die Summe des arithmetischen Verlaufs (!) Erkennt und in konstanter Zeit berechnet. </p><br><h4 id="jit-vs-njit">  jit vs njit </h4><br><p>  Bisher war nur der <code>@jit</code> Modus (nicht <code>@njit</code> ) relevant.  Der Punkt ist, dass Sie in diesem Modus Operationen verwenden k√∂nnen, die von numba nicht unterst√ºtzt werden: die numba mit hoher Geschwindigkeit erreicht die erste solche Operation, verlangsamt sich dann und dauert bis zum Ende der Funktionsausf√ºhrung mit der √ºblichen Python-Geschwindigkeit an, auch wenn in der Funktion nichts mehr "Verbotenes" auftritt ( der sogenannte Objektmodus), der offensichtlich irrational ist.  Jetzt geben <code>@jit</code> und nach auf. Es wird immer empfohlen, @njit (oder in voller Form <code>@jit(nopython=True)</code> ) zu verwenden. In diesem Modus schw√∂rt die Zahl mit Ausnahmen auf solche Stellen - es ist besser, sie neu zu schreiben, um nicht an Geschwindigkeit zu verlieren. </p><br><h4>  was kann beschleunigen </h4><br><p>  In √ºbertakteten Funktionen kann nur ein Teil der Python- und Numba-Funktionalit√§t verwendet werden.  Alle Operatoren, Funktionen und Klassen sind in Bezug auf die Numba in zwei Teile unterteilt: die, die die Numba "versteht" und die, die sie "nicht versteht". </p><br><p>  In der numba-Dokumentation gibt es zwei solcher Listen (mit Beispielen): </p><br><ul><li>  eine Untergruppe der <a href="https://numba.pydata.org/numba-doc/dev/reference/pysupported.html" rel="nofollow">Python-</a> Funktionen, die numbe und </li><li>  eine Untermenge der <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numpy-</a> Funktion, die <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numbe</a> kennt. </li></ul><br><p>  Aus den bemerkenswerten in diesen Listen: </p><br><ul><li>  eine numba "versteht" Python-Listen mit einem schnellen (amortisierten O (1)) Zusatz zum Ende, den numpy "nicht versteht" (obwohl nur homogene aus Elementen desselben Typs), </li><li>  Numpy's Arrays, die nicht im Basis-Python enthalten sind.  Versteht auch </li><li>  Tupel: Sie k√∂nnen, wie ein normaler Python, Elemente verschiedener Typen enthalten. </li><li>  w√∂rterb√ºcher: numba hat eine eigene Implementierung eines typisierten W√∂rterbuchs.  Alle Schl√ºssel m√ºssen vom selben Typ sein, genau wie die Werte.  Das Python-Diktat kann nicht an numba √ºbergeben werden, aber das numba <code>numba.typed.Dict</code> kann in Python erstellt und nach / von numba √ºbertragen werden (w√§hrend es in Python etwas langsamer als Python arbeitet). </li><li>  In letzter Zeit k√∂nnen str und bytes jedoch nur als Eingabeparameter noch nicht angelegt werden. </li></ul><br><p>  Sie versteht √ºberhaupt keine anderen Bibliotheken (insbesondere scipy und pandas). </p><br><p>  Aber selbst diese Untergruppe der Sprache, die sie versteht, reicht aus, um den gr√∂√üten Teil des Codes f√ºr wissenschaftliche Anwendungen zu √ºbertakten, auf die sich numba in erster Linie konzentriert. </p><br><h4>  wichtig! </h4><br><p>  Von den √ºbertakteten Funktionen k√∂nnen nur √ºbertaktete und keine √ºbertakteten Funktionen aufgerufen werden. <br>  (obwohl √ºbertaktete Funktionen von √ºbertaktet und nicht √ºbertaktet aufgerufen werden k√∂nnen). </p><br><h4>  Globals </h4><br><p>  In √ºbertakteten Funktionen werden globale Variablen zu Konstanten: Ihr Wert wird beim Kompilieren der Funktion festgelegt ( <a href="https://python-nsu.bitbucket.io/numba/globals.html" rel="nofollow">Beispiel</a> ).  =&gt; Verwenden Sie keine globalen Variablen in √ºbertakteten Funktionen (au√üer Konstanten). </p><br><h4>  Unterschriften </h4><br><p>  In der Zahl jeder Funktion werden eine oder mehrere Arten von Eingabe- und Ausgabeargumenten abgebildet, d.h.  Unterschriften.  Beim ersten Aufruf der Funktion wird die Signatur generiert und der entsprechende bin√§re Funktionscode automatisch √ºbersetzt.  Beim Starten mit anderen Argumenttypen werden neue Signaturen und neue Bin√§rdateien erstellt (die alten bleiben erhalten).  Somit erfolgt der "Exit to the Mode" in Bezug auf die Ausf√ºhrungsgeschwindigkeit f√ºr jede Signatur, beginnend mit dem zweiten Durchlauf mit diesen Arten von Argumenten.  Also auch nicht </p><br><ul><li>  "Aufw√§rmen des Caches" durch Starten mit kleinen Eingabearrays oder </li><li>  <code>@jit(cache=True)</code> das Argument <code>@jit(cache=True)</code> an, um den kompilierten Code mit seinem automatischen Laden bei nachfolgenden Programmstarts auf der Festplatte zu speichern (obwohl dieser erste Start in der heutigen Praxis noch etwas langsamer ist als die nachfolgenden, aber schneller als ohne <code>cache=True</code> ). . </li></ul><br><p>  Es gibt einen dritten Weg.  Signaturen k√∂nnen manuell gesetzt werden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y &gt;&gt;&gt; f.signatures [(int16, int16)]</code> </pre> <br><p>  Wenn Sie eine Funktion mit der im Dekorator angegebenen Signatur ausf√ºhren, ist die erste Ausf√ºhrung schnell: Die Kompilierung wird in dem Moment ausgef√ºhrt, in dem der Python die Definition der Funktion sieht, und nicht beim ersten Start.  Es kann mehrere Signaturen geben, die Reihenfolge ihrer Reihenfolge ist wichtig. </p><br><p>  Warnung: Diese letzte Methode ist nicht zukunftssicher.  Die Autoren von numba warnen davor, dass sich die Syntax f√ºr die Angabe von Typen in Zukunft √§ndern k√∂nnte. <code>@jit</code> / <code>@njit</code> ohne Signaturen ist in dieser Hinsicht eine sicherere Option. </p><br><p>  <code>f.signatures</code> erst dann signiert, wenn der Python davon erf√§hrt, <code>f.signatures</code> nach dem ersten Funktionsaufruf oder wenn sie manuell festgelegt wurden. </p><br><p>  Zus√§tzlich zu <code>f.signatures</code> Signaturen √ºber <code>f.inspect_types()</code> Zus√§tzlich zu den Typen der Eingabeparameter zeigt diese Funktion die Typen der Ausgabeparameter sowie die Typen aller lokalen Variablen an. </p><br><p>  Zus√§tzlich zu den Typen der Eingabe- und Ausgabeparameter k√∂nnen die Typen der lokalen Variablen manuell angegeben werden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16), locals={<span class="hljs-string"><span class="hljs-string">'z'</span></span>: int32}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> z = y + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + z</code> </pre> <br><h4 id="int">  int </h4><br><p>  In numba haben Ganzzahlen keine lange Arithmetik wie in "einfachem" Python, aber es gibt Standardtypen mit verschiedenen Breiten von <code>int8</code> bis <code>int64</code> ( <code>int64</code> in der Dokumentation).  Es gibt auch die Typen <code>int_</code> (sowie <code>float_</code> ), mit denen Sie der Zahl die M√∂glichkeit geben, die (aus ihrer Sicht) optimale Feldbreite zu w√§hlen. </p><br><h4 id="klassy">  Klassen </h4><br><p>  Es gibt generell Unterst√ºtzung f√ºr Klassen (@jitclass), aber bisher ist es experimentell, daher ist es besser, sie vorerst nicht zu verwenden (momentan ist es meiner Erfahrung nach mit ihnen viel langsamer als ohne sie). </p><br><h4 id="custom-dtypes">  benutzerdefinierte dtypes </h4><br><p>  Numba unterst√ºtzt eine bestimmte Alternative zu Klassen aus Arrays mit Numpy-Struktur oder, mit anderen Worten, benutzerdefinierten Datentypen.  Sie arbeiten mit der gleichen Geschwindigkeit wie normale Numpy-Arrays. Sie lassen sich leichter indizieren (beispielsweise ist <code>a['y2']</code> besser lesbar als <code>a[3]</code> ).  Interessanterweise ist in numba im Gegensatz zu numpy ein pr√§gnanteres <code>a.y2</code> zusammen mit der √ºblichen Syntax <code>a['y2']</code> .  Aber im Allgemeinen l√§sst ihre Unterst√ºtzung in der Numba zu w√ºnschen √ºbrig, und einige Operationen, die sogar in der Numba offensichtlich sind, mit ihnen in der Numba werden ganz untrivial aufgezeichnet. </p><br><h4 id="gpu">  GPU </h4><br><p>  Es ist in der Lage, √ºbertakteten Code auf der GPU und im Gegensatz zu demselben, zum Beispiel Pycuda oder Pytorch, nicht nur auf NVIDIA-, sondern auch auf AMD'sHNYH-Karten auszuf√ºhren.  Damit ist bisher wenig zu tun.  Hier ist ein Artikel zum Hub 2016  Dort wurde eine mit C vergleichbare Geschwindigkeit erhalten. </p><br><h4 id="ahead-of-time-kompilyaciya">  vorzeitige Kompilierung </h4><br><p>  Es gibt einen Modus f√ºr die normale (dh nicht jit) Kompilierung ( <a href="https://numba.pydata.org/numba-doc/dev/user/pycc.html" rel="nofollow">Dokumentation</a> ) in der Numba, aber dieser Modus ist nicht der Hauptmodus, ich habe ihn nicht verstanden. </p><br><h4 id="avtomaticheskoe-rasparallelivanie">  automatische Parallelisierung </h4><br><p>  Einige Aufgaben (z. B. das Multiplizieren einer Matrix mit einer Zahl) werden auf nat√ºrliche Weise parallelisiert.  Es gibt jedoch Aufgaben, deren Umsetzung nicht parallelisiert werden kann.  Mit dem <code>@njit(parallel=True)</code> Dekorator <code>@njit(parallel=True)</code> analysiert <code>@njit(parallel=True)</code> numba den Code der √ºbertakteten Funktion, findet solche Abschnitte, von denen jeder f√ºr sich nicht parallelisiert werden kann, und f√ºhrt sie gleichzeitig auf verschiedenen CPU-Kernen aus ( <a href="https://numba.pydata.org/numba-doc/dev/user/parallel.html" rel="nofollow">Dokumentation</a> ).  Bisher konnten Sie Funktionen nur manuell mithilfe von <code>@vectorize</code> ( <a href="https://numba.pydata.org/numba-doc/dev/reference/jit-compilation.html" rel="nofollow">Dokumentation</a> ) parallelisieren, wodurch Code√§nderungen erforderlich wurden. </p><br><p>  In der Praxis sieht es so aus: add <code>parallel=True</code> , messen Sie die Geschwindigkeit, wenn wir Gl√ºck haben und es schneller geworden ist - wir lassen es, langsamer - wir entfernen es.  (** Update Wie im <a href="https://habr.com/ru/post/484142/">Kommentar</a> zum zweiten Teil des Artikels erw√§hnt, weist dieses Flag viele offene Fehler auf.) </p><br><h4 id="osvobozhdenie-gil">  GIL-Ver√∂ffentlichung </h4><br><p>  Funktionen, die mit <code>@jit(nogil=True)</code> dekoriert sind und in verschiedenen Threads ausgef√ºhrt werden, k√∂nnen parallel ausgef√ºhrt werden.  Um Rennbedingungen zu vermeiden, m√ºssen Sie die Thread-Synchronisierung verwenden. </p><br><h4 id="dokumentaciya">  die Dokumentation </h4><br><p>  Numbe fehlt noch eine vern√ºnftige Dokumentation.  Sie ist, aber nicht alles ist in ihr. </p><br><h4 id="optimizaciya">  Optimierung </h4><br><p>  Es gibt eine gewisse Unvorhersehbarkeit bei der manuellen Optimierung von Code: Unpython-Code wird h√§ufig schneller ausgef√ºhrt als Python. </p><br><p>  F√ºr diejenigen, die sich f√ºr das Thema interessieren, kann ich ein <a href="https://www.youtube.com/watch%3Fv%3D1AwG0T4gaO0" rel="nofollow">Video eines</a> numba-Meisterkurses von der scipy 2017-Konferenz empfehlen (es gibt <a href="https://github.com/gforsyth/numba_tutorial_scipy2017" rel="nofollow">Quellcodes</a> auf dem Github).  Es ist sehr lang und teilweise veraltet (zum Beispiel, Strings werden bereits unterst√ºtzt), aber es hilft, sich einen √úberblick zu verschaffen: Es enth√§lt insbesondere Informationen zu Pythonic / Unpythonic, <a href="https://habr.com/ru/users/jit/" class="user_link">JIT</a> (parallel = True) usw. </p><br><p>  Im <a href="https://habr.com/ru/post/484142/">zweiten</a> Teil betrachten wir die Verwendung von numba unter Verwendung des Codes aus dem am Anfang des Artikels erw√§hnten Artikel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484136/">https://habr.com/ru/post/de484136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484114/index.html">Eine Auswahl von 143 √úbersetzungen des Aufsatzes von Paul Graham (von 184)</a></li>
<li><a href="../de484118/index.html">32 Januar</a></li>
<li><a href="../de484120/index.html">Die gefragtesten F√§higkeiten im Beruf des Dateningenieurs</a></li>
<li><a href="../de484124/index.html">Nikolai Prokhorov: ‚ÄûIn Finnland gab es eine riesige Abteilung von Vneshtorg, die unsere Autos ins Ausland lieferte.‚Äú</a></li>
<li><a href="../de484130/index.html">Microservices mit Spring Boot. Teil 1. Erste Schritte</a></li>
<li><a href="../de484142/index.html">Python (+ numba) ist schneller als C - wirklich?! Teil 2. √úben</a></li>
<li><a href="../de484146/index.html">T√§uschungen im Internet werden nicht verschwinden - was sollen wir tun?</a></li>
<li><a href="../de484148/index.html">SVM Erkl√§rung von Grund auf neu und Implementierung in Python. Detaillierte Analyse der Support-Vektor-Methode</a></li>
<li><a href="../de484150/index.html">5 neue Tools zum Erstellen von unterhaltsamen Inhalten</a></li>
<li><a href="../de484152/index.html">Hochgeschwindigkeits-PAC-Controller WISE-5580</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>