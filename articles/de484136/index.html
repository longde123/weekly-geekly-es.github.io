<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏭 😲 💀 Python (+ numba) ist schneller als C - wirklich?! Teil 1. Theorie 👮 👨🏽‍🎓 🍔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lange Zeit wollte ich einen Artikel über Numba schreiben und seine Geschwindigkeit mit Si vergleichen. Haskell-Artikel „ Schneller als C ++; langsamer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python (+ numba) ist schneller als C - wirklich?! Teil 1. Theorie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484136/"><p>  Lange Zeit wollte ich einen Artikel über Numba schreiben und seine Geschwindigkeit mit Si vergleichen.  Haskell-Artikel „ <a href="https://habr.com/ru/post/483864/">Schneller als C ++;</a>  <a href="https://habr.com/ru/post/483864/">langsamer als PHP</a> “.  In den Kommentaren zu diesem Artikel wurde die numba-Bibliothek erwähnt, mit der sich die Geschwindigkeit der Codeausführung in Python auf magische Weise der Geschwindigkeit in s annähern lässt.  In diesem Artikel wird nach einem kurzen Rückblick auf numba (Teil 1) eine etwas detailliertere Analyse dieser Situation ( <a href="https://habr.com/ru/post/484142/">Teil 2</a> ) gegeben. </p><br><p><img src="https://habrastorage.org/webt/a8/i_/ej/a8i_ejoqo5krkvtbdxo7fahp3p8.jpeg"></p><a name="habracut"></a><br><p> Der Hauptnachteil einer Python ist ihre Geschwindigkeit.  Das Übertakten von Pythons mit unterschiedlichem Erfolg begann fast in den ersten Tagen seines Bestehens: <a href="https://ru.wikipedia.org/wiki/Shedskin" rel="nofollow">Schuppen</a> , <a href="https://en.wikipedia.org/wiki/Psyco" rel="nofollow">Psyco</a> , <a href="https://ru.wikipedia.org/wiki/Unladen_Swallow" rel="nofollow">unbeladenes Flachwasser</a> , <a href="https://github.com/iskandr/parakeet" rel="nofollow">Sittich</a> , <a href="https://ru.wikipedia.org/wiki/Nuitka" rel="nofollow">Theano</a> , <a href="https://pythran.readthedocs.io/en/latest/" rel="nofollow">Nuitka</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">Pythran</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">Cython</a> , <a href="https://ru.wikipedia.org/wiki/PyPy" rel="nofollow">Pypy</a> , <a href="https://en.wikipedia.org/wiki/Numba" rel="nofollow">Numba</a> . <br><img src="https://habrastorage.org/webt/yy/4u/gr/yy4ugrto-i7axd0v6ds5cj58lmk.png"><br>  Bisher sind die letzten drei am gefragtesten.  <code>Cython</code> (nicht zu verwechseln mit Cpython) - ist semantisch ganz anders als reguläres Python.  In der Tat ist dies eine separate Sprache - eine Mischung aus C und Python.  <code>pypy</code> (eine alternative Implementierung des Python-Übersetzers mit jit-Kompilierung) und <code>numba</code> (eine Bibliothek zur Code-Kompilierung in llvm) gingen unterschiedliche Wege.  <code>pypy</code> erklärte zunächst die Unterstützung für alle Python-Konstrukte.  In numba gingen sie davon aus, dass es am häufigsten cpu-gebundene mathematische Berechnungen erfordert, sie identifizierten den Teil der mit Berechnungen verbundenen Sprache und begannen, sie zu übertakten, wodurch die "Abdeckung" allmählich zunahm (zum Beispiel gab es bis vor kurzem keine Unterstützung für Leitungen) , jetzt ist sie erschienen).  Dementsprechend wird nicht das gesamte Programm in <code>numba</code> übertaktet, sondern es werden <em>separate Funktionen verwendet</em> . Auf diese Weise können Sie hohe Geschwindigkeit und Abwärtskompatibilität mit Bibliotheken <code>numba</code> , die <code>numba</code> (noch) nicht unterstützt.  Numpy wird (mit geringfügigen Einschränkungen) sowohl in <code>pypy</code> als auch in <code>numba</code> . </p><br><p><img src="https://habrastorage.org/webt/c0/7l/_y/c07l_ygigxdy7wsfwnyn_nfm2v4.png" width="30%" align="right">  Meine Bekanntschaft mit Numba begann 2015 mit dieser Frage zum Stackoverflow über die Geschwindigkeit der Matrixmultiplikation in Python: <a href="https://stackoverflow.com/questions/27809511/efficient-outer-product-in-python" rel="nofollow">Effizientes Außenprodukt in Python</a> </p><br><p>  Seitdem sind viele Ereignisse in jeder der Bibliotheken aufgetreten, aber das Bild in Bezug auf <code>numba</code> / <code>numba</code> / <code>pypy</code> sich <code>numba</code> nicht geändert: <code>numba</code> überholt <code>cython</code> durch die Verwendung nativer Prozessoranweisungen ( <code>cython</code> kann nicht jit) und <code>pypy</code> - aufgrund einer effizienteren Ausführung von llvm-Bytecode . </p><br><p>  Numba ist nützlich für mich bei der Arbeit (Verarbeitung hyperspektraler Bilder) und im Unterricht (numerische Integration, Lösen von Differentialgleichungen). </p><br><h4 id="kak-ustanovit">  wie man einstellt </h4><br><p>  Vor ein paar Jahren gab es Probleme mit der Installation, jetzt wurde alles gelöst: Es lässt sich sowohl durch <code>pip install numba</code> als auch durch <code>conda install numba</code> gleich gut <code>conda install numba</code> .  llvm wird automatisch angezogen und installiert. </p><br><h4 id="kak-uskoryat">  wie man beschleunigt </h4><br><p>  Um eine Funktion zu beschleunigen, müssen Sie den njit-Dekorator eingeben, bevor Sie ihn definieren: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> njit @njit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> s = <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): s += sqrt(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s</code> </pre> <br><p>  Beschleunigung von <strong>40</strong> mal. </p><br><p>  Die Wurzel wird benötigt, da sonst numba die Summe des arithmetischen Verlaufs (!) Erkennt und in konstanter Zeit berechnet. </p><br><h4 id="jit-vs-njit">  jit vs njit </h4><br><p>  Bisher war nur der <code>@jit</code> Modus (nicht <code>@njit</code> ) relevant.  Der Punkt ist, dass Sie in diesem Modus Operationen verwenden können, die von numba nicht unterstützt werden: die numba mit hoher Geschwindigkeit erreicht die erste solche Operation, verlangsamt sich dann und dauert bis zum Ende der Funktionsausführung mit der üblichen Python-Geschwindigkeit an, auch wenn in der Funktion nichts mehr "Verbotenes" auftritt ( der sogenannte Objektmodus), der offensichtlich irrational ist.  Jetzt geben <code>@jit</code> und nach auf. Es wird immer empfohlen, @njit (oder in voller Form <code>@jit(nopython=True)</code> ) zu verwenden. In diesem Modus schwört die Zahl mit Ausnahmen auf solche Stellen - es ist besser, sie neu zu schreiben, um nicht an Geschwindigkeit zu verlieren. </p><br><h4>  was kann beschleunigen </h4><br><p>  In übertakteten Funktionen kann nur ein Teil der Python- und Numba-Funktionalität verwendet werden.  Alle Operatoren, Funktionen und Klassen sind in Bezug auf die Numba in zwei Teile unterteilt: die, die die Numba "versteht" und die, die sie "nicht versteht". </p><br><p>  In der numba-Dokumentation gibt es zwei solcher Listen (mit Beispielen): </p><br><ul><li>  eine Untergruppe der <a href="https://numba.pydata.org/numba-doc/dev/reference/pysupported.html" rel="nofollow">Python-</a> Funktionen, die numbe und </li><li>  eine Untermenge der <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numpy-</a> Funktion, die <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numbe</a> kennt. </li></ul><br><p>  Aus den bemerkenswerten in diesen Listen: </p><br><ul><li>  eine numba "versteht" Python-Listen mit einem schnellen (amortisierten O (1)) Zusatz zum Ende, den numpy "nicht versteht" (obwohl nur homogene aus Elementen desselben Typs), </li><li>  Numpy's Arrays, die nicht im Basis-Python enthalten sind.  Versteht auch </li><li>  Tupel: Sie können, wie ein normaler Python, Elemente verschiedener Typen enthalten. </li><li>  wörterbücher: numba hat eine eigene Implementierung eines typisierten Wörterbuchs.  Alle Schlüssel müssen vom selben Typ sein, genau wie die Werte.  Das Python-Diktat kann nicht an numba übergeben werden, aber das numba <code>numba.typed.Dict</code> kann in Python erstellt und nach / von numba übertragen werden (während es in Python etwas langsamer als Python arbeitet). </li><li>  In letzter Zeit können str und bytes jedoch nur als Eingabeparameter noch nicht angelegt werden. </li></ul><br><p>  Sie versteht überhaupt keine anderen Bibliotheken (insbesondere scipy und pandas). </p><br><p>  Aber selbst diese Untergruppe der Sprache, die sie versteht, reicht aus, um den größten Teil des Codes für wissenschaftliche Anwendungen zu übertakten, auf die sich numba in erster Linie konzentriert. </p><br><h4>  wichtig! </h4><br><p>  Von den übertakteten Funktionen können nur übertaktete und keine übertakteten Funktionen aufgerufen werden. <br>  (obwohl übertaktete Funktionen von übertaktet und nicht übertaktet aufgerufen werden können). </p><br><h4>  Globals </h4><br><p>  In übertakteten Funktionen werden globale Variablen zu Konstanten: Ihr Wert wird beim Kompilieren der Funktion festgelegt ( <a href="https://python-nsu.bitbucket.io/numba/globals.html" rel="nofollow">Beispiel</a> ).  =&gt; Verwenden Sie keine globalen Variablen in übertakteten Funktionen (außer Konstanten). </p><br><h4>  Unterschriften </h4><br><p>  In der Zahl jeder Funktion werden eine oder mehrere Arten von Eingabe- und Ausgabeargumenten abgebildet, d.h.  Unterschriften.  Beim ersten Aufruf der Funktion wird die Signatur generiert und der entsprechende binäre Funktionscode automatisch übersetzt.  Beim Starten mit anderen Argumenttypen werden neue Signaturen und neue Binärdateien erstellt (die alten bleiben erhalten).  Somit erfolgt der "Exit to the Mode" in Bezug auf die Ausführungsgeschwindigkeit für jede Signatur, beginnend mit dem zweiten Durchlauf mit diesen Arten von Argumenten.  Also auch nicht </p><br><ul><li>  "Aufwärmen des Caches" durch Starten mit kleinen Eingabearrays oder </li><li>  <code>@jit(cache=True)</code> das Argument <code>@jit(cache=True)</code> an, um den kompilierten Code mit seinem automatischen Laden bei nachfolgenden Programmstarts auf der Festplatte zu speichern (obwohl dieser erste Start in der heutigen Praxis noch etwas langsamer ist als die nachfolgenden, aber schneller als ohne <code>cache=True</code> ). . </li></ul><br><p>  Es gibt einen dritten Weg.  Signaturen können manuell gesetzt werden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y &gt;&gt;&gt; f.signatures [(int16, int16)]</code> </pre> <br><p>  Wenn Sie eine Funktion mit der im Dekorator angegebenen Signatur ausführen, ist die erste Ausführung schnell: Die Kompilierung wird in dem Moment ausgeführt, in dem der Python die Definition der Funktion sieht, und nicht beim ersten Start.  Es kann mehrere Signaturen geben, die Reihenfolge ihrer Reihenfolge ist wichtig. </p><br><p>  Warnung: Diese letzte Methode ist nicht zukunftssicher.  Die Autoren von numba warnen davor, dass sich die Syntax für die Angabe von Typen in Zukunft ändern könnte. <code>@jit</code> / <code>@njit</code> ohne Signaturen ist in dieser Hinsicht eine sicherere Option. </p><br><p>  <code>f.signatures</code> erst dann signiert, wenn der Python davon erfährt, <code>f.signatures</code> nach dem ersten Funktionsaufruf oder wenn sie manuell festgelegt wurden. </p><br><p>  Zusätzlich zu <code>f.signatures</code> Signaturen über <code>f.inspect_types()</code> Zusätzlich zu den Typen der Eingabeparameter zeigt diese Funktion die Typen der Ausgabeparameter sowie die Typen aller lokalen Variablen an. </p><br><p>  Zusätzlich zu den Typen der Eingabe- und Ausgabeparameter können die Typen der lokalen Variablen manuell angegeben werden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16), locals={<span class="hljs-string"><span class="hljs-string">'z'</span></span>: int32}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> z = y + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + z</code> </pre> <br><h4 id="int">  int </h4><br><p>  In numba haben Ganzzahlen keine lange Arithmetik wie in "einfachem" Python, aber es gibt Standardtypen mit verschiedenen Breiten von <code>int8</code> bis <code>int64</code> ( <code>int64</code> in der Dokumentation).  Es gibt auch die Typen <code>int_</code> (sowie <code>float_</code> ), mit denen Sie der Zahl die Möglichkeit geben, die (aus ihrer Sicht) optimale Feldbreite zu wählen. </p><br><h4 id="klassy">  Klassen </h4><br><p>  Es gibt generell Unterstützung für Klassen (@jitclass), aber bisher ist es experimentell, daher ist es besser, sie vorerst nicht zu verwenden (momentan ist es meiner Erfahrung nach mit ihnen viel langsamer als ohne sie). </p><br><h4 id="custom-dtypes">  benutzerdefinierte dtypes </h4><br><p>  Numba unterstützt eine bestimmte Alternative zu Klassen aus Arrays mit Numpy-Struktur oder, mit anderen Worten, benutzerdefinierten Datentypen.  Sie arbeiten mit der gleichen Geschwindigkeit wie normale Numpy-Arrays. Sie lassen sich leichter indizieren (beispielsweise ist <code>a['y2']</code> besser lesbar als <code>a[3]</code> ).  Interessanterweise ist in numba im Gegensatz zu numpy ein prägnanteres <code>a.y2</code> zusammen mit der üblichen Syntax <code>a['y2']</code> .  Aber im Allgemeinen lässt ihre Unterstützung in der Numba zu wünschen übrig, und einige Operationen, die sogar in der Numba offensichtlich sind, mit ihnen in der Numba werden ganz untrivial aufgezeichnet. </p><br><h4 id="gpu">  GPU </h4><br><p>  Es ist in der Lage, übertakteten Code auf der GPU und im Gegensatz zu demselben, zum Beispiel Pycuda oder Pytorch, nicht nur auf NVIDIA-, sondern auch auf AMD'sHNYH-Karten auszuführen.  Damit ist bisher wenig zu tun.  Hier ist ein Artikel zum Hub 2016  Dort wurde eine mit C vergleichbare Geschwindigkeit erhalten. </p><br><h4 id="ahead-of-time-kompilyaciya">  vorzeitige Kompilierung </h4><br><p>  Es gibt einen Modus für die normale (dh nicht jit) Kompilierung ( <a href="https://numba.pydata.org/numba-doc/dev/user/pycc.html" rel="nofollow">Dokumentation</a> ) in der Numba, aber dieser Modus ist nicht der Hauptmodus, ich habe ihn nicht verstanden. </p><br><h4 id="avtomaticheskoe-rasparallelivanie">  automatische Parallelisierung </h4><br><p>  Einige Aufgaben (z. B. das Multiplizieren einer Matrix mit einer Zahl) werden auf natürliche Weise parallelisiert.  Es gibt jedoch Aufgaben, deren Umsetzung nicht parallelisiert werden kann.  Mit dem <code>@njit(parallel=True)</code> Dekorator <code>@njit(parallel=True)</code> analysiert <code>@njit(parallel=True)</code> numba den Code der übertakteten Funktion, findet solche Abschnitte, von denen jeder für sich nicht parallelisiert werden kann, und führt sie gleichzeitig auf verschiedenen CPU-Kernen aus ( <a href="https://numba.pydata.org/numba-doc/dev/user/parallel.html" rel="nofollow">Dokumentation</a> ).  Bisher konnten Sie Funktionen nur manuell mithilfe von <code>@vectorize</code> ( <a href="https://numba.pydata.org/numba-doc/dev/reference/jit-compilation.html" rel="nofollow">Dokumentation</a> ) parallelisieren, wodurch Codeänderungen erforderlich wurden. </p><br><p>  In der Praxis sieht es so aus: add <code>parallel=True</code> , messen Sie die Geschwindigkeit, wenn wir Glück haben und es schneller geworden ist - wir lassen es, langsamer - wir entfernen es.  (** Update Wie im <a href="https://habr.com/ru/post/484142/">Kommentar</a> zum zweiten Teil des Artikels erwähnt, weist dieses Flag viele offene Fehler auf.) </p><br><h4 id="osvobozhdenie-gil">  GIL-Veröffentlichung </h4><br><p>  Funktionen, die mit <code>@jit(nogil=True)</code> dekoriert sind und in verschiedenen Threads ausgeführt werden, können parallel ausgeführt werden.  Um Rennbedingungen zu vermeiden, müssen Sie die Thread-Synchronisierung verwenden. </p><br><h4 id="dokumentaciya">  die Dokumentation </h4><br><p>  Numbe fehlt noch eine vernünftige Dokumentation.  Sie ist, aber nicht alles ist in ihr. </p><br><h4 id="optimizaciya">  Optimierung </h4><br><p>  Es gibt eine gewisse Unvorhersehbarkeit bei der manuellen Optimierung von Code: Unpython-Code wird häufig schneller ausgeführt als Python. </p><br><p>  Für diejenigen, die sich für das Thema interessieren, kann ich ein <a href="https://www.youtube.com/watch%3Fv%3D1AwG0T4gaO0" rel="nofollow">Video eines</a> numba-Meisterkurses von der scipy 2017-Konferenz empfehlen (es gibt <a href="https://github.com/gforsyth/numba_tutorial_scipy2017" rel="nofollow">Quellcodes</a> auf dem Github).  Es ist sehr lang und teilweise veraltet (zum Beispiel, Strings werden bereits unterstützt), aber es hilft, sich einen Überblick zu verschaffen: Es enthält insbesondere Informationen zu Pythonic / Unpythonic, <a href="https://habr.com/ru/users/jit/" class="user_link">JIT</a> (parallel = True) usw. </p><br><p>  Im <a href="https://habr.com/ru/post/484142/">zweiten</a> Teil betrachten wir die Verwendung von numba unter Verwendung des Codes aus dem am Anfang des Artikels erwähnten Artikel. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484136/">https://habr.com/ru/post/de484136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484114/index.html">Eine Auswahl von 143 Übersetzungen des Aufsatzes von Paul Graham (von 184)</a></li>
<li><a href="../de484118/index.html">32 Januar</a></li>
<li><a href="../de484120/index.html">Die gefragtesten Fähigkeiten im Beruf des Dateningenieurs</a></li>
<li><a href="../de484124/index.html">Nikolai Prokhorov: „In Finnland gab es eine riesige Abteilung von Vneshtorg, die unsere Autos ins Ausland lieferte.“</a></li>
<li><a href="../de484130/index.html">Microservices mit Spring Boot. Teil 1. Erste Schritte</a></li>
<li><a href="../de484142/index.html">Python (+ numba) ist schneller als C - wirklich?! Teil 2. Üben</a></li>
<li><a href="../de484146/index.html">Täuschungen im Internet werden nicht verschwinden - was sollen wir tun?</a></li>
<li><a href="../de484148/index.html">SVM Erklärung von Grund auf neu und Implementierung in Python. Detaillierte Analyse der Support-Vektor-Methode</a></li>
<li><a href="../de484150/index.html">5 neue Tools zum Erstellen von unterhaltsamen Inhalten</a></li>
<li><a href="../de484152/index.html">Hochgeschwindigkeits-PAC-Controller WISE-5580</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>