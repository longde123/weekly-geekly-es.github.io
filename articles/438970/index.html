<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚úàÔ∏è üòû üö∂üèª Se dice que Haskell es un lenguaje para genios y acad√©micos. Derecho? üï¥üèº ‚óΩÔ∏è üë©‚Äçüë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez habl√© con el fundador de una startup israel√≠ que estaba desarrollando una base de datos de GPU de alta velocidad. Haskell y C ++ estaban en su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Se dice que Haskell es un lenguaje para genios y acad√©micos. Derecho?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438970/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Una vez habl√© con el fundador de una startup israel√≠ que estaba desarrollando una base de datos de GPU de alta velocidad.  Haskell y C ++ estaban en su pila, y el fundador se quej√≥ de lo dif√≠cil que era encontrar personas en el equipo.  Vol√≥ a Mosc√∫, incluso para buscar buenos programadores. <br><br>  Pregunt√© cuidadosamente si era mejor usar algo m√°s com√∫n y nuevo.  Y aunque la respuesta fue cort√©s y constructiva, entre l√≠neas me pareci√≥: "Pff, ni siquiera menciones estos juguetes". <br><br>  Todo lo que escuch√© sobre Haskell desde un lado desde entonces se redujo a una cosa: "las bromas son malas con √©l".  Para conocer mejor a los Haskellistas, vine al chat de telegramas para hacerles preguntas.  Daba bastante miedo y result√≥ que no en vano. <br><br>  No quieren hablar de Haskell popularmente, y parece que contemplan tales emprendimientos con desprecio.  Ya hablando, con la m√°xima integridad y objetividad.  ‚ÄúUna de las cualidades caracter√≠sticas de Haskell como idioma y comunidad es que juntos no se esforzaron por hacerse populares, dando una respuesta simple a las preguntas populares.  En cambio, construyeron una forma l√≥gica de principios para resolver problemas reales, en lugar de penetrar r√°pidamente en el coraz√≥n de un transe√∫nte por una persona interesada ‚Äù, me escribieron all√≠. <br><br>  Sin embargo, varias personas compartieron sus experiencias, y reun√≠ sus opiniones aqu√≠. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">nolane</a> )</b> : En la universidad, sobre el tema de "Lenguajes de programaci√≥n", me ofrecieron tomar un curso en Haskell Coursera por un punto adicional de cada cien.  Luego hubo un curso de programaci√≥n funcional en el que tuvo lugar Haskell.  Escribi√≥ un trabajo final y un trabajo de posgrado del soltero en GHC.  Encontr√© un trabajo como programador Haskell. <br><br>  Fue duro, y a√∫n dif√≠cil.  Cuando comienzas a estudiar Haskell, tienes que comprender muchos conceptos nuevos.  Este es un trabajo duro.  Literalmente aprendes a programar de nuevo. <br><br>  Ahora ser√° dif√≠cil para muchos recordar c√≥mo comenzaron su viaje en la programaci√≥n, lo dif√≠cil que fue comprender qu√© es un "puntero", qu√© es una "funci√≥n", qu√© es una "clase".  Quiz√°s es por eso que estudiar Haskell es tan dif√≠cil.  Con la edad, se hace m√°s dif√≠cil aprender cosas nuevas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Una vez en un per√≠odo de prueba, ca√≠ en Redux, as√≠ que, mirando las lecciones de su creador, decid√≠ conocer mejor a todos.  Al principio apliqu√© las pr√°cticas aprendidas en JavaScript, pero luego aprend√≠ sobre Haskell, que se considera un verdadero lenguaje funcional.  Inmediatamente me atrajo su elegancia y un mont√≥n de nuevos conceptos desconocidos para m√≠. <br><br>  No fue f√°cil con infinitos tutoriales sobre m√≥nadas sobre el ejemplo de los burritos, que son muy confusos.  Adem√°s, un fondo imperativo dificulta la apertura de nuevos conceptos. <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">cblp</a> )</b> : lo m√°s dif√≠cil de aprender es Haskell en segundo lugar, cuando el s√≠ndrome del patito no pas√≥ al primer idioma. <br><br><h2>  ¬øQu√© es bueno y qu√© es mal lenguaje? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : El lenguaje es muy conciso, elegante y flexible, no en vano, la mitad de las bibliotecas en √©l son EDSL (al menos esa impresi√≥n). <br><br>  <b>Yuri Syrovetsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">cblp</a> )</b> : Alta expresividad, f√°cil de transferir el √°rea tem√°tica al c√≥digo, la combinaci√≥n √≥ptima de paradigmas imperativos y funcionales.  Es f√°cil crear abstracciones en datos y algoritmos, lo que le permite pensar en el problema sin distraerse con peque√±as cosas no relacionadas. <br><br>  <b>John Doe</b> : Mecanograf√≠a estrictamente fuerte (dir√≠a fascista). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">interphx</a> )</b> : un sistema de tipo muy expresivo.  No es tan poderoso como Idris o Agda, pero alcanza ese punto medio cuando casi todo se puede expresar, y la inferencia de tipos funciona bien.  No tiene que etiquetarlos manualmente en todas partes. <br><br>  Pero un poderoso sistema de tipos te hace prestar atenci√≥n a los valores pasados.  Un mont√≥n de definiciones de tipo puede parecer una repetitiva.  Cada equipo usa su propio conjunto de extensiones o no las usa en absoluto.  El c√≥digo es m√°s "denso": una l√≠nea a menudo contiene m√°s informaci√≥n que en otros idiomas, por lo que es m√°s dif√≠cil para un desarrollador inexperto leerlo. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Cuando estudias a Haskell, lo m√°s probable es que encuentres el dicho "si se compila, probablemente sea correcto".  No hay nulo, el paradigma funcional en s√≠ mismo es muy estricto y te obliga a seguir ciertas reglas, que en la mayor√≠a de los casos conducen a un mejor dise√±o. <br><br>  Por ejemplo, no hay variables en el lenguaje, solo constantes.  No tiene que hacer un seguimiento de qu√© y d√≥nde asigna.  Haskell fomenta el uso de funciones puras, lo que no produce efectos secundarios.  El dise√±o funcional simplemente hace que el programa funcione como un todo, a diferencia de OOP, donde un mont√≥n de objetos son arrojados al mundo y los objetos intentan comunicarse entre s√≠ a trav√©s de efectos secundarios, convirtiendo la aplicaci√≥n en un desastre impredecible.  En el trabajo, sufrimos bastante de esto con C # en Unity. <br><br>  <b>Denis Mirzoev</b> : La pereza incorporada aumenta la expresividad del lenguaje.  Muchos algoritmos se est√°n volviendo m√°s f√°ciles.  Puede aumentar la productividad si no se utilizan los resultados de los c√°lculos intermedios.  (Por ejemplo, `head. Sort` funciona en tiempo lineal). <br><br>  <b>Igor Shevnin</b> : un modelo de c√°lculo perezoso generalmente ayuda, pero cuando el orden de las funciones de llamada es importante, puede ser dif√≠cil darse cuenta de lo que est√° sucediendo. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Se compila, lo que inmediatamente da un gran aumento de velocidad. <br><br>  <b>Denis Mirzoev</b> : Comparado con Java en velocidad, pero no tan r√°pido como C. <br><br>  <b>Igor Shevnin</b> : <b>listo para usar</b> , hay soporte para extensiones que le permiten terminar el idioma y el sistema de tipos.  Sin embargo, hay muchas extensiones ampliamente utilizadas que son familiares para la comunidad, tienen ejemplos y documentaci√≥n decentes, y no son nicho. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : La biblioteca est√°ndar Prelude tiene funciones muy pobres como read, head, readFile, que puede lanzar una excepci√≥n y ponerla en un programa, en lugar de devolver Quiz√°s.  Por lo tanto, debe usar alternativas o escribir sus propias implementaciones. <br><br>  <b>Igor Shevnin</b> : El principal problema es la falta de estandarizaci√≥n, en la medida en que muchos reemplazan la biblioteca est√°ndar con una de las alternativas incompatibles.  Hay desacuerdos en la comunidad sobre qu√© deber√≠a ser una biblioteca est√°ndar, qu√© deber√≠a incluirse en el n√∫cleo del lenguaje y qu√© deber√≠a complementarse con extensiones, y me parece que esto ralentiza el desarrollo del lenguaje. <br><br>  <b>Denis Mirzoev</b> : No hay suficientes herramientas: no hay un IDE completo, hay muy pocas herramientas para medir el rendimiento, no hay depuraci√≥n "paso a paso", esto es, en general, un problema fundamental. <br><br><h2>  ¬øPara qu√© proyectos se adapta mejor Haskell? </h2><br>  <b>Yuri Syrovetsky</b> : Para tareas complejas relacionadas con la seguridad o el dinero, donde el costo del error es alto. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : para todo lo que necesita para realizar c√°lculos, transformaciones y an√°lisis de datos.  Muy sorprendido de que Haskell sea menos popular en Data Science que Python. <br><br>  <b>Igor Shevnin</b> : No me arriesgar√≠a a usarlo para sistemas integrados (el rendimiento no es malo, pero todav√≠a hay una sobrecarga significativa para el consumo de memoria debido a c√°lculos lentos) y peque√±os scripts (este rigor simplemente no es necesario all√≠).  Tambi√©n debe comprender que encontrar desarrolladores en un equipo es mucho m√°s dif√≠cil que para los idiomas convencionales. <br><br>  <b>John Doe</b> : Para escribir el c√≥digo de la industria que otros leer√°n, necesitar√° un equipo completo de Haskellistas.  Tales pocas personas lograron recolectar. <br><br>  <b>Igor Shevnin</b> : Pero debido a su brevedad y rigor, Haskell es adecuado para casi cualquier tarea. <br><br><h2>  ¬øComenzar a aprender desarrollo con Haskell es una buena idea? </h2><br>  Igor Shevnin: es poco probable que comience, porque la gran mayor√≠a de las bases de c√≥digo con las que una persona tendr√° que trabajar no est√°n escritas en √©l. <br><br>  <b>John Doe</b> : ¬°Mala, mala idea!  Los idiomas que no sean de la familia ML, sino de los idiomas industriales en general, ser√°n un shock para usted. <br><br>  <b>Denis Mirzoev</b> : Por lo general, las personas primero estudian matem√°ticas, luego pasan a la programaci√≥n.  Por lo tanto, aprender un idioma usando conceptos matem√°ticos (tipos de datos algebraicos, funciones puras) deber√≠a ser m√°s simple que imperativo.  Es decir, creo que esta es una buena idea. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Todos los reci√©n llegados que entreno, definitivamente te presentar√© a Haskell.  Las personas que no han estudiado el estilo imperativo son mucho m√°s f√°ciles de navegar en el c√≥digo funcional y aprenden m√°s r√°pido, incluso si trabajan con lenguajes orientados a objetos, aportan buenas soluciones arquitect√≥nicas y pr√°cticas funcionales. <br><br>  <b>Yuri Syrovetsky</b> : Es mejor comenzar de inmediato con varios lenguajes fundamentalmente diferentes, por ejemplo, C, Haskell y Smalltok, en cualquier orden.  Ni un solo idioma en <br>  por separado no dar√° una comprensi√≥n completa. <br><br><h2>  Haskell es un idioma bastante antiguo.  ¬øEs bueno o malo? </h2><br>  Yuri Syrovetsky: El lenguaje se est√° desarrollando de manera muy activa, la carga de compatibilidad solo por el hecho de la compatibilidad no tira. <br><br>  <b>John Doe</b> : El est√°ndar se adopt√≥ en 1998, pero esto no se nota: hasta ahora, se lanzan nuevas versiones del compilador, que potencialmente rompen la compatibilidad con versiones anteriores, aproximadamente cada seis meses. <br><br>  <b>Denis Mirzoev</b> : Haskell no es viejo, pero est√° probado en el tiempo.  Los cambios irreflexivos nunca entrar√°n en el idioma.  Entonces es bastante bueno. <br><br><h2>  Se dice que Haskell es uno de los idiomas m√°s complejos.  Es asi? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Al igual que el lenguaje en s√≠, no.  Lo m√°s probable son las abstracciones que se utilizan en √©l.  Una persona que nunca ha visto el c√≥digo Haskell puede volverse loco con el flujo de nueva informaci√≥n y varias construcciones inusuales. <br><br>  El petr√≥leo agrega al fuego que el lenguaje impone un mont√≥n de "restricciones", no permite o complica en gran medida un mont√≥n de cosas que no encajan en un concepto funcional. <br><br>  <b>John Doe</b> : Para que el primer proyecto de primaria se compilara al menos, tom√≥ casi dos meses fumar libros de texto, manuales y tutoriales por las tardes.  Es cierto que despu√©s de la compilaci√≥n, el proyecto comenz√≥ a funcionar de inmediato e higos a plena carga (6k rps con picos de hasta 15) durante seis meses, sin ning√∫n cambio en absoluto. <br><br>  <b>Denis Mirzoev</b> : Apuesto a que si un estudiante comienza a estudiar programaci√≥n de Haskell y se mueve lo suficiente, entonces la programaci√≥n imperativa le parecer√° m√°s complicada y menos intuitiva. <br><br>  <b>Igor Shevnin</b> : La complejidad es relativa.  De los lenguajes principales, todav√≠a encuentro C ++ como el m√°s complejo.  Los lenguajes para probar teoremas (Agda, Coq) ser√°n m√°s complicados que Haskell en un sentido conceptual.  Haskell es un lenguaje simple, pero sus patrones y bibliotecas, est√°ndar y de terceros, se pueden aprender de forma inmediata. <br><br><h2>  ¬øEst√° siempre justificada su complejidad? </h2><br>  <b>Igor Shevnin</b> : los patrones y un alto nivel de abstracci√≥n est√°n justificados, ya que hacen que el c√≥digo sea m√°s confiable y m√°s corto.  Pero creo que los operadores, los nombres de las funciones y muchas otras cosas podr√≠an ser m√°s claros. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : A menudo, las construcciones complejas de Haskell le permiten crear soluciones muy cortas, que tambi√©n resultan ser muy flexibles y modulares. <br><br>  <b>Yuri Syrovetsky</b> : Excepto que manejar los efectos es engorroso, aunque casi <br>  siempre es mejor que la falta de control.  Pero sobre simplificarlo <br>  El trabajo est√° en marcha. <br><br>  <b>John Doe</b> : El lenguaje para aquellos acostumbrados a python / php / lo que sea, generalmente lo hace parecer ortogonal a la realidad.  Para las personas que inicialmente no estaban interesadas en la teor√≠a de categor√≠as, lograr resultados del cero absoluto es muy dif√≠cil. <br><br>  Pero cuando comprende el idioma, obtiene una nueva forma de pensar sobre el problema que se est√° resolviendo. <br><br><h2>  Haskell parece ser un lenguaje para matem√°ticos, no para desarrolladores.  ¬øCrees que no est√° muy extendido por esto? </h2><br>  <b>Denis Mirzoev</b> : Esta es una demostraci√≥n del principio que siguen los principales desarrolladores de Haskell: "evitar el √©xito a toda costa".  El punto, por supuesto, no es evitar el √©xito, sino evitar el √©xito, cuyo precio es demasiado alto. <br><br>  Haskell podr√≠a hacerse popular.  Hay, por ejemplo, soporte para este idioma de Microsoft.  Era posible hacer que el lenguaje fuera m√°s imperativo, tomar algunas decisiones r√°pidas y mal concebidas para ganar popularidad.  Era posible usar muchos trucos sucios, pero gracias a una posici√≥n tan correcta de los principales desarrolladores no hab√≠a nada como esto. <br><br>  S√≠, la popularidad del idioma no es muy alta, pero su calidad no sufre.  Las ventajas de Haskell sobre los idiomas imperativos son obvias para m√≠, la mayor√≠a de sus problemas se pueden resolver, por lo que estoy seguro de que a medida que se desarrolle, obtendr√© una gran popularidad. <br><br>  <b>Yuri Syrovetsky</b> : Entonces solo lo ven personas que no saben nada de √©l.  En <br>  Haskell ha estado utilizando el desarrollo "real" durante mucho tiempo, los ejemplos son f√°ciles de encontrar en <br>  tu motor de b√∫squeda favorito  En particular, estamos en LC usando <br>  Haskell est√° satisfecho y no vemos nada m√°s en su lugar. <br><br>  <b>Igor Shevnin</b> : ¬øQu√© es un "lenguaje para matem√°ticos"? Realmente no lo s√©.  Esto es R / MatLab / Mathematica para c√°lculos y estad√≠sticas, o Python, porque es simple y requiere menos experiencia en ingenier√≠a.  Pero no Haskell.  Los conceptos algebraicos como los monoides se utilizan en √©l por razones pr√°cticas, y no solo por rigor adicional. <br><br>  El papel principal en popularidad fue jugado por la prevalencia hist√≥rica de C / C ++ / Java / C # en la empresa, ocuparon un nicho.  Pero ahora, muchas compa√±√≠as est√°n comenzando a usar Haskell y otros lenguajes funcionales. <br><br><h2>  ¬øCon qu√© ladr√≥n comparar√≠as a Haskell y a favor de qui√©n? </h2><br>  <b>John Doe</b> : m√°s o menos com√∫n, con Erlang.  Pero Erlang sigue siendo m√°s f√°cil de escribir y m√°s f√°cil de aprender, me parece. <br><br>  <b>Denis Mirzoev</b> : Conozco bien C, C ++, Java y Haskell.  C ++ ni siquiera necesita ser comparado con nada, el lenguaje es terrible.  C es un buen lenguaje para el desarrollo de bajo nivel.  En este nicho, √©l ser√° mejor.  De lo contrario, preferir√≠a Haskell. <br><br>  La elecci√≥n entre Java y Haskell ya es m√°s dif√≠cil, pero aqu√≠ tambi√©n debe analizar una tarea espec√≠fica.  Para Android en Haskell lo m√°s probable es que sea dif√≠cil de escribir, en este caso Java es mejor.  Pero el servidor para escribir en Haskell es casi tan conveniente como en Java.  Si el entorno lo permite (ajuste, accesibilidad de las bibliotecas), generalmente elijo Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Con C #, solo <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">busque en</a></b> Google c√≥mo implementar Quiz√°s en C # y en Haskell.  Es muy extra√±o que el dictatorial puramente funcional de Haskell se sienta mucho m√°s flexible y libre.  De hecho, estos son dos extremos. <br><br>  C # es uno de los lenguajes m√°s orientados a objetos, y los beneficios de Haskell est√°n en marcado contraste con √©l.  En C # constantemente tienes que escribir un mont√≥n de cosas innecesarias, y todo esto es muy desagradable.  El uso de funciones de orden superior puede estropear el c√≥digo en t√©rminos de sintaxis.  En medio de todo esto, ya es dif√≠cil regresar de las soluciones cortas y elegantes de Haskell. <br><br>  <b>Igor Shevnin</b> : Con Rust, hasta ahora a favor de Rust.  Se necesita mucho de Haskell y otros lenguajes de FP, pero al mismo tiempo el enfoque funcional es amigable con el imperativo, y los desarrolladores y la comunidad son mucho m√°s competentes y m√°s consistentes en el desarrollo del lenguaje desde el principio. <br><br><h2>  ¬øQu√© opinas de la comunidad haskellista? </h2><br>  <b>John Doe</b> : La gran mayor√≠a son personas muy amigables que siempre est√°n listas para ayudar.  Una buena diferencia de las comunidades de muchos otros idiomas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Las comunidades de Haskell a menudo contienen personas terriblemente inteligentes que siempre est√°n listas para ayudar.  No en vano van los memes locales sobre doctorado, teor√≠a de categor√≠as y acad√©micos.  Si entra al chat en otros idiomas, ver√° que las personas est√°n discutiendo problemas de producci√≥n y estructuras de datos comunes.  En un chat de Haskell, las m√≥nadas, el lema de Yoneda, los actores aplicativos, escribir tipos locos, etc., aparecen inmediatamente frente a ti. <br><br>  Inmediatamente ves tantas novedades que no sab√≠as antes: composiciones locas, transformaciones y transformaciones elegantes, soluciones a problemas que ocupan docenas de l√≠neas en los idiomas principales, casi en una sola l√≠nea. <br><br><h2>  Dicen que los Haskellistas son arrogantes.  Derecho? </h2><br>  <b>Denis Mirzoev</b> : S√≠.  Me parece que la arrogancia se debe al hecho de que realmente aman su idioma y est√°n molestos por su subestimaci√≥n. <br><br>  <b>John Doe</b> : Nifiga as√≠. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Lo m√°s probable es que esta opini√≥n haya desaparecido, debido al hecho de que muchos desarrolladores convencionales est√°n muy molestos cuando los Haskelistas comienzan a hablar sobre programaci√≥n funcional y sus ventajas.  Un terrible malentendido, a su vez, puede molestar al propio Haskelist, y comenzar√° a apresurarse en t√©rminos, por lo que las preguntas frecuentes lo estigmatizan. <br><br>  <b>Igor Shevnin</b> : Arrogancia es una palabra demasiado fuerte.  El punto aqu√≠ es m√°s bien que FP, OOP, la diferencia entre las clases de OOP y los tipos de uni√≥n, el problema de extensi√≥n y muchos otros conceptos una vez se suman a una imagen muy clara, y despu√©s de eso se hace dif√≠cil percibir a las personas que intentan oponerse a OOP y FI o, de lo contrario, imaginar problema generalizado en una perspectiva estrecha. <br><br><h2>  ¬øPor qu√© los lenguajes FP siguen siendo nicho? </h2><br>  <b>Denis Mirzoev</b> : Sus ventajas a√∫n no son suficientes para interesar a un gran n√∫mero de programadores.  La dificultad en el aprendizaje no conduce a la popularidad.  Los problemas con el ajuste tambi√©n ahuyentan a muchos, pero me parece que solo aumentar el tama√±o de la comunidad podr√≠a resolver este problema.  Resulta un c√≠rculo vicioso. <br><br>  <b>Igor Shevnin</b> : el nicho est√° pasando gradualmente y los conceptos funcionales se est√°n trasladando a otros idiomas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Los principios funcionales en s√≠ mismos y los lenguajes que los respaldan ya son omnipresentes.  Incluso para objetos punzantes, hay Linq y algunas otras bibliotecas.  Los nichos son lenguajes bastante puramente funcionales, ya que utilizan conceptos no est√°ndar. <br><br>  No olvide que hace 20 a√±os, el hierro no era lo suficientemente productivo para los lenguajes funcionales, por lo que el funcionalismo comenz√≥ a entrar en la corriente principal en los √∫ltimos a√±os, y el inter√©s en Haskell solo est√° creciendo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438970/">https://habr.com/ru/post/438970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438960/index.html">C√≥mo renunci√© a Ruby a favor de Python mientras trabajaba en un backend</a></li>
<li><a href="../438962/index.html">En su mayor parte, una perspectiva positiva para el futuro de los chips.</a></li>
<li><a href="../438964/index.html">¬øQui√©n est√° realmente detr√°s de las populares VPN gratuitas?</a></li>
<li><a href="../438966/index.html">Historial errante de documentaci√≥n de Haproxy, o qu√© buscar al configurarlo</a></li>
<li><a href="../438968/index.html">Marcado de zapatos en Rusia: el mercado no est√° listo, pero tendr√° que funcionar</a></li>
<li><a href="../438972/index.html">El cerebro desde adentro (visualizaci√≥n del paso del patr√≥n a trav√©s del modelo de red neuronal artificial)</a></li>
<li><a href="../438974/index.html">La realidad virtual ayuda a lidiar con los trastornos mentales</a></li>
<li><a href="../438976/index.html">El libro "Primavera. Todos los patrones de dise√±o ¬ª</a></li>
<li><a href="../438978/index.html">¬°Aprendiendo siempre y en todas partes! Podcasts para desarrolladores en ingl√©s</a></li>
<li><a href="../438980/index.html">Spring Boot 2: ¬øqu√© hay de nuevo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>