<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥓 👲🏾 😱 Lambdas: von C ++ 11 bis C ++ 20. Teil 2 🤸 🛌🏽 😊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habrowsk. Im Zusammenhang mit dem Beginn der Rekrutierung in einer neuen Gruppe im Kurs „C ++ Developer“ teilen wir Ihnen die Übersetzung des zw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambdas: von C ++ 11 bis C ++ 20. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/455978/">  Hallo Habrowsk.  Im Zusammenhang mit dem Beginn der Rekrutierung in einer neuen Gruppe im Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„C ++ Developer“</a> teilen wir Ihnen die Übersetzung des zweiten Teils des Artikels „Lambdas: von C ++ 11 nach C ++ 20“ mit.  Der erste Teil kann hier gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der Serie haben</a> wir Lambdas in Bezug auf C ++ 03, C ++ 11 und C ++ 14 betrachtet.  In diesem Artikel habe ich die Gründe für diese leistungsstarke C ++ - Funktion, die grundlegende Verwendung, die Syntax und die Verbesserungen der einzelnen Sprachstandards beschrieben.  Ich habe auch einige Grenzfälle erwähnt. <br>  Jetzt ist es Zeit, zu C ++ 17 überzugehen und einen Blick in die Zukunft zu werfen (ganz nah!): C ++ 20. <a name="habracut"></a><br><br>  <b>Eintrag</b> <br><br>  Eine kleine Erinnerung: Die Idee für diese Serie kam nach einem unserer letzten C ++ User Group-Treffen in Krakau. <br><br>  Wir hatten eine Live-Programmiersitzung über die „Geschichte“ der Lambda-Ausdrücke.  Das Gespräch wurde vom C ++ - Experten Thomas Kaminsky geführt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Linkedin-Profil von Thomas</a> ).  Hier ist die Veranstaltung: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambdas: Von C ++ 11 bis C ++ 20 - C ++ User Group Krakow</a> . <br><br>  Ich beschloss, den Code von Thomas zu nehmen (mit seiner Erlaubnis!) Und darauf basierende Artikel zu schreiben. Im ersten Teil der Serie sprach ich über die Lambda-Ausdrücke wie folgt: <br><br><ul><li>  Grundlegende Syntax </li><li>  Lambda-Typ </li><li>  Betreiber anrufen </li><li>  Erfassen von Variablen (veränderbare, globale, statische Variablen, Klassenmitglieder und dieser Zeiger, nur verschiebbare Objekte, Speichern von Konstanten): <br><br><ul><li>  Rückgabetyp </li><li>  IIFE - Sofort aufgerufener Funktionsausdruck </li><li>  Umwandlung in einen Funktionszeiger </li><li>  Rückgabetyp </li><li>  IIFE - Sofort aufgerufene Ausdrücke </li><li>  In einen Funktionszeiger konvertieren </li></ul></li><li>  Verbesserungen in C ++ 14 <br><br><ul><li>  Ausgabe vom Typ Rückgabe </li><li>  Mit Initialisierer aufnehmen </li><li>  Erfassen Sie eine Mitgliedsvariable </li><li>  Generische Lambda-Ausdrücke </li></ul></li></ul><br>  Die obige Liste ist nur ein Teil der Geschichte der Lambda-Ausdrücke! <br><br>  Nun wollen wir sehen, was sich in C ++ 17 geändert hat und was wir in C ++ 20 bekommen! <br><br>  <b>Verbesserungen in C ++ 17</b> <br><br>  Standard (Entwurf vor Veröffentlichung) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N659</a> Abschnitt über Lambdas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> .  C ++ 17 brachte zwei signifikante Verbesserungen für Lambda-Ausdrücke: <br><br><ul><li>  constexpr lambda </li><li>  Erfassen Sie * dies </li></ul><br>  Was bedeuten diese Innovationen für uns?  Lass es uns herausfinden. <br><br>  <i><b>constexpr Lambda-Ausdrücke</b></i> <br><br>  Ab C ++ 17 definiert der Standard den <code>operator()</code> für einen Lambda-Typ implizit als <code>constexpr</code> , wenn möglich: <br><blockquote>  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expr.prim.lambda # 4</a> : <br>  Der Funktionsaufrufoperator ist eine constexpr-Funktion, wenn auf die Deklaration des Bedingungsparameters des entsprechenden Lambda-Ausdrucks constexpr folgt oder er die Anforderungen für die constexpr-Funktion erfüllt. </blockquote><br>  Zum Beispiel: <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br>  Denken Sie daran, dass in C ++ 17 <code>constexpr</code> Funktion die folgenden Regeln befolgen muss: <br><br><ul><li>  es sollte nicht virtuell sein; <br><br><ul><li>  Der Rückgabetyp muss ein Literaltyp sein. </li><li>  Jeder der Typen seiner Parameter muss ein Literaltyp sein. </li><li>  Sein Hauptteil muss = delete, = default oder eine zusammengesetzte Anweisung sein, die nicht enthält <br><ul><li>  ASM-Definitionen </li><li>  gehe zu Ausdrücken, </li><li>  Tags </li><li>  versuche block oder </li><li>  die Definition einer nicht-literalen Variablen, einer statischen Variablen oder einer Streaming-Speichervariablen, für die keine Initialisierung durchgeführt wird. </li></ul></li></ul></li></ul><br>  Was ist mit einem praktischeren Beispiel? <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br>  Sie können hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Der Code verwendet <code>constexpr</code> lambda und wird dann an den einfachen <code>SimpleAccumulate</code> Algorithmus übergeben.  Der Algorithmus verwendet mehrere C ++ 17-Elemente: Die <code>constexpr</code> Ergänzungen zu <code>std::array</code> , <code>std::begin</code> und <code>std::end</code> (in einer <code>for</code> Schleife mit einem Bereich verwendet) sind jetzt auch <code>constexpr</code> , sodass der gesamte Code ausgeführt werden kann zur Kompilierungszeit. <br><br>  Das ist natürlich nicht alles. <br><br>  Sie können Variablen erfassen (vorausgesetzt, sie sind auch <code>constexpr</code> ): <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br>  Es gibt jedoch einen interessanten Fall, in dem Sie die erfasste Variable nicht weitergeben, zum Beispiel: <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br>  In diesem Fall können wir in Clang die folgende Warnung erhalten: <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br>  Dies liegt wahrscheinlich daran, dass x bei jeder Verwendung geändert werden kann (es sei denn, Sie übertragen es weiter oder nehmen die Adresse dieses Namens). <br><br>  Aber bitte sagen Sie mir, ob Sie die offiziellen Regeln für dieses Verhalten kennen.  Ich habe nur gefunden (von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cppreference</a> ) (aber ich kann es nicht im Entwurf finden ...) <br><br>  <i><b>(Anmerkung des Übersetzers: Während unsere Leser schreiben, meine ich wahrscheinlich, den Wert von 'x' an jeder Stelle zu ersetzen, an der er verwendet wird. Es ist definitiv unmöglich, ihn zu ändern.)</b></i> <br><br>  <i>Ein Lambda-Ausdruck kann den Wert einer Variablen lesen, ohne ihn zu erfassen, wenn die Variable</i> <i><br></i>  <i>* hat eine konstante <code>non-volatile</code> Ganzzahl oder einen Aufzählungstyp und wurde mit <code>constexpr</code> oder initialisiert</i> <i><br></i>  <i>* ist <code>constexpr</code> und hat keine veränderlichen Mitglieder.</i> <br><br>  Seien Sie auf die Zukunft vorbereitet: <br><br>  In C ++ 20 werden wir <code>constexpr</code> Standardalgorithmen und möglicherweise sogar einige Container haben, so dass <code>constexpr</code> Lambdas in diesem Zusammenhang sehr nützlich sein werden.  Ihr Code sieht sowohl für die Laufzeitversion als auch für die <code>constexpr</code> Version (Version zur Kompilierungszeit) gleich aus! <br><br>  Kurzgesagt: <br><br>  <code>constexpr</code> lambda können Sie mit der Boilerplate-Programmierung konsistent sein und möglicherweise kürzeren Code haben. <br><br>  Fahren wir nun mit der zweiten wichtigen Funktion fort, die in C ++ 17 verfügbar ist: <br><br>  <b>Erfassung von * diesem</b> <br>  <i><b>Erfassen Sie * dies</b></i> <br><br>  Erinnerst du dich an unser Problem, als wir ein Mitglied der Klasse fangen wollten?  Standardmäßig erfassen wir dies (als Zeiger!). Daher können Probleme auftreten, wenn temporäre Objekte den Gültigkeitsbereich verlassen ... Dies kann mithilfe der Erfassungsmethode mit einem Initialisierer behoben werden (siehe den ersten Teil der Serie).  Aber jetzt, in C ++ 17, haben wir einen anderen Weg.  Wir können eine Kopie davon einpacken: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br>  Sie können hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Das Erfassen der gewünschten Elementvariablen mithilfe der Erfassung mit dem Initialisierer schützt Sie vor möglichen Fehlern mit temporären Werten. Wir können jedoch nicht dasselbe tun, wenn wir eine Methode wie die folgende aufrufen möchten: <br><br>  Zum Beispiel: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br>  In C ++ 14 besteht die einzige Möglichkeit, Code sicherer zu machen, darin, <code>this</code> mit einem Initialisierer zu erfassen: <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br>  Noch etwas: <br><br>  Beachten Sie, dass wenn Sie <code>[=]</code> in eine Member-Funktion schreiben, <code>this</code> implizit erfasst wird!  Dies kann in Zukunft zu Fehlern führen ... und wird in C ++ 20 veraltet sein. <br><br>  Also kommen wir zum nächsten Abschnitt: der Zukunft. <br><br>  <b>Die Zukunft mit C ++ 20</b> <br><br>  In C ++ 20 erhalten wir die folgenden Funktionen: <br><br><ul><li>  Erlaube <code>[=, this]</code> als Lambda-Erfassung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0409R2</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brich</a> die implizite Erfassung über <code>[=]</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0806 ab</a> </li><li>  Paketerweiterung in <code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0780</a> </li><li>  statische, <code>thread_local</code> und Lambda-Erfassung für strukturierte Bindungen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1091</a> </li><li>  Lambda-Muster (auch mit Konzepten) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0428R2</a> </li><li>  Vereinfachung der impliziten Lambda-Erfassung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0588R1</a> </li><li>  Konstruktives und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuweisbares</a> Lambda ohne Speichern des Standardzustands - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0624R2</a> </li><li>  Lambdas in einem nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berechneten</a> Kontext - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0315R4</a> </li></ul><br>  In den meisten Fällen „löschen“ die neu eingeführten Funktionen die Lambda-Verwendung und ermöglichen einige erweiterte Anwendungsfälle. <br><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1091</a> können Sie beispielsweise eine strukturierte Bindung erfassen. <br><br>  Wir haben auch Erläuterungen dazu.  In C ++ 20 erhalten Sie eine Warnung, wenn Sie <code>[=]</code> in einer Methode erfassen: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br>  Wenn Sie dies wirklich erfassen müssen, sollten Sie <code>[=, this]</code> schreiben. <br><br>  Es gibt auch Änderungen in Bezug auf erweiterte Anwendungsfälle, z. B. zustandslose Kontexte und zustandslose Lambdas, die standardmäßig erstellt werden können. <br><br>  Mit beiden Änderungen können Sie schreiben: <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br>  Lesen Sie die Motive für diese Funktionen in der ersten Version der Sätze: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0315R0</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0624R0</a> . <br><br>  Aber schauen wir uns eine interessante Funktion an: Lambda-Vorlagen. <br><br>  <b>Lambd-Muster</b> <br><br>  In C ++ 14 haben wir verallgemeinerte Lambdas erhalten, was bedeutet, dass als auto deklarierte Parameter Vorlagenparameter sind. <br><br>  Für Lambda: <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br>  Der Compiler generiert eine Aufrufanweisung, die der folgenden Boilerplate-Methode entspricht: <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br>  Es gab jedoch keine Möglichkeit, diesen Vorlagenparameter zu ändern und die tatsächlichen Vorlagenargumente zu verwenden.  In C ++ 20 ist dies möglich. <br><br>  Wie können wir beispielsweise unser Lambda darauf beschränken, nur mit Vektoren irgendeiner Art zu arbeiten? <br><br>  Wir können ein allgemeines Lambda schreiben: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Wenn Sie es jedoch mit einem int-Parameter aufrufen (z. B. <code>foo(10);</code> ), wird möglicherweise ein schwer lesbarer Fehler angezeigt: <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>  In C ++ 20 können wir schreiben: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Das obige Lambda erlaubt die Template-Call-Anweisung: <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  Der Template-Parameter folgt der Capture-Klausel <code>[]</code> . <br><br>  Wenn Sie es mit <code>int (foo(10);)</code> aufrufen, erhalten Sie eine schönere Nachricht: <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br>  Sie können hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Im obigen Beispiel kann der Compiler uns vor Inkonsistenzen in der Lambda-Schnittstelle als im Code im Body warnen. <br><br>  Ein weiterer wichtiger Aspekt ist, dass Sie in einem universellen Lambda nur eine Variable haben, nicht deren Vorlagentyp.  Wenn Sie darauf zugreifen möchten, müssen Sie daher decltype (x) verwenden (für einen Lambda-Ausdruck mit dem Argument (auto x)).  Dies macht Code ausführlicher und komplizierter. <br><br>  Zum Beispiel (unter Verwendung des Codes von P0428): <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br>  Jetzt können Sie schreiben als: <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br>  Im obigen Abschnitt hatten wir einen kurzen Überblick über C ++ 20, aber ich habe einen weiteren zusätzlichen Anwendungsfall für Sie.  Diese Technik ist sogar in C ++ 14 möglich.  Also lesen Sie weiter. <br><br>  <b>Bonus - Heben mit Lambdas</b> <br><br>  Wir haben derzeit ein Problem, wenn Sie Funktionsüberladungen haben und diese an Standardalgorithmen übergeben möchten (oder an alles, was ein genanntes Objekt erfordert): <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br>  Wir erhalten den folgenden Fehler von GCC 9 (Trunk): <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br>  Es gibt jedoch einen Trick, bei dem wir ein Lambda verwenden und dann die gewünschte Überlastfunktion aufrufen können. <br><br>  In der Grundform können wir für einfache Werttypen für unsere beiden Funktionen den folgenden Code schreiben: <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br>  Und in der allgemeinsten Form müssen wir etwas mehr eingeben: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br>  Ziemlich komplizierter Code ... richtig?  :) :) <br><br>  Versuchen wir es zu entschlüsseln: <br><br>  Wir erstellen ein generisches Lambda und übergeben dann alle Argumente, die wir erhalten.  Um es richtig zu bestimmen, müssen wir noexcept und den Typ des Rückgabewerts angeben.  Deshalb müssen wir den aufrufenden Code duplizieren, um die richtigen Typen zu erhalten. <br>  Ein solches LIFT-Makro funktioniert in jedem Compiler, der C ++ 14 unterstützt. <br><br>  Sie können hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  <b>Fazit</b> <br><br>  In diesem Beitrag haben wir uns wichtige Änderungen in C ++ 17 angesehen und einen Überblick über die neuen Funktionen in C ++ 20 gegeben. <br><br>  Möglicherweise stellen Sie fest, dass sich Lambda-Ausdrücke bei jeder Iteration der Sprache mit anderen C ++ - Elementen mischen.  Zum Beispiel konnten wir sie vor C ++ 17 nicht im Kontext von constexpr verwenden, aber jetzt ist es möglich.  Ähnlich verhält es sich mit generischen Lambdas, die mit C ++ 14 beginnen, und ihrer Entwicklung zu C ++ 20 in Form von Template-Lambdas.  Vermisse ich etwas  Vielleicht haben Sie ein aufregendes Beispiel?  Bitte lassen Sie es mich in den Kommentaren wissen! <br><br>  <b>Referenzen</b> <br><br>  C ++ 11 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 17 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Ausdrücke in C ++ |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft-Dokumente</a> <br>  Simon Brand - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überlastsätze an Funktionen übergeben</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Weekly - Ep 128 - C ++ 20-Vorlagensyntax für Lambdas</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Weekly - Ep 41 - C ++ 17s Lambda-Support</a> <br><br>  Wir laden alle zu dem traditionellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Webinar</a> des Kurses ein, das morgen, den 14. Juni, stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455978/">https://habr.com/ru/post/de455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455962/index.html">Data Science und die Tropenkonferenz</a></li>
<li><a href="../de455966/index.html">Top 5 Unternehmen für die Entwicklung mobiler Apps in Großbritannien</a></li>
<li><a href="../de455970/index.html">Alles, was Sie über SwiftUI wissen wollten, aber Angst hatten zu fragen</a></li>
<li><a href="../de455972/index.html">Slurm: Die Raupe hat sich in einen Schmetterling verwandelt</a></li>
<li><a href="../de455976/index.html">Schränke, Module oder Einheiten - was für die Energieverwaltung im Rechenzentrum wählen?</a></li>
<li><a href="../de455980/index.html">iOS Digest Nr. 7 (31. Mai - 13. Juni)</a></li>
<li><a href="../de455982/index.html">Es ist Zeit, GIF durch AV1-Video zu ersetzen</a></li>
<li><a href="../de455984/index.html">So verstehen Sie, dass Links funktionieren: Metriken und Aufbau von KPI-Links</a></li>
<li><a href="../de455986/index.html">Warum sollte ein IT-Techniker ein Gehirn herausnehmen?</a></li>
<li><a href="../de455988/index.html">Die Datenstrukturen des Zustands der Plasma Cash Blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>