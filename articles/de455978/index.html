<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ì üë≤üèæ üò± Lambdas: von C ++ 11 bis C ++ 20. Teil 2 ü§∏ üõåüèΩ üòä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habrowsk. Im Zusammenhang mit dem Beginn der Rekrutierung in einer neuen Gruppe im Kurs ‚ÄûC ++ Developer‚Äú teilen wir Ihnen die √úbersetzung des zw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambdas: von C ++ 11 bis C ++ 20. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/455978/">  Hallo Habrowsk.  Im Zusammenhang mit dem Beginn der Rekrutierung in einer neuen Gruppe im Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûC ++ Developer‚Äú</a> teilen wir Ihnen die √úbersetzung des zweiten Teils des Artikels ‚ÄûLambdas: von C ++ 11 nach C ++ 20‚Äú mit.  Der erste Teil kann hier gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil der Serie haben</a> wir Lambdas in Bezug auf C ++ 03, C ++ 11 und C ++ 14 betrachtet.  In diesem Artikel habe ich die Gr√ºnde f√ºr diese leistungsstarke C ++ - Funktion, die grundlegende Verwendung, die Syntax und die Verbesserungen der einzelnen Sprachstandards beschrieben.  Ich habe auch einige Grenzf√§lle erw√§hnt. <br>  Jetzt ist es Zeit, zu C ++ 17 √ºberzugehen und einen Blick in die Zukunft zu werfen (ganz nah!): C ++ 20. <a name="habracut"></a><br><br>  <b>Eintrag</b> <br><br>  Eine kleine Erinnerung: Die Idee f√ºr diese Serie kam nach einem unserer letzten C ++ User Group-Treffen in Krakau. <br><br>  Wir hatten eine Live-Programmiersitzung √ºber die ‚ÄûGeschichte‚Äú der Lambda-Ausdr√ºcke.  Das Gespr√§ch wurde vom C ++ - Experten Thomas Kaminsky gef√ºhrt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Linkedin-Profil von Thomas</a> ).  Hier ist die Veranstaltung: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambdas: Von C ++ 11 bis C ++ 20 - C ++ User Group Krakow</a> . <br><br>  Ich beschloss, den Code von Thomas zu nehmen (mit seiner Erlaubnis!) Und darauf basierende Artikel zu schreiben. Im ersten Teil der Serie sprach ich √ºber die Lambda-Ausdr√ºcke wie folgt: <br><br><ul><li>  Grundlegende Syntax </li><li>  Lambda-Typ </li><li>  Betreiber anrufen </li><li>  Erfassen von Variablen (ver√§nderbare, globale, statische Variablen, Klassenmitglieder und dieser Zeiger, nur verschiebbare Objekte, Speichern von Konstanten): <br><br><ul><li>  R√ºckgabetyp </li><li>  IIFE - Sofort aufgerufener Funktionsausdruck </li><li>  Umwandlung in einen Funktionszeiger </li><li>  R√ºckgabetyp </li><li>  IIFE - Sofort aufgerufene Ausdr√ºcke </li><li>  In einen Funktionszeiger konvertieren </li></ul></li><li>  Verbesserungen in C ++ 14 <br><br><ul><li>  Ausgabe vom Typ R√ºckgabe </li><li>  Mit Initialisierer aufnehmen </li><li>  Erfassen Sie eine Mitgliedsvariable </li><li>  Generische Lambda-Ausdr√ºcke </li></ul></li></ul><br>  Die obige Liste ist nur ein Teil der Geschichte der Lambda-Ausdr√ºcke! <br><br>  Nun wollen wir sehen, was sich in C ++ 17 ge√§ndert hat und was wir in C ++ 20 bekommen! <br><br>  <b>Verbesserungen in C ++ 17</b> <br><br>  Standard (Entwurf vor Ver√∂ffentlichung) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N659</a> Abschnitt √ºber Lambdas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> .  C ++ 17 brachte zwei signifikante Verbesserungen f√ºr Lambda-Ausdr√ºcke: <br><br><ul><li>  constexpr lambda </li><li>  Erfassen Sie * dies </li></ul><br>  Was bedeuten diese Innovationen f√ºr uns?  Lass es uns herausfinden. <br><br>  <i><b>constexpr Lambda-Ausdr√ºcke</b></i> <br><br>  Ab C ++ 17 definiert der Standard den <code>operator()</code> f√ºr einen Lambda-Typ implizit als <code>constexpr</code> , wenn m√∂glich: <br><blockquote>  Aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">expr.prim.lambda # 4</a> : <br>  Der Funktionsaufrufoperator ist eine constexpr-Funktion, wenn auf die Deklaration des Bedingungsparameters des entsprechenden Lambda-Ausdrucks constexpr folgt oder er die Anforderungen f√ºr die constexpr-Funktion erf√ºllt. </blockquote><br>  Zum Beispiel: <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br>  Denken Sie daran, dass in C ++ 17 <code>constexpr</code> Funktion die folgenden Regeln befolgen muss: <br><br><ul><li>  es sollte nicht virtuell sein; <br><br><ul><li>  Der R√ºckgabetyp muss ein Literaltyp sein. </li><li>  Jeder der Typen seiner Parameter muss ein Literaltyp sein. </li><li>  Sein Hauptteil muss = delete, = default oder eine zusammengesetzte Anweisung sein, die nicht enth√§lt <br><ul><li>  ASM-Definitionen </li><li>  gehe zu Ausdr√ºcken, </li><li>  Tags </li><li>  versuche block oder </li><li>  die Definition einer nicht-literalen Variablen, einer statischen Variablen oder einer Streaming-Speichervariablen, f√ºr die keine Initialisierung durchgef√ºhrt wird. </li></ul></li></ul></li></ul><br>  Was ist mit einem praktischeren Beispiel? <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br>  Sie k√∂nnen hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Der Code verwendet <code>constexpr</code> lambda und wird dann an den einfachen <code>SimpleAccumulate</code> Algorithmus √ºbergeben.  Der Algorithmus verwendet mehrere C ++ 17-Elemente: Die <code>constexpr</code> Erg√§nzungen zu <code>std::array</code> , <code>std::begin</code> und <code>std::end</code> (in einer <code>for</code> Schleife mit einem Bereich verwendet) sind jetzt auch <code>constexpr</code> , sodass der gesamte Code ausgef√ºhrt werden kann zur Kompilierungszeit. <br><br>  Das ist nat√ºrlich nicht alles. <br><br>  Sie k√∂nnen Variablen erfassen (vorausgesetzt, sie sind auch <code>constexpr</code> ): <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br>  Es gibt jedoch einen interessanten Fall, in dem Sie die erfasste Variable nicht weitergeben, zum Beispiel: <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br>  In diesem Fall k√∂nnen wir in Clang die folgende Warnung erhalten: <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br>  Dies liegt wahrscheinlich daran, dass x bei jeder Verwendung ge√§ndert werden kann (es sei denn, Sie √ºbertragen es weiter oder nehmen die Adresse dieses Namens). <br><br>  Aber bitte sagen Sie mir, ob Sie die offiziellen Regeln f√ºr dieses Verhalten kennen.  Ich habe nur gefunden (von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cppreference</a> ) (aber ich kann es nicht im Entwurf finden ...) <br><br>  <i><b>(Anmerkung des √úbersetzers: W√§hrend unsere Leser schreiben, meine ich wahrscheinlich, den Wert von 'x' an jeder Stelle zu ersetzen, an der er verwendet wird. Es ist definitiv unm√∂glich, ihn zu √§ndern.)</b></i> <br><br>  <i>Ein Lambda-Ausdruck kann den Wert einer Variablen lesen, ohne ihn zu erfassen, wenn die Variable</i> <i><br></i>  <i>* hat eine konstante <code>non-volatile</code> Ganzzahl oder einen Aufz√§hlungstyp und wurde mit <code>constexpr</code> oder initialisiert</i> <i><br></i>  <i>* ist <code>constexpr</code> und hat keine ver√§nderlichen Mitglieder.</i> <br><br>  Seien Sie auf die Zukunft vorbereitet: <br><br>  In C ++ 20 werden wir <code>constexpr</code> Standardalgorithmen und m√∂glicherweise sogar einige Container haben, so dass <code>constexpr</code> Lambdas in diesem Zusammenhang sehr n√ºtzlich sein werden.  Ihr Code sieht sowohl f√ºr die Laufzeitversion als auch f√ºr die <code>constexpr</code> Version (Version zur Kompilierungszeit) gleich aus! <br><br>  Kurzgesagt: <br><br>  <code>constexpr</code> lambda k√∂nnen Sie mit der Boilerplate-Programmierung konsistent sein und m√∂glicherweise k√ºrzeren Code haben. <br><br>  Fahren wir nun mit der zweiten wichtigen Funktion fort, die in C ++ 17 verf√ºgbar ist: <br><br>  <b>Erfassung von * diesem</b> <br>  <i><b>Erfassen Sie * dies</b></i> <br><br>  Erinnerst du dich an unser Problem, als wir ein Mitglied der Klasse fangen wollten?  Standardm√§√üig erfassen wir dies (als Zeiger!). Daher k√∂nnen Probleme auftreten, wenn tempor√§re Objekte den G√ºltigkeitsbereich verlassen ... Dies kann mithilfe der Erfassungsmethode mit einem Initialisierer behoben werden (siehe den ersten Teil der Serie).  Aber jetzt, in C ++ 17, haben wir einen anderen Weg.  Wir k√∂nnen eine Kopie davon einpacken: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br>  Sie k√∂nnen hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Das Erfassen der gew√ºnschten Elementvariablen mithilfe der Erfassung mit dem Initialisierer sch√ºtzt Sie vor m√∂glichen Fehlern mit tempor√§ren Werten. Wir k√∂nnen jedoch nicht dasselbe tun, wenn wir eine Methode wie die folgende aufrufen m√∂chten: <br><br>  Zum Beispiel: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br>  In C ++ 14 besteht die einzige M√∂glichkeit, Code sicherer zu machen, darin, <code>this</code> mit einem Initialisierer zu erfassen: <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br>  Noch etwas: <br><br>  Beachten Sie, dass wenn Sie <code>[=]</code> in eine Member-Funktion schreiben, <code>this</code> implizit erfasst wird!  Dies kann in Zukunft zu Fehlern f√ºhren ... und wird in C ++ 20 veraltet sein. <br><br>  Also kommen wir zum n√§chsten Abschnitt: der Zukunft. <br><br>  <b>Die Zukunft mit C ++ 20</b> <br><br>  In C ++ 20 erhalten wir die folgenden Funktionen: <br><br><ul><li>  Erlaube <code>[=, this]</code> als Lambda-Erfassung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0409R2</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brich</a> die implizite Erfassung √ºber <code>[=]</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0806 ab</a> </li><li>  Paketerweiterung in <code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0780</a> </li><li>  statische, <code>thread_local</code> und Lambda-Erfassung f√ºr strukturierte Bindungen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1091</a> </li><li>  Lambda-Muster (auch mit Konzepten) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0428R2</a> </li><li>  Vereinfachung der impliziten Lambda-Erfassung - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0588R1</a> </li><li>  Konstruktives und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuweisbares</a> Lambda ohne Speichern des Standardzustands - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0624R2</a> </li><li>  Lambdas in einem nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berechneten</a> Kontext - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0315R4</a> </li></ul><br>  In den meisten F√§llen ‚Äûl√∂schen‚Äú die neu eingef√ºhrten Funktionen die Lambda-Verwendung und erm√∂glichen einige erweiterte Anwendungsf√§lle. <br><br>  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1091</a> k√∂nnen Sie beispielsweise eine strukturierte Bindung erfassen. <br><br>  Wir haben auch Erl√§uterungen dazu.  In C ++ 20 erhalten Sie eine Warnung, wenn Sie <code>[=]</code> in einer Methode erfassen: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br>  Wenn Sie dies wirklich erfassen m√ºssen, sollten Sie <code>[=, this]</code> schreiben. <br><br>  Es gibt auch √Ñnderungen in Bezug auf erweiterte Anwendungsf√§lle, z. B. zustandslose Kontexte und zustandslose Lambdas, die standardm√§√üig erstellt werden k√∂nnen. <br><br>  Mit beiden √Ñnderungen k√∂nnen Sie schreiben: <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br>  Lesen Sie die Motive f√ºr diese Funktionen in der ersten Version der S√§tze: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0315R0</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0624R0</a> . <br><br>  Aber schauen wir uns eine interessante Funktion an: Lambda-Vorlagen. <br><br>  <b>Lambd-Muster</b> <br><br>  In C ++ 14 haben wir verallgemeinerte Lambdas erhalten, was bedeutet, dass als auto deklarierte Parameter Vorlagenparameter sind. <br><br>  F√ºr Lambda: <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br>  Der Compiler generiert eine Aufrufanweisung, die der folgenden Boilerplate-Methode entspricht: <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br>  Es gab jedoch keine M√∂glichkeit, diesen Vorlagenparameter zu √§ndern und die tats√§chlichen Vorlagenargumente zu verwenden.  In C ++ 20 ist dies m√∂glich. <br><br>  Wie k√∂nnen wir beispielsweise unser Lambda darauf beschr√§nken, nur mit Vektoren irgendeiner Art zu arbeiten? <br><br>  Wir k√∂nnen ein allgemeines Lambda schreiben: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Wenn Sie es jedoch mit einem int-Parameter aufrufen (z. B. <code>foo(10);</code> ), wird m√∂glicherweise ein schwer lesbarer Fehler angezeigt: <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>  In C ++ 20 k√∂nnen wir schreiben: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Das obige Lambda erlaubt die Template-Call-Anweisung: <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  Der Template-Parameter folgt der Capture-Klausel <code>[]</code> . <br><br>  Wenn Sie es mit <code>int (foo(10);)</code> aufrufen, erhalten Sie eine sch√∂nere Nachricht: <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br>  Sie k√∂nnen hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  Im obigen Beispiel kann der Compiler uns vor Inkonsistenzen in der Lambda-Schnittstelle als im Code im Body warnen. <br><br>  Ein weiterer wichtiger Aspekt ist, dass Sie in einem universellen Lambda nur eine Variable haben, nicht deren Vorlagentyp.  Wenn Sie darauf zugreifen m√∂chten, m√ºssen Sie daher decltype (x) verwenden (f√ºr einen Lambda-Ausdruck mit dem Argument (auto x)).  Dies macht Code ausf√ºhrlicher und komplizierter. <br><br>  Zum Beispiel (unter Verwendung des Codes von P0428): <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br>  Jetzt k√∂nnen Sie schreiben als: <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br>  Im obigen Abschnitt hatten wir einen kurzen √úberblick √ºber C ++ 20, aber ich habe einen weiteren zus√§tzlichen Anwendungsfall f√ºr Sie.  Diese Technik ist sogar in C ++ 14 m√∂glich.  Also lesen Sie weiter. <br><br>  <b>Bonus - Heben mit Lambdas</b> <br><br>  Wir haben derzeit ein Problem, wenn Sie Funktions√ºberladungen haben und diese an Standardalgorithmen √ºbergeben m√∂chten (oder an alles, was ein genanntes Objekt erfordert): <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br>  Wir erhalten den folgenden Fehler von GCC 9 (Trunk): <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br>  Es gibt jedoch einen Trick, bei dem wir ein Lambda verwenden und dann die gew√ºnschte √úberlastfunktion aufrufen k√∂nnen. <br><br>  In der Grundform k√∂nnen wir f√ºr einfache Werttypen f√ºr unsere beiden Funktionen den folgenden Code schreiben: <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br>  Und in der allgemeinsten Form m√ºssen wir etwas mehr eingeben: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br>  Ziemlich komplizierter Code ... richtig?  :) :) <br><br>  Versuchen wir es zu entschl√ºsseln: <br><br>  Wir erstellen ein generisches Lambda und √ºbergeben dann alle Argumente, die wir erhalten.  Um es richtig zu bestimmen, m√ºssen wir noexcept und den Typ des R√ºckgabewerts angeben.  Deshalb m√ºssen wir den aufrufenden Code duplizieren, um die richtigen Typen zu erhalten. <br>  Ein solches LIFT-Makro funktioniert in jedem Compiler, der C ++ 14 unterst√ºtzt. <br><br>  Sie k√∂nnen hier mit dem Code spielen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Wandbox</a> <br><br>  <b>Fazit</b> <br><br>  In diesem Beitrag haben wir uns wichtige √Ñnderungen in C ++ 17 angesehen und einen √úberblick √ºber die neuen Funktionen in C ++ 20 gegeben. <br><br>  M√∂glicherweise stellen Sie fest, dass sich Lambda-Ausdr√ºcke bei jeder Iteration der Sprache mit anderen C ++ - Elementen mischen.  Zum Beispiel konnten wir sie vor C ++ 17 nicht im Kontext von constexpr verwenden, aber jetzt ist es m√∂glich.  √Ñhnlich verh√§lt es sich mit generischen Lambdas, die mit C ++ 14 beginnen, und ihrer Entwicklung zu C ++ 20 in Form von Template-Lambdas.  Vermisse ich etwas  Vielleicht haben Sie ein aufregendes Beispiel?  Bitte lassen Sie es mich in den Kommentaren wissen! <br><br>  <b>Referenzen</b> <br><br>  C ++ 11 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 17 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Ausdr√ºcke in C ++ |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft-Dokumente</a> <br>  Simon Brand - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberlasts√§tze an Funktionen √ºbergeben</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Weekly - Ep 128 - C ++ 20-Vorlagensyntax f√ºr Lambdas</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Weekly - Ep 41 - C ++ 17s Lambda-Support</a> <br><br>  Wir laden alle zu dem traditionellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Webinar</a> des Kurses ein, das morgen, den 14. Juni, stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455978/">https://habr.com/ru/post/de455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455962/index.html">Data Science und die Tropenkonferenz</a></li>
<li><a href="../de455966/index.html">Top 5 Unternehmen f√ºr die Entwicklung mobiler Apps in Gro√übritannien</a></li>
<li><a href="../de455970/index.html">Alles, was Sie √ºber SwiftUI wissen wollten, aber Angst hatten zu fragen</a></li>
<li><a href="../de455972/index.html">Slurm: Die Raupe hat sich in einen Schmetterling verwandelt</a></li>
<li><a href="../de455976/index.html">Schr√§nke, Module oder Einheiten - was f√ºr die Energieverwaltung im Rechenzentrum w√§hlen?</a></li>
<li><a href="../de455980/index.html">iOS Digest Nr. 7 (31. Mai - 13. Juni)</a></li>
<li><a href="../de455982/index.html">Es ist Zeit, GIF durch AV1-Video zu ersetzen</a></li>
<li><a href="../de455984/index.html">So verstehen Sie, dass Links funktionieren: Metriken und Aufbau von KPI-Links</a></li>
<li><a href="../de455986/index.html">Warum sollte ein IT-Techniker ein Gehirn herausnehmen?</a></li>
<li><a href="../de455988/index.html">Die Datenstrukturen des Zustands der Plasma Cash Blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>