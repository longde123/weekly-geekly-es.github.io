<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèª üíÜüèº üåÖ Quelques conseils angulaires üà∏ üíì üë©‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Assez de temps s'est √©coul√© depuis la sortie de l'Angular mis √† jour. Actuellement, de nombreux projets ont √©t√© achev√©s. De la "mise en route", de nom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quelques conseils angulaires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425959/"><p>  Assez de temps s'est √©coul√© depuis la sortie de l'Angular mis √† jour.  Actuellement, de nombreux projets ont √©t√© achev√©s.  De la "mise en route", de nombreux d√©veloppeurs sont d√©j√† pass√©s √† l'utilisation significative de ce cadre, de ses capacit√©s et ont appris √† contourner les pi√®ges.  Chaque d√©veloppeur et / ou √©quipe a d√©j√† form√© ses propres guides de style et meilleures pratiques, ou en utilise d'autres.  Mais en m√™me temps, vous devez souvent faire face √† beaucoup de code Angular, qui n'utilise pas beaucoup des fonctionnalit√©s de ce framework et / ou √©crit dans le style d'AngularJS. </p><br><p>  Cet article pr√©sente certaines des fonctionnalit√©s et des fonctionnalit√©s de l'utilisation du framework Angular, qui, selon l'opinion modeste de l'auteur, ne sont pas suffisamment couvertes dans les manuels ou ne sont pas utilis√©es par les d√©veloppeurs. <a name="habracut"></a>  L'article traite de l'utilisation des requ√™tes HTTP "Intercepteurs", de l'utilisation de Route Guards pour limiter l'acc√®s aux utilisateurs.  Certaines recommandations pour l'utilisation de RxJS et la gestion de l'√©tat de l'application sont donn√©es.  Sont √©galement pr√©sent√©es quelques recommandations sur la conception du code du projet, ce qui rendra probablement le code du projet plus propre et plus compr√©hensible.  L'auteur esp√®re que cet article sera utile non seulement aux d√©veloppeurs qui commencent tout juste √† se familiariser avec Angular, mais aussi aux d√©veloppeurs exp√©riment√©s. </p><br><h2 id="rabota-s-http">  Travailler avec HTTP </h2><br><p>  La construction de toute application Web cliente se fait autour des requ√™tes HTTP adress√©es au serveur.  Cette partie pr√©sente certaines des fonctionnalit√©s du framework Angular pour travailler avec les requ√™tes HTTP. </p><br><h3 id="ispolzuem-interceptors">  Utilisation d'intercepteurs </h3><br><p>  Dans certains cas, il peut √™tre n√©cessaire de modifier la demande avant qu'elle n'atteigne le serveur.  Ou vous devez changer chaque r√©ponse.  √Ä partir d'Angular 4.3, un nouveau HttpClient a √©t√© publi√©.  Il a ajout√© la possibilit√© d'intercepter une demande √† l'aide d'intercepteurs (Oui, ils n'ont finalement √©t√© renvoy√©s que dans la version 4.3 !, C'√©tait l'une des fonctionnalit√©s manquantes les plus attendues d'AngularJs qui n'ont pas migr√© vers Angular).  Il s'agit d'une sorte de middleware entre l'API http et la requ√™te r√©elle. </p><br><p>  Un cas d'utilisation courant peut √™tre l'authentification.  Pour obtenir une r√©ponse du serveur, vous devez souvent ajouter une sorte de m√©canisme d'authentification √† la demande.  Cette t√¢che utilisant des intercepteurs est r√©solue tout simplement: </p><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Injectable } from "@angular/core";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { Observable } from "rxjs/Observable";</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from @angular/common/http";</span></span> @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JWTInterceptor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInterceptor</span></span></span><span class="hljs-class"> </span></span>{ intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { req = req.clone({ setHeaders: { authorization: localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>) } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.handle(req); } }</code> </pre> <br><p>  Puisqu'une application peut avoir plusieurs intercepteurs, ils sont organis√©s en cha√Æne.  Le premier √©l√©ment est appel√© par le cadre angulaire lui-m√™me.  Par la suite, nous sommes responsables de transmettre la demande au prochain intercepteur.  Pour ce faire, nous appelons la m√©thode handle de l'√©l√©ment suivant de la cha√Æne d√®s que nous terminons.  Nous connectons l'intercepteur: </p><br><pre> <code class="hljs powershell">import { BrowserModule } from <span class="hljs-string"><span class="hljs-string">"@angular/platform-browser"</span></span>; import { NgModule } from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { AppComponent } from <span class="hljs-string"><span class="hljs-string">"./app.component"</span></span>; import { HttpClientModule } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; import { HTTP_INTERCEPTORS } from <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @NgModule({ declarations: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [<span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">HttpClientModule</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">HTTP_INTERCEPTORS</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">JWTInterceptor</span></span>, <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> {}</code> </pre> <br><p>  Comme vous pouvez le voir, la connexion et la mise en ≈ìuvre des intercepteurs est assez simple. </p><br><h3 id="otslezhivanie-progressa">  Suivi des progr√®s </h3><br><p>  L'une des fonctionnalit√©s de <code>HttpClient</code> est la possibilit√© de suivre la progression d'une demande.  Par exemple, si vous devez t√©l√©charger un fichier volumineux, vous souhaiterez probablement signaler √† l'utilisateur la progression du t√©l√©chargement.  Pour obtenir des progr√®s, vous devez d√©finir la propri√©t√© <code>reportProgress</code> de l'objet <code>HttpRequest</code> sur <code>true</code> .  Un exemple de service qui impl√©mente cette approche: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Injectable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpRequest } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Subject } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Subject"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpEventType } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpResponse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileUploadService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private http: HttpClient) {} public post(url: string, <span class="hljs-attr"><span class="hljs-attr">file</span></span>: File): Observable&lt;number&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject&lt;number&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpRequest(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, url, file, { <span class="hljs-attr"><span class="hljs-attr">reportProgress</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.request(req).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.type === HttpEventType.UploadProgress) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> percent = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round((<span class="hljs-number"><span class="hljs-number">100</span></span> * event.loaded) / event.total); subject.next(percent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HttpResponse) { subject.complete(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subject.asObservable(); } }</code> </pre> <br><p>  La m√©thode post renvoie un <code>Observable</code> qui repr√©sente la progression du t√©l√©chargement.  Il ne reste plus qu'√† afficher la progression du chargement dans le composant. </p><br><h2 id="marshrutizaciya-ispolzuem-route-guard">  Acheminement  Utilisation de Route Guard </h2><br><p>  Le routage vous permet de mapper les demandes d'application √† des ressources sp√©cifiques au sein de l'application.  Tr√®s souvent, il est n√©cessaire de r√©soudre le probl√®me de la limitation de la visibilit√© du chemin le long duquel certains composants sont situ√©s, en fonction de certaines conditions.  Dans ces cas, Angular a un m√©canisme de restriction de transition.  √Ä titre d'exemple, il existe un service qui impl√©mentera le routage guard.  Supposons que dans une application, l'authentification des utilisateurs soit impl√©ment√©e √† l'aide de JWT.  Une version simplifi√©e du service qui v√©rifie si l'utilisateur est autoris√© peut √™tre repr√©sent√©e comme: </p><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Injectable</span></span>() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{ constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> jwtHelper: JwtHelperService) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAuthenticated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"token"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        return !this.jwtHelper.isTokenExpired(token); } }</span></span></code> </pre> <br><p>  Pour impl√©menter Route Guard, vous devez impl√©menter l'interface <code>CanActivate</code> , qui consiste en une seule fonction <code>canActivate</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Injectable()</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthGuardService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CanActivate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> auth: AuthService, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> router: Router) {} canActivate(): boolean { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.auth.isAuthenticated()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.navigate([<span class="hljs-string"><span class="hljs-string">"login"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  L'impl√©mentation <code>AuthGuardService</code> utilise <code>AuthGuardService</code> d√©crit ci-dessus pour v√©rifier l'autorisation utilisateur.  La m√©thode <code>canActivate</code> renvoie une valeur bool√©enne qui peut √™tre utilis√©e dans la condition d'activation de l'itin√©raire. </p><br><p>  Nous pouvons maintenant appliquer la Route Guard cr√©√©e √† n'importe quel itin√©raire ou chemin.  Pour ce faire, lors de la d√©claration de <code>Routes</code> nous <code>CanActivate</code> notre service, qui h√©rite de l'interface <code>CanActivate</code> , dans la section <code>canActivate</code> : </p><br><pre> <code class="hljs powershell">export const ROUTES: Routes = [ { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">HomeComponent</span></span> }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"profile"</span></span>, <span class="hljs-type"><span class="hljs-type">component</span></span>: <span class="hljs-type"><span class="hljs-type">UserComponent</span></span>, <span class="hljs-type"><span class="hljs-type">canActivate</span></span>: [<span class="hljs-type"><span class="hljs-type">AuthGuardService</span></span>] }, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">"**"</span></span>, <span class="hljs-type"><span class="hljs-type">redirectTo</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ];</code> </pre> <br><p>  Dans ce cas, la route <code>/profile</code> a la valeur de configuration facultative <code>canActivate</code> .  <code>AuthGuard</code> d√©crit pr√©c√©demment est pass√© en tant qu'argument √† cette propri√©t√© <code>canActivate</code> .  Ensuite, la m√©thode <code>canActivate</code> sera appel√©e chaque fois que quelqu'un essaie d'acc√©der au chemin <code>/profile</code> .  Si l'utilisateur est autoris√©, il aura acc√®s au chemin <code>/profile</code> , sinon il sera redirig√© vers le chemin <code>/login</code> . </p><br><p>  Vous devez savoir que <code>canActivate</code> vous permet toujours d'activer le composant sur ce chemin, mais ne vous permet pas d'y basculer.  Si vous devez prot√©ger l'activation et le chargement du composant, alors dans ce cas, nous pouvons utiliser <code>canLoad</code> .  <code>CanLoad</code> impl√©mentation de <code>CanLoad</code> peut se faire par analogie. </p><br><h2 id="gotovim-rxjs">  Cooking RxJS </h2><br><p>  Angular est construit au-dessus de RxJS.  RxJS est une biblioth√®que pour travailler avec des flux de donn√©es asynchrones et bas√©s sur des √©v√©nements √† l'aide de s√©quences observables.  RxJS est une impl√©mentation JavaScript de l'API ReactiveX.  Pour la plupart, les erreurs qui se produisent lors de l'utilisation de cette biblioth√®que sont associ√©es √† une connaissance superficielle des bases de sa mise en ≈ìuvre. </p><br><h3 id="ispolzuem-async-vmesto-podpisyvaniya-na-sobytiya">  Utiliser async au lieu de s'inscrire √† des √©v√©nements </h3><br><p>  Un grand nombre de d√©veloppeurs qui ne sont venus que r√©cemment √† utiliser le framework Angular utilisent la fonction d' <code>subscribe</code> d' <code>Observable</code> pour recevoir et enregistrer des donn√©es dans le composant: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;span&gt;{{localData.name}} : {{localData.value}}&lt;/span&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ localData; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>).subscribe(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.localData = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }); } }</code> </pre> <br><p>  Au lieu de cela, nous pouvons nous abonner via le mod√®le en utilisant un canal asynchrone: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my-component"</span></span></span><span class="hljs-meta">, template: ` &lt;p&gt;{{data.name | async}} : {{data.value | async}}&lt;/p&gt;` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(http: HttpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"api/data"</span></span>); } }</code> </pre> <br><p>  En vous abonnant via un mod√®le, nous √©vitons les fuites de m√©moire car Angular se d√©sabonne automatiquement d' <code>Observable</code> lorsqu'un composant se casse.  Dans ce cas, pour les demandes HTTP, l'utilisation du canal asynchrone ne pr√©sente pratiquement aucun avantage, sauf pour un - async annulera la demande si les donn√©es ne sont plus n√©cessaires et ne terminera pas le traitement de la demande. </p><br><p>  De nombreuses fonctionnalit√©s d' <code>Observables</code> ne <code>Observables</code> pas utilis√©es lors de l'abonnement manuel.  <code>Observables</code> comportement <code>Observables</code> peut √™tre √©tendu en r√©p√©tant (par exemple, r√©essayer dans une demande http), en mettant √† jour la minuterie ou en mettant en cache. </p><br><h3 id="ispolzuem--dlya-oboznacheniya-observables">  Utilisez <code>$</code> pour d√©signer les observables </h3><br><p>  Le paragraphe suivant est li√© √† la conception des codes source de l'application et d√©coule du paragraphe pr√©c√©dent.  Afin de distinguer les variables <code>Observable</code> des variables simples, vous pouvez tr√®s souvent entendre le conseil d'utiliser le signe ¬´ <code>$</code> ¬ª au nom d'une variable ou d'un champ.  Cette astuce simple √©liminera la confusion dans les variables lors de l'utilisation de l'async. </p><br><pre> <code class="hljs cs">import { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; import { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Rx"</span></span>; import { UserClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user.client"</span></span>; import { User } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../services/user"</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">"user-list"</span></span>, template: ` &lt;ul <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user_list"</span></span> *ngIf=<span class="hljs-string"><span class="hljs-string">"(users$ | async).length"</span></span>&gt; &lt;li <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"user"</span></span> *ngFor=<span class="hljs-string"><span class="hljs-string">"let user of users$ | async"</span></span>&gt; {{ user.name }} - {{ user.birth_date }} &lt;/li&gt; &lt;/ul&gt;` }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserList</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> users$: Observable&lt;User[]&gt;; constructor(<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> userClient: UserClient) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client.getUsers(); } }</code> </pre> <br><h3 id="kogda-nuzhno-otpisyvatsya-unsubscribe">  Quand se d√©sinscrire (se d√©sinscrire) </h3><br><p>  La question la plus fr√©quemment pos√©e par un d√©veloppeur lorsqu'il apprend bri√®vement √† conna√Ætre Angular est quand vous devez toujours vous d√©sinscrire, et quand ce n'est pas le cas.  Pour r√©pondre √† cette question, vous devez d'abord d√©cider quel type d' <code>Observable</code> est actuellement utilis√©.  Dans Angular, il existe 2 types d' <code>Observable</code> - fini et infini, certains produisent un fini, d'autres, respectivement, un nombre infini de valeurs. </p><br><p>  <code>Http</code> <code>Observable</code> est compact et les √©couteurs / √©couteurs des √©v√©nements DOM sont infinis <code>Observable</code> . </p><br><p>  Si l'abonnement aux valeurs d'un <code>Observable</code> infini <code>Observable</code> fait manuellement (sans utiliser de canal asynchrone), alors une r√©ponse doit √™tre faite sans √©chec.  Si nous souscrivons manuellement √† un Observable fini, il n'est pas n√©cessaire de se d√©sinscrire, RxJS s'en chargera.  Dans le cas d' <code>Observables</code> compacts <code>Observables</code> nous pouvons nous d√©sinscrire si <code>Observable</code> a un temps d'ex√©cution plus long que n√©cessaire, par exemple, une requ√™te HTTP multiple. </p><br><p>  Un exemple d' <code>Observables</code> compacts: </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> http: HttpClient) { } ngOnInit() { Observable.timer(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"http://api.com"</span></span>).subscribe(...); } }</code> </pre> <br><p>  Exemple d'observables infinis </p><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.click.unsubscribe(); } }</code> </pre> <br><p>  Ci-dessous, plus en d√©tail, les cas dans lesquels vous devez vous d√©sinscrire </p><br><ol><li>  Il est n√©cessaire de se d√©sinscrire du formulaire et des contr√¥les individuels auxquels vous avez souscrit: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form = new FormGroup({...}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.valueChanges.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.form.statusChanges.subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.valueChangesSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.statusChangesSubs.unsubscribe(); } }</code> </pre> <br><ol><li>  Routeur  Selon la documentation, Angular devrait se d√©sinscrire, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mais cela ne se produit pas</a> .  Par cons√©quent, afin d'√©viter d'autres probl√®mes, nous √©crivons par nous-m√™mes: </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> route: ActivatedRoute, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> router: Router) { } ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.params.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.queryParams.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.fragment.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.route.url.subscribe(..); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.router.events.subscribe(...); } ngOnDestroy() { <span class="hljs-comment"><span class="hljs-comment">//        observables } }</span></span></code> </pre> <br><ol><li>  Des s√©quences sans fin.  Des exemples sont des s√©quences cr√©√©es √† l'aide d' <code>interva()</code> ou d'√©couteurs d'√©v√©nements <code>(fromEvent())</code> : </li></ol><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> element : ElementRef) { } interval: Subscription; click: Subscription; ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).subscribe(...); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs = Observable.fromEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.nativeElement, <span class="hljs-string"><span class="hljs-string">"click"</span></span>).subscribe(...); } ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.intervalSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clickSubs.unsubscribe(); } }</code> </pre> <br><h3 id="takeuntil-i-takewhile">  takeUntil et takeWhile </h3><br><p>  Pour simplifier le travail avec des <code>Observables</code> infinis dans RxJS, il existe deux fonctions pratiques - <code>takeUntil</code> et <code>takeWhile</code> .  Ils effectuent la m√™me action - se d√©sinscrire de l' <code>Observable</code> √† la fin d'une condition, la diff√©rence ne concerne que les valeurs accept√©es.  <code>takeWhile</code> accepte un <code>boolean</code> et <code>takeUntil</code> un <code>Subject</code> . <br>  Exemple <code>takeWhile</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> alive: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService .authenticate(email, password) .takeWhile(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.alive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Dans ce cas, lorsque le drapeau <code>alive</code> est modifi√©, l' <code>Observable</code> se d√©sabonne.  Dans cet exemple, d√©sabonnez-vous lorsque le composant est d√©truit. <br>  Exemple <code>takeUntil</code> : </p><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> user: User; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unsubscribe: Subject&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.authenticate(email, password) .takeUntil(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe) .subscribe(user =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user = user; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ngOnDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.next(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe.complete(); } }</code> </pre> <br><p>  Dans ce cas, pour vous d√©sabonner d' <code>Observable</code> nous signalons que le <code>subject</code> prend la valeur suivante et la compl√®te. </p><br><p>  L'utilisation de ces fonctions √©vitera les fuites et simplifiera le travail de d√©sinscription des donn√©es.  Quelle fonction utiliser?  La r√©ponse √† cette question doit √™tre guid√©e par les pr√©f√©rences personnelles et les exigences actuelles. </p><br><h2 id="upravlenie-sostoyaniem-v-angular-prilozheniyah-ngrxstore">  Gestion des √©tats dans les applications angulaires, @ ngrx / store </h2><br><p>  Tr√®s souvent, lors du d√©veloppement d'applications complexes, nous sommes confront√©s √† la n√©cessit√© de stocker l'√©tat et de r√©pondre √† ses changements.  Il existe de nombreuses biblioth√®ques d'applications d√©velopp√©es sur le framework ReactJs qui vous permettent de contr√¥ler l'√©tat de l'application et de r√©pondre √† ses changements - Flux, Redux, Redux-saga, etc.  Pour les applications angulaires, il existe un conteneur d'√©tat bas√© sur RxJS inspir√© de Redux - @ ngrx / store.  Une bonne gestion de l'√©tat de l'application √©vitera au d√©veloppeur de nombreux probl√®mes li√©s √† l'extension de l'application. </p><br><p>  Pourquoi Redux <br>  Redux se positionne comme un conteneur d'√©tat pr√©visible pour les applications JavaScript.  Redux est inspir√© par Flux et Elm. </p><br><p>  Redux sugg√®re de consid√©rer l'application comme un √©tat initial modifiable par une s√©quence d'actions, ce qui peut √™tre une bonne approche pour cr√©er des applications Web complexes. </p><br><p>  Redux n'est associ√© √† aucun framework sp√©cifique, et bien qu'il ait √©t√© d√©velopp√© pour React, il peut √™tre utilis√© avec Angular ou jQuery. </p><br><p>  Les principaux postulats de Redux: </p><br><ul><li>  un r√©f√©rentiel pour l'√©tat complet de l'application </li><li>  √©tat en lecture seule </li><li>  les modifications sont effectu√©es par des fonctions ¬´pures¬ª, soumises aux exigences suivantes: </li><li>  ne doit pas effectuer d'appels externes sur un r√©seau ou une base de donn√©es; </li><li>  retourne une valeur qui ne d√©pend que des param√®tres pass√©s; </li><li>  les arguments sont immuables, c'est-√†-dire  les fonctions ne doivent pas les modifier; </li><li>  appeler une fonction pure avec les m√™mes arguments renvoie toujours le m√™me r√©sultat; </li></ul><br><p>  Un exemple de fonction de gestion d'√©tat: </p><br><pre> <code class="hljs julia">// counter.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ActionReducer, Action } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> INCREMENT = <span class="hljs-string"><span class="hljs-string">"INCREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DECREMENT = <span class="hljs-string"><span class="hljs-string">"DECREMENT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESET = <span class="hljs-string"><span class="hljs-string">"RESET"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> counterReducer(state: number = <span class="hljs-number"><span class="hljs-number">0</span></span>, action: Action) { switch (action.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { case INCREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state + <span class="hljs-number"><span class="hljs-number">1</span></span>; case DECREMENT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state - <span class="hljs-number"><span class="hljs-number">1</span></span>; case RESET: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  Le r√©ducteur est import√© dans le module principal de l'application et en utilisant la fonction <code>StoreModule.provideStore(reducers)</code> nous le rendons disponible pour l'injecteur angulaire: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> app.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { StoreModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { counterReducer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./counter"</span></span>; @NgModule({ imports: [ BrowserModule, StoreModule.provideStore({ counter: counterReducer }) ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br><p>  Ensuite, le service <code>Store</code> est introduit dans les composants et services n√©cessaires.  La fonction store.select () est utilis√©e pour s√©lectionner l'√©tat "tranche": </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">// app.component.ts ... interface AppState { counter: number; } @Component({ selector: "my-app", template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"increment()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Increment</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Current Count: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ counter | async }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"decrement()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Decrement</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span></span><span class="xml"><span class="hljs-tag">)=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"reset()"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Reset Counter</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">` }) class AppComponent { counter: Observable</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">number</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">; constructor(private store: Store</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppState</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">) { this.counter = store.select("counter"); } increment() { this.store.dispatch({ type: INCREMENT }); } decrement() { this.store.dispatch({ type: DECREMENT }); } reset() { this.store.dispatch({ type: RESET }); } }</span></span></code> </pre> <br><h3 id="ngrxrouter-store">  @ ngrx / router-store </h3><br><p>  Dans certains cas, il est pratique d'associer l'√©tat de l'application √† l'itin√©raire actuel de l'application.  Pour ces cas, le module @ ngrx / router-store existe.  Pour que l'application utilise le <code>router-store</code> pour enregistrer l'√©tat, connectez simplement <code>routerReducer</code> et ajoutez un appel √† <code>RouterStoreModule.connectRoute</code> dans le module d'application principal: </p><br><pre> <code class="hljs powershell">import { StoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/store"</span></span>; import { routerReducer, RouterStoreModule } from <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; @NgModule({ imports: [ <span class="hljs-type"><span class="hljs-type">BrowserModule</span></span>, <span class="hljs-type"><span class="hljs-type">StoreModule.provideStore</span></span>({ <span class="hljs-type"><span class="hljs-type">router</span></span>: <span class="hljs-type"><span class="hljs-type">routerReducer</span></span> }), <span class="hljs-type"><span class="hljs-type">RouterStoreModule.connectRouter</span></span>() ], bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><p>  Ajoutez maintenant le <code>RouterState</code> √† l'√©tat principal de l'application: </p><br><pre> <code class="hljs cs">import { RouterState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@ngrx/router-store"</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">AppState</span></span> { ... router: RouterState; };</code> </pre> <br><p>  De plus, nous pouvons indiquer l'√©tat initial de l'application lors de la d√©claration du magasin: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">StoreModule</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.provideStore</span></span>( { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: routerReducer }, { <span class="hljs-attribute"><span class="hljs-attribute">router</span></span>: { path: window.location.pathname + window.location.search } } );</code> </pre> <br><p>  Actions prises en charge: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { go, replace, <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, back, forward } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "@ngrx/router-store"; //      store.dispatch(go(["/path", { routeParam: <span class="hljs-number"><span class="hljs-number">1</span></span> }], { query: "string" })); //        store.dispatch(replace(["/path"], { query: "string" })); //        store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(["/path"], { query: "string" })); //       store.dispatch(<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>({ query: "string" })); //   store.dispatch(back()); //   store.dispatch(forward());</code> </pre> <br><p>  UPD: Dans le commentaire, ils ont sugg√©r√© que ces actions ne seront pas disponibles dans la nouvelle version @ngrx, pour la nouvelle version <a href="">https://github.com/ngrx/platform/blob/master/MIGRATION.md#ngrxrouter-store</a> </p><br><p>  L'utilisation du conteneur d'√©tat √©liminera de nombreux probl√®mes lors du d√©veloppement d'applications complexes.  Cependant, il est important de rendre la gestion de l'√âtat aussi simple que possible.  Tr√®s souvent, il faut g√©rer des applications dans lesquelles l'imbrication d'√©tats est excessive, ce qui ne fait que compliquer la compr√©hension de l'application. </p><br><h2 id="organizaciya-koda">  Organisation du code </h2><br><h3 id="izbavlyaemsya-ot-gromozdkih-vyrazheniy-v-import">  Se d√©barrasser des expressions volumineuses lors de l' <code>import</code> </h3><br><p>  De nombreux d√©veloppeurs sont conscients d'une situation o√π les expressions √† l' <code>import</code> plut√¥t lourdes.  Cela est particuli√®rement visible dans les grandes applications o√π il existe de nombreuses biblioth√®ques r√©utilisables. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../core/subpackage1/subpackage2/some.service";</code> </pre> <br><p>  Quoi d'autre est mauvais dans ce code?  Si vous devez transf√©rer notre composant dans un autre r√©pertoire, les expressions √† l' <code>import</code> ne seront pas valides. </p><br><p>  Dans ce cas, l'utilisation d'alias nous permettra de nous √©loigner des expressions volumineuses √† l' <code>import</code> et de rendre notre code beaucoup plus propre.  Pour pr√©parer le projet √† l'utilisation des alias, vous devez ajouter les propri√©t√©s baseUrl et path dans <code>tsconfig.json</code> : </p><br><pre> <code class="hljs perl">/ tsconfig.json { <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { ... <span class="hljs-string"><span class="hljs-string">"baseUrl"</span></span>: <span class="hljs-string"><span class="hljs-string">"src"</span></span>, <span class="hljs-string"><span class="hljs-string">"paths"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@app/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"app/*"</span></span>], <span class="hljs-string"><span class="hljs-string">"@env/*"</span></span>: [<span class="hljs-string"><span class="hljs-string">"environments/*"</span></span>] } } }</code> </pre> <br><p>  Avec ces changements, il est assez facile de g√©rer les plug-ins: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, OnInit } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"rxjs/Observable"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@app/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { environment } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@env/environment"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LocalService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./local.service"</span></span>; @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( private someService: SomeService, private localService: LocalService ) { } }</code> </pre> <br><p>  Dans cet exemple, <code>SomeService</code> import√© directement de <code>@app/core</code> au lieu d'une expression volumineuse (par exemple <code>@app/core/some-package/some.service</code> ).  Ceci est possible gr√¢ce √† la r√©exportation des composants publics dans le fichier principal <code>index.ts</code> .  Il est conseill√© de cr√©er un fichier <code>index.ts</code> pour chaque package dans lequel vous devez r√©exporter tous les modules publics: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> index.ts <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./core.module"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./auth/auth.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./user/user.service"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-service/some.service"</span></span>;</code> </pre> <br><h3 id="core-shared-i-feature-moduli">  Modules de base, partag√©s et de fonctionnalit√©s </h3><br><p>  Pour une gestion plus souple des composants applicatifs, il est assez souvent recommand√© dans la litt√©rature et les diff√©rentes ressources Internet de diffuser la visibilit√© de ses composants.  Dans ce cas, la gestion des composants de l'application est simplifi√©e.  La s√©paration suivante est la plus couramment utilis√©e: modules Core, Shared et Feature. </p><br><h4 id="coremodule">  Coremodule </h4><br><p>  L'objectif principal de CoreModule est de d√©crire les services qui auront une instance pour l'ensemble de l'application (c'est-√†-dire impl√©menter le mod√®le singleton).  Il s'agit souvent d'un service d'autorisation ou d'un service d'obtention d'informations utilisateur.  Exemple de CoreModule: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule, Optional, SkipSelf } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { HttpClientModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common/http"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeSingletonService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-singleton/some-singleton.service"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, HttpClientModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [SomeSingletonService] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   CoreModule    NgModule the AppModule */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( @Optional() @SkipSelf() parentModule: CoreModule ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentModule) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"CoreModule is already loaded. Import only in AppModule"</span></span>); } } }</code> </pre> <br><h4 id="sharedmodule">  Module partag√© </h4><br><p>  Ce module d√©crit des composants simples.  Ces composants n'importent pas ou n'injectent pas de d√©pendances d'autres modules dans leurs constructeurs.  Ils doivent recevoir toutes les donn√©es via les attributs du mod√®le de composant.  <code>SharedModule</code> ne d√©pend pas du reste de notre application. C'est √©galement un endroit id√©al pour importer et r√©exporter des composants de mat√©riaux angulaires ou d'autres biblioth√®ques d'interface utilisateur. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { CommonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/common"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FormsModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/forms"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { MdButtonModule } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@angular/material"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SomeCustomComponent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./some-custom/some-custom.component"</span></span>; @NgModule({ <span class="hljs-attr"><span class="hljs-attr">imports</span></span>: [CommonModule, FormsModule, MdButtonModule], <span class="hljs-attr"><span class="hljs-attr">declarations</span></span>: [SomeCustomComponent], <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: [ <span class="hljs-comment"><span class="hljs-comment">/*  Angular Material*/</span></span> CommonModule, FormsModule, MdButtonModule, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> SomeCustomComponent ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedModule</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><h4 id="featuremodule">  Module de fonctionnalit√©s </h4><br><p>  Ici, vous pouvez r√©p√©ter le guide de style angulaire.  Un FeatureModule distinct est cr√©√© pour chaque fonction d'application ind√©pendante.  FeatureModule doit importer des services uniquement √† partir de <code>CoreModule</code> .  Si un module devait importer un service √† partir d'un autre module, il est possible que ce service soit d√©plac√© vers <code>CoreModule</code> . </p><br><p>  Dans certains cas, il est n√©cessaire d'utiliser le service uniquement par certains modules et il n'est pas n√©cessaire de l'exporter vers <code>CoreModule</code> .  Dans ce cas, vous pouvez cr√©er un <code>SharedModule</code> sp√©cial, qui ne sera utilis√© que dans ces modules. <br>  ,     ‚Äî   ,     -  ,    ,  <code>CoreModule</code>  ,  <code>SharedModule</code> . </p><br><p>        ,     .    ,   .    ,   ,             . </p><br><h3 id="spisok-literatury">  Les r√©f√©rences </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ngrx/store</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://stepansuvorov.com/blog/2017/06/angular-rxjs-unsubscribe-or-not-unsubscribe/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://medium.com/@tomastrajan/6-best-practices-pro-tips-for-angular-cli-better-developer-experience-7b328bc9db81</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/336280/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://angular.io/docs</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425959/">https://habr.com/ru/post/fr425959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425947/index.html">Ratatouille corporative</a></li>
<li><a href="../fr425951/index.html">Comment pirat√© la blockchain et les crypto-monnaies: 6 attaques r√©ussies "51 pour cent"</a></li>
<li><a href="../fr425953/index.html">Station m√©t√©o sur Arduino de A √† Z. Partie 3</a></li>
<li><a href="../fr425955/index.html">8 bogues b√™ta int√©ressants d'iOS 12 et comment nous les avons recherch√©s</a></li>
<li><a href="../fr425957/index.html">V√©los √† essence ou recherches de produits √©tranges (e-commerce)</a></li>
<li><a href="../fr425961/index.html">¬´Apprendre le printemps est une le√ßon absurde¬ª - Josh Long, principal √©vang√©liste du printemps dans la cuisine int√©rieure du projet</a></li>
<li><a href="../fr425963/index.html">Station m√©t√©o sur Arduino de A √† Z. Partie 4</a></li>
<li><a href="../fr425965/index.html">SAP Data Management Suite comme un complexe pour travailler avec le Big Data dans les entreprises</a></li>
<li><a href="../fr425967/index.html">Massacre √† la tron√ßonneuse au silicium</a></li>
<li><a href="../fr425969/index.html">Comment vais-je devenir d√©veloppeur web ... et le serai-je?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>