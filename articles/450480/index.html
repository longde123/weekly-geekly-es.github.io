<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 💇🏼 🧗🏻 Cómo la computación cuántica puede afectar el desarrollo de software 🤱🏾 🐮 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Durante los últimos seis meses, la editorial ha estado trabajando activamente en el tema de la computación cuántica y su aplicabilida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo la computación cuántica puede afectar el desarrollo de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/450480/">  Hola a todos! <br><br>  Durante los últimos seis meses, la editorial ha estado trabajando activamente en el tema de la computación cuántica y su aplicabilidad práctica.  Durante mucho tiempo no fue posible encontrar un artículo digno de traducción sobre este interesante tema, hasta que apareció un artículo en el blog de Oracle.  La publicación servirá como una excelente introducción al software, hardware y problemas de ciencias puramente naturales de este nuevo paradigma, por lo que la lectura es imprescindible. <br><br><img src="https://habrastorage.org/webt/it/bt/rt/itbtrtg_wcsimf8fhliumzzyigu.jpeg"><br><a name="habracut"></a><br>  En los últimos meses y años, el interés en la computación cuántica ha crecido significativamente.  Constantemente aparecen nuevos materiales de institutos de investigación, empresas u organizaciones gubernamentales, que informan sobre logros importantes en esta área.  Al mismo tiempo, los artículos con una base técnica más débil discuten las posibles consecuencias de la computación cuántica, y los pronósticos van desde la piratería de las técnicas de cifrado más modernas hasta las promesas de curar todas las enfermedades y completar el trabajo para crear una IA completa.  Sin embargo, no todas estas expectativas son igualmente realistas. <br><br>  Si eres un programador sobrio practicante, entonces te estarás preguntando dónde está la línea entre los hechos y la ficción en estos cálculos, y cómo la computación cuántica afectará el desarrollo de software en el futuro. <br><br>  Naturalmente, quedan muchos años antes de la creación de hardware de trabajo para la computación cuántica.  Sin embargo, los principios generales de este paradigma ya se entienden hoy, existen abstracciones que permiten a los desarrolladores crear aplicaciones en las que las posibilidades de la computación cuántica se realizan mediante simuladores. <br><br><h4>  ¿La computación cuántica se reduce a otra ganancia de CPU? </h4><br>  El desarrollo de software tradicional utilizando computadoras clásicas implica traducir un lenguaje de programación de alto nivel (como Java) en operaciones realizadas en una gran cantidad de transistores (hardware). <br><br>  En la Figura 1, este proceso se esquematiza en su forma más simple: el código fuente de Java se compila en código de bytes independiente de la plataforma, que, a su vez, se traduce en código de máquina específico de la plataforma.  El código de máquina utiliza una serie de operaciones simples (puertas) realizadas en la memoria.  El principal componente de hardware utilizado para este propósito es el conocido transistor. <br><br><img src="https://habrastorage.org/webt/8c/-6/go/8c-6goi59u27wzyytc0zvgv3ero.png"><br><br>  <i>Fig.</i>  <i>1. Traducción de un lenguaje de programación de alto nivel a operaciones realizadas en transistores</i> . <br><br>  El aumento de la productividad alcanzado en los últimos años se ha logrado principalmente debido a la mejora de las tecnologías de hardware.  Los tamaños de un solo transistor han disminuido drásticamente, y cuantos más transistores pueda colocar en cada milímetro cuadrado, más memoria y potencia de procesamiento tendrá la computadora. <br><br>  La computación cuántica es una tecnología disruptiva, porque aquí las unidades de computación más simples no son transistores clásicos, sino qubits, de los cuales hablaremos a continuación. <br><br>  El punto no es solo en las diferencias de estos elementos primarios, sino también en un dispositivo diferente de válvulas.  Por lo tanto, la pila con la fig.  1 en computación cuántica no es aplicable. <br><br><h4>  ¿La computación cuántica romperá toda la pila de arriba al nivel de Java? </h4><br>  En resumen: "no realmente".  Los científicos están paulatinamente de acuerdo en que las computadoras cuánticas serán especialmente buenas para resolver problemas específicos, mientras que otros problemas se resolverán de manera más racional usando las computadoras tradicionales.  Suena familiar, ¿verdad?  Se observa una situación similar al comparar la GPU y la CPU.  Si bien los transistores también se usan en la GPU, en principio difieren de la CPU, sin embargo, muchas aplicaciones escritas en un lenguaje de alto nivel utilizan las capacidades de la CPU y la GPU bajo el capó.  Las GPU son muy buenas para el procesamiento de vectores, y en muchas aplicaciones y bibliotecas el trabajo de la CPU y la GPU se diferencia. <br><br>  Por ejemplo, esta es exactamente la situación cuando se utiliza JavaFX o Deeplearning4j.  Si está escribiendo una aplicación de interfaz de usuario utilizando JavaFX, solo trabaja con código Java (quizás también FXML para declarar una interfaz de usuario).  Cuando la escena JavaFX necesita mostrarse en la pantalla, las implementaciones JavaFX internas usan sombreadores y texturas para esto, contactando directamente a los controladores de GPU de bajo nivel, como se muestra en la Figura 2. Por lo tanto, no tiene que preocuparse sobre qué parte del código está mejor adaptada para trabajar con la CPU y cuáles con GPU <br><br><img src="https://habrastorage.org/webt/lo/ni/um/loniumkhuuzidq5syb6z_pimfqe.png"><br><br>  <i>Fig.</i>  <i>2. JavaFX delega el trabajo de la GPU y la CPU.</i> <br><br>  Como se muestra en la fig.  2, el código de implementación JavaFX delega el trabajo pasándolo a la GPU y la CPU.  Aunque estas operaciones están ocultas para el desarrollador (no se proporciona a través de la API), cierto conocimiento de la GPU a menudo es útil cuando necesita desarrollar aplicaciones JavaFX más potentes. <br><br>  Cuando se usa Deeplearning4j, se desarrolla una situación similar.  Deeplearning4j tiene varias implementaciones para realizar las operaciones de matriz y vector requeridas, y algunas de ellas usan GPU.  Sin embargo, no le importa como desarrollador final qué capacidades utilizará su código: CPU o GPU. <br><br>  Parece que las computadoras cuánticas harán un excelente trabajo resolviendo problemas que, como regla, aumentan exponencialmente a medida que crece el volumen del problema y, por lo tanto, difícilmente se pueden resolver o casi no se pueden resolver usando computadoras clásicas.  En particular, los expertos hablan de una realización híbrida: una aplicación típica de extremo a extremo contiene código clásico que se ejecuta en la CPU, pero también puede contener código cuántico. <br><br><h4>  ¿Cómo puede un sistema ejecutar código cuántico? </h4><br>  Hoy, el hardware para computadoras cuánticas sigue siendo extremadamente experimental.  Si bien las grandes corporaciones y, presumiblemente, algunos estados se dedican al desarrollo de prototipos, dicha tecnología no está ampliamente disponible.  Pero, cuando aparece, su forma puede ser diferente: <br><br><ul><li>  Se puede integrar un coprocesador cuántico con la CPU en el sistema. </li><li>  Los problemas cuánticos se pueden delegar a los sistemas cuánticos de nubes. </li></ul><br>  Aunque sigue habiendo una enorme incertidumbre acerca de los antecedentes prácticos de tales decisiones, estamos cada vez más de acuerdo en cómo debería verse un código cuántico.  En el nivel más bajo deben estar los siguientes ladrillos: <i>qubits</i> y <i>puertas cuánticas</i> .  En base a ellos, puede crear <i>simuladores cuánticos</i> que implementen el comportamiento esperado. <br><br>  Por lo tanto, un simulador cuántico es una herramienta ideal para tal desarrollo. <br>  Los resultados que brindan deben ser casi los mismos que se obtendrían en el equipo real de una computadora cuántica, pero el simulador funciona mucho más lento, ya que los efectos cuánticos que aceleran los equipos cuánticos deben simularse con el software tradicional. <br><br><h4>  ¿Cuáles son los componentes básicos de la computación cuántica? </h4><br>  A menudo es importante comparar los cálculos clásicos con los cuánticos.  En informática clásica, tenemos bits y puertas. <br><br>  Un bit contiene un solo bit de información, y su valor puede ser 0 o 1. <br>  Una válvula actúa sobre uno o más bits y puede operar sobre ellos.  Por ejemplo, la válvula NOT, que se muestra en la Figura 3, invierte el valor de un bit.  Si la entrada es 0, entonces la salida de la puerta NOT será 1 y viceversa. <br><br><img src="https://habrastorage.org/webt/si/3q/o9/si3qo9r_ri2pwgthjqdboizvbni.png"><br><br>  <i>Fig.</i>  <i>3. NO válvula</i> <br><br>  En computación cuántica, tenemos bits y puertas equivalentes.  El equivalente cuántico de un bit es qubit.  El valor de un qubit puede ser igual a 0 o 1, como un bit clásico, sin embargo, también puede estar en la llamada superposición.  Este es un concepto complejo, según el cual un qubit puede estar simultáneamente en ambos estados: 0 y 1. <br><br>  Cuando un qubit está en superposición, su valor es una combinación lineal de los estados 0 y 1. Esto se puede escribir como se muestra en la Fig.  4: <br><br><img src="https://habrastorage.org/webt/gw/oy/o1/gwoyo19gwbizhzgmnxcix5z7kja.jpeg"><br><br>  <i>Fig.</i>  <i>4. Igualdad donde el qubit está en superposición.</i> <br><br>  Nota: los qubits a menudo se escriben en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notación de corchetes</a> , donde el nombre de la variable se coloca entre los caracteres "|"  y "&gt;". <br><br>  La expresión en la Fig.  4 informa que qubit x está en una superposición de estados | 0&gt; y | 1&gt;.  Esto no significa que esté en el estado | 0&gt; O en el estado | 1&gt;;  Esto significa que no conocemos su estado actual. <br><br>  De hecho, está en ambos estados simultáneamente, y de esta forma puede ser manipulado.  Sin embargo, cuando medimos el qubit, estará en un estado, ya sea | 0&gt; o | 1&gt;.  Hay otra restricción en la expresión anterior: a ^ 2 + b ^ 2 = 1. <br>  Los valores de ayb son probabilísticos: existe una probabilidad a ^ 2 de que, cuando medimos el qubit | x&gt;, contendrá el valor | 0&gt;, y la probabilidad b ^ 2 de que el qubit medido contendrá el valor | 1&gt;. <br><br>  Hay un importante factor limitante que rompe las alegrías de la computación cuántica: después de medir un qubit, se pierde toda la información sobre la superposición potencial en la que se encontraba.  El valor qubit puede ser 0 o 1. <br><br>  En los cálculos, un qubit en superposición puede corresponder a 0 y 1 al mismo tiempo (con diferentes probabilidades).  Si tenemos dos qubits, entonces se pueden usar para representar cuatro estados (00, 01, 10 y 11), nuevamente, con diferentes probabilidades.  Aquí llegamos a la esencia del poder de las computadoras cuánticas.  Con ocho bits clásicos, puede representar exactamente un número en el rango de 0 a 255. Los valores de cada uno de los ocho bits serán 0 o 1. Con ocho qubits, puede representar simultáneamente todos los números del 0 al 255. <br><br><h4>  ¿De qué sirve la superposición si solo puede medir un estado? </h4><br>  A menudo, el resultado del algoritmo es simple (sí o no), pero para llegar a él, se requiere mucha computación paralela.  Manteniendo qubits en superposición durante los cálculos, puede tener en cuenta de inmediato cualquier opción diferente.  Sin cumplir con las decisiones para cada combinación individual, una computadora cuántica puede calcular todas las opciones en un solo paso. <br>  Luego, en muchos algoritmos cuánticos, comienza la siguiente etapa importante: conectar el resultado del algoritmo con una medición que dé un resultado significativo.  A menudo, se tiene en cuenta la interferencia: los resultados interesantes se superponen estructuralmente entre sí, mientras que los que no son interesantes se cancelan entre sí (interferencia destructiva). <br><br><h4>  ¿Cómo se puede "transformar" un qubit en un estado de superposición? </h4><br>  Así como las puertas clásicas manipulan bits, las puertas cuánticas manipulan qubits.  Algunas puertas cuánticas se parecen a las clásicas;  por ejemplo, la puerta Pauli-X transfiere el qubit del estado a | 0&gt; + b | 1&gt; al estado b | 0 |  + a | 1&gt;, que es similar al principio de la puerta NO clásica.  De hecho, cuando a = 1 yb = 0, el qubit estaba inicialmente en el estado | 0&gt;.  Después de la acción de la válvula Pauli-X, este qubit entrará en el estado | 1&gt;, como se muestra en la Fig.  5) <br><br><img src="https://habrastorage.org/webt/vi/jd/np/vijdnpok8ttp8wrxzxlzkrpfv3y.png"><br><br>  <i>Fig.</i>  <i>5. El resultado del uso de la válvula Pauli-X.</i> <br><br>  En este contexto, la válvula Hadamard es muy interesante.  Pone el qubit en el estado | 0&gt;: 1 / sqrt (2) * (| 0&gt; + | 1&gt;) en una superposición, como se muestra en la Fig.  6) <br><br><img src="https://habrastorage.org/webt/ms/oe/rs/msoers9oh3on6umailvyiwom8lg.png"><br><br>  <i>Fig.</i>  <i>6. El resultado de aplicar la válvula Hadamard.</i> <br><br>  Después de aplicar la válvula Hadamard a un qubit y medir el qubit, existe una probabilidad del 50% de que el valor del qubit sea 0 y del 50% de que el valor del qubit sea 1. Hasta que se mida el qubit, permanece en un estado de superposición . <br><br><h4>  ¿Cómo es todo esto posible? </h4><br>  Si está realmente interesado en la respuesta a esta pregunta, tendrá que estudiar la física cuántica en detalle.  Pero, afortunadamente, no es necesario comprender toda la base teórica de estos fenómenos.  Si bien el fenómeno de superposición puede parecer incomprensible, es importante enfatizar que son estas propiedades las características de las partículas elementales en la naturaleza.  Por lo tanto, la computación cuántica está mucho más cerca de lo básico de la realidad física de lo que parece a primera vista. <br><br><h4>  ¿Debería esperar unos años y luego observar más de cerca la computación cuántica? </h4><br>  No  En este caso, llegarás tarde.  Es teóricamente posible desarrollar primero hardware, y luego proceder al estudio del nivel de software y ver qué se puede lograr con él.  Sin embargo, todos los conceptos ya son más o menos claros, y ya es posible escribir simuladores cuánticos en lenguajes populares, incluidos Java, C #, Python y otros. <br>  Entonces estos simuladores se pueden usar para trabajar en algoritmos cuánticos.  Aunque estos algoritmos no proporcionarán un aumento de rendimiento tal que se pueda lograr con su ayuda cuando trabajen en equipos cuánticos reales, deberían estar funcionalmente completos. <br><br>  Por lo tanto, si actualmente está desarrollando un algoritmo cuántico, entonces tiene tiempo para mejorarlo y puede iniciarlo cuando aparezca un equipo cuántico en el acceso. <br><br>  Los algoritmos cuánticos requieren un enfoque intelectual diferente al de los clásicos.  Destacados científicos comenzaron a desarrollar algoritmos cuánticos en el siglo pasado, y ahora se publican más y más artículos que describen tales algoritmos, incluidos los de multiplicación de enteros, búsqueda de listas, trabajo de optimización de rutas y mucho más. <br><br>  Hay otras razones por las cuales podría valer la pena hacer computación cuántica hoy.  Refactorizar un sistema de software en una gran empresa moderna no es una de esas cosas que se pueden hacer de la noche a la mañana.  Sin embargo, una de las áreas en las que la computación cuántica hará una verdadera revolución es el cifrado;  después de todo, todo se basa en la teoría de que en una computadora clásica es prácticamente imposible descomponer un número entero grande en factores primos. <br><br>  Aunque pueden pasar muchos años antes de que las computadoras cuánticas se vuelvan lo suficientemente grandes como para resolver fácilmente el problema de la factorización de enteros, los desarrolladores saben que lleva muchos años cambiar los sistemas e introducir tecnologías nuevas y más seguras en ellos. <br><br><h4>  ¿Cómo puedo aprender a trabajar con algoritmos cuánticos en Java? </h4><br>  Puede descargar y dominar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Strange</a> , el simulador de computadora cuántica de código abierto en Java.  Strange le permite simular un algoritmo cuántico creando una serie de qubits y aplicando varias puertas cuánticas a ellos. <br><br>  Como ejemplo simple, creemos dos qubits, q [0] y q [1], de modo que inicialmente ambos estén en estado 0. Luego aplicamos dos puertas simples a cada uno de los qubits, de modo que gráficamente esta operación corresponde a la fig.  7) <br><br>  El primer qubit irá primero a la válvula Pauli-X y luego a la válvula Hadamard.  La válvula Pauli-X lo traducirá del estado | 0 &amp; gt a | 1 &amp; gt, y la válvula Hadamard lo traducirá a una superposición con iguales probabilidades | 0 &amp; gt y | 1 &amp; gt.  Por lo tanto, si completamos la secuencia completa 1000 veces y medimos el primer qubit 1000 veces al final de este ciclo, entonces, en promedio, podemos esperar que en 500 casos tendrá un valor de 0 y en 500 casos tendrá un valor de 1. <br><br>  El segundo qubit es aún más simple.  Comenzamos con la puerta de identidad, que no cambia el comportamiento del qubit, y luego la pasamos a la puerta Pauli-X, cambiando su valor de 0 a 1. <br><br><img src="https://habrastorage.org/webt/wk/5t/ok/wk5tokshympqnwkvw8bj6ia6jys.png"><br><br>  <i>Fig.</i>  <i>7. Un ejemplo de un algoritmo cuántico que se puede simular usando Strange.</i> <br><br>  Para asegurarse de que nuestro razonamiento sea correcto, puede crear un programa cuántico simple usando Strange. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>); Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s); Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t); SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits(); Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure())); }</code> </pre> <br>  En esta aplicación, se crea un programa cuántico con dos qubits: <br><br><pre> <code class="java hljs"> Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Como parte de este programa, pasamos por dos etapas.  En el primer paso, aplique la válvula Pauli-X a q [0].  No aplicamos la válvula a q [1], lo que implica que funcionará con la válvula de identidad.  Agregue este paso al programa: <br><br><pre> <code class="java hljs"> Step s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); s.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">0</span></span>)); p.addStep(s);</code> </pre> <br>  Luego pasamos a la segunda etapa, donde aplicamos la válvula Hadamard a q [0] y la válvula Pauli-X a q [1];  agregue este paso al programa: <br><br><pre> <code class="java hljs"> Step t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Step(); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Hadamard(<span class="hljs-number"><span class="hljs-number">0</span></span>)); t.addGate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(<span class="hljs-number"><span class="hljs-number">1</span></span>)); p.addStep(t);</code> </pre> <br>  Entonces, nuestro programa está listo.  Ahora hagámoslo.  Un extraño simulador está integrado en Strange, sin embargo, Strange también puede usar un servicio en la nube para ejecutar programas en algún tipo de nube, por ejemplo, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Oracle Cloud</a> . <br><br>  En el siguiente ejemplo, usamos un simulador integrado simple, ejecutamos el programa y obtenemos los qubits resultantes: <br><br><pre> <code class="java hljs"> SimpleQuantumExecutionEnvironment sqee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleQuantumExecutionEnvironment(); Result res = sqee.runProgram(p); Qubit[] qubits = res.getQubits();</code> </pre> <br>  Antes de medir los qubits (y perder toda la información), mostramos las probabilidades.  Ahora mida los qubits y mire los valores: <br><br><pre> <code class="java hljs">Arrays.asList(qubits).forEach(q -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"qubit with probability on 1 = "</span></span>+q.getProbability()+<span class="hljs-string"><span class="hljs-string">", measured it gives "</span></span>+ q.measure()));</code> </pre> <br>  Al ejecutar esta aplicación, obtenemos el siguiente resultado: <br><br> <code>qubit with probability on 1 = 0.50, measured it gives 1 <br> qubit with probability on 1 = 1, measured it gives 1</code> <br>  Tenga en cuenta: para el primer qubit, el valor 0 también se puede medir, como esperábamos. <br>  Si ejecuta este programa muchas veces, el valor del primer qubit en promedio será 0 en la mitad de los casos y 1 en la mitad de los casos. <br><br><h4>  ¿Es eso todo lo que necesitas saber sobre computación cuántica? </h4><br>  Por supuesto que no.  Aquí no tocamos una serie de conceptos importantes, en particular, no discutimos las <i>complejidades</i> que aseguran la interacción entre dos qubits, incluso si físicamente están muy lejos el uno del otro.  No hablamos sobre los algoritmos cuánticos más famosos, entre ellos el algoritmo Shore, que permite descomponer enteros en factores primos.  También ignoramos una serie de hechos matemáticos y físicos, en particular, no tomamos en cuenta que en la superposición | x&gt; = a | 0&gt; + b | 1&gt;, ambos números, a y b, pueden ser complejos. <br><br>  Sin embargo, el objetivo principal de este artículo era darle la impresión de la computación cuántica y comprender cómo encajan en el futuro del desarrollo de software. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450480/">https://habr.com/ru/post/450480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450468/index.html">Hacer juegos no es difícil. Mirando hacia atrás en un pequeño proyecto móvil en Unity3D</a></li>
<li><a href="../450472/index.html">¿Cómo hacer una hoja de ruta perfecta?</a></li>
<li><a href="../450474/index.html">Introducción a Python</a></li>
<li><a href="../450476/index.html">Cómo registramos una empresa en la UE</a></li>
<li><a href="../450478/index.html">Hoy, muchos complementos populares para Firefox han dejado de funcionar debido a problemas con los certificados.</a></li>
<li><a href="../450484/index.html">Rendimiento de animación del sitio web</a></li>
<li><a href="../450486/index.html">9. Check Point Getting Started R80.20. Control de aplicaciones y filtrado de URL</a></li>
<li><a href="../450488/index.html">Aplicación para Android Chock Norris Facts en Kotlin</a></li>
<li><a href="../450490/index.html">Acuerdo de $ 6.9 mil millones: ¿por qué un desarrollador de GPU compra un fabricante de equipos de red?</a></li>
<li><a href="../450492/index.html">Trabajo social y diseño abierto. Introduccion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>