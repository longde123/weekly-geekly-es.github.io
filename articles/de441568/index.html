<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 ☝🏼 🕦 Python-Speicherverwaltung 🧛 👉🏻 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, wie die Daten, mit denen Sie arbeiten, im Darm von Python aussehen? Wie werden Variablen erstellt und im Speicher gespe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Speicherverwaltung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  Haben Sie sich jemals gefragt, wie die Daten, mit denen Sie arbeiten, im Darm von Python aussehen?  Wie werden Variablen erstellt und im Speicher gespeichert?  Wie und wann werden sie entfernt?  Das Material, dessen Übersetzung wir veröffentlichen, widmet sich der Erforschung der Tiefen von Python. Während dieser Zeit werden wir versuchen, die Merkmale der Speicherverwaltung in dieser Sprache herauszufinden.  Nachdem Sie diesen Artikel gelesen haben, werden Sie verstehen, wie die Mechanismen von Computern auf niedriger Ebene funktionieren, insbesondere diejenigen, die sich auf den Speicher beziehen.  Sie werden verstehen, wie Python Operationen auf niedriger Ebene abstrahiert und wie es den Speicher verwaltet. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Wenn Sie wissen, was in Python passiert, können Sie das Verhalten dieser Sprache besser verstehen.  Ich hoffe, dies gibt Ihnen die Gelegenheit, die enorme Arbeit zu schätzen, die bei der Implementierung der von Ihnen verwendeten Sprache geleistet wird, damit Ihre Programme genau so funktionieren, wie Sie es benötigen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Die Erinnerung ist ein leeres Buch</font> </h2><br>  Der Computerspeicher kann zu Beginn seiner Arbeit in Form eines leeren Buches für Kurzgeschichten dargestellt werden.  Es gibt zwar nichts auf seinen Seiten, aber bald werden Autoren von Geschichten erscheinen, von denen jeder seine eigene Geschichte in dieses Buch schreiben möchte. <br><br>  Da eine Geschichte nicht übereinander geschrieben werden kann, müssen die Autoren darauf achten, auf welchen Seiten des Buches sie schreiben.  Bevor sie etwas schreiben, konsultieren sie den Chefredakteur.  Er entscheidet, wo genau die Autoren Geschichten aufnehmen können. <br><br>  Da es das Buch, über das wir sprechen, schon seit einiger Zeit gibt, sind viele der darin enthaltenen Geschichten bereits veraltet.  Wenn niemand eine Geschichte liest oder in seinen Werken erwähnt, wird diese Geschichte aus dem Buch entfernt, um Platz für neue Geschichten zu schaffen. <br><br>  Im Allgemeinen können wir sagen, dass der Computerspeicher einem solchen Buch sehr ähnlich ist.  In der Tat werden fortlaufende Speicherblöcke mit fester Länge sogar als Seiten bezeichnet. Daher glauben wir, dass der Vergleich des Speichers mit einem Buch sehr erfolgreich ist. <br><br>  Autoren, die ihre Geschichten in ein Buch schreiben, sind verschiedene Anwendungen oder Prozesse, die Daten im Speicher speichern müssen.  Der Chefredakteur, der entscheidet, auf welchen Seiten des Buches die Autoren schreiben können, ist der Mechanismus, der sich mit der Speicherverwaltung befasst.  Und derjenige, der alte Geschichten aus dem Buch entfernt und Platz für neue schafft, kann mit dem Müllsammelmechanismus verglichen werden. <br><br><h2>  <font color="#3AC1EF">Speicherverwaltung: Der Weg vom Eisen zum Programm</font> </h2><br>  Die Speicherverwaltung ist ein Prozess, bei dessen Implementierung Programme Daten in den Speicher schreiben und daraus lesen.  Ein Speichermanager ist eine Entität, die bestimmt, wo genau eine Anwendung ihre Daten im Speicher ablegen kann.  Da die Anzahl der Speicherfragmente, die Anwendungen zugewiesen werden können, nicht unendlich ist, muss der Speichermanager, der Anwendungen bedient, freie Speicherfragmente finden und für Anwendungen bereitstellen, ebenso wie die Anzahl der Seiten in einem Buch nicht unendlich ist.  Dieser Vorgang, bei dem der Speicher Anwendungen zugewiesen wird, wird als Speicherzuweisung bezeichnet. <br><br>  Wenn andererseits einige Daten nicht mehr benötigt werden, können sie gelöscht werden oder mit anderen Worten den Speicher freigeben, den sie belegen.  Aber was genau „isolieren“ und „befreien“ sie, wenn sie von Erinnerung sprechen? <br><br>  Irgendwo auf Ihrem Computer befindet sich ein physisches Gerät, auf dem Daten gespeichert werden, die von Python-Programmen während der Arbeit verwendet werden.  Bevor ein Python-Objekt im physischen Speicher angezeigt wird, muss der Code viele Abstraktionsebenen durchlaufen. <br><br>  Eine der wichtigsten dieser Schichten, die sich auf der Hardware befindet (z. B. RAM oder Festplatte), ist das Betriebssystem.  Es führt Anforderungen zum Lesen von Daten aus dem Speicher und zum Schreiben von Daten in den Speicher aus (oder weigert sich, diese zu erfüllen). <br><br>  Über dem Betriebssystem befindet sich eine Anwendung, in unserem Fall eine der Python-Implementierungen (es kann sich um ein Softwarepaket handeln, das Teil Ihres Betriebssystems ist oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">python.org</a> heruntergeladen wurde).  Es ist dieses Softwarepaket, das sich mit der Speicherverwaltung befasst und den Betrieb Ihres Python-Codes sicherstellt.  Der Schwerpunkt dieses Artikels liegt auf den Algorithmen und Datenstrukturen, mit denen Python den Speicher verwaltet. <br><br><h2>  <font color="#3AC1EF">Python-Referenzimplementierung</font> </h2><br>  Die Referenz-Python-Implementierung heißt CPython.  Es ist in C geschrieben. Als ich zum ersten Mal davon hörte, hat es mich buchstäblich verunsichert.  Eine Programmiersprache, die in einer anderen Sprache geschrieben ist?  Nun, eigentlich ist das nicht ganz richtig. <br><br>  Die Python-Spezifikation wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Dokument</a> in einfachem Englisch beschrieben.  Diese Spezifikation allein, in Python geschriebener Code, kann natürlich nicht ausgeführt werden.  Dazu benötigen Sie etwas, das gemäß den Regeln dieser Spezifikation in Python geschriebenen Code interpretieren kann. <br><br>  Außerdem benötigen Sie etwas, das den interpretierten Code auf dem Computer ausführen kann.  Die Referenz-Python-Implementierung löst diese beiden Aufgaben.  Es konvertiert den Code in Anweisungen, die dann auf der virtuellen Maschine ausgeführt werden. <br><br>  Virtuelle Maschinen ähneln gewöhnlichen Computern aus Silizium, Metall und anderen Materialien, sind jedoch in Software implementiert.  Sie sind normalerweise damit beschäftigt, grundlegende Anweisungen zu verarbeiten, ähnlich den in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler</a> geschriebenen Anweisungen. <br><br>  Python ist eine interpretierte Sprache.  Der in Python geschriebene Code wird in einer Reihe von Anweisungen kompiliert, die für den Computer bequem zu verwenden sind, und zwar im sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytecode</a> .  Diese Anweisungen werden von der virtuellen Maschine interpretiert, wenn Sie Ihr Programm ausführen. <br><br>  Haben Sie jemals Dateien mit der Erweiterung <code>.pyc</code> oder dem Ordner <code>__pycache__</code> ?  Sie enthalten denselben Bytecode, der von der virtuellen Maschine interpretiert wird. <br><br>  Es ist wichtig zu beachten, dass es neben CPython noch andere Python-Implementierungen gibt.  Wenn Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IronPython verwenden, wird</a> Python-Code in eine Microsoft CLR-Anweisung kompiliert.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jython wird</a> Code in Java-Bytecode kompiliert und in einer virtuellen Java-Maschine ausgeführt.  In der Python-Welt gibt es so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPy</a> , aber es verdient einen separaten Artikel, deshalb erwähnen wir es hier nur. <br><br>  In diesem Artikel werde ich mich darauf konzentrieren, wie Speicherverwaltungsmechanismen in der Python-Referenzimplementierung CPython funktionieren. <br><br>  Es sollte beachtet werden, dass, obwohl das meiste, worüber wir hier sprechen werden, für neue Versionen von Python zutreffen wird, sich die Dinge in Zukunft ändern können.  Beachten Sie daher, dass ich mich in diesem Artikel auf die neueste Version von Python zum Zeitpunkt des Schreibens konzentriere - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3.7</a> . <br><br>  Das CPython-Softwarepaket ist also in C geschrieben und interpretiert Python-Bytecode.  Was hat das mit Speicherverwaltung zu tun?  Tatsache ist, dass die für die Speicherverwaltung verwendeten Algorithmen und Datenstrukturen im CPython-Code vorhanden sind, der, wie bereits erwähnt, in C geschrieben wurde. Um zu verstehen, wie die Speicherverwaltung in Python funktioniert, müssen Sie zunächst ein wenig über CPython verstehen. <br><br>  Die C-Sprache, in der CPython geschrieben ist, unterstützt keine objektorientierte Programmierung.  Aus diesem Grund werden im CPython-Code viele interessante Architekturlösungen verwendet. <br><br>  Sie haben vielleicht gehört, dass alles in Python ein Objekt ist, auch primitive Datentypen wie <code>int</code> und <code>str</code> .  Dies ist in der Tat auf der Ebene der Sprachimplementierung in CPython der Fall.  Es gibt eine Struktur namens <code>PyObject</code> , die von in CPython erstellten Objekten verwendet wird. <br><br>  Eine Struktur ist ein zusammengesetzter Datentyp, der Daten verschiedener Typen gruppieren kann.  Wenn Sie dies mit objektorientierter Programmierung vergleichen, ähnelt die Struktur einer Klasse, die Attribute, aber keine Methoden aufweist. <br><br>  <code>PyObject</code> ist der Vorfahr aller Python-Objekte.  Diese Struktur enthält nur zwei Felder: <br><br><ul><li>  <code>ob_refcnt</code> - Referenzzähler. </li><li>  <code>ob_type</code> - Zeiger auf einen anderen Typ. </li></ul><br>  Der Referenzzähler wird verwendet, um den Speicherbereinigungsmechanismus zu implementieren.  Ein weiteres <code>PyObject</code> Feld ist ein Zeiger auf einen bestimmten Objekttyp.  Dieser Typ wird durch eine andere Struktur dargestellt, die das Python-Objekt beschreibt (z. B. kann es sich um einen <code>dict</code> oder einen <code>int</code> ). <br><br>  Jedes Objekt verfügt über einen eigenen, für ein solches Objekt eindeutigen Speicherzuweisungsmechanismus, der weiß, wie der zum Speichern dieses Objekts erforderliche Speicher abgerufen wird.  Darüber hinaus verfügt jedes Objekt über einen eigenen Mechanismus zum Freigeben von Speicher, der den Speicher "freigibt", nachdem er nicht mehr benötigt wird. <br><br>  Es ist jedoch zu beachten, dass bei all diesen Gesprächen über die Zuweisung und Freigabe von Speicher ein wichtiger Faktor vorhanden ist.  Tatsache ist, dass der Computerspeicher eine gemeinsam genutzte Ressource ist.  Wenn gleichzeitig zwei verschiedene Prozesse versuchen, etwas in denselben Speicherbereich zu schreiben, kann etwas Schlimmes passieren. <br><br><h2>  <font color="#3AC1EF">Interpreter Global Lock</font> </h2><br>  Global Interpreter Lock (GIL) ist eine Lösung für ein häufiges Problem, das beim Arbeiten mit gemeinsam genutzten Computerressourcen wie Speicher auftritt.  Wenn zwei Threads gleichzeitig versuchen, dieselbe Ressource zu ändern, können sie miteinander "kollidieren".  Das Ergebnis wird ein Chaos sein und keiner der Streams wird das erreichen, wonach er strebte. <br><br>  Kehren wir noch einmal zur Buchanalogie zurück.  Stellen Sie sich vor, zwei Autoren hätten willkürlich entschieden, dass sie nun an der Reihe sind, sich Notizen zu machen.  Sie beschlossen aber auch, gleichzeitig Notizen auf derselben Seite zu machen. <br><br>  Jeder von ihnen achtet nicht darauf, dass der andere versucht, seine Geschichte zu schreiben.  Zusammen beginnen sie, Text auf die Seite zu schreiben.  Infolgedessen werden dort zwei Geschichten übereinander aufgezeichnet, wodurch die Seite vollständig unlesbar wird. <br><br>  Eine der Lösungen für dieses Problem ist ein einzelner globaler Interpreter-Mechanismus, der gemeinsam genutzte Ressourcen blockiert, mit denen ein bestimmter Thread arbeitet.  In unserem Beispiel ist dies ein „Mechanismus“, der die Seite eines Buches „blockiert“.  Ein solcher Mechanismus beseitigt die oben beschriebene Situation, in der zwei Autoren gleichzeitig Text auf dieselbe Seite schreiben. <br><br>  Der GIL-Mechanismus in Python erreicht dies, indem er den gesamten Interpreter blockiert.  Infolgedessen kann nichts den Betrieb des aktuellen Threads stören.  Wenn CPython mit Speicher arbeitet, verwendet es die GIL, um sicherzustellen, dass diese Arbeit sicher und effizient ausgeführt wird. <br><br>  Dieser Ansatz hat Stärken und Schwächen, und die GIL ist Gegenstand heftiger Debatten in der Python-Community.  Um mehr über GIL zu erfahren, können Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Material</a> ansehen. <br><br><h2>  <font color="#3AC1EF">Müllabfuhr</font> </h2><br>  Kehren wir zur Buchanalogie zurück und stellen uns vor, dass einige der in diesem Buch aufgezeichneten Geschichten hoffnungslos veraltet sind.  Niemand liest sie, niemand erwähnt sie irgendwo.  Und wenn niemand Material in seinen Werken liest oder darauf verweist, kann dieses Material entsorgt werden, um Platz für neue Texte zu schaffen. <br><br>  Diese alten, vergessenen Geschichten können mit Python-Objekten verglichen werden, deren Referenzanzahl Null ist.  Dies sind die gleichen Zähler, über die wir bei der Erörterung der <code>PyObject</code> Struktur gesprochen haben. <br><br>  Der Verbindungszähler wird aus mehreren Gründen erhöht.  Beispielsweise wird der Zähler inkrementiert, wenn das in einer Variablen gespeicherte Objekt in eine andere Variable geschrieben wird: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Sie erhöht sich, wenn das Objekt als Argument an eine Funktion übergeben wird: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Und hier ist ein weiteres Beispiel für eine Situation, in der die Zahl im Referenzzähler zunimmt.  Dies geschieht, wenn das Objekt in der Liste enthalten ist: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Mit Python kann der Programmierer mithilfe des <code>sys</code> Moduls den aktuellen Wert des Referenzzählers eines bestimmten Objekts ermitteln.  Hierzu wird folgende Konstruktion verwendet: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> es verwenden, müssen Sie <code>getfefcount()</code> dass das Übergeben eines Objekts an die Methode <code>getfefcount()</code> den <code>getfefcount()</code> um 1 erhöht. <br><br>  In jedem Fall ist der Referenzzähler größer als 0, wenn das Objekt noch irgendwo im Code verwendet wird. Wenn der Zählerwert auf 0 fällt, kommt eine spezielle Funktion ins Spiel, die den vom Objekt belegten Speicher "freigibt".  Dieser Speicher kann dann von anderen Objekten verwendet werden. <br><br>  Wir stellen uns nun Fragen darüber, was „Speicher freigeben“ ist und wie andere Objekte diesen Speicher nutzen können.  Um diese Fragen zu beantworten, sprechen wir über Speicherverwaltungsmechanismen in CPython. <br><br><h2>  <font color="#3AC1EF">Speicherverwaltungsmechanismen in CPython</font> </h2><br>  Jetzt werden wir darüber sprechen, wie CPython eine Speicherarchitektur hat und wie die Speicherverwaltung dort erfolgt. <br><br>  Wie bereits erwähnt, gibt es mehrere Abstraktionsebenen zwischen CPython und physischem Speicher.  Das Betriebssystem abstrahiert den physischen Speicher und erstellt eine virtuelle Speicherschicht, mit der Anwendungen arbeiten können (dies gilt auch für Python). <br><br>  Der virtuelle Speichermanager eines bestimmten Betriebssystems weist dem Python-Prozess einen Speicherplatz zu.  Die dunkelgrauen Bereiche im folgenden Bild sind die Speicherelemente, die zum Python-Prozess gehören. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Von CPython verwendete Speicherbereiche</font></i> <br><br>  Python verwendet eine bestimmte Menge an Speicher für den internen Gebrauch und für Anforderungen, die nicht mit der Zuweisung von Speicher für Objekte zusammenhängen.  Ein weiterer Speicher wird zum Speichern von Objekten verwendet (dies sind Werte vom Typ <code>int</code> , <code>dict</code> und ähnliche).  Bitte beachten Sie, dass dies ein vereinfachtes Diagramm ist.  Wenn Sie das vollständige Bild sehen möchten, schauen Sie sich den Quellcode von <a href="">CPython an</a> , in dem alles passiert, worüber wir sprechen. <br><br>  CPython verfügt über eine Funktion zum Zuweisen von Speicher für Objekte, die für das Zuweisen von Speicher in dem Bereich verantwortlich ist, in dem Objekte gespeichert werden sollen.  Das Interessanteste passiert, wenn dieser Mechanismus funktioniert.  Es wird aufgerufen, wenn das Objekt Speicher benötigt oder wenn Speicher freigegeben werden muss. <br><br>  Das Hinzufügen oder Löschen von Daten zu Python-Objekten wie <code>list</code> und <code>int</code> normalerweise nicht die gleichzeitige Verarbeitung sehr großer Informationsmengen.  Daher ist die Architektur des Speicherzuweisungswerkzeugs mit Blick auf die Verarbeitung kleiner Datenmengen aufgebaut.  Darüber hinaus versucht dieses Tool, keinen Speicher zuzuweisen, bis klar wird, dass dies unbedingt erforderlich ist. <br><br>  Die Kommentare im <a href="">Quellcode</a> beschreiben das Speicherzuweisungstool als "schnelles, spezialisiertes Speicherzuweisungstool für kleine Blöcke, das für die Verwendung auf dem universellen Malloc entwickelt wurde".  In diesem Fall ist <code>malloc</code> eine C-Bibliotheksfunktion zum Zuweisen von Speicher. <br><br>  Lassen Sie uns die von CPython verwendete Speicherzuweisungsstrategie diskutieren.  Zunächst werden wir über drei Entitäten sprechen - die sogenannten Blöcke (Blöcke), Pools (Pools) und Arenen (Arena) und wie sie miteinander in Beziehung stehen. <br><br>  Arenen sind die größten Erinnerungsfragmente.  Sie sind an den Rändern der Speicherseiten ausgerichtet.  An der Seitengrenze endet der fortlaufende Block des Speichers mit fester Länge, der vom Betriebssystem verwendet wird.  Python geht bei der Arbeit mit dem Speicher davon aus, dass die Größe der Systemspeicherseite 256 KB beträgt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenen, Pools und Blöcke</font></i> <br><br>  Pools befinden sich in den Arenen, bei denen es sich um 4 KB virtuelle Speicherseiten handelt.  Sie ähneln den Seiten des Buches aus unserem Beispiel.  Pools sind in kleine Speicherblöcke unterteilt. <br><br>  Alle Blöcke im selben Pool gehören zur gleichen Größenklasse.  Die Größenklasse, zu der der Block gehört, bestimmt die Größe dieses Blocks, der unter Berücksichtigung der angeforderten Speichergröße ausgewählt wird.  Hier ist eine Tabelle aus dem Quellcode, die die Datenmenge zeigt, die das System zum Speichern im Speicher anfordert, die Größe der zugewiesenen Blöcke und die Bezeichner der Größenklassen. <br><table><tbody><tr><td>  Die Datenmenge in Bytes <br></td><td>  Blockgröße <br></td><td>  IDX-Klassengröße <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Wenn beispielsweise 42 Bytes zum Speichern angefordert werden, werden Daten in einen 48-Byte-Block gestellt. <br><br><h2>  <font color="#3AC1EF">Pools</font> </h2><br>  Pools bestehen aus Blöcken derselben Größenklasse.  Jeder Pool wird mithilfe des doppelt verknüpften Listenmechanismus anderen Pools zugeordnet, die Blöcke derselben Größenklasse enthalten.  Mit diesem Ansatz kann der Speicherzuweisungsalgorithmus leicht freien Speicherplatz für einen Block einer bestimmten Größe finden, selbst wenn es darum geht, freien Speicherplatz in verschiedenen Pools zu finden. <br><br>  Mit der Liste der verwendeten Pools können Sie alle Pools verfolgen, in denen Platz für Daten einer bestimmten Größenklasse ist.  Wenn ein Block einer bestimmten Größe gespeichert werden soll, überprüft der Algorithmus diese Liste auf eine Liste von Pools, in denen Blöcke der erforderlichen Größe gespeichert sind. <br><br>  Die Pools selbst müssen sich in einem von drei Zuständen befinden.  Sie können nämlich verwendet werden (Status <code>used</code> ), sie können gefüllt ( <code>full</code> ) oder leer ( <code>empty</code> ) sein.  Der verwendete Pool verfügt über freie Blöcke, in denen Daten einer geeigneten Größe gespeichert werden können.  Alle Blöcke des gefüllten Pools werden für Daten zugeordnet.  Ein leerer Pool enthält keine Daten und kann bei Bedarf zum Speichern von Blöcken einer beliebigen Größenklasse zugewiesen werden. <br><br>  In der Liste der <code>freepools</code> Pools werden Informationen zu allen Pools <code>freepools</code> , die sich im <code>empty</code> Zustand befinden.  Wenn beispielsweise in der Liste der verwendeten Pools keine Einträge zu Pools vorhanden sind, in <code>usedpools</code> 8-Byte-Blöcke gespeichert sind (Klasse mit IDX 0), wird ein neuer Pool initialisiert, der sich im <code>empty</code> Zustand befindet und zum Speichern solcher Blöcke ausgelegt ist.  Dieser neue Pool wird zur Liste der verwendeten Pools hinzugefügt. Er kann verwendet werden, um Anforderungen zum Speichern von Daten zu erfüllen, die nach seiner Erstellung empfangen wurden. <br><br>  Angenommen, in einem Pool, der sich im <code>full</code> Zustand befindet, werden einige Blöcke freigegeben.  Dies liegt daran, dass die darin gespeicherten Daten nicht mehr benötigt werden.  Dieser Pool befindet sich wieder in der Liste der verwendeten <code>usedpools</code> und kann für Daten der entsprechenden Größenklasse verwendet werden. <br><br>  Die Kenntnis dieses Algorithmus ermöglicht es uns zu verstehen, wie sich der Status von Pools während des Betriebs ändert (und wie sich Größenklassen ändern, zu denen Blöcke gehören, die in ihnen gespeichert werden können). <br><br><h2>  <font color="#3AC1EF">Blöcke</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Gebrauchte, volle und leere Pools</font></i> <br><br>  Wie Sie der vorherigen Abbildung entnehmen können, enthalten Pools Zeiger auf die darin enthaltenen "freien" Speicherblöcke.  In Bezug auf die Arbeit mit Blöcken sollte ein kleines Merkmal beachtet werden, das im Quellcode angegeben ist.  Das in CPython verwendete Speicherverwaltungssystem auf allen Ebenen (Arenen, Pools, Blöcke) ist bestrebt, Speicher nur dann zuzuweisen, wenn dies unbedingt erforderlich ist. <br><br>  Dies bedeutet, dass Pools Blöcke enthalten können, die sich in einem von drei Zuständen befinden: <br><br><ul><li>  <code>untouched</code> ist der Teil des Speichers, der noch nicht zugewiesen wurde. </li><li>  <code>free</code> - der Teil des Speichers, der bereits zugewiesen wurde, aber später von CPython "frei" gemacht wurde und keine wertvollen Daten mehr enthält. </li><li>  <code>allocated</code> ist der Teil des Speichers, der wertvolle Daten enthält. </li></ul><br>  Der <code>freeblock</code> Zeiger zeigt auf eine einfach verknüpfte Liste von Free-Memory-Blöcken.  Mit anderen Worten, dies ist eine Liste von Orten, an denen Sie Daten ablegen können.  Wenn mehr als ein freier Block zum Platzieren von Daten benötigt wird, nimmt das Speicherzuweisungstool mehrere Blöcke aus dem Pool, die sich im <code>untouched</code> Zustand befinden. <br><br>  Wenn das Speicherverwaltungstool die Blöcke "frei" macht, gelangen sie, wenn sie den <code>free</code> Zustand erhalten, an die Spitze der Liste der <code>free</code> <code>freeblock</code> .  Die in dieser Liste enthaltenen Blöcke stellen nicht notwendigerweise einen zusammenhängenden Speicherbereich dar, der dem in der vorherigen Abbildung gezeigten ähnlich ist.  Sie können tatsächlich wie die folgende aussehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Einzelne verknüpfte Freeblock-Liste</font></i> <br><br><h2>  <font color="#3AC1EF">Arenen</font> </h2><br>  Arenen enthalten Pools.  Diese Pools können sich, wie bereits erwähnt, im <code>used</code> , <code>full</code> oder <code>empty</code> Zustand befinden.  Es sollte beachtet werden, dass Arenen keine ähnlichen Zustände haben wie Pools. <br><br>  Arenen sind in einer doppelt verknüpften Liste mit dem Namen <code>usable_arenas</code> .  Diese Liste ist nach der Anzahl der verfügbaren freien Pools sortiert.  Je weniger freie Pools in der Arena vorhanden sind, desto näher steht die Arena an der Spitze der Liste. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Usable_arenas Liste</font></i> <br><br>  Dies bedeutet, dass die Arena, die stärker ist als andere, die mit Daten gefüllt sind, ausgewählt wird, um neue Daten darin zu platzieren.  Und warum nicht umgekehrt?  Warum nicht neue Daten in der Arena mit dem meisten freien Speicherplatz veröffentlichen? <br><br>  Tatsächlich führt uns diese Funktion zu der Idee, Speicher wirklich freizugeben.  Möglicherweise haben Sie bemerkt, dass wir hier häufig das Konzept der „Speicherfreigabe“ verwendet haben, das in Anführungszeichen gesetzt ist.  Der Grund, warum dies getan wurde, ist, dass, obwohl der Block als "frei" betrachtet werden kann, der Speicher, den er darstellt, nicht tatsächlich an das Betriebssystem zurückgegeben wird.  Der Python-Prozess enthält diesen Speicher und verwendet ihn später zum Speichern neuer Daten.  Die wahre Freigabe des Speichers ist die Rückgabe des Betriebssystems, das davon profitieren kann. <br><br>  Arenen sind die einzige Einheit in dem hier betrachteten Schema, deren Gedächtnis wirklich freigesetzt werden kann.  Der gesunde Menschenverstand schreibt vor, dass das oben beschriebene Schema der Arbeit mit Arenen darauf abzielt, dass die fast leeren Arenen vollständig leer werden.  Mit diesem Ansatz kann der Speicherplatz, der durch eine vollständig leere Arena dargestellt wird, wirklich freigegeben werden, wodurch der von Python verbrauchte Speicherplatz reduziert wird. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Folgendes haben Sie beim Lesen dieses Materials gelernt: <br><br><ul><li>  Was ist Speicherverwaltung und warum ist sie wichtig? </li><li>  Wie die in der Programmiersprache C geschriebene Referenzimplementierung von Python, Cpython, angeordnet ist. </li><li>  Welche Datenstrukturen und Algorithmen werden in CPython für die Speicherverwaltung verwendet? </li></ul><br>  Die Speicherverwaltung ist ein wesentlicher Bestandteil der Arbeit von Computerprogrammen.  Python löst fast alle Speicherverwaltungsaufgaben, die vom Programmierer nicht bemerkt werden.  Mit Python kann jeder, der in dieser Sprache schreibt, die vielen kleinen Details im Zusammenhang mit der Arbeit mit Computern ignorieren.  Dies gibt dem Programmierer die Möglichkeit, auf einer höheren Ebene zu arbeiten und seinen eigenen Code zu erstellen, ohne sich Gedanken darüber zu machen, wo seine Daten gespeichert sind. <br><br>  <b>Liebe Leser!</b>  Wenn Sie Erfahrung mit der Python-Entwicklung haben, teilen Sie uns bitte mit, wie Sie die Speichernutzung in Ihren Programmen angehen.  Versuchen Sie zum Beispiel, es zu speichern? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441568/">https://habr.com/ru/post/de441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441550/index.html">Das Leben eines einfachen Programmierers ist hart und klar</a></li>
<li><a href="../de441554/index.html">Die ganze Geschichte von Linux. Teil I: Wie alles begann</a></li>
<li><a href="../de441560/index.html">Digitale Veranstaltungen in Moskau vom 25. Februar bis 3. März</a></li>
<li><a href="../de441562/index.html">Pixel Gallop - Teil 5 - Charakteranimation. Gehen</a></li>
<li><a href="../de441566/index.html">12 Wissenswertes zu JavaScript-Konzepten</a></li>
<li><a href="../de441570/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 353 (17. - 24. Februar 2019)</a></li>
<li><a href="../de441572/index.html">Frontend Weekly Digest (18. - 24. Februar 2019)</a></li>
<li><a href="../de441574/index.html">Docker lernen Teil 6: Arbeiten mit Daten</a></li>
<li><a href="../de441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../de441578/index.html">React Tutorial Teil 19: Methoden des Komponentenlebenszyklus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>