<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ ‚òùüèº üï¶ Python-Speicherverwaltung üßõ üëâüèª üóΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, wie die Daten, mit denen Sie arbeiten, im Darm von Python aussehen? Wie werden Variablen erstellt und im Speicher gespe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Speicherverwaltung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  Haben Sie sich jemals gefragt, wie die Daten, mit denen Sie arbeiten, im Darm von Python aussehen?  Wie werden Variablen erstellt und im Speicher gespeichert?  Wie und wann werden sie entfernt?  Das Material, dessen √úbersetzung wir ver√∂ffentlichen, widmet sich der Erforschung der Tiefen von Python. W√§hrend dieser Zeit werden wir versuchen, die Merkmale der Speicherverwaltung in dieser Sprache herauszufinden.  Nachdem Sie diesen Artikel gelesen haben, werden Sie verstehen, wie die Mechanismen von Computern auf niedriger Ebene funktionieren, insbesondere diejenigen, die sich auf den Speicher beziehen.  Sie werden verstehen, wie Python Operationen auf niedriger Ebene abstrahiert und wie es den Speicher verwaltet. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Wenn Sie wissen, was in Python passiert, k√∂nnen Sie das Verhalten dieser Sprache besser verstehen.  Ich hoffe, dies gibt Ihnen die Gelegenheit, die enorme Arbeit zu sch√§tzen, die bei der Implementierung der von Ihnen verwendeten Sprache geleistet wird, damit Ihre Programme genau so funktionieren, wie Sie es ben√∂tigen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Die Erinnerung ist ein leeres Buch</font> </h2><br>  Der Computerspeicher kann zu Beginn seiner Arbeit in Form eines leeren Buches f√ºr Kurzgeschichten dargestellt werden.  Es gibt zwar nichts auf seinen Seiten, aber bald werden Autoren von Geschichten erscheinen, von denen jeder seine eigene Geschichte in dieses Buch schreiben m√∂chte. <br><br>  Da eine Geschichte nicht √ºbereinander geschrieben werden kann, m√ºssen die Autoren darauf achten, auf welchen Seiten des Buches sie schreiben.  Bevor sie etwas schreiben, konsultieren sie den Chefredakteur.  Er entscheidet, wo genau die Autoren Geschichten aufnehmen k√∂nnen. <br><br>  Da es das Buch, √ºber das wir sprechen, schon seit einiger Zeit gibt, sind viele der darin enthaltenen Geschichten bereits veraltet.  Wenn niemand eine Geschichte liest oder in seinen Werken erw√§hnt, wird diese Geschichte aus dem Buch entfernt, um Platz f√ºr neue Geschichten zu schaffen. <br><br>  Im Allgemeinen k√∂nnen wir sagen, dass der Computerspeicher einem solchen Buch sehr √§hnlich ist.  In der Tat werden fortlaufende Speicherbl√∂cke mit fester L√§nge sogar als Seiten bezeichnet. Daher glauben wir, dass der Vergleich des Speichers mit einem Buch sehr erfolgreich ist. <br><br>  Autoren, die ihre Geschichten in ein Buch schreiben, sind verschiedene Anwendungen oder Prozesse, die Daten im Speicher speichern m√ºssen.  Der Chefredakteur, der entscheidet, auf welchen Seiten des Buches die Autoren schreiben k√∂nnen, ist der Mechanismus, der sich mit der Speicherverwaltung befasst.  Und derjenige, der alte Geschichten aus dem Buch entfernt und Platz f√ºr neue schafft, kann mit dem M√ºllsammelmechanismus verglichen werden. <br><br><h2>  <font color="#3AC1EF">Speicherverwaltung: Der Weg vom Eisen zum Programm</font> </h2><br>  Die Speicherverwaltung ist ein Prozess, bei dessen Implementierung Programme Daten in den Speicher schreiben und daraus lesen.  Ein Speichermanager ist eine Entit√§t, die bestimmt, wo genau eine Anwendung ihre Daten im Speicher ablegen kann.  Da die Anzahl der Speicherfragmente, die Anwendungen zugewiesen werden k√∂nnen, nicht unendlich ist, muss der Speichermanager, der Anwendungen bedient, freie Speicherfragmente finden und f√ºr Anwendungen bereitstellen, ebenso wie die Anzahl der Seiten in einem Buch nicht unendlich ist.  Dieser Vorgang, bei dem der Speicher Anwendungen zugewiesen wird, wird als Speicherzuweisung bezeichnet. <br><br>  Wenn andererseits einige Daten nicht mehr ben√∂tigt werden, k√∂nnen sie gel√∂scht werden oder mit anderen Worten den Speicher freigeben, den sie belegen.  Aber was genau ‚Äûisolieren‚Äú und ‚Äûbefreien‚Äú sie, wenn sie von Erinnerung sprechen? <br><br>  Irgendwo auf Ihrem Computer befindet sich ein physisches Ger√§t, auf dem Daten gespeichert werden, die von Python-Programmen w√§hrend der Arbeit verwendet werden.  Bevor ein Python-Objekt im physischen Speicher angezeigt wird, muss der Code viele Abstraktionsebenen durchlaufen. <br><br>  Eine der wichtigsten dieser Schichten, die sich auf der Hardware befindet (z. B. RAM oder Festplatte), ist das Betriebssystem.  Es f√ºhrt Anforderungen zum Lesen von Daten aus dem Speicher und zum Schreiben von Daten in den Speicher aus (oder weigert sich, diese zu erf√ºllen). <br><br>  √úber dem Betriebssystem befindet sich eine Anwendung, in unserem Fall eine der Python-Implementierungen (es kann sich um ein Softwarepaket handeln, das Teil Ihres Betriebssystems ist oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">python.org</a> heruntergeladen wurde).  Es ist dieses Softwarepaket, das sich mit der Speicherverwaltung befasst und den Betrieb Ihres Python-Codes sicherstellt.  Der Schwerpunkt dieses Artikels liegt auf den Algorithmen und Datenstrukturen, mit denen Python den Speicher verwaltet. <br><br><h2>  <font color="#3AC1EF">Python-Referenzimplementierung</font> </h2><br>  Die Referenz-Python-Implementierung hei√üt CPython.  Es ist in C geschrieben. Als ich zum ersten Mal davon h√∂rte, hat es mich buchst√§blich verunsichert.  Eine Programmiersprache, die in einer anderen Sprache geschrieben ist?  Nun, eigentlich ist das nicht ganz richtig. <br><br>  Die Python-Spezifikation wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Dokument</a> in einfachem Englisch beschrieben.  Diese Spezifikation allein, in Python geschriebener Code, kann nat√ºrlich nicht ausgef√ºhrt werden.  Dazu ben√∂tigen Sie etwas, das gem√§√ü den Regeln dieser Spezifikation in Python geschriebenen Code interpretieren kann. <br><br>  Au√üerdem ben√∂tigen Sie etwas, das den interpretierten Code auf dem Computer ausf√ºhren kann.  Die Referenz-Python-Implementierung l√∂st diese beiden Aufgaben.  Es konvertiert den Code in Anweisungen, die dann auf der virtuellen Maschine ausgef√ºhrt werden. <br><br>  Virtuelle Maschinen √§hneln gew√∂hnlichen Computern aus Silizium, Metall und anderen Materialien, sind jedoch in Software implementiert.  Sie sind normalerweise damit besch√§ftigt, grundlegende Anweisungen zu verarbeiten, √§hnlich den in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler</a> geschriebenen Anweisungen. <br><br>  Python ist eine interpretierte Sprache.  Der in Python geschriebene Code wird in einer Reihe von Anweisungen kompiliert, die f√ºr den Computer bequem zu verwenden sind, und zwar im sogenannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytecode</a> .  Diese Anweisungen werden von der virtuellen Maschine interpretiert, wenn Sie Ihr Programm ausf√ºhren. <br><br>  Haben Sie jemals Dateien mit der Erweiterung <code>.pyc</code> oder dem Ordner <code>__pycache__</code> ?  Sie enthalten denselben Bytecode, der von der virtuellen Maschine interpretiert wird. <br><br>  Es ist wichtig zu beachten, dass es neben CPython noch andere Python-Implementierungen gibt.  Wenn Sie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IronPython verwenden, wird</a> Python-Code in eine Microsoft CLR-Anweisung kompiliert.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jython wird</a> Code in Java-Bytecode kompiliert und in einer virtuellen Java-Maschine ausgef√ºhrt.  In der Python-Welt gibt es so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPy</a> , aber es verdient einen separaten Artikel, deshalb erw√§hnen wir es hier nur. <br><br>  In diesem Artikel werde ich mich darauf konzentrieren, wie Speicherverwaltungsmechanismen in der Python-Referenzimplementierung CPython funktionieren. <br><br>  Es sollte beachtet werden, dass, obwohl das meiste, wor√ºber wir hier sprechen werden, f√ºr neue Versionen von Python zutreffen wird, sich die Dinge in Zukunft √§ndern k√∂nnen.  Beachten Sie daher, dass ich mich in diesem Artikel auf die neueste Version von Python zum Zeitpunkt des Schreibens konzentriere - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3.7</a> . <br><br>  Das CPython-Softwarepaket ist also in C geschrieben und interpretiert Python-Bytecode.  Was hat das mit Speicherverwaltung zu tun?  Tatsache ist, dass die f√ºr die Speicherverwaltung verwendeten Algorithmen und Datenstrukturen im CPython-Code vorhanden sind, der, wie bereits erw√§hnt, in C geschrieben wurde. Um zu verstehen, wie die Speicherverwaltung in Python funktioniert, m√ºssen Sie zun√§chst ein wenig √ºber CPython verstehen. <br><br>  Die C-Sprache, in der CPython geschrieben ist, unterst√ºtzt keine objektorientierte Programmierung.  Aus diesem Grund werden im CPython-Code viele interessante Architekturl√∂sungen verwendet. <br><br>  Sie haben vielleicht geh√∂rt, dass alles in Python ein Objekt ist, auch primitive Datentypen wie <code>int</code> und <code>str</code> .  Dies ist in der Tat auf der Ebene der Sprachimplementierung in CPython der Fall.  Es gibt eine Struktur namens <code>PyObject</code> , die von in CPython erstellten Objekten verwendet wird. <br><br>  Eine Struktur ist ein zusammengesetzter Datentyp, der Daten verschiedener Typen gruppieren kann.  Wenn Sie dies mit objektorientierter Programmierung vergleichen, √§hnelt die Struktur einer Klasse, die Attribute, aber keine Methoden aufweist. <br><br>  <code>PyObject</code> ist der Vorfahr aller Python-Objekte.  Diese Struktur enth√§lt nur zwei Felder: <br><br><ul><li>  <code>ob_refcnt</code> - Referenzz√§hler. </li><li>  <code>ob_type</code> - Zeiger auf einen anderen Typ. </li></ul><br>  Der Referenzz√§hler wird verwendet, um den Speicherbereinigungsmechanismus zu implementieren.  Ein weiteres <code>PyObject</code> Feld ist ein Zeiger auf einen bestimmten Objekttyp.  Dieser Typ wird durch eine andere Struktur dargestellt, die das Python-Objekt beschreibt (z. B. kann es sich um einen <code>dict</code> oder einen <code>int</code> ). <br><br>  Jedes Objekt verf√ºgt √ºber einen eigenen, f√ºr ein solches Objekt eindeutigen Speicherzuweisungsmechanismus, der wei√ü, wie der zum Speichern dieses Objekts erforderliche Speicher abgerufen wird.  Dar√ºber hinaus verf√ºgt jedes Objekt √ºber einen eigenen Mechanismus zum Freigeben von Speicher, der den Speicher "freigibt", nachdem er nicht mehr ben√∂tigt wird. <br><br>  Es ist jedoch zu beachten, dass bei all diesen Gespr√§chen √ºber die Zuweisung und Freigabe von Speicher ein wichtiger Faktor vorhanden ist.  Tatsache ist, dass der Computerspeicher eine gemeinsam genutzte Ressource ist.  Wenn gleichzeitig zwei verschiedene Prozesse versuchen, etwas in denselben Speicherbereich zu schreiben, kann etwas Schlimmes passieren. <br><br><h2>  <font color="#3AC1EF">Interpreter Global Lock</font> </h2><br>  Global Interpreter Lock (GIL) ist eine L√∂sung f√ºr ein h√§ufiges Problem, das beim Arbeiten mit gemeinsam genutzten Computerressourcen wie Speicher auftritt.  Wenn zwei Threads gleichzeitig versuchen, dieselbe Ressource zu √§ndern, k√∂nnen sie miteinander "kollidieren".  Das Ergebnis wird ein Chaos sein und keiner der Streams wird das erreichen, wonach er strebte. <br><br>  Kehren wir noch einmal zur Buchanalogie zur√ºck.  Stellen Sie sich vor, zwei Autoren h√§tten willk√ºrlich entschieden, dass sie nun an der Reihe sind, sich Notizen zu machen.  Sie beschlossen aber auch, gleichzeitig Notizen auf derselben Seite zu machen. <br><br>  Jeder von ihnen achtet nicht darauf, dass der andere versucht, seine Geschichte zu schreiben.  Zusammen beginnen sie, Text auf die Seite zu schreiben.  Infolgedessen werden dort zwei Geschichten √ºbereinander aufgezeichnet, wodurch die Seite vollst√§ndig unlesbar wird. <br><br>  Eine der L√∂sungen f√ºr dieses Problem ist ein einzelner globaler Interpreter-Mechanismus, der gemeinsam genutzte Ressourcen blockiert, mit denen ein bestimmter Thread arbeitet.  In unserem Beispiel ist dies ein ‚ÄûMechanismus‚Äú, der die Seite eines Buches ‚Äûblockiert‚Äú.  Ein solcher Mechanismus beseitigt die oben beschriebene Situation, in der zwei Autoren gleichzeitig Text auf dieselbe Seite schreiben. <br><br>  Der GIL-Mechanismus in Python erreicht dies, indem er den gesamten Interpreter blockiert.  Infolgedessen kann nichts den Betrieb des aktuellen Threads st√∂ren.  Wenn CPython mit Speicher arbeitet, verwendet es die GIL, um sicherzustellen, dass diese Arbeit sicher und effizient ausgef√ºhrt wird. <br><br>  Dieser Ansatz hat St√§rken und Schw√§chen, und die GIL ist Gegenstand heftiger Debatten in der Python-Community.  Um mehr √ºber GIL zu erfahren, k√∂nnen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Material</a> ansehen. <br><br><h2>  <font color="#3AC1EF">M√ºllabfuhr</font> </h2><br>  Kehren wir zur Buchanalogie zur√ºck und stellen uns vor, dass einige der in diesem Buch aufgezeichneten Geschichten hoffnungslos veraltet sind.  Niemand liest sie, niemand erw√§hnt sie irgendwo.  Und wenn niemand Material in seinen Werken liest oder darauf verweist, kann dieses Material entsorgt werden, um Platz f√ºr neue Texte zu schaffen. <br><br>  Diese alten, vergessenen Geschichten k√∂nnen mit Python-Objekten verglichen werden, deren Referenzanzahl Null ist.  Dies sind die gleichen Z√§hler, √ºber die wir bei der Er√∂rterung der <code>PyObject</code> Struktur gesprochen haben. <br><br>  Der Verbindungsz√§hler wird aus mehreren Gr√ºnden erh√∂ht.  Beispielsweise wird der Z√§hler inkrementiert, wenn das in einer Variablen gespeicherte Objekt in eine andere Variable geschrieben wird: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Sie erh√∂ht sich, wenn das Objekt als Argument an eine Funktion √ºbergeben wird: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Und hier ist ein weiteres Beispiel f√ºr eine Situation, in der die Zahl im Referenzz√§hler zunimmt.  Dies geschieht, wenn das Objekt in der Liste enthalten ist: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Mit Python kann der Programmierer mithilfe des <code>sys</code> Moduls den aktuellen Wert des Referenzz√§hlers eines bestimmten Objekts ermitteln.  Hierzu wird folgende Konstruktion verwendet: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> es verwenden, m√ºssen Sie <code>getfefcount()</code> dass das √úbergeben eines Objekts an die Methode <code>getfefcount()</code> den <code>getfefcount()</code> um 1 erh√∂ht. <br><br>  In jedem Fall ist der Referenzz√§hler gr√∂√üer als 0, wenn das Objekt noch irgendwo im Code verwendet wird. Wenn der Z√§hlerwert auf 0 f√§llt, kommt eine spezielle Funktion ins Spiel, die den vom Objekt belegten Speicher "freigibt".  Dieser Speicher kann dann von anderen Objekten verwendet werden. <br><br>  Wir stellen uns nun Fragen dar√ºber, was ‚ÄûSpeicher freigeben‚Äú ist und wie andere Objekte diesen Speicher nutzen k√∂nnen.  Um diese Fragen zu beantworten, sprechen wir √ºber Speicherverwaltungsmechanismen in CPython. <br><br><h2>  <font color="#3AC1EF">Speicherverwaltungsmechanismen in CPython</font> </h2><br>  Jetzt werden wir dar√ºber sprechen, wie CPython eine Speicherarchitektur hat und wie die Speicherverwaltung dort erfolgt. <br><br>  Wie bereits erw√§hnt, gibt es mehrere Abstraktionsebenen zwischen CPython und physischem Speicher.  Das Betriebssystem abstrahiert den physischen Speicher und erstellt eine virtuelle Speicherschicht, mit der Anwendungen arbeiten k√∂nnen (dies gilt auch f√ºr Python). <br><br>  Der virtuelle Speichermanager eines bestimmten Betriebssystems weist dem Python-Prozess einen Speicherplatz zu.  Die dunkelgrauen Bereiche im folgenden Bild sind die Speicherelemente, die zum Python-Prozess geh√∂ren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Von CPython verwendete Speicherbereiche</font></i> <br><br>  Python verwendet eine bestimmte Menge an Speicher f√ºr den internen Gebrauch und f√ºr Anforderungen, die nicht mit der Zuweisung von Speicher f√ºr Objekte zusammenh√§ngen.  Ein weiterer Speicher wird zum Speichern von Objekten verwendet (dies sind Werte vom Typ <code>int</code> , <code>dict</code> und √§hnliche).  Bitte beachten Sie, dass dies ein vereinfachtes Diagramm ist.  Wenn Sie das vollst√§ndige Bild sehen m√∂chten, schauen Sie sich den Quellcode von <a href="">CPython an</a> , in dem alles passiert, wor√ºber wir sprechen. <br><br>  CPython verf√ºgt √ºber eine Funktion zum Zuweisen von Speicher f√ºr Objekte, die f√ºr das Zuweisen von Speicher in dem Bereich verantwortlich ist, in dem Objekte gespeichert werden sollen.  Das Interessanteste passiert, wenn dieser Mechanismus funktioniert.  Es wird aufgerufen, wenn das Objekt Speicher ben√∂tigt oder wenn Speicher freigegeben werden muss. <br><br>  Das Hinzuf√ºgen oder L√∂schen von Daten zu Python-Objekten wie <code>list</code> und <code>int</code> normalerweise nicht die gleichzeitige Verarbeitung sehr gro√üer Informationsmengen.  Daher ist die Architektur des Speicherzuweisungswerkzeugs mit Blick auf die Verarbeitung kleiner Datenmengen aufgebaut.  Dar√ºber hinaus versucht dieses Tool, keinen Speicher zuzuweisen, bis klar wird, dass dies unbedingt erforderlich ist. <br><br>  Die Kommentare im <a href="">Quellcode</a> beschreiben das Speicherzuweisungstool als "schnelles, spezialisiertes Speicherzuweisungstool f√ºr kleine Bl√∂cke, das f√ºr die Verwendung auf dem universellen Malloc entwickelt wurde".  In diesem Fall ist <code>malloc</code> eine C-Bibliotheksfunktion zum Zuweisen von Speicher. <br><br>  Lassen Sie uns die von CPython verwendete Speicherzuweisungsstrategie diskutieren.  Zun√§chst werden wir √ºber drei Entit√§ten sprechen - die sogenannten Bl√∂cke (Bl√∂cke), Pools (Pools) und Arenen (Arena) und wie sie miteinander in Beziehung stehen. <br><br>  Arenen sind die gr√∂√üten Erinnerungsfragmente.  Sie sind an den R√§ndern der Speicherseiten ausgerichtet.  An der Seitengrenze endet der fortlaufende Block des Speichers mit fester L√§nge, der vom Betriebssystem verwendet wird.  Python geht bei der Arbeit mit dem Speicher davon aus, dass die Gr√∂√üe der Systemspeicherseite 256 KB betr√§gt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenen, Pools und Bl√∂cke</font></i> <br><br>  Pools befinden sich in den Arenen, bei denen es sich um 4 KB virtuelle Speicherseiten handelt.  Sie √§hneln den Seiten des Buches aus unserem Beispiel.  Pools sind in kleine Speicherbl√∂cke unterteilt. <br><br>  Alle Bl√∂cke im selben Pool geh√∂ren zur gleichen Gr√∂√üenklasse.  Die Gr√∂√üenklasse, zu der der Block geh√∂rt, bestimmt die Gr√∂√üe dieses Blocks, der unter Ber√ºcksichtigung der angeforderten Speichergr√∂√üe ausgew√§hlt wird.  Hier ist eine Tabelle aus dem Quellcode, die die Datenmenge zeigt, die das System zum Speichern im Speicher anfordert, die Gr√∂√üe der zugewiesenen Bl√∂cke und die Bezeichner der Gr√∂√üenklassen. <br><table><tbody><tr><td>  Die Datenmenge in Bytes <br></td><td>  Blockgr√∂√üe <br></td><td>  IDX-Klassengr√∂√üe <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Wenn beispielsweise 42 Bytes zum Speichern angefordert werden, werden Daten in einen 48-Byte-Block gestellt. <br><br><h2>  <font color="#3AC1EF">Pools</font> </h2><br>  Pools bestehen aus Bl√∂cken derselben Gr√∂√üenklasse.  Jeder Pool wird mithilfe des doppelt verkn√ºpften Listenmechanismus anderen Pools zugeordnet, die Bl√∂cke derselben Gr√∂√üenklasse enthalten.  Mit diesem Ansatz kann der Speicherzuweisungsalgorithmus leicht freien Speicherplatz f√ºr einen Block einer bestimmten Gr√∂√üe finden, selbst wenn es darum geht, freien Speicherplatz in verschiedenen Pools zu finden. <br><br>  Mit der Liste der verwendeten Pools k√∂nnen Sie alle Pools verfolgen, in denen Platz f√ºr Daten einer bestimmten Gr√∂√üenklasse ist.  Wenn ein Block einer bestimmten Gr√∂√üe gespeichert werden soll, √ºberpr√ºft der Algorithmus diese Liste auf eine Liste von Pools, in denen Bl√∂cke der erforderlichen Gr√∂√üe gespeichert sind. <br><br>  Die Pools selbst m√ºssen sich in einem von drei Zust√§nden befinden.  Sie k√∂nnen n√§mlich verwendet werden (Status <code>used</code> ), sie k√∂nnen gef√ºllt ( <code>full</code> ) oder leer ( <code>empty</code> ) sein.  Der verwendete Pool verf√ºgt √ºber freie Bl√∂cke, in denen Daten einer geeigneten Gr√∂√üe gespeichert werden k√∂nnen.  Alle Bl√∂cke des gef√ºllten Pools werden f√ºr Daten zugeordnet.  Ein leerer Pool enth√§lt keine Daten und kann bei Bedarf zum Speichern von Bl√∂cken einer beliebigen Gr√∂√üenklasse zugewiesen werden. <br><br>  In der Liste der <code>freepools</code> Pools werden Informationen zu allen Pools <code>freepools</code> , die sich im <code>empty</code> Zustand befinden.  Wenn beispielsweise in der Liste der verwendeten Pools keine Eintr√§ge zu Pools vorhanden sind, in <code>usedpools</code> 8-Byte-Bl√∂cke gespeichert sind (Klasse mit IDX 0), wird ein neuer Pool initialisiert, der sich im <code>empty</code> Zustand befindet und zum Speichern solcher Bl√∂cke ausgelegt ist.  Dieser neue Pool wird zur Liste der verwendeten Pools hinzugef√ºgt. Er kann verwendet werden, um Anforderungen zum Speichern von Daten zu erf√ºllen, die nach seiner Erstellung empfangen wurden. <br><br>  Angenommen, in einem Pool, der sich im <code>full</code> Zustand befindet, werden einige Bl√∂cke freigegeben.  Dies liegt daran, dass die darin gespeicherten Daten nicht mehr ben√∂tigt werden.  Dieser Pool befindet sich wieder in der Liste der verwendeten <code>usedpools</code> und kann f√ºr Daten der entsprechenden Gr√∂√üenklasse verwendet werden. <br><br>  Die Kenntnis dieses Algorithmus erm√∂glicht es uns zu verstehen, wie sich der Status von Pools w√§hrend des Betriebs √§ndert (und wie sich Gr√∂√üenklassen √§ndern, zu denen Bl√∂cke geh√∂ren, die in ihnen gespeichert werden k√∂nnen). <br><br><h2>  <font color="#3AC1EF">Bl√∂cke</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Gebrauchte, volle und leere Pools</font></i> <br><br>  Wie Sie der vorherigen Abbildung entnehmen k√∂nnen, enthalten Pools Zeiger auf die darin enthaltenen "freien" Speicherbl√∂cke.  In Bezug auf die Arbeit mit Bl√∂cken sollte ein kleines Merkmal beachtet werden, das im Quellcode angegeben ist.  Das in CPython verwendete Speicherverwaltungssystem auf allen Ebenen (Arenen, Pools, Bl√∂cke) ist bestrebt, Speicher nur dann zuzuweisen, wenn dies unbedingt erforderlich ist. <br><br>  Dies bedeutet, dass Pools Bl√∂cke enthalten k√∂nnen, die sich in einem von drei Zust√§nden befinden: <br><br><ul><li>  <code>untouched</code> ist der Teil des Speichers, der noch nicht zugewiesen wurde. </li><li>  <code>free</code> - der Teil des Speichers, der bereits zugewiesen wurde, aber sp√§ter von CPython "frei" gemacht wurde und keine wertvollen Daten mehr enth√§lt. </li><li>  <code>allocated</code> ist der Teil des Speichers, der wertvolle Daten enth√§lt. </li></ul><br>  Der <code>freeblock</code> Zeiger zeigt auf eine einfach verkn√ºpfte Liste von Free-Memory-Bl√∂cken.  Mit anderen Worten, dies ist eine Liste von Orten, an denen Sie Daten ablegen k√∂nnen.  Wenn mehr als ein freier Block zum Platzieren von Daten ben√∂tigt wird, nimmt das Speicherzuweisungstool mehrere Bl√∂cke aus dem Pool, die sich im <code>untouched</code> Zustand befinden. <br><br>  Wenn das Speicherverwaltungstool die Bl√∂cke "frei" macht, gelangen sie, wenn sie den <code>free</code> Zustand erhalten, an die Spitze der Liste der <code>free</code> <code>freeblock</code> .  Die in dieser Liste enthaltenen Bl√∂cke stellen nicht notwendigerweise einen zusammenh√§ngenden Speicherbereich dar, der dem in der vorherigen Abbildung gezeigten √§hnlich ist.  Sie k√∂nnen tats√§chlich wie die folgende aussehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Einzelne verkn√ºpfte Freeblock-Liste</font></i> <br><br><h2>  <font color="#3AC1EF">Arenen</font> </h2><br>  Arenen enthalten Pools.  Diese Pools k√∂nnen sich, wie bereits erw√§hnt, im <code>used</code> , <code>full</code> oder <code>empty</code> Zustand befinden.  Es sollte beachtet werden, dass Arenen keine √§hnlichen Zust√§nde haben wie Pools. <br><br>  Arenen sind in einer doppelt verkn√ºpften Liste mit dem Namen <code>usable_arenas</code> .  Diese Liste ist nach der Anzahl der verf√ºgbaren freien Pools sortiert.  Je weniger freie Pools in der Arena vorhanden sind, desto n√§her steht die Arena an der Spitze der Liste. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Usable_arenas Liste</font></i> <br><br>  Dies bedeutet, dass die Arena, die st√§rker ist als andere, die mit Daten gef√ºllt sind, ausgew√§hlt wird, um neue Daten darin zu platzieren.  Und warum nicht umgekehrt?  Warum nicht neue Daten in der Arena mit dem meisten freien Speicherplatz ver√∂ffentlichen? <br><br>  Tats√§chlich f√ºhrt uns diese Funktion zu der Idee, Speicher wirklich freizugeben.  M√∂glicherweise haben Sie bemerkt, dass wir hier h√§ufig das Konzept der ‚ÄûSpeicherfreigabe‚Äú verwendet haben, das in Anf√ºhrungszeichen gesetzt ist.  Der Grund, warum dies getan wurde, ist, dass, obwohl der Block als "frei" betrachtet werden kann, der Speicher, den er darstellt, nicht tats√§chlich an das Betriebssystem zur√ºckgegeben wird.  Der Python-Prozess enth√§lt diesen Speicher und verwendet ihn sp√§ter zum Speichern neuer Daten.  Die wahre Freigabe des Speichers ist die R√ºckgabe des Betriebssystems, das davon profitieren kann. <br><br>  Arenen sind die einzige Einheit in dem hier betrachteten Schema, deren Ged√§chtnis wirklich freigesetzt werden kann.  Der gesunde Menschenverstand schreibt vor, dass das oben beschriebene Schema der Arbeit mit Arenen darauf abzielt, dass die fast leeren Arenen vollst√§ndig leer werden.  Mit diesem Ansatz kann der Speicherplatz, der durch eine vollst√§ndig leere Arena dargestellt wird, wirklich freigegeben werden, wodurch der von Python verbrauchte Speicherplatz reduziert wird. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Folgendes haben Sie beim Lesen dieses Materials gelernt: <br><br><ul><li>  Was ist Speicherverwaltung und warum ist sie wichtig? </li><li>  Wie die in der Programmiersprache C geschriebene Referenzimplementierung von Python, Cpython, angeordnet ist. </li><li>  Welche Datenstrukturen und Algorithmen werden in CPython f√ºr die Speicherverwaltung verwendet? </li></ul><br>  Die Speicherverwaltung ist ein wesentlicher Bestandteil der Arbeit von Computerprogrammen.  Python l√∂st fast alle Speicherverwaltungsaufgaben, die vom Programmierer nicht bemerkt werden.  Mit Python kann jeder, der in dieser Sprache schreibt, die vielen kleinen Details im Zusammenhang mit der Arbeit mit Computern ignorieren.  Dies gibt dem Programmierer die M√∂glichkeit, auf einer h√∂heren Ebene zu arbeiten und seinen eigenen Code zu erstellen, ohne sich Gedanken dar√ºber zu machen, wo seine Daten gespeichert sind. <br><br>  <b>Liebe Leser!</b>  Wenn Sie Erfahrung mit der Python-Entwicklung haben, teilen Sie uns bitte mit, wie Sie die Speichernutzung in Ihren Programmen angehen.  Versuchen Sie zum Beispiel, es zu speichern? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441568/">https://habr.com/ru/post/de441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441550/index.html">Das Leben eines einfachen Programmierers ist hart und klar</a></li>
<li><a href="../de441554/index.html">Die ganze Geschichte von Linux. Teil I: Wie alles begann</a></li>
<li><a href="../de441560/index.html">Digitale Veranstaltungen in Moskau vom 25. Februar bis 3. M√§rz</a></li>
<li><a href="../de441562/index.html">Pixel Gallop - Teil 5 - Charakteranimation. Gehen</a></li>
<li><a href="../de441566/index.html">12 Wissenswertes zu JavaScript-Konzepten</a></li>
<li><a href="../de441570/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 353 (17. - 24. Februar 2019)</a></li>
<li><a href="../de441572/index.html">Frontend Weekly Digest (18. - 24. Februar 2019)</a></li>
<li><a href="../de441574/index.html">Docker lernen Teil 6: Arbeiten mit Daten</a></li>
<li><a href="../de441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../de441578/index.html">React Tutorial Teil 19: Methoden des Komponentenlebenszyklus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>