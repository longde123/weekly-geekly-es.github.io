<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁳󠁣󠁴󠁿 ⛱️ ☑️ 如何破解昂贵的相机，以免太太杀了你 🚀 🃏 👨🏼‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="免责声明：这项研究始于2013年，因此，如果您认为某些方法既愚蠢又危险，那就对了。 但是，我在此过程中学到了很多东西。 

 参赛作品 
 这一切都在我第一个孩子出生前的几个月开始。 我和我的妻子一直想买一台很酷的Leica相机，突然意识到如果我们现在不买相机，那么我们很长一段时间都做不到。 因此，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何破解昂贵的相机，以免太太杀了你</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438168/"> <i>免责声明：这项研究始于2013年，因此，如果您认为某些方法既愚蠢又危险，那就对了。</i>  <i>但是，我在此过程中学到了很多东西。</i> <br><br>  <b>参赛作品</b> <br> 这一切都在我第一个孩子出生前的几个月开始。 我和我的妻子一直想买一台很酷的Leica相机，突然意识到如果我们现在不买相机，那么我们很长一段时间都做不到。 因此，我们订购了M240相机和...动臂，我们被安排了六个月的时间。 很快我就厌倦了等待，于是我开始研究他们的网站。 我的注意力立即吸引到文件部分。 好吧，您可以猜测为什么...固件！ <br><br> 我看到了一个以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PWAD magic</a>开头的未加密和未压缩的文件（ <code>m8-2_005.upd</code> ）。 你认识吗 是的，没错，这就是Doom Patch WAD格式。 男人似乎喜欢经典。 该格式已被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很好地记录下来</a> ，因此解析它并不困难。 <br><a name="habracut"></a><br><h1> 徕卡固件文件 </h1><br><h3> 固件Leica M8 </h3><br> 这实际上非常有趣，因为当我后来研究压缩的Leica T固件文件时，我首先决定测试id Software过去使用的压缩方法。 <br><br> 维基百科说，他们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LHA格式</a> ，本质上是LZW。 但是普通的LZW解压缩器不适合使用，因此我开始寻找id软件的特定实现-瞧，我在<a href="">源代码中</a>找到了<a href="">地下墓穴世界末日</a> 。 我必须承认，幸运。 <br><br> 无论如何，请回到M8。 这是固件结构： <br><br><pre> 规则：0x0000008C（3036：0x00000BDC）-XML说明
 LUTS：0x00000C68（183274：0x0002CBEA）
  GAMMA：0x0000007C（31760：0x00007C10）
 增益：0x00007C8C（50344：0x0000C4A8）
 徕卡：0x00014134（7000：0x00001B58）
  BLEMISH：0x00015C8C（250：0x000000FA）
  WREF：0x00015D88（82480：0x00014230）
  OBJ：0x00029FB8（11268：0x00002C04）
 版本：0x0002CBBC（46：0x0000002E）
 PXA：0x0002D854（858384：0x000D1910）
 BF：0x000FF164（134522：0x00020D7A）-Analog Devices Blackfin处理器系列
 GUI：0x0011FEE0（3574180：0x003689A4）
  TRANS：0x0000005C（59988：0x0000EA54）-本地化
 图像：0x0000EAB0（267433：0x000414A9）
   21_1PRT：0x000000CC（18411：0x000047EB）-JFIF的图片
   21_2GRP：0x000048B8（23172：0x00005A84）-JFIF的图片
   21_3PAN：0x0000A33C（23034：0x000059FA）-JFIF的图片
   24_1PRT：0x0000FD38（18489：0x00004839）-JFIF的图片
   24_2GRP：0x00014574（23230：0x00005ABE）-JFIF的图片
   24_3PAN：0x0001A034（22998：0x000059D6）-JFIF的图片
   28_1PRT：0x0001FA0C（22605：0x0000584D）-JFIF的图片
   28_2GRP：0x0002525C（23081：0x00005A29）-JFIF的图片
   28_3PAN：0x0002AC88（23282：0x00005AF2）-JFIF的图片
   35_1PRT：0x0003077C（22496：0x000057E0）-JFIF的图片
   35_2GRP：0x00035F5C（23532：0x00005BEC）-JFIF的图片
   35_3PAN：0x0003BB48（22881：0x00005961）-JFIF的图片
  FONT1：0x0004FF5C（1522988：0x00173D2C）
  FONT2：0x001C3C88（1723676：0x001A4D1C）
 版本：0x003689A4（0：0x00000000）
 M16C：0x00488884（130406：0x0001FD66）-瑞萨M16C系列（Motorola S记录）
 FPGA：0x004A85EC（131604：0x00020214）-Xilinx Spartan 3
 FSL：0x004C8800（814：0x0000032E）-第一阶段引导程序 </pre><br> 开箱即用的IDA不支持Blackfin处理器，但是有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三方插件</a> 。 <br><br><h3> 固件Leica M9 </h3><br>  Leica M9固件文件（ <code>m9-1_196.upd</code> ）看起来已加密：直方图显示约0.45％的分布。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac1/6fc/17d/ac16fc17df9bfb0c9c63bdefaecc83d9.png"><br><br> 故事的结局？ 也许不是。 事实是Leica在相机中使用了性能较弱的处理器，并且当时在消费类电子产品中经常使用XOR加密，因此我决定为XOR操作编写一个简单的工具，以将固件与本人进行比较并计算一些统计数据。 <br><br> 密钥长度是通过搜索最长的重复模式来确定的。 这很有意义，因为任何固件通常都包含大量重复数据块，例如0x00 / 0xFF填充或带有LUT像素的图形。 密钥本身是通过密钥长度内字节的频率来计算的，最常见的字节进入密钥缓冲区。 程序的结果清楚地表明了XOR加密。 然后，我不得不对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具进行</a>一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修改，</a>以获取潜在的密钥并解密代码。 再次证明这是一个PWAD文件。 <br><br>  PWAD的内容揭示了以下结构： <br><br><pre> 规则：0x0000007C（2788：0x00000AE4）-XML说明
 LUTS：0x00000B60（4060616：0x003DF5C8）
 过程：0x0000004C（3900572：0x003B849C）
  创建：0x0000004C（20：0x00000014）-时间戳
   LUTS：0x00000060（427744：0x000686E0）
  增益图：0x00068740（20008：0x00004E28）
  镜头：0x0006D568（3452724：0x0034AF34）
  CCD：0x003B84E8（148662：0x000244B6）
  创建：0x0000004C（20：0x00000014）-时间戳
   BLEMISH：0x00000060（1092：0x00000444）
   WREF：0x000004A4（147452：0x00023FFC）
   LIN：0x000244A0（22：0x00000016）
  ICCPROF：0x003DC9A0（4304：0x000010D0）
   ECI-RGB：0x0000003C（540：0x0000021C）
   sRGB：0x00000258（3144：0x00000C48）
   A-RGB：0x00000EA0（560：0x00000230）
  WBPARAM：0x003DDA70（7000：0x00001B58）
 BF561：0x003E0128（289128：0x00046968）-Analog Devices Blackfin处理器系列
  bf0：0x0000004C（117846：0x0001CC56）-主处理器
  bf1：0x0001CCA4（117826：0x0001CC42）-子处理器的固件
  bf0.map:0x000398E8（27072：0x000069C0）-主处理器固件卡，字符：D
  bf1.map：0x000402A8（26304：0x000066C0）-带有字符D的子处理器固件卡
身体：0x00426A90（143280：0x00022FB0）-瑞萨M16C系列（摩托罗拉S记录）
 GUI：0x00449A40（3647624：0x0037A888）
  TRANS：0x0000005C（131656：0x00020248）-本地化
 图像：0x000202A4（267433：0x000414A9）
   21_1PRT：0x000000CC（18411：0x000047EB）-JFIF的图片
   21_2GRP：0x000048B8（23172：0x00005A84）-JFIF的图片
   21_3PAN：0x0000A33C（23034：0x000059FA）-JFIF的图片
   24_1PRT：0x0000FD38（18489：0x00004839）-JFIF的图片
   24_2GRP：0x00014574（23230：0x00005ABE）-JFIF的图片
   24_3PAN：0x0001A034（22998：0x000059D6）-JFIF的图片
   28_1PRT：0x0001FA0C（22605：0x0000584D）-JFIF的图片
   28_2GRP：0x0002525C（23081：0x00005A29）-JFIF的图片
   28_3PAN：0x0002AC88（23282：0x00005AF2）-JFIF的图片
   35_1PRT：0x0003077C（22496：0x000057E0）-JFIF的图片
   35_2GRP：0x00035F5C（23532：0x00005BEC）-JFIF的图片
   35_3PAN：0x0003BB48（22881：0x00005961）-JFIF的图片
 字体1：0x00061750（1522988：0x00173D2C）
  USBLOGO：0x001D547C（1775：0x000006EF）-JFIF的图片
  FONT2：0x001D5B6C（1723676：0x001A4D1C）
 FPGA：0x007C42C8（150176：0x00024AA0）-Xilinx Spartan 3A
 BF547：0x007E8D68（937576：0x000E4E68）-Analog Devices Blackfin处理器系列（FSL？） </pre><br><br><h3> 固件Leica M240 </h3><br> 我习惯于每天早晨检查Leica固件的下载页面。 很快出现了一个新文件： <b>FW_M240_1_1_0_2.FW</b> 。 <br><br> 它看起来没有加密，但已被压缩... <br><br><h4> 压缩方式 </h4><br> 直方图显示了0x9D处的巨大爆发。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cb/025/ef7/6cb025ef734f60b1d4104b7301798cad.png"><br><br> 也许这是某种压缩魔术。 在Internet上进行的搜索[9D +压缩]没有任何结果，只是将0x1F9D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用作LZW压缩的签名</a> 。 如果有的话，我了解LZ压缩类型，并决定查看0x9D之后的字节。 我看到了四个选择： <br><br><ol><li> <code>9D 70 C4</code> <br> </li><li> <code>9D 00</code> <br> </li><li> <code>9D XX YY</code> <br> </li><li> <code>9D XX 8Y YY</code> </li> </ol><br> 您还注意到了什么： <br><br><ul><li> 第一个选项仅在地址0x30处弹出一次：它可能用作压缩数据的指示器； <br></li><li>  XX不得超过0x7F； <br></li><li> 在第三和第四种情况下，YY的最后一个字节不得超过0x7F </li></ul><br> 根据我对LZ的了解，这与LZ77或LZSS非常相似，其中YY是缩进步骤，而XX是要复制的字节数。 第二种选择是发出0x9D的特殊情况。 我编写了一个简单的C函数来实现此逻辑。 她确认我们正在朝正确的方向前进，但是第四个选择仍然不适合该计划。 <br><br> 我尝试了各种方式来解释它，但是没有任何结果。 因此，我向同志请教。 一个人注意到，根据我自己的观察，YY的第四个字节仅在设置最高位0x8Y时出现：这只是缩进步骤的额外距离。 我感到ham愧，一切都变得如此明显... <br><br> 最终，解压缩器开始发出有效流……直到它卡在文件中间。 这是由于滑动窗口的长度未知而发生的。 其他调试和测试解决了这种情况。 <br><br> 因此，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用于解析固件M240</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具</a> 。 <br><br><h4> 固件结构 </h4><br> 为了使用未知格式，我没有比测量代码段的某些偏移量和大小更好的方法了-尝试在文件头中查找最接近的值。 例如，以下代码块： <br><br> <code>0x00: 1E 1C AF 2E 01 01 00 02 07 E1 EA 5E 00 5C 1A B1 <br> 0x10: 01 29 1A 7E AE 38 73 65 9C 3D 75 B4 34 2F 44 6E <br> 0x20: 13 17 8E 6B 00 00 00 01 00 00 00 30 E1 E3 50 D1</code> <br> <br> 最终变成： <br><br> <code>1E1CAF2E —   "LEICA FILE" <br> 01010002 - 1.1.0.2 <br> 005C1AB1 —    (big endian) <br> 01291A7E —    (big endian) <br> AE3873659C3D75B4342F446E13178E6B —  MD5 <br> 00000001 —    <br> 00000030 —    </code> <br> <br> 当我了解固件的结构时，我改进了工具，最后产生了以下结果： <br><br> <code>Running with options: <br> + firmware folder: M240_FIRMWARE <br> + verbose enabled <br> <br> Open firmware file: FW_M240_1_1_0_2.FW <br> File size: 6036193 | 0x005C1AE1 <br> <br> Parse container header: <br> version: 1.1.0.2 <br> packed size: 6036145 | 0x005C1AB1 <br> unpacked size: 19470974 | 0x01291A7E <br> body blocks: 1 | 0x00000001 <br> body offset: 48 | 0x00000030 <br> MD5: AE387365 9C3D75B4 342F446E 13178E6B <br> MD5 check: PASSED <br> <br> Uncompress container body: <br> 6036145 -&gt; 19470974 <br> Uncompression: DONE <br> <br> Split container: <br> Number of sections: 9 | 0x00000009 <br> Section table size: 612 | 0x00000264 <br> Section table offset: 36 | 0x00000024 <br> Section 1 <br> Section Name: "[A]IMG_LOKI-212" <br> Section offset: 0 | 0x00000000 <br> Section size: 7340032 | 0x00700000 <br> Section base: 1048576 | 0x00100000 <br> MD5: A8D55AA2 B0ACDB14 0673AD79 707674F3 <br> MD5 check: PASSED <br> Create file: M240_FIRMWARE/IMG_LOKI-212.bin <br> <br> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ <br> <br> Section 9 <br> Section Name: "[A]IMG-LENSDATA-213" <br> Section offset: 19214844 | 0x012531FC <br> Section size: 255478 | 0x0003E5F6 <br> Section base: 16252928 | 0x00F80000 <br> MD5: 39C2BEC0 27ED23F6 2C1C8513 EEE697B9 <br> MD5 check: PASSED <br> Create file: M240_FIRMWARE/IMG-LENSDATA-213.bin <br> Splitting container: DONE <br> Extraction COMPLETE!</code> <br> <br>  M240固件包含一个包含九个元素的容器： <br><br> <code>IMG_LOKI-212.bin -    <br> IMG_LOKI-213.bin -    <br> CTRL_SYS-11.bin -   - <br> IMG-FPGA-212.bin -     () <br> IMG-FPGA-213.bin -     () <br> IMG-DSP-212.bin -  DSP <br> IMG-DSP-213.bin -  DSP <br> IMG-LENSDATA-212.bin -    <br> IMG-LENSDATA-213.bin -   </code> <br> <br> 如您所见，在一个固件中有两组文件。 后来我得知212是图像处理微电路的一个版本，并且有两个版本的Leica M240投入生产。 这项研究基于版本212。 <br><br><h1> 系统管理：CTRL_SYS-11.bin </h1><br> 唯一常见的部分是系统控制芯片的固件。 这是一个非常大的二进制文件，代码可以轻松猜出它的用途。 <br><br> <code>$ strings CTRL_SYS-11.bin | rg SH <br> -&gt; Test SH7216 data flash driver <br> -&gt; Test SH7216 SCI driver <br> -&gt; Test SH7216 I2C driver <br> -&gt; Test SH7216 MTU2 driver <br> -&gt; Test SH7216 ADC functions <br> -&gt; Test SH7216 CMT driver</code> <br> <br> 因此，我们拥有瑞萨的SH7216处理器（SH-2A），它负责加载的早期阶段，I / O测试和固件更新。 开箱即用的IDA支持这种类型的处理器。 只剩下找到正确的基本加载地址，这可以从固件部分的描述中得知：这是<code>0x0</code> 。 <br><br> <code>Section Name: "[A]CTRL_SYS-11" <br> Section offset: 14680064 | 0x00E00000 <br> Section size: 917277 | 0x000DFF1D <br> Section base: 0 | 0x00000000</code> <br> <br> 我将其加载到IDA中并识别了所有功能，但我并没有特别对其进行研究，因为主处理器的固件更加有趣。 <br><br> 在此还应注意，该芯片的UART通向服务端口，并在其中显示下载日志。 我们待会儿会再谈这个。 <br><br><h1> 主芯片：IMG_LOKI-212.bin </h1><br> 要开始对该固件进行反向工程，您必须首先回答以下几个问题： <br><br><ol><li> 什么类型的处理器 <br></li><li> 什么是基本加载地址 <br></li><li> 它基于什么操作系统（如果有） </li></ol><br> 借助我们的工具，我们已经知道基本负载的地址：这是<code>0x100000</code> 。 <br><br> <code>Section Name: "[A]IMG_LOKI-212" <br> Section offset: 0 | 0x00000000 <br> Section size: 7340032 | 0x00700000 <br> Section base: 1048576 | 0x00100000</code> <br> <br> 固件以可读形式存储其余答案。 例如，这一行： <br><br> <code>$ strings ./IMG_LOKI-212.bin | rg Softune <br> 6Softune REALOS/FR is Realtime OS for FR Family, based on micro-ITRON COPYRIGHT(C) FUJITSU LIMITED 1994-1999 <br> ...</code> <br> <br> 因此，我们正在处理定制处理器<b>Fujitsu FR</b> （徕卡称之为<b>Maestro</b> ）和操作系统<b>Softune REALOS</b> 。 实际上，这比Blackfin好得多，因为开箱即用的IDA支持FR。 <br><br><h2>  FR处理器模块 </h2><br> 现实情况并非如此，因为下载固件文件后，IDA程序未显示任何指令，外部链接等。 <br><br> 我决定修复它，但最后我不得不<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完全重写固件的某些部分</a> 。 结果如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/728/c76/9f3728c769d29aa02e2f405c08d8bb9a.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/2ea/81d/a082ea81d9056b07935398a19d4df294.png"><br><br> 除了对<code>ana</code> ， <code>ins</code>和<code>out</code>进行更正<code>out</code> ，全新的<code>emu</code>代码还可以： <br><br><ul><li> 识别各种类型的代码和数据的外部链接； <br></li><li> 识别开关语句 <br></li><li> 执行堆栈跟踪； <br></li><li> 单独的堆栈参数和局部变量 <br></li><li> 正确识别功能。 </li></ul><br> 但是，正如您所注意到的，最大的变化是说明的大写字母:) <br><br> 想查看全套说明吗？ 这是： <br><br><pre>  LSR MOV BN LDRES EXTSH   
 ADD2 ORH MUL LSR2 JMP BP STRES EXTUH   
 ADDC ORB MULU ASR CALL BV COPOP SRCH0   
 ADDN EOR MULH ASR2 RET BNV COPLD SRCH1   
 ADDN2 EORH MULUH LDI INT BLT COPST SRCHC   
 SUB EORB DIV0S LDI集成BGE COPSV LDM0    
 SUBC BANDL DIV0U LDI便携式NOP LDM1    
 SUBN BANDH DIV1 LD BRA BGT ANDCCR STM0    
 CMP BORL DIV2 LDUH BNO BLS ORCCR STM1    
 CMP2 BORH DIV3 LDUB BEQ BHI STILM ENTER   
 AND BEORL DIV4S ST BNE DMOV ADDSP离开   
 ANDH BEORH LSL STH BC DMOVH EXTSB XCHB    
 ANDB BTSTL LSL2 STB BNC DMOVB EXTUB </pre><br> 因此，简单而美丽。 <br><br> 顺便说一句，您可能已经注意到某些说明不统一： <br><br><pre> 胸罩：D loc_xxx
     LDI：8＃0x64，R5 </pre><br> 这不是处理器模块中的错误，但实际上是Fujitsu FR系列的功能。 它被称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟时隙</a> ，对于RISC处理器而言非常典型。 <br><br> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FR80处理器手册</a> （请注意：该链接不再起作用）： <br><br><blockquote> 紧接在分支指令之后的指令（其位置称为“延迟槽”）在分支之前执行，而目标地址处的指令在分支之后执行。 由于延迟时隙中的指令是在分支操作之前执行的，因此表观执行速度为1个周期。 </blockquote><br> 因此，从本质上讲，这是对流水线的优化，最好记住它，因为Leica固件中到处都使用它。 <br><br><h2> 软件REALOS </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从维基</a> ： <br><br><blockquote>  Softune是富士通针对富士通FR，FR-V和F2MC处理器系列的集成开发环境。 由REALOS µITRON实时内核提供支持。 例如，它可用于尼康DSLR相机（请参阅尼康EXPEED）和某些带有K的宾得相机。 </blockquote><br> 所以这是一个非常流行的体面的RTOS，带有任务，信号量和其他功能。 我想知道是否可以识别Leica固件中的某些标准库功能。 <br><br> 我必须把研究的第一部分称为浪费大量时间，这就是原因。 <br><br> 事实证明，很难找到Softune IDE，但最终我设法得到了一些东西。 正如预期的那样，IDE包含了库。 有四个二进制文件： <br><br><ul><li>  lib911.lib <br></li><li>  lib911e.lib <br></li><li>  lib911if.lib <br></li><li>  lib911p.lib </li></ul><br> 我不知道为什么，也许是出于惯性，当我破解与徕卡有关的所有内容时，我又开始了对该格式的逆向工程。 是的，有充分记录的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象模块格式</a> 。 是的，当然，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为此编写了一个特殊的工具</a> ： <br><br> <code>Fujitsu RISC Library Tool v1.0 <br> Usage: FRLibTool [-s start] [-i imagebase] [-o output] [-f index] [-dv] FIRMWARE.BIN LIBRARY.LIB <br> <br> This tool will help you to find Softune REALOS library functions in FR (Fujitsu RISC) firmware. <br> Use following arguments: <br> -f Specify firmware image file <br> -s Specify firmware image scan offset <br> -b Specify firmware imagebase <br> -o Specify output type (exclusively) <br> list - list of functions <br> idc - IDC script <br> py - IDA python script <br> pat - FLAIR pattern file <br> -i xxx Specify index of particular function <br> -d Dump library <br> -v Be verbose</code> <br> <br> 使用它，您可以创建<code>*.pat</code>文件，并将其用作<b>IDA FLAIR中的</b>输入以生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">签名文件</a> 。 <br><br> <code>$ FRLibTool -o pat lib911.lib <br> $ FRLibTool -o pat lib911e.lib <br> $ FRLibTool -o pat lib911if.lib <br> $ FRLibTool -o pat lib911p.lib <br> ... <br> $ sigmake -n "SOFTUNE C/C++ Library" lib911.pat lib911e.pat lib911if.pat lib911p.pat softune.sig</code> <br> <br> 应用此签名后，我终于在<b>IMG_LOKI-212.idb中</b>愉快地看到了对应<b>关系</b> 。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/189/618/145/189618145ab302edfff51fa222ed89b3.png"><br><br><h4> 布局图 </h4><br> 固件中的行数立即引起关注。 许多功能因其功能而被命名。 这在逆向工程过程中了解常规模式非常有用。 <br><br> 同样重要的是要注意，固件文件的某些部分已在重置处理程序中复制到其他地址。 例如，运行时内置的加载器在RAM中的位置更高。 <br><br> 我不得不手动创建其他部分，因此，我得到了以下布局： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70f/d9d/ca3/70fd9dca36e610c7dea2e1c2fd29090c.png"><br><br><h4> 打断 </h4><br> 中断向量表可以通过访问TBR（表基址寄存器）找到： <br><br> <code>LDI:32 #int_table, R0 <br> MOV R0, TBR</code> <br> <br> 通常，它发生在固件最开始的向量复位处理程序中。 <br><br> 表中处理程序的地址根据公式<code>TBR + (0x3FC - 4 × inum)</code>以相反的顺序存储，因此表末尾的复位向量偏移量为<code>0x3FC</code> 。 <br><br> 我从FR手册中发现了大部分干扰，并建议Leica Maestro具有类似的布局。 然后，他带走了每个处理程序，并试图找到一个字符串或任何其他揭示中断目的的提示。 <br><br> 结果，我列出了以下列表： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd7/eb8/c29/bd7eb8c291d5368d44576466400cb34b.png"><br><br> 预计会有许多中断，例如AUDIO / SDIO / VIDEO / JPEG / RAW，但尝试找出其中最神秘的中断吗？ 我说的是打断<code>int_uart_in</code> 。 相机似乎支持某种控制台模式UART CLI。 <br><br><h4> 系统调用 </h4><br> 与几乎所有操作系统一样，Softline REALOS也使用系统调用。 在汇编器中，它们如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/a92/9e3/22fa929e311af81f43be57bf0bbbbc74.png"><br><br> 系统调用处理程序的实际地址计算如下。 让我们开始寻找<code>INT #0x40</code>中断处理程序。 如上所述，这 <br><br> <code>(0x3FC - 4 × inum) = (0x3FC - 4 × 0x40) = 0x2FC = int_realos_syscall</code> <br> <br> 在处理程序中，很容易找到带有16位字的系统调用表底部的链接。 此表中的特定记录由公式<code>syscall_table_bottom + (num * 2)</code> ： <br><br> <code>[syscall_table_bottom + (-23 * 2)] = [syscall_table_bottom - 0x2E] = [0x1012EA] = 0xE68</code> <br> <br> 这看起来不像一个地址，因为系统调用处理程序的实际地址计算为<code>syscall_table_bottom + offset</code> 。 整个过程如图所示。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5a/240/2bb/c5a2402bb00a171532dabf9ef9aa45ea.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Softline REALOS / FR内核手册</a>中指出了所有系统调用及其功能，因此我设法恢复了表中所有已实现的处理程序，并进一步改进了IDB。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6a/b81/57a/c6ab8157a83a3e00613b4a000de45e54.png"><br><br> 当然，您可以通过在IDA中定义系统调用的类型来使代码更加美观。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/75c/099/1e075c099f1bdcb70388427705dd25c0.png"><br><br> 我写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一个Python脚本</a>来自动搜索这些系统调用以及更多内容。 <br><br><h4> 任务 </h4><br> 在<code>sta_tsk</code>系统调用中<code>sta_tsk</code>我注意到不是将main函数作为参数传递，而是将pid作为参数传递。 这意味着是时候寻找大量的任务描述符了。 从<code>sta_tsk</code>本身开始<code>sta_tsk</code> 。 <br><br><pre>  ROM：102180 sys_sta_tsk：
 ROM：102180 ST RP，@ -R15
 ROM：102182 LDUB @（R14，0x4F），R3
 ROM：102184 LDI：32＃word_100B80，R14 </pre><br> 在开始时，我们会看到一些链接。 我不得不对数据类型进行一些修改，但最终这些部分融合在一起： <br><br><pre>  ROM：100B80 word_100B80：.word 0xF； 任务数
 ROM：100B82。字0x1C; 任务描述符大小<font></font>
<font></font>
 ROM：100B84。长0x82A09F5C; 任务1描述符
 ROM：100B88。长0x1000D
 ROM：100B8C。长0
 ROM：100B90。长0x40000000
 ROM：100B94 .long sub_1A7DB2; 任务主体
 ROM：100B98。长0x8286EEC0
 ROM：100B9C。长0<font></font>
<font></font>
 ROM：100BA0 .long 0x82A09F88; 任务2描述符
 ROM：100BA4。长0x20010
 ROM：100BA8。长0
 ROM：100BAC。长0x40000000
 ROM：100BB0 .long sub_1A6BD2; 任务主体
 ROM：100BB4。长0x8287EEC0
 ROM：100BB8。长0
 ... </pre><br> 等等。 只有15个任务。 查看每个主要功能，确定任务的名称和目的（最后一个任务除外）只是时间问题。 以下是完整列表： <br><br><ol><li>  <b>子CPU</b> <br> 显然，此任务负责捕获操作，例如曝光，屏幕上的瞄准等。 <br></li><li>  <b>关键经理</b> <br> 最有可能的是，此任务与硬件按钮相关联。 <br></li><li>  <b>Guimanager</b> <br> 非常重要的任务是在其中实现UI状态机和界面呈现。 <br></li><li>  <b>调试管理器</b> <br> 是的，有一些要调试的东西。 百胜 <br></li><li>  <b>档案管理员</b> <br> 此任务全部关于文件操作。 <br></li><li>  <b>法玛纳格</b> <br> 我要说的是，该任务负责文件和内存，因为它取决于文件管理器和内存管理器的任务。 <br></li><li>  <b>内存管理器</b> <br> 毫不奇怪：内存操作，池管理等。 <br></li><li>  <b>影像管理员</b> <br> 此任务管理编码/解码过程和其他图像处理过程。 <br></li><li>  <b>Usbmanager</b> <br> 当前的挑战是USB通信处理，其中包括MassStorage，PTP和Leica自己的协议。 <br></li><li>  <b>IO管理器</b> <br> 这个任务似乎是在管理诸如SD和CF卡之类的存储设备（什么？还有哪些其他CF？也许来自213型）。 <br></li><li>  <b>系统管理员</b> <br> 各种任务，例如常规系统操作，电源管理等。 <br></li><li>  <b>设置管理器</b> <br> 处理相机状态和设置。 <br></li><li>  <b>监控经理</b> <br> 跟踪摄像机状态变化并通知其他任务。 <br></li><li>  <b>外围设备管理器</b> <br> 此任务控制GPS，亮度和其他一些传感器。 <br></li><li>  <b>不明</b> <br> 不幸的是，我没有发现对她有意义的东西。 </li></ol><br> 有趣的是，在主数组之后还有另一个出色的描述符。 <br><br> <code>ROM:100D28 dword_100D28: .long 0x82A0A1F0 <br> ROM:100D2C .long 0x21 <br> ROM:100D30 .long 0 <br> ROM:100D34 .long 0x80000000 <br> ROM:100D38 .long tid16_task <br> ROM:100D3C .long 0x8285EEC0 <br> ROM:100D40 .long 0</code> <br> <br> 任务的功能仅仅是分支本身。 <br><br> <code>ROM:101494 sub_101494: <br> ROM:101494 BRA sub_101494 ; CODE XREF: sub_101494</code> <br> <br> 在<code>start</code>函数的末尾引用该描述符，该函数负责创建其他任务并设置固件。 因此，这很可能是系统不活动的任务。 <br><br><h4> 模块和消息 </h4><br> 除了任务，您还可以定义一些逻辑对象，例如IO和外围模块。 模块作为一组消息处理程序呈现，作为任务之一的一部分。 <br><br>  IO组似乎包括： <br><br><ul><li>  IO经理 </li><li> 副处理器 </li><li>  USB管理器 </li><li>  USB PTP </li><li>  USB Leica协议 </li><li>  USB大容量存储 </li><li> 按钮管理器 </li><li> 调试管理器 </li><li> 镜头经理 </li></ul><br> 在外围组中： <br><br><ul><li> 周边经理 </li><li> 光线感应器 </li><li> 发光二极管 </li><li> 讲者 </li><li> 倾斜传感器 </li><li> 封盖识别 </li><li>  GPS模块 </li><li>  3DAxis模块 </li></ul><br> 消息传递系统本身使用标准的SOFTUNE结构： <br><br><pre> <code class="plaintext hljs">struct RealOS_MsgPayload { uint32_t msgID; // +0x0 uint32_t data[]; // +0x4 } struct RealOS_Message { uint32_t os_reserved1; // +0x0 uint32_t os_reserved2; // +0x4 uint32_t to; // +0x8 uint32_t from; // +0xC RealOS_MsgPayload* payload; // +0x10 }</code> </pre> <br> 不出所料，IPC也有几个消息组。 由于许多消息是在任务和模块中处理的，因此我只能恢复其中一些组： <br><br><pre>  0x1101xxxx-全局系统消息：
              0x11010002 = SYS_UPDATE_BOOTLOADER或
              0x11010005 = SYS_ERASE_SETTINGS
 0x1102xxxx-与图像捕获有关的消息：
              0x11020001 = CMD_CAP_CAPTURE或
              0x11020008 = IMAGE_STATUS_CHANGED  <font></font>
0x1104xxxx -   ,   :  <font></font>
             0x11040002 = PLY_DISABLE_PLAY_MODE <font></font>
             0x11040004 = PLY_IMAGE_READY  <font></font>
0x1108xxxx -     PTP  .:<font></font>
             0x11080002 = DBG_CHANGE_LEVEL <font></font>
             0x11080012 = DBG_WRITE_ROM_DUMP_SD  <font></font>
0x2201xxxx -  USB PTP<font></font>
             0x22010108 =    <font></font>
             0x22010118 =  DebugObject  <font></font>
0x2202xxxx -     SUBCPU:<font></font>
             0x22020002 = E_SUBCPU_REQUEST_M_EXPOSURE_REQUEST  <font></font>
             0x22020015 = E_IO_SUBCPU_COMMAND_CLEANING_SENSOR  <font></font>
0x2203xxxx -    :<font></font>
             0x22030001 =   <font></font>
0x2204xxxx -   IO:<font></font>
             0x2204000C = / Mass Storage <font></font>
             0x22040012 =    <font></font>
0x330000xx -     UI:<font></font>
             0x33000001 =  <font></font>
             0x33000007 =  <font></font>
0x440000xx -   ,     <font></font>
             0x44000013 = E_IMG_CMD_CHANGE_PINFO  <font></font>
0x55xxxxxx —   FAM:  <font></font>
             0x558800xx = - FAM <font></font>
             0x558888xx =     FAM<font></font>
0x6602xxxx —     LED, :<font></font>
             0x66020001 -  LED  X <font></font>
             0x66020002 =   LED  <font></font>
0x6604xxxx -  :<font></font>
             0x66040001 =  <font></font>
             0x66040007 =    <font></font>
0x6611xxxx -  ,   <font></font>
0x6622xxxx -   ,   <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x6660xxxx-其他与内存有关的消息：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
             0x66600006 =直方图  </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
             0x66600011 = RAWCOMP  </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x771100xx和0x77AA00xx-与切换摄像头模式有关的消息 </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不幸的是，许多其他职位仍然未知。 </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 图形用户界面 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在固件文件中，我们还将查看以下部分：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTRL_SYS-11</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LOKI-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-DSP-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-FPGA-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LENSDATA-212</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">令我惊讶的是完全缺乏GUI资源。但是它们应该在某个地方，并且很可能内置在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMG-LOKI-212中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我进行反向固件开发的常用方法之一是恢复所有可能的交叉引用。不仅在代码中，而且在数据部分中。然后，我仔细阅读它们，尝试找到一些模式或指向代码已知部分的链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徕卡固件也不例外。</font><font style="vertical-align: inherit;">有许多相似的数据序列，还有指向其他数据序列的地址，等等。当我爬上链接层次结构时，我终于看到了一个熟悉的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，我发现一个没有任何链接的数据结构：</font></font><br><br><pre> <code class="plaintext hljs">g_data = { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 另一个结构解决了这个问题： </font></font><br><br><pre> <code class="plaintext hljs">g_data_struct1 = { ... , &amp;g_data }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 依次由另一种结构引用： </font></font><br><br><pre> <code class="plaintext hljs">g_data_struct2 = { &amp;g_data, ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该数据结构具有来自代码的链接，并将其作为参数传递给另一个函数： </font></font><br><br><pre> <code class="plaintext hljs">func1() ╰ func2(..., &amp;g_data_struct2, ...)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，</font></font><code>func1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不是直接从另一个函数调用的，而是存储在某个数组中：</font></font><br><br><pre> <code class="plaintext hljs">g_func_list1[] = { ..., func1(), ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从上方看，我在代码中找到了一个调用</font></font><code>g_func_list1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br><pre> <code class="plaintext hljs">func3() { g_func_list1[x] }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同样，此函数存储在数组中： </font></font><br><br><pre> <code class="plaintext hljs">g_func_list2[] = { ..., func3(), ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他一些代码访问数组本身： </font></font><br><br><pre> <code class="plaintext hljs">func4() { g_func_list2[x] }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，这次是从另一个函数调用该函数，依此类推</font></font><code>gui_MADE_ApplicationRun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="plaintext hljs">gui_Statemachine_DoStateChange() ╰ gui_MADE_ApplicationRun() ╰ func5() ╰ func4()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有些行表示GUI子系统称为“ MADE”，并且使用</font></font><code>MADE_GetSysTri</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任何手段</font><font style="vertical-align: inherit;">来处理页面转换</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">GUI状态机基本上是通过功能实现的</font></font><code>gui_Statemachine_DoStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">收集有关GUI的信息后，出现了大致情况：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d4/33e/3cf/4d433e3cf679dba11141d58d080daf5b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，GUI资源的主要功能是</font></font><code>gui_CopyImageDesc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（尽管这不是真实名称）。</font><font style="vertical-align: inherit;">她有以下论点：</font></font><br><br><pre> <code class="plaintext hljs">gui_CopyImageDesc( uint32_t dstAddress; // R4 - destination address UIDescType type; // R5 - description type UITarget target; // R6 - rendering target uint32_t descAddress; // R7 - description address uint8_t always0; // (SP + 0x0) - always 0 uint8_t index1; // (SP + 0x4) - index 1 uint8_t index2; // (SP + 0x8) - index 2 uint16_t x_offset; // (SP + 0xC) - x offset uint16_t y_offset; // (SP + 0x10) - y offset uint16_t unknown2; // (SP + 0x14) - uint32_t language1; // (SP + 0x18) - language id 1 uint32_t language2; // (SP + 0x1C) - language id 2 uint32_t funcAddress; // (SP + 0x20) - function address )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 资源描述有四种类型： </font></font><br><br><pre> <code class="plaintext hljs">struct UIDescType0Header struct UIDescType1Header struct UIDescType2 struct UIDescType3 { { { { uint32_t address; uint32_t address; uint32_t reg; uint16_t x_offset; uint16_t entries; uint16_t entries; uint32_t address; uint16_t y_offset; uint16_t unknown; uint16_t unknown; uint16_t unknown1; uint32_t address; } } uint16_t unknown2; } uint16_t unknown3; struct UIDescType0Entry struct UIDescType1Entry uint16_t tableoff; { { } uint16_t x_offset; uint16_t x_offset; uint16_t y_offset; uint16_t y_offset; uint32_t address; uint32_t address; } uint16_t objects; uint16_t total_w; uint16_t total_h; uint16_t unknown; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一种类型具有标头，该标头引用记录数组。每个记录都有像素数据的坐标和地址。当前类型似乎描述了状态相关的元素，例如图标，这些元素可能会变灰或从UI中消失。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种类型也以标题开头，用于定位，描述行或文本块。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三种类型描述了不同语言的字符映射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后一种类型负责所有其他静态资源，例如图像，背景等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们看一下图像本身的数据。</font><font style="vertical-align: inherit;">前六个字节看起来像一个小标头，其后是某种重复模式，其中每个第二个字节为</font><font style="vertical-align: inherit;">或</font><font style="vertical-align: inherit;">。这是合乎逻辑的假设，</font><font style="vertical-align: inherit;">并</font></font><br><br> <code>+0x00: 00 08 00 14 00 01 A2 FF 0A 04 05 FF 0C 04 03 FF <br> +0x10: 0D 04 03 FF 0E 04 02 FF 0E 04 02 FF 04 04 06 FF <br> +0x20: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x30: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x40: 04 04 02 FF 04 04 06 FF 04 04 02 FF 04 04 06 FF <br> +0x50: 04 04 02 FF 04 04 06 FF 04 04 02 FF 0E 04 02 FF <br> +0x60: 0E 04 02 FF 0D 04 03 FF 0D 04 03 FF 0C 04 04 FF <br> +0x70: 04 04 0C FF 04 04 0C FF 04 04 0C FF 04 04 0C FF <br> +0x80: 04 04 0C FF 04 04 0C FF 04 04 0C FF 04 04 0C FF <br> +0x90: 04 04 0D FF 02 04 2D FF 00 06 00 14 00 01 79 FF</code> <br> <br><font style="vertical-align: inherit;"></font><code>0xFF</code><font style="vertical-align: inherit;"></font><code>0x04</code><font style="vertical-align: inherit;"></font><code>0x0008</code><font style="vertical-align: inherit;"></font><code>0x0014</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-具有直接字节顺序（大字节序）的视图中的宽度和高度。在此转储的结尾，我们看到了另一个序列的开始</font></font><code>00 06 00 14 00 01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这很可能是下一个资源（已通过链接确认）。因此，实际图像数据的大小是146字节。但是图像大小应为0x8 * 0x14 = 0xA0 =160。很明显，数据不是纯像素，甚至也不是8位LUT，因为它要小14个字节。</font></font>那呢<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能是某种压缩。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看此十六进制转储，很难相信使用了某种复杂的方案。 Leica的GUI并不是很丰富，因此以我的经验，最好在这里使用LUT表。在这种情况下，UI资源将完全重复LUT索引，例如</font></font><code>03 03 03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><code>1 1 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。通常，压缩程序会尝试消除数据重复，将其替换为链接。即使使用RLE这样的简单方法，这些索引数组也非常适合压缩</font></font><code>[data][number]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。一个简单的命令来写</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（计算）</font></font><code>number</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑到所有这些，我建议我们最有可能查看具有两种LUT颜色（</font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的简单图像</font><font style="vertical-align: inherit;">，并且该颜色前面的字节是要绘制的像素数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你想：“然后你写了另一种乐器。”但是不，我拿着笔和纸开始装满牢房。我仍然有那张照片真是可笑。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/743/b4a/1f3/743b4a1f3a65f485760e8a4f0584d2e6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一路上的某个地方，我意识到160像素不足以显示这张图片，因此0x8和0x14需要乘以2。第三个单词0x0001表示图像是否为ASCII字符，因此最终的ImageAsset结构如下：</font></font><br><br><pre> <code class="plaintext hljs">struct ImageAsset { uint16_t width; // /2 (big endian) uint16_t height; // /2 (big endian) uint16_t ascii; // 1,   ASCII struct image_data { uint8_t number; //     uint8_t color; //     LUT } data[]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是仍然缺少一部分：LUT。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到它并不难，因为已经手动恢复了许多链接和结构，所以我慢慢浏览了数据部分，从16位或32位值中查找256个元素的数组，直到遇到此问题为止：</font><font style="vertical-align: inherit;">再一次，谢谢在Blackmagic Design工作中，我立即识别出YUV像素（例如，所有值为8080的值）。</font><font style="vertical-align: inherit;">我不是一个傻瓜再次在纸上手动绘制整个用户界面，所以是的，我编写了另一个工具</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">-M240UITool</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">除了将所有图像资源从固件文件重置为BMP / PNG之外，该工具还可以在IDA中创建IDC脚本来确定所有UI资源。</font></font><br><br> <code>.long 0x7008080, 0x72D8080, 0x73C8080, 0x75A8080, 0x79B8080, 0x71DFF6B, 0x7BE8080, 0x7FF8080 <br> .long 0x77BBD27, 0x75B60E7, 0x7835F4A, 0x7D3089F, 0x7018080, 0x7028080, 0x7038080, 0x7048080 <br> .long 0x7058080, 0x7068080, 0x7078080, 0x7088080, 0x7098080, 0x70A8080, 0x70B8080, 0x70C8080 <br> .long 0x70D8080, 0x70E8080, 0x70F8080, 0x7108080, 0x7118080, 0x7128080, 0x7952B15, 0x7138080 <br> .long 0x7148080, 0x7158080, 0x7168080, 0x7178080, 0x7188080, 0x7198080, 0x71A8080, 0x71C8080 <br> .long 0x71D8080, 0x71E8080, 0x71F8080, 0x7338080, 0x7208080, 0x7218080, 0x7228080, 0x7238080 <br> .long 0x7248080, 0x7248080, 0x7268080, 0x7278080, 0x7288080, 0x7298080, 0x72A8080, 0x72B8080 <br> .long 0x72C8080, 0x75E8080, 0x7608080, 0x7628080, 0x7648080, 0x7678080, 0x7688080, 0x7698080 <br> .long 0x76B8080, 0x76E8080, 0x7708080, 0x7728080, 0x7758080, 0x7778080, 0x7798080, 0x77C8080 <br> .long 0x77E8080, 0x7818080, 0x7838080, 0x7868080, 0x7888080, 0x78B8080, 0x78D8080, 0x7908080 <br> .long 0x7928080, 0x7958080, 0x7978080, 0x7998080, 0x79C8080, 0x79D8080, 0x7668080, 0x79E8080 <br> .long 0x7A18080, 0x7A28080, 0x7A38080, 0x7A68080, 0x7A78080, 0x7A88080, 0x7AB8080, 0x7AC8080 <br> .long 0x7AD8080, 0x7B08080, 0x7B28080, 0x7B58080, 0x7B88080, 0x7B98080, 0x7BC8080, 0x7CC8080 <br> .long 0x7AB3BBB, 0x7E10094, 0x7E4556E, 0x4008080, 0x2922D17, 0x7B2AB00, 0x7C2A262, 0x71DFF6B <br> .long 0x768D4A2, 0x769D4EA, 0x7BD88AE, 0x705997B, 0x70BB377, 0x711CC73, 0x717E66F, 0x7238866 <br> .long 0x729A262, 0x72FBB5E, 0x735D55A, 0x7417751, 0x747914D, 0x74DAA48, 0x753C444, 0x75F663B <br> .long 0x76B9933, 0x7998080, 0x771B32F, 0x77D5526, 0x7836F22, 0x789881E, 0x78FA21A, 0x7159095 <br> .long 0x71AAA91, 0x720C38D, 0x726DD88, 0x7506F6A, 0x7568866, 0x75CA262, 0x762BB5E, 0x76E5E55 <br> .long 0x7747751, 0x77A914D, 0x780AA48, 0x78C4D3F, 0x792663B, 0x7988037, 0x79E9933, 0x7AA3C2A <br> .long 0x7B05526, 0x7B66F22, 0x7BC881E, 0x72488AE, 0x72AA1AA, 0x72FBBA6, 0x735D4A2, 0x7427799 <br> .long 0x7489095, 0x74DAA91, 0x753C38D, 0x77E556E, 0x7836F6A, 0x7898866, 0x78FA262, 0x79C4459 <br> .long 0x7A15E55, 0x7A77751, 0x7AD914D, 0x7BF4D3F, 0x7CC8080, 0x7C5663B, 0x7CB8037, 0x7337FC8 <br> .long 0x73999C4, 0x73FB2C0, 0x745CCBB, 0x7757799, 0x74C54FF, 0x77B9095, 0x780AA91, 0x7AB3C72 <br> .long 0x7B1556E, 0x7B66F6A, 0x7BC8866, 0x74277E1, 0x74890DD, 0x74EAAD9, 0x754C3D5, 0x76066CC <br> .long 0x7667FC8, 0x76C99C4, 0x772B2C0, 0x77E55B7, 0x7846EB3, 0x78A88AE, 0x790A1AA, 0x7526EFB <br> .long 0x75787F7, 0x75DA1F3, 0x763BAEE, 0x76F5DE6, 0x77577E1, 0x77B90DD, 0x781AAD9, 0x78D4CD0 <br> .long 0x79366CC, 0x79F99C4, 0x7E10094, 0x7CF44A1, 0x7DB7799, 0x7E71A90, 0x7ED338C, 0x7FF8080 <br> .long 0x7328080, 0x7DC8080, 0x7C88080, 0x7508080, 0x775CD2C, 0x76944EA, 0x7808080, 0x71A61FF <br> .long 0x7244D40, 0x7242C15, 0xFFF8080, 0xF338080, 0xF668080, 0xF998080, 0xFCC8080, 0xF008080 <br> .long 0xF4C54FF, 0xFAB3BBB, 0xFE10094, 0xFE4556E, 0xF952B15, 0xFDA7751, 0xFB2AB00, 0xFC2A262 <br> .long 0xF1DFF6B, 0xF68D4A2, 0xF69D4EA, 0xFBD88AE, 0xA922D17, 0xC6E4130, 0xE286963, 0x74C55FF <br> .long 0x768D536, 0x7FF8080, 0x7FF8080, 0x7FF8080, 0x2922D17, 0x46E4130, 0x6286963, 0x8080</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br> <code>Leica M (typ 240) UI Tool v1.0 <br> Usage: ./M240UITool [-a address] [-i imagebase] [-s script] [-d dump] [-f folder] [-l LUT] [-rbv] FIRMWARE.BIN <br> <br> This tool will help you to find UI resources in firmware. <br> Use following arguments: <br> -a Specify address of the gui_CopyImageDesc function (ex. 0x2F95E0) <br> -i Specify firmware imagebase <br> -s Specify IDC file name <br> -c Specify container file name <br> -d Specify dump image format <br> png - PNG format <br> bmp - BMP (ARGB) format <br> -f Specify folder for dumped images <br> -l Specify LUT for images (filename of address) <br> -b Specify number of bytes to display in verbose mode <br> -r Try to recover string characters <br> -v Be verbose</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经知道，从一个UI页面创建的功能来看，它被多次调用</font></font><code>gui_CopyImageDesc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我认为制作一个UI资源浏览器并定义所有页面呈现功能会很棒。</font><font style="vertical-align: inherit;">该选项专用于此</font></font><code>-c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-它创建了一个用于查看资源的特殊容器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁说UI资源浏览器可能看起来并不异常？</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b6/5f7/6c3/8b65f76c30a4d4a037719e805141573a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该工具具有交互性（屏幕截图上的半透明按钮），不仅使您可以滚动浏览EVF / LCD菜单的页面，还可以查看一页内的渲染步骤。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，该杰作的源代码在某个地方丢失了，但是头文件仍在M240UITool代码中，因此从技术上讲，您可以从头开始重新创建它。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调试菜单 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在进行逆向工程时，我们主要寻找哪条线？我认为，这个词</font></font><code>debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其派生</font><font style="vertical-align: inherit;">词</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固件中有很多有趣的行，但是这些行很特别：</font><font style="vertical-align: inherit;">似乎可以使用某些组合键进入调试模式。所有这些行都从一个巨型函数调用</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">实现了按钮扫描状态机。这是IDA中的样子：</font></font><br><br> <code>$ strings ./IMG_LOKI-212_1.1.0.2.bin | grep "Debug Mode" <br> GUI: State: %d! Scanning for Debug Mode successful <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> GUI: Scanning for Debug Mode: State: %d, Ignore long DEL <br> GUI: Scanning for Debug Mode: State: %d <br> ... <br> GUI: ScanningForDebugWithKeyAndJoyStick(): g_GUI_CheckForDebugWithKeyAndJoyStick = %d</code> <br> <br><font style="vertical-align: inherit;"></font><code>ScanningForDebugWithKeyAndJoyStick</code><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9e/525/cd2/e9e525cd2bc493e7bb8cc4b3710b1334.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不会说谎，花了一些时间来了解固件中如何处理硬件按钮，然后恢复按钮和操纵杆的枚举类型。但是当我得到合并的时候，我很生气地发现她什么也没做。它可能只能在特定的GUI页面上使用。 GUI状态机的手动跟踪又过了两个晚上-问题得以解决，我们还设法找到了Reset菜单页面。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，欢迎使用调试模式。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/74d/068/52674d068ae127cc7b90b5b1172de325.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我考虑过是否要宣布这一组合，但决定弃权。我尊重徕卡所做的辛勤工作，发布了其独特的设备，并且我不为这样的事实负责，因为他们的服务中心将由于一些深思熟虑的好奇心而填补相机破碎的尸体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是，我仍然会提供一些枚举类型，以便为准备采用这种方法的人员简化逆向工程。 </font></font><br><br><pre> <code class="plaintext hljs">enum ControlActionType { kControlAction_Idle, // 0 kControlAction_Push, // 1 kControlAction_Release, // 2 kControlAction_LongPush // 3 }; enum ControlBtnType { kControlBtn_LV, // 0 kControlBtn_PLAY, // 1 kControlBtn_DEL, // 2 kControlBtn_ISO, // 3 kControlBtn_MENU, // 4 kControlBtn_SET // 5 }; enum ControlJoystickType { kControlJoy_INFO, // 0 kControlJoy_Up, // 1 kControlJoy_Down, // 2 kControlJoy_Left, // 3 kControlJoy_Right // 4 };</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 点对点 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑到USB任务，我定义了三种模式（在调试菜单中也已确认）： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 点对点 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSC（海量存储类） </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 徕卡定制 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTP最为有趣，因为PTP有据可查，可让您控制摄像机。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在固件中找到PTP处理程序非常容易，因为此代码中有很多调用。</font><font style="vertical-align: inherit;">所有PTP呼叫均分为三类：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">传统</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徕卡扩展（LE）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生产</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试消息有助于为几乎所有代码建立名称。</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 旧版：徕卡扩展：生产：                           </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0x1001-GetDeviceInfo 0x9001-设置相机设置0x9100-公开生产会议      </font></font><font></font>
0x1002 - OpenSession 0x9002 - Get Camera Settings 0x9101 - Close Production Session     <font></font>
0x1003 - CloseSession 0x9003 - Get Lens Parameter 0x9102 - UpdateFirmware               <font></font>
0x1004 - Get Storage ID 0x9004 - Release Stage 0x9103 - Open OSD Session             <font></font>
0x1005 - Get Storage Info 0x9005 - Open LE Session 0x9104 - Close OSD Session            <font></font>
0x1006 - GetNumObjects 0x9006 - Close LE Session 0x9105 - Get OSD Data                 <font></font>
0x1007 - GetObjectHandles 0x9007 - RequestObjectTransferReady 0x9106 - GetFirmwareStruct            <font></font>
0x1008 - GetObjectInfo 0x9008 - GetGeoTackingData 0x910B - GetDebugMenu                 <font></font>
0x1009 - GetObject 0x900A - Open Debug Session 0x910C - SetDebugMenu                 <font></font>
0x100A - Get Thumb 0x900B - Close Debug Session 0x910D - ODIN Message                 <font></font>
0x100B - Delete Object 0x900C - Get Debug Buffer 0x910E - GetDebugObjectHandles        <font></font>
0x100E - Initiate Capture 0x900D - Debug Command String 0x910F - GetDebugObject               <font></font>
0x1014 - GetDevicePropDesc 0x900E - Get Debug Route 0x9110 - DeleteDebugObject            <font></font>
0x1015 - GetDevicePropV 0x900F - SetIPTCData 0x9111 - GetDebugObjectInfo           <font></font>
0x101C - Initiate Open Capture 0x9010 - GetIPTCData 0x9112 - WriteDebugObject             <font></font>
                                   0x9020 - Get3DAxisData 0x9113 - CreateDebugObject            <font></font>
                                   0x9030 - OpenLiveViewSession 0x9114 - Calibrate 3Daxis             <font></font>
                                   0x9031 - CloseLiveViewSession 0x9115 - Magnetic calibration         <font></font>
                                   0x9033 - Unknown 0x9116 - Get Viewfinder Data </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTP接口本身的实现似乎是标准的，但是某些命令具有一些限制，在此我特意忽略了这些限制。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论如何，以上所有都是令人兴奋的。</font><font style="vertical-align: inherit;">您可能会想：“让我们通过USB插入相机，然后开始使用libptp进行探测。”</font></font>没错 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该死的... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leica M240没有USB端口。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 手柄口 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徕卡为此相机提供的配件很少，但是其中一个特别有趣。</font><font style="vertical-align: inherit;">我们正在谈论</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多功能手柄Leica M（14495）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它取代了外壳的底部金属部分，提供了内置GPS和几个连接器，例如USB，SCA闪光端子，DIN / ISO-X和电源插座。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fab/250/1b6/fab2501b6e69cb6caf3f62528e413bdb.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后您再说一遍：“太好了，现在就购买它，将其连接到相机，通过USB连接相机，并开始使用libptp进行探测。”</font></font>没错 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是该死的... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它的成本近900美元。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这几乎是创建您自己的适配器的九百个原因。</font><font style="vertical-align: inherit;">但是，以防万一，我为此配件设置了eBay通知。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 连接器 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机上的连接器如下：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a29/4f0/388/a294f0388ad2c5ac3d355d0838e01586.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我试图在Internet上找到它，但是说真的，您如何在Google上描述它？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绝望了一下，我开始考虑一些疯狂的事情，例如将箔或针刺到橡皮上。但是一旦在Blackmagic Design工作时，看着摄像机电路板，我注意到其中一个连接器的形状非常熟悉。第二天，我将我的Leica M240投入使用-是的，它看起来很相似，只是用了很多垫子才更长。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然需要询问我们的组件管理器的零件号，然后在Samtec目录中找到它：</font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERM8-013-05.0-L-DV-TR</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a60/dc3/d36/a60dc3d36d12216f74690577507fc6db.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还询问了Samtec是否可以获取样本，他们表示同意。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dda/752/0d6/dda7520d6691fc48f3f1aaa026e49635.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以用烙铁，硬纸板和电工胶带做一些工作-我自己的插头已经准备好（2013年样品）。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddd/243/fe5/ddd243fe596648709c3f9dccb76f15ea.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">五年后的2018年，我决定亲自要求Samtec发送另一个样本。</font><font style="vertical-align: inherit;">我想做得更好。</font></font><br><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ERCD-013-05.00-TTR-TTR-1-D</font></font></a></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/e1a/56a/995/e1a56a9958b1dda50aca34f0ecac8863.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次使用烙铁进行大量工作，打磨，切割线，使用脏话，再使用烙铁进行工作，以做出一个新的，更具吸引力的选择：</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a5/b78/10d/1a5b7810d3a2ccea73bf4e2d75cad8cd.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 引脚排列 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接器中有26个触点：每侧13个。甚至在焊接我的零件之前，我就用万用表和逻辑分析仪探查了相机的连接器。顺便说一句，您需要在底盖传感器上放一块磁铁，以便相机认为盖已就位。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接地（相机关闭，没有电池）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我总是从地面开始，因为它安全且非常容易找到。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ead/140/15c/ead14015c97177d6717e198616c9114b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们有8条接地线（深灰色）。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电位（摄像头打开）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摄像头打开时，您可以测量每个引脚上的电位，并了解逻辑和功率级别。</font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alexhude.github.io/assets/2019/2019-01-24-hacking-leica-m240/probe2_potential.png</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚8–9和11–13的性能对于逻辑引脚而言过高，因此我将其定义为电源（红色）。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电阻（相机关闭，没有电池）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测量电阻非常有用。在某些情况下，这有助于识别输入并将某些行分组。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa7/fde/1a6/fa7fde1a623a5f13d264a5127a3083d2.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接输出（相机关闭，没有电池）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我决定检查相机机身上的所有外部打击垫，以检查它们是否已连接至维修端口。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f75/61e/c06/f7561ec060796fa8e39a15d533e3de03.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">闪光同步触点直接连接到10号线。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逻辑分析仪（相机已打开）</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按照以下顺序记录每条线的数据：打开，相机应处于LV模式，拍照，开始录像。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/494/33c/27c/49433c27cf94be5cb9430e4ba518560c.png"><br><br>     - : 01  21. <br><br> <b>01</b> — 115200,   8 , 1 -,  , LSB . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/3a2/fdf/bf73a2fdfbbfeab571c354f2a6d50c9b.png"><br><br>  500 ,   -  <code>C3 3C 02 81 00 01 00 82, C3 3C 02 81 01 01 00 83, C3 3C 02 81 02 01 00 80</code> … <br><br> <b>21</b> — 115200,   8 , 1 -,    , LSB . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f00/423/2dd/f004232dd3f1b8c8f0e665fd63f3fa9b.png"><br><br>     SH7216 (“Leica Camera AG”   ). <br><br>    -.  ,   Maestro           Debug. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c44/541/bb9/c44541bb98c4388f151bdc3faffa1dfe.png"><br><br>      310kOhm. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不知道为什么，但是我建议其他数据线可能具有相似的阻力或将被关闭。因此，我将〜300kOhm，〜200kOhm和〜100kOhm的线定义为数据线（图片中的蓝色阴影）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，绘制了以下图片。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7e/31f/f2c/e7e31ff2cc7da6ae304652488ca9db4c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据线上有12位候选人。但是如何检查它们呢？在与钢铁专家就集成电路的电气保护进行了简短的交谈之后，我开始通过4kOhm的电阻戳接触点，该电阻将电流降低到输入不应燃烧的水平。</font></font><br><br><h4> 串口 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还假设RX线应该在TX附近。</font><font style="vertical-align: inherit;">02、03和20行看起来像是不错的选择，因为它们的电压都像TX一样，为3.3V。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初，我尝试使用Bus Pirate探索这些线​​路。</font><font style="vertical-align: inherit;">不幸的是，结果很脏。</font><font style="vertical-align: inherit;">然后，我认为基于SiLabs的电缆在macOS上更加可靠且无冲突。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我将TX电缆连接到引脚20，并</font></font><code>help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在引导加载程序之后</font><font style="vertical-align: inherit;">开始键入</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">不出所料，在短暂的延迟之后，相机重复了角色。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a16/445/c00/a16445c00b6a22a6b37b74c97fc97ca5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">触点02和03是UART的下一个候选对象。</font><font style="vertical-align: inherit;">不幸的是，没有迹象表明这些线正在被挖掘。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在该图中，众所周知的UART用深绿色阴影表示。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/733/f68/fa1/733f68fa1950518017ad2c09971ac1f8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> USB接口 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切始于将USB电缆切成两半，中间有一个接头，并带有4kOhm的电阻用于感测。</font><font style="vertical-align: inherit;">差分对的信号完整性？</font><font style="vertical-align: inherit;">不，那我真的不在乎。</font></font> :) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/891/930/5d3/8919305d35cd2525d420313c2b0e7555.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我在家中探查了几个USB家庭设备，以了解该端口上的通信情况。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">佳能</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/c49/f85/cf8/c49f85cf89650352531c83c970eb609c.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相机Blackmagic便携式</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/8b7/7e5/bc8/8b77e5bc8c2fa3387083a8e8ec12c3db.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摄像机佳能</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/17f/dd4/67a/17fdd467a6627a4129f38d6e476d4ffc.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摄像机JVC摄像机</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/757/80d/4c8/75780d4c8a85c55c04afe5de9209e09d.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钥匙扣</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/ad9/3a6/382/ad93a63828797eaea1f5d906367b792f.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KidiZoom相机</font></font></b> <br><img src="https://habrastorage.org/getpro/habr/post_images/32e/d73/13a/32ed7313a12ef1cef1444a87c22f3c77.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有点不同，但是初始D-D +状态很低。</font><font style="vertical-align: inherit;">好吧，我们将知道，现在我们将检查是否具有：</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不太可能，因为D-D +是差分对，应该非常接近；</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">04/05-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不太可能，因为它们具有不同的抵抗力；</font></font><br></li><li> <b>14/15</b> — ,      ; <br></li><li> <b>15/16</b> — ,        . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我将USB D-D +连接到15/16引脚，然后将其连接到iMac ... </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/491/b7f/777491b7f4a3b4b0f8376931db78c6c8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在USB PTP屏幕上，但是相机未出现在主机上。我试图在电子电路的布局上配置不同的选项，但是没有任何效果。小猎犬显示出很多包装损坏和其他错误。最后，我放弃并返回对固件进行反向工程。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是最后的引脚分配，USB标记为深绿色。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ad/07d/289/2ad07d289a684e6db69a02ae9e50c294.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁曾想到，几年后，同样的eBay通知会传给我，我会以低廉的价格购买所需的配件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我可以检验对PTP的假设。但是起初，很好奇USB PHY在小工具内部的外观。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/afe/0b1/afc/afe0b1afc09953f7f9c6dbc451c47c56.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部是</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">SMSC 2512b</font></a><font style="vertical-align: inherit;">集线器</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从手柄插孔到Mini USB接口的路上。该芯片在默认模式下工作，因为没有EEPROM或SCL / SDA引脚。第一个下游端口连接到相机机身上的插槽，但第二个未连接任何东西。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可能错过了一些东西，但是对我来说，这样的解决方案没有多大意义。技术护照说，该芯片具有“完全集成的USB引脚以及用于升高和降低电压的电阻器”。也许徕卡的工程师决定不实施自己的USB PHY，而是在集线器中使用了一个经过良好测试并且可以立即使用的集线器。实际上，我不能怪他们，因为在我尝试这样做之前，事实证明这是一项艰巨的任务。谁知道，也许这是防止伪造的功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无论如何，如果您了解USB PHY并准备为您提供帮助，请随时给我写信：没有这个品牌附件的情况下，应该可以通过USB端口工作：） </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 再次PTP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就像我说的，是时候玩Leica PTP扩展程序了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，我找到了一个非常酷的C ++库，而不是libptp，它是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libEasyPTP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">基于此库编写工具也不需要花费很多时间：我已经知道Leica PTP界面的一些局限性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，尽管M240PTPTool有很多缺陷，但它非常适合概念验证（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅两个请求通过PTP：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetDebugBuffer（0x900C）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DebugCommandString（0x900D）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">顺便说一句，为了让模块填写调试日志，您需要在菜单中将“调试级别”设置为“调试”或“调试RAW”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M240PTPTool界面中有几个选项：</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">退出</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -关闭工具；</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">刷新</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -合并摄像机的调试缓冲区：</font></font></li></ul><br> <code>M240&gt; flush <br> I:[00:11:468]|01| DATE/TIME CORRECTED by 5921 sec <br> D:[00:12:079]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:179]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:282]|11| Message received from TID 0 for TID 1 over MBX 3 <br> D:[00:12:283]|11| Message received from TID 0 for TID 1 over MBX 3 <br> D:[00:12:301]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:402]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> D:[00:12:502]|00| Send message from TID 0 to TID 1 over MBX 3 - length: 4 - MesgID: 0x22020103 <br> ...</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他任何文本作为调试命令发送到相机。</font><font style="vertical-align: inherit;">例如，它</font></font><code>help</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示带有参数的所有可能的命令：</font><font style="vertical-align: inherit;">完整列表很大，但是看起来，您可以将直接消息发送给Softune执行任何任务！</font><font style="vertical-align: inherit;">将其发送到那里会很有趣。</font><font style="vertical-align: inherit;">经常在固件中搜索的另一条流行线是</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们看看是否有一个。</font><font style="vertical-align: inherit;">显然，您可以将固件转储到SD卡上。</font><font style="vertical-align: inherit;">使用“将文件转储到卡”行的链接，很容易找到造成此问题的代码。</font><font style="vertical-align: inherit;">它位于巨大的系统任务块（众所周知，pid 11）中，并由</font><font style="vertical-align: inherit;">不带参数</font><font style="vertical-align: inherit;">的消息</font><font style="vertical-align: inherit;">调用。</font><font style="vertical-align: inherit;">表盘</font><font style="vertical-align: inherit;">在</font><b><font style="vertical-align: inherit;">M240PTPTool</font></b><font style="vertical-align: inherit;">，按Enter键和看屏幕。</font></font><br><br> <code>M240&gt; help <br> ********* debug command description ******** <br> <br> exposure request <br> Description: requests a release from Sub CPU <br> Parameter 1: Exposure Time TV <br> <br> still request <br> Description: simulates the -still request- command flow of Sub CPU <br> Parameter: no <br> <br> ... <br> <br> send Message;[Parameter1];[Parameter2];[Parameter2];...;... <br> Description: Sending Message to Task <br> Parameter 1: Receiver Task ID <br> Parameter 2: Command ID <br> Parameter 3: Command Data[0] (32 Bit) <br> Parameter 4: Command Data[1] (32 Bit) <br> Parameter 5: . <br> Parameter 6: . <br> use maximum 10 Parameter <br> <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>dump</code><font style="vertical-align: inherit;"></font><br><br> <code>$ strings IMG_LOKI-212_1.1.0.2.bin | rg -i dump <br> GUI: HEX DUMP: Address: %x, Length: %d <br> HSK: DBG_WRITE_ROM_DUMP_SD: File was properly opened, but it seems to be empty. <br> ROM_DUMP <br> HSK: DBG_WRITE_ROM_DUMP_SD: Flushing Dump to ROM. Size %d <br> SD:\ROM_DUMP.bin <br> HSK: DBG_WRITE_ROM_DUMP_SD Command received! <br> ROM_DUMP.bin <br> HSK: DUMP failed, no cards inserted! <br> HSK: DUMP FlashROM to SD card. <br> HSK: DUMP FlashROM to CF card. <br> Dumping files to card</code> <br> <br><font style="vertical-align: inherit;"></font><code>0x11080006</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>send Message;11;0x11080006</code><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4de/1cc/e2e/4de1cce2e0ee47a67645df790a7e581c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后取出SD卡并检查其中的内容。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/209/2a8/25e/2092a825e23cb93c4845b416ea11b0e4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个完整的转储，包括固件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这开辟了无限的可能性。</font><font style="vertical-align: inherit;">例如，您可以制造一个带有MCU的小型设备，支持USB主机和用于启动复杂消息序列的按钮... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后我们有了第二个孩子。</font></font> :) <br><br><h1> 结语 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您不想损坏设备，通常可以通过一种方法来检查它，而无需打开外壳或将导线焊接到电路板上。</font><font style="vertical-align: inherit;">如果您感兴趣，以下是我的提示：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查找有关该设备的所有公共信息：技术规格，组件数据，内部照片，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工厂视频</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；）</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果您有固件，请深入研究并寻找外部输出的提示； </font></font><br></li><li>        ,     ; <br></li><li>  GND//    ,  ; <br></li><li>     ; <br></li><li>     ,   ; <br></li><li>   ,     (, ); <br></li><li>        ,    Google   (USB/UART/SPI/I2C/1Wire); <br></li><li>      ,      ; <br></li><li>  <s></s>  ,      ; <br></li><li>  ,    . </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/18b/006/166/18b006166a4070202c1be3a9b946c3e9.png"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/alexhude</a> <br><br> <b>  !</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438168/">https://habr.com/ru/post/zh-CN438168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438152/index.html">“我可以告诉您每个iOS开发人员的痛苦”-向开发人员提出的10个问题，第2集</a></li>
<li><a href="../zh-CN438158/index.html">美国数据经纪人未经用户同意就出售位置数据-他们的工作将受到监管</a></li>
<li><a href="../zh-CN438162/index.html">一个健康人的元组</a></li>
<li><a href="../zh-CN438164/index.html">遗传学和鸡：鸡蛋蛋白中的人类CSF1-Fc蛋白</a></li>
<li><a href="../zh-CN438166/index.html">浏览器中的站点与本地运行的程序之间的交互</a></li>
<li><a href="../zh-CN438170/index.html">奖以伊利亚·塞加洛维奇（Ilya Segalovich）命名。 有关计算机科学和发行出版物的故事</a></li>
<li><a href="../zh-CN438172/index.html">苹果无法将其设备的生产转移到美国</a></li>
<li><a href="../zh-CN438174/index.html">黄色-真空-云</a></li>
<li><a href="../zh-CN438176/index.html">Mikrotik的IPSec概述</a></li>
<li><a href="../zh-CN438178/index.html">创建您的第一个ARCore应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>