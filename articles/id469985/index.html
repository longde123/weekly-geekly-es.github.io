<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÑ ‚úåüèæ üî® Mempercepat program untuk prosesor Redd yang disintesis tanpa optimisasi: mengganti jam üèúÔ∏è ‚Ü©Ô∏è üßï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sampai sekarang, kami telah membahas topik tentang cara meningkatkan kecepatan sistem menggunakan beberapa metode intensif. Namun pada kenyataannya, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mempercepat program untuk prosesor Redd yang disintesis tanpa optimisasi: mengganti jam</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469985/">  Sampai sekarang, kami telah membahas topik tentang cara meningkatkan kecepatan sistem menggunakan beberapa metode intensif.  Namun pada kenyataannya, ada metode yang luas.  Sekarang kami bekerja pada frekuensi clock 50 MHz, yang dikaitkan dengan penggunaan komponen dari set untuk program universitas (dan tanpa itu tidak mungkin untuk clock SDRAM, yang mengharuskan pulsa clock pergi ke sirkuit mikro digeser relatif terhadap yang utama).  Ketika saya memperkenalkan komponen ini ke permainan, saya memperingatkan bahwa solusi ini bersifat sementara.  Lalu saya membuang begitu banyak informasi baru pada pembaca sehingga kebosanan ekstra dapat menyebabkan seru: "Nah, FPGA ini, semuanya sangat rumit di sini!"  Sekarang kita sudah dengan mudah dan alami membangun sistem prosesor, semua hal buruk ada di belakang kita.  Saatnya untuk mencari tahu bagaimana Anda dapat membuat komponen Anda sendiri, yang memungkinkan Anda untuk meningkatkan frekuensi clock dari prosesor dan periferal yang terhubung dengannya. <br><br><img src="https://habrastorage.org/webt/cw/bq/hz/cwbqhzbsc0zb9fvgee5j7_7gyqw.png"><br><a name="habracut"></a><br><h4>  Artikel sebelumnya dalam seri: </h4><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksperimen pertama menggunakan protokol streaming pada contoh koneksi CPU dan prosesor di FPGA kompleks Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Optimasi Kode untuk Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: efek cache.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode Optimasi Kode untuk Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: memori non-cache dan operasi bus paralel.</a> </li></ol><br><h2>  Sedikit alasan teoretis </h2><br>  Mari kita perkirakan frekuensi apa yang bisa kita atur tanpa henti untuk pencatatan semua besi kita.  Chip SDRAM yang digunakan dalam kompleks memungkinkan frekuensi frekuensi 133 MHz.  Untuk kecepatan jam prosesor, lihat <b>Tolok Ukur Kinerja Nios II</b> .  Di sana, untuk FPGA Cyclone IV E kami, frekuensi inti Nios II / f 160 MHz dijamin.  Saya bukan pendukung memeras semua jus dari sistem, jadi kita akan berbicara tentang bekerja pada frekuensi 100 MHz. <br><br>  Sejujurnya, saya masih belum terinspirasi oleh metodologi untuk menghitung pergeseran frekuensi jam yang diberikan dalam bagian <b>32.7.</b>  <b>Jam, PLL, dan Pertimbangan Waktu untuk</b> <b>Panduan Pengguna Perangkat IP Tertanam</b> , tetapi sepertinya saya bukan satu-satunya.  Setidaknya, pencarian panjang di internet tidak menuntun saya ke artikel yang akan berisi hasil yang dihitung dengan cara yang sama, tetapi tidak untuk frekuensi yang diberikan dalam dokumen utama (50 MHz yang sama). <br><br>  Ada artikel menarik yang akan saya berikan tautan langsung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.emb4fun.de/fpga/nutos1/index.html</a> .  Seseorang dapat merujuknya dan mengatakan "Mari kita lakukan sebagai penulis", jika bukan untuk satu "tetapi": penulis artikel ini menggunakan blok PLL (dalam bahasa Rusia - PLL, dan di tingkat rumah tangga - konverter frekuensi), memasukkan kode sendiri dalam VHDL.  Saya, sebagaimana telah dicatat dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang kesenangan Quartusel</a> , mematuhi ideologi bahwa sistem prosesor harus berada di tingkat atas hirarki proyek.  Tidak diperlukan penyisipan dalam bahasa apa pun, baik itu VHDL atau Verilog.  Baru-baru ini, pendekatan saya ini telah menerima satu konfirmasi lagi: kami memiliki karyawan baru, seorang siswa yang belum berbicara Verilog, tetapi membuat kode untuk kompleks Redd dengan sempurna, karena pendekatan yang dipilih memungkinkan ini. <br><br>  Ternyata kami hanya mengambil sebagai dasar bahwa semuanya bekerja untuk penulis pada pergeseran minus 54 derajat (derajat apa yang dijelaskan dalam artikel, tautan yang saya berikan paragraf di atas). <br><br>  Selanjutnya, perhatikan artikel menarik lainnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asral.unimap.edu.my/wp-content/uploads/2019/07/2019_IJEECS_Chan_Implementation-Camera-System.pdf</a> .  Semuanya bekerja untuk penulis dengan perubahan minus 65 derajat. <br><br>  Mari kita coba membuat sistem kita menggunakan nilai dari rentang ini.  Jika selama tes harian RAM tidak ada kerusakan tunggal, maka kita akan membiarkan nilai ini sebagai pertempuran.  Kami memiliki hak, karena ‚Äúfirmware‚Äù yang dikembangkan untuk Redd tidak akan diberikan kepada Pelanggan, tetapi akan digunakan untuk kebutuhan internal, dan dalam jumlah satuan.  Jika ada, akan selalu memungkinkan untuk memperbaiki semuanya tanpa kesulitan yang tidak perlu (kesulitan muncul ketika perlu memperbarui "firmware" di ribuan perangkat yang dijual, dan hanya di Pelanggan jarak jauh). <br><br><h2>  Konfigurasi perangkat keras baru </h2><br>  Untuk beberapa alasan, menurut saya sistem prosesor untuk artikel ini lebih mudah dilakukan dari awal daripada membuat ulang dari yang lama.  Hanya bagaimana mendemonstrasikan proses "memutar, memelintir, ingin membingungkan", terus mengacu pada artikel sebelumnya, saya lebih suka menunjukkan semuanya lagi dari awal.  Pada saat yang sama, kami memperbaiki materi.  Jadi, mari kita mulai. <br><br>  Pada awalnya, kami ditunjukkan sistem yang benar-benar kosong yang hanya berisi jam dan mengatur ulang sumber sinyal. <br><br><img src="https://habrastorage.org/webt/7q/lb/nb/7qlbnbmbkenpbeqgwna6jk4jnn4.png"><br><br>  Biasanya saya tidak mengubah apa pun di sana, tetapi hari ini saya akan membuat pengecualian.  Saya tidak ingin terganggu oleh rangkaian reset, karena kami masih akan bekerja dari bawah debugger.  Oleh karena itu, saya akan beralih kondisi reset dari level ke perbedaan negatif, dan kaki itu sendiri kemudian akan dibatalkan. <br><br><img src="https://habrastorage.org/webt/dg/wl/tq/dgwltqtfn-kmqrd7wln66eenqxa.png"><br><br>  Tetapi di sini sinyal clock memiliki frekuensi 50 MHz (frekuensi ini diatur oleh karakteristik generator yang disolder ke papan).  Pada artikel pertama yang saya sebutkan di atas, blok PLL ditambahkan ke proyek utama digunakan.  Di mana kita mendapatkannya di sini?  Dan ini dia! <br><br><img src="https://habrastorage.org/webt/08/oy/om/08oyom1okdqkzb2ifmkuzqnjjw0.png"><br><br>  Ini adalah blok yang sama, tetapi di sini kita tidak perlu menyematkan kode apa pun di Verilog atau VHDL.  Semuanya sudah dimasukkan untuk kita!  Benar, pengaturan untuk berbagai jenis FPGA berbeda sedikit lebih dari sepenuhnya.  Lebih tepatnya, parameter yang dapat disetel kurang lebih sama, tetapi mereka berada di tempat yang berbeda secara mendasar dalam dialog konfigurasi.  Karena Cyclone IV E FPGA digunakan di kompleks Redd, kami akan mempertimbangkan konfigurasi opsi ini. <br><br>  Pada tab pertama, ganti frekuensi input dengan 50 MHz (secara default adalah 100) dan pergi ke tab berikutnya (klik Next, untuk Cyclone IV E kita harus melakukan ini berkali-kali). <br><br><img src="https://habrastorage.org/webt/w-/rd/um/w-rdummwtsajd7lb__-cdwzp5ko.png"><br><br>  Hapus centang input dan output tambahan.  Kami tidak membutuhkannya: <br><br><img src="https://habrastorage.org/webt/ed/0q/_o/ed0q_otou0y9f25tgvrlxmcpzgm.png"><br><br>  Kami melewatkan beberapa tab berikutnya hingga kami dapat mengatur output C0.  Di sana kami beralih tombol radio untuk mengatur frekuensi dan memasukkan nilai 100 MHz: <br><br><img src="https://habrastorage.org/webt/r0/lr/xp/r0lrxpaypyrhi9k3yvdhe8qaqp4.png"><br><br>  Dengan C1, segalanya menjadi sedikit lebih rumit.  Pertama, pilih kotak centang yang mengatakan bahwa itu juga harus digunakan.  Kedua, kami juga mengatur frekuensi 100 MHz.  Nah, dan ketiga, kami mengatur pergeseran frekuensi.  Yang mana untuk bertanya?  Kurang 58 atau minus 65?  Tentu saja, saya mencoba kedua opsi tersebut.  Keduanya mendapatkan saya.  Tetapi argumen pada topik minus 58 terlihat sedikit kurang meyakinkan, jadi di sini saya akan merekomendasikan untuk memasukkan nilai minus 65 derajat (sementara otomatisasi akan memberi tahu saya bahwa nilai aktual yang dicapai akan minus 63 derajat). <br><br><img src="https://habrastorage.org/webt/bc/p2/qq/bcp2qqfzxrhq5dnpg8xrkxeq4cm.png"><br><br>  Yah, itu dia.  Sekarang Anda dapat melangkah melalui tombol <b>Berikutnya</b> sampai akhir, atau Anda cukup mengklik <b>Selesai</b> .  Kami menghubungkan input <b>inclk_interface</b> dan <b>inclk_interface_reset</b> .  Output <b>c0</b> akan digunakan sebagai jam untuk seluruh sistem.  Output <b>c1</b> diekspor untuk clocking chip <b>sdram</b> .  Di masa depan, Anda harus ingat untuk menghubungkan bus data ke input <b>pll_slave</b> .  Untuk Cyclone V, ini tidak perlu. <br><br><img src="https://habrastorage.org/webt/d8/ka/fr/d8kafro1xgmvgyh2ofbytqoo7a0.png"><br><br><h2>  Bagian perangkat keras lainnya, murni untuk memperbaiki bahan </h2><br>  Tambahkan inti prosesor.  Hari ini, SDRAM kami akan diuji.  Jadi, kode itu tidak boleh berada di dalamnya.  Dan ini, pada gilirannya, berarti bahwa semua kode akan ditempatkan di RAM internal FPGA.  Artinya, kita tidak perlu cache instruksi.  Matikan, hemat memori FPGA.  Kami juga menghubungkan satu bus instruksi dan data yang sangat terhubung.  Tidak diperlukan pengaturan yang lebih menarik untuk inti prosesor. <br><br><img src="https://habrastorage.org/webt/2s/h2/jz/2sh2jzypydrpub1i5pzsqfymbyc.png"><br><br>  Dengan gerakan tangan yang biasa, tambahkan dua blok RAM internal FPGA.  Satu adalah port ganda dengan kapasitas 16 kilobyte dan satu adalah port tunggal dengan kapasitas 4 kilobyte.  Bagaimana menamai mereka dan bagaimana menghubungkan, saya harap semua orang ingat.  Terakhir kali saya suka menyoroti ban dengan bunga, mungkin untuk kemudahan membaca, saya akan melakukannya di artikel ini. <br><br><img src="https://habrastorage.org/webt/lu/fs/sh/lufsshayqwws2kmrbr1isy3bjow.png"><br><br>  Jangan lupa untuk menetapkan blok memori ini alamat khusus dalam rentang pribadi dan menguncinya.  Biarkan <b>CodeMemory</b> ditugaskan ke 0x20000000, dan <b>DataMemory</b> ke 0x20004000. <br><br>  Baiklah, mari kita tambahkan blok <b>SDRAM</b> ke sistem, pengaturannya, serta blok <b>JTAG-UART</b> untuk menampilkan pesan dan <b>GPIO</b> bit-tunggal, di mana kami akan mengukur frekuensi nyata untuk memastikan bahwa itu meningkat.  Untuk referensi, berikut adalah beberapa pengaturan yang tidak jelas: <br><br><img src="https://habrastorage.org/webt/i3/eo/1h/i3eo1hx2p7ozz4h_9t026n6h-io.png"><br><br><img src="https://habrastorage.org/webt/t9/af/br/t9afbrimkhlvmd-n8qkhc08ol50.png"><br><br><img src="https://habrastorage.org/webt/hw/f3/gc/hwf3gcxo8y4dt4exehzc-v_qoli.png"><br><br>  Total, kami mendapatkan sistem seperti itu (saya menyoroti bus data, karena memindai di semua perangkat eksternal): <br><br><img src="https://habrastorage.org/webt/jq/km/rv/jqkmrvm8acbrz3gqqq_asxque_a.png"><br><br>  Kami menetapkan vektor ke prosesor, secara otomatis menetapkan alamat, secara otomatis menetapkan angka interupsi, ke sistem pembangkit. <br><br>  Kami menghubungkan sistem ke proyek, melakukan perakitan kasar, menetapkan nomor kaki, dan kali ini kami membuat virtual tidak hanya <b>CKE</b> , tetapi juga <b>reset_n</b> (bagaimana ini dilakukan, saya katakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu artikel sebelumnya</a> , cari Virtual Pin di sana).  Kami membuat perakitan akhir, mengisi peralatan di FPGA.  Itu saja.  Kami telah menyelesaikan peralatan, buka bagian perangkat lunak. <br><br><h2>  Kami menyiapkan BSP untuk lingkungan kami </h2><br>  Untuk perubahan, mari buat proyek berdasarkan templat bukan dari <b>Hello World Small</b> , tetapi dari <b>Memory Test Small</b> : <br><br><img src="https://habrastorage.org/webt/fh/bf/zj/fhbfzjbc6dqxyirgnhffs5nmzmw.png"><br><br>  Ketika itu dibuat, buka editor BSP.  Seperti biasa, hal pertama yang kami lakukan adalah mematikan pemeriksaan SysID dan mengizinkan penggunaan C ++ (meskipun kali ini saya tidak akan mengubah jenis file, tetapi sudah menjadi kebiasaan bagi saya): <br><br><img src="https://habrastorage.org/webt/ro/z3/4m/roz34m7na_mx3tzwawyu98qrrgs.png"><br><br>  Tetapi hal terpenting yang harus kita perbaiki pada tab <b>Skrip Linker</b> .  Otomasi mengakui bahwa bus instruksi hanya pergi ke memori <b>CodeMemory</b> , sehingga ia menempatkan bagian kode (disebut <b>.text</b> ) dalam memori <b>CodeMemory</b> .  Tetapi merawat kami, dia menempatkan segala sesuatu yang lain di wilayah data terbesar, yang terletak di <b>SDRAM</b> .  Bagaimana dia tahu bahwa kita tanpa ampun akan menghapus ingatan ini? <br><br><img src="https://habrastorage.org/webt/vo/tm/wq/votmwq4a0fiiu1irm0nud86hvwa.png"><br><br>  Kita harus secara manual, baris demi baris, mengganti wilayah dengan <b>DataMemory</b> (daftar pilihan akan muncul di sana, pemilihan harus diatur ulang di dalamnya).  Kita harus mendapatkan gambar ini: <br><br><img src="https://habrastorage.org/webt/-f/xf/gs/-fxfgskf00akgti0fab5r_nn-h0.png"><br><br><h2>  Eksperimen Program </h2><br>  Kami keluar dari editor, menghasilkan BSP, mencoba menjalankan program untuk debugging.  Kami mendapatkan teks berikut: <br><br><img src="https://habrastorage.org/webt/wd/wo/w2/wdwow2im-i13rjmekzoj2ada9ag.png"><br><br>  Jika saya menekan Enter, saya tidak berhasil.  Saya memasukkan sesuatu (ya bahkan spasi) dan kemudian menekan Enter.  Kemudian mereka bertanya kepada saya: <br><br><img src="https://habrastorage.org/webt/f8/or/rz/f8orrztu-bfgdmvrwfs5pmi6bag.png"><br><br>  Jam demi jam tidak mudah.  Dan alamat apa yang akan dimasukkan?  Anda dapat membuka Perancang Platform dan melihat nilainya di sana.  Tapi saya biasanya melihat file system.h referensi universal (path lengkap untuk proyek saya adalah C: \ Work \ CachePlay5 \ software \ MemoryTest_bsp \ system.h).  Di sana kami tertarik pada dua baris: <br><br><img src="https://habrastorage.org/webt/6s/jd/mn/6sjdmnjd-k-jpho1b21472e6xek.png"><br><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#define ALT_MODULE_CLASS_new_sdram_controller_0 altera_avalon_new_sdram_controller #define NEW_SDRAM_CONTROLLER_0_BASE 0x0 #define NEW_SDRAM_CONTROLLER_0_CAS_LATENCY 3 #define NEW_SDRAM_CONTROLLER_0_CONTENTS_INFO #define NEW_SDRAM_CONTROLLER_0_INIT_NOP_DELAY 0.0 #define NEW_SDRAM_CONTROLLER_0_INIT_REFRESH_COMMANDS 2 #define NEW_SDRAM_CONTROLLER_0_IRQ -1 #define NEW_SDRAM_CONTROLLER_0_IRQ_INTERRUPT_CONTROLLER_ID -1 #define NEW_SDRAM_CONTROLLER_0_IS_INITIALIZED 1 #define NEW_SDRAM_CONTROLLER_0_NAME "/dev/new_sdram_controller_0" #define NEW_SDRAM_CONTROLLER_0_POWERUP_DELAY 100.0 #define NEW_SDRAM_CONTROLLER_0_REFRESH_PERIOD 15.625 #define NEW_SDRAM_CONTROLLER_0_REGISTER_DATA_IN 1 #define NEW_SDRAM_CONTROLLER_0_SDRAM_ADDR_WIDTH 0x18 #define NEW_SDRAM_CONTROLLER_0_SDRAM_BANK_WIDTH 2 #define NEW_SDRAM_CONTROLLER_0_SDRAM_COL_WIDTH 9 #define NEW_SDRAM_CONTROLLER_0_SDRAM_DATA_WIDTH 16 #define NEW_SDRAM_CONTROLLER_0_SDRAM_NUM_BANKS 4 #define NEW_SDRAM_CONTROLLER_0_SDRAM_NUM_CHIPSELECTS 1 #define NEW_SDRAM_CONTROLLER_0_SDRAM_ROW_WIDTH 13 #define NEW_SDRAM_CONTROLLER_0_SHARED_DATA 0 #define NEW_SDRAM_CONTROLLER_0_SIM_MODEL_BASE 0 #define NEW_SDRAM_CONTROLLER_0_SPAN 33554432 #define NEW_SDRAM_CONTROLLER_0_STARVATION_INDICATOR 0</code> </pre> <br></div></div><br>  di mana desimal 33554432 sama dengan hex 0x2000000.  Oleh karena itu, jawaban saya dan hasil pekerjaan harus terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/4a/uq/tz/4auqtz8lgb-ql61btoxiqbskzfk.png"><br><br>  Bagus, tetapi ini tidak baik untuk tes harian.  Saya menulis ulang fungsi <b>utama</b> seperti ini: <br><br><pre> <code class="plaintext hljs">int main(void) { int step = 0; while (1) { if (step++%100 == 0) { alt_printf ("."); } if (MemTestDevice(NEW_SDRAM_CONTROLLER_0_BASE, NEW_SDRAM_CONTROLLER_0_SPAN)!=0) { printf ("*"); } } return (0); }</code> </pre><br>  Titik-titik menunjukkan bahwa program tidak "membeku".  Jika ada kesalahan, tanda bintang akan ditampilkan.  Untuk reliabilitas, Anda dapat menempatkan breakpoint pada outputnya, lalu jangan tidur. <br><br>  Benar, poin "kiri" naik dari suatu tempat.  Ternyata mereka ditampilkan di dalam fungsi <b>MemTestDevice ()</b> .  Di sana saya menghapus kesimpulan mereka.  Tes berhasil.  Sistem yang dihasilkan dapat digunakan, setidaknya untuk kebutuhan internal (yaitu, pengembangan tersebut dilakukan di bawah kompleks Redd). <br><br><h2>  Memeriksa kinerja sistem </h2><br>  Tapi saya sudah terbiasa dengan fakta bahwa ketika bekerja dengan peralatan Anda tidak bisa mempercayai apa pun.  Semuanya harus diperiksa dengan cermat.  Mari kita pastikan bahwa kita bekerja pada frekuensi dua kali lipat dibandingkan artikel sebelumnya.  Tambahkan fungsi MagicFunction1 () yang terkenal. <br><br><div class="spoiler">  <b class="spoiler_title">Biarkan saya mengingatkan Anda bagaimana penampilannya.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); }</code> </pre><br></div></div><br>  Kami akan memanggilnya dari <b>main ()</b> , kami akan menangkap pulsa pada osiloskop, tetapi kali ini kami akan memperhatikan tidak hanya keindahannya, tetapi juga pada frekuensinya (izinkan saya mengingatkan Anda bahwa setiap drop setidaknya naik, bahkan turun adalah satu perintah, sehingga Anda dapat mengukur jarak antara tetesan ) <br><br><img src="https://habrastorage.org/webt/sm/pt/xf/smptxfb1x4sub0-v-6lbu7wkdpy.png"><br><br>  Hanya 50 megahertz.  Apakah frekuensinya benar-benar tidak meningkat?  Bandingkan dengan frekuensi dari kode yang dikembangkan saat menulis artikel terakhir, dan kami memahami bahwa semuanya beres.  Hanya saja, unit pio biasa membutuhkan 2 siklus clock per output ke port (dalam home-made saya mendapat 1 jam, tapi di sini cukup bagi kami untuk memastikan bahwa kinerja sistem berlipat ganda). <br><br><img src="https://habrastorage.org/webt/w3/in/uo/w3inuobmvzdoa7pebgadrjigute.png"><br><br><h2>  Kesimpulan </h2><br>  Alih-alih menggunakan osilator frekuensi tetap, kami belajar cara menggunakan unit PLL khusus.  Benar, konstanta yang terdeteksi dimaksudkan untuk frekuensi 100 MHz, tetapi semua orang dapat menyesuaikannya dengan frekuensi lain baik menggunakan perhitungan terkenal, atau dengan coba-coba.  Kami juga memperkuat keterampilan menciptakan sistem prosesor yang optimal dan memastikan bahwa memori pada frekuensi yang lebih tinggi bekerja secara stabil, dan frekuensinya benar-benar meningkat. <br><br>  Secara umum, kita sudah dapat menghasilkan segala hal komputasi, kita bahkan dapat bertukar dengan prosesor sentral, tetapi prosesor pusat kompleks akan mengatasi perhitungan sepele lebih efisien.  FPGA ditambahkan ke Redd untuk mengimplementasikan antarmuka berkecepatan tinggi atau menangkap arus informasi (well, atau play).  Kami telah menguasai dasar-dasar mendesain, kami telah belajar bagaimana memberikan kinerja yang kurang lebih tinggi.  Saatnya untuk terus bekerja dengan antarmuka, yang akan kita lakukan di artikel selanjutnya.  Lebih tepatnya, satu set artikel, memperhatikan aturan "satu artikel - satu hal." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469985/">https://habr.com/ru/post/id469985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469967/index.html">Struktur data untuk penyimpanan grafik: review dari yang sudah ada dan dua "hampir baru"</a></li>
<li><a href="../id469975/index.html">Jalan Santiago dengan laptop</a></li>
<li><a href="../id469977/index.html">Bagaimana tiga teman sekelas menjadi mitra Facebook - Cerita Revealbot</a></li>
<li><a href="../id469979/index.html">Rekaman laporan dari mitap iOS kedua Redmadrobot</a></li>
<li><a href="../id469983/index.html">Bagaimana cara membuat strategi untuk mengalahkan penuaan?</a></li>
<li><a href="../id469987/index.html">20 Perusahaan Pengembangan Pasar Terbaik Dari Seluruh Dunia</a></li>
<li><a href="../id469989/index.html">C # Regex dalam contoh</a></li>
<li><a href="../id469991/index.html">Kami memproses pesanan dari toko online menggunakan RabbitMQ dan TypeScript</a></li>
<li><a href="../id469995/index.html">Python SAX parser vs python DOM parser. Parsim FIAS-rumah</a></li>
<li><a href="../id469997/index.html">Berita utama apa yang paling mungkin menarik perhatian atau analisis HabraHabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>