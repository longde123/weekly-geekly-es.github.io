<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 ⬅️ 👨🏿‍🤝‍👨🏾 AnyStub, bibliothèque de stub de connexion Java 💅 👨🏿‍🔬 👨🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contrairement à de nombreuses plates-formes, Java souffre d'un manque de bibliothèques de stub de connexion. Si vous êtes dans ce monde depuis longtem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AnyStub, bibliothèque de stub de connexion Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450958/"><p> Contrairement à de nombreuses plates-formes, Java souffre d'un manque de bibliothèques de stub de connexion.  Si vous êtes dans ce monde depuis longtemps, vous devriez probablement être familier avec WireMock, Betamax ou même Spock.  De nombreux développeurs dans les tests utilisent Mockito pour décrire le comportement des objets, DataJpaTest avec une base de données h2 locale, tests Cucumber.  Aujourd'hui, vous rencontrerez une alternative légère qui vous aidera à faire face aux différents problèmes que vous pourriez rencontrer en utilisant ces approches.  En particulier, anyStub essaie de résoudre les problèmes suivants: </p><br><ul><li>  simplifier la configuration de l'environnement de test </li><li>  automatiser la collecte de données pour les tests </li><li>  continuez à tester votre application et évitez de tester autre chose </li></ul><a name="habracut"></a><br><h2 id="chto-takoe-anystub-i-kak-eto-rabotaet">  Qu'est-ce qu'anyStub et comment ça marche </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AnyStub encapsule</a> les appels de fonction, essayant de trouver les appels correspondants qui ont déjà été enregistrés.  Deux choses peuvent se produire avec ceci: </p><br><ul><li>  s'il y a un appel correspondant, anyStub restaure le résultat enregistré associé à cet appel et le renvoie </li><li>  s'il n'y a pas d'appel correspondant et que l'accès au système externe est autorisé, anyStub fera cet appel, enregistrera ce résultat et le renverra </li></ul><br><p>  Dès la sortie de la boîte, anyStub fournit des wrappers pour le client http d'Apache HttpClient pour créer des stubs pour les requêtes http et plusieurs interfaces à partir de javax.sql. * Pour les connexions DB.  Vous disposez également d'une API pour créer des stubs pour d'autres connexions. </p><br><p>  AnyStub est une bibliothèque de classes simple et ne nécessite pas de configuration spéciale de votre environnement.  Cette bibliothèque est destinée à travailler avec des applications à démarrage par ressort et vous obtiendrez le maximum d'avantages en suivant ce chemin.  Vous pouvez l'utiliser en dehors de Spring, dans des applications Java simples, mais vous devrez certainement faire un travail supplémentaire.  La description suivante se concentre sur le test des applications Spring-Boot. </p><br><p>  Regardons les tests d'intégration.  Il s'agit de la manière la plus excitante et la plus complète de tester votre système.  En fait, Spring-boot et JUnit font presque tout pour vous lorsque vous écrivez des annotations magiques: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span></code> </pre> <br><p>  À l'heure actuelle, les tests d'intégration sont sous-estimés et sont utilisés dans une mesure limitée, et certains développeurs les évitent.  Cela est principalement dû à la préparation et à la maintenance fastidieuses des tests ou à la nécessité d'une configuration spéciale de l'environnement sur les serveurs de build. </p><br><p>  Avec anyStub, vous n'avez pas à paralyser le contexte printanier.  Au lieu de cela, garder le contexte proche de la configuration de production est simple et direct. </p><br><p>  Dans cet exemple, nous verrons comment connecter anyStub à un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Consuming a RESTful Web Service à</a> partir du manuel de Pivotal. </p><br><p>  Connexion d'une bibliothèque via pom.xml </p><br><pre> <code class="java hljs"> &lt;dependency&gt; &lt;groupId&gt;org.anystub&lt;/groupId&gt; &lt;artifactId&gt;anystub&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">0.2</span></span>.27&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;</code> </pre> <br><p>  L'étape suivante consiste à modifier le contexte du ressort. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.anystub.http.StubHttpClient; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.http.client.HttpClient; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.http.impl.client.HttpClientBuilder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.web.client.RestTemplateBuilder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.web.client.RestTemplateCustomizer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.annotation.Bean; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.annotation.Configuration; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.client.HttpComponentsClientHttpRequestFactory; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.client.RestTemplate; <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RestTemplateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">builder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestTemplateCustomizer restTemplateCustomizer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestTemplateCustomizer() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestTemplate restTemplate)</span></span></span><span class="hljs-function"> </span></span>{ HttpClient real = HttpClientBuilder.create().build(); StubHttpClient stubHttpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubHttpClient(real); HttpComponentsClientHttpRequestFactory requestFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpComponentsClientHttpRequestFactory(); requestFactory.setHttpClient(stubHttpClient); restTemplate.setRequestFactory(requestFactory); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestTemplateBuilder(restTemplateCustomizer); } }</code> </pre> <br><p>  Cette modification ne modifie pas les relations de composants dans l'application, mais remplace uniquement l'implémentation d'une interface unique.  Cela nous renvoie au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de substitution de Barbara Lisk</a> .  Si la conception de votre application ne la viole pas, cette substitution ne violera pas la fonctionnalité. </p><br><p>  Tout est prêt.  Ce projet comprend déjà un test. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RestTemplate restTemplate; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contextLoads</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertThat(restTemplate).isNotNull(); } }</code> </pre> <br><p>  Ce test est vide, mais il exécute déjà le contexte de l'application.  <strong>Le plaisir commence ici</strong> .  Comme nous l'avons dit ci-dessus, le contexte d'application dans le test coïncide avec le contexte de travail dans lequel le CommandLineRunner est créé dans lequel la requête http au système externe est exécutée. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger log = LoggerFactory.getLogger(Application.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RestTemplate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestTemplateBuilder builder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder.build(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CommandLineRunner </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestTemplate restTemplate)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args -&gt; { Quote quote = restTemplate.getForObject( <span class="hljs-string"><span class="hljs-string">"https://gturnquist-quoters.cfapps.io/api/random"</span></span>, Quote.class); log.info(quote.toString()); }; } }</code> </pre> <br><p>  Cela suffit pour démontrer le fonctionnement de la bibliothèque.  Après avoir démarré les tests pour la première fois, vous trouverez le nouveau <code>complete/src/test/resources/anystub/stub.yml</code> . </p><br><pre> <code class="plaintext hljs">request0: exception: [] keys: [GET, HTTP/1.1, 'https://gturnquist-quoters.cfapps.io/api/random'] values: [HTTP/1.1, '200', OK, 'Content-Type: application/json;charset=UTF-8', 'Date: Thu, 25 Apr 2019 23:04:49 GMT', 'X-Vcap-Request-Id: 5ffce9f3-d972-4e95-6b5c-f88f9b0ae29b', 'Content-Length: 177', 'Connection: keep-alive', '{"type":"success","value":{"id":3,"quote":"Spring has come quite a ways in addressing developer enjoyment and ease of use since the last time I built an application using it."}}']</code> </pre> <br><p>  Qu'est-il arrivé?  spring-boot a intégré RestTemplateBuilder à partir de la configuration de test dans l'application.  Cela a conduit l'application à travailler sur l'implémentation du stub du client http.  StubHttpClient a intercepté la demande, n'a pas trouvé le fichier de raccord, a exécuté la demande, a enregistré le résultat dans un fichier et a renvoyé le résultat récupéré à partir du fichier. </p><br><p>  A partir de maintenant, vous pouvez exécuter ce test sans connexion Internet et cette demande sera réussie.  <code>restTemplate.getForObject()</code> renverra le même résultat.  Vous pouvez compter sur ce fait dans vos futurs tests. </p><br><p>  Vous pouvez trouver toutes les modifications décrites sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><p>  En fait, nous n'avons toujours pas créé un seul test.  Avant d'écrire des tests, voyons comment cela fonctionne avec les bases de données. </p><br><p>  Dans cet exemple, nous allons ajouter un test d'intégration à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Accès</a> aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">données relationnelles à l'aide de JDBC avec Spring à</a> partir du didacticiel Pivotal. </p><br><p>  La configuration de test pour ce cas ressemble à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.anystub.jdbc.StubDataSource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.h2.jdbcx.JdbcDataSource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.annotation.Bean; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.context.annotation.Configuration; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.sql.DataSource; <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ JdbcDataSource ds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JdbcDataSource(); ds.setURL(<span class="hljs-string"><span class="hljs-string">"jdbc:h2:./test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StubDataSource(ds); } }</code> </pre> <br><p>  Ici, une source de données régulière vers une base de données externe est créée et encapsulée avec une implémentation de stub - la classe StubDataSource.  Spring-boot l'intègre dans son contexte.  Nous devons également créer au moins un test pour exécuter le contexte Spring dans le test. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.anystub.AnyStubId; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.Test; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.runner.RunWith; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.boot.test.context.SpringBootTest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.test.context.junit4.SpringRunner; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> org.junit.Assert.*; <span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-meta"><span class="hljs-meta">@AnyStubId</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  Il s'agit là encore d'un test vide - sa seule tâche est d'exécuter le contexte de l'application.  Nous voyons ici une annotation très importante <code>@AnystubId</code> , mais elle ne sera pas encore impliquée. </p><br><p>  Après la première exécution, vous trouverez un nouveau <code>src/test/resources/anystub/stub.yml</code> qui inclut tous les appels de base de données.  Vous serez surpris de voir comment le printemps fonctionne en arrière-plan avec les bases de données.  Notez que de nouvelles exécutions du test n'aboutiront pas à un véritable accès à la base de données.  Si vous supprimez test.mv.db, il n'apparaîtra pas après des exécutions répétées des tests.  L'ensemble complet des modifications peut être consulté sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><p>  Pour résumer.  avec anyStub: </p><br><ul><li>  vous n'avez pas besoin de configurer spécifiquement un environnement de test </li><li>  les tests sont effectués avec des données réelles </li><li>  la première exécution des tests prouve vos hypothèses et enregistre les données de test, les suivantes vérifient que le système ne s'est pas dégradé </li></ul><br><p>  Vous avez probablement des questions: comment cela couvre-t-il les cas où la base de données n'existe pas encore, que faire avec les tests négatifs et la gestion des exceptions.  Nous y reviendrons, mais d'abord, nous traiterons de l'écriture de tests simples. </p><br><p>  Nous expérimentons maintenant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consommation d'un service Web RESTful</a> .  Ce projet ne contient pas de composants pouvant être testés.  Deux classes sont créées ci-dessous, qui devraient représenter deux couches d'une conception d'architecture. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.client.RestTemplate; <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RestTemplate restTemplate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProvider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestTemplate restTemplate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.restTemplate = restTemplate; } <span class="hljs-function"><span class="hljs-function">Quote </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restTemplate.getForObject( <span class="hljs-string"><span class="hljs-string">"https://gturnquist-quoters.cfapps.io/api/random"</span></span>, Quote.class); } }</code> </pre> <br><p>  DataProvider donne accès aux données dans <del>  volatile </del>  système externe. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DataProvider dataProvider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataProvider dataProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dataProvider = dataProvider; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataProvider.provideData().getValue().getQuote().length(); } }</code> </pre> <br><p>  DataProcessor traitera les données d'un système externe. </p><br><p>  Nous avons l'intention de tester le <code>DataProcessor</code> .  Il est nécessaire de tester l'exactitude de l'algorithme de traitement et de protéger le système contre la dégradation des changements futurs. </p><br><p>  Pour atteindre ces objectifs, vous pouvez envisager de créer un objet maquette DataProvider avec un ensemble de données et de le transmettre au constructeur DataProcessor dans les tests.  Une autre façon pourrait être de décomposer le DataProcessor pour mettre en évidence le traitement de la classe Quote.  Ensuite, une telle classe est facile à tester à l'aide de tests unitaires (c'est sûrement la méthode recommandée dans les livres respectés sur le code propre).  Essayons d'éviter les changements de code et l'invention des données de test et écrivons simplement un test. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataProcessorTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DataProcessor dataProcessor; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-meta"><span class="hljs-meta">@AnyStubId</span></span>(filename = <span class="hljs-string"><span class="hljs-string">"stub"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDataTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertEquals(<span class="hljs-number"><span class="hljs-number">131</span></span>, dataProcessor.processData()); } }</code> </pre> <br><p>  Il est temps de parler de l'annotation @AnystubId.  Cette annotation permet de gérer et de contrôler les fichiers de raccord dans les tests.  Il peut être utilisé avec une classe de test ou sa méthode.  Cette annotation configure un fichier de raccord individuel pour la zone correspondante.  Si une zone est simultanément couverte par des annotations au niveau de la classe et de la méthode, l'annotation de la méthode est prioritaire.  Cette annotation a le paramètre filename, qui définit le nom du fichier de raccord.  l'extension ".yml" est ajoutée automatiquement si elle est omise.  En exécutant ce test, vous <strong>ne</strong> trouverez <strong>pas de</strong> nouveau fichier.  Le <code>src/test/resources/anystub/stub.yml</code> a déjà été créé précédemment et ce test le réutilisera.  Nous avons obtenu le numéro 131 de ce talon en analysant le résultat de la requête. </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-meta"><span class="hljs-meta">@AnyStubId</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDataTest2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertEquals(<span class="hljs-number"><span class="hljs-number">131</span></span>, dataProcessor.processData()); Base base = getStub(); assertEquals(<span class="hljs-number"><span class="hljs-number">1</span></span>, base.times(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>)); assertTrue(base.history().findFirst().get().matchEx_to(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">".*gturnquist-quoters.cfapps.io.*"</span></span>)); }</code> </pre> <br><p>  Dans ce test, l'annotation @AnyStubId apparaît sans le paramètre de nom de fichier.  Dans ce cas, le <code>src/test/resources/anystubprocessDataTest2.yml</code> .  Le nom du fichier est construit à partir du nom de la fonction (classe) + ".yml".  Une fois que anyStub crée un nouveau fichier pour ce test, vous devez effectuer un véritable appel système.  Et c'est notre chance que le nouveau devis ait la même longueur.  Les deux dernières vérifications montrent comment tester le comportement de l'application.  Il est à votre disposition: sélection de requêtes par paramètres ou parties de paramètres et comptage du nombre de requêtes.  Il existe plusieurs variantes des heures <em>et des</em> fonctions de <em>correspondance</em> qui peuvent être trouvées dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-meta"><span class="hljs-meta">@AnyStubId</span></span>(requestMode = RequestMode.rmTrack) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processDataTest3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ assertEquals(<span class="hljs-number"><span class="hljs-number">79</span></span>, dataProcessor.processData()); assertEquals(<span class="hljs-number"><span class="hljs-number">79</span></span>, dataProcessor.processData()); assertEquals(<span class="hljs-number"><span class="hljs-number">168</span></span>, dataProcessor.processData()); assertEquals(<span class="hljs-number"><span class="hljs-number">79</span></span>, dataProcessor.processData()); Base base = getStub(); assertEquals(<span class="hljs-number"><span class="hljs-number">4</span></span>, base.times(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>)); }</code> </pre> <br><p>  Dans ce test, @AnyStubId apparaît avec le nouveau paramètre requestMode.  Il vous permet de gérer les autorisations pour les fichiers de raccord.  Il y a deux aspects à contrôler: la recherche de fichiers et l'autorisation d'appeler un système externe. </p><br><p>  <code>RequestMode.rmTrack</code> définit les règles suivantes: si le fichier vient d'être créé, toutes les demandes sont envoyées au système externe et sont écrites dans le fichier avec les réponses, qu'il y ait ou non une demande identique dans le fichier (les doublons dans le fichier sont autorisés).  Si, avant d'exécuter les tests, le fichier de raccord existe, les demandes au système externe sont interdites.  Les appels sont attendus exactement dans la même séquence.  Si la demande suivante ne correspond pas à la demande du fichier, une exception est levée. </p><br><p>  <code>RequestMode.rmNew</code> ce mode est activé par défaut.  Chaque demande est recherchée dans le fichier de raccord.  Si une demande correspondante est trouvée - le résultat correspondant est restauré à partir du fichier, la demande au système externe est reportée.  Si la demande n'est pas trouvée, le système externe est demandé, le résultat est enregistré dans un fichier.  Demandes en double dans le fichier - ne se produisent pas. </p><br><p>  <code>RequestMode.rmNone</code> Chaque demande est recherchée dans un fichier de raccord.  Si une requête correspondante est trouvée, son résultat est restauré à partir du fichier.  Si le test génère une demande qui n'est pas dans le fichier, une exception est levée. </p><br><p>  <code>RequestMode.rmAll</code> avant la première demande, le fichier de raccord est effacé.  Toutes les demandes sont écrites dans le fichier (les doublons dans le fichier sont autorisés).  Vous pouvez utiliser ce mode si vous souhaitez regarder le travail de connexion. </p><br><p>  <code>RequestMode.rmPassThrough</code> toutes les demandes sont envoyées directement au système externe, en contournant le talon d'implémentation. </p><br><p>  Ces modifications sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub.</a> </p><br><h1 id="chto-eschyo">  Quoi d'autre? </h1><br><p>  Nous avons vu comment anyStub enregistre les réponses.  Si une exception est levée lors de l'accès à un système externe, anyStub l'enregistrera et la lira lors des requêtes suivantes. </p><br><p>  Souvent, des exceptions sont levées par les classes de niveau supérieur, tandis que les classes de connexion reçoivent une réponse valide (probablement avec un code d'erreur).  Dans ce cas, anyStub est responsable de reproduire la réponse même avec le code d'erreur, et les classes de niveau supérieur lèveront également des exceptions pour vos tests. </p><br><p>  Ajoutez des fichiers de raccord au référentiel. </p><br><p>  N'ayez pas peur de supprimer et d'écraser des fichiers de raccord. </p><br><p>  Gérez judicieusement les fichiers de raccord.  Vous pouvez réutiliser un fichier dans plusieurs tests ou fournir un fichier individuel pour chaque test.  Profitez de cette opportunité pour vos besoins.  Mais généralement, l'utilisation d'un seul fichier avec différents modes d'accès est une mauvaise idée. </p><br><p>  Ce sont toutes les principales fonctionnalités de anyStub. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450958/">https://habr.com/ru/post/fr450958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450948/index.html">MU-MIMO: l'un des algorithmes d'implémentation</a></li>
<li><a href="../fr450950/index.html">Dart Streams Basics</a></li>
<li><a href="../fr450952/index.html">Indice moyen et antibank</a></li>
<li><a href="../fr450954/index.html">Comment nous avons appris à exploiter Java dans Docker</a></li>
<li><a href="../fr450956/index.html">Comparaison des COB industriels: ISIM vs. Kics</a></li>
<li><a href="../fr450962/index.html">Pompes à insuline, micropuces inviolables et radio définie par logiciel</a></li>
<li><a href="../fr450964/index.html">Nouvelle bibliothèque intrinsèque SIMD x86 - Débogage immintrin</a></li>
<li><a href="../fr450966/index.html">Enregistrement de vidéo à partir d'un vieil ordinateur - méthodes de LGR</a></li>
<li><a href="../fr450970/index.html">Comment vraiment comparer les prix Apple aux États-Unis et en Russie. Expérience personnelle</a></li>
<li><a href="../fr450972/index.html">Comment organiser un studio photo? Cas de Bolshakova Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>