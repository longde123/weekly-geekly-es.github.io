<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé´ ‚òéÔ∏è üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ √úberpr√ºfen des Quellcodes von Roslyn üßëüèæ‚Äçü§ù‚Äçüßëüèæ ü§ûüèª üë©‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit kehren wir zu Projekten zur√ºck, die wir zuvor mit PVS-Studio getestet und Artikel dar√ºber geschrieben haben. Daf√ºr gibt es zwei Gr√ºnd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen des Quellcodes von Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio gegen Roslyn"></div><br>  Von Zeit zu Zeit kehren wir zu Projekten zur√ºck, die wir zuvor mit PVS-Studio getestet und Artikel dar√ºber geschrieben haben.  Daf√ºr gibt es zwei Gr√ºnde.  Erstens, um zu verstehen, wie viel besser unser Analysator geworden ist.  Zweitens, um zu verfolgen, ob die Autoren des Projekts auf unseren Artikel sowie auf den Fehlerbericht geachtet haben, den wir ihnen normalerweise zur Verf√ºgung stellen.  Nat√ºrlich k√∂nnen Fehler ohne unsere Teilnahme korrigiert werden.  Aber es ist immer sch√∂n, wenn genau unsere Bem√ºhungen dazu beitragen, ein Projekt besser zu machen.  Roslyn war keine Ausnahme.  Ein fr√ºherer √úbersichtsartikel zu diesem Projekt stammt aus dem 23. Dezember 2015.  Dies ist eine ziemlich lange Zeit, angesichts des Weges, den unser Analysator in dieser Zeit in seiner Entwicklung zur√ºckgelegt hat.  F√ºr uns pers√∂nlich ist Roslyn auch deshalb von zus√§tzlichem Interesse, weil der Kern des C # -Analysators PVS-Studio darauf basiert.  Daher sind wir sehr an der Qualit√§t des Codes f√ºr dieses Projekt interessiert.  Wir werden einen zweiten Check arrangieren und herausfinden, was neu und interessant ist (aber hoffen wir, dass nichts Bedeutendes), was PVS-Studio dort finden kann. <br><a name="habracut"></a><br>  Roslyn (oder die .NET Compiler-Plattform) ist wahrscheinlich vielen unserer Leser bekannt.  Kurz gesagt, es handelt sich um eine Reihe von Open Source-Compilern und APIs f√ºr die Codeanalyse f√ºr die C # - und Visual Basic .NET-Sprachen von Microsoft.  Der Quellcode f√ºr das Projekt ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar. <br><br>  Ich werde diese Plattform nicht detailliert beschreiben, aber ich w√ºrde jedem Interessierten einen Artikel meines Kollegen Sergey Vasiliev empfehlen: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in Roslyn. Verwenden statischer Analysewerkzeuge zur Entwicklung</a> ."  In diesem Artikel erfahren Sie nicht nur, welche Funktionen die Roslyn-Architektur bietet, sondern auch, wie genau wir diese Plattform verwenden. <br><br>  Wie ich bereits erw√§hnt habe, sind mehr als drei Jahre vergangen, seit mein Kollege Andrei Karpov den letzten Artikel √ºber den Roslyn-Check " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neujahrsver√∂ffentlichung von PVS-Studio 6.00: Check Roslyn</a> " geschrieben hat.  In dieser Zeit hat der C # PVS-Studio-Analysator viele neue Funktionen erhalten.  Im Allgemeinen war Andreys Artikel eine Art ‚ÄûTestball‚Äú, da der C # -Analysator erst damals zu PVS-Studio hinzugef√ºgt wurde.  Trotzdem gelang es Roslyn selbst dann in einem bedingungslos hochwertigen Projekt, interessante Fehler zu finden.  Was hat sich im Analysator f√ºr C # -Code bisher ge√§ndert, was m√∂glicherweise eine tiefere Analyse erm√∂glicht? <br><br>  In der Vergangenheit haben sich sowohl der Analysatorkern als auch die Infrastruktur entwickelt.  Unterst√ºtzung f√ºr Visual Studio 2017 und Roslyn 2.0 sowie eine umfassende Integration in MSBuild wurden hinzugef√ºgt.  Weitere Informationen zu unserem Ansatz zur Integration in MSBuild und zu den Gr√ºnden, aus denen wir ihn akzeptiert haben, finden Sie in dem Artikel meines Kollegen Pavel Yeremeyev: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist die Verwendung vorgefertigter L√∂sungen nicht so einfach, wie es scheint auf einen Blick</a> . " <br><br>  Jetzt arbeiten wir aktiv an der Umstellung auf Roslyn 3.0 nach demselben Schema, das wir urspr√ºnglich f√ºr Visual Studio 2017 unterst√ºtzt haben, dh √ºber unser eigenes Toolset, das im PVS-Studio-Distributionskit mit einem ‚ÄûStub‚Äú in Form einer leeren MSBuild.exe-Datei enthalten ist.  Trotz der Tatsache, dass es wie eine ‚ÄûKr√ºcke‚Äú aussieht (die MSBuild-API ist aufgrund der geringen Portabilit√§t der Bibliotheken nicht sehr benutzerfreundlich f√ºr die Wiederverwendung in Third-Patry-Projekten), hat uns dieser Ansatz bereits geholfen, mehrere Roslyn-Updates w√§hrend der Lebensdauer von Visual Studio 2017 relativ schmerzlos erneut zu erleben. und jetzt, obwohl mit vielen √úberlagerungen, √ºberleben Sie das Upgrade auf Visual Studio 2019 und behalten die volle Abw√§rtskompatibilit√§t und Leistung auf Systemen mit √§lteren Versionen von MSBuild bei. <br><br>  Der Analysatorkern hat auch eine Reihe von Verbesserungen erfahren.  Eine der Hauptinnovationen ist eine umfassende interprozedurale Analyse, die die Eingabe- und Ausgabewerte der Methoden ber√ºcksichtigt und in Abh√§ngigkeit von diesen Parametern die Erreichbarkeit der Ausf√ºhrungszweige und R√ºckgabepunkte ber√ºcksichtigt. <br><br>  Die Aufgabe, Parameter innerhalb der Methoden zu verfolgen, ist bereits kurz vor dem Abschluss, w√§hrend automatische Anmerkungen f√ºr die dortigen Parameter beibehalten werden (z. B. eine potenziell gef√§hrliche Dereferenzierung).  Auf diese Weise kann bei jeder Diagnose mithilfe des Datenflussmechanismus gef√§hrliche Situationen ber√ºcksichtigt werden, die beim √úbergeben eines Parameters an eine Methode auftreten.  Bisher wurde bei der Analyse derart gef√§hrlicher Orte keine Warnung generiert, da wir nicht alle m√∂glichen Eingabewerte f√ºr eine solche Methode kennen konnten.  Jetzt k√∂nnen wir die Gefahr erkennen, da diese Eingabeparameter an allen Stellen, an denen diese Methode aufgerufen wird, ber√ºcksichtigt werden. <br><br>  Hinweis: Sie k√∂nnen sich mit den wichtigsten Analysemechanismen wie Datenfluss und anderen aus dem Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im PVS-Studio Code Analyzer zum Auffinden von Fehlern und potenziellen Schwachstellen verwendete Technologien</a> " vertraut machen. <br><br>  Die interprozedurale Analyse in PVS-Studio C # ist weder durch Eingabeparameter noch durch die Tiefe begrenzt.  Die einzige Einschr√§nkung sind virtuelle Methoden in Klassen, die nicht wegen Vererbung geschlossen wurden und in Rekursion geraten (wir werden aufh√∂ren, wenn wir auf dem Stapel einen wiederholten Aufruf einer bereits berechneten Methode sehen).  Dar√ºber hinaus wird die rekursive Methode selbst letztendlich unter der Annahme berechnet, dass der R√ºckgabewert ihrer Selbstrekursion unbekannt ist. <br><br>  Eine weitere gro√üe Neuerung im C # -Analysator ist die M√∂glichkeit, einen potenziell Nullzeiger zu dereferenzieren.  Zuvor schwor der Analysator eine m√∂gliche Nullreferenzausnahme, wenn er sicher war, dass in allen Ausf√ºhrungszweigen der Wert der Variablen null sein w√ºrde.  Nat√ºrlich hat er sich manchmal geirrt, daher wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose zuvor als potenzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz bezeichnet</a> . <br><br>  Jetzt merkt sich der Analysator, dass die Variable in einem der Ausf√ºhrungszweige null sein kann (z. B. unter einer bestimmten Bedingung in if).  Wenn er den Zugriff auf eine solche Variable ohne √úberpr√ºfung sieht, erh√§lt er eine V3080-Nachricht, jedoch mit einer geringeren Wichtigkeit als wenn er in allen Zweigen null sieht.  In Kombination mit einer verbesserten interprozeduralen Analyse erm√∂glicht ein solcher Mechanismus das Auffinden sehr schwer zu erkennender Fehler.  Ein Beispiel ist eine lange Kette von Methodenaufrufen, mit denen Sie zuletzt nicht vertraut sind und die beispielsweise unter bestimmten Umst√§nden im Fang null zur√ºckgeben, aber Sie haben sich nicht davor gesch√ºtzt, weil Sie es einfach nicht wussten.  In diesem Fall schw√∂rt der Analysator nur, wenn er die Zuweisung von Null genau sieht.  Unserer Meinung nach unterscheidet dies unseren Ansatz qualitativ von einer solchen Innovation von C # 8.0 als nullbarem Referenztyp, die tats√§chlich darauf hinausl√§uft, bei jeder Methode Nullpr√ºfungen festzulegen.  Wir bieten eine Alternative an - nur dort zu pr√ºfen, wo wirklich null kommen kann, und unser Analysator kann jetzt nach solchen Situationen suchen. <br><br>  Fahren wir also unverz√ºglich mit der ‚ÄûNachbesprechung‚Äú fort und analysieren die Ergebnisse des Roslyn-Checks.  Schauen wir uns zun√§chst die Fehler an, die dank der oben beschriebenen Innovationen festgestellt wurden.  Im Allgemeinen wurden diesmal einige Warnungen f√ºr den Roslyn-Code ausgegeben.  Ich denke, dies liegt an der Tatsache, dass sich die Plattform sehr aktiv entwickelt (die Codebasis umfasst derzeit etwa 2.770.000 Codezeilen, ausgenommen leere), und wir haben dieses Projekt lange Zeit nicht analysiert.  Es gibt jedoch nicht so viele kritische Fehler, n√§mlich sie sind f√ºr den Artikel von Interesse.  Und ja, es gibt in Roslyn einige Tests, die ich wie √ºblich vom Testen ausgeschlossen habe. <br><br>  Ich beginne mit V3080-Fehlern mit mittlerer Kritikalit√§t, bei denen der Analysator einen m√∂glichen Zugriff √ºber eine Nullverbindung festgestellt hat, jedoch nicht in allen m√∂glichen F√§llen (Code-Verzweigungen). <br><br>  <b>M√∂gliche Null-Dereferenzierung - Mittel</b> <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  Betrachten Sie die √úberpr√ºfung der "aktuellen".  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Betrachten Sie die <i>GetNode-</i> Methode.  Der Analysator ist der Ansicht, dass der Zugriff per Nullreferenz im Zustand des <i>while-</i> Blocks m√∂glich ist.  Im Hauptteil des <i>while-</i> Blocks wird der <i>aktuellen</i> Variablen ein Wert zugewiesen - das Ergebnis der Ausf√ºhrung der <i>AsNode-</i> Methode.  Und dieser Wert ist in einigen F√§llen <i>null</i> .  Ein gutes Beispiel f√ºr eine interprozedurale Analyse in Aktion. <br><br>  Betrachten Sie nun einen √§hnlichen Fall, in dem die Interprozeduranalyse √ºber zwei Methodenaufrufe durchgef√ºhrt wurde. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie das Verzeichnis.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Die <i>Verzeichnisvariable</i> im Hauptteil der <i>ExpandFileNamePattern-</i> Methode <i>ruft</i> den Wert von der <i>GetDirectoryName (string)</i> -Methode ab.  Dies gibt wiederum das Ergebnis der √ºberladenen <i>GetDirectoryName-</i> Methode <i>(Zeichenfolge, Bool) zur√ºck</i> , deren Wert m√∂glicherweise <i>null ist</i> .  Da weiter im Hauptteil der <i>ExpandFileNamePattern-</i> Methode die <i>Verzeichnisvariable</i> verwendet wird, ohne zuvor auf <i>Nullgleichheit zu</i> pr√ºfen, k√∂nnen wir √ºber die Rechtm√§√üigkeit der Warnung durch den Analysator sprechen.  Dies ist ein m√∂glicherweise unsicheres Design. <br><br>  Ein weiterer Code mit Fehler V3080, genauer gesagt, sofort mit zwei Fehlern, die f√ºr eine Codezeile ausgegeben wurden.  Hier war keine interprozedurale Analyse erforderlich. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Die <i>Variablen</i> <i>spanStartLocation</i> und <i>spanEndLocationExclusive</i> sind vom Typ <i>nullable int</i> und werden mit <i>null</i> initialisiert.  Weiter im Code k√∂nnen ihnen Werte zugewiesen werden, jedoch nur, wenn bestimmte Bedingungen erf√ºllt sind.  In einigen F√§llen bleibt ihr Wert gleich <i>Null</i> .  Weiter im Code wird auf diese Variablen als Referenz zugegriffen, ohne vorher auf Nullgleichheit zu pr√ºfen, wie der Analysator anzeigt. <br><br>  Roslyn-Code enth√§lt einige solcher Fehler, mehr als 100. Oft ist das Muster dieser Fehler das gleiche.  Es gibt eine allgemeine Methode, die m√∂glicherweise <i>null</i> zur√ºckgibt.  Das Ergebnis dieser Methode wird an einer gro√üen Anzahl von Stellen verwendet, manchmal durch Dutzende von Zwischenmethodenaufrufen oder zus√§tzliche √úberpr√ºfungen.  Es ist wichtig zu verstehen, dass diese Fehler nicht schwerwiegend sind, aber m√∂glicherweise zum Zugriff √ºber einen Null-Link f√ºhren k√∂nnen.  Und solche Fehler zu erkennen ist sehr schwierig.  In einigen F√§llen sollten Sie daher in Betracht ziehen, den Code umzugestalten. In diesem Fall wird eine Ausnahme ausgel√∂st, wenn die Methode <i>null zur√ºckgibt</i> .  Andernfalls k√∂nnen Sie Ihren Code nur mit vollst√§ndigen √úberpr√ºfungen sichern, was ziemlich m√ºhsam und unzuverl√§ssig ist.  Nat√ºrlich sollte die Entscheidung in jedem Fall auf der Grundlage der Merkmale des Projekts getroffen werden. <br><br>  Hinweis  Es kommt vor, dass es derzeit keine Situationen (Eingabedaten) gibt, in denen die Methode <i>null</i> zur√ºckgibt und kein wirklicher Fehler vorliegt.  Ein solcher Code ist jedoch immer noch nicht zuverl√§ssig, da sich alles √§ndern kann, wenn √Ñnderungen am Code vorgenommen werden. <br><br>  Um das Thema mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080 zu schlie√üen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werfen</a> wir einen Blick auf die offensichtlichen Fehler mit dem hohen Konfidenzniveau, wenn der Zugriff √ºber einen Null-Link wahrscheinlicher oder sogar unvermeidlich ist. <br><br>  <b>M√∂gliche Null-Dereferenzierung - Hoch</b> <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Aufgrund eines Tippfehlers in der Bedingung (anstelle des von uns verwendeten Operators <i>||</i> <i>&amp;&amp;</i> ) funktioniert der Code nicht wie beabsichtigt, und auf die Variable <i>collectionType.Type</i> wird zugegriffen, wenn sie <i>null ist</i> .  Der Zustand muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  √úbrigens ist auch die zweite Variante der Ereignisentwicklung m√∂glich: Im ersten Teil werden die Bedingungen von den Operatoren <i>==</i> und <i>! =</i> <i>Verwechselt</i> .  Dann w√§re der korrigierte Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Diese Version des Codes ist weniger logisch, korrigiert aber auch den Fehler.  Die endg√ºltige Entscheidung liegt bei den Autoren des Projekts. <br><br>  Ein weiterer √§hnlicher Fehler. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberlegen Sie, ob Sie die Aktion √ºberpr√ºfen m√∂chten.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Beim Verfassen einer Nachricht f√ºr eine Ausnahme ist ein Fehler aufgetreten.  Gleichzeitig wird versucht, √ºber die <i>Aktionsvariable</i> , die offensichtlich <i>null</i> ist, auf die Eigenschaft <i>action.DisplayText</i> zuzugreifen. <br><br>  Und der letzte Fehler ist der V3080 High Level. <br><br>  V3080 M√∂gliche Null-Dereferenzierung.  √úberpr√ºfen Sie den Typ.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Die Methode ist klein, also gebe ich den gesamten Code.  Die Bedingung im <i>R√ºckgabeblock</i> ist falsch.  In einigen F√§llen ist es m√∂glich, beim Zugriff auf <i>type.FullName</i> eine <i>NullReferenceException</i> <i>auszul√∂sen</i> .  Ich benutze Klammern (sie werden das Verhalten hier nicht √§ndern), um die Situation zu kl√§ren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Auf diese Weise funktioniert dieser Code entsprechend der Priorit√§t der Operationen.  Wenn die Typvariable <i>null ist</i> , f√ºhren wir eine else-Pr√ºfung durch, bei der wir die Null- <i>Typreferenz verwenden</i> , um sicherzustellen, dass die Variable <i>targetTypeName</i> <i>null</i> ist.  Sie k√∂nnen den Code beispielsweise folgenderma√üen korrigieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Ich denke, hier k√∂nnen Sie die Untersuchung von V3080-Fehlern abschlie√üen und sehen, was der andere interessante PVS-Studio-Analysator im Roslyn-Code gefunden hat. <br><br>  <b>Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3005</a> Die Variable 'SourceCodeKind' wird sich selbst zugewiesen.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Aufgrund eines erfolglosen Variablennamens wurde im Konstruktor der <i>DynamicFileInfo-</i> Klasse ein Tippfehler gemacht.  Dem <i>Feld SourceCodeKind wird</i> ein eigener Wert zugewiesen, anstatt den Parameter <i>sourceCodeKind zu verwenden</i> .  Um die Wahrscheinlichkeit solcher Fehler zu minimieren, wird empfohlen, in solchen F√§llen das Unterstrichpr√§fix f√ºr Parameternamen zu verwenden.  Ich werde ein Beispiel f√ºr eine korrigierte Version des Codes geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Nachl√§ssigkeit</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3006</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schl√ºsselwort 'throw' k√∂nnte fehlen: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Unter bestimmten Bedingungen sollte der Destruktor eine Ausnahme ausl√∂sen. Dies ist jedoch nicht der Fall, und das Ausnahmeobjekt wird einfach erstellt.  Das Schl√ºsselwort <i>throw</i> wurde weggelassen.  Korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Das Problem, mit Destruktoren in C # zu arbeiten und Ausnahmen von ihnen auszul√∂sen, ist ein Thema f√ºr eine separate Diskussion, die den Rahmen dieses Artikels sprengt. <br><br>  <b>Wenn das Ergebnis nicht wichtig ist</b> <br><br>  F√ºr Methoden, die in allen F√§llen den gleichen Wert zur√ºckgeben, wurde eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009-</a> Warnungen empfangen.  Manchmal ist dies nicht kritisch oder der R√ºckkehrcode wird im aufrufenden Code einfach nicht √ºberpr√ºft.  Ich habe solche Warnungen verpasst.  Aber ein paar Code-Teile schienen mir verd√§chtig.  Ich werde einen von ihnen zitieren: <br><br>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die <i>TryExecuteCommand-</i> Methode gibt nur <i>true</i> und nichts als <i>true zur√ºck</i> .  Gleichzeitig ist der R√ºckgabewert an einigen √úberpr√ºfungen des aufrufenden Codes beteiligt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es ist schwer zu sagen, wie gef√§hrlich dieses Verhalten ist.  Wenn das Ergebnis jedoch nicht ben√∂tigt wird, kann es sinnvoll sein, den R√ºckgabetyp durch void zu ersetzen und minimale √Ñnderungen an der aufrufenden Methode vorzunehmen.  Dadurch wird der Code verst√§ndlicher und sicherer. <br><br>  Andere √§hnliche Warnungen: <br><br><ul><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  JsonRpcClient.cs 138 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'false' zur√ºckgibt.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  ObjectList.cs 173 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  ObjectList.cs 249 </li></ul><br>  <b>Nicht gepr√ºft</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Der Variablenwert ist vom Typ <i>NamingStylePreferences</i> .  Das Problem folgt dieser √úberpr√ºfung.  Selbst wenn die <i>Wertvariable</i> nicht null ist, garantiert dies nicht, dass die Typkonvertierung erfolgreich war und dass <i>valueToSerialize</i> keine <i>Null</i> enth√§lt.  Eine <i>NullReferenceException kann ausgel√∂st werden</i> .  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Und noch ein √§hnlicher Fehler. <br><br>  V3019 M√∂glicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schl√ºsselwort 'as' mit null verglichen.  √úberpr√ºfen Sie die Variablen 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Die Variable <i>columnState</i> ist vom Typ <i>ColumnState2</i> .  Das Ergebnis der Operation, die Variable <i>columnState2</i> , wird jedoch nicht weiter auf <i>null</i> gepr√ºft.  Stattdessen wird die Variable <i>columnState</i> mithilfe der bedingten <i>Null-</i> Anweisung √ºberpr√ºft.  Was ist die Gefahr dieses Codes?  Wie im vorherigen Beispiel kann die Typumwandlung mit dem Operator <i>as</i> fehlschlagen, und die Variable <i>columnState2</i> ist <i>null</i> , wodurch eine Ausnahme <i>ausgel√∂st</i> wird.  √úbrigens kann ein Tippfehler schuld sein.  Beachten Sie die Bedingung im <i>if-</i> Block.  Vielleicht <i>wollten</i> sie anstelle von <i>columnState? .Name columnState2? .Name</i> schreiben.  Dies ist sehr wahrscheinlich angesichts der eher ungl√ºcklichen Variablennamen <i>columnState und columnState2.</i> <br><br>  <b>Redundante Schecks</b> <br><br>  Eine ziemlich gro√üe Anzahl von Warnungen (√ºber 100) wurde f√ºr unkritische, aber m√∂glicherweise unsichere Konstruktionen ausgegeben, die mit redundanten √úberpr√ºfungen verbunden sind.  Zum Beispiel werde ich einen von ihnen geben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'navInfo == null' ist immer falsch.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Vielleicht gibt es hier keinen wirklichen Fehler.  Nur ein guter Grund, die Kombination der Technologien ‚ÄûInterprocedural Analysis + Data Flow Analysis‚Äú in Aktion zu demonstrieren.  Der Analysator ist der Ansicht, dass die zweite Pr√ºfung <i>navInfo == null</i> redundant ist.  <i>Zuvor</i> wird der Wert f√ºr die Zuweisung von <i>navInfo</i> von der <i>libraryService.NavInfoFactory.CreateForProject-</i> Methode abgerufen, die ein neues Objekt der <i>NavInfo-</i> Klasse erstellt und <i>zur√ºckgibt</i> .  Aber in keiner Weise <i>null</i> .  Die Frage ist, warum der Analysator keine Warnung f√ºr die erste Pr√ºfung <i>navInfo == null generiert hat</i> .  Daf√ºr gibt es eine Erkl√§rung.  Erstens, wenn sich herausstellt, dass die <i>Symbolvariable</i> <i>null ist</i> , bleibt der Wert von <i>navInfo</i> eine <i>Nullreferenz</i> .  Zweitens kann dieser Wert <i>null sein</i> , selbst wenn <i>navInfo</i> den Wert von der <i>libraryService.NavInfoFactory.CreateForSymbol-</i> Methode erh√§lt.  Die erste √úberpr√ºfung von <i>navInfo == null ist also</i> wirklich notwendig. <br><br>  <b>Nicht genug Schecks</b> <br><br>  Und jetzt ist die Situation umgekehrt.  F√ºr Code, auf den √ºber eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> zugegriffen werden konnte, wurden mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3042-</a> Warnungen empfangen.  Au√üerdem konnten nur ein oder zwei kleine Schecks alles reparieren. <br><br>  Stellen Sie sich einen interessanten Code vor, der zwei solche Fehler enth√§lt. <br><br>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'Empf√§nger'-Objekts Binder_Expressions.cs 7770 verwendet <br><br>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'Empf√§nger'-Objekts Binder_Expressions.cs 7776 verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Die <i>Empf√§ngervariable</i> kann <i>null sein</i> .  Der Autor des Codes wei√ü dies, weil er den bedingten <i>Nulloperator</i> in der Bedingung des <i>if-</i> Blocks verwendet, um auf den <i>Empf√§nger? .Syntax zuzugreifen</i> .  Weiter im Code wird der variable <i>Empf√§nger</i> ohne jegliche √úberpr√ºfung verwendet, um auf <i>Empf√§nger</i> zuzugreifen. Typ, <i>Empf√§nger</i> . <i>Syntax</i> und <i>Empf√§nger</i> . <i>HatErrors</i> .  Diese Fehler m√ºssen behoben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Sie m√ºssen auch sicherstellen, dass der <i>BoundConditionalReceiver-</i> Konstruktor das Abrufen von <i>Nullwerten</i> f√ºr seine Parameter unterst√ºtzt, oder zus√§tzliches Refactoring durchf√ºhren. <br><br>  Andere √§hnliche Fehler: <br><br><ul><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des Objekts 'includesType' SyntaxGeneratorExtensions_Negate.cs 240 verwendet </li><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li><li>  V3042 M√∂gliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden f√ºr den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li></ul><br>  <b>Fehler im Zustand</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3057</a> Die Funktion 'Teilzeichenfolge' k√∂nnte den Wert '-1' empfangen, w√§hrend ein nicht negativer Wert erwartet wird.  Untersuchen Sie das zweite Argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Wenn die <i>Doppelpunktvariable</i> 0 ist, was eine Bedingung im Code <i>zul√§sst</i> , <i>l√∂st</i> die <i>Substring-</i> Methode eine <i>ArgumentOutOfRangeException aus</i> .  Korrektur erforderlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Tippfehler ist m√∂glich</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3065 Der</a> Parameter 't2' wird im K√∂rper der Methode nicht verwendet.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Zwei Parameter werden an den Lambda-Ausdruck √ºbergeben: t1 und t2.  Es wird jedoch nur t1 verwendet.  Es sieht verd√§chtig aus, wenn man bedenkt, wie einfach es ist, Fehler bei der Verwendung von Variablen mit diesen Namen zu machen. <br><br>  <b>Nachl√§ssigkeit</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'TagsChanged', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Das <i>TagChanged-</i> Ereignis <i>wird</i> unsicher ausgel√∂st.  Zwischen der √úberpr√ºfung auf <i>Nullgleichheit</i> und dem Aufrufen eines Ereignisses haben sie m√∂glicherweise Zeit, sich von ihm abzumelden. Dann wird eine Ausnahme ausgel√∂st.  Dar√ºber hinaus werden im Hauptteil des <i>if-</i> Blocks unmittelbar vor dem Aufruf des Ereignisses einige andere Operationen ausgef√ºhrt.  Ich habe diesen Fehler "Unaufmerksamkeit" genannt, weil sie an anderen Stellen im Code mit diesem Ereignis genauer arbeiten, zum Beispiel wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Die Verwendung der optionalen <i>Handlervariablen</i> beseitigt das Problem.  In der <i>OnTextBufferChanged-</i> Methode m√ºssen <i>Sie</i> √Ñnderungen f√ºr denselben sicheren Vorgang mit dem Ereignis vornehmen. <br><br>  <b>Schnittpunkte</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3092 Bereichsschnittpunkte</a> sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Zum besseren Verst√§ndnis werde ich dieses Codefragment neu schreiben und die Konstantennamen durch ihre tats√§chlichen Werte ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Wahrscheinlich gibt es keinen wirklichen Fehler, aber der Zustand sieht seltsam aus.  Der zweite Teil ( <i>sonst wenn</i> ) wird nur f√ºr den Wertebereich von 2147483648 + 1 bis 4294967295 ausgef√ºhrt. <br><br>  Noch ein paar dieser Warnungen: <br><br><ul><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdr√ºcken m√∂glich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Weitere Informationen zu Null-Gleichheitspr√ºfungen (oder deren Fehlen)</b> <br><br>  Einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095-</a> Fehler beim √úberpr√ºfen einer Variablen auf <i>Null</i> nach ihrer Verwendung.  Der erste ist mehrdeutig, betrachten Sie den Code. <br><br>  V3095 Das Objekt 'displayName' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Es wird angenommen, dass die <i>displayName-</i> Referenz null sein kann.  √úberpr√ºfen Sie dazu <i>Debug.Assert</i> .  Es ist nicht klar, warum es nach der Verwendung der Zeichenfolge geht.  Es sollte auch <i>beachtet</i> werden <i>,</i> dass der Compiler bei anderen Konfigurationen als Debug <i>Debug.Assert √ºberhaupt</i> aus dem Code entfernt.  Bedeutet dies, dass nur f√ºr Debug eine Nullreferenz m√∂glich ist?  Und wenn dies nicht der <i>Fall</i> ist, warum wurde dann nicht <i>string.IsNullOrEmpty (string)</i> √ºberpr√ºft <i>?</i>  Dies sind Fragen an die Autoren des Codes. <br><br>  Der folgende Fehler ist offensichtlicher. <br><br>  V3095 Das Objekt 'scriptArgsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Ich denke, dieser Code bedarf keiner Erkl√§rung.  Ich werde die korrigierte Version geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Der Roslyn-Code hat weitere 15 solcher Fehler gefunden: <br><br><ul><li>  V3095 Das Objekt 'LocalFunctions' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Das Objekt 'Resolution.OverloadResolutionResult' wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Das Objekt 'Resolution.MethodGroup' wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Das Objekt 'touchFilesLogger' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Das Objekt 'newExceptionRegionsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 Das 'Symbol'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Das Objekt '_state.BaseTypeOrInterfaceOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Das Objekt 'element' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Das 'Sprachen'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Das Objekt 'memberType' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Das Objekt 'validTypeDeclarations' wurde verwendet, bevor es gegen null verifiziert wurde. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie die Fehler von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies verwendet die bedingten Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn die Variable initialisiert wird </font><font style="vertical-align: inherit;">, aber sp√§ter in der Codegr√∂√üe wird ohne pr√ºft auf Gleichheit verwendet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Fehler wird sofort durch zwei Warnungen angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. NullReferenceException ist m√∂glich. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. NullReferenceException ist m√∂glich. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialisiert werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen wird beim Erstellen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Ausnahme ausgel√∂st. </font><font style="vertical-align: inherit;">Der Code muss behoben werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter im Code muss die M√∂glichkeit der Gleichheit von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullvariablen vorgesehen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden, die an den Konstruktor √ºbergeben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere √§hnliche Fehler im Code:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. </font><font style="vertical-align: inherit;">NullReferenceException ist m√∂glich. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. </font><font style="vertical-align: inherit;">NullReferenceException ist m√∂glich. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorit√§ten und Klammern </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√∂glicherweise arbeitet der Operator '?:' Anders als erwartet. Seine Priorit√§t ist niedriger als die Priorit√§t anderer Betreiber in seinem Zustand. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedingung im R√ºckgabeblock wird √ºberhaupt nicht berechnet, wie der Entwickler gedacht hat. </font><font style="vertical-align: inherit;">Es wurde angenommen, dass die erste Bedingung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d sein w√ºrde (daher wurde nach dieser Bedingung ein Zeilenumbruch durchgef√ºhrt), und dann w√ºrden Bedingungsbl√∂cke mit dem Operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Sequentiell berechnet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tats√§chlich ist die erste Bedingung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine h√∂here Priorit√§t hat als der Operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Um den Fehler zu beheben, m√ºssen alle Ausdr√ºcke des Operators " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " In </font><font style="vertical-align: inherit;">Klammern gesetzt werden </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damit ist die Beschreibung der gefundenen Fehler abgeschlossen. </font></font><br><br>  <b>Schlussfolgerungen</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der erheblichen Anzahl von Fehlern, die ich in Bezug auf die Gr√∂√üe des Roslyn-Projektcodes (2.770.000 Zeilen) feststellen konnte, wird dies eine recht kleine Menge sein. Wie Andrei im vorherigen Artikel bin auch ich bereit, die hohe Qualit√§t dieses Projekts zu erkennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte darauf hinweisen, dass solche gelegentlichen Codepr√ºfungen nichts mit der Methodik der statischen Analyse zu tun haben und praktisch keinen Nutzen bringen. Die statische Analyse sollte regelm√§√üig und nicht von Fall zu Fall durchgef√ºhrt werden. Dann werden viele Fehler in den fr√ºhesten Stadien korrigiert, und daher sind die Kosten f√ºr ihre Behebung zehnmal niedriger. Diese Idee wird in diesem kleinen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhrlicher </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">beschrieben</font></a><font style="vertical-align: inherit;"> , mit dem Sie sich vertraut machen sollen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen sowohl im betrachteten Projekt als auch in jedem anderen unabh√§ngig voneinander nach weiteren Fehlern suchen. </font><font style="vertical-align: inherit;">Dazu m√ºssen Sie nur </font><font style="vertical-align: inherit;">unseren Analysator </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herunterladen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ausprobieren.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberpr√ºfen des Roslyn-Quellcodes</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446592/">https://habr.com/ru/post/de446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446578/index.html">Postkartenbasierte Programmiersprache</a></li>
<li><a href="../de446582/index.html">√úberlegungen zum Solar Hosting f√ºr Bienen</a></li>
<li><a href="../de446586/index.html">Netzwerkeinstellungen von FreeRadius √ºber DHCP</a></li>
<li><a href="../de446588/index.html">√úberpr√ºfen des Roslyn-Quellcodes</a></li>
<li><a href="../de446590/index.html">39 neue Funktionen in Java 12</a></li>
<li><a href="../de446598/index.html">Neuerstellen von CRT-Schriftarten</a></li>
<li><a href="../de446602/index.html">Maximaler Gleichstrom durch Feldeffekttransistor</a></li>
<li><a href="../de446604/index.html">ESET: Neue Backdoor-Lieferprogramme f√ºr OceanLotus Cybergroup</a></li>
<li><a href="../de446606/index.html">√úberpr√ºfen Sie, wie gut Sie in der additiven Technologie sind</a></li>
<li><a href="../de446608/index.html">√úberwindung des dritten Gesetzes der organisatorischen Schwerkraft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>