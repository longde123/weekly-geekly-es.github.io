<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎫 ☎️ 🧑🏽‍🤝‍🧑🏽 Überprüfen des Quellcodes von Roslyn 🧑🏾‍🤝‍🧑🏾 🤞🏻 👩‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit kehren wir zu Projekten zurück, die wir zuvor mit PVS-Studio getestet und Artikel darüber geschrieben haben. Dafür gibt es zwei Gründ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Überprüfen des Quellcodes von Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio gegen Roslyn"></div><br>  Von Zeit zu Zeit kehren wir zu Projekten zurück, die wir zuvor mit PVS-Studio getestet und Artikel darüber geschrieben haben.  Dafür gibt es zwei Gründe.  Erstens, um zu verstehen, wie viel besser unser Analysator geworden ist.  Zweitens, um zu verfolgen, ob die Autoren des Projekts auf unseren Artikel sowie auf den Fehlerbericht geachtet haben, den wir ihnen normalerweise zur Verfügung stellen.  Natürlich können Fehler ohne unsere Teilnahme korrigiert werden.  Aber es ist immer schön, wenn genau unsere Bemühungen dazu beitragen, ein Projekt besser zu machen.  Roslyn war keine Ausnahme.  Ein früherer Übersichtsartikel zu diesem Projekt stammt aus dem 23. Dezember 2015.  Dies ist eine ziemlich lange Zeit, angesichts des Weges, den unser Analysator in dieser Zeit in seiner Entwicklung zurückgelegt hat.  Für uns persönlich ist Roslyn auch deshalb von zusätzlichem Interesse, weil der Kern des C # -Analysators PVS-Studio darauf basiert.  Daher sind wir sehr an der Qualität des Codes für dieses Projekt interessiert.  Wir werden einen zweiten Check arrangieren und herausfinden, was neu und interessant ist (aber hoffen wir, dass nichts Bedeutendes), was PVS-Studio dort finden kann. <br><a name="habracut"></a><br>  Roslyn (oder die .NET Compiler-Plattform) ist wahrscheinlich vielen unserer Leser bekannt.  Kurz gesagt, es handelt sich um eine Reihe von Open Source-Compilern und APIs für die Codeanalyse für die C # - und Visual Basic .NET-Sprachen von Microsoft.  Der Quellcode für das Projekt ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. <br><br>  Ich werde diese Plattform nicht detailliert beschreiben, aber ich würde jedem Interessierten einen Artikel meines Kollegen Sergey Vasiliev empfehlen: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in Roslyn. Verwenden statischer Analysewerkzeuge zur Entwicklung</a> ."  In diesem Artikel erfahren Sie nicht nur, welche Funktionen die Roslyn-Architektur bietet, sondern auch, wie genau wir diese Plattform verwenden. <br><br>  Wie ich bereits erwähnt habe, sind mehr als drei Jahre vergangen, seit mein Kollege Andrei Karpov den letzten Artikel über den Roslyn-Check " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neujahrsveröffentlichung von PVS-Studio 6.00: Check Roslyn</a> " geschrieben hat.  In dieser Zeit hat der C # PVS-Studio-Analysator viele neue Funktionen erhalten.  Im Allgemeinen war Andreys Artikel eine Art „Testball“, da der C # -Analysator erst damals zu PVS-Studio hinzugefügt wurde.  Trotzdem gelang es Roslyn selbst dann in einem bedingungslos hochwertigen Projekt, interessante Fehler zu finden.  Was hat sich im Analysator für C # -Code bisher geändert, was möglicherweise eine tiefere Analyse ermöglicht? <br><br>  In der Vergangenheit haben sich sowohl der Analysatorkern als auch die Infrastruktur entwickelt.  Unterstützung für Visual Studio 2017 und Roslyn 2.0 sowie eine umfassende Integration in MSBuild wurden hinzugefügt.  Weitere Informationen zu unserem Ansatz zur Integration in MSBuild und zu den Gründen, aus denen wir ihn akzeptiert haben, finden Sie in dem Artikel meines Kollegen Pavel Yeremeyev: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für Visual Studio 2017 und Roslyn 2.0 in PVS-Studio: Manchmal ist die Verwendung vorgefertigter Lösungen nicht so einfach, wie es scheint auf einen Blick</a> . " <br><br>  Jetzt arbeiten wir aktiv an der Umstellung auf Roslyn 3.0 nach demselben Schema, das wir ursprünglich für Visual Studio 2017 unterstützt haben, dh über unser eigenes Toolset, das im PVS-Studio-Distributionskit mit einem „Stub“ in Form einer leeren MSBuild.exe-Datei enthalten ist.  Trotz der Tatsache, dass es wie eine „Krücke“ aussieht (die MSBuild-API ist aufgrund der geringen Portabilität der Bibliotheken nicht sehr benutzerfreundlich für die Wiederverwendung in Third-Patry-Projekten), hat uns dieser Ansatz bereits geholfen, mehrere Roslyn-Updates während der Lebensdauer von Visual Studio 2017 relativ schmerzlos erneut zu erleben. und jetzt, obwohl mit vielen Überlagerungen, überleben Sie das Upgrade auf Visual Studio 2019 und behalten die volle Abwärtskompatibilität und Leistung auf Systemen mit älteren Versionen von MSBuild bei. <br><br>  Der Analysatorkern hat auch eine Reihe von Verbesserungen erfahren.  Eine der Hauptinnovationen ist eine umfassende interprozedurale Analyse, die die Eingabe- und Ausgabewerte der Methoden berücksichtigt und in Abhängigkeit von diesen Parametern die Erreichbarkeit der Ausführungszweige und Rückgabepunkte berücksichtigt. <br><br>  Die Aufgabe, Parameter innerhalb der Methoden zu verfolgen, ist bereits kurz vor dem Abschluss, während automatische Anmerkungen für die dortigen Parameter beibehalten werden (z. B. eine potenziell gefährliche Dereferenzierung).  Auf diese Weise kann bei jeder Diagnose mithilfe des Datenflussmechanismus gefährliche Situationen berücksichtigt werden, die beim Übergeben eines Parameters an eine Methode auftreten.  Bisher wurde bei der Analyse derart gefährlicher Orte keine Warnung generiert, da wir nicht alle möglichen Eingabewerte für eine solche Methode kennen konnten.  Jetzt können wir die Gefahr erkennen, da diese Eingabeparameter an allen Stellen, an denen diese Methode aufgerufen wird, berücksichtigt werden. <br><br>  Hinweis: Sie können sich mit den wichtigsten Analysemechanismen wie Datenfluss und anderen aus dem Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im PVS-Studio Code Analyzer zum Auffinden von Fehlern und potenziellen Schwachstellen verwendete Technologien</a> " vertraut machen. <br><br>  Die interprozedurale Analyse in PVS-Studio C # ist weder durch Eingabeparameter noch durch die Tiefe begrenzt.  Die einzige Einschränkung sind virtuelle Methoden in Klassen, die nicht wegen Vererbung geschlossen wurden und in Rekursion geraten (wir werden aufhören, wenn wir auf dem Stapel einen wiederholten Aufruf einer bereits berechneten Methode sehen).  Darüber hinaus wird die rekursive Methode selbst letztendlich unter der Annahme berechnet, dass der Rückgabewert ihrer Selbstrekursion unbekannt ist. <br><br>  Eine weitere große Neuerung im C # -Analysator ist die Möglichkeit, einen potenziell Nullzeiger zu dereferenzieren.  Zuvor schwor der Analysator eine mögliche Nullreferenzausnahme, wenn er sicher war, dass in allen Ausführungszweigen der Wert der Variablen null sein würde.  Natürlich hat er sich manchmal geirrt, daher wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080-</a> Diagnose zuvor als potenzielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz bezeichnet</a> . <br><br>  Jetzt merkt sich der Analysator, dass die Variable in einem der Ausführungszweige null sein kann (z. B. unter einer bestimmten Bedingung in if).  Wenn er den Zugriff auf eine solche Variable ohne Überprüfung sieht, erhält er eine V3080-Nachricht, jedoch mit einer geringeren Wichtigkeit als wenn er in allen Zweigen null sieht.  In Kombination mit einer verbesserten interprozeduralen Analyse ermöglicht ein solcher Mechanismus das Auffinden sehr schwer zu erkennender Fehler.  Ein Beispiel ist eine lange Kette von Methodenaufrufen, mit denen Sie zuletzt nicht vertraut sind und die beispielsweise unter bestimmten Umständen im Fang null zurückgeben, aber Sie haben sich nicht davor geschützt, weil Sie es einfach nicht wussten.  In diesem Fall schwört der Analysator nur, wenn er die Zuweisung von Null genau sieht.  Unserer Meinung nach unterscheidet dies unseren Ansatz qualitativ von einer solchen Innovation von C # 8.0 als nullbarem Referenztyp, die tatsächlich darauf hinausläuft, bei jeder Methode Nullprüfungen festzulegen.  Wir bieten eine Alternative an - nur dort zu prüfen, wo wirklich null kommen kann, und unser Analysator kann jetzt nach solchen Situationen suchen. <br><br>  Fahren wir also unverzüglich mit der „Nachbesprechung“ fort und analysieren die Ergebnisse des Roslyn-Checks.  Schauen wir uns zunächst die Fehler an, die dank der oben beschriebenen Innovationen festgestellt wurden.  Im Allgemeinen wurden diesmal einige Warnungen für den Roslyn-Code ausgegeben.  Ich denke, dies liegt an der Tatsache, dass sich die Plattform sehr aktiv entwickelt (die Codebasis umfasst derzeit etwa 2.770.000 Codezeilen, ausgenommen leere), und wir haben dieses Projekt lange Zeit nicht analysiert.  Es gibt jedoch nicht so viele kritische Fehler, nämlich sie sind für den Artikel von Interesse.  Und ja, es gibt in Roslyn einige Tests, die ich wie üblich vom Testen ausgeschlossen habe. <br><br>  Ich beginne mit V3080-Fehlern mit mittlerer Kritikalität, bei denen der Analysator einen möglichen Zugriff über eine Nullverbindung festgestellt hat, jedoch nicht in allen möglichen Fällen (Code-Verzweigungen). <br><br>  <b>Mögliche Null-Dereferenzierung - Mittel</b> <br><br>  V3080 Mögliche Null-Dereferenzierung.  Betrachten Sie die Überprüfung der "aktuellen".  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Betrachten Sie die <i>GetNode-</i> Methode.  Der Analysator ist der Ansicht, dass der Zugriff per Nullreferenz im Zustand des <i>while-</i> Blocks möglich ist.  Im Hauptteil des <i>while-</i> Blocks wird der <i>aktuellen</i> Variablen ein Wert zugewiesen - das Ergebnis der Ausführung der <i>AsNode-</i> Methode.  Und dieser Wert ist in einigen Fällen <i>null</i> .  Ein gutes Beispiel für eine interprozedurale Analyse in Aktion. <br><br>  Betrachten Sie nun einen ähnlichen Fall, in dem die Interprozeduranalyse über zwei Methodenaufrufe durchgeführt wurde. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie das Verzeichnis.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Die <i>Verzeichnisvariable</i> im Hauptteil der <i>ExpandFileNamePattern-</i> Methode <i>ruft</i> den Wert von der <i>GetDirectoryName (string)</i> -Methode ab.  Dies gibt wiederum das Ergebnis der überladenen <i>GetDirectoryName-</i> Methode <i>(Zeichenfolge, Bool) zurück</i> , deren Wert möglicherweise <i>null ist</i> .  Da weiter im Hauptteil der <i>ExpandFileNamePattern-</i> Methode die <i>Verzeichnisvariable</i> verwendet wird, ohne zuvor auf <i>Nullgleichheit zu</i> prüfen, können wir über die Rechtmäßigkeit der Warnung durch den Analysator sprechen.  Dies ist ein möglicherweise unsicheres Design. <br><br>  Ein weiterer Code mit Fehler V3080, genauer gesagt, sofort mit zwei Fehlern, die für eine Codezeile ausgegeben wurden.  Hier war keine interprozedurale Analyse erforderlich. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Die <i>Variablen</i> <i>spanStartLocation</i> und <i>spanEndLocationExclusive</i> sind vom Typ <i>nullable int</i> und werden mit <i>null</i> initialisiert.  Weiter im Code können ihnen Werte zugewiesen werden, jedoch nur, wenn bestimmte Bedingungen erfüllt sind.  In einigen Fällen bleibt ihr Wert gleich <i>Null</i> .  Weiter im Code wird auf diese Variablen als Referenz zugegriffen, ohne vorher auf Nullgleichheit zu prüfen, wie der Analysator anzeigt. <br><br>  Roslyn-Code enthält einige solcher Fehler, mehr als 100. Oft ist das Muster dieser Fehler das gleiche.  Es gibt eine allgemeine Methode, die möglicherweise <i>null</i> zurückgibt.  Das Ergebnis dieser Methode wird an einer großen Anzahl von Stellen verwendet, manchmal durch Dutzende von Zwischenmethodenaufrufen oder zusätzliche Überprüfungen.  Es ist wichtig zu verstehen, dass diese Fehler nicht schwerwiegend sind, aber möglicherweise zum Zugriff über einen Null-Link führen können.  Und solche Fehler zu erkennen ist sehr schwierig.  In einigen Fällen sollten Sie daher in Betracht ziehen, den Code umzugestalten. In diesem Fall wird eine Ausnahme ausgelöst, wenn die Methode <i>null zurückgibt</i> .  Andernfalls können Sie Ihren Code nur mit vollständigen Überprüfungen sichern, was ziemlich mühsam und unzuverlässig ist.  Natürlich sollte die Entscheidung in jedem Fall auf der Grundlage der Merkmale des Projekts getroffen werden. <br><br>  Hinweis  Es kommt vor, dass es derzeit keine Situationen (Eingabedaten) gibt, in denen die Methode <i>null</i> zurückgibt und kein wirklicher Fehler vorliegt.  Ein solcher Code ist jedoch immer noch nicht zuverlässig, da sich alles ändern kann, wenn Änderungen am Code vorgenommen werden. <br><br>  Um das Thema mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3080 zu schließen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werfen</a> wir einen Blick auf die offensichtlichen Fehler mit dem hohen Konfidenzniveau, wenn der Zugriff über einen Null-Link wahrscheinlicher oder sogar unvermeidlich ist. <br><br>  <b>Mögliche Null-Dereferenzierung - Hoch</b> <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Aufgrund eines Tippfehlers in der Bedingung (anstelle des von uns verwendeten Operators <i>||</i> <i>&amp;&amp;</i> ) funktioniert der Code nicht wie beabsichtigt, und auf die Variable <i>collectionType.Type</i> wird zugegriffen, wenn sie <i>null ist</i> .  Der Zustand muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Übrigens ist auch die zweite Variante der Ereignisentwicklung möglich: Im ersten Teil werden die Bedingungen von den Operatoren <i>==</i> und <i>! =</i> <i>Verwechselt</i> .  Dann wäre der korrigierte Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Diese Version des Codes ist weniger logisch, korrigiert aber auch den Fehler.  Die endgültige Entscheidung liegt bei den Autoren des Projekts. <br><br>  Ein weiterer ähnlicher Fehler. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überlegen Sie, ob Sie die Aktion überprüfen möchten.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Beim Verfassen einer Nachricht für eine Ausnahme ist ein Fehler aufgetreten.  Gleichzeitig wird versucht, über die <i>Aktionsvariable</i> , die offensichtlich <i>null</i> ist, auf die Eigenschaft <i>action.DisplayText</i> zuzugreifen. <br><br>  Und der letzte Fehler ist der V3080 High Level. <br><br>  V3080 Mögliche Null-Dereferenzierung.  Überprüfen Sie den Typ.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Die Methode ist klein, also gebe ich den gesamten Code.  Die Bedingung im <i>Rückgabeblock</i> ist falsch.  In einigen Fällen ist es möglich, beim Zugriff auf <i>type.FullName</i> eine <i>NullReferenceException</i> <i>auszulösen</i> .  Ich benutze Klammern (sie werden das Verhalten hier nicht ändern), um die Situation zu klären: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Auf diese Weise funktioniert dieser Code entsprechend der Priorität der Operationen.  Wenn die Typvariable <i>null ist</i> , führen wir eine else-Prüfung durch, bei der wir die Null- <i>Typreferenz verwenden</i> , um sicherzustellen, dass die Variable <i>targetTypeName</i> <i>null</i> ist.  Sie können den Code beispielsweise folgendermaßen korrigieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Ich denke, hier können Sie die Untersuchung von V3080-Fehlern abschließen und sehen, was der andere interessante PVS-Studio-Analysator im Roslyn-Code gefunden hat. <br><br>  <b>Tippfehler</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3005</a> Die Variable 'SourceCodeKind' wird sich selbst zugewiesen.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Aufgrund eines erfolglosen Variablennamens wurde im Konstruktor der <i>DynamicFileInfo-</i> Klasse ein Tippfehler gemacht.  Dem <i>Feld SourceCodeKind wird</i> ein eigener Wert zugewiesen, anstatt den Parameter <i>sourceCodeKind zu verwenden</i> .  Um die Wahrscheinlichkeit solcher Fehler zu minimieren, wird empfohlen, in solchen Fällen das Unterstrichpräfix für Parameternamen zu verwenden.  Ich werde ein Beispiel für eine korrigierte Version des Codes geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Nachlässigkeit</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3006</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Das Schlüsselwort 'throw' könnte fehlen: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Unter bestimmten Bedingungen sollte der Destruktor eine Ausnahme auslösen. Dies ist jedoch nicht der Fall, und das Ausnahmeobjekt wird einfach erstellt.  Das Schlüsselwort <i>throw</i> wurde weggelassen.  Korrigierte Version des Codes: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Das Problem, mit Destruktoren in C # zu arbeiten und Ausnahmen von ihnen auszulösen, ist ein Thema für eine separate Diskussion, die den Rahmen dieses Artikels sprengt. <br><br>  <b>Wenn das Ergebnis nicht wichtig ist</b> <br><br>  Für Methoden, die in allen Fällen den gleichen Wert zurückgeben, wurde eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009-</a> Warnungen empfangen.  Manchmal ist dies nicht kritisch oder der Rückkehrcode wird im aufrufenden Code einfach nicht überprüft.  Ich habe solche Warnungen verpasst.  Aber ein paar Code-Teile schienen mir verdächtig.  Ich werde einen von ihnen zitieren: <br><br>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die <i>TryExecuteCommand-</i> Methode gibt nur <i>true</i> und nichts als <i>true zurück</i> .  Gleichzeitig ist der Rückgabewert an einigen Überprüfungen des aufrufenden Codes beteiligt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Es ist schwer zu sagen, wie gefährlich dieses Verhalten ist.  Wenn das Ergebnis jedoch nicht benötigt wird, kann es sinnvoll sein, den Rückgabetyp durch void zu ersetzen und minimale Änderungen an der aufrufenden Methode vorzunehmen.  Dadurch wird der Code verständlicher und sicherer. <br><br>  Andere ähnliche Warnungen: <br><br><ul><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  JsonRpcClient.cs 138 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'false' zurückgibt.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  ObjectList.cs 173 </li><li>  V3009 Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  ObjectList.cs 249 </li></ul><br>  <b>Nicht geprüft</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3019</a> Möglicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen.  Überprüfen Sie die Variablen 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Der Variablenwert ist vom Typ <i>NamingStylePreferences</i> .  Das Problem folgt dieser Überprüfung.  Selbst wenn die <i>Wertvariable</i> nicht null ist, garantiert dies nicht, dass die Typkonvertierung erfolgreich war und dass <i>valueToSerialize</i> keine <i>Null</i> enthält.  Eine <i>NullReferenceException kann ausgelöst werden</i> .  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Und noch ein ähnlicher Fehler. <br><br>  V3019 Möglicherweise wird eine falsche Variable nach der Typkonvertierung mit dem Schlüsselwort 'as' mit null verglichen.  Überprüfen Sie die Variablen 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Die Variable <i>columnState</i> ist vom Typ <i>ColumnState2</i> .  Das Ergebnis der Operation, die Variable <i>columnState2</i> , wird jedoch nicht weiter auf <i>null</i> geprüft.  Stattdessen wird die Variable <i>columnState</i> mithilfe der bedingten <i>Null-</i> Anweisung überprüft.  Was ist die Gefahr dieses Codes?  Wie im vorherigen Beispiel kann die Typumwandlung mit dem Operator <i>as</i> fehlschlagen, und die Variable <i>columnState2</i> ist <i>null</i> , wodurch eine Ausnahme <i>ausgelöst</i> wird.  Übrigens kann ein Tippfehler schuld sein.  Beachten Sie die Bedingung im <i>if-</i> Block.  Vielleicht <i>wollten</i> sie anstelle von <i>columnState? .Name columnState2? .Name</i> schreiben.  Dies ist sehr wahrscheinlich angesichts der eher unglücklichen Variablennamen <i>columnState und columnState2.</i> <br><br>  <b>Redundante Schecks</b> <br><br>  Eine ziemlich große Anzahl von Warnungen (über 100) wurde für unkritische, aber möglicherweise unsichere Konstruktionen ausgegeben, die mit redundanten Überprüfungen verbunden sind.  Zum Beispiel werde ich einen von ihnen geben. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022 Der</a> Ausdruck 'navInfo == null' ist immer falsch.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Vielleicht gibt es hier keinen wirklichen Fehler.  Nur ein guter Grund, die Kombination der Technologien „Interprocedural Analysis + Data Flow Analysis“ in Aktion zu demonstrieren.  Der Analysator ist der Ansicht, dass die zweite Prüfung <i>navInfo == null</i> redundant ist.  <i>Zuvor</i> wird der Wert für die Zuweisung von <i>navInfo</i> von der <i>libraryService.NavInfoFactory.CreateForProject-</i> Methode abgerufen, die ein neues Objekt der <i>NavInfo-</i> Klasse erstellt und <i>zurückgibt</i> .  Aber in keiner Weise <i>null</i> .  Die Frage ist, warum der Analysator keine Warnung für die erste Prüfung <i>navInfo == null generiert hat</i> .  Dafür gibt es eine Erklärung.  Erstens, wenn sich herausstellt, dass die <i>Symbolvariable</i> <i>null ist</i> , bleibt der Wert von <i>navInfo</i> eine <i>Nullreferenz</i> .  Zweitens kann dieser Wert <i>null sein</i> , selbst wenn <i>navInfo</i> den Wert von der <i>libraryService.NavInfoFactory.CreateForSymbol-</i> Methode erhält.  Die erste Überprüfung von <i>navInfo == null ist also</i> wirklich notwendig. <br><br>  <b>Nicht genug Schecks</b> <br><br>  Und jetzt ist die Situation umgekehrt.  Für Code, auf den über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullreferenz</a> zugegriffen werden konnte, wurden mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3042-</a> Warnungen empfangen.  Außerdem konnten nur ein oder zwei kleine Schecks alles reparieren. <br><br>  Stellen Sie sich einen interessanten Code vor, der zwei solche Fehler enthält. <br><br>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'Empfänger'-Objekts Binder_Expressions.cs 7770 verwendet <br><br>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'Empfänger'-Objekts Binder_Expressions.cs 7776 verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Die <i>Empfängervariable</i> kann <i>null sein</i> .  Der Autor des Codes weiß dies, weil er den bedingten <i>Nulloperator</i> in der Bedingung des <i>if-</i> Blocks verwendet, um auf den <i>Empfänger? .Syntax zuzugreifen</i> .  Weiter im Code wird der variable <i>Empfänger</i> ohne jegliche Überprüfung verwendet, um auf <i>Empfänger</i> zuzugreifen. Typ, <i>Empfänger</i> . <i>Syntax</i> und <i>Empfänger</i> . <i>HatErrors</i> .  Diese Fehler müssen behoben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Sie müssen auch sicherstellen, dass der <i>BoundConditionalReceiver-</i> Konstruktor das Abrufen von <i>Nullwerten</i> für seine Parameter unterstützt, oder zusätzliches Refactoring durchführen. <br><br>  Andere ähnliche Fehler: <br><br><ul><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des Objekts 'includesType' SyntaxGeneratorExtensions_Negate.cs 240 verwendet </li><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li><li>  V3042 Mögliche NullReferenceException.  Das '?.'  und '.'  Operatoren werden für den Zugriff auf Mitglieder des 'expression'-Objekts ExpressionSyntaxExtensions.cs 349 verwendet </li></ul><br>  <b>Fehler im Zustand</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3057</a> Die Funktion 'Teilzeichenfolge' könnte den Wert '-1' empfangen, während ein nicht negativer Wert erwartet wird.  Untersuchen Sie das zweite Argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Wenn die <i>Doppelpunktvariable</i> 0 ist, was eine Bedingung im Code <i>zulässt</i> , <i>löst</i> die <i>Substring-</i> Methode eine <i>ArgumentOutOfRangeException aus</i> .  Korrektur erforderlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Tippfehler ist möglich</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3065 Der</a> Parameter 't2' wird im Körper der Methode nicht verwendet.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Zwei Parameter werden an den Lambda-Ausdruck übergeben: t1 und t2.  Es wird jedoch nur t1 verwendet.  Es sieht verdächtig aus, wenn man bedenkt, wie einfach es ist, Fehler bei der Verwendung von Variablen mit diesen Namen zu machen. <br><br>  <b>Nachlässigkeit</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> Unsicherer Aufruf des Ereignisses 'TagsChanged', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Das <i>TagChanged-</i> Ereignis <i>wird</i> unsicher ausgelöst.  Zwischen der Überprüfung auf <i>Nullgleichheit</i> und dem Aufrufen eines Ereignisses haben sie möglicherweise Zeit, sich von ihm abzumelden. Dann wird eine Ausnahme ausgelöst.  Darüber hinaus werden im Hauptteil des <i>if-</i> Blocks unmittelbar vor dem Aufruf des Ereignisses einige andere Operationen ausgeführt.  Ich habe diesen Fehler "Unaufmerksamkeit" genannt, weil sie an anderen Stellen im Code mit diesem Ereignis genauer arbeiten, zum Beispiel wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Die Verwendung der optionalen <i>Handlervariablen</i> beseitigt das Problem.  In der <i>OnTextBufferChanged-</i> Methode müssen <i>Sie</i> Änderungen für denselben sicheren Vorgang mit dem Ereignis vornehmen. <br><br>  <b>Schnittpunkte</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3092 Bereichsschnittpunkte</a> sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Zum besseren Verständnis werde ich dieses Codefragment neu schreiben und die Konstantennamen durch ihre tatsächlichen Werte ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Wahrscheinlich gibt es keinen wirklichen Fehler, aber der Zustand sieht seltsam aus.  Der zweite Teil ( <i>sonst wenn</i> ) wird nur für den Wertebereich von 2147483648 + 1 bis 4294967295 ausgeführt. <br><br>  Noch ein paar dieser Warnungen: <br><br><ul><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Bereichsschnittpunkte sind innerhalb von bedingten Ausdrücken möglich.  Beispiel: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Weitere Informationen zu Null-Gleichheitsprüfungen (oder deren Fehlen)</b> <br><br>  Einige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095-</a> Fehler beim Überprüfen einer Variablen auf <i>Null</i> nach ihrer Verwendung.  Der erste ist mehrdeutig, betrachten Sie den Code. <br><br>  V3095 Das Objekt 'displayName' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Es wird angenommen, dass die <i>displayName-</i> Referenz null sein kann.  Überprüfen Sie dazu <i>Debug.Assert</i> .  Es ist nicht klar, warum es nach der Verwendung der Zeichenfolge geht.  Es sollte auch <i>beachtet</i> werden <i>,</i> dass der Compiler bei anderen Konfigurationen als Debug <i>Debug.Assert überhaupt</i> aus dem Code entfernt.  Bedeutet dies, dass nur für Debug eine Nullreferenz möglich ist?  Und wenn dies nicht der <i>Fall</i> ist, warum wurde dann nicht <i>string.IsNullOrEmpty (string)</i> überprüft <i>?</i>  Dies sind Fragen an die Autoren des Codes. <br><br>  Der folgende Fehler ist offensichtlicher. <br><br>  V3095 Das Objekt 'scriptArgsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Ich denke, dieser Code bedarf keiner Erklärung.  Ich werde die korrigierte Version geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Der Roslyn-Code hat weitere 15 solcher Fehler gefunden: <br><br><ul><li>  V3095 Das Objekt 'LocalFunctions' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Das Objekt 'Resolution.OverloadResolutionResult' wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Das Objekt 'Resolution.MethodGroup' wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Das Objekt 'touchFilesLogger' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Das Objekt 'newExceptionRegionsOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 Das 'Symbol'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Das Objekt '_state.BaseTypeOrInterfaceOpt' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Das Objekt 'element' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Das 'Sprachen'-Objekt wurde verwendet, bevor es gegen Null verifiziert wurde.  Überprüfen Sie die Zeilen: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Das Objekt 'memberType' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Das Objekt 'validTypeDeclarations' wurde verwendet, bevor es gegen null verifiziert wurde. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berücksichtigen Sie die Fehler von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dies verwendet die bedingten Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenn die Variable initialisiert wird </font><font style="vertical-align: inherit;">, aber später in der Codegröße wird ohne prüft auf Gleichheit verwendet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der nächste Fehler wird sofort durch zwei Warnungen angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. NullReferenceException ist möglich. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'documentId' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. NullReferenceException ist möglich. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann auf </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> initialisiert werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infolgedessen wird beim Erstellen des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Ausnahme ausgelöst. </font><font style="vertical-align: inherit;">Der Code muss behoben werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter im Code muss die Möglichkeit der Gleichheit von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nullvariablen vorgesehen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden, die an den Konstruktor übergeben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere ähnliche Fehler im Code:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. </font><font style="vertical-align: inherit;">NullReferenceException ist möglich. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Die Variable 'symbol' wurde verwendet, nachdem sie durch einen nullbedingten Operator zugewiesen wurde. </font><font style="vertical-align: inherit;">NullReferenceException ist möglich. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioritäten und Klammern </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Möglicherweise arbeitet der Operator '?:' Anders als erwartet. Seine Priorität ist niedriger als die Priorität anderer Betreiber in seinem Zustand. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedingung im Rückgabeblock wird überhaupt nicht berechnet, wie der Entwickler gedacht hat. </font><font style="vertical-align: inherit;">Es wurde angenommen, dass die erste Bedingung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d sein würde (daher wurde nach dieser Bedingung ein Zeilenumbruch durchgeführt), und dann würden Bedingungsblöcke mit dem Operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Sequentiell berechnet </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tatsächlich ist die erste Bedingung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine höhere Priorität hat als der Operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Um den Fehler zu beheben, müssen alle Ausdrücke des Operators " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " In </font><font style="vertical-align: inherit;">Klammern gesetzt werden </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damit ist die Beschreibung der gefundenen Fehler abgeschlossen. </font></font><br><br>  <b>Schlussfolgerungen</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der erheblichen Anzahl von Fehlern, die ich in Bezug auf die Größe des Roslyn-Projektcodes (2.770.000 Zeilen) feststellen konnte, wird dies eine recht kleine Menge sein. Wie Andrei im vorherigen Artikel bin auch ich bereit, die hohe Qualität dieses Projekts zu erkennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte darauf hinweisen, dass solche gelegentlichen Codeprüfungen nichts mit der Methodik der statischen Analyse zu tun haben und praktisch keinen Nutzen bringen. Die statische Analyse sollte regelmäßig und nicht von Fall zu Fall durchgeführt werden. Dann werden viele Fehler in den frühesten Stadien korrigiert, und daher sind die Kosten für ihre Behebung zehnmal niedriger. Diese Idee wird in diesem kleinen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausführlicher </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">beschrieben</font></a><font style="vertical-align: inherit;"> , mit dem Sie sich vertraut machen sollen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können sowohl im betrachteten Projekt als auch in jedem anderen unabhängig voneinander nach weiteren Fehlern suchen. </font><font style="vertical-align: inherit;">Dazu müssen Sie nur </font><font style="vertical-align: inherit;">unseren Analysator </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herunterladen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ausprobieren.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überprüfen des Roslyn-Quellcodes</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446592/">https://habr.com/ru/post/de446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446578/index.html">Postkartenbasierte Programmiersprache</a></li>
<li><a href="../de446582/index.html">Überlegungen zum Solar Hosting für Bienen</a></li>
<li><a href="../de446586/index.html">Netzwerkeinstellungen von FreeRadius über DHCP</a></li>
<li><a href="../de446588/index.html">Überprüfen des Roslyn-Quellcodes</a></li>
<li><a href="../de446590/index.html">39 neue Funktionen in Java 12</a></li>
<li><a href="../de446598/index.html">Neuerstellen von CRT-Schriftarten</a></li>
<li><a href="../de446602/index.html">Maximaler Gleichstrom durch Feldeffekttransistor</a></li>
<li><a href="../de446604/index.html">ESET: Neue Backdoor-Lieferprogramme für OceanLotus Cybergroup</a></li>
<li><a href="../de446606/index.html">Überprüfen Sie, wie gut Sie in der additiven Technologie sind</a></li>
<li><a href="../de446608/index.html">Überwindung des dritten Gesetzes der organisatorischen Schwerkraft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>