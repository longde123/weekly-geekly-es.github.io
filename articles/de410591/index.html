<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìó üë∫ üïç Die emotionale Geschichte der Prozessoren f√ºr die ersten Computer von den 70ern bis zu den fr√ºhen 90ern üë∞ ü§∏ üå≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe zuf√§llig Assembler verschiedener Prozessoren programmiert. Als letztes auf der Liste steht Xilinx MicroBlaze. Ich beschloss, einige meiner Be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die emotionale Geschichte der Prozessoren f√ºr die ersten Computer von den 70ern bis zu den fr√ºhen 90ern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410591/">  Ich habe zuf√§llig Assembler verschiedener Prozessoren programmiert.  Als letztes auf der Liste steht Xilinx MicroBlaze.  Ich beschloss, einige meiner Beobachtungen zu den Merkmalen dieser fast magischen Eisenst√ºcke zu ver√∂ffentlichen, die uns wie der magische Schl√ºssel von Pinocchio T√ºren im magischen Land der virtuellen Realit√§t und der Massenkreativit√§t √∂ffneten.  Informationen zu den Funktionen moderner Systeme x86, x86-64, ARM, ARM-64 usw.  Ich werde nicht schreiben, vielleicht ein anderes Mal - das Thema ist sehr gro√ü und komplex.  Daher habe ich vor, mit Intel 80486 und Motorola 68040 fertig zu werden. Ich wollte auch die IBM / 370 einbeziehen, mit der ich mich befasst habe.  Diese Systeme waren ziemlich weit von der Masse der Benutzer entfernt, hatten aber gleichzeitig einen enormen Einfluss auf die Computertechnologie.  Sie hatten einfach nicht genug Zeit f√ºr das Thema, sie verwendeten keine Prozessorchips und aus irgendeinem Grund schienen sie selbst v√∂llig verschwunden zu sein.  Ich hoffe wirklich, dass meine Materialien die Aufmerksamkeit von Kennern auf sich ziehen, die etwas hinzuf√ºgen k√∂nnen, √ºber das sie nicht nachgedacht haben oder das sie nicht wussten. <br><br>  Zur Veranschaulichung f√ºge ich meinen kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Stein aus Rosetta hinzu</a> - Programme zur Berechnung der Zahl œÄ auf verschiedenen Prozessoren und Systemen unter Verwendung eines Verschlussalgorithmus, der behauptet, die schnellste seiner Implementierungen zu sein. <br><br><a name="habracut"></a><br><h2>  Intel 8080 und 8085 </h2><br>  Der erste echte Prozessor auf einem Chip, der in der ersten H√§lfte des Jahres 1974 hergestellt wurde, wird noch hergestellt und findet Verwendung.  Viele Male auf der ganzen Welt geklont, hatte es in der UdSSR die Bezeichnung KR580VM80A.  Moderne Intel-Prozessoren f√ºr PCs zeigen immer noch leicht ihre Affinit√§t zu diesem Reliktprodukt.  Ich selbst habe keine Codes f√ºr diesen Prozessor geschrieben, aber da ich mit der Architektur von z80 vertraut bin, w√ºrde ich es wagen, einige meiner Kommentare einzubringen. <br><br>  Das 8080-Befehlssystem kann wie andere Intel-Prozessoren f√ºr PCs kaum als ideal bezeichnet werden, ist jedoch universell, recht flexibel und verf√ºgt √ºber mehrere sehr attraktive Funktionen.  Von seinen Konkurrenten unterschieden sich Motorola 6800 und MOS Technology 6502, 8080 in einer gro√üen Anzahl von, wenn auch etwas ungeschickten Registern, und versorgten den Benutzer mit einer 8-Bit-Batterie A, einem 16-Bit-Halbakkumulator und einem Teilzeit-Schnell-HL-Indexregister sowie einem 16-Bit-SP-Stapelzeiger sowie zwei weitere 16-Bit-Register Sun und DE.  Die Register BC, DE und HL k√∂nnen als 6-Byte-Register verwendet werden.  Dar√ºber hinaus unterst√ºtzte der 8080 einen fast vollst√§ndigen Satz von Statusflags: √úbertrag, Vorzeichen, Null und sogar Parit√§t und Halb√ºbertragung.  Einige der Anweisungen aus dem 8080-Befehlssatz waren lange Zeit Speed-Champions.  Zum Beispiel tauscht der XCHG-Befehl den Inhalt von 16-Bit-DE- und HL-Registern in nur 4 Taktzyklen aus - es war au√üergew√∂hnlich schnell!  Eine Reihe anderer Teams, die zwar keine so lebendigen Rekorde aufgestellt haben, geh√∂rten lange Zeit ebenfalls zu den besten: <br><br><ul><li>  XTHL - Austausch des Inhalts des HL-Registers und der Daten oben auf dem Stapel, 18 Taktzyklen - selbst auf einem echten 16-Bit-8086 scheint ein solcher Befehl viel zu sein, und f√ºr einen 6800 oder 6502 ist es sogar schwierig, sich einen solchen Befehl vorzustellen. </li><li>  DAD - Addiere zum HL-Halbakkumulator den Wert eines anderen 16-Bit-Registers (BC, DE oder sogar SP), 10 Taktzyklen.  Dies ist eine echte 16-Bit-Addition mit dem Setzen des √úbertragsflags.  Wenn Sie HL mit sich selbst addieren, erhalten Sie eine schnelle 16-Bit-Linksverschiebung oder zweifache Multiplikation, eine Schl√ºsseloperation sowohl f√ºr die vollst√§ndige Multiplikation als auch f√ºr die Division. </li><li>  PUSH und POP - auf den Stapel legen und 16-Bit-Wert aus dem Register oder aus dem Register entfernen.  Wird in 11 und 10 Zyklen durchgef√ºhrt.  Dies sind die schnellsten Operationen von 8080 f√ºr die Arbeit mit Speicher, und bei ihrer Leistung erfolgt eine automatische Inkrementierung oder Dekrementierung von SP.  PUSH kann beispielsweise verwendet werden, um einen Speicher schnell mit einem Muster mit Werten aus 3 Registern (BC, DE, HL) zu f√ºllen.  Es gibt √ºberhaupt keine Befehle zum Arbeiten mit 8-Bit-Mengen mit einem Stapel. </li><li>  LXI - Laden einer 16-Bit-Konstante in das Register (HL, DE, BC, SP) f√ºr 10 Taktzyklen; </li><li>  RNZ, RZ, RNC, RC, RPO, RPE, RP, RM - bedingte R√ºckgaben von der Unterroutine, die den Code sauberer machen und das Schreiben zus√§tzlicher bedingter Verzweigungen √ºberfl√ºssig machen.  Diese Teams wurden in der x86-Architektur aufgegeben, es ist m√∂glich, dass der Code mit ihm vergeblich besser ausf√§llt. </li></ul><br>  Dieser Prozessor wurde im ersten Altair 8800-Personalcomputer verwendet, der nach der Ver√∂ffentlichung des Magazins Anfang 1975 sehr popul√§r wurde. In der UdSSR fand eine √§hnliche Ver√∂ffentlichung √ºbrigens erst 1980 statt und ihre entsprechende Relevanz erst 1986. <br><br><img src="https://img.newatlas.com/altair-8800-clone-0.jpg?auto=format%2Ccompress&amp;fit=max&amp;h=670&amp;q=60&amp;w=1000&amp;s=a0b62f09568803467c43a40736f5f4df" align="left"><br>  <i>Zuerst fast PC</i> <i><br></i> <br>  Der Intel 8080 wurde zur Grundlage f√ºr die Entwicklung des einstigen professionellen CP / M-Massenbetriebssystems, das bis Mitte der 1980er Jahre Mikrocomputer f√ºr die professionelle Arbeit dominierte. <br><br>  Nun zu den M√§ngeln.  8080 ben√∂tigte drei Spannungsversorgungen -5, 5 und 12 Volt.  Das Arbeiten mit Interrupts ist umst√§ndlich und langsam.  Und im Allgemeinen ist der 8080 ziemlich ruhig, wenn wir ihn mit den Konkurrenten vergleichen, die bald auftauchten.  6502 kann bis zu dreimal schneller sein, wenn mit derselben Frequenz wie 8080 gearbeitet wird. <br><br>  In der Architektur von 8080 stellte sich jedoch heraus, dass es sich um eine korrekte Zukunftsvision handelte, n√§mlich um die in den 70er Jahren unbekannte Tatsache, dass Prozessoren schneller als Speicher sein werden.  Die Register 8080 DE und BC √§hneln eher einem Prototyp moderner handbetriebener Caches als Allzweckregister.  Der 8080 startete mit einer Frequenz von 2 MHz und Konkurrenten mit nur 1, wodurch der Leistungsunterschied ausgeglichen wurde. <br><br>  Es ist schwer, den 8080 zu 100% als 8-Bit-Prozessor zu bezeichnen.  Nat√ºrlich hat er eine 8-Bit-ALU, aber es gibt viele 16-Bit-Anweisungen, die schneller sind als die Verwendung von nur 8-Bit-Analoga.  Und f√ºr einige Teams gibt es √ºberhaupt keine 8-Bit-Analoga.  Das XCHG-Team besteht im Wesentlichen aus 100% 16-Bit.  Es gibt echte 16-Bit-Register.  Daher wage ich es, 8080 teilweise 16-Bit aufzurufen.  Es w√§re interessant, den Prozessorkapazit√§tsindex aus der Gesamtheit der Zeichen zu berechnen, aber soweit der Autor wei√ü, hat noch niemand einen solchen Job gemacht. <br><br>  Der Autor kennt den Grund nicht, warum Intel die direkte Unterst√ºtzung f√ºr die Entwicklung von 8-Bit-PCs mit seinen Prozessoren verweigerte.  Intel war schon immer von der Komplexit√§t und Mehrdeutigkeit der Politik gepr√§gt.  Insbesondere die Verbindung zur Politik zeigt sich darin, dass Intel lange Zeit Fabriken in Israel betrieb und bis Ende der 90er Jahre geheim war.  Intel hat praktisch nicht versucht, den 8080 zu verbessern, die Taktfrequenz wurde nur mit einem kleinen MHz auf 3 erh√∂ht.  Tats√§chlich wurde der 8-Bit-Markt mit einem verwandten 8080-z80-Prozessor auf Zilog √ºbertragen, der den Hauptkonkurrenten, den ‚ÄûTerminator‚Äú 6502, recht erfolgreich konfrontieren konnte. <br><br>  In der UdSSR und in Russland wurde der inl√§ndische Klon 8080 zur Grundlage vieler Massencomputer, die bis in die fr√ºhen 90er Jahre popul√§r blieben.  Dies sind nat√ºrlich Radio-86RK, Mikrosh, Orion-128, Vector und Corvette.  Die billigen und verbesserten zX Spectrum z80-basierten Klone besiegten jedoch die Clone Wars. <br><br><img src="https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531/"><br>  <i>Dies ist ein echter PC.</i> <br><br>  Anfang 1976 stellte Intel den 8085-Prozessor vor, der mit dem 8080 kompatibel ist, aber seinem Vorg√§nger weit √ºberlegen ist.  Es machte bereits die Stromversorgung von -5 und 12 Volt unn√∂tig und das Anschlussdiagramm wurde vereinfacht, die Arbeit mit Interrupts wurde verbessert, die Taktfrequenz wurde von 3 auf sehr solide 6 MHz verwendet, das Befehlssystem wurde mit mehreren n√ºtzlichen Anweisungen erweitert: 16-Bit-Subtraktion, 16-Bit-Verschiebung in nur 7 Zyklen nach rechts (dies ist sehr schnell), 16-Bit-Drehung nach links durch das √úbertragungsflag, Laden eines 16-Bit-Registers mit einem 8-Bit-Offset (dieser Befehl kann auch mit dem SP-Stapelzeiger verwendet werden), schreiben Sie das HL-Register in die Adresse im DE-Register √§hnlich wie h  HL flie√üen durch DE.  Alle oben genannten Anweisungen, mit Ausnahme der Verschiebung nach rechts, werden in 10 Zyklen ausgef√ºhrt - dies ist manchmal erheblich schneller als ihre Gegenst√ºcke oder die Emulation auf z80.  Ein paar weitere Anweisungen wurden hinzugef√ºgt und sogar zwei neue Flaggenflaggen.  Unter den neuen Flags ist das √úberlauf-Flag zu beachten, obwohl die Arbeit damit praktisch nicht unterst√ºtzt wurde.  Dar√ºber hinaus wurden viele Anweisungen zum Arbeiten mit Byte-Daten auf den Takt beschleunigt.  Dies war sehr wichtig, da auf vielen Systemen mit 8080 oder z80 Verz√∂gerungs-Ticks eingef√ºhrt wurden, die aufgrund des Vorhandenseins zus√§tzlicher Ticks auf dem 8080 die Ausf√ºhrungszeit fast zweimal verl√§ngern konnten.  Beispielsweise wurden in einem Haushaltscomputer Vektorbefehle vom Registerregistertyp f√ºr 8 Taktzyklen ausgef√ºhrt, und wenn dort 8085 oder z80 vorhanden w√§ren, w√ºrden dieselben Befehle in nur 4 Taktzyklen ausgef√ºhrt.  Der XTHL-Befehl ist sogar zwei Schritte schneller.  Mit den neuen Anweisungen k√∂nnen Sie Code zum Kopieren des Speicherblocks schreiben, der schneller ist als die LDI / LDD-Befehle des Z80-Prozessors!  Einige Anweisungen, z. B. 16-Bit-Inkrementierung und -Dekrementierung, PUSH und bedingte R√ºckgabe, wurden jedoch pro Takt langsamer. <br><br>  Der 8085 verf√ºgt √ºber eine integrierte Unterst√ºtzung f√ºr die Arbeit mit Interrupts, sodass Sie in vielen F√§llen auf einen separaten Interrupt-Controller im System und einen seriellen Ein- / Ausgangsanschluss verzichten k√∂nnen.  Wie bereits erw√§hnt, wurde 8085 das √úberlaufflag nicht vollst√§ndig unterst√ºtzt, sodass die Arithmetik von Zahlen mit einem Vorzeichen etwas unvollst√§ndig blieb. <br><br>  Ich kann jedoch die Formel ‚Äûaus dem Autor unbekannten Gr√ºnden‚Äú noch einmal wiederholen. Intel lehnte es ab, 8085 als Hauptprozessor zu bewerben.  Erst in den 80er Jahren erschienen mehrere recht erfolgreiche 8085-basierte Systeme. Das erste im Jahr 1981 war der Vorg√§nger und fast Rivale des IBM PC - IBM System / 23 Datamaster.  Dann wurde 1982 ein sehr schneller Computer mit hervorragender Grafik Zenith Z-100 ver√∂ffentlicht, in dem 8085 mit 5 MHz arbeitete.  1983 schuf die japanische Firma Kyotronic ein sehr erfolgreiches KC-85-Knieschoner, dessen Varianten auch von anderen Firmen hergestellt wurden: Tandy produzierte das TRS-80-Modell 100, NEC - PC-8201a, Olivetti - M-10.  Insgesamt wurden mehr als 10 Millionen Exemplare solcher Computer ver√∂ffentlicht!  In der UdSSR / RF gab es Anfang der 90er Jahre, basierend auf dem inl√§ndischen Klon IM1821VM85A, Versuche, einige Systeme zu verbessern, beispielsweise den Vektorcomputer.  √úberraschenderweise war der Hauptprozessor des Sojourner-Rovers, der 1997 die Marsoberfl√§che erreichte, 8085 mit einer Frequenz von 2 MHz! <br><br>  Tats√§chlich gab Intel dem z80 eine gr√ºne Farbe.  Einige Jahre sp√§ter, im Kampf um den 16-Bit-Markt, verhielt sich Intel v√∂llig anders und leitete eine Klage ein, um den Verkauf von v20- und v30-Prozessoren in den USA zu verbieten.  Interessanterweise konnten die genannten Prozessoren des japanischen Unternehmens NEC in den Modus der vollst√§ndigen Bin√§rkompatibilit√§t mit dem 8080 wechseln, was sie zu den schnellsten Prozessoren der 8080-Architektur machte. <br><br>  Ein weiteres Geheimnis von Intel ist die Weigerung, ein erweitertes Befehlssystem zu ver√∂ffentlichen, einschlie√ülich der Unterst√ºtzung neuer Flags.  Einer der offiziellen Hersteller dieser Prozessoren hat jedoch das gesamte Teamsystem ver√∂ffentlicht.  Was sind die Gr√ºnde f√ºr eine so seltsame Ablehnung?  Man kann nur raten.  Vielleicht spielte Zilog dann eine √§hnliche Rolle wie AMD und schuf den Anschein von Konkurrenz, und 8085 k√∂nnte Zilog st√ºrzen?  Vielleicht liegt der Punkt in dem Wunsch, das Befehlssystem n√§her an dem damals entworfenen 8086 zu halten?  Letzteres scheint zweifelhaft.  Intel 8086 wurde mehr als 2 Jahre nach der Ver√∂ffentlichung von 8085 ver√∂ffentlicht, und es ist kaum zu glauben, dass sein Befehlssystem bereits 1975 bekannt war.  In jedem Fall kann die Kompatibilit√§t mit 8080 und 8085 bis 8086 nur mit einem Makroprozessor erreicht werden, wobei manchmal ein 8080/8085-Befehl durch mehrere eigene ersetzt wird.  Dar√ºber hinaus sind die beiden ver√∂ffentlichten neuen Anweisungen 8085 in 8086 √ºberhaupt nicht durchf√ºhrbar.  Es ist besonders schwierig zu erkl√§ren, warum Intel nach der Ver√∂ffentlichung von 8086 keine Informationen √ºber neue Teams ver√∂ffentlicht hat. Wir k√∂nnen nur davon ausgehen, dass es sich h√∂chstwahrscheinlich um Marketing handelte.  Vor diesem Hintergrund haben wir die Spezifikationen von 8085 k√ºnstlich verschlechtert und einen spektakul√§reren 8086 erhalten. <br><br><h2>  Motorola 6800 und nahe Verwandte </h2><br>  Motorola-Prozessoren zeichneten sich seit jeher durch das Vorhandensein mehrerer sehr attraktiver "Highlights" aus, w√§hrend gleichzeitig einige architektonische L√∂sungen vorhanden waren, die in Bezug auf Abstraktheit und geringe Praktikabilit√§t absurd sind.  Das wichtigste "Highlight" aller fraglichen Prozessoren ist die zweite volle und sehr schnelle Registerbatterie. <br><br>  Der 6800 war der erste Prozessor der Welt, der nur eine Stromquelle (5 Volt) ben√∂tigte - es war eine sehr n√ºtzliche Innovation.  Aufgrund der Einzigartigkeit des 16-Bit-Indexregisters, die f√ºr eine 8-Bit-Architektur umst√§ndlich ist, erwies sich der Ho 6800 als unpraktisch f√ºr die Programmierung und Verwendung durch das Produkt.  Es wurde 1974 ver√∂ffentlicht, nicht viel sp√§ter als 8080, wurde aber nie zur Grundlage f√ºr ein bekanntes Computersystem.  Interessanterweise nannten die 6502-Entwickler Chuck Peddle und Bill Mensch den 6800 falsch, "zu gro√ü".  Er und seine Varianten wurden jedoch h√§ufig als Mikrocontroller eingesetzt.  Vielleicht ist es erw√§hnenswert, dass Intel seit 1971 Prozessoren herstellt, was Motorola in die Lage versetzt, eine Fangseite zu sein, f√ºr die der 6800 der allererste Prozessor war.  Und wenn Sie den 6800 nicht mit 8080 vergleichen, sondern mit seinem Vorg√§nger 8008, dann ist der 6800 viel besser.  Motorola hat Intel mit 68000/20/30/40 fast eingeholt.  Sie k√∂nnen auch feststellen, dass Motorola in den 70er Jahren ein viel gr√∂√üeres Unternehmen als Intel war. <br><br>  Es wurden auch zahlreiche 6800 Varianten hergestellt: 6801, 6802, 6803, 6805, ... Die meisten davon sind Mikrocontroller mit integriertem Speicher und Eingangs- / Ausgangsanschl√ºssen.  6803 ist ein vereinfachter 6801 und wurde sehr sp√§t (1983) f√ºr seinen Klassencomputer Tandy TRS-80 MC-10 und seinen franz√∂sischen Klon Matra Alice verwendet, die mit Commodore VIC-20 (1980) oder Sinclair ZX81 (1981) vergleichbar waren.  Das Befehlssystem 6801/6803 wurde erheblich verbessert, 16-Bit-Befehle, Multiplikation, wurden hinzugef√ºgt ... Ein ungew√∂hnlicher bedingungsloser Verzweigungsbefehl (BRN - Verzweigung nie) ist erschienen, der niemals ausgef√ºhrt wird!  Einige Anweisungen sind etwas schneller geworden. <br><br>  680x unterst√ºtzt die Arbeit mit vorzeichenbehafteten Ganzzahlen vollst√§ndig, z80 und 6502 unterst√ºtzen es schlechter, w√§hrend die 8080 und 8085 fast keine solche Unterst√ºtzung haben.  In 8-Bit-Software wurde eine solche Unterst√ºtzung jedoch selten ben√∂tigt. <br><br>  6809 wurde 1978 ver√∂ffentlicht, als die 16-Bit-√Ñra bereits mit 8086 begonnen hatte, und verf√ºgt √ºber ein sehr entwickeltes Befehlssystem, das das Multiplizieren von zwei Byte-Batterien umfasst, um ein 16-Bit-Ergebnis in 11 Zyklen zu erhalten (zum Vergleich ben√∂tigt 8086 70 Zyklen f√ºr eine solche Operation). .  In mehreren F√§llen k√∂nnen zwei Batterien zu einer 16-Bit-Batterie zusammengefasst werden, was schnelle 16-Bit-Anweisungen ergibt.  6809 hat zwei Indexregister und eine Datensatzanzahl von Adressierungsmethoden unter 8-Bit-Prozessoren - 12. Unter den Adressierungsmethoden gibt es eindeutige f√ºr 8-Bit-Chips, wie z. B. Index mit automatischer Inkrementierung oder Dekrementierung, relativ zum Befehlsz√§hler, Index mit Offset.  6809 bietet eine interessante M√∂glichkeit, zwei Arten von Interrupts zu verwenden: Sie k√∂nnen schnelle Interrupts mit teilweiser automatischer Registerspeicherung und Interrupts mit vollst√§ndiger Registerspeicherung verwenden - 6809 verf√ºgt √ºber drei Eing√§nge f√ºr Interruptsignale FIRQ (schnell maskierbar), IRQ (maskierbar), NMI (nicht maskierbar).  Manchmal ist es auch praktisch, schnelle Anweisungen zum gleichzeitigen Lesen und Setzen aller Flags zu verwenden. <br><br>  Speicheroperationen erfordern jedoch mehr als 6502 Taktzyklen. Indexregister sind in einer 8-Bit-Welt ungeschickte 16-Bit-Dinosaurier geblieben. Einige Operationen sind aufgrund ihrer Langsamkeit einfach schockierend. Beispielsweise dauert das √úbertragen einer Byte-Batterie auf eine andere 6 Zyklen, und der Austausch dauert 6 Zyklen Ihr Inhalt betr√§gt 8 Zyklen (vergleiche mit 8080, wo ein 16-Bit-Austausch in 4 Zyklen stattfindet)!  Aus irgendeinem Grund werden sofort zwei Stapelzeiger angeboten, vielleicht war es der Einfluss der Deadlock-Architektur VAX-11 - in einer 8-Bit-Architektur mit 64 KB Speicher sieht es sehr umst√§ndlich aus.  Und selbst das Vorhandensein einer Anweisung mit dem interessanten Namen SEX kann nicht alle Probleme von 6809 l√∂sen.  Im Allgemeinen ist 6809 bei gleicher Frequenz immer noch etwas schneller als 6502, erfordert jedoch dieselbe Speichergeschwindigkeit.  Ich habe es geschafft, die Division f√ºr 6809 mit einer 32-Bit-Dividende und einem 16-Bit-Divider (32/16 = 32,16) f√ºr etwas mehr als 520 Zyklen durchzuf√ºhren, f√ºr 6502 konnte ich nicht weniger als 650 Zyklen erreichen.  Die zweite Batterie ist ein gro√üer Vorteil, aber andere Merkmale des 6502, insbesondere die invertierte √úbertragung, reduzieren diesen Vorteil nur auf die angegebenen 25%.  Die Multiplikation mit einer 16-Bit-Konstante erwies sich jedoch als langsamer als die Tabelle 1 f√ºr 6502 mit einer Tabelle f√ºr 768 Bytes.  Mit 6809 k√∂nnen Sie relativ kompakte und schnelle Codes unter Verwendung der Adressierung der installierten Seite (direkte Seite) schreiben, aber diese Adressierung macht die Codes ziemlich verwirrend.  Das Wesentliche dieser Adressierung besteht darin, das High-Byte der Datenadresse in einem speziellen Register festzulegen und nur das Low-Byte der Adresse in den Befehlen anzugeben.  Das gleiche System mit nur einem festen High-Byte-Wert wird in 6502 verwendet, wo es als Nullseitenadressierung bezeichnet wird.  Das Adressieren der installierten Seite ist ein direktes Analogon zur Verwendung des DS-Segmentregisters in x86 nicht nur f√ºr Segmente mit 64 KB, sondern auch f√ºr Segmente mit nur 256 Byte.  Eine andere weit hergeholte Architektur von 6800 ist die Verwendung der Bytereihenfolge von hoch nach niedrig (Big Endian), wodurch 16-Bit-Operationen der Addition und Subtraktion verlangsamt werden.  Der 6809 ist nicht vollst√§ndig mit den 6800-Befehlscodes kompatibel. 6809 war der letzte 8-Bit-Prozessor von Motorola. In weiteren Entwicklungen wurde beschlossen, stattdessen 68008 zu verwenden. <br><br>  Es ist davon auszugehen, dass Motorola viel Geld f√ºr die Werbung f√ºr 6809 ausgegeben hat. Dies gilt auch bei der Erw√§hnung dieses Prozessors.  Um 6809 gibt es viele positive Bewertungen, die sich in einigen Nebeln, Verallgemeinerungen und Unbestimmtheiten unterscheiden.  6809 wurde als 8-Bit-Mikroprozessor-basierter Superprozessor positioniert.  Fast Unix-, OS-9- und UniFlex-Betriebssysteme wurden sogar f√ºr ihn entwickelt.        Apple Macintosh ,       ,          68000. , 6809 ‚Äì   ,            6502 (   )  z80 ( ).   ,   ,   Motorola          6809    6502. <br><br> 6809       .     ‚Äì    Tandy Color  Tandy Coco,         Dragon-32/64.   80-     Tandy Coco      ,           .   6809 -      80-  Thomson,       -   . 6809            :   Commodore SuperPET 9000          TUBE-  BBC Micro.          ,  , .         .      , Vectrex,     ‚Äì  . <br><br><img src="https://i.imgur.com/DOVW3CM.jpg"><br> <i>  3</i> <br><br> 680x        ¬´  ¬ª (Halt and Catch Fire ‚Äì HCF),       , , .      ,        (reset).       .  6800 , ,      , ..          ! <br><br>   8080, 8085  z80 6809     8-.  6309     8-,     Toshiba (        ,    ,   1982)  ,    6809. ,        ,        6809      .       ,     1988   Usenet.     ,      ,    .      .   ,           32-   16-  (32/16=16,16)  34 ,     .   16-   32-   28 .               6 + 3n,  n ‚Äì    ,     ,     .            .      .     , -  .             0.  - , 6309 ‚Äì      8-         64 . <br><br> 6309      6809,        Tandy  .     , e   6309. <br><br><h2> MOS Technology 6502  WDC 65816 </h2><br>      .           .            .    : <br><br><ul><li>  - Motorola,   -    Intel; </li><li>   MOS Technology; </li><li>   6502       . </li></ul><br>  Alles begann damit, dass Motorola sich aus v√∂llig unbekannten Gr√ºnden weigerte, die Initiative junger Ingenieure zu unterst√ºtzen, die vorschlugen, den allgemein mittelm√§√üigen Prozessor 6800 zu verbessern. Sie mussten das Unternehmen verlassen und ihre Arbeit bei dem kleinen, aber vielversprechenden Unternehmen MOS Technology fortsetzen, wo sie bald zwei Prozessoren vorbereiteten 6501 und 6502 mit NMOS-Technologie hergestellt.  Der erste war mit dem 6800 kompatibel, ansonsten waren sie identisch.  Dem Team 6501/6502 gelang es, eine neue Technologie zur Chipherstellung erfolgreich einzuf√ºhren, die die Kosten f√ºr neue Prozessoren drastisch senkte.  1975 konnte MOS Technology 6502 US-Dollar f√ºr 25 US-Dollar anbieten, w√§hrend der Startpreis f√ºr Intel 8080 und Motorola 6800 1974 bei 360 US-Dollar lag.  1975 senkten Motorola und Intel die Preise, lagen aber immer noch nahe bei 100 US-Dollar.  Experten von MOS Technology behaupteten, ihr Prozessor sei bis zu viermal schneller als der 6800. Dies erscheint mir zweifelhaft: Der 6502 kann viel schneller mit Speicher arbeiten, aber der zweite 6800-Akku beschleunigte viele Berechnungen erheblich.  Ich kann sch√§tzen, dass 6502 im Durchschnitt schneller als nicht mehr als zweimal war.  Motorola hat eine Klage gegen seine ehemaligen Mitarbeiter eingereicht - sie haben angeblich viele der technologischen Geheimnisse des Unternehmens genutzt.  W√§hrend des Prozesses konnte festgestellt werden, dass einer der Ingenieure, die Motorola verlassen hatten, einige vertrauliche Dokumente zum 6800 herausgab, die den Einstellungen ihrer Kollegen widersprachen.  Ob es seine eigene Tat war oder einige F√ºhrungskr√§fte hinter ihm standen, ist noch unbekannt.  Aus diesem und anderen nicht ganz klaren Gr√ºnden zwang Motorola MOS Technology, dessen finanzielle M√∂glichkeiten sehr gering waren, einen erheblichen Betrag von 200.000 US-Dollar zu zahlen und die Produktion von 6501 einzustellen. Intel handelte in einer √§hnlichen Situation mit Zilog √ºberhaupt nicht.  Obwohl zugegeben werden muss, dass MOS Technology manchmal zu riskant war, als es versuchte, das gro√üe Geld, das Motorola ausgab, f√ºr 6800 f√ºr seine eigenen Zwecke zu bewerben. <br><br>  Weiter in der Geschichte erscheinen die legend√§re Commodore-Firma und ihr ebenso legend√§rer Gr√ºnder Jack Tramiel, in deren Schatten die Figur des Hauptfinanzierers der Firma stand, die ihre Politik bestimmt - ein Mann namens Irving Gould.  Jack erhielt einen Kredit von Irving und zwang MOS Tecchnology mit diesem Geld, um es milde und skrupellos auszudr√ºcken, MOS Tecchnology, Teil des Commodore zu werden.  Danach wurde, m√∂glicherweise entgegen den W√ºnschen von Tramel, der Hood nachgeben musste, die Entwicklung von 6502 praktisch gestoppt, obwohl es 1976 m√∂glich war, Prototypen 6502 mit Betriebsfrequenzen bis zu 10 MHz herzustellen, obwohl eine Nachricht dar√ºber erst nach vielen Jahren von einer Person erschien genannt Bill Mensch (er war in dem Team, das Motorola verlassen hat), der wiederholt laute, aber weitgehend leere Aussagen machte und eine eher zweideutige Rolle im Schicksal von 6502 spielte.  Der Chefentwickler von 6502, Chuck Peddle, wurde f√ºr immer von der Entwicklung von Prozessoren ausgeschlossen.  6502 wurde weiterhin nicht nur bei Commodore produziert, sondern auch in dem von Bill Mensch, Western Design Center (WDC), gegr√ºndeten Unternehmen.  Es ist merkw√ºrdig, dass in Zukunft keines der vorherigen 6502-Teams mit ihm zusammengearbeitet hat. <br><br>  Das Drama um 6502 endete dort nicht.  1980 erschien in Rockwells AIM65 Interactive Magazine ein kurzer anonymer Artikel, der besagt, dass alle 6502 einen gef√§hrlichen Fehler namens JMP (xxFF) tragen.  Der Ton des Artikels deutet auf etwas v√∂llig Au√üergew√∂hnliches hin.  In der Folge wechselte diese Haltung zu Apples Position zu diesem Thema und wurde zu einer Art Mainstream.  Obwohl es streng genommen keinen ‚ÄûBug‚Äú gab.  Nat√ºrlich scheint eine der Funktionen, die f√ºr Mikroprozessoren durchaus angemessen und sogar n√ºtzlich ist, f√ºr einen Spezialisten, der sich an die komfortablen Prozessoren gro√üer Systeme jener Jahre gew√∂hnt hat, ein √§rgerlicher Fehler zu sein.  Tats√§chlich wurde dieses Verhalten, das die Gef√ºhle eines Menschen verletzte, in der offiziellen Dokumentation von 1976 und in den Programmierlehrb√ºchern beschrieben, die vor dem Erscheinen des genannten Artikels erschienen.  Der ‚ÄûFehler‚Äú wurde von Bill Mensch behoben, der vermutlich 1983, dh nach der Ver√∂ffentlichung von 65816, 6502 (CMOS 6502) herstellte. W√§hrend Intel, Motorola und andere 16-Bit-Prozessoren neuer Generationen herstellten, wurde 6502 nur mikroskopisch verbessert und k√ºnstlich teilweise mit sich selbst unvereinbar gemacht.  Zus√§tzlich zur Beseitigung des ‚ÄûFehlers‚Äú wurden eine Reihe von √Ñnderungen vorgenommen, die insbesondere zu einer √Ñnderung bei der Ausf√ºhrung mehrerer Anweisungen f√ºhrten, die pro Schlag langsamer wurden, aber gleichzeitig in einem weit hergeholten akademischen Sinne korrekter wurden.  Aber ich muss zugeben, dass einige neue Anweisungen erwartet und n√ºtzlich waren.  Auf der anderen Seite belegte die √ºberwiegende Mehrheit der neuen Anweisungen nur den Codebereich und f√ºgte den Funktionen von 6502 fast nichts hinzu, wodurch weniger neue Codes f√ºr m√∂gliche weitere Upgrades √ºbrig blieben.  Commodore und der Japaner Ricoh (Hersteller der beliebtesten NES-Spielekonsolen) haben diese √Ñnderungen nicht akzeptiert.  Der Autor dieses Materials selbst ist mehrmals auf das Problem dieses ‚ÄûFehlers‚Äú gesto√üen.  Er wusste nichts √ºber ihn und schrieb Programme f√ºr Commodore.  Dann √ºbertrug er einen von ihnen auf Systeme, in denen ein Befehlssatz 6502 verwendet wurde.  Inkompatibilit√§t trat auf, ich musste die Codes √§ndern, eine bedingte Kompilierung vornehmen.  Der Code f√ºr 6502 erwies sich als sperriger und langsamer.  Dann sprach er dieses Problem im Forum 6502.org an, wo die meisten Teilnehmer aus der Apple-Welt stammen.  Ich fragte, ob jemand ein Beispiel geben k√∂nnte, wenn der angegebene "Fehler" das Programm zum Absturz brachte.  Ich erhielt nur emotionale und allgemeine Kommentare, es wurde kein konkretes Beispiel vorgeschlagen. <br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png">  Bug !!! <br><br>  65C02 wurde an viele Firmen lizenziert, insbesondere an NCR, GTE, Rockwell, Synertek und Sanyo.  Wird in Apple II verwendet, beginnend mit IIe-Modellen, obwohl viele IIe NMOS 6502 verwendeten. Die 65C02 6512-Variante wurde auch in sp√§teren BBC Micro-Modellen verwendet.  Atari verwendete NMOS 6502. Zus√§tzlich zu CMOS 6502 produzierten Synertek und Rockwell auch NMOS 6502. NMOS 6502 verf√ºgt √ºbrigens √ºber einen eigenen Satz von undokumentierten Anweisungen, deren Art sich vollst√§ndig von den ‚Äûgeheimen‚Äú Befehlen 8085 unterscheidet. In 6502 erschienen diese Anweisungen daher als Nebeneffekt der verwendeten Technologie Die meisten von ihnen sind ziemlich nutzlos, aber mehrere, zum Beispiel das Laden oder Entladen von zwei Registern mit einem Befehl gleichzeitig, und einige andere k√∂nnen den Code schneller und kompakter machen. <br><br>  Es gab andere Versuche, den 6502 zu aktualisieren. Im selben Jahr 1979 erschien ein Artikel, in dem sich Atari-Computer auf die Produktion des 6509-Prozessors vorbereiteten (nicht zu verwechseln mit dem Prozessor mit dem gleichen Namen der sp√§ter erscheinenden Commodore-Firma), der die Ausf√ºhrung von Befehlen um 25% und viele neue beschleunigen sollte Anweisungen.  Aus Gr√ºnden, deren Genauigkeit nicht bekannt ist, fand die Herstellung dieses Prozessors jedoch nicht statt.  Commodore f√ºhrte nur mikroskopische Upgrades durch.  Dort wechselten sie insbesondere zur HMOS-Technologie und zur Herstellung statischer Kerne, wodurch die Prozessoren verlangsamt werden konnten.  Aus programmtechnischer Sicht ist der 6509-Prozessor am interessantesten, der, wenn auch in sehr primitiver Form, mit Hilfe von nur zwei speziell f√ºr diesen Zweck zugewiesenen Anweisungen die Adressierung von bis zu 1 MB Speicher erm√∂glicht.  Im √ºberaus beliebten Commodore 64 und 128 gab es 6510/8510 Prozessoren und in der weniger erfolgreichen 264-Serie 7501/8501.  Diese Prozessoren hatten nur 6 bzw. 7 integrierte E / A-Bit-Ports, w√§hrend der 7501/8501 nicht maskierbare Interrupts nicht unterst√ºtzte.  Rockwell produzierte die 65C02-Variante mit seinem erweiterten Befehlssatz f√ºr 32-Bit-Operationen (√§hnlich wie z80-Bit-Befehle). Soweit ich wei√ü, wurden solche Prozessoren jedoch nicht in Computern verwendet, und diese Bit-Befehle selbst wurden eher nur in eingebetteten Systemen verwendet.  Diese Erweiterung wurde √ºbrigens von Bill Mensch produziert. <br><br>  Die letzte Szene des Dramas mit der Beteiligung von 6502 wurde in der Pr√§vention von Computern auf Basis von 6502 mit einer Frequenz von 2 MHz f√ºr den US-Markt in der ersten H√§lfte der 80er Jahre angezeigt.  Dies betraf den Ausl√§nder-Engl√§nder BBC Micro, dessen Produktionsfirma Acorn eine gro√üe Menge Computer f√ºr die USA herstellte, aber, wie sich herausstellte, vergebens.  Eine Art Schloss funktionierte und die Computer mussten dringend nach europ√§ischen Standards erneuert werden.  Die halbamerikanischen, aber formal kanadischen Computer Commodore CBM II (1982) waren trotz einiger Probleme (insbesondere gem√§√ü den Normen f√ºr elektrische Ger√§te) weiterhin zugelassen.  Vielleicht aufgrund der Tatsache, dass sie keine Grafikmodi und sogar keinen Farbtext hatten - selbst das stilvolle Porsche-Design konnte dies nicht kompensieren.  Der letzte in der Liste der Verlierer war der 100% amerikanische Apple III (1980) - es ist bekannt, dass Steve Jobs, wie das Apple-Management im Allgemeinen, viel getan hat, um diesen Computer zu verhindern.  Jobs erforderten eindeutig unm√∂gliche Spezifikationen und Management - unrealistische Fristen.  Werden wir jemals ihre Motive herausfinden?  Mit dem 1983 ver√∂ffentlichten Apple III Plus konnten die M√§ngel des Apple III behoben werden. Das Apple-Management schloss das Projekt jedoch 1984 stillschweigend ab, da es nicht bereit war, mit dem Macintosh-Computer zu konkurrieren.  Erst 1985, als die √Ñra der 8-Bit-Technologie zu beginnen begann, erschien der Commodore 128, der 6502 in einem seiner Modi mit einer Taktrate von 2 MHz verwenden konnte.  Aber auch hier stellte sich heraus, dass es sich eher um einen Witz handelte, da dieser Modus praktisch nicht unterst√ºtzt wurde und es praktisch keine Programme daf√ºr gab.  Erst in der zweiten H√§lfte der 80er Jahre begannen in den USA Konsolenbeschleuniger f√ºr Apple II und seit 1988 das Apple IIc + Modell mit 4 MHz Prozessor zu produzieren.  Warum ist das passiert?  Vielleicht, weil 6502 mit 2 oder 3 MHz (und solche wurden bereits Anfang der 80er Jahre hergestellt) bei einer Reihe von Aufgaben und insbesondere bei Spielen erfolgreich mit Systemen konkurrieren konnte, die auf Intel 8088 oder Motorola 68000 basieren. 1991 schloss die Commodore Corporation Ein interessantes, wenn auch versp√§tetes Projekt C65, das auf einem 4510-Prozessor mit einer Frequenz von 3,54 MHz basiert.  4510 - dies ist der schnellste 6502, der erst 1988 hergestellt wurde. Er wurde schlie√ülich erw√§hnt und hat bereits eine fr√ºhere Optimierung der Zyklen erw√§hnt, die eine 25% ige Geschwindigkeitssteigerung ergab.  Somit ist der Prozessor in C65 in der Geschwindigkeit nahe an Systemen mit 6502 bei 4,5 MHz.  √úberraschenderweise wurde dieser schnellste 6502 mit einem erweiterten Befehlssatz (in einigen Details erwies sich diese Erweiterung als erfolgreicher als in 65816) seitdem nirgendwo mehr verwendet. <br><br>  C128 und Apple III Plus verf√ºgten √ºber eine Speicherverwaltungseinheit (Memory Management Unit, MMU), die die Verwendung mehrerer Stapel und Nullseiten f√ºr mehr als 64 KB Speicher usw. erm√∂glichte. In C128 wurde die MMU k√ºnstlich so angepasst, dass sie nur mit 128 KB Speicher funktioniert.  F√ºr BBC Micro wurden Konsolen mit 6502 bei 3 MHz (1984) und 4 MHz (1986) hergestellt. <br><br><img src="http://www.starringthecomputer.com/snapshots/jewel_of_the_nile_cbm_ii.jpg"><br>  <i>Anti-Werbung - mehrere Porsche-PETs in der Wohnung des B√∂sewichts aus der Perle des Nils (1985) - die √Ñra nur f√ºr Apple in Hollywood ist noch nicht angebrochen</i> <br><br>  Nun ein paar Worte zum 6502-Befehlssystem. Das Hauptmerkmal dieses Prozessors ist, dass er fast so schnell wie m√∂glich hergestellt wurde, praktisch ohne zus√§tzliche Taktzyklen, die in den Prozessoren 8080/8085 / z80 / 8088/68000 besonders zahlreich sind.  Tats√§chlich war es die Ideologie der 6502 RISC-Architekturprozessoren, die sp√§ter und unter direktem Einfluss auftauchte.  Dieselbe Ideologie dominiert, beginnend mit 80486, und unter Intel-Prozessoren.  Dar√ºber hinaus reagierte 6502 so schnell wie m√∂glich auf Unterbrechungen, was es in einigen eingebetteten Systemen sehr n√ºtzlich machte.  Der 6502 verf√ºgt √ºber eine Batterie und zwei Indexregister. Dar√ºber hinaus k√∂nnen die ersten 256 Byte Speicher in speziellen Befehlen entweder als schnellerer Speicher oder als Satz von 16-Bit-Registern (die in ihrer Funktionalit√§t fast identisch mit den BC- und DE-Registern in 8080 / z80 sind) verwendet werden ziemlich leistungsf√§hige Adressierungsmethoden.  Einige arithmetische Anweisungen (Verschiebungen, Drehung, Inkrementierung und Dekrementierung) k√∂nnen direkt mit dem Speicher verwendet werden, ohne Register zu verwenden.  Es gibt keine 16-Bit-Anweisungen - es handelt sich um einen 100% 8-Bit-Prozessor.  Alle wichtigen Flags mit Ausnahme der charakteristischen Intel Parity Flag-Architektur werden unterst√ºtzt.  Es gibt noch ein paar ungew√∂hnliche Flaggen des nutzlosen 10. Modus.  Intel- und Motorola-Prozessoren verwenden spezielle Korrekturanweisungen f√ºr die Arbeit mit Dezimalzahlen, und 6502 kann in den 10. Modus wechseln, wodurch der Geschwindigkeitsvorteil bei 10 Zahlen noch bedeutender ist als bei bin√§ren.  Es ist sehr beeindruckend, dass f√ºr die 6502-Tabellenmultiplikation von 8-Bit-Operanden mit einem 16-Bit-Ergebnis weniger als 30 Taktzyklen erzielt werden, wobei die Gr√∂√üe der Hilfstabelle 2048 Byte betr√§gt.  Langsam erzeugt 6502 Massenkopiervorg√§nge des Speichers - ab 14 Taktzyklen pro Byte. <br><br>  6502 kann parallel mit einem anderen Ger√§t arbeiten, beispielsweise einem anderen 6502. Soweit ich wei√ü, wurden solche Systeme mit zwei Prozessoren nie hergestellt.  Anstelle des zweiten Prozessors wurde normalerweise ein Videocontroller verwendet, der den Speicher mit 6502 gemeinsam nutzte. <br><br>  65816 wurde 1983 von WDC ver√∂ffentlicht. Interessanterweise erhielt Bill Mensch von Apple Spezifikationen f√ºr den neuen Prozessor.  Dies war nat√ºrlich ein gro√üer Schritt nach vorne, aber offensichtlich versp√§tet und mit gro√üen architektonischen M√§ngeln.  65816 wurde von niemandem als Konkurrent f√ºr die Hauptprozessoren von Intel oder Motorola angesehen - es war bereits ein sekund√§rer Au√üenseiter, der bereits darauf programmiert war, einen weiteren Positionsverlust herbeizuf√ºhren.  65816 hatte zwei wichtige Vorteile - es war relativ billig und fast kompatibel mit dem immer noch sehr beliebten 6502. In den folgenden Jahren versuchte Bill Mensch nicht einmal, seine Idee zu verbessern, eine Schleifenoptimierung durchzuf√ºhren und die Adresse der Nullseite durch die erweiterte Seite unter Verwendung des Z-Registers zu ersetzen ( Dies geschah in 4510), um zumindest die Multiplikation hinzuzuf√ºgen ... WDC erh√∂hte nur die maximalen Taktfrequenzen und erreichte Mitte der 90er Jahre 14 MHz (dieser Prozessor wurde im beliebten Beschleuniger f√ºr C64 SuperCPU mit einer Frequenz von 20 MHz verwendet).  Allerdings bietet WDC auch jetzt (2019!) Aus irgendeinem Grund 65816 nur auf denselben 14 MHz an.  65816 kann bis zu 16 MB Speicher belegen, die hierf√ºr verwendeten Adressierungsmethoden sind jedoch alles andere als optimal.  Beispielsweise k√∂nnen Indexregister nur 8- oder 16-Bit sein, der Stapel kann nur in den ersten 64 KB Speicher abgelegt werden, nur dort k√∂nnen Sie die bequeme Kurzadressierung der installierten Seite (direkte Seite - Verallgemeinerung der Nullseite) verwenden und mit einem Speicher √ºber 64 KB arbeiten vergleichsweise ungeschickt, ... 65816 hat eine 16-Bit-ALU, aber einen 8-Bit-Datenbus, so dass es in arithmetischen Operationen nur etwa 50% schneller als 6502 ist. Trotzdem wurde 65816 in einer Menge von mehr als einer Milliarde ver√∂ffentlicht.  Nat√ºrlich erg√§nzen eine Reihe von Befehlen 65816 die L√ºcken in der 6502-Architektur deutlich, beispielsweise Befehle zum Massenkopieren von Speicher f√ºr 7 Taktzyklen pro Byte.  Sie k√∂nnen auch hinzuf√ºgen, dass 65816 fast alle Anweisungscodes verwendet (255 von 256).  Der letzte nicht verwendete Code ist f√ºr lange zuk√ºnftige Anweisungen gedacht, die nie erschienen sind. <br><br>  Apple IIx, an dessen Entwicklung Steve Wozniak aktiv beteiligt war, sollte 65816 verwenden, aber es war nur m√∂glich, die Produktion dieses Prozessors im Jahr 1984 einzurichten, und die erste Charge von 65816 war defekt, was zu √ºberm√§√üigen Verz√∂gerungen f√ºhrte und infolgedessen das gesamte Projekt geschlossen wurde. <br><br>  Es gibt auch eine Option 65816 65802, die einen 16-Bit-Adressbus verwendet und mit 6502-Anschl√ºssen kompatibel ist. Es gab Upgrades f√ºr Apple II, die auf diesem Prozessor basierten, aber mit einem solchen Upgrade k√∂nnen Sie nur mit speziell daf√ºr geschriebenen Programmen eine kleine Beschleunigung erzielen. <br><br>  6502 wurde in einer gro√üen Anzahl von Computersystemen verwendet, von denen die beliebtesten 8-Bit-Commodore, Atari, Apple, NES sind.  Interessanterweise wurde der 6502 als Tastaturcontroller im Commodore Amiga-Computer verwendet, und zwei 6502 mit 10 MHz wurden im Hochleistungs-Apple Macintosh IIfx verwendet.  Hier kann man nur die Atari-Spielekonsolen erw√§hnen, die von 1977 bis 1996 hergestellt wurden - sie wurden ungef√§hr 35 Millionen Mal verkauft!  65816 wurde im recht beliebten Apple IIgs-Computer, in der Super NES-Spielekonsole und auch im seltenen englischen Computer Acorn Communicator verwendet. <br><br>  1984 erschien im Byte-Magazin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel</a> √ºber eine schlechte Kopie des Apple-Computers [hergestellt in der UdSSR] vor dem Hintergrund von Bildern mit roten Bannern, Lenin und marschierenden Soldaten.  In diesem Artikel wurde ein merkw√ºrdiger Preis f√ºr diesen Computer genannt - 17.000 US-Dollar (dies ist eine absurde Zahl, der tats√§chliche Preis lag bei 4.000 Rubel) und ironischerweise darauf hingewiesen, dass die sowjetischen Hersteller den Preis drastisch senken m√ºssten, wenn sie ihr Produkt im Westen verkaufen wollten.  Achat wurde haupts√§chlich in der Schulbildung verwendet.  √Ñltere Achatmodelle waren fast 100% Apple-kompatibel] [und hatten einige ziemlich n√ºtzliche Erweiterungen. <br><br>  Sie k√∂nnen nur versuchen, sich vorzustellen, was passieren w√ºrde, wenn sich 6502 im gleichen Tempo wie seine Konkurrenten entwickeln k√∂nnte.  Es scheint mir, dass die schrittweise √úbertragung des Nullseiten-Speichers in Register und die schrittweise Erweiterung des Befehlssystems bei gleichzeitiger Optimierung der Zyklen es dem 6502-Terminator erm√∂glichen w√ºrden, in Bezug auf die Geschwindigkeit bis Anfang der 90er Jahre an der Spitze zu bleiben.  Die Einf√ºhrung von Modus 16 und dann 32 Bit w√ºrde die Verwendung gro√üer Speichermengen und schnellerer Befehle erm√∂glichen.  K√∂nnten seine Konkurrenten etwas zu widerlegen haben? <br><br>  Ich m√∂chte mit einigen allgemeinen philosophischen √úberlegungen enden.  Warum war der 6502 gebremst und hatte keine viel bessere Zukunft?  Vielleicht aufgrund der Tatsache, dass er wirklich gro√üe Firmen unter Druck setzen und eine v√∂llig neue Realit√§t schaffen konnte.  Aber war das 6502-Team daf√ºr eingerichtet?  Vielmehr wollten sie nur einen besseren Prozessor entwickeln. <br><br>  Bereits viel sp√§ter, zu Beginn des 21. Jahrhunderts, wurde das Unternehmen Lexra, das f√ºnf Jahre lang verschiedene innovative Prozessoren herstellte, mit Hilfe von Klagen aus weit hergeholten Gr√ºnden besiegt.  Diese traurige Geschichte erinnert ein wenig an das, was mit MOS Technology passiert ist. <br><br><h2>  Zilog z80 </h2><br>  Dieser Prozessor wurde zusammen mit 6502 zum Hauptprozessor der ersten Personal Computer.  Es gibt keine dramatischen Ereignisse in der Geschichte seines Auftretens und seiner Verwendung.  Es ist nur eine Intrige, dass Zilog die n√§chste Generation von Prozessoren nicht hergestellt hat.  Z80 begann 1976 zu produzieren und seine Varianten werden noch produziert. -           z80. <br><br>   .      6502,   Z80,   (Federico Faggin),    ,  Intel.    z80          Z8000    80-     ,        .       ,   ,    .  , ,  z80,  Zilog            Z8. <br><br> Z80 ‚Äì         ,  8080.             .  ,      8080     ,         . ,   Zilog      8080,      ,       z80.      Intel x86     GNU,   -           .  Z80    , Intel       8086. ,    z80    ,  ,   8086,     .  z80,    6502,       , ..       ,     ¬´ ¬ª, ¬´  ¬ª,     ‚Äì       ,  8086, 6800  PDP-11  . <br><br>    z80        21   ,        .     EXX,    48   ,  BC, DE, HL   ,     4 !  32- ARM        6 .      ,     .  : <br><br><ul><li> 16-  c   16-     15 ; </li><li>      8 ; </li><li>        ,   BC, DE, SP, IX,IY,    HL; </li><li> ,   -   8- ; </li><li>  ,       ; </li><li>    (JR); </li><li>  . </li></ul><br><br>     ,              .       16-  IX  IY,       . ,    IX  IY   Z80     6800    Z80!     ,     Z80    -       ,   . <br><br>   8080  z80         .    16-   ADD    ,        ,   -. <br><br>          8080.  z80     ,     (     8080)    .      2,         . <br><br> Z80     ,          CMOS,            .   ,       16-  I  IY.    Z80     , ,      . <br><br> , z80    ,  8080     16-.     z80  - ,    ,    z80    4-!    z80  8080 ‚Äì   . <br><br>       z80  6502,           .       ,       .       z80     ,   .  z80  4      ,   6502  6809  1.3 .     ,     ,    6502     2.4  2.6  ,  z80.      .   ,   ,    z80 ‚Äì   ,     ,        .   ,         z80  6502   2.2 .       ,        4- .     z80     .     z80,   PUSH,      6502,     .     z80   1.5  .  ,    32-   16- z80    1.7 . ,      .  , ,  ZX Spectrum c z80  3.5 MHz      64  6502  1 .   ,        z80  6502       , , -     Amstrad CPC/PCW    3.2 ,    4.    6502         .       ,   ,  ,  z80  25-40% ,  6502.     ,      2  z80      6 ,  6502   2 . <br><br> Z80       .      Tandy TRS-80,   ‚Äî ZX Spectrum,   Amstrad CPC  PCW. ,   Amstrad PCW     90-           90-.             MSX.   C128    z80,        ‚Äì   , 1985  , 8-  z80,   2 ,     1.6 .   ,     8080  70-.       CP/M        . <br><br><img src="http://www.old-computers.com/museum/photos/Amstrad_9512_Running_s1.jpg"><br> <i>       90-,   z80  ,   ZX Spectrum</i> <br><br>         z80 ‚Äì  BBC Micro c TUBE-  z80B  6 ,   1984.        ,  , ¬´ ¬ª.      Apple ][  1979.       Z80H  8    . ,  Microsoft  1980         .    Amstrad PCW16,   1994,   CMOS Z80   16 . <br><br>     MSX TurboR (1990)   R800,   z80.  R800    16-   32- .     16- ,      768     .  ,  R800 ‚Äî    Z800,       ,   ,    7.16 M.  ,   R800   28.64 ! <br><br>   Zilog     Z80     .  Z80     2.5 ,    Z80A      4  ‚Äì        ,  Z80 . Z80B   1980,    , ,     BBC Micro    (1989)  Sam Coup√©. Z80H    80-       8  ‚Äì     . ,   Zilog       ,      , ,  Z80  9   ,   ,   ,      . <br><br>    z80    Zilog  ,   16-  Intel.  1978,   8086   Z8000,    z80.          Intel , , Motorola ‚Äì 68000      Z8000,  Z8000       ,  ,     Unix. ,  IBM    Z8000     IBM PC,  Zilog   Exxon,     IBM.  -  Z8000 Zilog   1980  Exxon.      32- .  1986  Z80000,   Z8000,   <b></b>    .  ,  ,     Zilog   ,  ,   Zilog   -      ,   Exxon. <br><br>   ,  Zilog    ,     Z80,         Intel,           .       ,  , AMD, Cyrix, VIA. <br><br>      Z80    1985,    Z800. ,    Zilog    Z80000  Z800    .  1986,   z80000   Z280,    Z800, ,  ,         ,    ‚Äì      Intel 486DX2  486DX4  . Z280     ,       . ,     ‚Äì Z280,     ,       ,    <b></b>   . ,  Z280     Intel 80286,   ,   50%      80286  . ,   Z280  5  ,       . <br><br>          Hitachi,   1985   -Z80, HD64180,     Intel 80186,    512  ,    ,         Z80  . HD64180     . Zilog    HD64180       Z64180. Zilog     ,  ,     1        1986 .      Z180        ,     33 .       MSX2,    . ,  Z280  Z180    ,      80286  80186    .  1994   Z180   32- Z380,    z80      Intel 80386  Motorola 68020 ‚Äì Zilog       10 .  21     Z180    - eZ80      6502.     ,  ,   , DVD-, ,‚Ä¶ <br><br><h2> Texas Instruments TMS9900 </h2><br>          .          16- .    1976 .           (Big Endian).        Motorola  6800  68000     IBM/370.          (Little Endian). <br><br>  TMS9900    16- :  ,      .        32   16  .    -       6502.   , TMS9900     .   Z80,     .    ,     ,  (), , ,          .       RISC- .    ,       .                   .  ,        . TMS9900    ,         16. <br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br> <i> 16-   ‚Äì      </i> <br><br>     .     .   X             .    ,       8 ,   ‚Äì  14,   (16*16=32)  52     (32/16=16,16)  124        70-. <br><br> TMS9900     -5, 5  12       ‚Äì      .  1979       IBM,          IBM PC.   TMS9900 (  64  ,    ,  )            Intel 8088.      Texas Instruments    TMS9900  8- , TMS-9980,    33% . <br><br> TMS9900        TI99/4  TI99/4A,   ¬´¬ª     Commodore VIC-20  1983. ,      Texas Instruments           1983 $49 ( 1979   $1150!)        .        Commodore+4,      1986,        $49   1989 . T99/4A    1984, ,  -      .       16-.      256  (!)         16- .     -    8- .        16-   -0010. ,  TI99/4  TI99/4A     3  ‚Äì       -0010. <br><br>  TI-99/4  TI99/4A        TMS9918,           MSX,        .    Yamaha        ,  ,    TI-99/4  TI99/4A! <br><br>  TI99/4 ‚Äì    ,          . <br><br><h2>  DEC PDP-11 </h2><br>   70-    10-    DEC.  DEC   ,   IBM          ,    IBM  .         .   PDP-11   .   PDP-11    70-   90-.             .       , -60/81/85, -1/2/3, -0010/0011 (0010 ‚Äì   ,      ). <br><br> , DEC         VAX-11,      .     70- DEC      PDP-11,  ,       16-   .   PDP-11       70-. <br><br> PDP-11  ,      , , LSI-11, F-11, J-11.   70- DEC      T-11. ,    ,         ,           ,        .         Atari. T-11         ,        z80.     18011, 18012, 18013,‚Ä¶   DEC,      DEC.         . <br><br>     PDP-11    ,  ,      ,      .    PDP-11          Motorola 68000. <br><br>   PDP-11  16-.  8    (      ‚Äì    R7) ‚Äì 16 ,   (  ) 16- ,    1-  3- 16- .       (  , ,  XOR)   ‚Äì    .   ‚Äì    .   80-   ,     Intel x86    -.    PDP-11,         . , ,           90-  .       ,   ,   -  .    PDP-11         , , <br><br><pre><code class="plaintext">MOV @(R0)+,@-(R1)</code> </pre> <br>  bedeutet dasselbe wie der C / C ++ - Sprachoperator <br><br><pre> <code class="plaintext">**‚Äìr1 = **r1++;</code> </pre> <br>  , wobei r0 und r1 als deklariert sind <br><br><pre> <code class="plaintext">signed short **r0, **r1;</code> </pre> <br>  Ein weiteres Beispiel, ein Befehl <br><br><pre> <code class="plaintext">MOVB @11(R2),@-20(R3)</code> </pre> <br>  entspricht <br><br><pre> <code class="plaintext">**(r3-20) = **(r2+11);</code> </pre> <br>  wobei r2 und r3 als deklariert sind <br><br><pre> <code class="plaintext">char **r2, **r3;</code> </pre> <br>  In den heutigen popul√§ren Architekturen kann ein Team nicht auf ein solches Team verzichten, wahrscheinlich werden mindestens 10 Teams ben√∂tigt.  Sie k√∂nnen die Adresse auch relativ zum aktuellen Wert des Befehlsz√§hlers abrufen.  Ich werde ein weiteres Beispiel mit einfacherer Adressierung geben.  Das Team <br><br><pre> <code class="plaintext">ADD #16,11(R4)</code> </pre> <br>  in Intel x86 kann Architektur abgebildet werden <br><br><pre> <code class="plaintext">ADD [BX+11],16</code> </pre> <br>  In DEC-Assemblern ist es √ºblich, Operanden von links nach rechts zu schreiben, im Gegensatz zu Intel, wo sie von rechts nach links schreiben.  Es besteht Grund zu der Annahme, dass der GNU-Assembler f√ºr x86 unter dem Einfluss des PDP-11-Assemblers erstellt wurde. <br><br>  Multiplikations- und Divisionsbefehle sind nur symbolisch und nicht auf allen Prozessoren verf√ºgbar.  Die Dezimalzahlarithmetik ist ebenfalls optional - dies ist die sogenannte kommerzielle DEC-Terminologie-Arithmetik.  Als Kuriosit√§t der vollst√§ndigen Orthogonalit√§t werde ich ein Beispiel f√ºr einen Befehl geben <br><br><pre> <code class="plaintext">MOV #11,#22</code> </pre> <br>  was nach der Ausf√ºhrung wird <br><br><pre> <code class="plaintext">MOV #11,#11</code> </pre> <br>  - Dies ist ein Beispiel f√ºr die Verwendung einer Sofortkonstante als Operand.  Ein weiteres merkw√ºrdiges Team ist der einzigartige MARK-Befehl, dessen Code auf den Stapel geschoben werden muss und niemals explizit verwendet werden kann.  Das Aufrufen von Routinen in der PDP-11-Architektur ist ebenfalls etwas eigenartig.  Der entsprechende Befehl speichert zuerst das zugewiesene Register (kann ein beliebiges sein) auf dem Stapel, speichert dann den Befehlsz√§hler in diesem Register und schreibt erst dann den neuen Wert in den Befehlsz√§hler.  Der R√ºckgabebefehl aus dem Unterprogramm muss das Gegenteil bewirken und wissen, welches Register beim Aufrufen des Unterprogramms verwendet wurde.  Mit dem Befehlsz√§hler als normalem Register k√∂nnen sehr seltsame und unvorhersehbare Effekte erzielt werden. <br><br>  Es ist interessant, dass sich unter PDP-11-Programmierern eine Kultur der direkten Arbeit mit Maschinencodes entwickelt hat.  Programmierer k√∂nnten beispielsweise beim Debuggen ohne Disassembler arbeiten.  Oder schreiben Sie kleine Programme direkt in den Speicher, ohne sie zusammenzusetzen! <br><br>  Nat√ºrlich unterscheiden sich die Teamzeiten nicht in zu schnellen Eigenschaften.  Es war einmal √ºberraschend herauszufinden, dass auf dem Haushaltscomputer des BK der √úbertragungsbefehl von Register zu Register bis zu 12 Zyklen dauert (10 Zyklen bei Verwendung des Codes aus dem ROM) und Befehle mit zwei Operanden mit doppelter indirekter Adressierung f√ºr mehr als 100 Zyklen ausgef√ºhrt werden.  Z80 f√ºhrt eine 16-Bit-Register√ºbertragung f√ºr 8 durch. Die Langsamkeit des BC wird jedoch nicht so sehr durch den Prozessor verursacht, sondern durch die schlechte Qualit√§t des inl√§ndischen Speichers, unter dessen Merkmalen der BC angepasst werden musste.  Wenn ein ausreichend schneller Speicher verwendet wurde, sendete der BC 16 Registerbits auch f√ºr 8 Taktzyklen.  Fr√ºher gab es viele Kontroversen, was ist schneller als BC oder Spectrum?  Es muss sofort gesagt werden, dass der Spectrum einer der schnellsten 8-Bit-Massencomputer ist, wenn die oberen 32 KB Speicher verwendet werden.  Daher ist es nicht √ºberraschend, dass das Spektrum schneller als das BC ist, aber nicht viel.  Und wenn der BC mit einem Speicher ohne Bremsen arbeiten w√ºrde, w√§re er wahrscheinlich etwas schneller. <br><br>  Die Codedichte ist auch eher eine Schwachstelle der PDP-11-Architektur.  Die Anweisungscodes sollten ein Vielfaches der L√§nge des Maschinenworts sein - 2 Bytes, was besonders unangenehm ist, wenn mit Byteargumenten oder einfachen Befehlen wie dem Setzen oder Zur√ºcksetzen eines Flags gearbeitet wird. <br><br>  Interessant sind Versuche, einen Personal Computer auf Basis der PDP-11-Architektur herzustellen.  Einer der ersten PCs der Welt, der nur wenig sp√§ter als Apple und Commodore PET und etwas fr√ºher als der Tandy TRS-80 erschien, war der Terak 8510 / a mit Schwarzwei√ügrafiken und der M√∂glichkeit, eine unvollst√§ndige Version von Unix herunterzuladen.  Dieser PC war ziemlich teuer und wurde, soweit ich wei√ü, nur im US-amerikanischen Hochschulsystem verwendet.  Seit 1978 wurde der Computer in Form eines Bausatzes zur Montage des Heathkit H11 hergestellt.  DEC selbst hat ebenfalls versucht, einen eigenen PC zu bauen, allerdings sehr uneinheitlich.  DEC hat zum Beispiel einen PC herausgebracht, der auf dem z80 und 8088 basiert und offensichtlich eher gegen seine Hauptentwicklungen spielt.  Personal, das auf der PDP-11 DEC PRO-325/350/380-Architektur basiert, hatte einige eher k√ºnstliche Inkompatibilit√§ten mit der zugrunde liegenden Architektur, was es schwierig machte, einen Teil der Software zu verwenden.  Die beste Personalisierung von Mini-Computertechnologien war in der UdSSR, wo BK-, DVK- und CC-NTs hergestellt wurden ... Electronics-85 ist √ºbrigens ein ziemlich genauer Klon des DEC PRO-350.  Dar√ºber hinaus wurde der CP1600-Prozessor, √§hnlich der PDP-11-Architektur, in Intellivision-Spielekonsolen verwendet, die in den fr√ºhen 80er Jahren beliebt waren. <br><br><img src="https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg"><br>  <i>Inl√§ndischer 16-Bit-Heimcomputer (1985) - fast PDP-11-kompatibel</i> <br><br>  K1802BM2, das im DVK verwendet wurde, ist ungef√§hr doppelt so schnell wie K1801BM1, K1801BM3 ist sogar noch schneller und schneller als Intel 8086. <br><br>  Bei √§lteren PDP-11-Modellen und in der N√§he befindlichen Haushaltscomputern kann der Prozessor bis zu 4 MB Speicher adressieren, einem Programm k√∂nnen jedoch nicht mehr als 64 KB zugewiesen werden.  In Bezug auf die Geschwindigkeit liegen diese Prozessoren auch in Bezug auf die Anzahl der Operationen pro Megahertz nahe bei 8086, obwohl sie immer noch langsamer sind. <br><br><h2>  CPU f√ºr DEC VAX-11 </h2><br>  VAX-11-Systeme waren in den 80er Jahren sehr beliebt, insbesondere im Hochschulbereich.  Jetzt ist es schwierig, einige der in B√ºchern dieser Jahre beschriebenen Konzepte zu verstehen, ohne die Architektur dieser Systeme zu kennen.  Die VAX-11 waren teurer als die PDP-11, aber sie waren st√§rker auf universelle Programmierung ausgerichtet und immer noch deutlich billiger als IBM / 370-Systeme.  F√ºr die VAX-Architektur wurde Mitte der 80er Jahre ein V-11-Prozessor hergestellt, und bis zu diesem Zeitpunkt wurden Prozessorbaugruppen verwendet. <br><br>  Die VAX-11-Architektur ist 32-Bit, sie verwendet 16 Register, unter denen sich wie beim PDP-11 ein Befehlsz√§hler befindet.  Es sollen zwei Stapel verwendet werden, von denen einer zum Speichern von Hilfsrahmen verwendet wird.  Zus√§tzlich wird eines der Register zugewiesen, um mit Argumenten aufgerufener Funktionen zu arbeiten.  Somit sind 3 von 16 Registern f√ºr Stapel zugeordnet.  Das VAX-11-Befehlssystem √ºberrascht mit seiner Gr√∂√üe und dem Vorhandensein sehr seltener und h√§ufig eindeutiger Befehle, z. B. zum Arbeiten mit Bitfeldern oder verschiedenen Arten von Warteschlangen, zum Berechnen der CRC, zum Multiplizieren von 10 Zeilen ... Viele Befehle sind in Versionen mit drei Adressen erh√§ltlich (beide ARM) und in zwei Adressen (als x86), aber es gibt Befehle mit vier Adressen, zum Beispiel die erweiterte Aufteilung von EDIV.  Nat√ºrlich gibt es Unterst√ºtzung f√ºr die Arbeit mit reellen Zahlen. <br><br>  Aber der VAX-11 ist f√ºr seine Klasse und seinen Preis ein sehr langsames System.  Selbst der supereinfache 6502 mit 4 MHz k√∂nnte den langsamsten der VAX-11/730-Familie √ºberholen, und die schnellsten VAX-11-Systeme - riesige Schr√§nke und ‚Äûganze M√∂belsets‚Äú - erreichen das Leistungsniveau der ersten PC-ATs.  Als der 80286 erschien, wurde klar, dass die Tage des VAX-11 gez√§hlt waren und selbst das Bremsen mit der Einf√ºhrung von Systemen auf Basis des 80286 nichts mehr grundlegend √§ndern konnte.  Die unkomplizierteren Briten aus Acorn, die 1985 ARM hergestellt hatten, ohne etwas zu verbergen, sagten, ARM sei viel billiger und sp√ºrbar schneller.  VAX-11 blieb jedoch bis in die fr√ºhen 90er Jahre relevant und hatte immer noch einige Vorteile gegen√ºber einem PC, insbesondere schnellere Systeme f√ºr die Arbeit mit Festplatten. <br><br>  VAX-11 ist wahrscheinlich das letzte Massensystem, bei dem die Bequemlichkeit der Arbeit im Assembler als wichtiger als die Geschwindigkeit angesehen wurde.  In gewisser Weise hat sich dieser Ansatz auf moderne, beliebte Skriptsprachen verlagert. <br><br><img src="https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg" align="left">  <i>Das Foto zeigt den VAX-11/785 - dies ist auch ein Computer (1984) - der schnellste unter den VAX-11, vergleichbar in der Leistung mit dem IBM PC AT oder ARM Evaluation System</i> <br><br>  √úberraschenderweise gibt es nur sehr wenig Literatur zu VAX-11-Systemen.  Als ob ein seltsames Gesetz √ºber das Vergessen in Kraft w√§re.  Mehrere politiknahe Episoden, die mit der Geschichte der UdSSR korrelieren, sind mit der Geschichte dieser Architektur verbunden.  Es ist m√∂glich, dass die tats√§chliche Ablehnung der Entwicklung der PDP-11-Architektur durch ihre Billigkeit und den Erfolg ihres Klonens in der Sowjetunion verursacht wurde.  Das Klonen von VAX-11 kostete eine Gr√∂√üenordnung gro√üer Ressourcen und f√ºhrte zu einer Sackgasse.  Das Interesse an der VAX-11 wurde beispielsweise durch Kundgebungen wie den ber√ºhmten Kreml Vax am 1. April 1984 geweckt, bei denen der damalige F√ºhrer der UdSSR, Konstantin Chernenko, anl√§sslich der Verbindung zum Usenet-Netzwerk anbot, Wodka zu trinken.  Ein weiterer Witz war, dass einige VAX-11-Chips mit einer Nachricht in gebrochenem Russisch bedruckt waren, wie gut der VAX-11 ist.  :) :) <br><br>  Einige VAX-11-Modelle wurden Ende der 80er Jahre in der UdSSR geklont, aber nur sehr wenige solcher Klone wurden hergestellt und fanden fast nie Verwendung. <br><br>  F√ºr die Verwendung √ºber das Netzwerk stehen mehrere VAX-11-Systeme zur Verf√ºgung.  Und dies vergleicht sie g√ºnstig mit den IBM / 370-Systemen, mit denen sie konkurrierten. <br><br><h2>  Intel: 8086 bis 80486 </h2><br>  Nat√ºrlich ist 8086 einer der besten Prozessoren, die in den 70er Jahren hergestellt wurden, sowie der billigere, fast analoge 8088. Die Architektur dieser Prozessoren zeichnet sich angenehm durch das Fehlen mechanischer Anleihen und die Einhaltung abstrakter Theorien aus, durchdachte und ausgewogene Architektur, ausgewogen und fokussiert Weiterentwicklung.  Unter den M√§ngeln der x86-Architektur kann man von einer gewissen Umst√§ndlichkeit und einer Tendenz zu einem starken Anstieg der Anzahl von Anweisungen sprechen. <br><br>  Eine der genialen Designl√∂sungen von 8086 war die Erfindung von Segmentregistern.  Damit wurden sozusagen zwei Ziele erreicht: die ‚Äûfreie‚Äú Portabilit√§t von Programmen mit einer Gr√∂√üe von bis zu 64 KB (dies war bis Mitte der 80er Jahre eine sehr anst√§ndige Menge an Computerspeicher f√ºr ein Programm) und die Adressierbarkeit von bis zu 1 MB Adressraum.  Sie k√∂nnen auch feststellen, dass der 8086 wie der 8080 oder der z80 einen speziellen Adressraum f√ºr E / A-Ports mit einer Gr√∂√üe von 64 KB hat (y 8080 und 8085, dieses Volume ist 256 Byte).  Es gibt nur vier Segmentregister: f√ºr Code, f√ºr Stapel und zwei f√ºr Daten.  Somit stehen 64 * 4 = 256 KB Speicher f√ºr die schnelle Verwendung zur Verf√ºgung, dies war jedoch bereits Mitte der 80er Jahre der Fall.  Tats√§chlich gibt es kein Problem mit der Gr√∂√üe des Codes, da Sie die sogenannten langen Aufrufe von Unterprogrammen zum Laden und Speichern der vollst√§ndigen Adresse aus zwei Registern verwenden k√∂nnen.  Die Gr√∂√üe eines Unterprogramms ist nur auf 64 KB begrenzt - dies reicht f√ºr viele moderne Anwendungen aus.  Die Unm√∂glichkeit, Datenarrays mit einer Gr√∂√üe von mehr als 64 KB schnell zu adressieren, f√ºhrt zu einem gewissen Problem. Wenn Sie solche Arrays verwenden, m√ºssen Sie bei jedem Aufruf das Segmentregister und die Adresse selbst laden, wodurch sich die Arbeitsgeschwindigkeit mit so gro√üen Arrays um ein Vielfaches verringert. <br><br>  Segmentregister sind so implementiert, dass ihre Anwesenheit in Maschinencodes kaum wahrnehmbar ist, was es einfach machte, sie zu gegebener Zeit abzulehnen. <br><br>  Die 8086-Architektur behielt ihre N√§he zur 8080-Architektur bei, was einen vergleichsweise geringen Aufwand beim √úbertragen von Programmen von 8080 (oder sogar z80) auf 8086 erm√∂glichte, insbesondere wenn der Quellcode der Programme verf√ºgbar war. <br><br>  Die Teams 8086 unterscheiden sich nicht in der hohen Ausf√ºhrungsgeschwindigkeit, sind jedoch mit Wettbewerbern vergleichbar, beispielsweise dem Motorola 68000, das ein Jahr sp√§ter erschien.  Eines der neuen Produkte, das den im Allgemeinen ruhigen 8086 leicht beschleunigt, war die Wende der Teams. <br><br>  Der 8086 verwendet acht 16-Bit-Register, von denen einige als Zwei-Byte-Register und einige als Indexregister verwendet werden k√∂nnen.  Somit sind die 8086-Register etwas heterogen, aber sie sind gut ausbalanciert und die Register sind sehr bequem zu verwenden.  Diese Heterogenit√§t erm√∂glicht es Ihnen √ºbrigens, dichtere Codes zu haben.  Der 8086 verwendet dieselben Flags wie der 8080 sowie einige neue.  Beispielsweise wurde ein Flag angezeigt, das f√ºr die PDP-11-Architektur typisch ist - schrittweise Ausf√ºhrung. <br><br>  Mit 8086 k√∂nnen Sie sehr interessante Adressierungsmodi verwenden. Beispielsweise kann eine Adresse aus der Summe zweier Register und einer konstanten 16-Bit-Mischung bestehen, der der Wert eines der Segmentregister √ºberlagert ist.  Von der Summe der Adressen k√∂nnen nur zwei oder sogar ein Begriff weggelassen werden.  Dies funktioniert bei PDP-11 mit einem Befehl nicht.  Die meisten 8086-Befehle erlauben nicht beide Operanden vom Typ Speicher, einer der Operanden muss ein Register sein.  Es gibt jedoch Zeichenfolgenbefehle, die nur wissen, wie man mit dem Speicher unter Verwendung von zwei Adressen arbeitet.  Mit String-Befehlen k√∂nnen Sie schnell Blockkopien (17 Kennzahlen pro Byte oder Wort) durchf√ºhren, suchen, f√ºllen, laden und vergleichen.  Dar√ºber hinaus k√∂nnen Zeichenfolgenbefehle beim Arbeiten mit E / A-Ports verwendet werden.  Die Idee von 8086, Befehlspr√§fixe zu verwenden, ist sehr interessant, so dass h√§ufig sehr n√ºtzliche zus√§tzliche Funktionen verwendet werden k√∂nnen, ohne dass die Befehlscodierungsschemata wesentlich kompliziert werden. <br><br>  8086 hat eine der besten unter allen Computersystemen Organisation der Arbeit mit dem Stapel.  Mit nur zwei Registern (BP und SP) k√∂nnen Sie mit 8086 alle Probleme l√∂sen, wenn Sie Aufrufe von Routinen mit Parametern organisieren. <br><br>  Unter den Teams gibt es symbolische und vorzeichenlose Multiplikation und Division.  Es gibt sogar eindeutige Dezimalanpassungsbefehle f√ºr Multiplikations- und Divisionsbefehle.  Es ist schwer zu sagen, dass im 8086-Befehlssystem eindeutig etwas fehlt.  Eher das Gegenteil.  Das Teilen einer 32-Bit-Dividende in einen 16-Bit-Teiler, um einen privaten 32-Bit- und einen 16-Bit-Rest zu erhalten, kann bis zu 300 Taktzyklen erfordern - nicht besonders schnell, aber um ein Vielfaches schneller als eine solche Division auf 8-Bit-Prozessoren (au√üer 6309). und in der Geschwindigkeit mit 68000 vergleichbar. Die Division durch x86 hat eine unerwartete Eigenschaft - sie √§ndert die Zeichenflaggen unvorhersehbar ... <br><br>  Es ist erw√§hnenswert, dass in der x86-Architektur das vom 8080 geerbte XCHG-Team erhalten blieb, was verbessert wurde.  Dar√ºber hinaus verwendeten sp√§tere Prozessoren die Anweisungen XADD, CMPXCHG und CMPXCHG8B, die auch einen atomaren Austausch von Argumenten durchf√ºhren k√∂nnen.  Solche Anweisungen sind eines der Merkmale von x86. Es ist schwierig, sie auf Prozessoren anderer Architekturen zu finden. <br><br>  Wir k√∂nnen zusammenfassen, dass der 8086 ein sehr erfolgreicher Prozessor ist, der sowohl die Bequemlichkeit der Programmierung als auch die Bindung an Speicherbeschr√§nkungen kombiniert, die f√ºr ihre Zeit charakteristisch sind.  8086 wurde relativ selten verwendet, wodurch der billigere 8088 den Ehrenplatz erhielt, der erste Prozessor f√ºr die Haupt-PC-Architektur unserer Zeit, die IBM PC-Architektur, zu sein.  Der 8088 verwendete einen 8-Bit-Datenbus, was ihn etwas langsamer machte, aber es erm√∂glichte, darauf basierende Systeme zu bauen, die f√ºr Kunden zug√§nglicher waren. <br><br>  Interessanterweise weigerte sich Intel grunds√§tzlich, Verbesserungen an seinen Prozessoren vorzunehmen, und zog es vor, stattdessen die n√§chsten Generationen zu entwickeln.  Einer der gr√∂√üten zweiten Subunternehmer von Intel (NEC), das japanische Unternehmen NEC, das Anfang der 80er Jahre viel gr√∂√üer war als Intel, entschied sich f√ºr die Verbesserung der 8088 und 8086 und ver√∂ffentlichte V20- und V30-Prozessoren, die mit ihnen am Sockel kompatibel und bis zu 30% schneller sind.  NEC bot Intel sogar an, sein Subunternehmer zu werden!  Intel leitete stattdessen eine Klage gegen NEC ein, die jedoch nicht gewinnen konnte.  Aus irgendeinem Grund wurde dieser gro√üe Showdown zwischen Intel und NEC von Wikipedia v√∂llig ignoriert. <br><br>  80186 und 80286 erschienen 1982. Daher kann davon ausgegangen werden, dass Intel zwei nahezu unabh√§ngige Entwicklungsteams hatte.  80186 ist ein 8086, der durch mehrere Befehle und k√ºrzere Zeitabl√§ufe sowie mehrere f√ºr die x86-Architektur typische integrierte Schaltkreise verbessert wurde: Taktgenerator, Zeitgeber, DMA / DAP, Interrupt-Controller, Verz√∂gerungsgenerator usw. Ein solcher Prozessor scheint die Produktion erheblich zu vereinfachen Computer, die darauf basieren, aber da sich herausstellte, dass der integrierte Interrupt-Controller aus irgendeinem Grund nicht mit dem IBM-PC kompatibel ist, wurde er auf einem PC fast nie verwendet.  Der Autor kennt nur das BBC Master 512-System, das auf dem BBC Micro-Computer basiert und nicht die eingebauten Schaltkreise verwendet, auch nicht den Timer. Es gab jedoch mehrere weitere Systeme, die 80186 verwendeten. Der adressierbare Speicher von 80186 blieb auf die gleiche Weise wie bei 8086 mit einer Gr√∂√üe von 1 MB.  Das japanische Unternehmen NEC produzierte Analoga von 80186, die mit dem IBM PC kompatibel waren. <br><br>  80286 hatte noch bessere Timings als 80.186, wobei besonders die fantastische Division (32/16 = 16,16) f√ºr 22 Takte besonders bemerkenswert ist - seitdem hat man nicht gelernt, schneller zu teilen!  80286 unterst√ºtzt die Arbeit mit allen neuen 80186-Teams sowie mit vielen Teams, um in einem neuen, gesch√ºtzten Modus zu arbeiten.  80286 war der erste Prozessor mit integrierter Unterst√ºtzung f√ºr den gesch√ºtzten Modus, der das Organisieren des Speicherschutzes, die korrekte Verwendung privilegierter Anweisungen und den Zugriff auf den virtuellen Speicher erm√∂glichte.  Obwohl die Arbeit im neuen Modus viele problematische Probleme verursachte (der gesch√ºtzte Modus wurde eher erfolglos erstellt) und relativ selten verwendet wurde, war dies ein gro√üer Durchbruch.  In diesem neuen Modus haben Segmentregister eine neue Qualit√§t erhalten, sodass Sie bis zu 16 MB adressierbaren Speicher und bis zu 1 GB virtuellen Speicher pro Task verwenden k√∂nnen.  Das gro√üe Problem bei 80286 war die Unf√§higkeit, vom gesch√ºtzten Modus in den realen Modus zu wechseln, in dem die meisten Programme damals funktionierten.  Mit dem undokumentierten LOADALL-Befehl ‚Äûsecret‚Äú konnten 16 MB im Speicher und im Real-Modus verwendet werden. <br><br>  Im Jahr 80286 begann die Berechnung von Adressen in Operanden von Befehlen nach getrennten Schemata durchzuf√ºhren und verlangsamte die Ausf√ºhrung von Befehlen.  Dies f√ºgte beispielsweise dem Team interessante Funktionen hinzu <br><br><pre> <code class="plaintext">LEA AX,[BX+SI+4000]</code> </pre> <br>  In nur 3 Zyklen konnten zwei Additionen durchgef√ºhrt und das Ergebnis in das AX-Register √ºbertragen werden! <br><br>  Segmentierte Register im gesch√ºtzten Modus sind Teil eines vollst√§ndigen Speicherverwaltungssystems (MMU) geworden.  Im Real-Modus bieten diese Register nur teilweise MMU-Funktionalit√§t. <br><br>  Die Anzahl der Hersteller und spezifischen Systeme, die 80286 verwenden, ist enorm, aber die ersten waren nat√ºrlich IBM PC AT-Computer mit Leistungsindikatoren, die unter PCs fast fantastisch waren.  Von diesen Computern begann der Speicher in der Geschwindigkeit vom Prozessor zur√ºckzubleiben, es gab Verz√∂gerungszust√§nde, aber dann schien es etwas anderes vor√ºbergehend zu sein. <br><br>  80286,    8086/8088,        100% ,           . ,  POPF  80286      ,        (     REP ES:MOVSB)  8086/8088       .   POPF      80286. <br><br>   80286   ,         64          . 80386,   1985,       ,    4        .  ,       8086     8086.            . 80386         ,   80286.   80386       32-      .  ,  .      (barrel shifter),        . ,     -      .    ,   80286.    , ,  ,       ,     80286.         ,      16-  80286     - ,  80386     . <br><br>  80386    ,           ,        . ,   : <br><br><ul><li>  ,      ,   ,     z80; </li><li>   BSF  BSR; </li><li>       , MOVSX  MOVZX; </li><li>         SETxx; </li><li>    SHLD, SHRD. </li></ul><br>  x86   80386    ,       ‚Äì     .  80386       (    32- ) ,    ,        ( )  ,          ,  . <br><br>       4-   ,  ,         ,   . <br><br>        ,   80286,       .   ,   flat-     4 ,        .             flat-,         . <br><br>  80386  Intel    ,        IBM PC,     Motorola,      .    80386      90-,           25  40 . C 80386 IBM      IBM PC  .  ,  ,  ,      80386   1986   Compaq. <br><br><p>       ,     80386   .    ,  80386     ,       1970,     1980. <br><br></p><p>      80386.   .     ,               .       80386 ,    .     IBTS  XBTS.   80386DX/SX,   AMD,   Intel (     ),      ,       EAX,            POPAD  PUSHAD  ,     BX.       .      ,        .    . <br><br>  ARM      .   ,  ARM   .  Intel  80486.             Intel           ‚Äì   . <br><br>  80486                ARM  .     -   .  ,           ,   8088!      ,  8 ,  -.    , , CMPXCHG ‚Äì       IBTS  XBTS (,             80386).     ‚Äì  ,             32-  BSWAP.           ‚Äì     .      . <br><br>     80486   .  ,      80486,  VX FT,    Apricot ‚Äì    1989   18  40  ,     ‚Äì  60 !           Intel       ARM  Acorn. IBM      80486  1990,    PS/2 90  $17000. <br><br>     Intel  ,   .      ,     8086. ,        ,        AAD  AAM      ,   (      Pentium  15 !).      AND/OR/XOR    , , AND BX,7      (83 E3 07).  ,    ,       ,        80386. ,      8086  80286     ,       .      ADD/ADC/SBB/SUB,      . ,  ,   ,    (?)      .           ‚Äì       .  , ,   SAL/SHL ( D0 E0, D0 F0  D1 E0, D1 F0)   . ,    ,     . ,     .   ,  Intel     ,     ?  SALC      1995  20 !    ICEBP    10   1985  1995.       LOADALL  LOADALLD ‚Äì      ,                80286  80386 .        UD1 (0F B9),      .    . <br><br>        8088  8086,    80286    . <br><br></p><h2> Motorola:  68000  68040 </h2><br> Motorola ‚Äì   ,  -      Intel       . <br><br> 68000    1979        8086.   16 32-  (  17),      .   16   ,     , ,   . ,    68000 ,     ,  .       1  ‚Äì         .    68000 ,   8086 ‚Äì          68000  .     ,    68k    2   ,   86 ‚Äì 1.      ,    ,      68000    ,   8086.  16  ‚Äì 8 ,  -        x86.     16-,    32-  ,   .     - ‚Äì 4 ,   8086 ‚Äì  2.    68000   80-    ,    Intel 8088,  68000               ,          . <br><br>  ,    Motorola,  68000      . ,       (  ,    ).       . -  ,   MOVE,      .  ,       ,     68000,     ,   68010.     , ,      CLR     0    MOVE         .     , ,   ,     .             8086,    . ,      4     8086       .   68000       PDP-11,    60-. <br><br>   Motorola  -        86  ARM.   , 68000    8086,      20-30%.  680x0, ,   -     ,  ,   x86.  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">eab.abime.net</a> ,    68k  ,   x86. <br><br>  , 68000 ‚Äì   ,    .        :    Apple Macintosh,     90-,     Commodore Amiga,       Atari ST. 68000      ,    Unix,  ,    Tandy 16B. ,  IBM    PC    System 9000   68000,         PC. <br><br> 68010   ,   1982,   Intel  80286,      -. 68010     68000,     - ,   68000  68010     .       68000         . 68010  ,     10%  68000. ,  68010   80286          80186.   80186, 68010          . <br><br> 68008     1982      8088.  68000,   8-  ,        .  68008,   68000,    ,      50% ,  68000.  , 68008     ,  8088,  -       20% ,  8086. <br><br>     Clive Sinclair  Spectrum QL ‚Äì   ,  -        Atari ST   .              ,  QL (Quantum leap ‚Äì  )    ,       ,          (    Amstrad,    QL). <br><br>        68000, ,   ,   16,      24. <br><br>   1984, 68020   Motorola   .           .       ,       ! 32-                68020EC  24- .  32-           .        , 256 , ,     ,          .        (64/32=32,32)   (32*32=64),   80   45  .       , ,  (32/16=16,16)     45  ( 140   68000).        ,    !     ,  ,   ‚Äì  x86         80386.         ,     , ‚Äì PDP-11    . <br><br>    , ,                 10- ,      ,  -  .         ,         .    80286, 68020      ,    .   68020         -  80286.      .  68020      (MMU)            . <br><br> 68020      Apple Macintosh II, Macintosh LC  Commodore Amiga 1200.           Unix. <br><br>  80386       MMU  32-   ,   Motorola    2. 68030,   1987,   ,    Motorola . 68030           ,        ‚Äì     .  , 68030        ,         . ,    , 68030    80386   . , 68030      50 ,  80386   40 ,       68030  . <br><br> 68030     Apple Macintosh II, Commodore Amiga 3000, Atari TT, Atari Falcon   . <br><br>  68040 Motorola     Intel.       80486,            .  Motorola,     ,         -    .  68040                 ,  80486.    lowendmac.com/benchmarks 68040    2.1   68030,  ,  68040   80486    . 68040       .          ‚Äì 68LC040,    . ,        ,       ! <br><br>      Motorola  . Motorola,     ,        68000/68010,     Intel     8087 c 1980.   68020/68030     68881    -  68882.         68882       68881. <br><br>   ,   Intel x86        ‚Äì    , ,      ,    4 .       ,     . <br><br><h2> National Semiconductor 32016 </h2><br>    32- ,        1982.      VAX-11  ,  -     DEC  National Semiconductor (NS)          VAX-11. <br><br>         ‚Äì    .        ,   .         . <br><br>   NS32016       VAX-11,  ,      .   24-,     16  .  32016     .     (        ), , ,  ( )    L (less),   ‚Äì     .      ,     Motorola 680x0.   -  F.    ,    (!)    .      , ,  (L)  ,     . <br><br>    32-   .  ,    ,   ,    ,    ( - ),    ( -  ),     ,     .   NS32016    68000. <br><br> 32016         BBC Micro   .         1984 .       6, 8  10 .           .    32016   ,    Acorn, -   Unix   Panos    Acorn . BBC Micro    MMU ‚Äì     ,      .       . <br><br> ,         ,   . <br><br><h2> Acorn ARM </h2><br>  6502,    ,   ,         Acorn,  ARM-1,   1985,  ,      Intel,  80386. ARM                     . ,  ARM    MMU      ,    ,    80386   .   ARM   ,        .    100   . <br><br>  ARM  1983   ,    Acorn     32016,  ,     6502          ,  ,    .     80286,     ,   Intel,       Acorn,      .    80286     80386     ,            . ,   Intel    ,   Acorn    ,      ARM. <br><br> ARM    ,    ,   BBC Micro.        ,      .     .  1986     BBC Micro c  ARM Evaluation system,    4   (     ),        (    4000  , ..  6000 ). ,            ,          .        .    ,       Unix    ‚Äì      Unix,    MMU,   Unix  PDP-11, 68000, 80186   8088. ,   90-  Acorn Archimedes   Linux.      Unix  ARM    Acorn   ARM  . <br><br><img src="http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg"><br> <i>    ARM</i> <br><br>     Acorn    1985     . Acorn  ARM        ,  ,  , -      32016.        Acorn Communicator.   ,    IBM PC   Master 512,   .  ,            ,            Acorn     Olivetti    ,   Intel 8086  80286, . ,   Acorn,  Olivetti        . <br><br>    Olivetti Acorn    ARM2    ,            Archimedes,       1987. ,   Olivetti      IBM PC            Acorn. <br><br> ARM    16 32-  (  ,      ).   , R15,   PDP-11   .      1 .   ,  ,  ,     .  ,      ARM       .  ,  ,    .      ,          .  ,      ,     .   ARM ‚Äì    ,  26-, . .    64 ,   .         ,           ,       ,         4- .       4- ,  16-      .       ARM 3-.    RISC     -      . ARM      (Barrel Shifter),               . ,    R0  65 c     R1       <br><br><pre> <code class="plaintext">ADD R1, R0, R0 shl 6</code> </pre> <br> ,    63 ‚Äì  <br><br><pre> <code class="plaintext">RSB R1, R0, R0 shl 6</code> </pre> <br>      ,  ,  ,            . ARM     :    .  16  ( ),     .  ,   ,         .        ,  ,    .   ARM        .    ,           .  ARM   6809    ,    .  ,          ,         . <br><br>   ARM     ,     x86.     ARM    .       ARM     80386, , RSB ( ), BIC (AND  ,     PDP-11), 4- MLA (  ), LDM  STM (      ,    MOVEM   68k).    ARM 3-,     80386    2 .   ARM   ‚Äì   ,      R14  R15.   ARM   3-4  80386   ,    80386   2-3  ARM. ,   IBM PC XT    Acorn Archimedes    8    ,    PC XT.   Commodore Amiga   68000  7       ,   10-15%  PC XT.   ,    NeXT  25  68030         8  ARM. Apple    M√∂bius  - Apple ][,   ,           Apple ][,     68k  ,  ! <br><br>   ARM       .    8    ,        .    32-     4 . , ,      ,        ,       12-.   ARM     ,     ,       . ,           .     ARM       (MMU) ‚Äì  , ,  Apple   90-.         ARM      .  ARM       ,     x86.          ARM:       .  ,    <pre> <code class="plaintext">R1 shl 7</code> </pre> ‚Äì    R1  7   ‚Äì   <pre> <code class="plaintext">R1, shl 7</code> </pre>  . <br><br>  1989   ARM3   .  1990   ARM   Acorn     Apple  VLSI  ARM Holding.          ARM    Acorn-Olivetti.  Acorn    ,  ARM Holding    .  Acorn  ARM Holding     Apple   ARM    Newton       . <br><br> ARM     ,  80486      10-20%! Intel                Pentium. DEC StrongARM       1996,       Intel,         ARM-.  ,      . <br><br>    ARM   ,     .   ,      ARM Holding Apple  90-   . <br><br><h2>  ,    </h2><br>    ,  8-          70-  80-     .   8- 6502   . Intel  Motorola       ,     . <br><br>  ,  Amiga  Atari ST       4    20-  24- ,   6502,   68000.    ,     6502  10 . <br><br>     Amstrad PCW,       Commodore CBM II,    z80   ,   ,        10  . <br><br>    ,   ARM   1982,    ? <br><br>     ,        ,    ? <p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de410591/">https://habr.com/ru/post/de410591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de410581/index.html">Alkoholmissbrauch ist der schnellste Weg zur Demenz</a></li>
<li><a href="../de410583/index.html">Samsung Gear VR: Eindr√ºcke nach einem Monat</a></li>
<li><a href="../de410585/index.html">Wie werde ich ein Zauberer (Teil 1)</a></li>
<li><a href="../de410587/index.html">Apple beabsichtigt, Kobalt ausschlie√ülich von Bergbauunternehmen zu kaufen</a></li>
<li><a href="../de410589/index.html">Meeres√∂kosysteme, die sich an die globale Erw√§rmung anpassen k√∂nnen</a></li>
<li><a href="../de410593/index.html">Telegramm f√ºhrt eine weitere Runde von ICO durch</a></li>
<li><a href="../de410597/index.html">Ein weiteres Smart-Home-Ger√§t</a></li>
<li><a href="../de410599/index.html">Eine Welle von Ger√§tediebst√§hlen von Bergbaubetrieben fegte √ºber Island</a></li>
<li><a href="../de410601/index.html">Was ist heute p√§dagogische Robotik?</a></li>
<li><a href="../de410603/index.html">Manifest der Angemessenheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>