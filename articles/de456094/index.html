<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦂 🍎 👆🏻 Wir lesen Datenblätter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8 👩🏿‍🎓 🏟️ 👼🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil habe ich versucht, elektronischen Hobbyisten, die aus Arduino-Hosen hervorgegangen sind, zu sagen, wie und warum sie Datenblätter und a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lesen Datenblätter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil habe</a> ich versucht, elektronischen Hobbyisten, die aus Arduino-Hosen hervorgegangen sind, zu sagen, wie und warum sie Datenblätter und andere Dokumentationen für Mikrocontroller lesen sollten.  Der Text erwies sich als groß, daher versprach ich, praktische Beispiele in einem separaten Artikel zu zeigen.  Nun, er nannte sich eine Fracht ... </p><br><p>  Heute werde ich zeigen, wie man Datenblätter verwendet, um ziemlich einfache Aufgaben zu lösen, die für viele Projekte auf den Controllern STM32 (Blue Pill) und STM8 erforderlich sind.  Alle Demo-Projekte sind meinen Lieblings-LEDs gewidmet, wir werden sie in großen Mengen beleuchten, für die wir alle Arten von interessanten Peripheriegeräten verwenden müssen. </p><a name="habracut"></a><br><p>  Der Text stellte sich wieder als riesig heraus. Der Einfachheit halber mache ich den Inhalt: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32 Blue Pill: 16 LEDs mit DM634-Treiber</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM8: Konfigurieren von sechs PWM-Pins</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM8: 8 RGB-LEDs an drei Pins, Interrupts</a> </p><br><p>  <em>Haftungsausschluss: Ich bin kein Ingenieur, ich gebe nicht vor, ein tiefes Wissen in Elektronik zu haben, der Artikel ist für Liebhaber wie mich gedacht.</em>  <em>Tatsächlich habe ich mich vor zwei Jahren als Zielgruppe betrachtet.</em>  <em>Wenn mir damals jemand gesagt hätte, dass es nicht beängstigend ist, Datenblätter auf einem unbekannten Chip zu lesen, hätte ich nicht viel Zeit damit verbracht, im Internet nach Code zu suchen und Krücken mit einer Schere und einem Pflaster zu erfinden.</em> </p><br><p>  <em>Im Zentrum dieses Artikels stehen Datenblätter, keine Projekte, sodass der Code möglicherweise nicht zu stark gekämmt und häufig überfüllt ist.</em>  <em>Die Projekte selbst sind sehr einfach, obwohl sie für eine erste Bekanntschaft mit dem neuen Chip geeignet sind.</em> </p><br><p>  <em>Ich hoffe, dass mein Artikel jemandem in einem ähnlichen Stadium eines Hobby-Tauchgangs hilft.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs mit DM634 und SPI </h1><br><p>  Ein kleines Projekt mit der Blue Pill (STM32F103C8T6) und dem DM634 LED-Treiber.  Mit Hilfe von Datenblättern werden wir uns mit dem Treiber, den IO-Ports STM und der Konfiguration von SPI befassen. </p><br><h2 id="dm634">  DM634 </h2><br><p>  Der taiwanesische Chip mit 16 16-Bit-PWM-Ausgängen kann in Ketten geschaltet werden.  Das jüngste 12-Bit-Modell ist für das Inlandsprojekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightpack bekannt</a> .  Als ich einmal zwischen dem DM63x und dem bekannten TLC5940 gewählt habe, habe ich aus mehreren Gründen beim DM angehalten: 1) TLC auf Aliexpress ist definitiv eine Fälschung, aber diese ist es nicht;  2) der DM hat eine autonome PWM mit einem eigenen Frequenzgenerator;  3) es könnte billig in Moskau gekauft werden und nicht auf ein Paket mit Ali warten.  Natürlich war es interessant zu lernen, wie man den Chip selbst verwaltet und keine vorgefertigte Bibliothek verwendet.  Die Chips sind jetzt hauptsächlich im SSOP24-Paket enthalten und lassen sich leicht an den Adapter anlöten. </p><br><p>  Da der Hersteller Taiwaner ist, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> für den Chip in chinesischem Englisch verfasst, was bedeutet, dass es Spaß machen wird.  Schauen Sie sich zunächst die <em>Pin-Verbindung</em> ( <em>Pin-Verbindung</em> ) an, um zu verstehen, mit welchem ​​Bein verbunden werden soll, und die Beschreibung der Pins ( <em>Pin-Beschreibung</em> ).  16 Schlussfolgerungen: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Zuflussquellen von Gleichstrom (offener Drain)</sup> </p><br><p>  <strong>Sink</strong> / <strong>Open-Drain-Ausgang</strong> - Drain;  Quelle des eingehenden Stroms;  aktiver Ausgang mit Masse verbunden - LEDs sind über Kathoden mit dem Treiber verbunden.  Elektrisch ist dies natürlich kein „offener Drain“, aber in Datenblättern ist diese Bezeichnung für Ausgänge im Drain-Modus üblich. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Externe Widerstände zwischen REXT und GND zum Einstellen des Ausgangsstromwerts</sup> </p><br><p>  Zwischen dem REXT-Pin und der Masse ist ein Referenzwiderstand installiert, der den Innenwiderstand der Ausgänge steuert (siehe Grafik auf Seite 9 des Datenblattes).  In DM634 kann dieser Widerstand auch programmgesteuert durch Einstellen der <em>globalen Helligkeit</em> gesteuert werden.  Ich werde in diesem Artikel nicht auf Details eingehen, ich habe hier nur einen 2,2 - 3 kOhm Widerstand eingefügt. </p><br><p>  Informationen zur Steuerung des Chips finden Sie in der Beschreibung der Geräteschnittstelle: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Ja, hier ist es, chinesisches Englisch in seiner ganzen Pracht.  Es ist problematisch zu übersetzen, Sie können es verstehen, wenn Sie es wünschen, aber es gibt noch einen anderen Weg - um zu sehen, wie die Verbindung im Datenblatt zum funktional geschlossenen TLC5940 beschrieben wird: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Es sind nur drei Pins erforderlich, um Daten in das Gerät einzugeben.</sub>  <sub>Die Vorderflanke des SCLK-Signals verschiebt Daten vom SIN-Pin zum internen Register.</sub>  <sub>Nachdem alle Daten heruntergeladen wurden, erfasst ein kurzes hohes XLAT-Signal die seriellen Daten in internen Registern.</sub>  <sub>Interne Register - XLAT-ausgelöste Absperrschieber.</sub>  <sub>Alle Daten werden im höchstwertigen Bit vorwärts übertragen.</sub> </p><br><p>  Riegel - ein Riegel / Riegel / Klemme. <br>  <strong>Steigende Flanke</strong> - Vorderkante des Impulses <br>  <strong>MSB first</strong> - das <strong>höchstwertige</strong> Bit ganz links. <br>  <strong>Daten takten</strong> - Daten sequentiell (bitweise) übertragen. </p><br><p>  Das Wort " <em>Latch" wird</em> häufig in der Dokumentation für Chips gefunden und auf verschiedene Arten übersetzt, sodass ich es mir erlauben werde, es zu verstehen </p><div class="spoiler">  <b class="spoiler_title">kleines Bildungsprogramm</b> <div class="spoiler_text">  Der LED-Treiber ist im Wesentlichen ein Schieberegister.  "Shift" im Namen ist eine bitweise Bewegung von Daten innerhalb des Geräts: Jedes neue Bit, das nach innen verschoben wird, schiebt die gesamte Kette vor sich hin.  Da niemand das chaotische Blinken von LEDs während der Verschiebung beobachten möchte, findet der Prozess in Pufferregistern statt, die durch einen <em>Latch</em> von den Arbeitsregistern getrennt sind - dies ist eine Art Wartezimmer, in dem die Bits in der gewünschten Reihenfolge angeordnet sind.  Wenn alles fertig ist, öffnet sich der Verschluss und die Bits werden an die Arbeit gesendet, wobei der vorherige Stapel ersetzt wird.  Das Wort <em>Latch</em> in der Dokumentation für Mikroschaltungen impliziert fast immer einen solchen Dämpfer, unabhängig davon, in welcher Kombination er verwendet wird. </div></div><br><p>  Die Datenübertragung zum DM634 ist also wie folgt: Setzen Sie den DAI-Eingang auf das höherwertige Bit der Fern-LED, ziehen Sie das DCK nach oben und unten;  Setzen Sie den DAI-Eingang auf das nächste Bit und ziehen Sie DCK.  und so weiter, bis alle Bits übertragen ( <em>getaktet</em> ) sind, wonach wir die LAT ziehen.  Dies kann manuell erfolgen ( <em>Bit-Bang</em> ), es ist jedoch besser, die geschärfte SPI-Schnittstelle speziell dafür zu verwenden, da sie auf unserem STM32 in zwei Kopien dargestellt wird. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blaue Tablette STM32F103 </h2><br><p>  Einführung: STM32-Controller sind viel komplizierter als Atmega328, als sie erschrecken können.  Gleichzeitig sind aus Gründen der Energieeinsparung fast alle Peripheriegeräte zu Beginn deaktiviert, und die Taktfrequenz von einer internen Quelle beträgt 8 MHz.  Glücklicherweise haben die STM-Programmierer Code geschrieben, der den Chip auf die „berechneten“ 72 MHz brachte, und die Autoren aller mir bekannten IDEs haben ihn in den Initialisierungsvorgang einbezogen, sodass wir nicht takten müssen (aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie können, wenn Sie wirklich wollen</a> ).  Aber Sie müssen die Peripheriegeräte einschalten. </p><br><p>  Dokumentation: Der beliebte STM32F103C8T6-Chip ist auf der Blue Pill installiert. Es gibt zwei nützliche Dokumente dafür: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> für Mikrocontroller STM32F103x8 und STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzhandbuch</a> für die gesamte STM32F103-Linie und darüber hinaus. </li></ul><br><p>  In einem Datenblatt könnten wir interessiert sein an: </p><br><ul><li>  Pinbelegung - Pinbelegung von Chips - für den Fall, dass wir uns entscheiden, selbst Bretter herzustellen; </li><li>  Memory Map - Speicherkarte für einen bestimmten Chip.  Im Referenzhandbuch gibt es eine Karte für die gesamte Zeile, in der die Register aufgelistet sind, die sich nicht in unserer befinden. </li><li>  Tabellen-Pin-Definitionen - Auflistung der Haupt- und Alternativfunktionen von Pins;  Für die „blaue Pille“ im Internet finden Sie bequemere Bilder mit einer Liste der Stifte und ihrer Funktionen.  Google daher sofort die Pinbelegung der Blauen Pille und halte dieses Bild zur Hand: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: Auf dem Bild aus dem Internet wurde in den Kommentaren ein Fehler festgestellt, wofür ich mich bedanke.</em>  <em>Das Bild wurde ersetzt, aber dies ist eine Lektion - es ist besser, Informationen aus Nicht-Datenblättern zu überprüfen.</em> </p><br><p>  Wir entfernen das Datenblatt, öffnen das Referenzhandbuch, jetzt verwenden wir es nur noch. <br>  Vorgehensweise: Wir beschäftigen uns mit Standardeingabe / -ausgabe, konfigurieren SPI und schalten die gewünschten Peripheriegeräte ein. </p><br><h3 id="vvod-vyvod">  Eingabe-Ausgabe </h3><br><p>  Atmega328 I / O ist extrem einfach, weshalb die Fülle an STM32-Optionen verwirrend sein kann.  Jetzt brauchen wir nur noch Schlussfolgerungen, aber es gibt sogar vier Möglichkeiten: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>Open-Drain-Ausgang, Push-Pull-Ausgang, alternativer Push-Pull-Ausgang, alternativer offener Drain</sub> </p><br><p>  " <em>Push-Pull</em> " ( <em>Push-Pull</em> ) - die übliche Schlussfolgerung von Arduina, der Pin kann entweder HIGH oder LOW sein.  Aber mit dem "offenen Abfluss" gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schwierigkeiten</a> , obwohl hier tatsächlich alles einfach ist: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Ausgangskonfiguration / Wenn der Port dem Ausgang zugewiesen ist: / Der Ausgangspuffer ist eingeschaltet: / - Open Drain-Modus: „0“ aktiviert N-MOS im Ausgangsregister, „1“ belässt den Port im Ausgangsregister im Hi-Z-Modus (P-MOS ist nicht aktiviert ) / - "Pull-Push" -Modus: "0" im Ausgangsregister aktiviert N-MOS, "1" im Ausgangsregister aktiviert P-MOS.</sub> </p><br><p>  Der ganze Unterschied zwischen Open Drain und <em>Push-Pull</em> besteht darin, dass der erste Pin den HIGH-Zustand nicht akzeptieren kann: Wenn er eine Einheit in das Ausgangsregister schreibt, schaltet er auf <em>hochohmig</em> , <em>Hi -Z</em> ).  Bei der Aufnahme von Null verhält sich der Pin in beiden Modi logisch und elektrisch gleich. </p><br><p>  Im normalen Ausgangsmodus übersetzt der Pin einfach den Inhalt des Ausgangsregisters.  In der "Alternative" wird es von der entsprechenden Peripherie gesteuert (siehe 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Wenn das Portbit als alternativer Funktionsausgang konfiguriert ist, wird das Ausgangsregister deaktiviert und der Pin mit dem peripheren Ausgangssignal verbunden</sub> </p><br><p>  Eine alternative Funktionalität für jeden Pin ist im Datenblatt <em>Pin-Definitionen beschrieben</em> und befindet sich auf dem heruntergeladenen Bild.  Auf die Frage, was zu tun ist, wenn der Pin mehrere alternative Funktionen hat, gibt die Antwort eine Fußnote im Datenblatt: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Wenn mehrere Peripherieblöcke denselben Pin verwenden, sollte zur Vermeidung eines Konflikts zwischen alternativen Funktionen gleichzeitig nur ein Peripherieblock verwendet werden, der mit dem Aktivierungsbit für den Peripherietakt (im entsprechenden RCC-Register) umschaltet.</sub> </p><br><p>  Schließlich haben Pins im Ausgangsmodus auch eine Taktrate.  Dies ist eine weitere Energiesparfunktion. In unserem Fall setzen wir sie einfach auf das Maximum und vergessen sie. </p><br><p>  Also: Wir verwenden SPI, daher sollten zwei Pins (mit Daten und einem Taktsignal) eine „alternative Push-Push-Funktion“ und eine andere (LAT) eine „normale Pull-Push-Funktion“ sein.  Aber bevor wir sie zuweisen, werden wir uns mit SPI befassen. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Ein weiteres kleines Bildungsprogramm</b> <div class="spoiler_text"><p>  SPI oder Serial Peripherial Interface (serielle Peripherieschnittstelle) - eine einfache und sehr effektive Schnittstelle für die Kommunikation von MK mit anderen MK und der Außenwelt im Allgemeinen.  Das Funktionsprinzip wurde bereits oben beschrieben, wo es um den chinesischen LED-Treiber geht (im Referenzhandbuch siehe Abschnitt 25).  SPI kann im Master- („Master“) und Slave- („Slave“) Modus betrieben werden.  SPI verfügt über vier grundlegende Kanäle, von denen möglicherweise nicht alle beteiligt sind: </p><br><ul><li>  MOSI, Master-Ausgang / Slave-Eingang: Dieser Pin sendet im Master-Modus, empfängt aber im Slave-Modus Daten. </li><li>  MISO, Master Input / Slave Output: im Gegenteil, im Master akzeptiert, im Slave - gibt; </li><li>  SCK, Serial Clock: Legt die Frequenz der Datenübertragung im Master fest oder empfängt ein Taktsignal im Slave.  Im Wesentlichen schlägt Bits; </li><li>  SS, Slave Select: Über diesen Kanal erfährt der Slave, dass er etwas davon möchte.  Auf STM32 heißt es NSS, wobei N = negativ ist, d.h.  Der Controller wird zum Slave, wenn in diesem Kanal Masse vorhanden ist.  Kann gut mit dem Open Drain-Ausgabemodus kombiniert werden, aber das ist eine andere Geschichte. </li></ul></div></div><br><p>  Wie alles andere ist auch das SPI des STM32 reich an Funktionen, was das Verständnis etwas erschwert.  Zum Beispiel kann es nicht nur mit dem SPI, sondern auch mit der I2S-Schnittstelle funktionieren, und in der Dokumentation, deren Beschreibungen verwechselt sind, müssen Sie den Überschuss rechtzeitig abschneiden.  Unsere Aufgabe ist sehr einfach: Sie müssen nur Daten mit MOSI und SCK senden.  Wir gehen zu Abschnitt 25.3.4 (Halbduplex-Kommunikation), wo wir <em>1 Takt und 1 unidirektionalen Datenkabel</em> (1 Taktsignal und 1 unidirektionaler Datenstrom) finden: </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>In diesem Modus verwendet die Anwendung SPI entweder nur im Sende- oder im Empfangsmodus.</sub>  <sub>/ Der Nur-Senden-Modus ähnelt dem Duplex-Modus: Daten werden auf dem Sende-Pin (MOSI im Master-Modus oder MISO im Slave-Modus) übertragen, und der Empfangs-Pin (MISO bzw. MOSI) kann als regulärer Eingangs- / Ausgangs-Pin verwendet werden.</sub>  <sub>In diesem Fall reicht es aus, wenn die Anwendung den Empfangspuffer ignoriert (wenn Sie ihn lesen, werden keine Daten übertragen).</sub> </p><br><p>  Nun, der MISO-Pin ist frei von uns. Verbinden wir das LAT-Signal damit.  Wir werden uns mit Slave Select befassen, das auf dem STM32 programmgesteuert gesteuert werden kann, was äußerst praktisch ist.  Wir lesen den gleichnamigen Absatz in Abschnitt 25.3.1 der Allgemeinen Beschreibung des SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>NSS-Programmsteuerung (SSM = 1) / Informationen zur Auswahl des Slaves sind im SSI-Bit des Registers SPI_CR1 enthalten.</sub>  <sub>Der externe NSS-Pin bleibt für andere Anwendungsanforderungen frei.</sub> </p><br><p>  Es ist Zeit, in Register zu schreiben.  Ich habe mich für SPI2 entschieden. Wir suchen nach der Basisadresse im Datenblatt - in Abschnitt 3.3 Speicherzuordnung: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Nun, wir fangen an: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Wir öffnen Abschnitt 25.3.3 mit dem Spruch „Konfigurieren von SPI im Master-Modus“: </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Stellen Sie die serielle Taktrate mit den BR-Bits [2: 0] im Register SPI_CR1 ein.</strong> </p><br><p>  Die Register werden im gleichnamigen Referenzhandbuch gesammelt.  CR1 hat einen <em>Adressoffset</em> ( <em>Adressoffset</em> ) von 0x00, standardmäßig werden alle Bits zurückgesetzt ( <em>Reset-Wert</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Die BR-Bits setzen den Regler-Taktfrequenzteiler und bestimmen so die Frequenz, bei der der SPI arbeiten wird.  Wir werden eine STM32-Frequenz von 72 MHz haben, der LED-Treiber arbeitet laut Datenblatt mit einer Frequenz von bis zu 25 MHz, daher ist es notwendig, durch vier zu teilen (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Setzen Sie die CPOL- und CPHA-Bits, um die Beziehung zwischen Datenübertragung und Taktung der seriellen Schnittstelle zu bestimmen (siehe Abbildung auf Seite 249).</strong> </p><br><p>  Da wir hier Datenblätter lesen und keine Schaltkreise berücksichtigen, sollten wir die Textbeschreibung der CPOL- und CPHA-Bits auf Seite 704 (SPI General Description) besser studieren: </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Taktphase und Polarität</sub> <sub><br></sub>  <sub>Unter Verwendung der CPOL- und CPHA-Bits des SPI_CR1-Registers können vier Optionen für Zeitsteuerungsbeziehungen programmgesteuert ausgewählt werden.</sub>  <sub>Das CPOL-Bit (Clock Polarity) steuert den Status des Takts, wenn keine Daten übertragen werden.</sub>  <sub>Dieses Bit steuert den Master- und Slave-Modus.</sub>  <sub>Wenn der CPOL zurückgesetzt wird, ist der SCK-Pin im Leerlaufmodus niedrig.</sub>  <sub>Wenn das CPOL-Bit gesetzt ist, befindet sich der SCK-Pin im Leerlaufmodus auf einem hohen Pegel.</sub> <sub><br></sub>  <sub>Wenn das CPHA-Bit (Taktphase) gesetzt ist, fungiert die zweite Flanke des SCK-Signals als Trap-Gate des High-Bits (absteigend, wenn CPOL gelöscht ist, oder aufsteigend, wenn CPOL gesetzt ist).</sub>  <sub>Daten werden durch die zweite Änderung des Taktsignals erfasst.</sub>  <sub>Wenn das CPHA-Bit gelöscht ist, fungiert die Vorderflanke des SCK-Signals als Trap-Gate des High-Bits (nach unten, wenn CPOL gesetzt ist, oder nach oben, wenn CPOL gelöscht ist).</sub>  <sub>Daten werden durch die erste Änderung des Taktsignals erfasst.</sub> </p><br><p>  Nachdem wir dieses Wissen geraucht haben, schließen wir, dass beide Bits Nullen bleiben müssen, weil  Das SCK-Signal muss niedrig bleiben, wenn es nicht verwendet wird, und die Daten müssen entlang der Vorderflanke des Impulses übertragen werden (siehe <em>Steigende</em> Flanke im DM634-Datenblatt). </p><br><p>  Übrigens haben wir hier zum ersten Mal eine Funktion des Wortschatzes in ST-Datenblättern gefunden: In diesen wird der Ausdruck „Bit auf Null zurücksetzen“ geschrieben <em>, um ein Bit zurückzusetzen</em> und nicht <em>ein bisschen zu löschen</em> , wie zum Beispiel in Atmega. </p><br><p>  <strong>3. Setzen Sie das DFF-Bit, um ein 8-Bit- oder 16-Bit-Datenblockformat zu definieren.</strong> </p><br><p>  Ich habe speziell das 16-Bit-DM634 genommen, um mich nicht mit der Übertragung von 12-Bit-PWM-Daten wie dem DM633 zu beschäftigen.  DFF macht Sinn, eine Einheit einzutragen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Konfigurieren Sie das LSBFIRST-Bit im Register SPI_CR1, um das Blockformat zu bestimmen</strong> </p><br><p>  LSBFIRST setzt, wie der Name schon sagt, das niederwertige Bit vorwärts.  Der DM634 möchte jedoch Daten empfangen, die mit dem High-Bit beginnen.  Deshalb lassen wir es weggeworfen. </p><br><p>  <strong>5. Wenn im Hardwaremodus eine Eingabe vom NSS-Pin erforderlich ist, senden Sie während der gesamten Byte-Übertragungssequenz ein hohes Signal an den NSS-Pin.</strong>  <strong>Setzen Sie im NSS-Programmiermodus die SSM- und SSI-Bits im Register SPI_CR1.</strong>  <strong>Wenn der NSS-Pin am Ausgang arbeiten soll, muss nur das SSOE-Bit gesetzt werden.</strong> </p><br><p>  Installieren Sie SSM und SSI, um den NSS-Hardwaremodus zu vergessen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Die MSTR- und SPE-Bits müssen gesetzt sein (sie bleiben nur gesetzt, wenn ein hohes Signal an das NSS angelegt wird).</strong> </p><br><p>  Mit diesen Bits weisen wir unseren SPI als Master zu und schalten ihn ein: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  Wenn SPI konfiguriert ist, schreiben wir Funktionen, die sofort Bytes an den Treiber senden.  Wir lesen weiterhin 25.3.3 "Konfigurieren von SPI im Master-Modus": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Datenübertragungsverfahren</sub> <sub><br></sub>  <sub>Die Übertragung beginnt, wenn ein Byte in den Sendepuffer geschrieben wird.</sub> <sub><br></sub>  <sub>Das Datenbyte wird während der Übertragung des ersten Bits im <strong>Parallelmodus</strong> (vom internen Bus) in das Schieberegister geladen, wonach es im <strong>seriellen</strong> Modus an den MOSI-Pin übertragen wird, wobei das erste oder letzte Bit in Abhängigkeit von der Einstellung des LSBFIRST-Bits im Register CPI_CR1 weitergeleitet wird.</sub>  <sub>Das TXEIE-Flag wird gesetzt, nachdem Daten <strong>vom Tx-Puffer in das Schieberegister übertragen wurden</strong> , und ein Interrupt wird auch erzeugt, wenn das TXEIE-Bit im CPI_CR1-Register gesetzt ist.</sub> </p><br><p>  Ich habe einige Wörter in der Übersetzung hervorgehoben, um auf ein Merkmal der Implementierung von SPI in STM-Controllern aufmerksam zu machen.  Auf Atmega wird das TXE-Flag ( <em>Tx leer</em> , Tx ist leer und bereit, Daten zu empfangen) erst gesetzt, nachdem das gesamte Byte ausgegangen <em>ist</em> .  Und hier wird dieses Flag gesetzt, nachdem das Byte in das interne Schieberegister verschoben wurde.  Da es von allen Bits gleichzeitig (parallel) dorthin geschoben wird und dann die Daten nacheinander übertragen werden, wird TXE gesetzt, bevor das Byte vollständig gesendet wird.  Das ist wichtig, weil  Im Fall unseres LED-Treibers müssen wir den LAT-Pin ziehen, nachdem wir <em>alle</em> Daten gesendet haben, d. h.  Nur das TXE-Flag wird uns nicht ausreichen. </p><br><p>  Und das bedeutet, dass wir eine andere Flagge brauchen.  Mal sehen in 25.3.7 - "Statusflags": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>BESETZTE Flagge</sub> <sub><br></sub>  <sub>Das BSY-Flag wird von der Hardware gesetzt und zurückgesetzt (das Schreiben darauf hat keine Auswirkungen).</sub>  <sub>Das BSY-Flag zeigt den Status der SPI-Kommunikationsschicht an.</sub> <sub><br></sub>  <sub>Es wird zurückgesetzt:</sub> <sub><br></sub>  <sub>wenn die Übertragung abgeschlossen ist (außer im Master-Modus, wenn die Übertragung kontinuierlich ist)</sub> <sub><br></sub>  <sub>wenn SPI deaktiviert ist</sub> <sub><br></sub>  <sub>wenn ein Assistentenmodusfehler auftritt (MODF = 1)</sub> <sub><br></sub>  <sub>Wenn die Übertragung nicht kontinuierlich ist, wird das BSY-Flag zwischen jeder Datenübertragung gelöscht.</sub> </p><br><p>  Okay, sei praktisch.  Wir finden heraus, wo sich der Tx-Puffer befindet.  Lesen Sie dazu das "SPI-Datenregister": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Datenregister</sub> <sub><br></sub>  <sub>Empfangene Daten oder Daten zur Übertragung.</sub> <sub><br></sub>  <sub>Das Datenregister ist in zwei Puffer unterteilt - einen zum Schreiben (Sendepuffer) und einen zum Lesen (Empfangspuffer).</sub>  <sub>Das Schreiben in das Datenregister schreibt in den Tx-Puffer, und das Lesen aus dem Datenregister gibt den im Rx-Puffer enthaltenen Wert zurück.</sub> </p><br><p>  Nun, das Statusregister, in dem es TXE- und BSY-Flags gibt: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Wir schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Nun, da wir je nach Anzahl der Ausgänge des LED-Treibers zweimal 16 Bytes senden müssen, ungefähr so: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Wir wissen jedoch immer noch nicht, wie wir den Stift LAT ziehen sollen, und kehren daher zu I / O zurück. </p><br><h3 id="naznachaem-piny">  Stifte zuweisen </h3><br><p>  In STM32F1 sind die für den Zustand der Pins verantwortlichen Register eher ungewöhnlich.  Es ist klar, dass es mehr davon als Atmega gibt, aber sie unterscheiden sich auch von anderen STM-Chips.  Abschnitt 9.1 Allgemeine Beschreibung des GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Jeder der Allzweck-Eingangs- / Ausgangsports <em>(GPIO)</em> verfügt über zwei 32-Bit-Konfigurationsregister (GPIOx_CRL und GPIOx_CRH), zwei 32-Bit-Datenregister (GPIOx_IDR und GPIOx_ODR), ein 32-Bit-Set / Reset-Register (GPIOx_BSRR) und 16 Bit ein Rücksetzregister (GPIOx_BRR) und ein 32-Bit-Blockregister (GPIOx_LCKR).</sub> </p><br><p>  Die ersten beiden Register sind ungewöhnlich und eher unpraktisch, da 16 Port-Pins im Format „vier Bits pro Bruder“ über sie verteilt sind.  Das heißt,  Die Pins 0 bis 7 befinden sich in der CRL und der Rest in der CRH.  Gleichzeitig passen die restlichen Register erfolgreich in die Bits aller Pins des Ports - oft bleibt die Hälfte „reserviert“. </p><br><p>  Beginnen Sie der Einfachheit halber am Ende der Liste. </p><br><p>  Wir brauchen kein Blockregister. </p><br><p>  Die Setup- und Reset-Register sind insofern sehr lustig, als sie sich teilweise duplizieren: Sie können alles nur in BSRR schreiben, wobei die höchsten 16 Bits den Pin auf Null zurücksetzen und die unteren auf 1 setzen oder auch BRR verwenden, dessen untere 16 Bits nur den Pin zurücksetzen .  Ich mag die zweite Option.  Diese Register sind insofern wichtig, als sie einen atomaren Zugang zu den Pins ermöglichen: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Atomic Installation oder Reset</sub> <sub><br></sub>  <sub>Sie müssen Interrupts nicht deaktivieren, wenn Sie GPIOx_ODR auf Bitebene programmieren: Sie können ein oder mehrere Bits mit einer atomaren Schreiboperation APB2 ändern.</sub>  <sub>Dies wird erreicht, indem „1“ in das Set / Reset-Register (GPIOx_BSRR oder nur zum Zurücksetzen in GPIOx_BRR) das Bit geschrieben wird, das Sie ändern möchten.</sub>  <sub>Andere Bits bleiben unverändert.</sub> </p><br><p>  Datenregister haben ganz sprechende Namen - IDR = <em>Eingangsrichtungsregister</em> , Eingangsregister;  ODR = <em>Ausgangsrichtungsregister</em> , Ausgangsregister.  Im aktuellen Projekt werden wir sie nicht brauchen. </p><br><p>  Und schließlich Kontrollregister.  Da wir an den Pins des zweiten SPI interessiert sind, nämlich PB13, PB14 und PB15, schauen wir uns sofort CRH an: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  Und wir sehen, dass es notwendig sein wird, vom 20. bis zum 31. etwas in Bits zu schreiben. </p><br><p>  Wir haben bereits herausgefunden, was wir von den Pins wollen, also kann ich hier auf einen Screenshot verzichten. Sagen wir einfach, dass MODE die Richtung (Eingabe, wenn beide Bits auf 0 gesetzt sind) und die Pin-Geschwindigkeit (wir brauchen 50 MHz, d. H. Beide) einstellt Pin in „1“) und CNF stellt den Modus ein: normales „Push-Push“ - 00, „Alternative“ - 10. Wie oben gezeigt, haben alle Pins standardmäßig das dritte Bit von unten (CNF0), auf das sie gesetzt werden <em>schwebender Eingabemodus</em> . </p><br><p>  Da ich der Einfachheit halber etwas anderes mit diesem Chip machen möchte, habe ich alle möglichen MODE- und CNF-Werte sowohl für das untere als auch für das obere Steuerregister definiert. </p><br><div class="spoiler">  <b class="spoiler_title">So etwas in der Art</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Unsere Pins befinden sich an Port B (die Basisadresse ist 0x40010C00), Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO – B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  Dementsprechend können Sie Definitionen für die LAT schreiben, die die Register BRR und BSRR zucken: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse – high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low nur durch Trägheit, irgendwie war es immer, lass dich bleiben) </p><br><p>  Jetzt ist schon alles super, funktioniert einfach nicht.  Da es sich um STM32 handelt, wird Strom gespart, sodass Sie die Uhr für die erforderlichen Peripheriegeräte aktivieren müssen. </p><br><h2 id="vklyuchaem-taktirovanie">  Timing einschalten </h2><br><p>  Die Uhr ist für die Uhr verantwortlich, sie sind auch Uhr.  Und wir konnten bereits die Abkürzung RCC sehen.  Wir suchen es in der Dokumentation: Dies ist Reset und Clock Control. </p><br><p>  Wie oben erwähnt, haben die Mitarbeiter von STM zum Glück den schwierigsten Teil des Timing-Themas für uns erledigt. Vielen Dank für sie (ich werde Ihnen einen Link zurück zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Di Halt geben</a> , um zu verdeutlichen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwirrt</a> dies ist).  Wir brauchen nur die Register, die für die Aktivierung von Peripherietakten verantwortlich sind (Peripheral Clock Enable Registers).  Suchen Sie zuerst die Basisadresse von RCC, sie befindet sich ganz am Anfang der "Speicherkarte": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  Klicken Sie dann entweder auf den Link, über den Sie versuchen, etwas in der Platte zu finden, oder lesen Sie die Beschreibungen der Einschlussregister in den Abschnitten zu den <em>Aktivierungsregistern</em> .  Wo wir RCC_APB1ENR und RCC_APB2ENR finden: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  Und in ihnen jeweils Bits, einschließlich Taktung von SPI2, IOPB (E / A-Port B) und alternativen Funktionen (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  Den endgültigen Code finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Wenn es eine Gelegenheit und einen Wunsch zum Testen gibt, verbinden wir DM634 wie folgt: DAI mit PB15, DCK mit PB13, LAT mit PB14.  Wir speisen den Fahrer ab 5 Volt, vergessen Sie nicht, die Erde zu kombinieren. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM auf STM8 </h1><br><p>  Als ich diesen Artikel zum Beispiel plante, habe ich mich entschlossen, einige Funktionen eines unbekannten Chips mit nur einem Datenblatt zu erlernen, damit ich keinen Schuhmacher ohne Stiefel bekomme.  STM8 war ideal für diese Rolle geeignet: Erstens hatte ich ein paar chinesische Motherboards mit STM8S103, und zweitens ist es nicht sehr beliebt, und daher besteht die Versuchung, im Internet eine Lösung zu lesen und zu finden, darin, dass genau diese Lösungen fehlen. </p><br><p>  Der Chip hat auch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzhandbuch RM0016</a> , in der ersten Pinbelegung und Registeradressen, in der zweiten - alles andere.  STM8 ist in C in der hässlichen IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ST Visual Develop</a> programmiert. </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Uhr und E / A. </h3><br><p>  Standardmäßig arbeitet der STM8 mit einer Frequenz von 2 MHz, dies muss sofort behoben werden. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>HSI-Uhr (interne Geschwindigkeit)</sub> <sub><br></sub>  <sub>Der HSI-Takt wird von einem internen 16-MHz-RC-Oszillator mit einem programmierbaren Teiler (1 bis 8) erhalten.</sub>  <sub>Sie wird im Register des Taktteilers (CLK_CKDIVR) eingestellt.</sub> <sub><br></sub>  <sub>Hinweis: Zu Beginn wird der HSI-RC-Oszillator mit Teiler 8 als führende Taktquelle ausgewählt.</sub> </p><br><p>  Wir finden die Registeradresse im Datenblatt, die Beschreibung in refman und sehen, dass das Register gelöscht werden muss: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Da wir PWM starten und die LEDs anschließen, sehen wir uns die Pinbelegung an: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  Der Chip ist klein, viele Funktionen sind an denselben Pins aufgehängt.  Die Tatsache, dass in eckigen Klammern „alternative Funktionalität“ steht, wird durch „ <em>Optionsbytes</em> “ umgeschaltet - so etwas wie Atmegas Sicherungen.  Sie können ihre Werte programmgesteuert ändern, sind aber nicht erforderlich, da  Neue Funktionen werden erst nach einem Neustart aktiviert.  Es ist einfacher, ST Visual Programmer (Downloads zusammen mit Visual Develop) zu verwenden, mit dem diese Bytes geändert werden können.  Die Pinbelegung zeigt, dass die Schlussfolgerungen von CH1 und CH2 des ersten Timers in eckigen Klammern versteckt sind.  Es ist notwendig, die Bits AFR1 und AFR0 in STVP zu setzen, und der zweite überträgt auch den Ausgang von CH1 des zweiten Timers von PD4 auf PC5. </p><br><p>  Somit steuern 6 Pins die LEDs: PC6, PC7 und PC3 für den ersten Timer, PC5, PD3 und PA3 für den zweiten. </p><br><p>  Das Konfigurieren der E / A-Pins selbst auf dem STM8 ist einfacher und logischer als auf dem STM32: </p><br><ul><li>  vertraut mit Atmega <em>Data Direction Register</em> : 1 = Ausgabe; </li><li>  das erste Steuerregister CR1 am Ausgang stellt den Gegentaktmodus (1) oder den offenen Drain (0) ein;  Da ich die LEDs mit Kathoden an den Chip anschließe, lasse ich hier Nullen. </li><li>  Das zweite Steuerregister CR2 am Ausgang stellt die Taktrate ein: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  PWM-Setup </h2><br><p>  Definieren wir zunächst die Begriffe: </p><br><ul><li>  <strong>PWM-Frequenz</strong> - Frequenz, mit der der Timer tickt; </li><li>  <strong>Auto-Reload, AR</strong> - Autoload-Wert, bis zu dem der Timer zählt (Impulsperiode); </li><li>  <strong>Update Event, UEV</strong> - ein Ereignis <strong>, das auftritt,</strong> wenn der Timer bis AR gezählt hat; </li><li>  <strong>PWM-</strong> Arbeitszyklus - PWM-Arbeitszyklus, häufig als "Arbeitszyklus" bezeichnet; </li><li>  <strong>Capture / Compare Value</strong> - Wert für <strong>Capture / Compare</strong> , der gezählt hat, bis zu dem der Timer <em>etwas unternimmt</em> (im Fall von PWM invertiert er das Ausgangssignal); </li><li>  <strong>Preload Value</strong> - vorinstallierter Wert.  <em>Der Vergleichswert</em> kann sich nicht ändern, während der Timer tickt, da sonst der PWM-Zyklus unterbrochen wird.  Daher werden die neu übertragenen Werte in den Puffer gelegt und von dort herausgezogen, wenn der Timer das Ende der Zählung erreicht und zurückgesetzt wird. </li><li>  <strong>Modi</strong> für Kantenausrichtung und Mittelausrichtung - Ausrichtung am Rand und in der Mitte, genau wie bei Atmelovskie <em>Fast PWM</em> und <em>Phasenkorrektem PWM</em> . </li><li>  <strong>OCiREF, Output Compare Reference Signal</strong> - das Referenzausgangssignal, das sich im PWM-Modus tatsächlich am entsprechenden Pin befindet. </li></ul><br><p>  Wie bereits aus der Pinbelegung hervorgeht, verfügen zwei Timer über die PWM-Funktionen - der erste und der zweite.  Beide sind 16-Bit, das erste hat viele zusätzliche Funktionen (insbesondere kann es sowohl nach oben als auch nach unten zählen).  Wir müssen beide auf die gleiche Weise arbeiten, also habe ich beschlossen, mit der offensichtlich ärmeren Sekunde zu beginnen, um nicht versehentlich etwas zu verwenden, das nicht darin enthalten ist.  Ein Problem besteht darin, dass die Beschreibung der PWM-Funktionalität aller Timer im Referenzhandbuch im Kapitel über den ersten Timer (17.5.7 PWM-Modus) enthalten ist, sodass Sie im gesamten Dokument hin und her springen müssen. </p><br><p>  PWM auf STM8 hat einen wichtigen Vorteil gegenüber PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM mit Kantenausrichtung</sub> <sub><br></sub>  <sub>Kontokonfiguration von unten nach oben</sub> <sub><br></sub>  <sub>Die Bottom-Up-Zählung ist aktiv, wenn das DIR-Bit im Register TIM_CR1 gelöscht wird</sub> <sub><br></sub>  <sub>Beispiel</sub> <sub><br></sub>  <sub>Das Beispiel verwendet den ersten PWM-Modus.</sub>  <sub>Das OCiREF PWM-Referenzsignal wird hoch gehalten, während TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Ansonsten nimmt es ein niedriges Niveau.</sub>  <sub>Wenn der Vergleichswert im Register TIM1_CCRi größer als der Startwert (Register TIM1_ARR) ist, wird das OCiREF-Signal auf 1 gehalten. <strong>Wenn der Vergleichswert 0 ist, wird OCiREF auf Null gehalten.</strong></sub>  <sub>...</sub> </p><br><p>  Der STM8-Timer überprüft während des <em>Aktualisierungsereignisses</em> zuerst den <em>Vergleichswert</em> und gibt erst dann ein Referenzsignal aus.  Der Timer von Atmega mischt zuerst und vergleicht dann, wodurch die Ausgabe beim <code>compare value == 0</code> zu einer Nadel führt, die irgendwie bekämpft werden muss (z. B. durch programmgesteuertes Invertieren der Logik). </p><br><p>  Also, was wir tun wollen: 8-Bit-PWM ( <code>AR == 255</code> ), betrachten wir von unten nach oben, Ausrichtung entlang der Grenze.  Da die Glühbirnen über Kathoden mit dem Chip verbunden sind, muss die PWM vor dem <em>Vergleich des Werts</em> 0 (LED leuchtet) und danach 1 ausgeben. </p><br><p>  Wir haben bereits über einige <em>PWM-Modi</em> gelesen und finden das gewünschte Register des zweiten Timers, indem wir im Referenzhandbuch nach diesem Satz suchen (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Erster PWM-Modus - Wenn von unten nach oben gezählt wird, ist der erste Kanal aktiv, während TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Andernfalls ist der erste Kanal inaktiv.</sub>  <sub>[weiter im Dokument fehlerhaftes Kopieren und Einfügen von Timer 1]</sub> <sub><br></sub>  <sub>111: Zweiter PWM-Modus - Wenn von unten nach oben gezählt wird, ist der erste Kanal inaktiv, während TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Ansonsten ist der erste Kanal aktiv.</sub> </p><br><p>  Da die LEDs an die MK-Kathoden angeschlossen sind, ist der zweite Modus für uns geeignet (der erste auch, aber wir wissen es noch nicht). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Aktivieren Sie das Vorladen von Ausgang 1</sub> <sub><br></sub>  <sub>0: Register vorladen bei TIMx_CCR1 aus.</sub>  <sub>Sie können jederzeit in TIMx_CCR1 schreiben.</sub>  <sub>Der neue Wert funktioniert sofort.</sub> <sub><br></sub>  <sub>1: Das Preload-Register bei TIMx_CCR1 ist aktiviert.</sub>  <sub>Lese- / Schreibvorgänge greifen auf das Preload-Register zu.</sub>  <sub>Der vorinstallierte Wert TIMx_CCR1 wird bei jedem Aktualisierungsereignis in das Schattenregister geladen.</sub> <sub><br></sub>  <sub>* Hinweis: Damit der PWM-Modus ordnungsgemäß funktioniert, müssen die Vorspannungsregister aktiviert sein.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   «»   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   …    .  Was ist los? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   –  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     «»   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   «»,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  – ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     –      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X –  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> –   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  Das heißt,  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     №13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    №13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> –     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    – <code>sim</code> –  .          «»,         . </p><br><p>   – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456094/">https://habr.com/ru/post/de456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456084/index.html">Kubernetes 1.15: Highlights Übersicht</a></li>
<li><a href="../de456086/index.html">iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices</a></li>
<li><a href="../de456088/index.html">Probleme bei der Big Data-Analyse</a></li>
<li><a href="../de456090/index.html">Einführung in Unit Testing in Unity</a></li>
<li><a href="../de456092/index.html">Sieben beunruhigende Anzeichen dafür, dass Sie wetterabhängig sind, auch wenn Sie dies nicht glauben</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, während er in den Wolken schwebt</a></li>
<li><a href="../de456100/index.html">Jetzt in der neuen Verpackung - Kingston A400 im M.2-Format eilt auf den Markt</a></li>
<li><a href="../de456104/index.html">Ezblock Pi - Programmieren ohne Programmieren, diesmal für Raspberry Pi-Fans</a></li>
<li><a href="../de456106/index.html">Wir teilen Features schneller. Android-Entwicklungserfahrung bei Badoo</a></li>
<li><a href="../de456110/index.html">Wie sieht dein Text aus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>