<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ç üçé üëÜüèª Wir lesen Datenbl√§tter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8 üë©üèø‚Äçüéì üèüÔ∏è üëºüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil habe ich versucht, elektronischen Hobbyisten, die aus Arduino-Hosen hervorgegangen sind, zu sagen, wie und warum sie Datenbl√§tter und a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lesen Datenbl√§tter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil habe</a> ich versucht, elektronischen Hobbyisten, die aus Arduino-Hosen hervorgegangen sind, zu sagen, wie und warum sie Datenbl√§tter und andere Dokumentationen f√ºr Mikrocontroller lesen sollten.  Der Text erwies sich als gro√ü, daher versprach ich, praktische Beispiele in einem separaten Artikel zu zeigen.  Nun, er nannte sich eine Fracht ... </p><br><p>  Heute werde ich zeigen, wie man Datenbl√§tter verwendet, um ziemlich einfache Aufgaben zu l√∂sen, die f√ºr viele Projekte auf den Controllern STM32 (Blue Pill) und STM8 erforderlich sind.  Alle Demo-Projekte sind meinen Lieblings-LEDs gewidmet, wir werden sie in gro√üen Mengen beleuchten, f√ºr die wir alle Arten von interessanten Peripherieger√§ten verwenden m√ºssen. </p><a name="habracut"></a><br><p>  Der Text stellte sich wieder als riesig heraus. Der Einfachheit halber mache ich den Inhalt: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32 Blue Pill: 16 LEDs mit DM634-Treiber</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM8: Konfigurieren von sechs PWM-Pins</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM8: 8 RGB-LEDs an drei Pins, Interrupts</a> </p><br><p>  <em>Haftungsausschluss: Ich bin kein Ingenieur, ich gebe nicht vor, ein tiefes Wissen in Elektronik zu haben, der Artikel ist f√ºr Liebhaber wie mich gedacht.</em>  <em>Tats√§chlich habe ich mich vor zwei Jahren als Zielgruppe betrachtet.</em>  <em>Wenn mir damals jemand gesagt h√§tte, dass es nicht be√§ngstigend ist, Datenbl√§tter auf einem unbekannten Chip zu lesen, h√§tte ich nicht viel Zeit damit verbracht, im Internet nach Code zu suchen und Kr√ºcken mit einer Schere und einem Pflaster zu erfinden.</em> </p><br><p>  <em>Im Zentrum dieses Artikels stehen Datenbl√§tter, keine Projekte, sodass der Code m√∂glicherweise nicht zu stark gek√§mmt und h√§ufig √ºberf√ºllt ist.</em>  <em>Die Projekte selbst sind sehr einfach, obwohl sie f√ºr eine erste Bekanntschaft mit dem neuen Chip geeignet sind.</em> </p><br><p>  <em>Ich hoffe, dass mein Artikel jemandem in einem √§hnlichen Stadium eines Hobby-Tauchgangs hilft.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs mit DM634 und SPI </h1><br><p>  Ein kleines Projekt mit der Blue Pill (STM32F103C8T6) und dem DM634 LED-Treiber.  Mit Hilfe von Datenbl√§ttern werden wir uns mit dem Treiber, den IO-Ports STM und der Konfiguration von SPI befassen. </p><br><h2 id="dm634">  DM634 </h2><br><p>  Der taiwanesische Chip mit 16 16-Bit-PWM-Ausg√§ngen kann in Ketten geschaltet werden.  Das j√ºngste 12-Bit-Modell ist f√ºr das Inlandsprojekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightpack bekannt</a> .  Als ich einmal zwischen dem DM63x und dem bekannten TLC5940 gew√§hlt habe, habe ich aus mehreren Gr√ºnden beim DM angehalten: 1) TLC auf Aliexpress ist definitiv eine F√§lschung, aber diese ist es nicht;  2) der DM hat eine autonome PWM mit einem eigenen Frequenzgenerator;  3) es k√∂nnte billig in Moskau gekauft werden und nicht auf ein Paket mit Ali warten.  Nat√ºrlich war es interessant zu lernen, wie man den Chip selbst verwaltet und keine vorgefertigte Bibliothek verwendet.  Die Chips sind jetzt haupts√§chlich im SSOP24-Paket enthalten und lassen sich leicht an den Adapter anl√∂ten. </p><br><p>  Da der Hersteller Taiwaner ist, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> f√ºr den Chip in chinesischem Englisch verfasst, was bedeutet, dass es Spa√ü machen wird.  Schauen Sie sich zun√§chst die <em>Pin-Verbindung</em> ( <em>Pin-Verbindung</em> ) an, um zu verstehen, mit welchem ‚Äã‚ÄãBein verbunden werden soll, und die Beschreibung der Pins ( <em>Pin-Beschreibung</em> ).  16 Schlussfolgerungen: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Zuflussquellen von Gleichstrom (offener Drain)</sup> </p><br><p>  <strong>Sink</strong> / <strong>Open-Drain-Ausgang</strong> - Drain;  Quelle des eingehenden Stroms;  aktiver Ausgang mit Masse verbunden - LEDs sind √ºber Kathoden mit dem Treiber verbunden.  Elektrisch ist dies nat√ºrlich kein ‚Äûoffener Drain‚Äú, aber in Datenbl√§ttern ist diese Bezeichnung f√ºr Ausg√§nge im Drain-Modus √ºblich. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Externe Widerst√§nde zwischen REXT und GND zum Einstellen des Ausgangsstromwerts</sup> </p><br><p>  Zwischen dem REXT-Pin und der Masse ist ein Referenzwiderstand installiert, der den Innenwiderstand der Ausg√§nge steuert (siehe Grafik auf Seite 9 des Datenblattes).  In DM634 kann dieser Widerstand auch programmgesteuert durch Einstellen der <em>globalen Helligkeit</em> gesteuert werden.  Ich werde in diesem Artikel nicht auf Details eingehen, ich habe hier nur einen 2,2 - 3 kOhm Widerstand eingef√ºgt. </p><br><p>  Informationen zur Steuerung des Chips finden Sie in der Beschreibung der Ger√§teschnittstelle: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Ja, hier ist es, chinesisches Englisch in seiner ganzen Pracht.  Es ist problematisch zu √ºbersetzen, Sie k√∂nnen es verstehen, wenn Sie es w√ºnschen, aber es gibt noch einen anderen Weg - um zu sehen, wie die Verbindung im Datenblatt zum funktional geschlossenen TLC5940 beschrieben wird: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Es sind nur drei Pins erforderlich, um Daten in das Ger√§t einzugeben.</sub>  <sub>Die Vorderflanke des SCLK-Signals verschiebt Daten vom SIN-Pin zum internen Register.</sub>  <sub>Nachdem alle Daten heruntergeladen wurden, erfasst ein kurzes hohes XLAT-Signal die seriellen Daten in internen Registern.</sub>  <sub>Interne Register - XLAT-ausgel√∂ste Absperrschieber.</sub>  <sub>Alle Daten werden im h√∂chstwertigen Bit vorw√§rts √ºbertragen.</sub> </p><br><p>  Riegel - ein Riegel / Riegel / Klemme. <br>  <strong>Steigende Flanke</strong> - Vorderkante des Impulses <br>  <strong>MSB first</strong> - das <strong>h√∂chstwertige</strong> Bit ganz links. <br>  <strong>Daten takten</strong> - Daten sequentiell (bitweise) √ºbertragen. </p><br><p>  Das Wort " <em>Latch" wird</em> h√§ufig in der Dokumentation f√ºr Chips gefunden und auf verschiedene Arten √ºbersetzt, sodass ich es mir erlauben werde, es zu verstehen </p><div class="spoiler">  <b class="spoiler_title">kleines Bildungsprogramm</b> <div class="spoiler_text">  Der LED-Treiber ist im Wesentlichen ein Schieberegister.  "Shift" im Namen ist eine bitweise Bewegung von Daten innerhalb des Ger√§ts: Jedes neue Bit, das nach innen verschoben wird, schiebt die gesamte Kette vor sich hin.  Da niemand das chaotische Blinken von LEDs w√§hrend der Verschiebung beobachten m√∂chte, findet der Prozess in Pufferregistern statt, die durch einen <em>Latch</em> von den Arbeitsregistern getrennt sind - dies ist eine Art Wartezimmer, in dem die Bits in der gew√ºnschten Reihenfolge angeordnet sind.  Wenn alles fertig ist, √∂ffnet sich der Verschluss und die Bits werden an die Arbeit gesendet, wobei der vorherige Stapel ersetzt wird.  Das Wort <em>Latch</em> in der Dokumentation f√ºr Mikroschaltungen impliziert fast immer einen solchen D√§mpfer, unabh√§ngig davon, in welcher Kombination er verwendet wird. </div></div><br><p>  Die Daten√ºbertragung zum DM634 ist also wie folgt: Setzen Sie den DAI-Eingang auf das h√∂herwertige Bit der Fern-LED, ziehen Sie das DCK nach oben und unten;  Setzen Sie den DAI-Eingang auf das n√§chste Bit und ziehen Sie DCK.  und so weiter, bis alle Bits √ºbertragen ( <em>getaktet</em> ) sind, wonach wir die LAT ziehen.  Dies kann manuell erfolgen ( <em>Bit-Bang</em> ), es ist jedoch besser, die gesch√§rfte SPI-Schnittstelle speziell daf√ºr zu verwenden, da sie auf unserem STM32 in zwei Kopien dargestellt wird. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blaue Tablette STM32F103 </h2><br><p>  Einf√ºhrung: STM32-Controller sind viel komplizierter als Atmega328, als sie erschrecken k√∂nnen.  Gleichzeitig sind aus Gr√ºnden der Energieeinsparung fast alle Peripherieger√§te zu Beginn deaktiviert, und die Taktfrequenz von einer internen Quelle betr√§gt 8 MHz.  Gl√ºcklicherweise haben die STM-Programmierer Code geschrieben, der den Chip auf die ‚Äûberechneten‚Äú 72 MHz brachte, und die Autoren aller mir bekannten IDEs haben ihn in den Initialisierungsvorgang einbezogen, sodass wir nicht takten m√ºssen (aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie k√∂nnen, wenn Sie wirklich wollen</a> ).  Aber Sie m√ºssen die Peripherieger√§te einschalten. </p><br><p>  Dokumentation: Der beliebte STM32F103C8T6-Chip ist auf der Blue Pill installiert. Es gibt zwei n√ºtzliche Dokumente daf√ºr: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> f√ºr Mikrocontroller STM32F103x8 und STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzhandbuch</a> f√ºr die gesamte STM32F103-Linie und dar√ºber hinaus. </li></ul><br><p>  In einem Datenblatt k√∂nnten wir interessiert sein an: </p><br><ul><li>  Pinbelegung - Pinbelegung von Chips - f√ºr den Fall, dass wir uns entscheiden, selbst Bretter herzustellen; </li><li>  Memory Map - Speicherkarte f√ºr einen bestimmten Chip.  Im Referenzhandbuch gibt es eine Karte f√ºr die gesamte Zeile, in der die Register aufgelistet sind, die sich nicht in unserer befinden. </li><li>  Tabellen-Pin-Definitionen - Auflistung der Haupt- und Alternativfunktionen von Pins;  F√ºr die ‚Äûblaue Pille‚Äú im Internet finden Sie bequemere Bilder mit einer Liste der Stifte und ihrer Funktionen.  Google daher sofort die Pinbelegung der Blauen Pille und halte dieses Bild zur Hand: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: Auf dem Bild aus dem Internet wurde in den Kommentaren ein Fehler festgestellt, wof√ºr ich mich bedanke.</em>  <em>Das Bild wurde ersetzt, aber dies ist eine Lektion - es ist besser, Informationen aus Nicht-Datenbl√§ttern zu √ºberpr√ºfen.</em> </p><br><p>  Wir entfernen das Datenblatt, √∂ffnen das Referenzhandbuch, jetzt verwenden wir es nur noch. <br>  Vorgehensweise: Wir besch√§ftigen uns mit Standardeingabe / -ausgabe, konfigurieren SPI und schalten die gew√ºnschten Peripherieger√§te ein. </p><br><h3 id="vvod-vyvod">  Eingabe-Ausgabe </h3><br><p>  Atmega328 I / O ist extrem einfach, weshalb die F√ºlle an STM32-Optionen verwirrend sein kann.  Jetzt brauchen wir nur noch Schlussfolgerungen, aber es gibt sogar vier M√∂glichkeiten: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>Open-Drain-Ausgang, Push-Pull-Ausgang, alternativer Push-Pull-Ausgang, alternativer offener Drain</sub> </p><br><p>  " <em>Push-Pull</em> " ( <em>Push-Pull</em> ) - die √ºbliche Schlussfolgerung von Arduina, der Pin kann entweder HIGH oder LOW sein.  Aber mit dem "offenen Abfluss" gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schwierigkeiten</a> , obwohl hier tats√§chlich alles einfach ist: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Ausgangskonfiguration / Wenn der Port dem Ausgang zugewiesen ist: / Der Ausgangspuffer ist eingeschaltet: / - Open Drain-Modus: ‚Äû0‚Äú aktiviert N-MOS im Ausgangsregister, ‚Äû1‚Äú bel√§sst den Port im Ausgangsregister im Hi-Z-Modus (P-MOS ist nicht aktiviert ) / - "Pull-Push" -Modus: "0" im Ausgangsregister aktiviert N-MOS, "1" im Ausgangsregister aktiviert P-MOS.</sub> </p><br><p>  Der ganze Unterschied zwischen Open Drain und <em>Push-Pull</em> besteht darin, dass der erste Pin den HIGH-Zustand nicht akzeptieren kann: Wenn er eine Einheit in das Ausgangsregister schreibt, schaltet er auf <em>hochohmig</em> , <em>Hi -Z</em> ).  Bei der Aufnahme von Null verh√§lt sich der Pin in beiden Modi logisch und elektrisch gleich. </p><br><p>  Im normalen Ausgangsmodus √ºbersetzt der Pin einfach den Inhalt des Ausgangsregisters.  In der "Alternative" wird es von der entsprechenden Peripherie gesteuert (siehe 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Wenn das Portbit als alternativer Funktionsausgang konfiguriert ist, wird das Ausgangsregister deaktiviert und der Pin mit dem peripheren Ausgangssignal verbunden</sub> </p><br><p>  Eine alternative Funktionalit√§t f√ºr jeden Pin ist im Datenblatt <em>Pin-Definitionen beschrieben</em> und befindet sich auf dem heruntergeladenen Bild.  Auf die Frage, was zu tun ist, wenn der Pin mehrere alternative Funktionen hat, gibt die Antwort eine Fu√ünote im Datenblatt: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Wenn mehrere Peripheriebl√∂cke denselben Pin verwenden, sollte zur Vermeidung eines Konflikts zwischen alternativen Funktionen gleichzeitig nur ein Peripherieblock verwendet werden, der mit dem Aktivierungsbit f√ºr den Peripherietakt (im entsprechenden RCC-Register) umschaltet.</sub> </p><br><p>  Schlie√ülich haben Pins im Ausgangsmodus auch eine Taktrate.  Dies ist eine weitere Energiesparfunktion. In unserem Fall setzen wir sie einfach auf das Maximum und vergessen sie. </p><br><p>  Also: Wir verwenden SPI, daher sollten zwei Pins (mit Daten und einem Taktsignal) eine ‚Äûalternative Push-Push-Funktion‚Äú und eine andere (LAT) eine ‚Äûnormale Pull-Push-Funktion‚Äú sein.  Aber bevor wir sie zuweisen, werden wir uns mit SPI befassen. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Ein weiteres kleines Bildungsprogramm</b> <div class="spoiler_text"><p>  SPI oder Serial Peripherial Interface (serielle Peripherieschnittstelle) - eine einfache und sehr effektive Schnittstelle f√ºr die Kommunikation von MK mit anderen MK und der Au√üenwelt im Allgemeinen.  Das Funktionsprinzip wurde bereits oben beschrieben, wo es um den chinesischen LED-Treiber geht (im Referenzhandbuch siehe Abschnitt 25).  SPI kann im Master- (‚ÄûMaster‚Äú) und Slave- (‚ÄûSlave‚Äú) Modus betrieben werden.  SPI verf√ºgt √ºber vier grundlegende Kan√§le, von denen m√∂glicherweise nicht alle beteiligt sind: </p><br><ul><li>  MOSI, Master-Ausgang / Slave-Eingang: Dieser Pin sendet im Master-Modus, empf√§ngt aber im Slave-Modus Daten. </li><li>  MISO, Master Input / Slave Output: im Gegenteil, im Master akzeptiert, im Slave - gibt; </li><li>  SCK, Serial Clock: Legt die Frequenz der Daten√ºbertragung im Master fest oder empf√§ngt ein Taktsignal im Slave.  Im Wesentlichen schl√§gt Bits; </li><li>  SS, Slave Select: √úber diesen Kanal erf√§hrt der Slave, dass er etwas davon m√∂chte.  Auf STM32 hei√üt es NSS, wobei N = negativ ist, d.h.  Der Controller wird zum Slave, wenn in diesem Kanal Masse vorhanden ist.  Kann gut mit dem Open Drain-Ausgabemodus kombiniert werden, aber das ist eine andere Geschichte. </li></ul></div></div><br><p>  Wie alles andere ist auch das SPI des STM32 reich an Funktionen, was das Verst√§ndnis etwas erschwert.  Zum Beispiel kann es nicht nur mit dem SPI, sondern auch mit der I2S-Schnittstelle funktionieren, und in der Dokumentation, deren Beschreibungen verwechselt sind, m√ºssen Sie den √úberschuss rechtzeitig abschneiden.  Unsere Aufgabe ist sehr einfach: Sie m√ºssen nur Daten mit MOSI und SCK senden.  Wir gehen zu Abschnitt 25.3.4 (Halbduplex-Kommunikation), wo wir <em>1 Takt und 1 unidirektionalen Datenkabel</em> (1 Taktsignal und 1 unidirektionaler Datenstrom) finden: </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>In diesem Modus verwendet die Anwendung SPI entweder nur im Sende- oder im Empfangsmodus.</sub>  <sub>/ Der Nur-Senden-Modus √§hnelt dem Duplex-Modus: Daten werden auf dem Sende-Pin (MOSI im Master-Modus oder MISO im Slave-Modus) √ºbertragen, und der Empfangs-Pin (MISO bzw. MOSI) kann als regul√§rer Eingangs- / Ausgangs-Pin verwendet werden.</sub>  <sub>In diesem Fall reicht es aus, wenn die Anwendung den Empfangspuffer ignoriert (wenn Sie ihn lesen, werden keine Daten √ºbertragen).</sub> </p><br><p>  Nun, der MISO-Pin ist frei von uns. Verbinden wir das LAT-Signal damit.  Wir werden uns mit Slave Select befassen, das auf dem STM32 programmgesteuert gesteuert werden kann, was √§u√üerst praktisch ist.  Wir lesen den gleichnamigen Absatz in Abschnitt 25.3.1 der Allgemeinen Beschreibung des SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>NSS-Programmsteuerung (SSM = 1) / Informationen zur Auswahl des Slaves sind im SSI-Bit des Registers SPI_CR1 enthalten.</sub>  <sub>Der externe NSS-Pin bleibt f√ºr andere Anwendungsanforderungen frei.</sub> </p><br><p>  Es ist Zeit, in Register zu schreiben.  Ich habe mich f√ºr SPI2 entschieden. Wir suchen nach der Basisadresse im Datenblatt - in Abschnitt 3.3 Speicherzuordnung: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Nun, wir fangen an: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Wir √∂ffnen Abschnitt 25.3.3 mit dem Spruch ‚ÄûKonfigurieren von SPI im Master-Modus‚Äú: </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Stellen Sie die serielle Taktrate mit den BR-Bits [2: 0] im Register SPI_CR1 ein.</strong> </p><br><p>  Die Register werden im gleichnamigen Referenzhandbuch gesammelt.  CR1 hat einen <em>Adressoffset</em> ( <em>Adressoffset</em> ) von 0x00, standardm√§√üig werden alle Bits zur√ºckgesetzt ( <em>Reset-Wert</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Die BR-Bits setzen den Regler-Taktfrequenzteiler und bestimmen so die Frequenz, bei der der SPI arbeiten wird.  Wir werden eine STM32-Frequenz von 72 MHz haben, der LED-Treiber arbeitet laut Datenblatt mit einer Frequenz von bis zu 25 MHz, daher ist es notwendig, durch vier zu teilen (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Setzen Sie die CPOL- und CPHA-Bits, um die Beziehung zwischen Daten√ºbertragung und Taktung der seriellen Schnittstelle zu bestimmen (siehe Abbildung auf Seite 249).</strong> </p><br><p>  Da wir hier Datenbl√§tter lesen und keine Schaltkreise ber√ºcksichtigen, sollten wir die Textbeschreibung der CPOL- und CPHA-Bits auf Seite 704 (SPI General Description) besser studieren: </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Taktphase und Polarit√§t</sub> <sub><br></sub>  <sub>Unter Verwendung der CPOL- und CPHA-Bits des SPI_CR1-Registers k√∂nnen vier Optionen f√ºr Zeitsteuerungsbeziehungen programmgesteuert ausgew√§hlt werden.</sub>  <sub>Das CPOL-Bit (Clock Polarity) steuert den Status des Takts, wenn keine Daten √ºbertragen werden.</sub>  <sub>Dieses Bit steuert den Master- und Slave-Modus.</sub>  <sub>Wenn der CPOL zur√ºckgesetzt wird, ist der SCK-Pin im Leerlaufmodus niedrig.</sub>  <sub>Wenn das CPOL-Bit gesetzt ist, befindet sich der SCK-Pin im Leerlaufmodus auf einem hohen Pegel.</sub> <sub><br></sub>  <sub>Wenn das CPHA-Bit (Taktphase) gesetzt ist, fungiert die zweite Flanke des SCK-Signals als Trap-Gate des High-Bits (absteigend, wenn CPOL gel√∂scht ist, oder aufsteigend, wenn CPOL gesetzt ist).</sub>  <sub>Daten werden durch die zweite √Ñnderung des Taktsignals erfasst.</sub>  <sub>Wenn das CPHA-Bit gel√∂scht ist, fungiert die Vorderflanke des SCK-Signals als Trap-Gate des High-Bits (nach unten, wenn CPOL gesetzt ist, oder nach oben, wenn CPOL gel√∂scht ist).</sub>  <sub>Daten werden durch die erste √Ñnderung des Taktsignals erfasst.</sub> </p><br><p>  Nachdem wir dieses Wissen geraucht haben, schlie√üen wir, dass beide Bits Nullen bleiben m√ºssen, weil  Das SCK-Signal muss niedrig bleiben, wenn es nicht verwendet wird, und die Daten m√ºssen entlang der Vorderflanke des Impulses √ºbertragen werden (siehe <em>Steigende</em> Flanke im DM634-Datenblatt). </p><br><p>  √úbrigens haben wir hier zum ersten Mal eine Funktion des Wortschatzes in ST-Datenbl√§ttern gefunden: In diesen wird der Ausdruck ‚ÄûBit auf Null zur√ºcksetzen‚Äú geschrieben <em>, um ein Bit zur√ºckzusetzen</em> und nicht <em>ein bisschen zu l√∂schen</em> , wie zum Beispiel in Atmega. </p><br><p>  <strong>3. Setzen Sie das DFF-Bit, um ein 8-Bit- oder 16-Bit-Datenblockformat zu definieren.</strong> </p><br><p>  Ich habe speziell das 16-Bit-DM634 genommen, um mich nicht mit der √úbertragung von 12-Bit-PWM-Daten wie dem DM633 zu besch√§ftigen.  DFF macht Sinn, eine Einheit einzutragen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Konfigurieren Sie das LSBFIRST-Bit im Register SPI_CR1, um das Blockformat zu bestimmen</strong> </p><br><p>  LSBFIRST setzt, wie der Name schon sagt, das niederwertige Bit vorw√§rts.  Der DM634 m√∂chte jedoch Daten empfangen, die mit dem High-Bit beginnen.  Deshalb lassen wir es weggeworfen. </p><br><p>  <strong>5. Wenn im Hardwaremodus eine Eingabe vom NSS-Pin erforderlich ist, senden Sie w√§hrend der gesamten Byte-√úbertragungssequenz ein hohes Signal an den NSS-Pin.</strong>  <strong>Setzen Sie im NSS-Programmiermodus die SSM- und SSI-Bits im Register SPI_CR1.</strong>  <strong>Wenn der NSS-Pin am Ausgang arbeiten soll, muss nur das SSOE-Bit gesetzt werden.</strong> </p><br><p>  Installieren Sie SSM und SSI, um den NSS-Hardwaremodus zu vergessen: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Die MSTR- und SPE-Bits m√ºssen gesetzt sein (sie bleiben nur gesetzt, wenn ein hohes Signal an das NSS angelegt wird).</strong> </p><br><p>  Mit diesen Bits weisen wir unseren SPI als Master zu und schalten ihn ein: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  Wenn SPI konfiguriert ist, schreiben wir Funktionen, die sofort Bytes an den Treiber senden.  Wir lesen weiterhin 25.3.3 "Konfigurieren von SPI im Master-Modus": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Daten√ºbertragungsverfahren</sub> <sub><br></sub>  <sub>Die √úbertragung beginnt, wenn ein Byte in den Sendepuffer geschrieben wird.</sub> <sub><br></sub>  <sub>Das Datenbyte wird w√§hrend der √úbertragung des ersten Bits im <strong>Parallelmodus</strong> (vom internen Bus) in das Schieberegister geladen, wonach es im <strong>seriellen</strong> Modus an den MOSI-Pin √ºbertragen wird, wobei das erste oder letzte Bit in Abh√§ngigkeit von der Einstellung des LSBFIRST-Bits im Register CPI_CR1 weitergeleitet wird.</sub>  <sub>Das TXEIE-Flag wird gesetzt, nachdem Daten <strong>vom Tx-Puffer in das Schieberegister √ºbertragen wurden</strong> , und ein Interrupt wird auch erzeugt, wenn das TXEIE-Bit im CPI_CR1-Register gesetzt ist.</sub> </p><br><p>  Ich habe einige W√∂rter in der √úbersetzung hervorgehoben, um auf ein Merkmal der Implementierung von SPI in STM-Controllern aufmerksam zu machen.  Auf Atmega wird das TXE-Flag ( <em>Tx leer</em> , Tx ist leer und bereit, Daten zu empfangen) erst gesetzt, nachdem das gesamte Byte ausgegangen <em>ist</em> .  Und hier wird dieses Flag gesetzt, nachdem das Byte in das interne Schieberegister verschoben wurde.  Da es von allen Bits gleichzeitig (parallel) dorthin geschoben wird und dann die Daten nacheinander √ºbertragen werden, wird TXE gesetzt, bevor das Byte vollst√§ndig gesendet wird.  Das ist wichtig, weil  Im Fall unseres LED-Treibers m√ºssen wir den LAT-Pin ziehen, nachdem wir <em>alle</em> Daten gesendet haben, d. h.  Nur das TXE-Flag wird uns nicht ausreichen. </p><br><p>  Und das bedeutet, dass wir eine andere Flagge brauchen.  Mal sehen in 25.3.7 - "Statusflags": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>BESETZTE Flagge</sub> <sub><br></sub>  <sub>Das BSY-Flag wird von der Hardware gesetzt und zur√ºckgesetzt (das Schreiben darauf hat keine Auswirkungen).</sub>  <sub>Das BSY-Flag zeigt den Status der SPI-Kommunikationsschicht an.</sub> <sub><br></sub>  <sub>Es wird zur√ºckgesetzt:</sub> <sub><br></sub>  <sub>wenn die √úbertragung abgeschlossen ist (au√üer im Master-Modus, wenn die √úbertragung kontinuierlich ist)</sub> <sub><br></sub>  <sub>wenn SPI deaktiviert ist</sub> <sub><br></sub>  <sub>wenn ein Assistentenmodusfehler auftritt (MODF = 1)</sub> <sub><br></sub>  <sub>Wenn die √úbertragung nicht kontinuierlich ist, wird das BSY-Flag zwischen jeder Daten√ºbertragung gel√∂scht.</sub> </p><br><p>  Okay, sei praktisch.  Wir finden heraus, wo sich der Tx-Puffer befindet.  Lesen Sie dazu das "SPI-Datenregister": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Datenregister</sub> <sub><br></sub>  <sub>Empfangene Daten oder Daten zur √úbertragung.</sub> <sub><br></sub>  <sub>Das Datenregister ist in zwei Puffer unterteilt - einen zum Schreiben (Sendepuffer) und einen zum Lesen (Empfangspuffer).</sub>  <sub>Das Schreiben in das Datenregister schreibt in den Tx-Puffer, und das Lesen aus dem Datenregister gibt den im Rx-Puffer enthaltenen Wert zur√ºck.</sub> </p><br><p>  Nun, das Statusregister, in dem es TXE- und BSY-Flags gibt: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Wir schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Nun, da wir je nach Anzahl der Ausg√§nge des LED-Treibers zweimal 16 Bytes senden m√ºssen, ungef√§hr so: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Wir wissen jedoch immer noch nicht, wie wir den Stift LAT ziehen sollen, und kehren daher zu I / O zur√ºck. </p><br><h3 id="naznachaem-piny">  Stifte zuweisen </h3><br><p>  In STM32F1 sind die f√ºr den Zustand der Pins verantwortlichen Register eher ungew√∂hnlich.  Es ist klar, dass es mehr davon als Atmega gibt, aber sie unterscheiden sich auch von anderen STM-Chips.  Abschnitt 9.1 Allgemeine Beschreibung des GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Jeder der Allzweck-Eingangs- / Ausgangsports <em>(GPIO)</em> verf√ºgt √ºber zwei 32-Bit-Konfigurationsregister (GPIOx_CRL und GPIOx_CRH), zwei 32-Bit-Datenregister (GPIOx_IDR und GPIOx_ODR), ein 32-Bit-Set / Reset-Register (GPIOx_BSRR) und 16 Bit ein R√ºcksetzregister (GPIOx_BRR) und ein 32-Bit-Blockregister (GPIOx_LCKR).</sub> </p><br><p>  Die ersten beiden Register sind ungew√∂hnlich und eher unpraktisch, da 16 Port-Pins im Format ‚Äûvier Bits pro Bruder‚Äú √ºber sie verteilt sind.  Das hei√üt,  Die Pins 0 bis 7 befinden sich in der CRL und der Rest in der CRH.  Gleichzeitig passen die restlichen Register erfolgreich in die Bits aller Pins des Ports - oft bleibt die H√§lfte ‚Äûreserviert‚Äú. </p><br><p>  Beginnen Sie der Einfachheit halber am Ende der Liste. </p><br><p>  Wir brauchen kein Blockregister. </p><br><p>  Die Setup- und Reset-Register sind insofern sehr lustig, als sie sich teilweise duplizieren: Sie k√∂nnen alles nur in BSRR schreiben, wobei die h√∂chsten 16 Bits den Pin auf Null zur√ºcksetzen und die unteren auf 1 setzen oder auch BRR verwenden, dessen untere 16 Bits nur den Pin zur√ºcksetzen .  Ich mag die zweite Option.  Diese Register sind insofern wichtig, als sie einen atomaren Zugang zu den Pins erm√∂glichen: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Atomic Installation oder Reset</sub> <sub><br></sub>  <sub>Sie m√ºssen Interrupts nicht deaktivieren, wenn Sie GPIOx_ODR auf Bitebene programmieren: Sie k√∂nnen ein oder mehrere Bits mit einer atomaren Schreiboperation APB2 √§ndern.</sub>  <sub>Dies wird erreicht, indem ‚Äû1‚Äú in das Set / Reset-Register (GPIOx_BSRR oder nur zum Zur√ºcksetzen in GPIOx_BRR) das Bit geschrieben wird, das Sie √§ndern m√∂chten.</sub>  <sub>Andere Bits bleiben unver√§ndert.</sub> </p><br><p>  Datenregister haben ganz sprechende Namen - IDR = <em>Eingangsrichtungsregister</em> , Eingangsregister;  ODR = <em>Ausgangsrichtungsregister</em> , Ausgangsregister.  Im aktuellen Projekt werden wir sie nicht brauchen. </p><br><p>  Und schlie√ülich Kontrollregister.  Da wir an den Pins des zweiten SPI interessiert sind, n√§mlich PB13, PB14 und PB15, schauen wir uns sofort CRH an: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  Und wir sehen, dass es notwendig sein wird, vom 20. bis zum 31. etwas in Bits zu schreiben. </p><br><p>  Wir haben bereits herausgefunden, was wir von den Pins wollen, also kann ich hier auf einen Screenshot verzichten. Sagen wir einfach, dass MODE die Richtung (Eingabe, wenn beide Bits auf 0 gesetzt sind) und die Pin-Geschwindigkeit (wir brauchen 50 MHz, d. H. Beide) einstellt Pin in ‚Äû1‚Äú) und CNF stellt den Modus ein: normales ‚ÄûPush-Push‚Äú - 00, ‚ÄûAlternative‚Äú - 10. Wie oben gezeigt, haben alle Pins standardm√§√üig das dritte Bit von unten (CNF0), auf das sie gesetzt werden <em>schwebender Eingabemodus</em> . </p><br><p>  Da ich der Einfachheit halber etwas anderes mit diesem Chip machen m√∂chte, habe ich alle m√∂glichen MODE- und CNF-Werte sowohl f√ºr das untere als auch f√ºr das obere Steuerregister definiert. </p><br><div class="spoiler">  <b class="spoiler_title">So etwas in der Art</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Unsere Pins befinden sich an Port B (die Basisadresse ist 0x40010C00), Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO ‚Äì B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  Dementsprechend k√∂nnen Sie Definitionen f√ºr die LAT schreiben, die die Register BRR und BSRR zucken: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse ‚Äì high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low nur durch Tr√§gheit, irgendwie war es immer, lass dich bleiben) </p><br><p>  Jetzt ist schon alles super, funktioniert einfach nicht.  Da es sich um STM32 handelt, wird Strom gespart, sodass Sie die Uhr f√ºr die erforderlichen Peripherieger√§te aktivieren m√ºssen. </p><br><h2 id="vklyuchaem-taktirovanie">  Timing einschalten </h2><br><p>  Die Uhr ist f√ºr die Uhr verantwortlich, sie sind auch Uhr.  Und wir konnten bereits die Abk√ºrzung RCC sehen.  Wir suchen es in der Dokumentation: Dies ist Reset und Clock Control. </p><br><p>  Wie oben erw√§hnt, haben die Mitarbeiter von STM zum Gl√ºck den schwierigsten Teil des Timing-Themas f√ºr uns erledigt. Vielen Dank f√ºr sie (ich werde Ihnen einen Link zur√ºck zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Di Halt geben</a> , um zu verdeutlichen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwirrt</a> dies ist).  Wir brauchen nur die Register, die f√ºr die Aktivierung von Peripherietakten verantwortlich sind (Peripheral Clock Enable Registers).  Suchen Sie zuerst die Basisadresse von RCC, sie befindet sich ganz am Anfang der "Speicherkarte": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  Klicken Sie dann entweder auf den Link, √ºber den Sie versuchen, etwas in der Platte zu finden, oder lesen Sie die Beschreibungen der Einschlussregister in den Abschnitten zu den <em>Aktivierungsregistern</em> .  Wo wir RCC_APB1ENR und RCC_APB2ENR finden: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  Und in ihnen jeweils Bits, einschlie√ülich Taktung von SPI2, IOPB (E / A-Port B) und alternativen Funktionen (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  Den endg√ºltigen Code finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Wenn es eine Gelegenheit und einen Wunsch zum Testen gibt, verbinden wir DM634 wie folgt: DAI mit PB15, DCK mit PB13, LAT mit PB14.  Wir speisen den Fahrer ab 5 Volt, vergessen Sie nicht, die Erde zu kombinieren. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM auf STM8 </h1><br><p>  Als ich diesen Artikel zum Beispiel plante, habe ich mich entschlossen, einige Funktionen eines unbekannten Chips mit nur einem Datenblatt zu erlernen, damit ich keinen Schuhmacher ohne Stiefel bekomme.  STM8 war ideal f√ºr diese Rolle geeignet: Erstens hatte ich ein paar chinesische Motherboards mit STM8S103, und zweitens ist es nicht sehr beliebt, und daher besteht die Versuchung, im Internet eine L√∂sung zu lesen und zu finden, darin, dass genau diese L√∂sungen fehlen. </p><br><p>  Der Chip hat auch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenblatt</a> und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Referenzhandbuch RM0016</a> , in der ersten Pinbelegung und Registeradressen, in der zweiten - alles andere.  STM8 ist in C in der h√§sslichen IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ST Visual Develop</a> programmiert. </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Uhr und E / A. </h3><br><p>  Standardm√§√üig arbeitet der STM8 mit einer Frequenz von 2 MHz, dies muss sofort behoben werden. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>HSI-Uhr (interne Geschwindigkeit)</sub> <sub><br></sub>  <sub>Der HSI-Takt wird von einem internen 16-MHz-RC-Oszillator mit einem programmierbaren Teiler (1 bis 8) erhalten.</sub>  <sub>Sie wird im Register des Taktteilers (CLK_CKDIVR) eingestellt.</sub> <sub><br></sub>  <sub>Hinweis: Zu Beginn wird der HSI-RC-Oszillator mit Teiler 8 als f√ºhrende Taktquelle ausgew√§hlt.</sub> </p><br><p>  Wir finden die Registeradresse im Datenblatt, die Beschreibung in refman und sehen, dass das Register gel√∂scht werden muss: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Da wir PWM starten und die LEDs anschlie√üen, sehen wir uns die Pinbelegung an: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  Der Chip ist klein, viele Funktionen sind an denselben Pins aufgeh√§ngt.  Die Tatsache, dass in eckigen Klammern ‚Äûalternative Funktionalit√§t‚Äú steht, wird durch ‚Äû <em>Optionsbytes</em> ‚Äú umgeschaltet - so etwas wie Atmegas Sicherungen.  Sie k√∂nnen ihre Werte programmgesteuert √§ndern, sind aber nicht erforderlich, da  Neue Funktionen werden erst nach einem Neustart aktiviert.  Es ist einfacher, ST Visual Programmer (Downloads zusammen mit Visual Develop) zu verwenden, mit dem diese Bytes ge√§ndert werden k√∂nnen.  Die Pinbelegung zeigt, dass die Schlussfolgerungen von CH1 und CH2 des ersten Timers in eckigen Klammern versteckt sind.  Es ist notwendig, die Bits AFR1 und AFR0 in STVP zu setzen, und der zweite √ºbertr√§gt auch den Ausgang von CH1 des zweiten Timers von PD4 auf PC5. </p><br><p>  Somit steuern 6 Pins die LEDs: PC6, PC7 und PC3 f√ºr den ersten Timer, PC5, PD3 und PA3 f√ºr den zweiten. </p><br><p>  Das Konfigurieren der E / A-Pins selbst auf dem STM8 ist einfacher und logischer als auf dem STM32: </p><br><ul><li>  vertraut mit Atmega <em>Data Direction Register</em> : 1 = Ausgabe; </li><li>  das erste Steuerregister CR1 am Ausgang stellt den Gegentaktmodus (1) oder den offenen Drain (0) ein;  Da ich die LEDs mit Kathoden an den Chip anschlie√üe, lasse ich hier Nullen. </li><li>  Das zweite Steuerregister CR2 am Ausgang stellt die Taktrate ein: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  PWM-Setup </h2><br><p>  Definieren wir zun√§chst die Begriffe: </p><br><ul><li>  <strong>PWM-Frequenz</strong> - Frequenz, mit der der Timer tickt; </li><li>  <strong>Auto-Reload, AR</strong> - Autoload-Wert, bis zu dem der Timer z√§hlt (Impulsperiode); </li><li>  <strong>Update Event, UEV</strong> - ein Ereignis <strong>, das auftritt,</strong> wenn der Timer bis AR gez√§hlt hat; </li><li>  <strong>PWM-</strong> Arbeitszyklus - PWM-Arbeitszyklus, h√§ufig als "Arbeitszyklus" bezeichnet; </li><li>  <strong>Capture / Compare Value</strong> - Wert f√ºr <strong>Capture / Compare</strong> , der gez√§hlt hat, bis zu dem der Timer <em>etwas unternimmt</em> (im Fall von PWM invertiert er das Ausgangssignal); </li><li>  <strong>Preload Value</strong> - vorinstallierter Wert.  <em>Der Vergleichswert</em> kann sich nicht √§ndern, w√§hrend der Timer tickt, da sonst der PWM-Zyklus unterbrochen wird.  Daher werden die neu √ºbertragenen Werte in den Puffer gelegt und von dort herausgezogen, wenn der Timer das Ende der Z√§hlung erreicht und zur√ºckgesetzt wird. </li><li>  <strong>Modi</strong> f√ºr Kantenausrichtung und Mittelausrichtung - Ausrichtung am Rand und in der Mitte, genau wie bei Atmelovskie <em>Fast PWM</em> und <em>Phasenkorrektem PWM</em> . </li><li>  <strong>OCiREF, Output Compare Reference Signal</strong> - das Referenzausgangssignal, das sich im PWM-Modus tats√§chlich am entsprechenden Pin befindet. </li></ul><br><p>  Wie bereits aus der Pinbelegung hervorgeht, verf√ºgen zwei Timer √ºber die PWM-Funktionen - der erste und der zweite.  Beide sind 16-Bit, das erste hat viele zus√§tzliche Funktionen (insbesondere kann es sowohl nach oben als auch nach unten z√§hlen).  Wir m√ºssen beide auf die gleiche Weise arbeiten, also habe ich beschlossen, mit der offensichtlich √§rmeren Sekunde zu beginnen, um nicht versehentlich etwas zu verwenden, das nicht darin enthalten ist.  Ein Problem besteht darin, dass die Beschreibung der PWM-Funktionalit√§t aller Timer im Referenzhandbuch im Kapitel √ºber den ersten Timer (17.5.7 PWM-Modus) enthalten ist, sodass Sie im gesamten Dokument hin und her springen m√ºssen. </p><br><p>  PWM auf STM8 hat einen wichtigen Vorteil gegen√ºber PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM mit Kantenausrichtung</sub> <sub><br></sub>  <sub>Kontokonfiguration von unten nach oben</sub> <sub><br></sub>  <sub>Die Bottom-Up-Z√§hlung ist aktiv, wenn das DIR-Bit im Register TIM_CR1 gel√∂scht wird</sub> <sub><br></sub>  <sub>Beispiel</sub> <sub><br></sub>  <sub>Das Beispiel verwendet den ersten PWM-Modus.</sub>  <sub>Das OCiREF PWM-Referenzsignal wird hoch gehalten, w√§hrend TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Ansonsten nimmt es ein niedriges Niveau.</sub>  <sub>Wenn der Vergleichswert im Register TIM1_CCRi gr√∂√üer als der Startwert (Register TIM1_ARR) ist, wird das OCiREF-Signal auf 1 gehalten. <strong>Wenn der Vergleichswert 0 ist, wird OCiREF auf Null gehalten.</strong></sub>  <sub>...</sub> </p><br><p>  Der STM8-Timer √ºberpr√ºft w√§hrend des <em>Aktualisierungsereignisses</em> zuerst den <em>Vergleichswert</em> und gibt erst dann ein Referenzsignal aus.  Der Timer von Atmega mischt zuerst und vergleicht dann, wodurch die Ausgabe beim <code>compare value == 0</code> zu einer Nadel f√ºhrt, die irgendwie bek√§mpft werden muss (z. B. durch programmgesteuertes Invertieren der Logik). </p><br><p>  Also, was wir tun wollen: 8-Bit-PWM ( <code>AR == 255</code> ), betrachten wir von unten nach oben, Ausrichtung entlang der Grenze.  Da die Gl√ºhbirnen √ºber Kathoden mit dem Chip verbunden sind, muss die PWM vor dem <em>Vergleich des Werts</em> 0 (LED leuchtet) und danach 1 ausgeben. </p><br><p>  Wir haben bereits √ºber einige <em>PWM-Modi</em> gelesen und finden das gew√ºnschte Register des zweiten Timers, indem wir im Referenzhandbuch nach diesem Satz suchen (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Erster PWM-Modus - Wenn von unten nach oben gez√§hlt wird, ist der erste Kanal aktiv, w√§hrend TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Andernfalls ist der erste Kanal inaktiv.</sub>  <sub>[weiter im Dokument fehlerhaftes Kopieren und Einf√ºgen von Timer 1]</sub> <sub><br></sub>  <sub>111: Zweiter PWM-Modus - Wenn von unten nach oben gez√§hlt wird, ist der erste Kanal inaktiv, w√§hrend TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Ansonsten ist der erste Kanal aktiv.</sub> </p><br><p>  Da die LEDs an die MK-Kathoden angeschlossen sind, ist der zweite Modus f√ºr uns geeignet (der erste auch, aber wir wissen es noch nicht). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Aktivieren Sie das Vorladen von Ausgang 1</sub> <sub><br></sub>  <sub>0: Register vorladen bei TIMx_CCR1 aus.</sub>  <sub>Sie k√∂nnen jederzeit in TIMx_CCR1 schreiben.</sub>  <sub>Der neue Wert funktioniert sofort.</sub> <sub><br></sub>  <sub>1: Das Preload-Register bei TIMx_CCR1 ist aktiviert.</sub>  <sub>Lese- / Schreibvorg√§nge greifen auf das Preload-Register zu.</sub>  <sub>Der vorinstallierte Wert TIMx_CCR1 wird bei jedem Aktualisierungsereignis in das Schattenregister geladen.</sub> <sub><br></sub>  <sub>* Hinweis: Damit der PWM-Modus ordnungsgem√§√ü funktioniert, m√ºssen die Vorspannungsregister aktiviert sein.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   ¬´¬ª   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   ‚Ä¶    .  Was ist los? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   ‚Äì  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     ¬´¬ª   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   ¬´¬ª,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  ‚Äì ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     ‚Äì      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X ‚Äì  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> ‚Äì   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  Das hei√üt,  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     ‚Ññ13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    ‚Ññ13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> ‚Äì     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    ‚Äì <code>sim</code> ‚Äì  .          ¬´¬ª,         . </p><br><p>   ‚Äì <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456094/">https://habr.com/ru/post/de456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456084/index.html">Kubernetes 1.15: Highlights √úbersicht</a></li>
<li><a href="../de456086/index.html">iOS Storyboards: Analyse der Vor- und Nachteile, Best Practices</a></li>
<li><a href="../de456088/index.html">Probleme bei der Big Data-Analyse</a></li>
<li><a href="../de456090/index.html">Einf√ºhrung in Unit Testing in Unity</a></li>
<li><a href="../de456092/index.html">Sieben beunruhigende Anzeichen daf√ºr, dass Sie wetterabh√§ngig sind, auch wenn Sie dies nicht glauben</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, w√§hrend er in den Wolken schwebt</a></li>
<li><a href="../de456100/index.html">Jetzt in der neuen Verpackung - Kingston A400 im M.2-Format eilt auf den Markt</a></li>
<li><a href="../de456104/index.html">Ezblock Pi - Programmieren ohne Programmieren, diesmal f√ºr Raspberry Pi-Fans</a></li>
<li><a href="../de456106/index.html">Wir teilen Features schneller. Android-Entwicklungserfahrung bei Badoo</a></li>
<li><a href="../de456110/index.html">Wie sieht dein Text aus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>