<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ¤˜ğŸ¾ ğŸ‘“ Apa yang diajarkan PDP-11 kepada kita? ã€°ï¸ ğŸ™ŒğŸ¼ ğŸ§˜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CG Bell, WD Strecker, "Komputer Yang Telah Kita Pelajari dari PDP-11," Simposium Tahunan ke-3 tentang Prosiding Konferensi Arsitektur Komputer, hal. k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang diajarkan PDP-11 kepada kita?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435292/"><img src="https://habrastorage.org/webt/bt/ex/g2/btexg2j_gmcvjxnfpjn4x3jbxs4.png"><br>  <i>CG Bell, WD Strecker, "Komputer Yang Telah Kita Pelajari dari PDP-11," Simposium Tahunan ke-3 tentang Prosiding Konferensi Arsitektur Komputer, hal.</i>  <i>ke-14, 1976.</i> <br><br>  Artikel yang saya pilih hari ini adalah retrospektif dari desain komputer.  Ini adalah salah satu dari beberapa artikel oleh Gordon Bell dengan berbagai penulis yang menggambarkan pengembangan, pertumbuhan, dan penggantian tiba-tiba dari lini produk kultus perusahaan, minicomputer PDP-11. <br><a name="habracut"></a><br><ul><li>  CG Bell, R. Cady, H. McFarland, B. Delagi, J. O'Laughlin, R. Noonan dan W. Wulf, "Arsitektur Baru untuk Komputer-Komputer Kecil - DEC PDP-11," Prosiding Joint Sprint Konferensi Komputer, hlm.  657-675, AFIPS Press, 1970. </li><li>  CG Bell, WD Strecker, "Komputer Yang Telah Kita Pelajari dari PDP-11," Simposium Tahunan ke-3 tentang Prosiding Konferensi Arsitektur Komputer, hal.  ke-14, 1976. </li><li>  WD Strecker, "VAX-11/780: Perpanjangan Alamat Virtual ke Keluarga DEC PDP-11," Prosiding National Computer Conference, hlm.  967-980, AFIPS Press, 1978. </li><li>  CG Bell, WD Strecker, â€œRetrospektif: apa yang telah kita pelajari dari PDP-11 - apa yang telah kita pelajari dari VAX dan Alphaâ€, Prosiding Simposium Internasional Tahunan ke 25 tentang Arsitektur Komputer, hlm.  6-10, 1998. </li></ul><br>  Tahun ini kami merayakan ulang tahun ke 60 berdirinya perusahaan yang memproduksi PDP-11.  40 tahun telah berlalu sejak artikel ini ditulis, dan saya pikir akan menarik untuk meninjau kembali artikel Bell dari sudut pandang modern kita. <br><br><img src="https://habrastorage.org/webt/ef/p_/vy/efp_vyyz1an5rfis3axmot-vf5i.jpeg"><br><br><h3>  Apa itu Digital Equipment Corporation? </h3><br>  Untuk membayangkan waktu artikel ini ditulis, pertama-tama kita perlu berbicara sedikit tentang perusahaan yang meluncurkan PDP-11, Digital Equipment Corporation dari Maynard, Massachusetts.  Lebih dikenal dengan DEC. <br><br><img src="https://habrastorage.org/webt/vw/er/6w/vwer6wfpzv4-ppq7-xfxqjcnoqc.jpeg"><br><br>  DEC didirikan pada tahun 1957 oleh Ken Olsen dan Harlan Anderson.  Olsen dan Anderson bekerja bersama di Laboratorium Lincoln di Massachusetts Institute of Technology, di mana mereka memperhatikan bahwa para siswa berbaris berjam-jam untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TX-0</a> , sebuah komputer interaktif eksperimental yang dikembangkan oleh Wes Clark <br><br><div class="spoiler">  <b class="spoiler_title">1</b> <div class="spoiler_text">  Clark terus mengembangkan TX-0 di TX-2 dan kemudian bergabung dengan DEC sebagai kepala LINC <br></div></div><br><img src="https://habrastorage.org/webt/u-/p_/lm/u-p_lmwp4ly-4rjqdbq6bvjayuc.jpeg"><br><br>  Ini TX-0. <br><br><img src="https://habrastorage.org/webt/so/de/vr/sodevrwmacb_y7v65biysm1xxom.jpeg"><br><br>  Mari kita bandingkan dengan sesuatu seperti IBM 704, sebuah komputer pada masa yang kebanyakan siswa abaikan. <br><br><div class="spoiler">  <b class="spoiler_title">2</b> <div class="spoiler_text">  Setelah presentasi, seseorang menyarankan bahwa antipati siswa terhadap IBM dapat didasarkan pada kurangnya anggaran untuk waktu komputer dari sistem ini. <br></div></div><br>  Apa yang ditemukan Olsen dan Anderson adalah keinginan untuk menggunakan komputer interaktif begitu kuat sehingga ada pasar untuk komputer "kecil" yang dirancang untuk peran ini. <br><br><img src="https://habrastorage.org/webt/nc/eo/ab/nceoabpycn2zpif7o01ykcgjj5k.jpeg"><br><br>  DEC pada awalnya memperkenalkan PDP-1, versi komersial efisien dari TX-0. <br><br>  <i><b>Amandemen</b> : Michael Cheponis, kepala proyek pemulihan PDP-1, dengan ramah menulis kepada saya hal berikut:</i> <i><br><br></i>  <i>Angin puyuh dan PDP-1 memiliki kode operasi 5-bit, TX-0 dimulai dengan kode operasi 2- atau 3-bit, tetapi nilai ini meningkat dengan peningkatan ukuran memori TX-2.</i>  <i>Perbandingan urutan kode PDP-1 dan Whirlwind mengungkapkan bahwa PDP-1 adalah versi arsitektur Whirlwind yang lebih murah dan agak ditingkatkan.</i> <i><br><br></i> <ul><li>  Peningkatan: Menambahkan pengalamatan tidak langsung. </li><li>  Pengurangan biaya: "live-register" dihapus dan instruksi panggilan subrutin ditambahkan, dan penghitung shift dihapus karena fakta bahwa instruksi perkalian dan pembagian bilangan bulat digantikan oleh instruksi dari langkah penggandaan dan pembagian, yang membuat pergeseran dengan satu digit.  Penurunan harga PDP-1 terbesar dibandingkan dengan Whirlwind adalah karena perubahan dalam desain logika dan desain. </li></ul><br>  Kontras antara PDP-1 dan IBM 704 sangat bagus, tetapi beberapa tahun sebelumnya komputer interaktif kecil dan lambat, seperti Librascope LGP-30 dan Bendix G-15, telah muncul, dan mereka dijual dalam jumlah yang sama. <br><br>  Perlu juga dicatat bahwa nama PDP adalah akronim untuk "Pemrogram Data yang Diprogram," karena komputer pada waktu itu berarti mesin yang besar, kompleks, dan mahal, dan pemodal ventura mungkin tidak mendukung DEC jika mereka menghasilkan "komputer" <br><br><div class="spoiler">  <b class="spoiler_title">3</b> <div class="spoiler_text">  Salah satu game komputer pertama, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spacewar</a> " oleh Steve Russell, ditulis untuk PDP-1 <br></div></div><br>  Menyusul keberhasilan PDP-1, DEC menawarkan beberapa keluarga komputer, banyak di antaranya dirancang, setidaknya sebagian, oleh Gordon Bell. <br><br><h3>  Pendahuluan </h3><br>  <i>Komputer tidak sepenuhnya ditentukan oleh arsitektur;</i>  <i>itu mencerminkan aspek teknologi, ekonomi dan kemanusiaan dari waktu dan tempat di mana ia dirancang dan dibangun.</i>  <i>Komputer jadi adalah produk dari jamannya.</i> <br><br>  Sejak awal, Bell memberi tahu kami bahwa untuk keberhasilan setiap proyek komputer, Anda tidak perlu membangun komputer abstrak terbaik di dunia, tetapi membangun komputer yang tepat dengan mempertimbangkan konteksnya. <br><br>  <i>Dalam bab ini, kita akan melihat pada PDP-11: tujuan penciptaan, arsitektur, berbagai implementasi, dan orang-orang yang menciptakannya.</i>  <i>Kami akan mempelajari desainnya, dimulai dengan spesifikasi arsitektur, dan mempertimbangkan bagaimana mereka dipengaruhi oleh teknologi, organisasi pengembangan, penjualan, aplikasi, organisasi produksi, dan sifat pengguna akhir.</i> <br><br>  Pada saat ini, pada tahun 1976, Bell adalah kepala pengembangan DEC selama hampir empat tahun.  Jelas bahwa ia memandang keberhasilan PDP-11 dalam konteks pasar yang lebih luas, kebutuhan yang seharusnya mereka puaskan, dan yang kemudian memengaruhi evolusi seluruh keluarga PDP-11. <br><br>  Berumur dalam semangat kata-kata Bell, presentasi ini berfokus pada dua aspek dari artikel, teknologi, dan orang-orang. <br><br><h3>  Fundamental: pemikiran di balik desain </h3><br>  Bell diawali dengan pengamatan seperti itu, <i>karena sifatnya, teknik komputer berorientasi pada tujuan menciptakan produk akhir.</i>  <i>Karena itu, sulit untuk membangun rencana jangka panjang di dalamnya.</i> <br><br>  Ini adalah prinsip lincah.  Saat itu.  25 tahun sebelum Snowbird dan menulis manifesto lincah.  Ketika itu ditulis, DEC tidak lagi menjadi startup yang berjuang untuk keberadaannya, itu adalah perusahaan yang matang dengan beberapa lini produk yang sukses di pasar, dan Bell mengatakan bahwa kebutuhan untuk merilis produk dengan permintaan minimum (produk yang layak minimum) lebih penting daripada semua jangka panjang lainnya rencana. <br><br>  Seperti IBM / 360, PDP-11 tidak dikembangkan sebagai model komputer tunggal, tetapi sebagai serangkaian model, sedangkan perangkat lunak yang ditulis untuk PDP-11 kecil akan kompatibel dengan yang besar. <br><br>  <i>â€œIstilahâ€œ arsitektur â€digunakan di sini untuk menggambarkan atribut-atribut sistem, seperti yang dilihat oleh programmer, mis.</i>  <i>"struktur konseptual dan perilaku fungsional, dan bukan untuk menggambarkan organisasi aliran data dan manajemen, desain logis dan implementasi fisik."</i>  <i>- GM Amdahl GA Blaauw dan FP Brooks Jr.</i>  <i>Arsitektur Sistem IBM / 360, 1964</i> <br><br>  Karena sifat terbuka PDP-11, apa pun yang menginterpretasikan instruksi sesuai dengan spesifikasi prosesor adalah PDP-11, dan DEC, segera setelah pasar PDP-11 memanas, mulai membangun implementasi arsitektur ini, mereka memiliki beberapa kelompok, satu dimana mereka membangun komputer yang cepat dan mahal, sementara yang lain mendesain yang lebih lambat dengan harga lebih murah. <br><br>  <i>Meskipun gaya perencanaan evolusionernya, PDP-11 berhasil di pasar: lebih dari 20.000 unit terjual dalam enam tahun mereka di pasar (1970-1975).</i>  <i>Desain dalam hal ini tidak begitu penting: organisasi pemasaran yang besar dan agresif, dipersenjatai dengan perangkat lunak untuk memperbaiki kekurangan dan kekurangan arsitektur, dapat menyelamatkan hampir semua desain.</i> <br><br>  Di sini, Bell dalam artikelnya mengajukan pertanyaan: apakah PDP-11 memiliki desain yang bagus, atau hanya mendapatkan keuntungan melalui pemasaran yang hiperaktif?  Untuk menjawab pertanyaannya sendiri, Bell mempertimbangkan produk dalam hal kriteria desain yang dia dan rekan penulis identifikasi enam tahun sebelumnya. <br><br><h3>  Ruang alamat </h3><br>  Kelemahan pertama dari mikrokomputer adalah ruang alamat yang terbatas.  Kesalahan terbesar dan paling umum adalah merancang komputer yang tidak memiliki ruang alamat yang cukup untuk menangani dan mengelola memori. <br><br>  Komputer mini pada zaman itu memiliki ruang alamat 12-bit, yang memungkinkan hanya 4096 alamat untuk diatasi, masing-masing menyimpan kata 12-bit. <br><br>  Perlu dicatat bahwa kata "komputer mini", yang kemudian menjadi ukuran fisik, pada awalnya dibentuk dari frasa "komputer minimal".  Contoh kanonik adalah PDP-8, model DEC sebelumnya, yang hanya memiliki delapan instruksi. <br><br><img src="https://habrastorage.org/webt/vi/me/co/vimecoj2x5aezvsojy6vza9erdi.jpeg"><br><br>  Alasan untuk ruang alamat kecil adalah harga.  Memori itu sangat mahal di tahun 60-an dan awal 70-an, ketika masing-masing bit terdiri dari inti magnetik kecil, yang ditenun ke dalam jaringan kabel kontrol. <br><br>  Inti disusun dalam panel, dalam hal ini masing-masing 4096 bit, yang disusun untuk mendapatkan kata, jadi 4096 kata memori terdiri dari 16 juta dering (di <i>sini, jelas, kesalahan dalam teks asli, 4096 kata * 16 bit = 65536 cincin terjemahan kira-kira.</i> ), yang masing-masing, setidaknya sebagian, dirakit secara manual.  Sekarang sudah jelas mengapa memori begitu mahal. <br><br><img src="https://habrastorage.org/webt/cm/fg/jp/cmfgjpj8yor6yj6qy6r6efh8og4.png"><br><br>  Bell dan perancang PDP-11 lainnya tahu bahwa harga inti akan terus turun, dan memori semikonduktor, walaupun tidak seefektif biaya saat itu, akan terus menjadi lebih murah berdasarkan satu byte yang disimpan.  Dengan demikian, jumlah memori yang mampu dibeli pembeli akan meningkat seiring waktu, karena pengguna cenderung membeli "sistem dengan harga yang sama dalam dolar."  Tapi tetap saja <br><br>  <i>PDP-11 mengikuti tradisi buruk dalam menghemat bit alamat ini, tetapi diselamatkan oleh prinsip bahwa desain yang baik dapat bertahan setidaknya satu perubahan besar.</i> <br><br>  Bahkan dengan mempertimbangkan prediksi para pengembang, Bell mencatat bahwa kurang dari dua tahun telah berlalu sejak diperkenalkannya arsitektur PDP-11, itu memerlukan dimasukkannya modul manajemen memori dalam arsitektur untuk memberikan akses ke ruang alamat yang lebih besar, 18-bit dengan biaya meningkatnya kompleksitas perangkat lunak .  Beberapa tahun kemudian 4 bit lainnya ditambahkan. <br><br>  Dalam keadilan, meskipun Bell mencela dirinya sendiri karena tergesa-gesa, tradisi membuat ruang alamat yang tidak memadai berlanjut hingga hari ini.  Ingat batasan 640K dalam DOS?  Ingat pertempuran dengan himem.sys?  Menghadapi situasi di mana program 32-bit membutuhkan lebih dari 2 GB untuk data? <br><br>  Jadi tidak ada yang sempurna. <br><br><h3>  Register tidak cukup </h3><br>  <i>Kelemahan kedua dari minicomputer adalah kecenderungan jumlah register yang tidak mencukupi.</i>  <i>Ini diperbaiki di PDP-11, yang memiliki delapan register 16-bit.</i>  <i>Kemudian, enam register 32-bit ditambahkan untuk aritmatika floating point.</i>  <i>Lebih banyak register dapat meningkatkan waktu pengalihan konteks tugas.</i> <br><br>  Itu tidak biasa, bahkan untuk mainframe saat itu, hanya menyediakan satu register - baterai.  Jika register tambahan disediakan, mereka hanya digunakan sebagai register indeks, bukan sebagai register tujuan umum. <br><br>  Menarik juga untuk dicatat komentar Bell bahwa register tambahan dapat merepotkan bagi pengguna.  Pada awal 1970-an, yang paling umum adalah mesin pemrograman langsung di assembler. <br><br>  Ada korelasi yang kuat antara jumlah register dalam arsitektur, jumlah bit alamat, dan ukuran instruksi.  Semua faktor ini menyebabkan memori tidak mencukupi, dan masuk akal untuk dengan cermat memikirkan sistem perintah. <br><br>  Dalam mesin Von Neumann (yang praktis semua komputer tahun 60-an), program dan data berbagi ruang alamat yang sama dan terbatas, dan program yang tidak efektif tidak hanya menghabiskan waktu komputer, tetapi juga memori.  Program yang lambat dapat ditoleransi, tetapi jika program tersebut tidak sesuai dengan memori, itu berakibat fatal, yaitu, metode pengkodean instruksi harus seefisien mungkin. <br><br>  Mari kita lihat kasus perpindahan yang sangat umum dari satu lokasi memori ke lokasi lainnya.  Berapa banyak bit yang diperlukan untuk menggambarkan operasi ini?  Berikut ini adalah salah satu implementasi yang mungkin: <br><br><pre><code class="plaintext hljs">MOV addr addr</code> </pre> <br>  Anda memerlukan 16 bit untuk alamat sumber, 16 lainnya untuk alamat tujuan, dan sejumlah bit untuk menyandikan instruksi MOV itu sendiri.  Biar ada total 40 bit, ini bukan kelipatan 16, yang berarti pengodean instruksi 2,5-bit yang kompleks.  Namun, bagaimana jika kita memuat alamat ke dalam register? <br><br><pre> <code class="plaintext hljs">MOV (R0), (R1)</code> </pre> <br>  Dalam hal ini, kita hanya perlu menggambarkan register, PDP-11 memiliki 8 register, dan hanya 3 bit yang cukup untuk menggambarkan register, ditambah beberapa bit untuk menggambarkan operator.  Perintah seperti itu dapat dengan mudah dimasukkan ke dalam kata 16-bit, dan tidak memerlukan pengkodean instruksi yang rumit dengan panjang variabel. <br><br><img src="https://habrastorage.org/webt/ud/dt/01/uddt01pifmvr1f_nkkop39uzxr0.png"><br><br>  Pada kenyataannya, PDP-11 menggunakan 6 bit per register, dan 4 bit per operasi jika instruksi memiliki dua operan. <br><br><h3>  Tumpukan perangkat keras </h3><br>  <i>Kelemahan ketiga dari minicomputer adalah kurangnya dukungan perangkat keras untuk stack.</i>  <i>PDP-11 menerapkan mekanisme penambahan otomatis dan pengurangan otomatis untuk alamat tersebut.</i>  <i>Solusi ini unik untuk PDP-11 dan telah terbukti sangat berguna.</i>  <i>(Dan solusi ini disalin oleh pengembang sistem lain.)</i> <br><br>  Saat ini, sulit membayangkan perangkat keras yang tidak memiliki tumpukan, tetapi sebenarnya tumpukan tidak terlalu penting jika Anda tidak menggunakan rekursi. <br><br>  Desain PDP-11 tanggal kembali ke 1969, dan jika kita melihat bahasa pemrograman saat itu, FORTRAN dan COBOL, mereka tidak mendukung pemanggilan fungsi rekursif.  Urutan panggilan fungsi termasuk menyimpan alamat kembali dalam kata kosong di awal prosedur, yang membuat rekursi menjadi tidak mungkin. <br><br><img src="https://habrastorage.org/webt/9t/a0/jg/9ta0jg3ud742lxb5ayw93pfv-ke.png"><br><br>  PDP-11 mendefinisikan penunjuk tumpukan seperti yang kita pahami hari ini, sebagai register yang dikendalikan oleh operasi PUSH dan POP, tetapi PDP-11 melangkah lebih jauh dan mengizinkan register apa pun untuk berfungsi sebagai penunjuk tumpukan dengan menambahkan pengubah kenaikan / penurunan otomatis ke register operan. <br><br>  Sebagai contoh, satu instruksi: <br><br><pre> <code class="plaintext hljs">MOV R4, -(R6)</code> </pre> <br>  akan menurunkan nilai dalam R6 dua, kemudian menyimpan nilai R4 di alamat yang tersimpan di R6.  Jadi, dalam assembler PDP-11 kita menempatkan nilai pada stack.  Jika ada di antara Anda yang diprogram untuk ARM, ini seharusnya tidak asing bagi Anda. <br><br>  Ini berarti bahwa tidak perlu untuk instruksi PUSH atau POP khusus, ini menghemat ruang instruksi, memungkinkan Anda untuk menggunakan register apa pun sebagai penunjuk tumpukan, meskipun secara tradisional penunjuk tumpukan adalah R6, dan digunakan oleh peralatan saat melakukan panggilan subprogram. <br><br><h3>  Keterlambatan Interupsi </h3><br>  <i>Kelemahan keempat dari minicomputer pada waktu itu adalah dukungan terbatas untuk interupsi dan perpindahan konteks yang lambat, dan masalah ini diselesaikan dengan menggunakan pengontrol interupsi vektor UNIBUS dengan koneksi langsung dari gangguan perangkat.</i> <br><br>  Pada titik ini dalam kehidupan DEC, hampir semua produknya memiliki arsitektur PDP-10, mainframe DEC yang dirancang untuk aplikasi interaktif, laboratorium, dan kontrol proses.  Respons terhadap interupsi, penundaan antara aktivasi sinyal interupsi dan dimulainya pemrosesan interupsi, adalah kunci untuk mendapatkan kinerja real-time yang tinggi. <br><br>  Dalam PDP-11, perangkat yang memicu interupsi menyediakan alamat penangan interupsi.  Bell dengan jujur â€‹â€‹menulis tentang ini: <br><br>  <i>Mekanisme utamanya sangat cepat, hanya membutuhkan empat siklus mengakses memori sejak saat interupsi diminta sampai instruksi pertama dari interrupt handler dijalankan.</i> <br><br><h3>  Dukungan Karakter </h3><br>  <i>Kelemahan kelima dari kebanyakan minicomputer adalah dukungan string yang buruk, yang diselesaikan dalam PDP-11 oleh kemampuan untuk secara langsung mengatasi byte.</i> <br><br>  Pentingnya mendukung string dan karakter mulai tumbuh selama 1960-an ketika solusi untuk sains dan bisnis mulai muncul.  Metode pengkodean dominan pada waktu itu adalah set karakter 6-bit, yang menyediakan ruang yang cukup untuk huruf besar, angka dari 0 hingga 9, spasi dan beberapa tanda baca, cukup untuk mencetak laporan keuangan. <br><br><img src="https://habrastorage.org/webt/4j/7a/2i/4j7a2igan6lbjg_1rs05pxmoeus.jpeg"><br><br>  Karena ingatannya sangat mahal, menempatkan satu karakter dalam kata 12-bit atau 18-bit tidak dapat diterima, dan karakter-karakter tersebut dikemas dalam kata-kata. <br><br>  Ini meningkatkan efisiensi penyimpanan, tetapi sulit untuk operasi seperti memindahkan, membandingkan, dan menggabungkan, yang harus mempertimbangkan bahwa karakter dapat berada di bagian bawah atau atas kata, yang meningkatkan jumlah memori mahal yang ditempati oleh program. <br><br>  Masalahnya diselesaikan di PDP-11, mesin dapat beroperasi dengan kata-kata 16-bit dan 8-bit yang mendapatkan popularitas.  Memperpanjang panjang karakter dengan dua bit operasi string yang disederhanakan, dan membuatnya lebih mudah untuk beradaptasi dengan standar ASCII 7-bit yang semakin populer, yang didukung oleh DEC pada saat itu.  Bell mengakhiri paragraf ini seperti ini: <br><br>  <i>Terlepas dari kenyataan bahwa instruksi untuk memproses string tidak ada dalam peralatan, operasi string biasa (bergerak, membandingkan, menyatukan) dapat diprogram sebagai siklus yang sangat singkat.</i> <br><br>  Dan ini sebenarnya benar.  Anda dapat menulis prosedur penyalinan hanya dalam dua instruksi, dengan asumsi bahwa sumber dan alamat tujuan ada dalam register. <br><br><pre> <code class="plaintext hljs">loop: MOVB (src)+, (dst)+ BNE loop</code> </pre> <br>  Kode ini mengambil keuntungan dari kenyataan bahwa perintah MOV menetapkan bendera.  Siklus akan berlanjut sampai nilai di alamat sumber menjadi nol, dan pada titik ini kontrol berlanjut ke instruksi berikutnya.  Inilah sebabnya mengapa garis C diakhiri dengan nol. <br><br><h3>  ROM </h3><br>  <i>Titik lemah keenam dari minicomputer adalah ketidakmampuan untuk menggunakan ROM, dan PDP-11 tidak memiliki kelemahan ini.</i>  <i>Sebagian besar kode yang ditulis untuk PDP-11 adalah "bersih" dan memungkinkan masuk kembali tanpa upaya programmer khusus, yang memungkinkan penggunaan langsung ROM.</i> <br><br>  Dalam aplikasi kontrol proses, di mana program relatif tetap, mereka harus mengunduh program setiap kali dari pita magnetik atau pita berlubang, yang mahal.  Anda harus membeli dan memelihara perangkat I / O yang jarang digunakan.  Lebih nyaman bila program selalu ada di komputer.  Namun, karena keterbatasan yang kuat pada jumlah memori, dan kurangnya dukungan perangkat keras untuk stack, kode modifikasi sendiri sering tidak dapat dihindari, yang sangat membatasi penggunaan ROM.  Bell dengan bangga mengatakan bahwa PDP-11 telah mengubah situasi. <br><br><h3>  I / O primitif </h3><br>  <i>Kelemahan ketujuh dari minicomputer adalah kemampuan I / O primitif.</i> <br><br>  Selama 60-an, ketika PDP-11 dikembangkan, perangkat I / O sangat mahal.  Mainframe waktu itu menggunakan apa yang disebut saluran I / O, di mana prosesor pusat mengirim program kecil ke pengontrol saluran, yang mengeksekusi program dan melaporkan hasilnya.  Suatu program dapat, misalnya, memuat data dari pita magnetik atau menembus kartu punch. <br><br>  Saluran I / O penting, memungkinkan untuk membongkar prosesor dari operasi I / O, dan melakukan tindakan I / O pada saat yang sama, yang meningkatkan pemanfaatan prosesor.  Kelemahannya adalah bahwa saluran I / O memerlukan CPU terpisah di setiap pengontrol saluran, yang meningkatkan biaya seluruh sistem secara cukup signifikan. <br><br><img src="https://habrastorage.org/webt/i8/5d/p-/i85dp-32llbfdd4hxev4ixfzcs0.jpeg"><br><br>  Dalam dunia minicomputer, I / O biasanya dilakukan langsung ke CPU, biasanya menggunakan instruksi khusus yang dikodekan secara keras untuk setiap perangkat tertentu, seperti tape drive atau printer konsol. <br><br>  PDP-11 memperkenalkan sesuatu yang tidak biasa, memetakan I / O.  I / O yang dipetakan dengan memori seperti itu dapat Anda gunakan dengan panggilan sistem mmap (2), tetapi hanya kesepakatan bahwa beberapa alamat dalam memori bukan hanya sel memori, dan isinya ditampilkan pada papan yang dimasukkan ke dalam backplane, yang dalam DEC disebut UNIBUS. <br><br><img src="https://habrastorage.org/webt/zg/bx/9i/zgbx9il5qoyr81cc_zkpbxarjza.jpeg"><br><br>  Misalnya, nilai yang tercatat di 777566 <div class="spoiler">  <b class="spoiler_title">4</b> <div class="spoiler_text">  Alamat diberikan dalam oktal, seperti biasa pada mesin DEC 12, 18, dan 36-bit sebelumnya </div></div>  akan ditulis ke perangkat yang terhubung ke konsol, biasanya terminal pencetakan. <br><br><img src="https://habrastorage.org/webt/0p/_r/wk/0p_rwkprbziqlerzwca8rwp0ulo.jpeg"><br><br>  Jika Anda membaca nilai dari alamat 777570, Anda menerima nilai yang dimasukkan oleh sakelar di panel depan.  Ini sering digunakan untuk mengkonfigurasi bootloader. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  Demikian pula, drive RK05 diakses dengan menulis nomor sektor yang ingin Anda akses ke alamat 777412, alamat tempat Anda ingin menulis data ke 777410, dan jumlah kata menjadi 777406. Kemudian, atur bit nol pada 777404 ke 1 ( bit GO), dan drive akan mentransfer jumlah kata yang diinginkan langsung ke memori. <br><br><img src="https://habrastorage.org/webt/au/d-/4y/aud-4yckvahw_4xpj_wlwyfvqpy.jpeg"><br><br>  Perangkat favorit saya adalah KW11-L.  Menulis bit 6 ke alamat 777546 memicu interupsi setiap 20 ms.  Mengapa 20 ms?  Karena itu adalah periode frekuensi AC <br><br><div class="spoiler">  <b class="spoiler_title">5</b> <div class="spoiler_text">  Jika Anda memesan mobil untuk wilayah dengan frekuensi jaringan 60 Hz, ia memiliki nomor yang berbeda (nomor) <br></div></div><br>  Ya, seperti jam rumah tangga, PDP-11 menghitung waktu dengan periode tegangan dalam jaringan. <br><br><h3>  Biaya pemrograman yang tinggi </h3><br>  <i>Kelemahan kesembilan dari minicomputer adalah tingginya biaya pemrograman.</i>  <i>Banyak pengguna yang diprogram dalam bahasa assembly tanpa editor dan IDE yang nyaman, sistem file, dan debugger tersedia di sistem besar.</i>  <i>PDP-11 tidak dapat mengatasi kelemahan ini, meskipun PDP-11 membangun sistem yang lebih kompleks dari model sebelumnya, PDP-8 dan PDP-15.</i> <br><br>  Karena sifatnya yang minimalis, minicomputer tidak menyediakan lingkungan yang nyaman untuk mengembangkan program.  Sering menggunakan pergantian sakelar sakelar yang membosankan, atau, mungkin, mengedit dan merakit program di komputer lain yang besar, dan memindahkannya ke pita kertas. <br><br>  Itu mirip dengan bagaimana mikrokontroler diprogram hari ini, kami mengedit program pada workstation besar, mengkompilasi file biner target, dan mentransfernya ke memori flash mikrokontroler. <br><br><img src="https://habrastorage.org/webt/ep/kq/lh/epkqlhrntlqhzoejdeaownpnmws.jpeg"><br><br>  Namun, Bell tampaknya tidak tahu tentang karya Thompson dan Richie, yang sibuk membangun lingkungan perangkat lunak mereka sendiri pada PDP-11 di New Jersey. <br><br><h3>  Orang yang membangun desain </h3><br>  Mari kita beralih ke bagian kedua: orang <br><br>  Bagian ini paling menarik bagi saya, sebagai penggemar sejarah, karena mempelajari sejarah komputer, seperti subjek sejarah lainnya, pada dasarnya mempelajari sejarah orang dan konteks di mana mereka membuat keputusan. <br><br>  Bell mencatat bahwa sementara komputer berbasis teknologi, mereka adalah buatan manusia, dan oleh karena itu ia mengabdikan bagian ini untuk menggambarkan dinamika kelompok DEC selama pengembangan PDP-11. <br><br>  <i>Masalah yang dihadapi oleh pengembang komputer dapat dibagi menjadi dua bagian: masalah karena kurang pengalaman dan masalah yang bersifat sistemik.</i> <br><br>  Di sini, Bell mengingat kata-kata Fred Brooks dari buku terakhirnya pada waktu itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mythical Man-Month</a> . <br><br>  Brooks, kepala proyek OS / 360, telah berjuang selama bertahun-tahun untuk menciptakan sistem operasi serba guna yang dapat dijalankan pada semua model IBM / 360, yang merupakan tujuan dari proyek tersebut.  Kata-kata Brooks segar dalam ingatan Bell ketika ia menulis paragraf ini. <br><br><h3>  Garis waktu desain </h3><br>  Bagian ini adalah jendela ke dalam karya DEC Corporation di akhir 1960-an. <br><br>  Organisasi internal tim desain di DEC selama bertahun-tahun telah berfluktuasi antara orientasi pasar dan orientasi produk.  Ketika perusahaan tumbuh 30 atau 40% per tahun, ada kebutuhan untuk reorganisasi berkelanjutan.  Pada waktu tertentu, sekitar sepertiga karyawan bekerja di perusahaan selama kurang dari satu tahun. <br><br>  Angkat tangan Anda jika ini biasa bagi Anda. <br><br>  <i>Selama pengembangan PDP-11, perusahaan terstruktur di sekitar lini produk.</i>  <i>Pengembang perusahaan diorganisasikan dalam kelompok kecil: grup PDP-10, grup PDP-15 (mesin 18-bit), grup PDP-8, subkelompok PDP-8 / S, grup LINC-8.</i>  <i>Setiap kelompok termasuk pemasar dan insinyur yang bertanggung jawab untuk pengembangan produk, perangkat lunak dan perangkat keras.</i>  <i>Sebagai hasil dari organisasi seperti itu, pengalaman dalam arsitektur dibagi menjadi beberapa kelompok.</i> <br><br>  Bell mencurahkan waktu untuk meninjau setiap kelompok, mendaftar kekuatan dan kelemahannya, dan kontribusi mereka untuk PDP-11.  Saya tidak akan mencantumkan semua ini di sini, dengan satu pengecualian. <br><br>  <i>Grup PDP-10 adalah yang terkuat di perusahaan.</i>  <i>mereka membangun mesin yang besar, kuat, dan berbagi waktu.</i>  <i>Dalam banyak hal itu adalah divisi terpisah dari perusahaan, dengan interaksi minimum dengan kelompok lain.</i>  <i>Meskipun kelompok PDP-10 secara keseluruhan memiliki pemahaman terbaik tentang bagaimana arsitektur sistem bekerja, mereka tidak tahu tentang berbagai sistem, mereka tertarik untuk membangun hanya komputer berkecepatan tinggi.</i> <br><br>  Saya baru-baru ini bekerja untuk perusahaan perangkat lunak di mana satu atau dua produk tertua menghasilkan hampir semua keuntungan perusahaan, dan saya memahami posisi Bell dengan sangat baik.  PDP-10 adalah versi DEC dari mainframe, sangat cepat, dan tersedia hanya dengan satu harga tetap. <br><br>  <i>Pekerjaan pertama tentang menciptakan komputer 16-bit dimulai di bawah pengawasan seorang manajer PDP-15, seorang pemasar dengan pengalaman teknik.</i>  <i>Proyek pertama disebut PDP-X, dan termasuk spesifikasi untuk sejumlah mesin.</i>  <i>Ini adalah arsitektur keluarga mesin, dan itu dirancang lebih baik daripada PDP-11 kemudian, tetapi tidak terlalu inovatif.</i>  <i>Sayangnya, manajer grup menyalahkan manajemen bahwa proyek mereka berpotensi serumit PDP-10 (bukan itu), dan bahwa ia yakin akan kegagalan proyek, dan karena itu tidak ada orang lain yang ingin membuat komputer besar lain selain satu komputer besar. perusahaan.</i> <br><br>  Dan di sini Bell memberi kita pelajaran yang baik: jika kompetensi Anda dalam rantai yang sama dengan proyek-proyek manajer lain, mereka memiliki alat yang efektif untuk membunuh proyek Anda sebelum memasuki pasar. <br><br>  <i>Dalam retrospeksi, orang-orang yang terlibat dalam pengembangan PDP-X tampaknya telah bekerja pada pengembangan Data General pada saat yang sama.</i> <br><br>  Ini mungkin tidak diperhatikan oleh pembaca rata-rata, tetapi ini merujuk pada "delapan pengkhianat" Shockley satu dekade sebelumnya. <br><br><div class="spoiler">  <b class="spoiler_title">6</b> <div class="spoiler_text">  Kelompok ini termasuk Robert Noyce dan Gordon Moore, yang sepuluh tahun kemudian meninggalkan Fairchild dan mendirikan perusahaan mereka sendiri Intel. <br></div></div><br>  Edson de Castro, manajer produk PDP-8, dan manajer proyek PDP-X meninggalkan DEC, bersama beberapa orang dari timnya, untuk membentuk Data General.  Tidak jelas dari catatan apakah de Castro pergi karena PDP-X dihentikan, atau apakah kepergiannya adalah tantangan terakhir untuk membunuh proyek.  Bagaimanapun, hasilnya jelas, seperti yang ditulis Bell. <br><br>  <i>Ketika proyek PDP-X ditutup, proyek DCM (Desk Calculator Machine, nama kode yang dipilih untuk privasi) dimulai.</i>  <i>Desain dan perencanaan tidak menentu karena Data General berkompetisi dengan komputer 16-bitnya yang sangat kecil.</i> <br><br>  Data General tidak bersaing dengan DEC dengan komputer Nova 16-bit di pasar tempat PDP-8 dikembangkan dan yang de Castro tahu seperti bagian belakang tangannya: peralatan laboratorium yang dipasang di rak <br><br><img src="https://habrastorage.org/webt/7j/z0/ha/7jz0hacw75yjku2enc4pbz3pgoy.jpeg"><br><br>  12-bit PDP-8 vs Data General 16-bit Nova <br><br><img src="https://habrastorage.org/webt/dt/gl/5l/dtgl5lnjei8r8hyf3ec33ufgioo.jpeg"><br><br><h3>  PDP-11: nilai </h3><br>  Pada bagian terakhir artikel, PDP-11 dibandingkan dengan pendahulunya, dan kemudian Bell melanjutkan untuk mengevaluasi arsitektur PDP-11 itu sendiri.  Terobosan terbesar adalah UNIBUS. <br><br>  <i>Secara umum, bus UNIBUS melampaui semua harapan.</i>  <i>Ratusan jenis perangkat penyimpanan dan periferal dapat dihubungkan dengannya, ia menjadi komponen arsitektur sistem standar dalam kisaran harga dari $ 3K hingga $ 100K (1975).</i> <br><br><h3>  Apa itu UNIBUS? </h3><br><img src="https://habrastorage.org/webt/tf/jd/ow/tfjdowtglv5wihs8_bnuuht-11i.jpeg"><br><br>  Komputer komersial paling awal dirancang sebagai satu set modul yang terhubung ke backplane dengan koneksi kabel.  Pada masa lampu, ini adalah keharusan karena lampu tidak dapat diandalkan dan modul perlu diganti dengan cepat. <br><br><img src="https://habrastorage.org/webt/i3/je/cz/i3jeczdmrf1xtwgbhwzdazbcwzw.jpeg"><br><br>  Kemudian, keinginan untuk membangun komputer dari modul standar menyebabkan pembangunan blok logis umum yang terhubung menggunakan backplane kompleks. <br><br>  Berikut adalah contoh modul DEC awal. <br><br><img src="https://habrastorage.org/webt/pg/dl/sv/pgdlsv83s3hiyinvvjjygywglyq.jpeg"><br><br>  Anda dapat memasang mereka di backplane kompleks dengan koneksi kabel, dan membangun komputer dari mereka, dalam hal ini PDP-8. <br><br>  UNIBUS adalah pengembangan dari pengembangan DEC sebelumnya dan merupakan abstraksi dari bus kontrol yang ideal.  Ketersediaan komponen integrasi menengah menghilangkan kebutuhan untuk backplane yang kompleks dan memindahkan kompleksitas utama ke modul yang dipasang di backplane.  Ini memungkinkan untuk membangun modul standar yang terhubung ke komputer. <br><br>  <i>Bus UNIBUS, sebagai standar, adalah komponen arsitektur yang memungkinkan Anda membangun sistem yang mudah dikonfigurasi.</i>  <i>Perusahaan mana pun, tidak hanya DEC, dapat dengan mudah membuat komponen yang berinteraksi dengan bus.</i>  <i>Ban yang baik menciptakan lingkungan rekayasa yang baik di mana orang dapat berkonsentrasi pada desain yang terstruktur.</i>  <i>UNIBUS menciptakan industri sekunder yang menawarkan sumber pasokan alternatif untuk memori dan periferal.</i>  <i>Selain bus IBM 360, UNIBUS adalah standar bus paling umum di industri komputer.</i> <br><br>  Sebelum munculnya UNIBUS, perangkat input / output mana yang dapat didukung oleh komputer mini hanya ditentukan oleh pengembangnya.  Cara berinteraksi dengan perangkat diberi kode-keras oleh sirkuit logika komputer.  Dengan munculnya UNIBUS, bidang yang luas dibuka untuk menyesuaikan komputer oleh pengguna akhir dan bidang untuk eksperimen. <br><br><h3>  Apa yang diajarkan PDP-11 kepada kita? </h3><br><img src="https://habrastorage.org/webt/nn/e5/ex/nne5exbe74glx2ouw6c_m5ynxxm.jpeg"><br><br>  Retrospektif Bell berakhir pada saat artikel itu ditulis, yaitu  pada 1976-77, tetapi dari sudut pandang kami, empat puluh tahun kemudian, pengaruh PDP-11 sangat besar. <br><br><h3>  RISC </h3><br>  Pada awalnya, ketika PDP-11 belum dikembangkan, dan, apalagi, tidak dianggap sebagai mesin RISC, istilah ini tidak ada sebelum diperkenalkan oleh John Coke pada tahun 1976 sehubungan dengan IBM 801. Namun, untuk semua orang yang memiliki pengalaman pemrograman Prosesor ARM, prosesor RISC modern, kesamaan mereka jelas.  Sama seperti desain bahasa pemrograman adalah proses pengembangan evolusi serta meminjam, hal yang sama terjadi dengan desain sistem perintah. <br><br>  PDP-11        -,      -,       .  ,    -,  Intel 8080     Z80. <br><br><h3> UNIX </h3><br> PDP-11        . PDP-11  ,         UNIX  Bell Labs <br><br><div class="spoiler">  <b class="spoiler_title">7</b> <div class="spoiler_text"> UNIX     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDP-7</a> .  1970    PDP-11/20,    PDP-11/45. <br></div></div><br>  PDP-11 UNIX  .  PDP-11   ,   ,     .    ,     int  16 ,   - PDP-11. <br><br> UNIX     (pipes), Â«  Â»   . <br><br><h3> VAX-11/780 </h3><br>   ,    ,   PDP     ,         PDP-11. <br><br>     , 1977,    PDP-11, VAX-11,   â€œvirtual address extensionâ€. <br><br><h3> BSD </h3><br> UNIX     1974 ,    ,        BSD â€” Berkley Systems Distribution. <br><br> Berkeley UNIX    VAX   1980-      DEC-   VMS. Berkeley UNIX    ,     ,  Sun Microsystems,    Self,      Java. <br><br> UNIX          80-    Â« UNIX-Â»   BSD-,    . <br><br><h3> NeXT </h3><br> 4BSD,     ,       NeXT   .  Apple  NeXT  1997 , NextSTEP    BSD   Darwin, OSX  iOS. <br><br><h3> Windows NT </h3><br>    ,     ,  DEC   . <br><br>  ,    VAX VMS,            ,    VAX,   Microsoft  1988,      ,    Windows NT. ,    Windows    VMS, ,   . <br><br><h3> Xerox Alto </h3><br>       ,  Data General Nova      ,    , ,   ,   Apple Macintosh. <br><br><h3> Data General Nova </h3><br>   Data General  DEC    32- ,      ,   1981   ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Soul of a New Machine</a> ". <br><br><h3>     PDP-11? </h3><br>      ,    , PDP-11      . <br><br>  , ,  ,  ,     PDP-11. <br><br>    <br><br><h3>   </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">What did devops mean ?</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Introducing gb, a project based build tool for the Go programming language</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">avr11: how to add 256 kilobytes of ram to an Arduino</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Padding is hard</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435292/">https://habr.com/ru/post/id435292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435278/index.html">10 materi tentang alat musik yang tidak biasa dan cara atipikal untuk mengekstraksi suara</a></li>
<li><a href="../id435280/index.html">Apakah pejabat dibutuhkan? Gagasan crowdfunding sosial</a></li>
<li><a href="../id435286/index.html">Bagaimana saya menyelamatkan Mars atau pencarian python kecil</a></li>
<li><a href="../id435288/index.html">Segerombolan satelit sebagai pengganti teleskop besar yang mengorbit</a></li>
<li><a href="../id435290/index.html">Belajar Bahasa Inggris - Sebuah Opini Tidak Populer</a></li>
<li><a href="../id435294/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 346 (1 - 6 Januari 2019)</a></li>
<li><a href="../id435296/index.html">Hall of Fame Elektronik Konsumen: Kisah Gadget Terbaik 50 Tahun Terakhir, Bagian 3</a></li>
<li><a href="../id435298/index.html">Google Soli "Radar" Terus Berkembang</a></li>
<li><a href="../id435300/index.html">Visi subyektif dari bahasa pemrograman yang ideal</a></li>
<li><a href="../id435302/index.html">Kami membuat prototipe dengan kode. FrontTalks Kuliah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>