<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘® ğŸ‘¨ğŸ»â€ğŸ’» ğŸ˜¯ Penjelasan paling sederhana tentang bagaimana algoritma enkripsi simetris bekerja hari ini ğŸ¥¢ ğŸ‘¨ğŸ¼â€ğŸ¤ ğŸ‘©ğŸ½â€ğŸ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(Saya menemukan utas di Twitter dengan penjelasan yang sangat keren tentang sandi simetris. Itu ditulis oleh Colm MacCÃ¡rthaigh, salah satu kontributor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penjelasan paling sederhana tentang bagaimana algoritma enkripsi simetris bekerja hari ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443050/"><p>  <em>(Saya menemukan utas di Twitter dengan penjelasan yang sangat keren tentang sandi simetris. Itu ditulis oleh Colm MacCÃ¡rthaigh, salah satu kontributor utama Apache. Saya meminta izin kepada Colm untuk menerjemahkan, dia setuju).</em> </p><br><p>  Saya akan menjelaskan kepada Anda dalam bahasa sederhana apa yang terjadi ketika data dienkripsi.  Saya berharap bahwa tanpa mistisisme dan hal-hal kompleks yang ditemukan oleh cryptographers. </p><br><p>  Jadi, enkripsi simetris adalah persis apa yang kita gunakan dalam kebanyakan kasus ketika kita ingin mengenkripsi banyak data.  Browser Anda mengirim dan menerima data menggunakan enkripsi simetris.  Jika Anda mengenkripsi file atau disk, enkripsi simetris juga berfungsi dalam hal ini.  iMessage, Signal, WhatsApp - semuanya menggunakan enkripsi simetris untuk keamanan korespondensi Anda. </p><br><p> Jika Anda berpikir bahwa ketika mengenkripsi data dicampur sehingga tidak ada yang bisa membacanya tanpa kunci, cara itu benar-benar terjadi. </p><br><p>  Ini adalah contoh sederhana.  Misalkan saya memiliki string Ovaltine dan ingin mengenkripsi itu.  Saya bisa menggunakan rot13 - sandi tua-sekolah Caesar yang sangat sederhana, yang membuat tarian bundar huruf di mana a dan z berpegangan tangan, dan mengganti setiap huruf dengan huruf alfabet lain, yang merupakan 13 karakter dari huruf yang diganti.  Jadi, "O" berubah menjadi "B", dan "v" menjadi "i", sebagai akibatnya, "Ovaltine" berubah menjadi "Binygvar".  Tentu saja, ini tidak terlalu aman.  Ini adalah contoh naif, yang sangat mudah retak, karena penyerang dapat mengetahui huruf mana yang paling sering ditemukan (biasanya dalam teks asli itu adalah "e") dan menemukan huruf yang tersisa dengan cara yang sama. </p><a name="habracut"></a><br><p>  Sekarang Anda dapat membayangkan bahwa harus ada cara yang lebih sulit untuk "mencampur" surat-surat itu.  Misalnya, beberapa skema rumit di mana "a" masuk ke "p", tetapi ketika dienkripsi ulang, menjadi "f".  Mungkin bahkan terkadang skema ini mulai mengenkripsi "a" dengan dua huruf, misalnya, "jd" atau sesuatu yang lain.  Dengan demikian, skema rumit ini dapat mengenkripsi "Ovaltine" ke dalam string "FGyswDmweeRq" (perhatikan bahwa ia telah menjadi lebih lama).  Algoritma enkripsi muncul di masa lalu yang bekerja dengan cara yang serupa, tetapi itu sama sekali bukan cara kerja enkripsi modern. </p><br><p>  Alih-alih huruf "menyeret", enkripsi modern mengambil string rahasia Anda dan menggabungkannya dengan data acak.  Ini mirip dengan rot13 hanya dalam dua aspek: enkripsi dan dekripsi pada dasarnya operasi yang sama, dan semuanya terjadi "di tempat".  Memang, pernahkah Anda memperhatikan bahwa rot13 merupakan algoritma enkripsi dan dekripsi?  rot13 (Ovaltine) -&gt; Binygvar, rot13 (Binygvar) -&gt; Ovaltine.  Saya percaya bahwa ini adalah simetri yang sangat indah dalam enkripsi simetris.  Tapi kembali ke topik kita.  Caranya adalah kita menggunakan operasi XOR bitwise.  Dalam kriptografi, logika formal, dan kode, program XOR dapat didefinisikan secara berbeda, tetapi saya akan menggunakan notasi yang kemungkinan besar Anda kenal.  Ini terlihat seperti ini: ^. </p><br><p>  XOR singkatan dari "eksklusif ATAU".  Ini adalah operator (atau fungsi, jika Anda mau), yang mengambil dua argumen dan mengembalikan hasilnya.  A ^ B = C. Operator ini disebut "bitwise" karena berlaku untuk bit yang sesuai satu sama lain.  Jika A dan B adalah byte, maka kita dapat mengasumsikan bahwa A ^ B = C pada dasarnya adalah 8 operasi berbeda yang terjadi secara bersamaan.  ^ membandingkan bit pertama A dan bit pertama B, dan kemudian menempatkan hasilnya di bit pertama C. Ia mengulangi yang sama 7 kali lebih banyak untuk bit yang tersisa.  Aturannya sederhana: jika bit dari A adalah "1" ATAU bit dari B adalah "1", maka kita mengatur bit yang sesuai C ke "1", tetapi hanya jika "A" dan "B" bukan "1" pada saat yang sama.  Ini adalah bagian eksklusif.  Berikut adalah tabel kebenaran sekolah tua: </p><br><pre><code class="plaintext hljs">A|B|C 0|0|0 1|0|1 0|1|1 1|1|0</code> </pre> <br><p>  Hal paling keren tentang XOR adalah tampilannya seperti rot13.  Kita dapat menggunakannya untuk enkripsi dan dekripsi.  Saya akan menunjukkan ini dengan contoh sederhana.  Mari kita bayangkan bahwa kita ingin mengenkripsi angka "3" yang biasa dan kunci enkripsi kita adalah angka lain "7".  Jadi 3 ^ 7 = 4. Artinya, hasil enkripsi adalah "4".  Sekarang mari kita menguraikan nomornya.  Saya hanya akan melakukan hal yang sama lagi: 4 ^ 7 = 3. Ambil nomor apa pun yang Anda suka atau data apa pun, dan itu akan selalu berfungsi - XOR akan selalu dapat mendekripsi dirinya. </p><br><p>  Sedikit demi sedikit - ini adalah bagaimana kita benar-benar mengenkripsi dan mendekripsi data, tidak ada pencampuran, hanya XOR-ing.  Bagian yang sulit adalah menemukan data yang dapat kita terapkan XOR.  Satu pendekatan adalah mengambil sejumlah besar data rahasia dan menggunakannya sebagai argumen kedua untuk XOR.  Dalam hal ini, semua peserta dalam proses transmisi data terenkripsi harus menggunakan set data rahasia yang sama untuk enkripsi dan dekripsi.  Dan itu akan berhasil.  Benar, ada beberapa masalah. </p><br><p>  Masalah pertama.  Data rahasia seharusnya tampak acak.  Anda tidak dapat mengambil teks dari buku atau semacamnya.  Pola apa pun akan muncul dalam data terenkripsi.  Inilah yang membuat pasukan sekutu unggul dalam Perang Dunia II. </p><br><p>  Masalah kedua.  Anda tidak dapat menggunakan kembali data sensitif, karena pola akan muncul kembali.  Dengan demikian, Anda entah bagaimana harus memberikan potongan besar data rahasia untuk semua orang yang membutuhkannya, seperti papan sekali pakai.  Ini terlalu sulit. </p><br><p>  Dalam enkripsi modern, kita "menghasilkan" data rahasia yang kita butuhkan dari kunci kecil.  Kunci-kunci ini lebih mudah dibawa dan dilindungi.  Inilah yang sebenarnya merupakan algoritma enkripsi simetris - skema untuk generasi deterministik data acak dari suatu kunci.  Bagian tentang "determinisme" sangat penting: dua orang dengan kunci yang sama harus benar-benar menghasilkan set data yang sama, jika tidak mereka tidak akan dapat saling memahami.  Anda mungkin pernah mendengar tentang algoritme tersebut: AES, 3DES, DES, RC4, ChaCha20.  Mereka semua melakukannya. </p><br><p>  Ternyata masalah matematika menghasilkan aliran data acak (di mana tidak ada pola dalam bentuk yang dapat diprediksi) menggunakan kunci sangat sulit.  Dari daftar ini, hanya AES dan ChaCha20 yang dianggap aman hari ini.  Algoritme lain diretas: orang dapat memperkirakannya.  Selain itu, AES memiliki reputasi yang sedikit ternoda, karena cryptographers mengatakan yang berikut: </p><br><blockquote>  AES adalah algoritma enkripsi utama dan paling dianalisis.  Standar Benar-Benar Emas!  : dark_sunglasses: </blockquote><p>  Tetapi pada saat yang sama mereka menambahkan: </p><br><blockquote>  Implementasi AES dalam perangkat lunak (bukan dalam perangkat keras) tidak aman atau lambat, dan terkadang tidak aman, dan lambat.  Itu tidak dirancang mempertimbangkan fakta bahwa itu bisa diretas menggunakan analisis cache.  : facepalm: </blockquote><p>  Jangan terlalu takut jika ini tidak jelas bagi Anda.  Gagasan utamanya adalah ini: AES cantik dari sudut pandang matematika, tetapi sangat rumit dalam implementasi perangkat lunak.  Tetapi jangan khawatir - kami hampir selalu memiliki dukungan AES di tingkat perangkat keras (daftar semua prosesor dengan dukungan perangkat keras AES dapat ditemukan di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/AES_instruction_set</a> , - catatan penerjemah). </p><br><p>  Meskipun begitu, kami melanjutkan ... Bagaimana algoritma ini bekerja?  Bagaimana kita bisa mengambil kunci dan dengan aman menghasilkan aliran data acak?  Saya akan menyederhanakan sedikit di sini dan mulai dengan blok. </p><br><p>  Algoritma ini menerima tiga parameter pada input dan memberikan ciphertext pada output.  Parameter input - kunci, teks terenkripsi dan ... kejutan - sesuatu yang aneh yang disebut "vektor inisialisasi" (vektor inisialisasi, IV). </p><br><pre> <code class="plaintext hljs">AES(key, IV, plaintext) -&gt; encrypted_data.</code> </pre> <br><p>  Kunci dan IV digabungkan satu sama lain untuk membuat satu set "kondisi awal" untuk algoritma;  ini mirip dengan pertukaran awal atau pengacakan ubin dalam game Scrabble.  Kombinasi kunci dan IV yang sama akan selalu membuat kondisi awal yang sama.  Anda bertanya, mengapa kita bahkan membutuhkan IV?  Kami membutuhkan infus sehingga kami dapat mengenkripsi beberapa pesan menggunakan kunci yang sama.  Tanpa IV, setiap aliran data yang dihasilkan akan sama, dan ini buruk.  Ini akan melanggar salah satu aturan yang kita bicarakan sebelumnya: kita tidak bisa menggunakan kembali data yang sama untuk enkripsi.  Jadi kita perlu infus untuk mencampur hasilnya.  Tetapi tidak seperti kunci IV, itu bisa publik. </p><br><p>  Jadi, ketika Anda mengenkripsi pesan dan mengirimkannya ke seseorang, Anda juga dapat menambahkan: "Hei, ini IV yang saya gunakan."  Masih penting bahwa kami tidak menggunakan kembali kombinasi kunci dan IV, karena mereka akan memberi kami data acak berulang.  Ada dua cara untuk mencapai kondisi ini: 1) IV adalah jenis penghitung yang kami tingkatkan dengan setiap pesan baru.  2) IV dihasilkan secara acak, sementara itu memiliki nilai yang cukup besar, jadi kita tidak perlu terlalu khawatir tentang tabrakan.  Bagaimanapun, saya menyebutkan bahwa saya akan berbicara tentang blok. </p><br><p>  Kunci dan IV adalah "campuran" atau digabungkan sedemikian rupa untuk membuat satu set kondisi awal ... kondisi ini sebenarnya adalah "blok" awal data acak.  Panjang blok ini adalah 128 bit untuk AES128, 256 bit untuk AES256, dan 512 bit untuk ChaCha20.  Dan di sini keajaiban nyata dan individualitas dari algoritma enkripsi tertentu dimanifestasikan.  Bahkan, esensi mereka terletak pada bagaimana urutan blok dihasilkan dan bagaimana setiap blok dikaitkan dengan tetangganya.  Hubungan antara blok-blok ini tetap dapat diprediksi bahkan bagi mereka yang tidak memiliki kunci. </p><br><p>  Saya tidak akan masuk jauh ke dalam bagaimana algoritma ini bekerja, tetapi jika Anda ingin tahu lebih banyak, saya menyarankan Anda untuk mulai menjelajahi topik ini dengan generator linear congruential (LCG).  LCG adalah fungsi yang membuat blok data "melingkar" secara acak dan tidak berulang.  Kemudian lihat jaringan Feistel, level pengembangan LCG berikutnya.  Kemudian berurusan dengan S-Boxes, dan kemudian lihat bagaimana Salsa20 menciptakan interlacing dalam algoritma ChaCha20.  Semua ini jauh lebih terjangkau daripada yang mungkin Anda pikirkan! </p><br><p>  Jadi, kita sekarang tahu bagaimana aliran data acak dapat dikombinasikan dengan teks untuk mengenkripsi dan mendekripsi, dan kita sudah sedikit dalam subjek tentang bagaimana aliran data acak ini dibuat.  Bukankah itu yang kita butuhkan?  Untuk enkripsi disk, itu hampir semuanya.  Kami dapat mengenkripsi setiap blok atau sektor penyimpanan menggunakan satu kunci dan IV, yang dapat diperoleh dari "posisi" pada disk.  Dengan demikian, kita selalu dapat mendekripsi blok data apa saja di mana saja pada disk, selama kita memiliki kuncinya.  Tetapi ada satu masalah ... seseorang dapat merusak data terenkripsi kami.  Jika saya mengubah nilai byte apa pun, bahkan jika saya tidak memiliki kunci, maka pada akhirnya kita tidak akan dapat mendekripsi blok.  Dan tidak ada perlindungan terhadap gangguan semacam ini.  Dalam hal pengiriman pesan dan data melalui jaringan, ini menjadi lebih kritis.  Kami tidak ingin siapa pun merusak data yang kami kirim.  Jadi kita perlu menambahkan pemeriksaan integritas!  Ada beberapa skema untuk melakukan ini. </p><br><p>  HMAC, GCM, dan Poly1305 adalah skema pemeriksaan integritas modern paling umum.  Algoritma ini pada dasarnya bekerja seperti ini: mereka disediakan dengan data dan kunci lain (disebut kunci integritas).  Setelah perhitungan, mereka memberikan MAC (kode otentikasi pesan) atau tag, yang pada gilirannya hanyalah sepotong data yang bertindak sebagai tanda tangan. </p><br><p>  Jadi, untuk enkripsi dan perlindungan, skema kami mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">AES(key, IV, "Ovaltine") -&gt; encrypted_output HMAC(key, encrypted_output) -&gt; MAC</code> </pre> <br><p>  dan kemudian dengan kawat kami kirim: </p><br><pre> <code class="plaintext hljs">IV | encrypted_output | MAC</code> </pre> <br><p>  Untuk dekripsi, kami memeriksa MAC, menghasilkannya lagi dan membandingkan hasilnya dengan MAC yang diterima, dan kemudian mendekripsi datanya.  Ada perbedaan internal dalam cara HMAC, GCM, dan Poly1305 menghasilkan tanda tangan ini, tetapi Anda tidak perlu khawatir tentang itu.  Sampai saat ini, kombinasi operasi ini biasanya dibungkus dengan fungsi yang disebut "AEAD" (Enkripsi terotentikasi dengan Data Tambahan).  Di bawah tenda, dia melakukan semua yang saya bicarakan sebelumnya: </p><br><pre> <code class="plaintext hljs">AEAD(key, IV, plaintext, additional_data) -&gt; IV_encrypted_data_MAC</code> </pre> <br><p>  Sepotong yang disebut "additional_data" hanyalah data yang dengannya Anda dapat memastikan bahwa pihak pengirim memiliki data ini, meskipun tidak dikirim kepada mereka.  Ini seperti meta-data yang menetapkan hak akses.  Seringkali bidang ini dibiarkan kosong. </p><br><p>  Namun demikian, Anda dapat memiliki masalah dengan AEAD jika Anda menggunakan IV yang sama.  Ini buruk!  Ada upaya untuk memperbaiki situasi ini: kolega saya, yang bernama Shay, sedang mengerjakan skema SIV yang keren yang menambahkan lapisan perlindungan terhadap masalah ini.  Tetapi jika Anda menggunakan IV yang unik, enkripsi modern sangat aman.  Artinya, Anda bisa menerbitkan ciphertext di New York Times, dan tidak ada yang bisa memecahkannya.  Cipher akan tetap tidak dapat diakses bahkan jika "beberapa" bagian dari teks diketahui.  Misalnya, dalam protokol Internet sejumlah besar teks diketahui.  Server HTTP selalu merespons hal yang sama dan byte pertama selalu diketahui.  Tetapi fakta ini tidak masalah sama sekali - itu tidak akan membantu penyerang untuk menemukan satu bagian dari data yang tersisa ... Kami telah menempuh perjalanan panjang sejak Perang Dunia Kedua. </p><br><p>  Tetapi ada serangan yang berhasil!  Jika Anda mengirim data melalui jaringan dan seseorang melacak waktu dan ukuran pesan, maka data terenkripsi dapat dipecahkan menggunakan analisis lalu lintas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0f3/159/f21/0f3159f21f88bfaa15fb4e2b7399792c.gif" alt="gambar"></p><br><p>  Mari kita cari tahu panjangnya terlebih dahulu.  Jelas, panjang bukanlah karakteristik yang tersembunyi.  Dan ini normal jika Anda mencoba melindungi kata sandi atau nomor kartu kredit di suatu tempat di tengah pesan.  Bukan masalah besar.  Tetapi ini berarti bahwa siapa pun yang berpotensi dapat menentukan jenis konten yang Anda kirimkan.  Contoh sederhana: jika Anda mengirim gif menggunakan messenger dan jika ukuran gambar ini unik, penyerang mencegat data Anda mungkin menyarankan GIF mana yang baru saja dikirim.  Ada versi yang lebih rumit dari serangan ini untuk Google Maps, Netflix, Wikipedia, dll.  Untuk melindungi dari serangan ini, Anda dapat "menyelesaikan" pesan yang dikirim dengan byte tambahan, sehingga semua pesan yang dikirim memiliki panjang yang sama, apa pun yang terjadi.  Enkripsi yang digunakan dalam jaringan militer selalu "menyelesaikan" lalu lintas dengan data tambahan, yaitu, untuk pencegat selalu terlihat sama!  Masalah lain dengan panjangnya adalah bahwa jika Anda menggunakan kompresi dan memberi penyerang kemampuan untuk mengubah bagian mana pun dari konten pada halaman yang dilihat pengguna, ini memungkinkan penyerang untuk mengetahui bahkan rahasia terkecil sekalipun.  Cari serangan yang disebut CRIME.  Dia cantik dan menakutkan. </p><br><p>  Saya juga mengatakan bahwa masalah lainnya adalah waktu.  Jelas, waktu pengiriman setiap pesan adalah informasi terbuka.  Mungkinkah ini menjadi masalah?  Mungkin  Misalnya, jika Anda mengirim pesan setiap kali Anda menekan tombol, maka itu sepele untuk mengetahui apa yang sebenarnya dicetak menggunakan analisis waktu.  Keren!  Contoh lain adalah VOIP.  Jika aplikasi panggilan Anda mengirim data hanya ketika orang berbicara, tetapi tidak selama keheningan, ini sudah cukup untuk mengembalikan 70% pidato bahasa Inggris.  Hanya karena keheningan.  Keren menakutkan. </p><br><p>  Contoh-contoh ini hanyalah puncak gunung es.  Bahkan ketika Anda menggunakan algoritma dan skema enkripsi yang telah membaik selama 80 tahun, masih ada celah yang dapat digunakan untuk memecahkan keamanan.  Itulah mengapa sangat berharga untuk mengetahuinya! </p><br><p>  Bagaimanapun, ini adalah tingkat penjelasan yang ingin saya bahas sekarang, tetapi kami telah mempertimbangkan hal-hal yang paling perlu untuk diketahui.  Jika Anda membaca sampai titik ini - terima kasih!  Anda sekarang harus memiliki pemahaman yang lebih besar tentang apa yang terjadi selama enkripsi dan apa yang harus diperhatikan. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jangan ragu untuk bertanya.</a> </p><br><p>  <em>Terjemahan diterbitkan di bawah Lisensi CC BY-NC-SA 4.0</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443050/">https://habr.com/ru/post/id443050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443034/index.html">Stasiun Pengisian Tesla Baru: Isi Daya Baterai untuk 120 Kilometer dalam 5 Menit</a></li>
<li><a href="../id443038/index.html">Jika superglue masuk ke mata</a></li>
<li><a href="../id443040/index.html">7 alasan utama mengapa aplikasi diblokir di Google Play dan AppStore</a></li>
<li><a href="../id443042/index.html">Peluncuran 619 ribu tetris di GLSL, rendering dan bot sederhana</a></li>
<li><a href="../id443046/index.html">Bagaimana Peneliti Keamanan Mengakses Situs yang Dilindungi Kode iOS</a></li>
<li><a href="../id443052/index.html">Jam tangan akurat dan cantik dari smartphone lama</a></li>
<li><a href="../id443054/index.html">Pilihan utilitas untuk programmer di Linux</a></li>
<li><a href="../id443056/index.html">Pasien HIV kedua mencapai remisi</a></li>
<li><a href="../id443058/index.html">Arsitektur bersih. Bagian I - Pendahuluan</a></li>
<li><a href="../id443060/index.html">Akankah Starship mencapai Mars?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>