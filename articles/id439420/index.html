<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚤 ⛺️ 💈 Membangun paket transportasi tanpa menginstal MODX 🧑🏾‍🤝‍🧑🏽 ✒️ 👨🏽‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menulis paket Anda untuk MODX tidak mudah bagi pemula, dan pengembang yang berpengalaman terkadang memiliki waktu yang menyenangkan. Tetapi pemula tak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun paket transportasi tanpa menginstal MODX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439420/"><img src="https://habrastorage.org/webt/jv/hq/2n/jvhq2nbsj0ti2v8v_ucoyk_bwam.jpeg"><br><br>  Menulis paket Anda untuk MODX tidak mudah bagi pemula, dan pengembang yang berpengalaman terkadang memiliki waktu yang menyenangkan.  Tetapi pemula takut, dan yang berpengalaman mengerti :). <br><br>  Posting ini berbicara tentang bagaimana Anda dapat menulis dan membangun paket komponen untuk MODX tanpa menginstal dan mengkonfigurasi MODX itu sendiri.  Levelnya di atas rata-rata, jadi Anda mungkin harus memeras otak Anda dalam beberapa kasus, tetapi itu sepadan. <br><br>  Saya meminta detail di bawah kucing. <br><a name="habracut"></a><br>  Suatu ketika, ketika MODX Revolution baru saja muncul, itu dalam versi beta awal, para pengembang belum tahu bagaimana bekerja dengannya dan bagaimana menulis plugin untuk itu.  Ya, kecuali tim yang meneliti CMS.  Dan tim, saya harus mengatakan, sebagian berhasil dan menyediakan sistem dengan kemampuan untuk dengan mudah mengumpulkan paket yang kemudian dapat diinstal melalui repositori, yang tampaknya logis.  Namun sejak itu, bertahun-tahun telah berlalu dan persyaratan untuk paket dan perakitannya telah sedikit berubah. <br><br><h2>  Copy-paste itu jahat, meski tidak selalu </h2><br>  Selama beberapa bulan terakhir, saya dihantui oleh pemikiran mengapa, untuk membangun paket untuk MODX, Anda harus menginstalnya, membuat database, membuat admin, dll.  Begitu banyak aksi ekstra.  Tidak, tidak ada yang salah dengan ini jika Anda mengaturnya sekali dan kemudian menggunakannya.  Banyak yang melakukannya.  Tetapi bagaimana ketika Anda ingin mempercayakan naskah kepada skrip, dan pergi dan minum kopi sendiri? <br><br>  Kebetulan bahwa pencipta MODX digunakan untuk bekerja dengan MODX itu sendiri dan menambahkan kelas ke paket langsung ke kernel.  Mereka juga menulis komponen pertama, skrip build pertama, yang kemudian digunakan sebagai contoh oleh pengembang lain yang hanya menyalin solusi, tidak selalu menggali esensi dari apa yang terjadi.  Dan saya berhasil. <br><br>  Tetapi tugasnya adalah untuk mengotomatiskan perakitan paket, lebih disukai di server, selalu dengan perangkat lunak minimum yang diperlukan, dengan sumber daya minimal dan karenanya dengan kecepatan yang lebih besar.  Tugasnya sudah diatur dan setelah mempelajari sumbernya, Jason yang mengerem dalam obrolan menemukan solusinya. <br><br><h2>  Dan yang mana? </h2><br>  Hal pertama yang saya temukan adalah bahwa kode yang bertanggung jawab untuk membangun paket secara langsung terletak di pustaka xPDO, dan di MODX hanya ada kelas pembungkus yang menyediakan API yang lebih nyaman dan agak lebih mudah untuk dikerjakan, tetapi hanya jika MODX diinstal.  Oleh karena itu, mungkin hanya xPDO yang dapat digunakan, tetapi dalam kode, konstruktor objek xPDO mengharuskan Anda menentukan data untuk koneksi database. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $dsn, $username = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $password = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $options = [], $driverOptions= null )</span></span></span></span>;</code> </pre> <br>  Setelah menginterogasi Jason, menjadi jelas bahwa meskipun parameter perlu diatur, koneksi fisik nyata ke database terjadi tepat pada saat diperlukan.  Malas memuat semua kemuliaan.  Masalah kedua telah diatasi. <br><br>  Masalah ketiga adalah masalah menghubungkan xPDO ke proyek.  Composer segera muncul di pikiran, tetapi versi 2.x yang dijalankan oleh MODX saat ini tidak mendukung Composer, dan cabang 3.x menggunakan ruang nama dan nama kelas ditulis berbeda dari 2.x, yang mengarah pada konflik dan kesalahan.  Secara umum, tidak kompatibel.  Kemudian saya harus menggunakan alat git dan menghubungkan xPDO sebagai submodule. <br><blockquote><h4>  Cara menggunakan submodula </h4><br><br>  Pertama, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasinya</a> . <br><br>  Kemudian, jika ini adalah proyek baru, Anda perlu menambahkan submodule: <br><br><pre> <code class="plaintext hljs">$ git submodule add https://github.com/username/reponame</code> </pre> <br>  Perintah ini akan mengkloning dan menginstal submodule di proyek Anda.  Maka Anda perlu menambahkan folder submodule ke repositori Anda dengan perintah git add.  Itu tidak akan menambahkan seluruh folder dengan submodule, tetapi akan menambah hanya git tautan ke komit terakhir dari submodule. <br><br>  Agar pengembang lain dapat mengkloning proyek dengan semua dependensi, Anda perlu membuat konfigurasi .gitmodules untuk submodula.  Dalam proyek Slackify, seperti ini: <br><br><pre> <code class="plaintext hljs">[submodule "_build/xpdo"] path = _build/xpdo url = https://github.com/modxcms/xpdo.git branch = 2.x</code> </pre><br>  Setelah itu, saat kloning, cukup tentukan flag rekursif dan git akan mengunduh semua repositori dependen. </blockquote>  Akibatnya, kita memiliki xPDO, xPDO dapat digunakan tanpa terhubung ke database, jika tidak diperlukan, xPDO dapat dihubungkan ke kode komponen sebagai ketergantungan eksternal (git submodule).  Sekarang implementasi skrip build. <br><br><h2>  Mari kita mengerti </h2><br>  Saya akan menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skrip build dari</a> add <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Slackify -pada</a> baru-baru ini diposting oleh saya.  Komponen ini gratis dan tersedia untuk umum di GitHub, yang akan memfasilitasi belajar mandiri. <br><br><h3>  Hubungkan xPDO </h3><br>  Kami menghilangkan tugas konstanta dengan nama paket dan panggilan lain yang diperlukan dan menghubungkan xPDO. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/xpdo.class.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/transport/xpdotransport.class.php'</span></span>; $xpdo = xPDO::getInstance(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, [ xPDO::OPT_CACHE_PATH =&gt; <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/../cache/'</span></span>, xPDO::OPT_HYDRATE_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_ADHOC_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_CONNECTIONS =&gt; [ [ <span class="hljs-string"><span class="hljs-string">'dsn'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'mysql:host=localhost;dbname=xpdotest;charset=utf8'</span></span>, <span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'options'</span></span> =&gt; [xPDO::OPT_CONN_MUTABLE =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>], <span class="hljs-string"><span class="hljs-string">'driverOptions'</span></span> =&gt; [], ] ] ]);</code> </pre> <br>  Saya menambahkan submodule xPDO ke folder _build, yang kita perlukan hanya pada tahap pengembangan dan perakitan paket dan yang tidak akan masuk ke arsip utama komponen.  Salinan kedua xPDO di situs dengan MODX langsung yang tidak kita butuhkan. <br><br>  Dalam pengaturan koneksi xPDO, saya mengatur nama database di <code>dsn</code> , tetapi tidak memainkan peran apa pun.  Adalah penting bahwa folder cache di dalam xPDO dapat ditulis.  Itu saja, xPDO diinisialisasi. <br><br><h3>  Membuat hack yang rumit dengan kelas-kelas </h3><br>  Saat menggunakan MODX yang terinstal saat membuat paket, semuanya sederhana, kami mengambil dan membuat objek dari kelas yang kami butuhkan.  MODX benar-benar menemukan kelas yang diperlukan, menemukan implementasi yang diperlukan untuk kelas ini (kelas dengan postfix _mysql), yang tergantung pada database dan kemudian membuat objek yang diinginkan (karena fitur ini, Anda mungkin mendapatkan kesalahan ketika membangun paket yang kelasnya * _mysql tidak ditemukan, ini tidak menakutkan).  Namun, kami tidak memiliki basis atau implementasi.  Kita perlu entah bagaimana mengganti kelas yang diinginkan, yang sedang kita lakukan. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modNamespace</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modSystemSetting</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Kami membuat kelas dummy (rintisan), yang diperlukan untuk membuat objek yang diinginkan.  Ini tidak harus dilakukan jika xPDO tidak secara khusus memeriksa kelas objek yang dimiliki.  Tapi dia memeriksa. <br><br>  Tetapi ada beberapa kasus khusus ketika Anda perlu melakukan sedikit lebih dari sekedar mendefinisikan kelas.  Ini adalah kasus ketergantungan antar kelas.  Misalnya, kita perlu menambahkan plugin ke kategori.  Dalam kode, hanya <code>$category-&gt;addOne($plugin);</code>  tetapi dalam kasus kami ini tidak akan berhasil. <br><br>  Jika Anda pernah melihat <a href="">skema database MODX</a> , Anda mungkin melihat elemen seperti agregat dan komposit.  Itu ditulis tentang mereka dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , tetapi jika dengan cara yang sederhana, mereka menggambarkan hubungan antar kelas. <br><br>  Dalam kasus kami, mungkin ada beberapa plugin dalam suatu kategori, di mana elemen agregat bertanggung jawab atas kelas <code>modCategory</code> .  Oleh karena itu, karena kita memiliki kelas tanpa implementasi konkret, kita perlu menunjukkan koneksi ini dengan tangan.  Lebih mudah untuk melakukan ini dengan <code>getFKDefinition</code> metode <code>getFKDefinition</code> : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modCategory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFKDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($alias)</span></span></span><span class="hljs-function"> </span></span>{ $aggregates = [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modPlugin'</span></span>, <span class="hljs-string"><span class="hljs-string">'local'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'foreign'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, <span class="hljs-string"><span class="hljs-string">'cardinality'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'many'</span></span>, <span class="hljs-string"><span class="hljs-string">'owner'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'local'</span></span>, ] ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($aggregates[$alias]) ? $aggregates[$alias] : []; } }</code> </pre> <br>  Di komponen kami, hanya plugin yang digunakan, jadi kami menambahkan tautan hanya untuk mereka.  Setelah itu, metode addMany dari kelas modCategory dapat dengan mudah menambahkan plugin yang diperlukan ke kategori, dan kemudian ke paket. <br><br><h3>  Buat paket </h3><br><pre> <code class="php hljs">$package = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> xPDOTransport($xpdo, $signature, $directory);</code> </pre> <br>  Seperti yang Anda lihat, semuanya sangat, sangat sederhana.  Di sini kami perlu melewati parameter <code>$xpdo</code> , yang kami inisialisasi di awal.  Jika tidak untuk saat ini, tidak akan ada masalah 2.  <code>$signature</code> - nama paket, termasuk versi, <code>$directory</code> - tempat paket akan ditempatkan dengan hati-hati.  Dari mana variabel-variabel ini berasal, lihat sendiri di sumbernya. <br><br><h3>  Buat namespace dan tambahkan ke paket </h3><br>  Kami membutuhkan namespace untuk mengikat lexicons dan pengaturan sistem untuk itu.  Dalam kasus kami, hanya untuk ini, yang lain belum dipertimbangkan. <br><br><pre> <code class="php hljs">$namespace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> modNamespace($xpdo); $namespace-&gt;fromArray([ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{core_path}components/'</span></span> . PKG_NAME_LOWER . <span class="hljs-string"><span class="hljs-string">'/'</span></span>, ]); $package-&gt;put($namespace, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_FILES =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_PHP =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::NATIVE_KEY =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'namespace'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ]);</code> </pre> <br>  Bagian pertama jelas bagi siapa saja yang pernah menulis kode untuk MODX.  Yang kedua, dengan tambahan paket, sedikit lebih rumit.  Metode <code>put</code> mengambil 2 parameter: objek itu sendiri dan berbagai parameter yang menggambarkan objek ini dan perilaku yang mungkin terjadi pada saat menginstal paket.  Sebagai contoh, <code>xPDOTransport::UNIQUE_KEY =&gt; 'name'</code> berarti bahwa untuk namespace, bidang <code>name</code> dengan nama namespace itu sendiri sebagai suatu nilai akan digunakan sebagai kunci unik dalam database.  Anda dapat membaca lebih lanjut tentang parameter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi xPDO</a> , dan lebih baik dengan mempelajari kode sumber. <br><br>  Dengan cara yang sama, Anda dapat menambahkan objek lain, seperti pengaturan sistem. <br><br><pre> <code class="php hljs">$package-&gt;put($setting, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'key'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modSystemSetting'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, ]);</code> </pre> <br><h3>  Buat kategori </h3><br>  Dengan tambahan kategori, saya memiliki lelucon terbesar ketika saya menemukan jawabannya.  Elemen-elemen yang dimasukkan ke dalam kategori dalam model xPDO harus keduanya termasuk dalam kategori ini, mis.  bersarang di dalamnya, dan hanya kemudian kategori itu sendiri harus disarangkan dalam paket.  Dan pada saat yang sama, Anda perlu memperhitungkan hubungan antar kelas, yang telah saya jelaskan di atas.  Butuh waktu yang cukup lama untuk memahami, menyadari, dan menerapkannya dengan benar. <br><br><pre> <code class="php hljs">$package-&gt;put($category, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::ABORT_INSTALL_ON_VEHICLE_FAIL =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ], <span class="hljs-string"><span class="hljs-string">'PluginEvents'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; [<span class="hljs-string"><span class="hljs-string">'pluginid'</span></span>, <span class="hljs-string"><span class="hljs-string">'event'</span></span>], xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ] ], xPDOTransport::NATIVE_KEY =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; $validators, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; $resolvers ]);</code> </pre> <br>  Itu terlihat mengerikan, tetapi tidak begitu terlihat.  Parameter penting adalah <code>xPDOTransport::RELATED_OBJECTS =&gt; true</code> , yang menunjukkan bahwa kategori tersebut memiliki elemen bersarang yang juga perlu dikemas dan kemudian diinstal. <br><br>  Karena sebagian besar modul berisi berbagai elemen (bongkahan, cuplikan, plugins), kategori dengan elemen adalah bagian terpenting dari paket transportasi.  Oleh karena itu, di sini validator dan resolver ditentukan, yang dilakukan selama instalasi paket. <br><blockquote>  Validator dilakukan sebelum instalasi, resolvers - after. </blockquote><br>  Saya hampir lupa, sebelum mengemas kategori, kita perlu menambahkan elemen kita ke dalamnya.  Seperti ini: <br><br><pre> <code class="php hljs">$plugins = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $sources[<span class="hljs-string"><span class="hljs-string">'data'</span></span>] . <span class="hljs-string"><span class="hljs-string">'transport.plugins.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($plugins)) { $category-&gt;addMany($plugins, <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span>); }</code> </pre> <br><h3>  Tambahkan data lain ke paket. </h3><br>  Dalam paket Anda perlu menambahkan file lain dengan lisensi, file dengan log perubahan dan file dengan deskripsi komponen.  Jika perlu, Anda dapat menambahkan skrip khusus lain melalui atribut <code>setup-options</code> , yang akan menampilkan jendela sebelum menginstal paket.  Ini adalah saat alih-alih "Instal" tombol "Opsi Instalasi".  Dan dari versi MODX 2.4 menjadi mungkin untuk menentukan dependensi antara paket menggunakan atribut yang <code>requires</code> , dan di dalamnya Anda juga dapat menentukan versi PHP dan MODX. <br><br><pre> <code class="php hljs">$package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'changelog'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'changelog.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'license'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'license.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'readme'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'readme.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'requires'</span></span>, [<span class="hljs-string"><span class="hljs-string">'php'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&gt;=5.4'</span></span>]); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'setup-options'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source'</span></span> =&gt; $sources[<span class="hljs-string"><span class="hljs-string">'build'</span></span>] . <span class="hljs-string"><span class="hljs-string">'setup.options.php'</span></span>]);</code> </pre> <br><h3>  Kami berkemas </h3><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($package-&gt;pack()) { $xpdo-&gt;log(xPDO::LOG_LEVEL_INFO, <span class="hljs-string"><span class="hljs-string">"Package built"</span></span>); }</code> </pre> <br>  Itu saja, ambil paket yang sudah jadi di <code>_packages</code> , well, atau dari mana Anda mengkonfigurasi assembly. <br><br><h2>  Apa hasilnya? </h2><br>  Hasilnya melebihi harapan saya, karena pendekatan ini, meskipun memberlakukan beberapa batasan dan di beberapa tempat menambah beberapa ketidaknyamanan, tetapi menang dalam hal kemungkinan aplikasi. <br><br>  Untuk membangun paket, cukup jalankan 2 perintah: <br><br><pre> <code class="plaintext hljs">git clone --recursive git@github.com:Alroniks/modx-slackify.git cd modx-slackify/_build &amp;&amp; php build.transport.php</code> </pre> <br>  Yang pertama adalah kloning dari repositori dan submodulanya.  Parameter penting adalah <code>--recursive</code> , berkat itu git akan mengunduh dan menginstal, selain kode komponen itu sendiri, semua dependensi digambarkan sebagai submodul. <br><br>  Yang kedua adalah membangun paket secara langsung.  Setelah itu, Anda dapat mengambil <code>package-1.0.0-pl.transport.zip</code> yang sudah <code>_packages</code> folder <code>_packages</code> dan memuatnya, misalnya, ke dalam repositori. <br><br>  Prospeknya luas.  Misalnya, Anda dapat mengonfigurasi kail di GitHub, yang, setelah melakukan ke cabang, akan menjalankan skrip di server Anda yang akan mengumpulkan paket dan meletakkannya di semua situs yang Anda miliki.  Atau unggah versi baru ke beberapa repositori, dan pada saat itu Anda akan membuat kopi untuk diri sendiri, seperti yang saya katakan di awal.  Atau Anda dapat membuat dan menulis tes untuk modul dan menjalankan uji coba dan membangun melalui Jenkins atau Travis.  Ya, banyak skenario yang bisa Anda buat.  Dengan pendekatan ini, melakukan ini sekarang jauh lebih mudah. <br><br>  Ajukan pertanyaan, coba jawab. <br><br>  PS Jangan lewat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">letakkan bintang Slackify di GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439420/">https://habr.com/ru/post/id439420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439408/index.html">Pseudo Lens Flare</a></li>
<li><a href="../id439410/index.html">Jeff Hawkins akhirnya siap menjelaskan penelitian otaknya</a></li>
<li><a href="../id439414/index.html">Klien untuk "Server Pesan Push"</a></li>
<li><a href="../id439416/index.html">Artikel Peninjauan A-Frame</a></li>
<li><a href="../id439418/index.html">Integrasi Data Pentaho (PDI), Python dan Deep Learning</a></li>
<li><a href="../id439422/index.html">Apa yang dibutuhkan seorang programmer untuk mengembangkan game dan siapa yang merupakan pengembang game dari seorang programmer?</a></li>
<li><a href="../id439424/index.html">Bagaimana saya berjuang dengan hosting gratis dan Komposer</a></li>
<li><a href="../id439426/index.html">Situasi: gelombang serangan baru dengan intersepsi permintaan DNS - kami menganalisis metode dasar perlindungan</a></li>
<li><a href="../id439428/index.html">Bagaimana mencegah serangan cyber yang ditargetkan? 10 kotak pasir jaringan terbaik</a></li>
<li><a href="../id439430/index.html">Percayalah pada saya jika Anda bisa. Meter air. bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>