<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎 🔒 🛃 Fatalismo en el manejo de errores 🥥 🌙 🤦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prólogo 


 Este artículo es una reacción al artículo: ¿Qué pasará con el manejo de errores en C ++ 2a ? Después de cada párrafo, me picaba, las herid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fatalismo en el manejo de errores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426971/"><h2 id="predislovie">  Prólogo </h2><br><p>  Este artículo es una reacción al artículo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué pasará con el manejo de errores en C ++ 2a</a> ?  Después de cada párrafo, me picaba, las heridas curadas se abrieron y comencé a sangrar.  Tal vez llevo lo que está escrito demasiado cerca de mi corazón.  Pero solo quiero aullar sobre la miopía y el analfabetismo que los programadores de C ++ muestran en el siglo XXI.  Y ni siquiera al principio. </p><br><p>  Empecemos </p><br><h2 id="klassifikaciya">  Clasificación </h2><br><blockquote>  Convencionalmente, todas las situaciones erróneas en el programa se pueden dividir en 2 grandes grupos: <br><ol><li>  Errores fatales. </li><li>  No son fatales ni se esperan errores. </li></ol><br></blockquote><a name="habracut"></a><br><p> Ahora encontraré la culpa.  Pero errores fatales: también son, en cierto sentido, esperados.  Esperamos que el viaje de memoria a menudo conduzca a una caída, pero puede que no conduzca a ella.  Y esto se espera, ¿no?  Cuando se introduce una clasificación, siempre será posible verificar su coherencia. </p><br><p>  Pero esto es así, un error sutil frecuente. </p><br><p>  Veamos los errores fatales. </p><br><p>  <strong>División por 0</strong> .  Me pregunto por qué este error es fatal?  Me encantaría lanzar una excepción en este caso y atraparla para su posterior procesamiento.  ¿Por qué es ella fatal?  ¿Por qué me impone un cierto comportamiento de mi propio programa y no puedo influirlo de ninguna manera?  ¿C ++ no se trata de flexibilidad y del hecho de que el lenguaje se dirige hacia el programador?  Aunque ... </p><br><p> <strong>Puntero nulo desreferenciación</strong> .  Inmediatamente recuerdo Java, hay una <code>NullPointerException</code> que se puede manejar.  ¡También hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>NullPointerException</code></a> biblioteca de Poco!  Entonces, ¿por qué los desarrolladores estándar con la tenacidad del sordomudo repiten el mismo mantra? </p><br><p>  En general, ¿por qué comencé este tema?  Es muy importante y solo revela la comprensión del desarrollador sobre el manejo de errores.  No se trata del manejo de errores per se, es el preludio de una acción importante.  Siempre se trata de la confiabilidad de la aplicación, de la tolerancia a fallas y, a veces, en los tipos de programas más raros y en peligro, incluso diría, en peligro, del comportamiento transaccional y consistente. </p><br><p>  En este aspecto, todas las disputas sobre dividir entre cero y desreferenciar los punteros parecen una lucha de pájaros por una miga de pan.  Ciertamente un proceso importante.  Pero solo desde el punto de vista de las aves. </p><br><p>  Volvamos a la división en fatalismo y su ausencia ... Comenzaré con una simple pregunta: si recibí datos incorrectos a través de la red, ¿es un error fatal? </p><br><p>  Respuesta simple y correcta: depende de.  Está claro que en la mayoría de los casos esto no es un error fatal, y todos los datos recibidos a través de la red deben ser validados y devueltos 4xx si los datos son incorrectos.  ¿Hay algún caso en el que deba bloquearse?  Y se estrelló con un aullido salvaje, por lo que llegarían SMS, por ejemplo.  Sí, y no uno. </p><br><p>  Hay.  Puedo dar un ejemplo de mi área temática: un algoritmo de consenso distribuido.  Un nodo recibe una respuesta que contiene un hash de una cadena de cambios de otro nodo.  Y este hash es diferente del local.  Esto significa que algo salió mal, y continuar con la ejecución posterior es simplemente peligroso: los datos pueden divergir, si no es que ya.  Ocurre cuando la disponibilidad de un servicio es menos importante que su consistencia.  En este caso, tenemos que caer, y con un rugido, para que todos escuchen.  Es decir  Recibimos datos a través de la red, los validaron y cayeron.  Para nosotros, este error no es más fatal.  ¿Se espera este error?  Bueno, sí, escribimos el código con validación.  Es una tontería decir lo contrario.  Solo que no queremos continuar el programa después de eso.  Se requiere intervención manual, la automatización no funcionó. </p><br><h2 id="vybor-fatalizma">  Elección del fatalismo </h2><br><p>  Lo más obvio en el manejo de errores es decidir qué es fatal y qué no.  Pero cada programador se hace esta pregunta durante toda la actividad de desarrollo.  Por lo tanto, de alguna manera se responde a esta pregunta.  La respuesta correcta proviene de la práctica por alguna razón. </p><br><p>  Sin embargo, esta es solo la parte visible del iceberg.  En las profundidades hay una pregunta mucho más monstruosa.  Para comprender la profundidad completa, debe establecer una tarea simple e intentar responderla. </p><br><p>  <em>Desafío</em>  Haz un marco para algo. </p><br><p>  Todo es simple  Hacemos un marco, por ejemplo, de interacción de red.  O analizando JSON.  O, en el peor de los casos, XML.  La pregunta surge de inmediato: pero cuando ocurre un error desde el zócalo, ¿es un error fatal o no?  Parafraseando: ¿debo lanzar una excepción o devolver un error?  ¿Es esta una situación excepcional o no?  ¿O puede devolver <code>std::optional</code> ?  O una monja?  (^ 1) </p><br><p>  La conclusión paradójica es que el marco en sí mismo no puede responder a esta pregunta.  Solo el código que lo usa lo sabe.  Es por eso que la excelente biblioteca, en mi opinión, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boost.asio</a> usa ambas opciones.  Dependiendo de las preferencias personales del autor del código y la lógica aplicada, se puede elegir uno u otro método de manejo de errores.  Al principio, estaba un poco avergonzado por este enfoque, pero con el tiempo, me impregné de la flexibilidad de este enfoque. </p><br><p>  Sin embargo, esto no es todo.  Lo peor está por venir.  Aquí estamos escribiendo el código de la aplicación, pero nos parece que se aplica.  Para otro código, de nivel superior, nuestro código será la biblioteca.  Es decir  La división en código de aplicación / biblioteca (marco, etc.) es una convención pura, que depende del nivel de reutilización de los componentes.  Siempre puede atornillar algo en la parte superior y el código de la aplicación dejará de serlo.  Y esto significa inmediatamente que la elección de lo que es válido y lo que no lo está ya está decidido por el código que usa, y no lo usa. </p><br><p>  Si saltamos a un lado, resulta que a veces ni siquiera es posible entender quién usa a quién.  Es decir  el componente <strong>A</strong> puede usar el componente <strong>B</strong> y el componente <strong>B</strong> componente <strong>A</strong> (^ 2).  Es decir  quién determina lo que sucederá no está claro en absoluto. </p><br><h2 id="rasputyvanie-klubka">  Enredo desenredando </h2><br><p>  Cuando miras toda esta desgracia, surge la pregunta de inmediato: ¿cómo vivir con ella?  Que hacer  ¿Qué pautas puedes elegir para no ahogarse en la variedad? </p><br><p>  Para hacer esto, es útil mirar alrededor y comprender cómo se resuelven estos problemas en otros lugares.  Sin embargo, uno debe buscar con prudencia: es necesario distinguir entre la "recolección de sellos" de las soluciones completas. </p><br><p>  ¿Qué es coleccionar sellos?  Este es un término colectivo, lo que significa que intercambiamos un objetivo pero algo más.  Por ejemplo: teníamos un objetivo: llamar y comunicarnos con nuestros seres queridos.  Y una vez, y compramos un juguete caro, porque "de moda" y "hermoso" (^ 3).  ¿Eso es familiar?  ¿Crees que eso no les sucede a los programadores?  No te hagas ilusiones. </p><br><p>  El manejo de errores no es el objetivo.  Cada vez que hablamos sobre el manejo de errores, inmediatamente nos detenemos.  Porque es una forma de lograr un objetivo.  Y el objetivo inicial es hacer que nuestro software sea confiable, simple y comprensible.  Son estos objetivos los que deben establecerse y cumplirse siempre.  Y el manejo de errores es una mierda que no vale la pena discutir.  Quiero lanzar una excepción, ¡pero a la salud!  Devolvió un error, ¡bien hecho!  ¿Quieres una mónada?  Felicitaciones, creaste la ilusión de avance, pero solo en tu propia cabeza (^ 4). </p><br><p>  Entonces quise escribir cómo hacerlo bien, pero ya escribí.  Las heridas sanaron y dejaron de sangrar.  En resumen, los consejos son: </p><br><ol><li>  Separar en componentes con límites claros. </li><li>  En las fronteras, describa qué y cómo puede volar.  Es deseable que sea uniforme.  Pero mucho más importante es. </li><li>  Facilite el manejo de errores en el código que lo usará. </li><li>  Si algo puede procesarse internamente sin cargar el código de usuario, no lo sobresalga.  Cuantos menos errores deba manejar un usuario, mejor. </li><li>  Respeta a tu usuario, ¡no seas imbécil!  Escriba interfaces intuitivas con el comportamiento esperado para que no necesite leer comentarios y jurar. </li></ol><br><p>  El quinto consejo es el más importante, porque  él combina los primeros cuatro. </p><br><p>  <em>PD:</em> En la infancia, siempre tuve curiosidad por mirar el hormiguero.  Miles de hormigas, todos hacen algo, se arrastran por su negocio.  El proceso está en marcha.  Ahora también estoy mirando con interés.  También detrás del hormiguero.  Donde miles de personas están haciendo su pequeña cosa.  ¡Puedo desearles buena suerte en su duro negocio! </p><br><p>  ^ 1: La gente es aficionada a las cosas de moda.  Cuando todos jugaron lo suficiente, los programadores de C ++ se despertaron y luego todo cambió. </p><br><p>  ^ 2: Esto puede suceder cuando hay varias abstracciones en el componente <strong>B</strong> que las conecta.  Ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inversión de control</a> . </p><br><p>  ^ 3: Y al día siguiente, bam, y la pantalla se bloqueó. </p><br><p>  ^ 4: No estoy en contra de las mónadas, estoy en contra de aspirar, como, mira, aquí está la mónada, es decir  monoide en la categoría monoidal de endofunctores!  Se escuchan aplausos y aprobaciones.  Y en algún lugar lejos, lejos, apenas audible, alguien tiene orgasmos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426971/">https://habr.com/ru/post/es426971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426961/index.html">Cómo Microsoft reescribió el compilador de C # a C # y lo abrió</a></li>
<li><a href="../es426963/index.html">¿Las aplicaciones Flutter sueñan con widgets basados ​​en plataformas?</a></li>
<li><a href="../es426965/index.html">¿Qué pasará con el manejo de errores en C ++ 2a?</a></li>
<li><a href="../es426967/index.html">Generador de código ABAP en línea</a></li>
<li><a href="../es426969/index.html">Vigilant Lida: Automatización de pruebas de seguridad</a></li>
<li><a href="../es426973/index.html">Sandwiches corporativos</a></li>
<li><a href="../es426975/index.html">Joker 2018: lo imposible es posible</a></li>
<li><a href="../es426977/index.html">LibreOffice: la pesadilla del contador</a></li>
<li><a href="../es426979/index.html">Cómo aprender inglés gratis: 3 herramientas comunes e instrucciones detalladas para cada</a></li>
<li><a href="../es426981/index.html">10 trucos para tablero avanzado en Splunk. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>