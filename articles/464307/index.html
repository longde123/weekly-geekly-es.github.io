<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèΩ üÉè üëèüèº Pruebas de integraci√≥n de microservicios en Scala üë© üåé üêê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pruebas unitarias son geniales, pero una no es suficiente. A menudo, desea asegurarse adicionalmente de que la aplicaci√≥n en ejecuci√≥n funcionar√°....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de integraci√≥n de microservicios en Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Las pruebas unitarias son geniales, pero una no es suficiente.  A menudo, desea asegurarse adicionalmente de que la aplicaci√≥n en ejecuci√≥n funcionar√°.  Las pruebas de integraci√≥n vienen al rescate.  Se utiliza cada vez m√°s para probar servicios, y Docker le permite administrar convenientemente su entorno de prueba.  Pero, como siempre, las cosas no son tan simples cuando hay muchos m√°s microservicios y dependencias. <br><br>  Yuri Badalyants en RIT ++ cont√≥ c√≥mo en 2GIS est√°n probando una gran cantidad de servicios y un zool√≥gico tecnol√≥gico completo.  Bajo el corte, la versi√≥n de este informe, complementada y actualizada bajo la cuidadosa supervisi√≥n del orador: qu√© opciones probaste, qu√© se te ocurri√≥, qu√© problemas no tienes que resolver ahora.  Ser√° sobre Docker, Testcontainers y tambi√©n sobre Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LMnet</a> ) comenz√≥ su carrera en 2011 como desarrollador web, trabaj√≥ con PHP, JavaScript y Java.  Ahora escribe sobre Scala en 2GIS. <br><br><h2>  Casino </h2><br>  2GIS ha estado proporcionando mapas de ciudades convenientes y directorios de empresas durante 20 a√±os, y recientemente tenemos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva versi√≥n</a> con un mapa ilimitado de Rusia.  Te contar√© sobre la experiencia adquirida mientras trabajaba en el equipo de Casino.  Este equipo est√° involucrado en tres √°reas principales: <br><br><ul><li>  Publicidad: qu√© anunciantes mostrar, qu√© ocultar, qu√© aumentar y c√≥mo reducir la calificaci√≥n. </li></ul><br><ul><li>  BigData est√° relacionado con la publicidad y su personalizaci√≥n, as√≠ como con la creaci√≥n de an√°lisis y m√©tricas. </li><li>  Crawler es un programa que busca organizaciones en Internet para agregarlas autom√°ticamente a la base de datos. </li></ul><br>  Estas tres √°reas son las tareas principales, que, a su vez, tienen una gran cantidad de subtareas.  Actualmente, hay m√°s de 25 microservicios escritos en Scala.  Este es nuestro c√≥digo exclusivamente, sin embargo, tambi√©n utilizamos sistemas de terceros, por ejemplo, PostgreSQL, Cassandra y Kafka.  Almacenamos los datos en Hadoop y los procesamos en Spark.  Adem√°s, utilizamos los m√©todos de aprendizaje autom√°tico proporcionados por el equipo de Data Science. <br><br>  Como resultado, tenemos una gran cantidad de servicios y microservicios, una gran cantidad de dependencias y, por supuesto, todo esto necesita ser probado de alguna manera. <br><br>  Por supuesto, escribimos pruebas unitarias.  Sin embargo, incluso si todas las pruebas son verdes, esto no significa que todo funcione.  Algo puede salir mal durante la fase de integraci√≥n de componentes o microservicios.  Por lo tanto, escribimos pruebas de integraci√≥n. <br><br><h2>  Pruebas de integraci√≥n </h2><br>  Cada microservicio desarrollado por el equipo de Casino resuelve su problema comercial y se encuentra en un repositorio separado en GitLab.  Este art√≠culo se centrar√° en las pruebas de integraci√≥n dentro de uno de estos repositorios (microservicio) con dependencias bloqueadas, que es responsabilidad de los propios desarrolladores.  El equipo de control de calidad est√° probando la interacci√≥n de los microservicios, y no hablar√© sobre este tema. <br><br>  Cuando me un√≠ al equipo por primera vez, a finales de 2016, hab√≠a aproximadamente el siguiente esquema de prueba de integraci√≥n: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  El desarrollador introduce su c√≥digo en GIT, despu√©s de lo cual el c√≥digo del microservicio ingresa a TeamCity.  TeamCity comienza a construir c√≥digo y ejecutar pruebas. </li><li>  TeamCity toma el archivo de configuraci√≥n (config) de Chef (un sistema de gesti√≥n de configuraci√≥n similar a Ansible, solo escrito en Ruby).  Chef tambi√©n sirve para automatizar la implementaci√≥n.  Cuando tengo 100 m√°quinas, no quiero ir a cada una de ellas e instalar lo que necesito en SSH, y Chef me permite automatizar esto. </li><li>  TeamCity recopila el archivo jar (dado que escribimos en Scala, el artefacto que publicamos es el jar), luego el programa lo carga en el entorno de CI.  Nuestra aplicaci√≥n se implementa all√≠, tambi√©n hay algunas dependencias.  En el diagrama, una de las dependencias se representa como una base de datos.  Puede haber tantas dependencias como sea posible, y gracias a Chef, nuestra aplicaci√≥n las conoce y comienza a interactuar con ellas. </li><li>  A continuaci√≥n, TeamCity lanza <strong>SBT</strong> (este es nuestro sistema de compilaci√≥n, donde se ejecutan la compilaci√≥n y las pruebas) y ejecuta las pruebas en s√≠.  Son relativamente similares a las pruebas unitarias, pero funcionan principalmente en este principio: vaya a trav√©s de http a una direcci√≥n espec√≠fica, verifique alg√∫n m√©todo y vea qu√© devuelve;  o hacer algo de preparaci√≥n, y luego ver si lo que se necesita ha regresado. </li></ol><br>  <strong>¬øQu√© se puede decir sobre tal esquema?</strong>  Lo m√°s importante, funciona.  Cuando todo est√° configurado, ejecutar pruebas es f√°cil, ya que parecen pruebas unitarias.  Pero las ventajas terminan ah√≠. <br><br>  Y los contras comienzan.  <strong>El entorno de CI siempre est√° activado</strong> , y esto es un desperdicio adicional de recursos.  Dado que Chef es una configuraci√≥n est√°tica, siempre debe tener alg√∫n tipo de m√°quina donde se configuren todas las dependencias, donde las aplicaciones se implementar√°n de forma independiente.  Tal m√°quina consumir√° recursos adicionales, ya que las pruebas se ejecutan de vez en cuando, y la m√°quina debe estar lista todo el tiempo.  Adem√°s, el entorno de CI se incluye con todas las dependencias. <br><br>  <strong>No es posible ejecutar pruebas en dos ramas al mismo tiempo</strong> .  Esto se desprende del p√°rrafo anterior: dado que tenemos un entorno, simplemente no podemos ejecutarlos en paralelo. <br><br>  <strong>No es posible probar el inicio, detener y reiniciar</strong> .  Explicar√© por qu√© esto es necesario: todas nuestras aplicaciones obedecen la l√≥gica del llamado <strong>apagado elegante</strong> , es decir, cuando obtenemos SIGTERM, no detenemos el proceso en el medio, sino que interceptamos esta se√±al y entendemos que necesitamos apagar el programa.  En este punto, se activa cierta l√≥gica, por ejemplo, se procesan las solicitudes HTTP que est√°n "en vuelo", o si trabajamos con Kafka, comprometemos todas las compensaciones; en otras palabras, realizamos ciertas acciones para que podamos completar el trabajo de forma segura, y luego, cuando todo est√© listo, ap√°guelo. <br><br>  Esta l√≥gica no siempre es simple, y puede probarla con dicho esquema solo manualmente, porque a partir de las pruebas no controlamos el ciclo de vida de la aplicaci√≥n.  Resulta que TeamCity de alguna manera ha implementado algo a trav√©s de Chef, mientras que las pruebas est√°n en una etapa diferente y no saben c√≥mo se implementa la aplicaci√≥n. <br><br>  El siguiente <strong>inconveniente</strong> es que es muy <strong>dif√≠cil configurar todo esto localmente</strong> .  Es decir, hay muchas dependencias, tienen sus propias configuraciones, necesitan ser generadas en la m√°quina local.  La aplicaci√≥n en s√≠ tambi√©n tiene su propio archivo de configuraci√≥n, en el que hay muchos valores.  Las pruebas en s√≠ tienen una configuraci√≥n que debe coincidir con la configuraci√≥n de la aplicaci√≥n, y tambi√©n puede haber m√°s de un valor de configuraci√≥n.  Parece que todo esto no suena tan aterrador, como "ve y arregla las configuraciones en tres lugares", pero en realidad puede tomar horas para que los nuevos empleados hagan esto. <br><br><h3>  Docker GitLab CI + </h3><br>  Con el tiempo, este esquema se ha transformado en otro: <strong>GitLab CI</strong> y <strong>Docker</strong> .  Esto no sucedi√≥ porque el esquema anterior no era ideal, sino porque la compa√±√≠a cambi√≥ ligeramente el rumbo en t√©rminos de organizaci√≥n administrativa. <br><br>  Anteriormente, cada equipo, y tenemos muchos de ellos, como quer√≠amos o c√≥mo pod√≠amos, y desarrollamos su trabajo.  Por ejemplo, ten√≠amos que TeamCity, Chef y otros equipos pod√≠an usar Jenkins o Ansible. <br><br>  Ahora nos estamos moviendo hacia la nube local y Kubernetes, y hay un equipo separado que gestiona todo esto, tanto GitLab CI como Kubernetes.  Otros equipos solo usan esto como un servicio.  Esto es mucho m√°s conveniente ya que no necesita administrar todo esto manualmente. <br><br>  Usando Kubernetes, implementamos el siguiente esquema: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  En lugar de TeamCity, ahora se usa Gitlab CI. </li><li>  GitLab CI crea una imagen acoplable y la implementa en Kubernetes.  La configuraci√≥n ahora se almacena directamente en el repositorio, y no por separado en Chef, por lo que para la implementaci√≥n no necesita trabajar con un servicio de configuraci√≥n de terceros. </li><li>  Las dependencias se plantean de antemano, tambi√©n en Kubernetes. </li><li>  Luego, GitLab CI lanza SBT y las pruebas en un paso separado. </li></ol><br>  Todo es bastante similar al esquema anterior y no es fundamentalmente diferente de √©l, es decir, incluso los pros y los contras ser√°n exactamente los mismos, pero aparece Docker. <br><br>  Con Docker, puedes hacer diferentes cosas m√°s divertidas y una de ellas es Docker-compose. <br><br><h3>  Docker-compose </h3><br>  Este es un tipo de "superposici√≥n" en Docker, que le permite ejecutar m√∫ltiples im√°genes de docker como una sola entidad. <br><br>  Un buen ejemplo donde Docker-compose realmente ayuda es Kafka.  Ella necesita ZooKeeper para correr.  Si levanta Kafka y ZooKeeper sin el docker-compose, entonces necesita levantar ZooKeeper por separado en el docker, por separado, Kafka, y mantener estos dos contenedores de docker consistentes.  Esto no es muy conveniente, y docker-compose le permite describir ambos contenedores en un archivo docker-compose.yml y usar el simple <code>docker-compose run Kafka</code> Docker <code>docker-compose run Kafka</code> aumentar Kafka y ZooKeeper. <br><br>  Puede crear pruebas de integraci√≥n en docker-compose.  Veamos c√≥mo se ver√°. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Nuevamente, empuje todo en GitLab. </li><li>  GitLab CI lanza docker-compose. </li><li>  En docker-compose, la aplicaci√≥n sube, todas las dependencias y SBT suben, y SBT dirige las pruebas para esta aplicaci√≥n; todo sucede dentro de docker-compose. </li></ol><br>  Gracias a este esquema, no hay necesidad de mantener un entorno y dependencias separados, porque todo va directamente al corredor de GitLab CI, donde solo deben estar docker y docker-compose.  Durante el inicio, bombear√° las im√°genes necesarias y las ejecutar√°. <br><br>  Adem√°s, puede probar diferentes ramas al mismo tiempo, porque todo sucede en el corredor. <br><br>  Ahora <strong>es m√°s f√°cil configurar el</strong> entorno <strong>localmente</strong> , pero a√∫n necesita coordinar varios lugares.  La cuesti√≥n es que ahora, cuando hacemos la configuraci√≥n local, no necesitamos poner todo en la m√°quina local, todo est√° escrito en el archivo docker-compose.yml.  Por lo tanto, debe configurar en dos lugares diferentes: esto es docker-compose.yml y la configuraci√≥n de nuestras pruebas. <br><br>  En cuanto a las desventajas, <strong>todav√≠a es imposible probar el inicio, detener y reiniciar</strong> , porque desde SBT, desde las pruebas, no controlamos el ciclo de vida de la aplicaci√≥n.  Lo ejecuta docker-compose, ejecuta SBT y las pruebas se ejecutan dentro de SBT.  Por lo tanto, no hay una gesti√≥n completa del ciclo de vida de la aplicaci√≥n.  Tambi√©n hay dificultades con el lanzamiento, sobre las cuales me gustar√≠a hablar m√°s. <br><br><h4>  docker-compose 2 </h4><br>  En los d√≠as de docker-compose 2, docker-compose.yml el archivo se ve√≠a as√≠: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Los servicios se registran aqu√≠, es decir, lo que recaudaremos como parte de este docker-compose.  En este caso, acabo de tomar un ejemplo de la documentaci√≥n de docker-compose.  Hay tres servicios: web, redis y db (base de datos). <br><br>  Web es nuestra aplicaci√≥n, y redis y db son alg√∫n tipo de dependencias. <br><br>  Hay un elemento en el bloque web llamado <code>depends_on</code> .  Esto sugiere que la aplicaci√≥n web depende de algunos otros contenedores, y se describe a continuaci√≥n en los cuales: de la base de datos y redis. <br><br>  Adem√°s, hay una cl√°usula de <code>condition</code> .  Para redis, esto es <code>service_started</code> , lo que significa que hasta que se inicie redis, el contenedor no intentar√° iniciar la aplicaci√≥n web. <br><br>  En cuanto a la base de datos, su condici√≥n es <code>service_healthy</code> , y la comprobaci√≥n de salud se describe a continuaci√≥n.  Es decir, no solo necesitamos lanzar el contenedor docker, sino tambi√©n ejecutar un cierto chequeo de salud.  Puede ser cualquier l√≥gica personalizada. <br><br>  Por ejemplo, usamos PostgreSQL, que usa la extensi√≥n PostGIS, y necesita algo de tiempo para inicializarse.  Cuando lanzamos el contenedor docker, no podemos trabajar de inmediato con la extensi√≥n postgis; debemos esperar a que la extensi√≥n se inicialice.  Por lo tanto, solo <code>SELECT PostGIS_Version();</code> consultas <code>SELECT PostGIS_Version();</code> a <code>SELECT PostGIS_Version();</code>  .  Hasta que se inicialice la extensi√≥n, la solicitud arrojar√° un error, y cuando la extensi√≥n se inicialice, comenzar√° a devolver la versi√≥n.  Esto es muy conveniente y l√≥gico: <strong>primero elevaremos todas las dependencias y luego la aplicaci√≥n</strong> . <br><br><h4>  docker-compose 3 </h4><br>  Cuando sali√≥ Docker-compose 3, comenzamos a usarlo. <br><br>  Pero en la documentaci√≥n para ello, apareci√≥ un elemento al cambiar la l√≥gica depend_on.  Los desarrolladores de Docker decidieron que una descripci√≥n del gr√°fico de dependencia era suficiente.  Esto significa que cuando inicia el <code>docker-compose run web</code> , tanto la aplicaci√≥n como la base de datos de la que depende se iniciar√°n simult√°neamente. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  El siguiente p√°rrafo de la documentaci√≥n dice que depende_on ya no es condici√≥n. <br><br>  Por lo tanto, si a√∫n desea obtener la funcionalidad que se utiliz√≥ en la segunda versi√≥n, tendr√° que tener todo en sus manos. <br><br>  La p√°gina de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pedidos de inicio de Controlling</a> ofrece varias soluciones.  La primera opci√≥n es usar <strong>wait-for-it.sh</strong> . <br><br>  Ahora docker-compose.yml se ve un poco diferente: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> es solo una matriz, no hay condiciones. <br><br>  En nuestras dependencias, redefinimos el comando, es decir, en docker-compose puede adjuntar un comando con el que se inicia el contenedor de docker. <br><br>  All√≠ deber√≠amos escribir wait-for-it.sh, y algo m√°s.  En lugar de los tres puntos en el ejemplo anterior, deber√≠amos escribir lo que necesitamos esperar, as√≠ como el comando original que inicia el contenedor docker. <br><br>  Para hacer esto, debe encontrar el archivo acoplable, copiar el comando para redis desde all√≠ y pegarlo, lo mismo ocurre con la base de datos.  Un gran inconveniente es que la <strong>abstracci√≥n se descompone</strong> : no quiero saber qu√© comando inicia el contenedor acoplable.  Estos comandos pueden ser no triviales, bastante complejos, pero no quiero molestarme, solo quiero ingresar el <code>docker run</code> y eso es todo. <br><br>  Personalmente no me gusta esta soluci√≥n, pero ten√≠amos un par de servicios que funcionan as√≠. <br><br><h4>  Script en la parte superior de docker-compose </h4><br>  Entonces decid√≠ que hab√≠a llegado el momento de " <strong>construir</strong> bicicletas", y tuve <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Perm√≠teme darte un ejemplo semi-realista: hay postgres en docker-compose.yml, hay una aplicaci√≥n my_service, que depende de postgres, y SBT, en la que se ejecutan las pruebas y que depende de mi servicio. <br><br>  Ejecuto el programa no a trav√©s de <code>docker run</code> , sino a trav√©s del script docker-compose-run.sh. <br><br>  Primero, comienza la dependencia m√°s profunda primero, en mi caso es postgres.  El script inicia la dependencia en el modo "daemon", es decir, no bloquea el terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  Luego espero a que la funci√≥n wait_until satisfaga la condici√≥n.  Esto es casi lo mismo que wait-for-it.sh, solo, por as√≠ decirlo, en un estilo imperativo.  Mientras PostGIS se est√° inicializando, el terminal est√° bloqueado, es decir, el programa tambi√©n espera, y si no espera, se produce un error y las pruebas dejan de funcionar. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Cuando PostGIS se inicializa, contin√∫e con el siguiente paso y haga lo mismo con el servicio.  Para √©l, la prueba es un poco m√°s simple: el puerto 80 deber√≠a estar vinculado. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  El √∫ltimo paso es ejecutar SBT a trav√©s del comando de ejecuci√≥n, en el que se ejecutan las pruebas. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Por lo tanto, todo se plantea en el orden correcto, pero manualmente. <br><br>  Al final, se llama <code>down</code> funci√≥n <code>down</code> , que acepta el resultado del comando anterior.  Si es "0", las pruebas han pasado y simplemente desactivamos docker-compose;  de lo contrario, primero "escupimos" los registros para descubrir qu√© sali√≥ mal, y solo luego apagamos la compilaci√≥n de la ventana acoplable. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Tal esquema funciona, pero no escala bien.  Cada servicio tendr√° que describir su docker-compose-run.sh con su propia l√≥gica.  Adem√°s, la configuraci√≥n de inicio se extiende entre docker-compose-run.sh y docker-compose.yml.  Bueno, en general, parece que no estamos usando docker-compose, pero estamos luchando con sus deficiencias. <br><br><h4>  Ejecutando Docker desde el c√≥digo </h4><br>  Cuando se cre√≥ el esquema anterior, pens√©: si ya tengo todo en la ventana acoplable, ¬øpor qu√© no ejecutarlo desde el c√≥digo?  Empec√© a buscar una soluci√≥n y encontr√© varias opciones. <br><br>  La primera opci√≥n es simplemente <strong>usar el cliente docker</strong> .  Hay dos clientes principales de docker en el mundo JVM: <strong>docker-java</strong> y <strong>spotify docker-client</strong> . <br><br>  El cliente docker le permite ejecutar comandos docker directamente desde el c√≥digo utilizando la API.  Es decir, en lugar de concatenar cadenas para construir comandos como <code>`docker run ...`</code> , simplemente puede formar dicho comando en el c√≥digo y ejecutarlo.  Es mucho mas conveniente. <br><br>  Este m√©todo funciona bien y, con seguridad, pueden hacer todo, sin embargo, este es un nivel muy bajo.  Tendr√≠a que crear mi propio an√°logo compuesto por docker, que es una tarea muy grande. <br><br>  La siguiente opci√≥n es la <strong>biblioteca docker-it-scala</strong> , que envuelve a ambos clientes y le permite elegir qu√© back-end usar.  Ella puede ejecutar los contenedores que necesita. <br><br>  Pero el inconveniente de esta biblioteca es que no tiene una API muy flexible y no hay control del ciclo de vida. <br><br>  Tampoco me gust√≥ esta opci√≥n, continu√© buscando y encontr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Testcontainers</a> .  Me gustar√≠a contarles m√°s sobre esto. <br><br><h2>  Contenedores de prueba </h2><br>  Este es un tipo de biblioteca java para iniciar y probar contenedores docker.  Hay una fachada Scala, testcontainers-scala.  Fuera de la caja, hay una serie de servicios populares, por ejemplo, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Puede ejecutar cualquier otro contenedor.  La biblioteca tiene una API bastante simple y flexible, en la que me detendr√© con m√°s detalle. <br><br><h3>  Contenedores predefinidos </h3><br>  Entonces, c√≥mo trabajar con contenedores predefinidos, que est√°n en la biblioteca: de hecho, todo es bastante simple, ya que los contenedores se representan como objetos: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  En este caso, creamos <code>PostgreSQLContainer</code> , podemos iniciarlo y comenzar a trabajar con √©l.  A continuaci√≥n, obtenemos <code>jbdcUrl</code> , con el que puede conectarse a PostgreSQL.  Despu√©s de eso obtenemos <code>mappedPort</code> . <br><br>  Esto significa que PostgreSQL sobresale del puerto de acoplamiento 5432, y Testcontainers ve este puerto y lo asigna autom√°ticamente a alg√∫n puerto aleatorio.  Es decir, de las pruebas que vemos, por ejemplo, 32422. La asignaci√≥n se realiza autom√°ticamente. <br><br><h3>  Contenedor personalizado </h3><br>  La siguiente vista, el llamado contenedor personalizado, tambi√©n es bastante simple: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Hay un <code>GenericContainer</code> del que debe heredar y anular varios campos.  Aseg√∫rese de establecer solo <code>imageName</code> : este es el nombre del contenedor que queremos crear. <br><br>  Puede configurar los puertos <code>exposedPorts</code> : los puertos que el contenedor sobresaldr√°.  En env, puede establecer variables de entorno; tambi√©n puede establecer el <code>command</code> para ejecutar. <br><br>  <code>classpathResourceMapping</code> permite lanzar recursos de classpath al contenedor acoplable.  Esto es muy conveniente, por ejemplo, si la configuraci√≥n de la aplicaci√≥n est√° directamente en los recursos de prueba.  Simplemente asigna dentro, y la aplicaci√≥n dentro de Docker obtiene acceso a esta configuraci√≥n. <br><br>  <code>waitStrategy</code> es algo muy conveniente que faltaba en docker-compose 3, de hecho es HealthCheck.  Hay varios <code>waitStrategy</code> predefinidos, por ejemplo, puede esperar hasta que se produzca un enlace de puerto, o un m√©todo http espec√≠fico devolver√° 200. Pero puede escribir cualquiera de sus HealthCheck. <br><br>  Como escribe HealthCheck simplemente en su c√≥digo, puede usar, en primer lugar, un idioma normal, no bash, y, en segundo lugar, cualquier biblioteca que est√© disponible a partir de su c√≥digo: si desea hacer HealthCheck personalizado en Cassandra, tome el controlador y escriba cualquier HealthCheck. <br><br><h3>  Ejecutando pruebas </h3><br>  Y ahora un poco sobre c√≥mo ejecutar pruebas: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Hablar√© sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScalaTest</a> , el est√°ndar de facto para pruebas en el mundo Scala. <br><br>  Por ejemplo, queremos escribir pruebas para Postgres.  Cree una prueba <code>PostgresqlSpec</code> y herede de <code>ForAllTestContainer</code> .  Este es un rasgo proporcionado por la biblioteca.  Comenzar√° los contenedores necesarios antes de todas las pruebas y los detendr√° despu√©s de todas las pruebas.  O puede usar <code>ForeachTestContainer</code> , luego los contenedores comienzan antes de cada prueba y se detienen despu√©s de cada uno de ellos. <br><br>  Entonces necesitas redefinir el contenedor.  Esto puede hacerse anulando la propiedad del <code>container</code> .  En mi caso, estoy usando <code>PostgreSQLContainer</code> . <br><br>  Luego escribimos pruebas.  En el ejemplo, creo una conexi√≥n, tomo jdbcUrl, nombre de usuario, contrase√±a, escribo pruebas espec√≠ficas, env√≠o de solicitudes. <br><br>  Por lo general, las pruebas de integraci√≥n requieren varios contenedores.  Puedo crearlos usando <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Es decir, creo contenedores, los agrego a <code>MultipleContainers</code> y los uso como <code>container</code> . <br><br>  El esquema para ejecutar pruebas con Testcontainers es el siguiente: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Empuje el c√≥digo en GitLa. </li><li>  El corredor de GitLab CI lanza SBT. </li><li>  SBT ejecuta pruebas.  Dentro de las pruebas, se lanzan nuestra aplicaci√≥n y dependencias. </li></ol><br>  Las ventajas de este esquema: <br><br><ul><li>  No es necesario mantener un entorno y dependencias separados, todo sucede en el corredor. </li><li>  Puede probar diferentes ramas al mismo tiempo. </li><li>  Puede probar iniciar, detener y reiniciar, porque podemos controlar el ciclo de vida de la aplicaci√≥n (todo comienza en el c√≥digo de prueba). </li><li>  Hay HealthChecks flexibles que faltaban mucho. </li><li>  No hay archivos * .sh en el repositorio, puede configurar las pruebas en la aplicaci√≥n de la manera m√°s flexible que desee. </li><li>  Gracias a la asignaci√≥n de classpathResource, puede usar la misma configuraci√≥n con ambas pruebas y la aplicaci√≥n. </li><li>  Puede configurar pruebas desde el c√≥digo. </li><li>  Todo esto se ejecuta igualmente f√°cilmente tanto en CI como localmente, ya que estas son solo pruebas que se ven y se ejecutan como pruebas unitarias, solo todo sube en el contenedor de la ventana acoplable. </li></ul><br>  Resulta que todo es sospechosamente suave y bueno, pero esto es solo a primera vista, de hecho, encontramos una serie de problemas. <br><br><h3>  Contenedores dependientes </h3><br>  El primer problema que encontramos son <strong>los contenedores dependientes</strong> .  Digamos que hay alg√∫n tipo de prueba: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Ejecuta postgres y AppContainer.  El appContainer de postgres se pasa jdbcUrl, el nombre de usuario y la contrase√±a para la conexi√≥n.  A continuaci√≥n, se crea MultipleContainers y se describe la prueba en s√≠. <br><br>  Ejecuto el programa y veo un error: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  El punto es que el puerto asignado no se puede tomar hasta que se inicia el contenedor.  ¬øPor qu√© est√° pasando esto? <br><br>  El hecho es que <code>ForAllTestContainer</code> o <code>ForEachTestContainer</code> inician contenedores justo antes de las pruebas, y no en el momento en que creo instancias de contenedor.  Resulta que en el momento en que creo el AppContainer, todav√≠a no tengo <code>PostgreSQLContainer</code> activado, lo que significa que no puedo obtener el puerto asignado de √©l, y es necesario para formar <code>jdbcUrl</code> . <br><br>  El problema es que la esencia del contenedor es mutable: tiene varios estados.  Por ejemplo, se puede apagar y encender. <br><br>  ¬øC√≥mo resolver este problema?  El primer m√©todo que llamar√≠a "vago". <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  La idea principal es crear contenedores utilizando <strong>vago val</strong> .  Entonces no se inicializar√°n inmediatamente en el constructor de prueba, sino que esperar√°n la primera llamada.  Inicializaremos en los <code>afterAll</code> <code>beforeAll</code> y <code>afterAll</code> , que proporciona el <code>BeforeAndAfterAll</code> BeforeAndAfterAll de ScalaTest.  En <code>beforeAll</code> contenedores comienzan y en <code>afterAll</code> se apagan.  Dado que los contenedores se declaran vagos, en el momento en que se llama al m√©todo de inicio antes de All, se crear√°n, inicializar√°n e iniciar√°n. <br><br>  Sin embargo, todav√≠a se produce un error que no puedo unir localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Parece que usamos jdbcUrl, ¬øpor qu√© aparece localhost?  Veamos c√≥mo funciona jdbcUrl: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Es solo una concatenaci√≥n de cadenas.  Todo est√° claro con constantes; no pueden romperse.  <code>getMappedPort</code> deber√≠a funcionar, porque ya lo hemos solucionado.  <code>databaseName</code> es una constante codificada.  Pero con <code>getContainerIpAddress</code> m√°s interesante.  Por nombre, podemos suponer que debe devolver la direcci√≥n IP del contenedor.  Pero si ejecuta este c√≥digo, resulta que siempre devuelve localhost.  Al final result√≥ que, este m√©todo no est√° destinado a la interacci√≥n entre contenedores: <code>getContainerIpAddress</code> <strong>proporciona la interacci√≥n de las pruebas dentro del contenedor</strong> . <br><br>  Recomendaci√≥n del desarrollador de Testcontainers: <strong>cree una red personalizada para la comunicaci√≥n entre contenedores</strong> .  Docker-compose funciona de esta manera: crea una red y resuelve todo por s√≠ solo. <br><br>  Entonces necesitas crear una red. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Ahora tenemos que configurar manualmente nuestro jdbcUrl.  Tambi√©n necesitamos habilitar nuestros contenedores en la red y establecer un alias para PostgreSQLContainer para que sea accesible dentro de la red mediante alg√∫n nombre de dominio.  Al final, debe recordar "matar" la red. <br><br>  Finalmente, dicho programa funcionar√°. <br><br>  En versiones recientes de testcontainers-scala, la inicializaci√≥n de contenedor diferido es compatible de forma inmediata: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Puede usar <code>ForAllTestContainer</code> y <code>MultipleContainers</code> nuevamente.  En <code>beforeAll</code> ya no necesita <code>beforeAll</code> manualmente <code>beforeAll</code> orden de inicio.  Ahora <code>MultipleContainers</code> puede trabajar con val diferido y ejecutarlos en el orden correcto, y no realiza una inicializaci√≥n estricta inmediatamente despu√©s de la creaci√≥n.  Al mismo tiempo, las manipulaciones con la red personalizada y jdbcUrl tambi√©n deben realizarse manualmente. <br><br><h3>  Simulacros </h3><br>  Sin embargo, todav√≠a hay problemas.  Por ejemplo moki.  A veces no es muy conveniente crear alg√∫n tipo de dependencia en un contenedor acoplable.  Utilizamos Spark JobServer, que crea trabajos de Spark y controla su ciclo de vida en Spark.  Utilizamos dos de sus m√©todos: "crear" y "dar estado". <br><br>  Para ejecutar Spark JobServer dentro de la ventana acoplable.  Es necesario criar Spark, y hasta hace poco, no ten√≠a un contenedor acoplable y era necesario ensamblarlo usted mismo.  Adem√°s, Spark JobServer usa PostgreSQL para almacenar estados.  Como resultado, debe realizar un trabajo dif√≠cil cuando realmente solo necesita dos m√©todos con una API simple. <br><br>  Pero puede echar un vistazo a la implementaci√≥n del Spark JobServer y crear un simulacro que se comporte de la misma manera, pero que no requiera las dependencias del Spark JobServer original. <br><br>  Se ve as√≠ (en el ejemplo, un pseudoc√≥digo simplificado): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    ¬´¬ª    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    ¬´¬ª docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       ‚Äî    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Resumen </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers ‚Äî   ,    . API   ,      . <br><br>     Java-,        .      ‚Äî     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>‚Äî       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>‚Äî   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>‚Äî         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube ‚Äî     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>‚Äî     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag ‚Äî   , ‚Äî       ,        .    ,    latest   . <br><br> <strong><em>‚Äî ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>‚Äî  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , ‚Äî   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desea m√°s detalles sobre los microservicios en s√≠ y no solo sobre Scala: nuestro programa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene respuestas a varias preguntas. </font><font style="vertical-align: inherit;">M√°s interesado en la arquitectura y las interconexiones de sus diversas partes: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visite HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del 7 al 8 de noviembre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo es tan sabroso y no est√° claro qu√© elegir, luego suscr√≠base al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bolet√≠n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el que hablamos sobre informes y recopilamos materiales √∫tiles sobre el tema.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464307/">https://habr.com/ru/post/464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464293/index.html">¬øLos ganchos se reemplazan en React Redux?</a></li>
<li><a href="../464295/index.html">Ejemplos de uso de algunas funciones nuevas de JavaScript</a></li>
<li><a href="../464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../464303/index.html">Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL</a></li>
<li><a href="../464305/index.html">Peque√±o, si. Unboxing del petardo microvirtual</a></li>
<li><a href="../464309/index.html">Bot√≥n de llamada de bricolaje. Raspberry Pi, MajorDoMo, Freeswitch y Linphonec</a></li>
<li><a href="../464315/index.html">La pel√≠cula en la que hab√≠a tierra. Investigaci√≥n de Yandex y una breve historia de b√∫squeda por significado</a></li>
<li><a href="../464317/index.html">Proyecto Konbanwa</a></li>
<li><a href="../464325/index.html">C√≥mo Scrumban une lo mejor de las metodolog√≠as Kanban y Scrum</a></li>
<li><a href="../464327/index.html">Comparaci√≥n del uso de memoria de diferentes GUI de kit de herramientas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>