<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏽 🃏 👏🏼 Pruebas de integración de microservicios en Scala 👩 🌎 🐐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las pruebas unitarias son geniales, pero una no es suficiente. A menudo, desea asegurarse adicionalmente de que la aplicación en ejecución funcionará....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de integración de microservicios en Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Las pruebas unitarias son geniales, pero una no es suficiente.  A menudo, desea asegurarse adicionalmente de que la aplicación en ejecución funcionará.  Las pruebas de integración vienen al rescate.  Se utiliza cada vez más para probar servicios, y Docker le permite administrar convenientemente su entorno de prueba.  Pero, como siempre, las cosas no son tan simples cuando hay muchos más microservicios y dependencias. <br><br>  Yuri Badalyants en RIT ++ contó cómo en 2GIS están probando una gran cantidad de servicios y un zoológico tecnológico completo.  Bajo el corte, la versión de este informe, complementada y actualizada bajo la cuidadosa supervisión del orador: qué opciones probaste, qué se te ocurrió, qué problemas no tienes que resolver ahora.  Será sobre Docker, Testcontainers y también sobre Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LMnet</a> ) comenzó su carrera en 2011 como desarrollador web, trabajó con PHP, JavaScript y Java.  Ahora escribe sobre Scala en 2GIS. <br><br><h2>  Casino </h2><br>  2GIS ha estado proporcionando mapas de ciudades convenientes y directorios de empresas durante 20 años, y recientemente tenemos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva versión</a> con un mapa ilimitado de Rusia.  Te contaré sobre la experiencia adquirida mientras trabajaba en el equipo de Casino.  Este equipo está involucrado en tres áreas principales: <br><br><ul><li>  Publicidad: qué anunciantes mostrar, qué ocultar, qué aumentar y cómo reducir la calificación. </li></ul><br><ul><li>  BigData está relacionado con la publicidad y su personalización, así como con la creación de análisis y métricas. </li><li>  Crawler es un programa que busca organizaciones en Internet para agregarlas automáticamente a la base de datos. </li></ul><br>  Estas tres áreas son las tareas principales, que, a su vez, tienen una gran cantidad de subtareas.  Actualmente, hay más de 25 microservicios escritos en Scala.  Este es nuestro código exclusivamente, sin embargo, también utilizamos sistemas de terceros, por ejemplo, PostgreSQL, Cassandra y Kafka.  Almacenamos los datos en Hadoop y los procesamos en Spark.  Además, utilizamos los métodos de aprendizaje automático proporcionados por el equipo de Data Science. <br><br>  Como resultado, tenemos una gran cantidad de servicios y microservicios, una gran cantidad de dependencias y, por supuesto, todo esto necesita ser probado de alguna manera. <br><br>  Por supuesto, escribimos pruebas unitarias.  Sin embargo, incluso si todas las pruebas son verdes, esto no significa que todo funcione.  Algo puede salir mal durante la fase de integración de componentes o microservicios.  Por lo tanto, escribimos pruebas de integración. <br><br><h2>  Pruebas de integración </h2><br>  Cada microservicio desarrollado por el equipo de Casino resuelve su problema comercial y se encuentra en un repositorio separado en GitLab.  Este artículo se centrará en las pruebas de integración dentro de uno de estos repositorios (microservicio) con dependencias bloqueadas, que es responsabilidad de los propios desarrolladores.  El equipo de control de calidad está probando la interacción de los microservicios, y no hablaré sobre este tema. <br><br>  Cuando me uní al equipo por primera vez, a finales de 2016, había aproximadamente el siguiente esquema de prueba de integración: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  El desarrollador introduce su código en GIT, después de lo cual el código del microservicio ingresa a TeamCity.  TeamCity comienza a construir código y ejecutar pruebas. </li><li>  TeamCity toma el archivo de configuración (config) de Chef (un sistema de gestión de configuración similar a Ansible, solo escrito en Ruby).  Chef también sirve para automatizar la implementación.  Cuando tengo 100 máquinas, no quiero ir a cada una de ellas e instalar lo que necesito en SSH, y Chef me permite automatizar esto. </li><li>  TeamCity recopila el archivo jar (dado que escribimos en Scala, el artefacto que publicamos es el jar), luego el programa lo carga en el entorno de CI.  Nuestra aplicación se implementa allí, también hay algunas dependencias.  En el diagrama, una de las dependencias se representa como una base de datos.  Puede haber tantas dependencias como sea posible, y gracias a Chef, nuestra aplicación las conoce y comienza a interactuar con ellas. </li><li>  A continuación, TeamCity lanza <strong>SBT</strong> (este es nuestro sistema de compilación, donde se ejecutan la compilación y las pruebas) y ejecuta las pruebas en sí.  Son relativamente similares a las pruebas unitarias, pero funcionan principalmente en este principio: vaya a través de http a una dirección específica, verifique algún método y vea qué devuelve;  o hacer algo de preparación, y luego ver si lo que se necesita ha regresado. </li></ol><br>  <strong>¿Qué se puede decir sobre tal esquema?</strong>  Lo más importante, funciona.  Cuando todo está configurado, ejecutar pruebas es fácil, ya que parecen pruebas unitarias.  Pero las ventajas terminan ahí. <br><br>  Y los contras comienzan.  <strong>El entorno de CI siempre está activado</strong> , y esto es un desperdicio adicional de recursos.  Dado que Chef es una configuración estática, siempre debe tener algún tipo de máquina donde se configuren todas las dependencias, donde las aplicaciones se implementarán de forma independiente.  Tal máquina consumirá recursos adicionales, ya que las pruebas se ejecutan de vez en cuando, y la máquina debe estar lista todo el tiempo.  Además, el entorno de CI se incluye con todas las dependencias. <br><br>  <strong>No es posible ejecutar pruebas en dos ramas al mismo tiempo</strong> .  Esto se desprende del párrafo anterior: dado que tenemos un entorno, simplemente no podemos ejecutarlos en paralelo. <br><br>  <strong>No es posible probar el inicio, detener y reiniciar</strong> .  Explicaré por qué esto es necesario: todas nuestras aplicaciones obedecen la lógica del llamado <strong>apagado elegante</strong> , es decir, cuando obtenemos SIGTERM, no detenemos el proceso en el medio, sino que interceptamos esta señal y entendemos que necesitamos apagar el programa.  En este punto, se activa cierta lógica, por ejemplo, se procesan las solicitudes HTTP que están "en vuelo", o si trabajamos con Kafka, comprometemos todas las compensaciones; en otras palabras, realizamos ciertas acciones para que podamos completar el trabajo de forma segura, y luego, cuando todo esté listo, apáguelo. <br><br>  Esta lógica no siempre es simple, y puede probarla con dicho esquema solo manualmente, porque a partir de las pruebas no controlamos el ciclo de vida de la aplicación.  Resulta que TeamCity de alguna manera ha implementado algo a través de Chef, mientras que las pruebas están en una etapa diferente y no saben cómo se implementa la aplicación. <br><br>  El siguiente <strong>inconveniente</strong> es que es muy <strong>difícil configurar todo esto localmente</strong> .  Es decir, hay muchas dependencias, tienen sus propias configuraciones, necesitan ser generadas en la máquina local.  La aplicación en sí también tiene su propio archivo de configuración, en el que hay muchos valores.  Las pruebas en sí tienen una configuración que debe coincidir con la configuración de la aplicación, y también puede haber más de un valor de configuración.  Parece que todo esto no suena tan aterrador, como "ve y arregla las configuraciones en tres lugares", pero en realidad puede tomar horas para que los nuevos empleados hagan esto. <br><br><h3>  Docker GitLab CI + </h3><br>  Con el tiempo, este esquema se ha transformado en otro: <strong>GitLab CI</strong> y <strong>Docker</strong> .  Esto no sucedió porque el esquema anterior no era ideal, sino porque la compañía cambió ligeramente el rumbo en términos de organización administrativa. <br><br>  Anteriormente, cada equipo, y tenemos muchos de ellos, como queríamos o cómo podíamos, y desarrollamos su trabajo.  Por ejemplo, teníamos que TeamCity, Chef y otros equipos podían usar Jenkins o Ansible. <br><br>  Ahora nos estamos moviendo hacia la nube local y Kubernetes, y hay un equipo separado que gestiona todo esto, tanto GitLab CI como Kubernetes.  Otros equipos solo usan esto como un servicio.  Esto es mucho más conveniente ya que no necesita administrar todo esto manualmente. <br><br>  Usando Kubernetes, implementamos el siguiente esquema: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  En lugar de TeamCity, ahora se usa Gitlab CI. </li><li>  GitLab CI crea una imagen acoplable y la implementa en Kubernetes.  La configuración ahora se almacena directamente en el repositorio, y no por separado en Chef, por lo que para la implementación no necesita trabajar con un servicio de configuración de terceros. </li><li>  Las dependencias se plantean de antemano, también en Kubernetes. </li><li>  Luego, GitLab CI lanza SBT y las pruebas en un paso separado. </li></ol><br>  Todo es bastante similar al esquema anterior y no es fundamentalmente diferente de él, es decir, incluso los pros y los contras serán exactamente los mismos, pero aparece Docker. <br><br>  Con Docker, puedes hacer diferentes cosas más divertidas y una de ellas es Docker-compose. <br><br><h3>  Docker-compose </h3><br>  Este es un tipo de "superposición" en Docker, que le permite ejecutar múltiples imágenes de docker como una sola entidad. <br><br>  Un buen ejemplo donde Docker-compose realmente ayuda es Kafka.  Ella necesita ZooKeeper para correr.  Si levanta Kafka y ZooKeeper sin el docker-compose, entonces necesita levantar ZooKeeper por separado en el docker, por separado, Kafka, y mantener estos dos contenedores de docker consistentes.  Esto no es muy conveniente, y docker-compose le permite describir ambos contenedores en un archivo docker-compose.yml y usar el simple <code>docker-compose run Kafka</code> Docker <code>docker-compose run Kafka</code> aumentar Kafka y ZooKeeper. <br><br>  Puede crear pruebas de integración en docker-compose.  Veamos cómo se verá. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Nuevamente, empuje todo en GitLab. </li><li>  GitLab CI lanza docker-compose. </li><li>  En docker-compose, la aplicación sube, todas las dependencias y SBT suben, y SBT dirige las pruebas para esta aplicación; todo sucede dentro de docker-compose. </li></ol><br>  Gracias a este esquema, no hay necesidad de mantener un entorno y dependencias separados, porque todo va directamente al corredor de GitLab CI, donde solo deben estar docker y docker-compose.  Durante el inicio, bombeará las imágenes necesarias y las ejecutará. <br><br>  Además, puede probar diferentes ramas al mismo tiempo, porque todo sucede en el corredor. <br><br>  Ahora <strong>es más fácil configurar el</strong> entorno <strong>localmente</strong> , pero aún necesita coordinar varios lugares.  La cuestión es que ahora, cuando hacemos la configuración local, no necesitamos poner todo en la máquina local, todo está escrito en el archivo docker-compose.yml.  Por lo tanto, debe configurar en dos lugares diferentes: esto es docker-compose.yml y la configuración de nuestras pruebas. <br><br>  En cuanto a las desventajas, <strong>todavía es imposible probar el inicio, detener y reiniciar</strong> , porque desde SBT, desde las pruebas, no controlamos el ciclo de vida de la aplicación.  Lo ejecuta docker-compose, ejecuta SBT y las pruebas se ejecutan dentro de SBT.  Por lo tanto, no hay una gestión completa del ciclo de vida de la aplicación.  También hay dificultades con el lanzamiento, sobre las cuales me gustaría hablar más. <br><br><h4>  docker-compose 2 </h4><br>  En los días de docker-compose 2, docker-compose.yml el archivo se veía así: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Los servicios se registran aquí, es decir, lo que recaudaremos como parte de este docker-compose.  En este caso, acabo de tomar un ejemplo de la documentación de docker-compose.  Hay tres servicios: web, redis y db (base de datos). <br><br>  Web es nuestra aplicación, y redis y db son algún tipo de dependencias. <br><br>  Hay un elemento en el bloque web llamado <code>depends_on</code> .  Esto sugiere que la aplicación web depende de algunos otros contenedores, y se describe a continuación en los cuales: de la base de datos y redis. <br><br>  Además, hay una cláusula de <code>condition</code> .  Para redis, esto es <code>service_started</code> , lo que significa que hasta que se inicie redis, el contenedor no intentará iniciar la aplicación web. <br><br>  En cuanto a la base de datos, su condición es <code>service_healthy</code> , y la comprobación de salud se describe a continuación.  Es decir, no solo necesitamos lanzar el contenedor docker, sino también ejecutar un cierto chequeo de salud.  Puede ser cualquier lógica personalizada. <br><br>  Por ejemplo, usamos PostgreSQL, que usa la extensión PostGIS, y necesita algo de tiempo para inicializarse.  Cuando lanzamos el contenedor docker, no podemos trabajar de inmediato con la extensión postgis; debemos esperar a que la extensión se inicialice.  Por lo tanto, solo <code>SELECT PostGIS_Version();</code> consultas <code>SELECT PostGIS_Version();</code> a <code>SELECT PostGIS_Version();</code>  .  Hasta que se inicialice la extensión, la solicitud arrojará un error, y cuando la extensión se inicialice, comenzará a devolver la versión.  Esto es muy conveniente y lógico: <strong>primero elevaremos todas las dependencias y luego la aplicación</strong> . <br><br><h4>  docker-compose 3 </h4><br>  Cuando salió Docker-compose 3, comenzamos a usarlo. <br><br>  Pero en la documentación para ello, apareció un elemento al cambiar la lógica depend_on.  Los desarrolladores de Docker decidieron que una descripción del gráfico de dependencia era suficiente.  Esto significa que cuando inicia el <code>docker-compose run web</code> , tanto la aplicación como la base de datos de la que depende se iniciarán simultáneamente. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  El siguiente párrafo de la documentación dice que depende_on ya no es condición. <br><br>  Por lo tanto, si aún desea obtener la funcionalidad que se utilizó en la segunda versión, tendrá que tener todo en sus manos. <br><br>  La página de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pedidos de inicio de Controlling</a> ofrece varias soluciones.  La primera opción es usar <strong>wait-for-it.sh</strong> . <br><br>  Ahora docker-compose.yml se ve un poco diferente: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> es solo una matriz, no hay condiciones. <br><br>  En nuestras dependencias, redefinimos el comando, es decir, en docker-compose puede adjuntar un comando con el que se inicia el contenedor de docker. <br><br>  Allí deberíamos escribir wait-for-it.sh, y algo más.  En lugar de los tres puntos en el ejemplo anterior, deberíamos escribir lo que necesitamos esperar, así como el comando original que inicia el contenedor docker. <br><br>  Para hacer esto, debe encontrar el archivo acoplable, copiar el comando para redis desde allí y pegarlo, lo mismo ocurre con la base de datos.  Un gran inconveniente es que la <strong>abstracción se descompone</strong> : no quiero saber qué comando inicia el contenedor acoplable.  Estos comandos pueden ser no triviales, bastante complejos, pero no quiero molestarme, solo quiero ingresar el <code>docker run</code> y eso es todo. <br><br>  Personalmente no me gusta esta solución, pero teníamos un par de servicios que funcionan así. <br><br><h4>  Script en la parte superior de docker-compose </h4><br>  Entonces decidí que había llegado el momento de " <strong>construir</strong> bicicletas", y tuve <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Permíteme darte un ejemplo semi-realista: hay postgres en docker-compose.yml, hay una aplicación my_service, que depende de postgres, y SBT, en la que se ejecutan las pruebas y que depende de mi servicio. <br><br>  Ejecuto el programa no a través de <code>docker run</code> , sino a través del script docker-compose-run.sh. <br><br>  Primero, comienza la dependencia más profunda primero, en mi caso es postgres.  El script inicia la dependencia en el modo "daemon", es decir, no bloquea el terminal: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  Luego espero a que la función wait_until satisfaga la condición.  Esto es casi lo mismo que wait-for-it.sh, solo, por así decirlo, en un estilo imperativo.  Mientras PostGIS se está inicializando, el terminal está bloqueado, es decir, el programa también espera, y si no espera, se produce un error y las pruebas dejan de funcionar. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Cuando PostGIS se inicializa, continúe con el siguiente paso y haga lo mismo con el servicio.  Para él, la prueba es un poco más simple: el puerto 80 debería estar vinculado. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  El último paso es ejecutar SBT a través del comando de ejecución, en el que se ejecutan las pruebas. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Por lo tanto, todo se plantea en el orden correcto, pero manualmente. <br><br>  Al final, se llama <code>down</code> función <code>down</code> , que acepta el resultado del comando anterior.  Si es "0", las pruebas han pasado y simplemente desactivamos docker-compose;  de lo contrario, primero "escupimos" los registros para descubrir qué salió mal, y solo luego apagamos la compilación de la ventana acoplable. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Tal esquema funciona, pero no escala bien.  Cada servicio tendrá que describir su docker-compose-run.sh con su propia lógica.  Además, la configuración de inicio se extiende entre docker-compose-run.sh y docker-compose.yml.  Bueno, en general, parece que no estamos usando docker-compose, pero estamos luchando con sus deficiencias. <br><br><h4>  Ejecutando Docker desde el código </h4><br>  Cuando se creó el esquema anterior, pensé: si ya tengo todo en la ventana acoplable, ¿por qué no ejecutarlo desde el código?  Empecé a buscar una solución y encontré varias opciones. <br><br>  La primera opción es simplemente <strong>usar el cliente docker</strong> .  Hay dos clientes principales de docker en el mundo JVM: <strong>docker-java</strong> y <strong>spotify docker-client</strong> . <br><br>  El cliente docker le permite ejecutar comandos docker directamente desde el código utilizando la API.  Es decir, en lugar de concatenar cadenas para construir comandos como <code>`docker run ...`</code> , simplemente puede formar dicho comando en el código y ejecutarlo.  Es mucho mas conveniente. <br><br>  Este método funciona bien y, con seguridad, pueden hacer todo, sin embargo, este es un nivel muy bajo.  Tendría que crear mi propio análogo compuesto por docker, que es una tarea muy grande. <br><br>  La siguiente opción es la <strong>biblioteca docker-it-scala</strong> , que envuelve a ambos clientes y le permite elegir qué back-end usar.  Ella puede ejecutar los contenedores que necesita. <br><br>  Pero el inconveniente de esta biblioteca es que no tiene una API muy flexible y no hay control del ciclo de vida. <br><br>  Tampoco me gustó esta opción, continué buscando y encontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Testcontainers</a> .  Me gustaría contarles más sobre esto. <br><br><h2>  Contenedores de prueba </h2><br>  Este es un tipo de biblioteca java para iniciar y probar contenedores docker.  Hay una fachada Scala, testcontainers-scala.  Fuera de la caja, hay una serie de servicios populares, por ejemplo, PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Puede ejecutar cualquier otro contenedor.  La biblioteca tiene una API bastante simple y flexible, en la que me detendré con más detalle. <br><br><h3>  Contenedores predefinidos </h3><br>  Entonces, cómo trabajar con contenedores predefinidos, que están en la biblioteca: de hecho, todo es bastante simple, ya que los contenedores se representan como objetos: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  En este caso, creamos <code>PostgreSQLContainer</code> , podemos iniciarlo y comenzar a trabajar con él.  A continuación, obtenemos <code>jbdcUrl</code> , con el que puede conectarse a PostgreSQL.  Después de eso obtenemos <code>mappedPort</code> . <br><br>  Esto significa que PostgreSQL sobresale del puerto de acoplamiento 5432, y Testcontainers ve este puerto y lo asigna automáticamente a algún puerto aleatorio.  Es decir, de las pruebas que vemos, por ejemplo, 32422. La asignación se realiza automáticamente. <br><br><h3>  Contenedor personalizado </h3><br>  La siguiente vista, el llamado contenedor personalizado, también es bastante simple: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Hay un <code>GenericContainer</code> del que debe heredar y anular varios campos.  Asegúrese de establecer solo <code>imageName</code> : este es el nombre del contenedor que queremos crear. <br><br>  Puede configurar los puertos <code>exposedPorts</code> : los puertos que el contenedor sobresaldrá.  En env, puede establecer variables de entorno; también puede establecer el <code>command</code> para ejecutar. <br><br>  <code>classpathResourceMapping</code> permite lanzar recursos de classpath al contenedor acoplable.  Esto es muy conveniente, por ejemplo, si la configuración de la aplicación está directamente en los recursos de prueba.  Simplemente asigna dentro, y la aplicación dentro de Docker obtiene acceso a esta configuración. <br><br>  <code>waitStrategy</code> es algo muy conveniente que faltaba en docker-compose 3, de hecho es HealthCheck.  Hay varios <code>waitStrategy</code> predefinidos, por ejemplo, puede esperar hasta que se produzca un enlace de puerto, o un método http específico devolverá 200. Pero puede escribir cualquiera de sus HealthCheck. <br><br>  Como escribe HealthCheck simplemente en su código, puede usar, en primer lugar, un idioma normal, no bash, y, en segundo lugar, cualquier biblioteca que esté disponible a partir de su código: si desea hacer HealthCheck personalizado en Cassandra, tome el controlador y escriba cualquier HealthCheck. <br><br><h3>  Ejecutando pruebas </h3><br>  Y ahora un poco sobre cómo ejecutar pruebas: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Hablaré sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ScalaTest</a> , el estándar de facto para pruebas en el mundo Scala. <br><br>  Por ejemplo, queremos escribir pruebas para Postgres.  Cree una prueba <code>PostgresqlSpec</code> y herede de <code>ForAllTestContainer</code> .  Este es un rasgo proporcionado por la biblioteca.  Comenzará los contenedores necesarios antes de todas las pruebas y los detendrá después de todas las pruebas.  O puede usar <code>ForeachTestContainer</code> , luego los contenedores comienzan antes de cada prueba y se detienen después de cada uno de ellos. <br><br>  Entonces necesitas redefinir el contenedor.  Esto puede hacerse anulando la propiedad del <code>container</code> .  En mi caso, estoy usando <code>PostgreSQLContainer</code> . <br><br>  Luego escribimos pruebas.  En el ejemplo, creo una conexión, tomo jdbcUrl, nombre de usuario, contraseña, escribo pruebas específicas, envío de solicitudes. <br><br>  Por lo general, las pruebas de integración requieren varios contenedores.  Puedo crearlos usando <code>MultipleContainers</code> : <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Es decir, creo contenedores, los agrego a <code>MultipleContainers</code> y los uso como <code>container</code> . <br><br>  El esquema para ejecutar pruebas con Testcontainers es el siguiente: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Empuje el código en GitLa. </li><li>  El corredor de GitLab CI lanza SBT. </li><li>  SBT ejecuta pruebas.  Dentro de las pruebas, se lanzan nuestra aplicación y dependencias. </li></ol><br>  Las ventajas de este esquema: <br><br><ul><li>  No es necesario mantener un entorno y dependencias separados, todo sucede en el corredor. </li><li>  Puede probar diferentes ramas al mismo tiempo. </li><li>  Puede probar iniciar, detener y reiniciar, porque podemos controlar el ciclo de vida de la aplicación (todo comienza en el código de prueba). </li><li>  Hay HealthChecks flexibles que faltaban mucho. </li><li>  No hay archivos * .sh en el repositorio, puede configurar las pruebas en la aplicación de la manera más flexible que desee. </li><li>  Gracias a la asignación de classpathResource, puede usar la misma configuración con ambas pruebas y la aplicación. </li><li>  Puede configurar pruebas desde el código. </li><li>  Todo esto se ejecuta igualmente fácilmente tanto en CI como localmente, ya que estas son solo pruebas que se ven y se ejecutan como pruebas unitarias, solo todo sube en el contenedor de la ventana acoplable. </li></ul><br>  Resulta que todo es sospechosamente suave y bueno, pero esto es solo a primera vista, de hecho, encontramos una serie de problemas. <br><br><h3>  Contenedores dependientes </h3><br>  El primer problema que encontramos son <strong>los contenedores dependientes</strong> .  Digamos que hay algún tipo de prueba: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Ejecuta postgres y AppContainer.  El appContainer de postgres se pasa jdbcUrl, el nombre de usuario y la contraseña para la conexión.  A continuación, se crea MultipleContainers y se describe la prueba en sí. <br><br>  Ejecuto el programa y veo un error: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  El punto es que el puerto asignado no se puede tomar hasta que se inicia el contenedor.  ¿Por qué está pasando esto? <br><br>  El hecho es que <code>ForAllTestContainer</code> o <code>ForEachTestContainer</code> inician contenedores justo antes de las pruebas, y no en el momento en que creo instancias de contenedor.  Resulta que en el momento en que creo el AppContainer, todavía no tengo <code>PostgreSQLContainer</code> activado, lo que significa que no puedo obtener el puerto asignado de él, y es necesario para formar <code>jdbcUrl</code> . <br><br>  El problema es que la esencia del contenedor es mutable: tiene varios estados.  Por ejemplo, se puede apagar y encender. <br><br>  ¿Cómo resolver este problema?  El primer método que llamaría "vago". <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  La idea principal es crear contenedores utilizando <strong>vago val</strong> .  Entonces no se inicializarán inmediatamente en el constructor de prueba, sino que esperarán la primera llamada.  Inicializaremos en los <code>afterAll</code> <code>beforeAll</code> y <code>afterAll</code> , que proporciona el <code>BeforeAndAfterAll</code> BeforeAndAfterAll de ScalaTest.  En <code>beforeAll</code> contenedores comienzan y en <code>afterAll</code> se apagan.  Dado que los contenedores se declaran vagos, en el momento en que se llama al método de inicio antes de All, se crearán, inicializarán e iniciarán. <br><br>  Sin embargo, todavía se produce un error que no puedo unir localhost: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Parece que usamos jdbcUrl, ¿por qué aparece localhost?  Veamos cómo funciona jdbcUrl: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Es solo una concatenación de cadenas.  Todo está claro con constantes; no pueden romperse.  <code>getMappedPort</code> debería funcionar, porque ya lo hemos solucionado.  <code>databaseName</code> es una constante codificada.  Pero con <code>getContainerIpAddress</code> más interesante.  Por nombre, podemos suponer que debe devolver la dirección IP del contenedor.  Pero si ejecuta este código, resulta que siempre devuelve localhost.  Al final resultó que, este método no está destinado a la interacción entre contenedores: <code>getContainerIpAddress</code> <strong>proporciona la interacción de las pruebas dentro del contenedor</strong> . <br><br>  Recomendación del desarrollador de Testcontainers: <strong>cree una red personalizada para la comunicación entre contenedores</strong> .  Docker-compose funciona de esta manera: crea una red y resuelve todo por sí solo. <br><br>  Entonces necesitas crear una red. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Ahora tenemos que configurar manualmente nuestro jdbcUrl.  También necesitamos habilitar nuestros contenedores en la red y establecer un alias para PostgreSQLContainer para que sea accesible dentro de la red mediante algún nombre de dominio.  Al final, debe recordar "matar" la red. <br><br>  Finalmente, dicho programa funcionará. <br><br>  En versiones recientes de testcontainers-scala, la inicialización de contenedor diferido es compatible de forma inmediata: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Puede usar <code>ForAllTestContainer</code> y <code>MultipleContainers</code> nuevamente.  En <code>beforeAll</code> ya no necesita <code>beforeAll</code> manualmente <code>beforeAll</code> orden de inicio.  Ahora <code>MultipleContainers</code> puede trabajar con val diferido y ejecutarlos en el orden correcto, y no realiza una inicialización estricta inmediatamente después de la creación.  Al mismo tiempo, las manipulaciones con la red personalizada y jdbcUrl también deben realizarse manualmente. <br><br><h3>  Simulacros </h3><br>  Sin embargo, todavía hay problemas.  Por ejemplo moki.  A veces no es muy conveniente crear algún tipo de dependencia en un contenedor acoplable.  Utilizamos Spark JobServer, que crea trabajos de Spark y controla su ciclo de vida en Spark.  Utilizamos dos de sus métodos: "crear" y "dar estado". <br><br>  Para ejecutar Spark JobServer dentro de la ventana acoplable.  Es necesario criar Spark, y hasta hace poco, no tenía un contenedor acoplable y era necesario ensamblarlo usted mismo.  Además, Spark JobServer usa PostgreSQL para almacenar estados.  Como resultado, debe realizar un trabajo difícil cuando realmente solo necesita dos métodos con una API simple. <br><br>  Pero puede echar un vistazo a la implementación del Spark JobServer y crear un simulacro que se comporte de la misma manera, pero que no requiera las dependencias del Spark JobServer original. <br><br>  Se ve así (en el ejemplo, un pseudocódigo simplificado): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    «»    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    «» docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       —    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Resumen </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers —   ,    . API   ,      . <br><br>     Java-,        .      —     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>—       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>—   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>—         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube —     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>—     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag —   , —       ,        .    ,    latest   . <br><br> <strong><em>— ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>—  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , —   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desea más detalles sobre los microservicios en sí y no solo sobre Scala: nuestro programa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScalaConf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene respuestas a varias preguntas. </font><font style="vertical-align: inherit;">Más interesado en la arquitectura y las interconexiones de sus diversas partes: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">visite HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del 7 al 8 de noviembre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo es tan sabroso y no está claro qué elegir, luego suscríbase al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boletín</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el que hablamos sobre informes y recopilamos materiales útiles sobre el tema.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464307/">https://habr.com/ru/post/464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464293/index.html">¿Los ganchos se reemplazan en React Redux?</a></li>
<li><a href="../464295/index.html">Ejemplos de uso de algunas funciones nuevas de JavaScript</a></li>
<li><a href="../464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../464303/index.html">Datos de series de tiempo en un DBMS relacional. Extensiones TimescaleDB y PipelineDB para PostgreSQL</a></li>
<li><a href="../464305/index.html">Pequeño, si. Unboxing del petardo microvirtual</a></li>
<li><a href="../464309/index.html">Botón de llamada de bricolaje. Raspberry Pi, MajorDoMo, Freeswitch y Linphonec</a></li>
<li><a href="../464315/index.html">La película en la que había tierra. Investigación de Yandex y una breve historia de búsqueda por significado</a></li>
<li><a href="../464317/index.html">Proyecto Konbanwa</a></li>
<li><a href="../464325/index.html">Cómo Scrumban une lo mejor de las metodologías Kanban y Scrum</a></li>
<li><a href="../464327/index.html">Comparación del uso de memoria de diferentes GUI de kit de herramientas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>