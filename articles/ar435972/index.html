<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌠 ⛏️ 😟 تقديم البرمجة التفاعلية في الربيع 👩‍🍳 👊🏽 🧛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر! 

 نتوقع هذا الأسبوع كتاب ربيع جديد من المطبعة: 


 من بين السمات المثيرة للاهتمام في برنامج Spring 5 ، تستحق البرمجة التفاعلية الإشارة ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تقديم البرمجة التفاعلية في الربيع</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/435972/" style=";text-align:right;direction:rtl">  مرحبا يا هبر! <br><br>  نتوقع هذا الأسبوع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كتاب</a> ربيع جديد من المطبعة: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br>  من بين السمات المثيرة للاهتمام في برنامج Spring 5 ، تستحق البرمجة التفاعلية الإشارة بشكل خاص ، والتي تم وصف تنفيذها بإيجاز في المقالة المقترحة بواسطة Matt Raible.  في الكتاب المذكور أعلاه ، تمت مناقشة الأنماط التفاعلية في الفصل 11. <br><br>  شارك في تأليف مات جوش لونج ، مؤلف كتاب آخر رائع عن جافا والربيع ، " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جافا في الغيمة</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">،</a> صدر في الصيف الماضي. <br><a name="habracut"></a><br>  البرمجة التفاعلية هي طريقتك لبناء أنظمة مقاومة للأحمال الكبيرة.  لم تعد معالجة عدد كبير من الزيارات مشكلة ، حيث أن الخادم غير محظور ولا يتعين على عمليات العميل انتظار الردود.  لا يمكن للعميل مراقبة كيفية تشغيل البرنامج مباشرة على الخادم والمزامنة معه.  عندما تجد واجهة برمجة التطبيقات صعوبة في معالجة الطلبات ، يجب أن تقدم ردودًا معقولة.  يجب ألا ترفض الرسائل وتتجاهلها بطريقة لا يمكن التحكم فيها.  يجب أن تبلغ المكونات العليا بأنها تعمل تحت الحمل حتى يتمكنوا من تحريرها جزئيًا من هذا الحمل.  وتسمى هذه التقنية الضغط الخلفي ، وهو جانب مهم في البرمجة التفاعلية. <br><br>  شاركنا في تأليف هذا المقال مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جوش لونج</a> .  Josh هو بطل Java و Spring Developer Advocate وعموما رجل عالمي يعمل في Pivotal.  لقد عملت مع Spring لفترة طويلة ، ولكن كان Josh هو الذي أطلعني على Boot Spring ، وكان في مؤتمر Devoxx في بلجيكا.  منذ ذلك الحين ، أصبحنا أصدقاء أقوياء ، نحن مغرمون بجافا ونكتب تطبيقات رائعة. <br><br>  <b>البرمجة التفاعلية أو I / O ، I / O ، نذهب للعمل ...</b> <br><br>  البرمجة التفاعلية هي طريقة لإنشاء برنامج يستخدم الإدخال / الإخراج غير المتزامن بنشاط.  الإدخال / الإخراج غير المتزامن هي فكرة صغيرة ، محفوفة بالتغييرات الكبيرة في البرمجة.  الفكرة في حد ذاتها بسيطة: تصحيح الموقف من خلال تخصيص غير فعال للموارد ، وتحرير تلك الموارد التي كانت ستظل خامدة دون تدخلنا ، في انتظار استكمال الإدخال / الإخراج.  يؤدي الإدخال / الإخراج غير المتزامن إلى عكس الطريقة المعتادة لمعالجة I / O: يتم تحرير العميل ويمكنه القيام بمهام أخرى ، في انتظار إعلامات جديدة. <br><br>  فكر فيما هو شائع بين الإدخال / الإخراج المتزامن وغير المتزامن ، وما هي الاختلافات بينهما. <br><br>  سنقوم بكتابة برنامج بسيط يقرأ البيانات من المصدر (على وجه التحديد ، نحن نتحدث عن رابط <code>java.io.File</code> ).  لنبدأ بتنفيذ تطبيق يستخدم <code>java.io.InputStream</code> القديم الجيد: <br><br>  <i>مثال 1. قراءة البيانات من ملف بشكل متزامن</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نحن نقدم ملف للقراءة مع <code>java.io.File</code> المعتاد </li><li style=";text-align:right;direction:rtl">  اسحب النتائج من مصدر سطر واحد في وقت واحد ... </li><li style=";text-align:right;direction:rtl">  لقد كتبت هذا الرمز لاتخاذ <code>Consumer&lt;BytesPayloadgt;</code>  دعا عندما تصل البيانات الجديدة </li></ol><br>  بسيطة بما فيه الكفاية ، ماذا تقول؟  قم بتشغيل هذا الرمز وسترى في إخراج السجل (على يسار كل سطر) ، مشيرا إلى أن جميع الإجراءات تحدث في موضوع واحد. <br>  نحن هنا نستخرج البايتات من بياناتنا المأخوذة في المصدر (في هذه الحالة ، نتحدث عن فئة فرعية من <code>java.io.FileInputStream</code> الموروثة من <code>java.io.InputStream</code> ).  ما هو الخطأ في هذا المثال؟  في هذه الحالة ، نستخدم InputStream يشير إلى البيانات الموجودة على نظام الملفات لدينا.  إذا كان الملف موجودًا ، وكان القرص الصلب يعمل ، فسيعمل هذا الرمز كما هو متوقع. <br><br>  ولكن ، ماذا يحدث إذا قرأنا البيانات ليس من <code>File</code> ، ولكن من مقبس شبكة ، <code>InputStream</code> تطبيقًا آخر لـ <code>InputStream</code> ؟  لا شيء يدعو للقلق!  بالطبع ، لن يكون هناك أي شيء يدعو للقلق مطلقًا إذا كانت سرعة الشبكة عالية للغاية.  وإذا كانت قناة الشبكة بين هذه والعقدة الأخرى لا تفشل أبدا.  إذا تم استيفاء هذه الشروط ، فإن الرمز سوف يعمل بشكل مثالي. <br><br>  ولكن ماذا يحدث إذا تباطأت الشبكة أو تباطأت؟  في هذه الحالة ، أعني أننا <code>in.read(…)</code> الفترة حتى <code>in.read(…)</code> العملية <code>in.read(…)</code> .  في الواقع ، قد لا تعود على الإطلاق!  هذه مشكلة إذا حاولنا القيام بشيء آخر باستخدام الدفق الذي نقرأ منه البيانات.  بالطبع ، يمكنك دائمًا إنشاء دفق آخر وقراءة البيانات من خلاله.  يمكن القيام بذلك إلى حد ما ، لكن في النهاية ، سنصل إلى الحد الذي لم تعد فيه إضافة مؤشرات الترابط لمزيد من التوسع أكبر.  لن يكون لدينا منافسة حقيقية تتجاوز عدد النوى الموجودة على الجهاز.  طريق مسدود!  في هذه الحالة ، يمكننا زيادة معالجة المدخلات / المخرجات (القراءة تعني هنا) فقط بسبب التدفقات الإضافية ، ولكننا سنصل عاجلاً أم آجلاً إلى هذا الحد. <br><br>  في هذا المثال ، يكمن الجزء الرئيسي من العمل في القراءة - لا يحدث شيء تقريبًا على جبهات أخرى.  نحن نعتمد على I / O.  فكر في الطريقة التي يساعدنا بها الحل غير المتزامن في التغلب جزئيًا على احتكار تدفقاتنا. <br><br>  <i>مثال 2. قراءة البيانات بشكل غير متزامن من ملف</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  هذه المرة نقوم بتكييف <code>java.io.File</code> ، مما يجعل <code>Java NIO java.nio.file.Path</code> منه </li><li style=";text-align:right;direction:rtl">  عند إنشاء <code>Channel</code> ، نحدد ، على وجه الخصوص ، خدمة <code>java.util.concurrent.ExecutorService</code> ، والتي سيتم استخدامها للاتصال <code>CompletionHandler</code> CompleteHandler عند ظهور البيانات اللازمة </li><li style=";text-align:right;direction:rtl">  نبدأ القراءة بتمرير رابط إلى <code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li style=";text-align:right;direction:rtl">  في رد الاتصال ، اقرأ البايتات من <code>ByteBuffer</code> في سعة <code>byte[]</code> </li><li style=";text-align:right;direction:rtl">  تمامًا كما في المثال <code>Synchronous</code> ، يتم تمرير بيانات <code>byte[]</code> للمستهلك. </li></ol><br>  سنقوم بالحجز على الفور: لقد أصبح هذا الرمز أصعب بكثير!  هناك الكثير من الأشياء التي تحدث هنا بحيث يدور رأسك على الفور ، ولكن دعني أشير ... هذا الرمز يقرأ البيانات من <code>Java NIO Channel</code> ، ثم يعالج هذه البيانات في سلسلة رسائل منفصلة مسؤولة عن عمليات الاسترجاعات.  وبالتالي ، لا يُحتكر الدفق الذي بدأت فيه القراءة.  نعود على الفور تقريبًا بعد الاتصال <code>.read(..)</code> ، وعندما يكون لدينا أخيرًا البيانات المتوفرة لدينا ، يتم إجراء رد اتصال - موجود بالفعل في سلسلة رسائل أخرى.  إذا كان هناك تأخير بين المكالمات إلى <code>.read()</code> يمكنك الانتقال إلى مسائل أخرى عن طريق تنفيذها في سلسلة رسائلنا.  مدة عملية القراءة غير المتزامنة ، من البايت الأول إلى الأخير ، في أحسن الأحوال لم تعد أطول من عملية القراءة المتزامنة.  عادةً ما تكون العملية غير المتزامنة ضئيلة لفترة أطول.  ومع ذلك ، في مواجهة هذه الصعوبات الإضافية ، يمكننا معالجة تدفقاتنا بشكل أكثر فعالية.  القيام بالمزيد من العمل ، قم بتعدد الإدخال / الإخراج في التجمع مع عدد محدود من مؤشرات الترابط. <br><br>  أنا أعمل في شركة الحوسبة السحابية.  نود بالنسبة لك الحصول على مثيلات جديدة للتطبيق لحل مشكلات القياس الأفقي!  بالطبع ، أنا هنا مخادع بعض الشيء.  الإدخال / الإخراج غير المتزامن يعقد الأشياء قليلاً ، لكن آمل أن يوضح هذا المثال مدى فعالية التعليمات البرمجية التفاعلية: فهو يتيح لك معالجة المزيد من الطلبات والقيام بمزيد من العمل على أجهزتك الحالية إذا كان الأداء يعتمد اعتمادًا كبيرًا على I / O.  إذا كان الأداء يعتمد على استخدام المعالج (على سبيل المثال ، فنحن نتحدث عن العمليات على أرقام فيبوناتشي ، أو التنقيب عن عملات البيتكوين أو تشفيرها) ، ثم البرمجة التفاعلية لن تعطينا أي شيء. <br><br>  في الوقت الحالي ، لا يستخدم معظمنا تطبيقات <code>Channel</code> أو <code>InputStream</code> في عملنا اليومي!  علينا أن نفكر في المشاكل على مستوى التجريدات عالية المستوى.  يتعلق الأمر بأشياء مثل المصفوفات ، أو بالأحرى التسلسل الهرمي <code>java.util.Collection</code> .  يتم عرض مجموعة <code>java.util.Collection</code> بشكل جيد للغاية على InputStream: يفترض كلا الكيانين أنه يمكنك العمل على جميع البيانات في وقت واحد وعلى الفور تقريبًا.  من المتوقع أن تتمكن من إنهاء القراءة من معظم <code>InputStreams</code> وقت سابق ، وليس في وقت لاحق.  تصبح أنواع المجموعات غير مريحة قليلاً عند الانتقال إلى كميات أكبر من البيانات.  ماذا لو كنت تتعامل مع شيء غير محدود (غير محدود) - على سبيل المثال ، مآخذ الويب أو أحداث الخادم؟  ماذا تفعل إذا كان هناك تأخير بين التسجيلات؟ <br><br>  نحن بحاجة إلى طريقة أفضل لوصف هذا النوع من البيانات.  نحن نتحدث عن أحداث غير متزامنة ، من شأنها أن تحدث في النهاية.  قد يبدو أن <code>Future&lt;T&gt;</code> أو <code>CompletableFuture&lt;T&gt;</code> مناسب تمامًا لهذا الغرض ، لكنهما يصفان شيئًا واحدًا فقط يحدث في النهاية.  في الواقع ، لا توفر Java استعارة مناسبة لوصف هذا النوع من البيانات.  قد لا يكون كلا النوعين <code>Iterator</code> و <code>Stream</code> من Java 8 مرتبطين ، ولكن كلاهما موجه للسحب ؛  أنت نفسك تطلب الإدخال التالي ، وليس النوع يجب أن يرسل رد اتصال إلى الكود.  من المفترض أنه في حالة دعم المعالجة المستندة إلى الدفع في هذه الحالة ، مما سيتيح تحقيق المزيد على مستوى الخيط ، فإن API ستوفر أيضًا التحكم في عملية الجدولة والترابط.  لا تذكر تطبيقات <code>Iterator</code> شيئًا عن الترابط ، وتتشارك جميع مؤشرات ترابط Java 8 في نفس تجمع الشوكة. <br><br>  إذا كان <code>Iterator</code> و <code>Stream</code> يدعمان حقًا معالجة الدفع ، فسنواجه مشكلة أخرى تتصاعد حقًا في سياق I / O: سنحتاج إلى نوع من آلية اختراق الظهر!  نظرًا لأن مستهلك البيانات تتم معالجته بشكل غير متزامن ، فليس لدينا أي فكرة عن متى ستكون البيانات قيد الإعداد وبأي كمية.  لا نعرف مقدار البيانات التي ستحتاج إلى معالجتها في رد الاتصال التالي: بايت واحد أو تيرابايت واحد! <br><br>  عند سحب البيانات من <code>InputStream</code> ، تقرأ قدر المعلومات التي تكون جاهزًا للمعالجة ، وليس أكثر.  في الأمثلة السابقة ، نقرأ البيانات في المخزن المؤقت <code>byte[]</code> بطول ثابت ومعروف.  في سياق غير متزامن ، نحتاج إلى طريقة لإخبار المزود مقدار البيانات التي نرغب في معالجتها. <br>  نعم سيدي  هناك شيء مفقود هنا بالتأكيد. <br><br>  <b>ابحث عن الاستعارة المفقودة</b> <br><br>  في هذه الحالة ، نبحث عن استعارة تعكس بشكل جميل جوهر الإدخال / الإخراج غير المتزامن ، وتدعم مثل هذه الآلية للنقل العكسي للبيانات وتتيح لنا التحكم في تدفق التنفيذ في الأنظمة الموزعة.  في البرمجة التفاعلية ، تسمى قدرة العميل على الإشارة إلى الحمل الذي يمكنه التعامل معه "التدفق العكسي". <br><br>  يوجد الآن عدد من المشاريع الجيدة - Vert.x و Akka Streams و RxJava - تدعم البرمجة التفاعلية.  يدير فريق Spring أيضًا مشروعًا يسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Reactor</a> .  بين هذه المعايير المختلفة ، يوجد مجال عام واسع إلى حد ما ، يتم تخصيصه <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">فعليًا</a> لمعيار <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مبادرة تدفقات التفاعلات</a> .  تعرّف مبادرة الجداول التفاعلية أربعة أنواع: <br><br>  واجهة <code>Publisher&lt;T&amp;gt</code> ؛  تنتج القيم التي قد تصل في نهاية المطاف.  واجهة <code>Publisher&lt;T&amp;gt</code> ؛  ينتج قيم النوع <code>T</code> <code>Subscriber&lt;T&gt;</code> . <br><br>  <i>مثال 3. التدفقات التفاعلية: واجهة <code>Publisher&lt;T&gt;</code></i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  يشترك نوع المشترك في <code>Publisher&lt;T&gt;</code> ، ويتلقى إخطارات بأي قيم جديدة من النوع <code>T</code> خلال <code>onNext(T)</code> .  في حالة حدوث أي أخطاء ، يتم <code>onError(Throwable)</code> أسلوب <code>onError(Throwable)</code> .  عند اكتمال المعالجة بشكل طبيعي ، يتم <code>onComplete</code> طريقة <code>onComplete</code> للمشترك. <br><br>  <i>مثال 4. تدفقات Jet: واجهة <code>Subscriber&lt;T&gt;</code> .</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  عندما يتصل <code>Subscriber</code> بـ <code>Publisher</code> لأول مرة ، فإنه يتلقى <code>Subscriber#onSubscribe</code> .  الاشتراك هو ربما الجزء الأكثر أهمية في كامل المواصفات ؛  هي التي توفر تدفق العودة.  يستخدم المشترك المشترك طريقة <code>Subscription#request</code> بيانات إضافية أو طريقة <code>Subscription#cancel</code> لإيقاف المعالجة. <br><br>  <i>مثال 5. التدفقات التفاعلية: واجهة <code>Subscription&lt;T&gt;</code></i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  توفر مواصفات الدفق التفاعلي نوعًا آخر مفيدًا ، وإن كان واضحًا ،: <code>Processor&lt;A,B&gt;</code> <code>Subscriber&lt;A&gt;</code> ، <code>Subscriber&lt;A&gt;</code> هو مجرد واجهة ترث <code>Subscriber&lt;A&gt;</code> <code>Publisher&lt;B&gt;</code> . <br><br>  <i>مثال 6. تدفقات Jet: واجهة <code>Processor&lt;T&gt;</code></i> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  لا يتم تحديد المواصفة كوصفة للتنفيذ ؛ في الواقع ، الغرض منه هو تحديد أنواع لدعم التشغيل المتداخل.  تتمثل الفائدة الواضحة للأنواع المرتبطة بالتدفقات التفاعلية في أنها مع ذلك وجدت مكانًا في إصدار Java 9 ، علاوة على ذلك ، فهي تعني "واحد إلى واحد" تتوافق مع الواجهات من فئة <code>java.util.concurrent.Flow</code> ، على سبيل المثال: <code>java.util.concurrent.Flow.Publisher</code> . <br><br>  <b>تلبية مفاعل</b> <br><br>  أنواع التدفقات التفاعلية وحدها ليست كافية ؛  هناك حاجة إلى تطبيقات أعلى ترتيب لدعم عمليات مثل التصفية والتحويل.  على هذا النحو ، فإن مشروع Reactor مناسب ؛  يعتمد على مواصفات التدفقات التفاعلية ويوفر اثنين من تخصصات <code>Publisher&lt;T&gt;</code> . <br><br>  أولاً ، <code>Flux&lt;T&gt;</code> هو <code>Publisher</code> ينتج قيمًا صفرية أو أكثر.  الثاني ، <code>Mono&lt;T&gt;</code> ، هو <code>Publisher&lt;T&gt;</code> ، ينتج عنه صفر أو قيمة واحدة.  ينشر كلاهما القيم ويمكنهما التعامل معها وفقًا لذلك ، ومع ذلك ، فإن قدراتهما أوسع بكثير من مواصفات التدفقات التفاعلية.  كلاهما يوفر عوامل تشغيل تتيح لك معالجة تدفقات القيمة.  يتم تكوين أنواع المفاعلات بشكل جيد - يمكن أن يعمل إخراج أحدها كمدخلات للآخر ، وإذا احتاج نوع ما إلى العمل مع تدفقات البيانات الأخرى ، فإنهم يعتمدون على مثيلات <code>Publisher&lt;T&gt;</code> . <br><br>  تطبيق كل من <code>Mono&lt;T&gt;</code> و <code>Flux&lt;T&gt;</code> <code>Publisher&lt;T&gt;</code> ؛  نوصي بأن تقبل الأساليب الخاصة بك مثيلات <code>Publisher&lt;T&gt;</code> مع إرجاع <code>Flux&lt;T&gt;</code> أو <code>Mono&lt;T&gt;</code> ؛  هذا سيساعد العميل على التمييز بين نوع البيانات التي يتلقاها. <br><br>  افترض أنك حصلت على <code>Publisher&lt;T&gt;</code> وطُلب منك عرض واجهة المستخدم لهذا <code>Publisher&lt;T&gt;</code> .  هل ينبغي علي بعد ذلك عرض صفحة تحتوي على تفاصيل لسجل واحد ، حيث يمكنك الحصول على <code>CompletableFuture&lt;T&gt;</code> ؟  أو عرض صفحة نظرة عامة مع قائمة أو شبكة حيث يتم عرض جميع الإدخالات صفحة صفحة؟  من الصعب القول. <br><br>  بدوره ، <code>Flux&lt;T&gt;</code> و <code>Mono&lt;T&gt;</code> محددة للغاية.  أنت تعلم أنك بحاجة إلى عرض صفحة مراجعة إذا <code>Flux&lt;T&gt;</code> استلام <code>Flux&lt;T&gt;</code> ، وصفحة تحتوي على تفاصيل لسجل واحد (أو ليس واحد) عندما تتلقى <code>Mono&lt;T&gt;</code> . <br><br>  مفاعل هو مشروع مفتوح المصدر أطلقته Pivotal.  الآن أصبح يتمتع بشعبية كبيرة.  يستخدمه Facebook في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">محركه</a> النفاث <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">لاستدعاء الإجراءات عن بُعد</a> ، ويستخدمه أيضًا في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Rsocket</a> ، بقيادة RxJava Creator Ben Christensen.  Salesforce يستخدمه في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنفيذ gRPC رد الفعل</a> .  يقوم مفاعل بتنفيذ أنواع Reactive Streams ، بحيث يمكنه التفاعل مع التقنيات الأخرى التي تدعم هذه الأنواع ، على سبيل المثال ، مع <a href="">RxJava 2</a> من Netflix و <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Akka Streams</a> من Lightbend ومع مشروع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Vert.x</a> من Eclipse Foundation.  تعاون ديفيد Cairnock ، مدير RxJava 2 ، بنشاط مع Pivotal لتطوير Reactor ، مما جعل المشروع أفضل.  بالإضافة إلى ذلك ، بالطبع ، إنه موجود بشكل أو بآخر في Spring Framework ، بدءًا من Spring Framework 4.0. <br><br>  <b>البرمجة التفاعلية مع Spring WebFlux</b> <br><br>  مع كل فائدته ، فإن Reactor هو الأساس فقط.  يجب أن تتواصل تطبيقاتنا مع مصادر البيانات.  يجب أن تدعم المصادقة والترخيص.  الربيع يوفر كل هذا.  إذا أعطانا مفاعل الاستعارة المفقودة ، فإن Spring يساعدنا جميعًا على التحدث بلغة مشتركة. <br><br>  تم إصدار Spring Framework 5.0 في سبتمبر عام 2017. وهو يعتمد على مواصفات Reactive Stream.  لديها وقت تشغيل تفاعلي جديد وطراز مكون يسمى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Spring WebFlux</a> . <br><br>  Spring WebFlux مستقل عن واجهة برمجة تطبيقات Servlet ولا يتطلب منهم العمل.  يأتي مزودًا بمحولات تتيح لك استخدامه أعلى محرك Servlet إذا لزم الأمر ، ولكن هذا ليس ضروريًا.  كما يوفر وقت تشغيل يستند إلى Netty جديد يسمى Spring WebFlux.  يعد Spring Framework 5 ، الذي يعمل مع Java 8 و Java EE 7 والإصدارات الأحدث ، بمثابة الأساس لمعظم النظام البيئي Spring ، بما في ذلك Spring Data Kay و Spring Security 5 و Spring Boot 2 و Spring Cloud Finchley. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar435972/">https://habr.com/ru/post/ar435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar435960/index.html">تجربة الفكر: رفرفة على الذهاب</a></li>
<li><a href="../ar435962/index.html">الذكرى الخامسة والعشرون لـ Aeron: الأحاسيس والانطباعات حول الإصدار المحدّث من Aeron Remastered</a></li>
<li><a href="../ar435964/index.html">تخطط Ethereum لتكون اقتصادية بنسبة 99 ٪</a></li>
<li><a href="../ar435968/index.html">نظرة عامة على خوارزميات تعلم الآلة العميقة للروبوتات</a></li>
<li><a href="../ar435970/index.html">دليل المبتدئين لتطوير خادم الويب مع Node.js</a></li>
<li><a href="../ar435974/index.html">Three.js - هل الضوابط للفضاء أو القبة السماوية</a></li>
<li><a href="../ar435976/index.html">Web التجميع في الإنتاج و "حقل الألغام" من Smart TV: مقابلة مع أندريه ناجح</a></li>
<li><a href="../ar435978/index.html">حلول الحماية البيومترية</a></li>
<li><a href="../ar435984/index.html">الشبكات العصبية وفلسفة اللغة</a></li>
<li><a href="../ar435986/index.html">سوف يحتفظ Windows بـ 7 غيغابايت للحصول على تحديثات النظام لتجنب نفاد مساحة القرص الثابت</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>