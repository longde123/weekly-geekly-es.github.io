<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 👨‍👦‍👦 🌺 能源，热和水的第三部分：收音机 🔆 🌇 🍌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="参赛作品 
 在为智能家居选择解决方案的过程中，我尝试绕过需要与外部云进行通信或拥有自己的应用程序的盒装解决方案，尤其是无法直接连接到设备的解决方案。 所有可用度量标准都简化为一个界面-zabbix，在其中组织了利益相关者警报系统。 控制旋钮在本地Web界面中实现。 

 以前的文章： 
 第一部分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>能源，热和水的第三部分：收音机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467761/"><h2> 参赛作品 </h2><br> 在为智能家居选择解决方案的过程中，我尝试绕过需要与外部云进行通信或拥有自己的应用程序的盒装解决方案，尤其是无法直接连接到设备的解决方案。 所有可用度量标准都简化为一个界面-zabbix，在其中组织了利益相关者警报系统。 控制旋钮在本地Web界面中实现。 <br><br><h2> 以前的文章： </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> （1线温度，UPS，水表...） <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> （联网，gidrolock，压力传感器...） <br><br><h2> 本文中解决的任务 </h2><br><ul><li> 具有zabbix警报的可扩展，灵活的漏水保护 </li><li>  433MHz的其他设备：钟形，开门式等。 </li><li> 我们在MQTT中推1wire </li></ul><br><h2> 漏电保护系统 </h2><br><h3> 系统要求： </h3><br><ul><li> 房子周围散布着很多传感器（在我的情况下-在不同的位置有6个） </li><li> 传感器无电线 </li><li> 检测到泄漏后迅速关闭 </li><li>  zabbix中的所有当前状态信息。 有警报 </li></ul><br><h3> 系统组成 </h3><br><ul><li> 树莓派 </li><li>  RTL2832U USB调谐器 </li><li> 泄漏传感器433MHz </li><li> 用网+ gidrolock起重机（见上一篇文章）关闭行李箱 </li></ul><a name="habracut"></a><br><h3> 关于铁 </h3><br> 在上一篇文章中，我描述了使用网状网关闭供水的解决方案。 我有一个用于此解决方案的有线传感器。 如果所有可能发生泄漏的点都在大约相同的位置，则这很方便。 在我的情况下，网直接安装在高速公路的入口处，并在同一位置控制机电式自动锁式起重机（请参阅上一篇文章）。 分散的网+ gidrolock +有线传感器既昂贵又麻烦。 此外，我再也没有机会在房屋周围拖曳新电线。 在电动起重机中占用插座和呼吸是一种一般的解决方案。 预期的解决方案-我们根据分布在各个位置的无线电传感器发出的信号，使用普通公路的重叠部分。 <br> 从Internet上找到的-来自现成系统的许多不同的无线电传感器。 有些可以单独购买，我没有购买传感器控制器，以免在电路中产生其他元件。 <br><br> 如何捕捉433MHz？ 事实证明-特定芯片组上的电视调谐器。 现在他值得一分钱（我花了300r买了Avito），像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b84/efb/7c8/b84efb7c88ad3e4a89edbb470a653843.png" alt="图片"><br><br> 我在12dbi上为其订购了单独的天线，因为当前的天线无法覆盖整个房子。 <br><br> 由于我试图最小化电路的控制组件，因此一直希望通过Openwrt将调谐器拧紧到我的家庭路由器中，直到那时，这才是1wire，modbus，wifi传感器/协议的智能家庭解决方案的核心，但不幸的是，我耗尽了部分资源（内置闪存驱动器上用于必要软件的空间已用完，处理器加载了某些东西-网络已经存在问题，并且我们仍然需要4k才能在线查看:)，+ USB上已经挂了太多东西，这影响了数据收集的稳定性）。 决定逐步将智能家居的功能转移到外部设备-rarpberry pi（即将推出的第一个版本）中。 <br><br><h3> 关于软件 </h3><br> 在带有窗户的台式计算机上使用了具有sdr清晰度的电视调谐器（试图赶上别人的收音机和飞机谈判）后，我开始看看传感器本身是否看到了“回音”。 是的，它看起来很完美： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37e/68a/4d6/37e68a4d69b575f74e47db6ae45b0d4b.jpg" alt="图片"><br><br><h4> 覆盆子设置 </h4><br> 我选择了本地树莓派。 我在Mac / Linux下的USB闪存驱动器上写入了最后一个图像： <br><br><pre><code class="bash hljs">sudo dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=2019-07-10-raspbian-buster-lite.img of=/dev/disk2 bs=1048576 conv=sync</code> </pre> <br> 引导，配置网络和ssh。 <br><br> 接下来-放入树莓派包rtl-sdr，rtl_433： <br><br><pre> <code class="bash hljs">sudo apt-get install cmake build-essential python-pip libusb-1.0-0-dev libusb-1.0 python-numpy git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/merbanan/rtl_433.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> rtl_433/ mkdir build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build cmake .. make make install</code> </pre> <br>  rtl_433具有内置协议，可对来自工作在433mhz范围内的不同设备的数据进行解密。 <br><br><h4> 我们开始rtl_433 </h4><br><pre> <code class="bash hljs">rtl_433 -f 433.9e6</code> </pre> <br> 我们将传感器放到水中并得到珍惜： <br><br><pre> <code class="bash hljs">time : 2019-09-17 15:04:39 model : Smoke detector GS 558 id : 16919 unit : 1 learn : 0 Raw Code : c842e1</code> </pre><br> 烟雾探测器？ 好的，我们将这些传感器发出的警报中的歌曲“ Smoke on the water”放到警报中... :) <br> 但是请认真对待-我们拥有每个传感器的编号，根据这些编号，将来我们将了解确切的位置有泄漏（无论如何我们都会关闭）。 <br><br><h4> 关于泄漏传感器 </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/47a/255/60d/47a25560dd09554b0749dc171502c71b.png" alt="图片"><img src="https://habrastorage.org/getpro/habr/post_images/710/dd8/917/710dd891751f85699ed64c30b180c443.png" alt="图片"><img src="https://habrastorage.org/getpro/habr/post_images/b56/f4b/a31/b56f4ba310bd674da8b16171c5112806.png" alt="图片"><br><br> 设置完软件部分后，我注意到当水进入触点时，带有速卖通的传感器（左图）会发出一个信号。 如果水停止闭合触点，则再加上一个信号。 这根本不适合我（预期的行为：传感器感测到水时会不断发送警报信号，因为单个信号可能会丢失）。 如果您用导线闭合触点，则会观察到类似的行为。 但是奇怪的是-如果您用手（皮肤）合上触点，则每2-3秒会发生一次警报。 在这里，我仍然有两个假设：要么中国人搞砸了电阻测量，要么传感器有其他某种操作模式，它们的行为有所不同（例如，与控制器配对），或者还有其他频率（直到我发现） ） <br><br>  <i>顺便说一句，在评论中写下，也许有人在使用这些传感器，是否可以以某种方式“教导”他们不断发送有关泄漏的信号？</i> <br><br> 我将这些传感器放在一旁，在军火库中，还有一个来自rubetek的传感器（右图），并在勒罗伊购买了：GAL SHW-1005（中图）。 <br><br>  rubetek传感器的行为似乎完全不可预测（不可预测的反应“看到水/看不到”）。 <br><br> 但是Leroy行驶中的传感器准确显示了我所需要的：有水-我在空中发送垃圾邮件，没有水-我无语。 它唯一的缺点是其作用半径小于其他传感器。 但是通过为接收器购买更灵敏的天线解决了该问题。 <br><br><h4>  MQTT </h4><br> 如何发送rtl_433输出到zabbix？ 喂代理？ 发送到zabbix_sender，分析过程吗？ 也许通过系统日志？ <br><br> 在这里，您需要记住，我的zabbix在云端。 当然，无需借助扳机来堵住水。 房子的地板会一直淹没，直到他做出决定为止（如果有的话）。 <br><br> 好消息是rtl_433可以在MQTT上发送信息。 开箱即用。 同时，数据以json格式发送到代理。 <br><br> 因此，您需要： <br><br><ul><li> 放置一个本地蚊子经纪人（在覆盆子上做）。 </li><li> 将信息与所需主题合并到代理中，以便稍后对其进行解析。 </li><li> 在树莓派上本地连接到代理并将命令发送到网络 </li><li> 从将重定向到zabbix的位置连接到代理（在我的情况下，zabbix服务器也是MQTT客户端） </li></ul><br><h4> 安装设置mosquitto MQTT： </h4><br><pre> <code class="bash hljs">apt-get install mosquitto mosquitto-clients systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> mosquitto systemctl start mosquitto</code> </pre> <br><h4> 我们将指示设备ID的信息发送给代理： </h4><br><pre> <code class="bash hljs">rtl_433 -f 433.88e6 -F mqtt://127.0.0.1,events=/433/[id]</code> </pre> <br> 在mqtt客户端中，我们将获得以下内容： <br><br><pre> <code class="bash hljs">mosquitto_sub -h 127.0.0.1 -t <span class="hljs-string"><span class="hljs-string">'#'</span></span> (   ) /433/16919 {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-18 11:55:29"</span></span>,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Smoke detector GS 558"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:16919,<span class="hljs-string"><span class="hljs-string">"unit"</span></span>:1,<span class="hljs-string"><span class="hljs-string">"learn"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-string"><span class="hljs-string">"c842e1"</span></span>}</code> </pre> <br><h4> 连接到代理并将命令发送到网的脚本 </h4><br> 我草绘了一个简单的MQTT脚本客户端，该客户端允许您在配置中指定的主题出现时运行与该主题关联的脚本。 因此，当某个传感器被触发并且有关它的信息出现在空中时（例如/ 433/16919），您可以执行一些操作（在打网的情况下，发送curl请求关闭起重机，请参阅上一篇文章）。 脚本的链接位于文章的末尾。 <br><br><h4>  zabbix中的重定向 </h4><br> 我使用了现成的mqtt-zabbix解决方案。 在级别上，我们了解要在哪个项目中发送值（按ID）。 <br><br> 在keys.cfg中，指定： <br><br><pre> <code class="bash hljs">/433/16919,mqtt.ventilation.waterleak::hostname</code> </pre> <br> 其中hostname是在Zabbix中带有项目流浪类型的主机名。 <br><br> 重要！ 设置中的主机名应与脚本中要发送的名称相对应，项目（数据元素）的类型应适合要发送的数据（例如，对于json-文本），否则您将捕获以下形式的错误： <br><br><pre> <code class="bash hljs">2019-09-18 14:29:48,749 Got response from Zabbix: {u<span class="hljs-string"><span class="hljs-string">'info'</span></span>: u<span class="hljs-string"><span class="hljs-string">'processed: 0; failed: 1; total: 1; seconds spent: 0.000055'</span></span>, u<span class="hljs-string"><span class="hljs-string">'response'</span></span>: u<span class="hljs-string"><span class="hljs-string">'success'</span></span>}</code> </pre> <br> 而且，很难从zabbix实现更多调试（以及为什么失败）。 <br><br> 我们配置/etc/mqtt-zabbix/mqtt-zabbix.cfg（指定ip mqtt代理和zabbix服务器的地址）。 <br><br><h3> 还有什么可以连接到433的？ </h3><br>  <i>是的，什么！</i>  <i>:)</i> <br><br><h4> 气象站传感器 </h4><br> 修补无线泄漏传感器时，我意外地从气象站捕获了来自外部传感器的信号。 它看起来像这样： <br><br><pre> <code class="bash hljs">time : 2019-09-19 10:48:54 Protocol : 56 model : TFA pool temperature sensor Id : 182 Channel : 3 Temperature: 19.3 C Modulation: ASK Freq : 433.9 MHz RSSI : -0.1 dB SNR : 35.0 dB Noise : -35.2 dB time : 2019-09-20 10:57:29 Protocol : 12 brand : OS model : THN132N House Code: 4 Channel : 3 Battery : OK Celsius : 20.00 C Modulation: ASK Freq : 432.9 MHz RSSI : -0.2 dB SNR : 31.5 dB Noise : -31.7 dB</code> </pre><br> 因此，额外的好处是能够通过zabbix中的显示监视空中点的温度。 仅在某些房间，我无法拉长电缆。 <br><br><h4> 门铃 </h4><br> 许多无线电通话都在433mhz的相同频率范围内工作。 因此，我们可以拦截呼叫按钮的按下（甚至没有必要进行呼叫本身，只需按钮就足够了）。 怎么了 例如，通过SMS配置其他通知/发送电报/或在监视器上显示摄像机的图像。 <br><br> 我买了一个电话：Evology QA-688-E RU。 <br><br> 为了让rtl_433按钮看到呼叫按钮，您需要激活“测试”协议，例如，通过使用“ G”选项运行或指定特定的附加协议，同时我们将添加有关协议和频率的信息输出： <br><br><pre> <code class="bash hljs">rtl_433 -f 433.9e6 -G -M protocol -M level -F mqtt://127.0.0.1,events=/433/[id] &amp;</code> </pre> <br> 进入MQTT： <br><br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 10:57:00"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:72,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"RF-tech"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"battery"</span></span>:<span class="hljs-string"><span class="hljs-string">"LOW"</span></span>,<span class="hljs-string"><span class="hljs-string">"temperature_C"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"button"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.84822,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.5981,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.77488,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}</code> </pre> <br> 在这里您可以看到id = 0。 同时，我将几台设备确定为RF-tech。 它们的id都等于0。结果，zabbix中的所有设备都显示为一项。 可以仅通过频率来准确区分哪个设备起作用。 <br><br> 我们将频率拉到一个独立的相关项中：mqtt.outside.doorbell.freq，带有$ .freq的JSON预处理（zabbix可以从第4版开始执行此操作）。 <br><br> 在此项目上，使用以下表达式触发： <br><br><pre> <code class="bash hljs">{HOME_PI:mqtt.outside.doorbell.freq.last()}&gt;433.8 and {HOME_PI:mqtt.outside.doorbell.freq.last()}&lt;433.81 and {HOME_PI:mqtt.outside.doorbell.freq.nodata(30)}=0</code> </pre> <br> 即 如果突然在常规项目mqtt.outside.doorbell.freq（无数据）中出现一个值，并且频率在433.8和433.81之间的指定范围内，我们可以得出结论，他们正在给我们打电话（例如，复制对SMS的呼叫）。 <br><br><h4> 门/窗传感器 </h4><br> 我有来自rubetek的渗透传感器。 发送以下内容： <br><br><pre> <code class="bash hljs">{<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:28"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:86,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Smoke detector GS 558"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:12262,<span class="hljs-string"><span class="hljs-string">"unit"</span></span>:16,<span class="hljs-string"><span class="hljs-string">"learn"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-string"><span class="hljs-string">"e5fcd0"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85021,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.99241,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.38058,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}  : {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:28"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:68,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Kerui Security"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:46074,<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>:7,<span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"close"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85021,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-3.99241,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:33.38058,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-37.373}  : {<span class="hljs-string"><span class="hljs-string">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-09-30 14:11:21"</span></span>,<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>:68,<span class="hljs-string"><span class="hljs-string">"model"</span></span>:<span class="hljs-string"><span class="hljs-string">"Kerui Security"</span></span>,<span class="hljs-string"><span class="hljs-string">"id"</span></span>:46074,<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>:14,<span class="hljs-string"><span class="hljs-string">"state"</span></span>:<span class="hljs-string"><span class="hljs-string">"open"</span></span>,<span class="hljs-string"><span class="hljs-string">"mod"</span></span>:<span class="hljs-string"><span class="hljs-string">"ASK"</span></span>,<span class="hljs-string"><span class="hljs-string">"freq"</span></span>:433.85005,<span class="hljs-string"><span class="hljs-string">"rssi"</span></span>:-11.0148,<span class="hljs-string"><span class="hljs-string">"snr"</span></span>:25.1088,<span class="hljs-string"><span class="hljs-string">"noise"</span></span>:-36.1236}</code> </pre> <br> 将最后一个无线电传感器添加到zabbix后，我想重做MQTT上的所有内容。 方便的分类，您可以确定主题-ah以及设备的放置和类型。 您将获得所有事件的一般广播。 <br><br><h2>  1wire至MQTT </h2><br> 我希望一切都在MQTT中，至少对于相同类型的实现而言。 我想获得事件的一般“醚”和对这些事件做出反应的一般方法。 当然，zabbix解决了反应问题，我对此发出了警告。 但是我想使管理更加轻松，更接近系统和“以太”。 <br><br> 存在将传感器状态从1wire网络中继到MQTT的现成解决方案，但它们不适合我。 节点上现成的解决方案要么在其背后带有一堆依赖项，要么吃掉了整个树莓派处理器。 作者放弃了Google搜索中排名前10位的某些解决方案，而某些解决方案仅受温度传感器支持。 还有一类网关通过gpio接口收集信息。 这一切都不适合我。 <br><br> 我在/ mnt / 1wire中有一个装有1wire设备的伪文件系统，我想从那里获取所有必要的信息。 为此，只需在bash上制作一条简单的一行就可以了，并通过mosquitto_pub为每个传感器发送数据。 但是，会出现以下问题：启动这些脚本（从顶部开始，驱动到某种守护进程？），数据的正常表示（获取相同的json），添加新的传感器等。这种想法发展得越深，拐杖就越多。 事实证明，为该任务编写到mqtt的另一个owfs的网关更加容易。 <br><br> 有一个配置文件，我们需要在其中输入传感器的ID，以及我们要发布到mqtt的来自fuse.OWFS的文件。 <br><br>  mqtt中的输出是以下json： <br><br><pre> <code class="bash hljs">/1wire/28.0425260a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"30"</span></span>} /1wire/28.bf16270a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"7.9375"</span></span>} /1wire/26.da2f71010000 {<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"25.2812"</span></span>, <span class="hljs-string"><span class="hljs-string">"IAD"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"CA"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"VAD"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.91"</span></span>, <span class="hljs-string"><span class="hljs-string">"VDD"</span></span>: <span class="hljs-string"><span class="hljs-string">"4.59"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS2438"</span></span>} /1wire/28.48b3010b0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"40.5625"</span></span>} /1wire/1d.6a9306000000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS2423"</span></span>, <span class="hljs-string"><span class="hljs-string">"counter.B"</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>, <span class="hljs-string"><span class="hljs-string">"counter.A"</span></span>: <span class="hljs-string"><span class="hljs-string">"9219"</span></span>} /1wire/28.61cc260a0000 {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>, <span class="hljs-string"><span class="hljs-string">"temperature"</span></span>: <span class="hljs-string"><span class="hljs-string">"12.5"</span></span>}</code> </pre> <br> 添加到自动运行，设置轮询间隔。 问题解决了。 <br><br><h3> 参考文献 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/merbanan/rtl_433-</a>用于解码无线电协议的工具 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/kylegordon/mqtt-zabbix-Zabbix上的</a> MQTT <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/unlo/1wire2mqtt-MQTT中的</a> 1wire，MQTT客户端，允许您在出现主题时运行脚本 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467761/">https://habr.com/ru/post/zh-CN467761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467749/index.html">GCP：解析Google Cloud Platform计算堆栈</a></li>
<li><a href="../zh-CN467751/index.html">分散式信使如何在区块链上</a></li>
<li><a href="../zh-CN467753/index.html">无线数据传输的世界纪录：每11公里40 Gb / s</a></li>
<li><a href="../zh-CN467755/index.html">ions病毒，钙，微生物群，食物激素和阿尔茨海默氏症</a></li>
<li><a href="../zh-CN467759/index.html">类似于Unix的OS设计-虚拟地址空间（6）</a></li>
<li><a href="../zh-CN467763/index.html">关于RTOS的全部真相。 第三十三条 使用Nucleus SE实时操作系统</a></li>
<li><a href="../zh-CN467765/index.html">Wi-Fi和许多其他缩写。 如何在Android应用程序中的Wi-Fi节点上获取数据而不会膨胀</a></li>
<li><a href="../zh-CN467767/index.html">JSON-RPC关注者的更多便利设施</a></li>
<li><a href="../zh-CN467769/index.html">在包含人口信息的单一联邦信息资源上</a></li>
<li><a href="../zh-CN467771/index.html">就像绿色的初级自动重新加载器一样，他写了<s> hot </ s>。 第2部分。CSS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>