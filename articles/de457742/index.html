<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏻 😞 🔜 Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden für hohe Verfügbarkeit und Verfügbarkeit der Infrastruktur 🍌 👌🏾 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gruß, Chabrowiten! Die Übersetzung des folgenden Artikels wurde speziell für Studenten des Kubernetes-basierten Infrastructure Platform- Kurses erstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden für hohe Verfügbarkeit und Verfügbarkeit der Infrastruktur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457742/">  Gruß, Chabrowiten!  Die Übersetzung des folgenden Artikels wurde speziell für Studenten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes-basierten Infrastructure Platform-</a> Kurses erstellt, der morgen mit dem Unterricht beginnen wird.  Fangen wir an. <br><br><img src="https://habrastorage.org/webt/ex/tr/ly/extrlyzx2l86vdau8i-upyejtf4.png"><br><br><h3>  Autoskalierung in Kubernetes </h3><br>  Mit der automatischen Skalierung können Sie die Arbeitslast je nach Ressourcennutzung automatisch erhöhen und verringern. <br><br>  Die automatische Skalierung von Kubernetes hat zwei Dimensionen: <br><br><ul><li>  Cluster Autoscaler, der für die Skalierung der Knoten verantwortlich ist; </li><li>  Horizontal Pod Autoscaler (HPA), der automatisch die Anzahl der Herde in einem Bereitstellungs- oder Replikatsatz skaliert. </li></ul><br>  Die automatische Skalierung von Clustern kann in Verbindung mit der automatischen Skalierung von horizontalen Herden verwendet werden, um die Rechenressourcen und den Grad der Systemgleichzeitigkeit, die zur Einhaltung von Service Level Agreements (SLAs) erforderlich sind, dynamisch zu steuern. <a name="habracut"></a><br><br>  Die automatische Skalierung von Clustern hängt stark von den Funktionen des Cloud-Infrastrukturanbieters ab, der den Cluster hostet, und HPA kann unabhängig vom IaaS / PaaS-Anbieter betrieben werden. <br><br><h3>  HPA-Entwicklung </h3><br>  Die automatische Skalierung des horizontalen Herdes hat seit der Einführung von Kubernetes v1.1 wesentliche Änderungen erfahren.  Die erste Version von HPA skalierte Herde basierend auf dem gemessenen CPU-Verbrauch und später basierend auf der Speichernutzung.  Kubernetes 1.6 führte eine neue API namens Custom Metrics ein, die HPA-Zugriff auf benutzerdefinierte Metriken ermöglichte.  Kubernetes 1.7 hat eine Aggregationsebene hinzugefügt, mit der Anwendungen von Drittanbietern die Kubernetes-API durch Registrierung als API-Add-Ons erweitern können. <br><br>  Dank der API für benutzerdefinierte Metriken und der Aggregationsebene können Überwachungssysteme wie Prometheus dem HPA-Controller anwendungsspezifische Metriken bereitstellen. <br><br>  Die automatische Skalierung des horizontalen Herdes wird als Regelkreis implementiert, der regelmäßig die Ressourcenmetrik-API (Ressourcenmetrik-API) nach Schlüsselmetriken wie CPU- und Speichernutzung und die Benutzerdefinierte Metrik-API (Benutzerdefinierte Metrik-API) nach bestimmten Anwendungsmetriken abfragt. <br><br><img src="https://habrastorage.org/webt/j3/7c/-b/j37c-bs-leoz4u_a8tg6ov6zflu.png"><br><br>  Im Folgenden finden Sie eine schrittweise Anleitung zum Konfigurieren von HPA v2 für Kubernetes 1.9 und höher. <br><br><ol><li>  Installieren Sie das Metrics Server-Add-In, das wichtige Metriken bereitstellt. </li><li>  Starten Sie eine Demo-Anwendung, um zu sehen, wie die automatische Skalierung des Herdes basierend auf der CPU- und Speicherauslastung funktioniert. </li><li>  Stellen Sie den Prometheus- und den benutzerdefinierten API-Server bereit.  Registrieren Sie einen benutzerdefinierten API-Server auf Aggregationsebene. </li><li>  Konfigurieren Sie HPA mithilfe von benutzerdefinierten Metriken, die von der Demoanwendung bereitgestellt werden. </li></ol><br>  Bevor Sie beginnen, müssen Sie Go Version 1.8 (oder höher) installieren und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k8s-prom-hpa-Repository</a> in <code>GOPATH</code> : <br><br><pre> <code class="go hljs">cd $GOPATH git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/stefanprodan/k8s-prom-hpa</span></span></code> </pre> <br><h2>  1. Einrichten des Metrikservers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metric</a> Server ist der Cluster-Aggregator für Ressourcenauslastungsdaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">innerhalb des</a> Clusters, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heapster</a> ersetzt.  Der <code>kubernetes.summary_api</code> sammelt Informationen zur CPU- und Speichernutzung für Knoten und Herde von <code>kubernetes.summary_api</code> .  Die Zusammenfassungs-API ist eine speichereffiziente API zum Übertragen von Kubelet / cAdvisor-Datenmetriken an einen Server. <br><br><img src="https://habrastorage.org/webt/a-/ks/a5/a-ksa5k66aqr8auak_onalu3jki.png"><br><br>  In der ersten Version von HPA wurde ein Heapster-Aggregator benötigt, um die CPU und den Speicher abzurufen.  In HPA v2 und Kubernetes 1.8 ist nur ein <code>horizontal-pod-autoscaler-use-rest-clients</code> aktivierten <code>horizontal-pod-autoscaler-use-rest-clients</code> erforderlich.  Diese Option ist in Kubernetes 1.9 standardmäßig aktiviert.  GKE 1.9 wird mit einem vorinstallierten Metrikserver geliefert. <br><br>  Erweitern Sie den <code>kube-system</code> Namespace des <code>kube-system</code> : <br><br><pre> <code class="go hljs">kubectl create -f ./metrics-server</code> </pre> <br>  Nach 1 Minute beginnt der <code>metric-server</code> mit der Übertragung von Daten über die Nutzung der CPU und des Speichers durch Knoten und Pods. <br><br>  Knotenmetriken anzeigen: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/metrics.k8s.io/v1beta1/nodes"</span></span> | jq .</code> </pre> <br>  Herzfrequenzindikatoren anzeigen: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/metrics.k8s.io/v1beta1/pods"</span></span> | jq .</code> </pre> <br><h2>  2. Automatische Skalierung basierend auf CPU- und Speicherauslastung </h2><br>  Zum Testen der horizontalen automatischen Skalierung (HPA) von Herden können Sie eine kleine Golang-basierte Webanwendung verwenden. <br><br>  Erweitern Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">podinfo</a> im <code>default</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml</code> </pre> <br>  <code>podinfo</code> über den NodePort-Dienst unter <code>http://&lt;K8S_PUBLIC_IP&gt;:31198</code> . <br><br>  Geben Sie einen HPA an, der mindestens zwei Replikate bereitstellt, und skalieren Sie ihn auf zehn Replikate, wenn die durchschnittliche CPU-Auslastung 80% überschreitet oder der Speicherverbrauch über 200 MiB liegt: <br><br><pre> <code class="go hljs">apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: podinfo spec: scaleTargetRef: apiVersion: extensions/v1beta1 kind: Deployment name: podinfo minReplicas: <span class="hljs-number"><span class="hljs-number">2</span></span> maxReplicas: <span class="hljs-number"><span class="hljs-number">10</span></span> metrics: - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resource resource: name: cpu targetAverageUtilization: <span class="hljs-number"><span class="hljs-number">80</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resource resource: name: memory targetAverageValue: <span class="hljs-number"><span class="hljs-number">200</span></span>Mi</code> </pre> <br>  HPA erstellen: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-hpa.yaml</code> </pre> <br>  Nach einigen Sekunden kontaktiert der HPA-Controller den Metrikserver und erhält Informationen zur CPU- und Speichernutzung: <br><br><pre> <code class="go hljs">kubectl get hpa NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE podinfo Deployment/podinfo <span class="hljs-number"><span class="hljs-number">2826240</span></span> / <span class="hljs-number"><span class="hljs-number">200</span></span>Mi, <span class="hljs-number"><span class="hljs-number">15</span></span>% / <span class="hljs-number"><span class="hljs-number">80</span></span>% <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>m</code> </pre> <br>  Führen Sie einen Auslastungstest mit rakyll / hey durch, um die CPU-Auslastung zu erhöhen: <br><br><pre> <code class="go hljs">#install hey <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get -u github.com/rakyll/hey #do <span class="hljs-number"><span class="hljs-number">10</span></span>K requests hey -n <span class="hljs-number"><span class="hljs-number">10000</span></span> -q <span class="hljs-number"><span class="hljs-number">10</span></span> -c <span class="hljs-number"><span class="hljs-number">5</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//&lt;K8S_PUBLIC_IP&gt;:31198/</span></span></code> </pre> <br>  Sie können HPA-Ereignisse wie folgt überwachen: <br><br><pre> <code class="go hljs">$ kubectl describe hpa Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">7</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">4</span></span>; reason: cpu resource utilization (percentage of request) above target Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">3</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">8</span></span>; reason: cpu resource utilization (percentage of request) above target</code> </pre> <br>  Entfernen Sie podinfo vorübergehend (Sie müssen es in einem der nächsten Schritte dieses Handbuchs erneut bereitstellen). <br><br><pre> <code class="go hljs">kubectl <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span> -f ./podinfo/podinfo-hpa.yaml,./podinfo/podinfo-dep.yaml,./podinfo/podinfo-svc.yaml</code> </pre> <br><h2>  3. Benutzerdefiniertes Metrics Server-Setup </h2><br>  Für die Skalierung basierend auf benutzerdefinierten Metriken werden zwei Komponenten benötigt.  Die erste - die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-</a> Zeitreihendatenbank - sammelt Anwendungsmetriken und speichert sie.  Die zweite Komponente, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k8s-prometheus-Adapter</a> , ergänzt die benutzerdefinierten Metriken-API-Kubernetes mit vom Builder bereitgestellten Metriken. <br><br><img src="https://habrastorage.org/webt/hf/g5/-j/hfg5-js5hf_5ldfgkrhk0dwgfu0.png"><br><br>  Ein dedizierter Namespace wird verwendet, um Prometheus und den Adapter bereitzustellen. <br><br>  Erstellen Sie einen <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./namespaces.yaml</code> </pre> <br>  Erweitern Sie Prometheus v2 im <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./prometheus</code> </pre> <br>  Generieren Sie die für den Prometheus-Adapter erforderlichen TLS-Zertifikate: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> certs</code> </pre> <br>  Stellen Sie den Prometheus-Adapter für die API für benutzerdefinierte Metriken bereit: <br><br><pre> <code class="go hljs">kubectl create -f ./custom-metrics-api</code> </pre> <br>  Holen Sie sich eine Liste der von Prometheus bereitgestellten speziellen Metriken: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1"</span></span> | jq .</code> </pre> <br>  Extrahieren Sie dann die Dateisystem-Nutzungsdaten für alle Pods im <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/monitoring/pods/*/fs_usage_bytes"</span></span> | jq .</code> </pre> <br><h2>  4. Automatische Skalierung basierend auf benutzerdefinierten Metriken </h2><br>  Erstellen Sie den NodePort- <code>podinfo</code> Dienst und stellen Sie ihn im <code>default</code> Namespace <code>podinfo</code> : <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml</code> </pre> <br>  Die <code>podinfo</code> Anwendung <code>podinfo</code> die spezielle Metrik <code>http_requests_total</code> .  Der Prometheus-Adapter entfernt das Suffix <code>_total</code> und markiert diese Metrik als Zähler. <br><br>  Rufen Sie die Gesamtzahl der Abfragen pro Sekunde über die API für benutzerdefinierte Metriken ab: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests"</span></span> | jq . { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"MetricValueList"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom.metrics.k8s.io/v1beta1"</span></span>, <span class="hljs-string"><span class="hljs-string">"metadata"</span></span>: { <span class="hljs-string"><span class="hljs-string">"selfLink"</span></span>: <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/%2A/http_requests"</span></span> }, <span class="hljs-string"><span class="hljs-string">"items"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"describedObject"</span></span>: { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-string"><span class="hljs-string">"default"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"podinfo-6b86c8ccc9-kv5g9"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"/__internal"</span></span> }, <span class="hljs-string"><span class="hljs-string">"metricName"</span></span>: <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-10T16:49:07Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"901m"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"describedObject"</span></span>: { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-string"><span class="hljs-string">"default"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"podinfo-6b86c8ccc9-nm7bl"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"/__internal"</span></span> }, <span class="hljs-string"><span class="hljs-string">"metricName"</span></span>: <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-10T16:49:07Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"898m"</span></span> } ] }</code> </pre> <br>  Der Buchstabe <code>m</code> bedeutet <code>901m</code> , so dass beispielsweise 901 <code>901m</code> 901 Millisekunden sind. <br><br>  Erstellen Sie eine HPA, die die Podinfo-Bereitstellung erweitert, wenn die Anzahl der Anforderungen 10 Anforderungen pro Sekunde überschreitet: <br><br><pre> <code class="go hljs">apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: podinfo spec: scaleTargetRef: apiVersion: extensions/v1beta1 kind: Deployment name: podinfo minReplicas: <span class="hljs-number"><span class="hljs-number">2</span></span> maxReplicas: <span class="hljs-number"><span class="hljs-number">10</span></span> metrics: - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Pods pods: metricName: http_requests targetAverageValue: <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Erweitern Sie HPA <code>podinfo</code> im <code>default</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-hpa-custom.yaml</code> </pre> <br>  Nach einigen Sekunden erhält der HPA den Wert <code>http_requests</code> von der Metrik-API: <br><br><pre> <code class="go hljs">kubectl get hpa NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE podinfo Deployment/podinfo <span class="hljs-number"><span class="hljs-number">899</span></span>m / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>m</code> </pre> <br>  Wenden Sie die Last für den Podinfo-Dienst mit 25 Anforderungen pro Sekunde an: <br><br><pre> <code class="go hljs">#install hey <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get -u github.com/rakyll/hey #do <span class="hljs-number"><span class="hljs-number">10</span></span>K requests rate limited at <span class="hljs-number"><span class="hljs-number">25</span></span> QPS hey -n <span class="hljs-number"><span class="hljs-number">10000</span></span> -q <span class="hljs-number"><span class="hljs-number">5</span></span> -c <span class="hljs-number"><span class="hljs-number">5</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//&lt;K8S-IP&gt;:31198/healthz</span></span></code> </pre> <br>  Nach einigen Minuten beginnt der HPA mit der Skalierung der Bereitstellung: <br><br><pre> <code class="go hljs">kubectl describe hpa Name: podinfo Namespace: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Reference: Deployment/podinfo Metrics: ( current / target ) <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span> on pods: <span class="hljs-number"><span class="hljs-number">9059</span></span>m / <span class="hljs-number"><span class="hljs-number">10</span></span>&lt; Min replicas: <span class="hljs-number"><span class="hljs-number">2</span></span> Max replicas: <span class="hljs-number"><span class="hljs-number">10</span></span> Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">2</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">3</span></span>; reason: pods metric http_requests above target</code> </pre> <br>  Bei der aktuellen Anzahl von Anforderungen pro Sekunde erreicht die Bereitstellung niemals maximal 10 Pods.  Drei Replikate reichen aus, um sicherzustellen, dass die Anzahl der Anforderungen pro Sekunde für jeden Pod weniger als 10 beträgt. <br><br>  Nach Abschluss der Auslastungstests reduziert HPA die Bereitstellungsskala auf die anfängliche Anzahl von Replikaten: <br><br><pre> <code class="go hljs">Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">5</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">3</span></span>; reason: pods metric http_requests above target Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">21s</span></span> horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">2</span></span>; reason: All metrics below target</code> </pre> <br>  Möglicherweise haben Sie bemerkt, dass der automatische Skalierer nicht sofort auf Änderungen der Metriken reagiert.  Standardmäßig werden sie alle 30 Sekunden synchronisiert.  Darüber hinaus erfolgt die Skalierung nur, wenn die Arbeitslast in den letzten 3 bis 5 Minuten nicht erhöht oder verringert wurde.  Dies hilft, widersprüchliche Entscheidungen zu vermeiden, und lässt Zeit, um den Auto-Scaler des Clusters zu verbinden. <br><br><h2>  Fazit </h2><br>  Nicht alle Systeme können die SLA-Konformität nur auf der Grundlage der CPU- oder Speicherauslastung (oder beider) erzwingen.  Die meisten Webserver und mobilen Server zur Verarbeitung von Verkehrsspitzen benötigen eine automatische Skalierung basierend auf der Anzahl der Anforderungen pro Sekunde. <br><br>  Für ETL-Anwendungen (aus dem Eng. Extract Transform Load - „Extrahieren, Transformieren, Laden“) kann die automatische Skalierung beispielsweise ausgelöst werden, wenn die angegebene Schwellenlänge der Jobwarteschlange überschritten wird. <br><br>  In allen Fällen können Sie durch Instrumentieren von Anwendungen mit Prometheus und Hervorheben der erforderlichen Indikatoren für die automatische Skalierung die Anwendungen optimieren, um die Verarbeitung von Verkehrsspitzen zu verbessern und eine hohe Verfügbarkeit der Infrastruktur sicherzustellen. <br><br>  Ideen, Fragen, Kommentare?  Nehmen Sie an der Diskussion bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack teil</a> ! <br><br>  Hier ist so ein Material.  Wir warten auf Ihre Kommentare und sehen uns auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurs</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457742/">https://habr.com/ru/post/de457742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457728/index.html">Hash-Tabellen in Go. Implementierungsdetails</a></li>
<li><a href="../de457730/index.html">Im Büro gibt es eine Illusion der Kontrolle - es ist nicht auf der Fernbedienung. Gespräch mit Devhab</a></li>
<li><a href="../de457734/index.html">Italien Open Source Revolution beginnt</a></li>
<li><a href="../de457736/index.html">"Tools sind nicht so wichtig wie die Fähigkeit, über die von ihnen erstellten Systeme nachzudenken." Tolles Interview mit Martin Kleppman</a></li>
<li><a href="../de457738/index.html">Wie wir SD-Access implementiert haben und warum es benötigt wurde</a></li>
<li><a href="../de457744/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek - Teil 2</a></li>
<li><a href="../de457746/index.html">Meteorologie und Flüge</a></li>
<li><a href="../de457750/index.html">Arbeiten Sie mit JSON RPC in Symfony 4</a></li>
<li><a href="../de457752/index.html">Keine Mondrover und keine Joker. Was wissen wir über Roboter in Fukushima?</a></li>
<li><a href="../de457754/index.html">Staats- und T-Killer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>