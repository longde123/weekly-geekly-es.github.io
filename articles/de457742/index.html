<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèª üòû üîú Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden f√ºr hohe Verf√ºgbarkeit und Verf√ºgbarkeit der Infrastruktur üçå üëåüèæ üêÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gru√ü, Chabrowiten! Die √úbersetzung des folgenden Artikels wurde speziell f√ºr Studenten des Kubernetes-basierten Infrastructure Platform- Kurses erstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Horizontale automatische Skalierung von Kubernetes- und Prometheus-Herden f√ºr hohe Verf√ºgbarkeit und Verf√ºgbarkeit der Infrastruktur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457742/">  Gru√ü, Chabrowiten!  Die √úbersetzung des folgenden Artikels wurde speziell f√ºr Studenten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes-basierten Infrastructure Platform-</a> Kurses erstellt, der morgen mit dem Unterricht beginnen wird.  Fangen wir an. <br><br><img src="https://habrastorage.org/webt/ex/tr/ly/extrlyzx2l86vdau8i-upyejtf4.png"><br><br><h3>  Autoskalierung in Kubernetes </h3><br>  Mit der automatischen Skalierung k√∂nnen Sie die Arbeitslast je nach Ressourcennutzung automatisch erh√∂hen und verringern. <br><br>  Die automatische Skalierung von Kubernetes hat zwei Dimensionen: <br><br><ul><li>  Cluster Autoscaler, der f√ºr die Skalierung der Knoten verantwortlich ist; </li><li>  Horizontal Pod Autoscaler (HPA), der automatisch die Anzahl der Herde in einem Bereitstellungs- oder Replikatsatz skaliert. </li></ul><br>  Die automatische Skalierung von Clustern kann in Verbindung mit der automatischen Skalierung von horizontalen Herden verwendet werden, um die Rechenressourcen und den Grad der Systemgleichzeitigkeit, die zur Einhaltung von Service Level Agreements (SLAs) erforderlich sind, dynamisch zu steuern. <a name="habracut"></a><br><br>  Die automatische Skalierung von Clustern h√§ngt stark von den Funktionen des Cloud-Infrastrukturanbieters ab, der den Cluster hostet, und HPA kann unabh√§ngig vom IaaS / PaaS-Anbieter betrieben werden. <br><br><h3>  HPA-Entwicklung </h3><br>  Die automatische Skalierung des horizontalen Herdes hat seit der Einf√ºhrung von Kubernetes v1.1 wesentliche √Ñnderungen erfahren.  Die erste Version von HPA skalierte Herde basierend auf dem gemessenen CPU-Verbrauch und sp√§ter basierend auf der Speichernutzung.  Kubernetes 1.6 f√ºhrte eine neue API namens Custom Metrics ein, die HPA-Zugriff auf benutzerdefinierte Metriken erm√∂glichte.  Kubernetes 1.7 hat eine Aggregationsebene hinzugef√ºgt, mit der Anwendungen von Drittanbietern die Kubernetes-API durch Registrierung als API-Add-Ons erweitern k√∂nnen. <br><br>  Dank der API f√ºr benutzerdefinierte Metriken und der Aggregationsebene k√∂nnen √úberwachungssysteme wie Prometheus dem HPA-Controller anwendungsspezifische Metriken bereitstellen. <br><br>  Die automatische Skalierung des horizontalen Herdes wird als Regelkreis implementiert, der regelm√§√üig die Ressourcenmetrik-API (Ressourcenmetrik-API) nach Schl√ºsselmetriken wie CPU- und Speichernutzung und die Benutzerdefinierte Metrik-API (Benutzerdefinierte Metrik-API) nach bestimmten Anwendungsmetriken abfragt. <br><br><img src="https://habrastorage.org/webt/j3/7c/-b/j37c-bs-leoz4u_a8tg6ov6zflu.png"><br><br>  Im Folgenden finden Sie eine schrittweise Anleitung zum Konfigurieren von HPA v2 f√ºr Kubernetes 1.9 und h√∂her. <br><br><ol><li>  Installieren Sie das Metrics Server-Add-In, das wichtige Metriken bereitstellt. </li><li>  Starten Sie eine Demo-Anwendung, um zu sehen, wie die automatische Skalierung des Herdes basierend auf der CPU- und Speicherauslastung funktioniert. </li><li>  Stellen Sie den Prometheus- und den benutzerdefinierten API-Server bereit.  Registrieren Sie einen benutzerdefinierten API-Server auf Aggregationsebene. </li><li>  Konfigurieren Sie HPA mithilfe von benutzerdefinierten Metriken, die von der Demoanwendung bereitgestellt werden. </li></ol><br>  Bevor Sie beginnen, m√ºssen Sie Go Version 1.8 (oder h√∂her) installieren und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k8s-prom-hpa-Repository</a> in <code>GOPATH</code> : <br><br><pre> <code class="go hljs">cd $GOPATH git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/stefanprodan/k8s-prom-hpa</span></span></code> </pre> <br><h2>  1. Einrichten des Metrikservers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metric</a> Server ist der Cluster-Aggregator f√ºr Ressourcenauslastungsdaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">innerhalb des</a> Clusters, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heapster</a> ersetzt.  Der <code>kubernetes.summary_api</code> sammelt Informationen zur CPU- und Speichernutzung f√ºr Knoten und Herde von <code>kubernetes.summary_api</code> .  Die Zusammenfassungs-API ist eine speichereffiziente API zum √úbertragen von Kubelet / cAdvisor-Datenmetriken an einen Server. <br><br><img src="https://habrastorage.org/webt/a-/ks/a5/a-ksa5k66aqr8auak_onalu3jki.png"><br><br>  In der ersten Version von HPA wurde ein Heapster-Aggregator ben√∂tigt, um die CPU und den Speicher abzurufen.  In HPA v2 und Kubernetes 1.8 ist nur ein <code>horizontal-pod-autoscaler-use-rest-clients</code> aktivierten <code>horizontal-pod-autoscaler-use-rest-clients</code> erforderlich.  Diese Option ist in Kubernetes 1.9 standardm√§√üig aktiviert.  GKE 1.9 wird mit einem vorinstallierten Metrikserver geliefert. <br><br>  Erweitern Sie den <code>kube-system</code> Namespace des <code>kube-system</code> : <br><br><pre> <code class="go hljs">kubectl create -f ./metrics-server</code> </pre> <br>  Nach 1 Minute beginnt der <code>metric-server</code> mit der √úbertragung von Daten √ºber die Nutzung der CPU und des Speichers durch Knoten und Pods. <br><br>  Knotenmetriken anzeigen: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/metrics.k8s.io/v1beta1/nodes"</span></span> | jq .</code> </pre> <br>  Herzfrequenzindikatoren anzeigen: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/metrics.k8s.io/v1beta1/pods"</span></span> | jq .</code> </pre> <br><h2>  2. Automatische Skalierung basierend auf CPU- und Speicherauslastung </h2><br>  Zum Testen der horizontalen automatischen Skalierung (HPA) von Herden k√∂nnen Sie eine kleine Golang-basierte Webanwendung verwenden. <br><br>  Erweitern Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">podinfo</a> im <code>default</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml</code> </pre> <br>  <code>podinfo</code> √ºber den NodePort-Dienst unter <code>http://&lt;K8S_PUBLIC_IP&gt;:31198</code> . <br><br>  Geben Sie einen HPA an, der mindestens zwei Replikate bereitstellt, und skalieren Sie ihn auf zehn Replikate, wenn die durchschnittliche CPU-Auslastung 80% √ºberschreitet oder der Speicherverbrauch √ºber 200 MiB liegt: <br><br><pre> <code class="go hljs">apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: podinfo spec: scaleTargetRef: apiVersion: extensions/v1beta1 kind: Deployment name: podinfo minReplicas: <span class="hljs-number"><span class="hljs-number">2</span></span> maxReplicas: <span class="hljs-number"><span class="hljs-number">10</span></span> metrics: - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resource resource: name: cpu targetAverageUtilization: <span class="hljs-number"><span class="hljs-number">80</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Resource resource: name: memory targetAverageValue: <span class="hljs-number"><span class="hljs-number">200</span></span>Mi</code> </pre> <br>  HPA erstellen: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-hpa.yaml</code> </pre> <br>  Nach einigen Sekunden kontaktiert der HPA-Controller den Metrikserver und erh√§lt Informationen zur CPU- und Speichernutzung: <br><br><pre> <code class="go hljs">kubectl get hpa NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE podinfo Deployment/podinfo <span class="hljs-number"><span class="hljs-number">2826240</span></span> / <span class="hljs-number"><span class="hljs-number">200</span></span>Mi, <span class="hljs-number"><span class="hljs-number">15</span></span>% / <span class="hljs-number"><span class="hljs-number">80</span></span>% <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>m</code> </pre> <br>  F√ºhren Sie einen Auslastungstest mit rakyll / hey durch, um die CPU-Auslastung zu erh√∂hen: <br><br><pre> <code class="go hljs">#install hey <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get -u github.com/rakyll/hey #do <span class="hljs-number"><span class="hljs-number">10</span></span>K requests hey -n <span class="hljs-number"><span class="hljs-number">10000</span></span> -q <span class="hljs-number"><span class="hljs-number">10</span></span> -c <span class="hljs-number"><span class="hljs-number">5</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//&lt;K8S_PUBLIC_IP&gt;:31198/</span></span></code> </pre> <br>  Sie k√∂nnen HPA-Ereignisse wie folgt √ºberwachen: <br><br><pre> <code class="go hljs">$ kubectl describe hpa Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">7</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">4</span></span>; reason: cpu resource utilization (percentage of request) above target Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">3</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">8</span></span>; reason: cpu resource utilization (percentage of request) above target</code> </pre> <br>  Entfernen Sie podinfo vor√ºbergehend (Sie m√ºssen es in einem der n√§chsten Schritte dieses Handbuchs erneut bereitstellen). <br><br><pre> <code class="go hljs">kubectl <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span> -f ./podinfo/podinfo-hpa.yaml,./podinfo/podinfo-dep.yaml,./podinfo/podinfo-svc.yaml</code> </pre> <br><h2>  3. Benutzerdefiniertes Metrics Server-Setup </h2><br>  F√ºr die Skalierung basierend auf benutzerdefinierten Metriken werden zwei Komponenten ben√∂tigt.  Die erste - die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus-</a> Zeitreihendatenbank - sammelt Anwendungsmetriken und speichert sie.  Die zweite Komponente, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k8s-prometheus-Adapter</a> , erg√§nzt die benutzerdefinierten Metriken-API-Kubernetes mit vom Builder bereitgestellten Metriken. <br><br><img src="https://habrastorage.org/webt/hf/g5/-j/hfg5-js5hf_5ldfgkrhk0dwgfu0.png"><br><br>  Ein dedizierter Namespace wird verwendet, um Prometheus und den Adapter bereitzustellen. <br><br>  Erstellen Sie einen <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./namespaces.yaml</code> </pre> <br>  Erweitern Sie Prometheus v2 im <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./prometheus</code> </pre> <br>  Generieren Sie die f√ºr den Prometheus-Adapter erforderlichen TLS-Zertifikate: <br><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">make</span></span> certs</code> </pre> <br>  Stellen Sie den Prometheus-Adapter f√ºr die API f√ºr benutzerdefinierte Metriken bereit: <br><br><pre> <code class="go hljs">kubectl create -f ./custom-metrics-api</code> </pre> <br>  Holen Sie sich eine Liste der von Prometheus bereitgestellten speziellen Metriken: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1"</span></span> | jq .</code> </pre> <br>  Extrahieren Sie dann die Dateisystem-Nutzungsdaten f√ºr alle Pods im <code>monitoring</code> Namespace: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/monitoring/pods/*/fs_usage_bytes"</span></span> | jq .</code> </pre> <br><h2>  4. Automatische Skalierung basierend auf benutzerdefinierten Metriken </h2><br>  Erstellen Sie den NodePort- <code>podinfo</code> Dienst und stellen Sie ihn im <code>default</code> Namespace <code>podinfo</code> : <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-svc.yaml,./podinfo/podinfo-dep.yaml</code> </pre> <br>  Die <code>podinfo</code> Anwendung <code>podinfo</code> die spezielle Metrik <code>http_requests_total</code> .  Der Prometheus-Adapter entfernt das Suffix <code>_total</code> und markiert diese Metrik als Z√§hler. <br><br>  Rufen Sie die Gesamtzahl der Abfragen pro Sekunde √ºber die API f√ºr benutzerdefinierte Metriken ab: <br><br><pre> <code class="go hljs">kubectl get --raw <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/*/http_requests"</span></span> | jq . { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"MetricValueList"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom.metrics.k8s.io/v1beta1"</span></span>, <span class="hljs-string"><span class="hljs-string">"metadata"</span></span>: { <span class="hljs-string"><span class="hljs-string">"selfLink"</span></span>: <span class="hljs-string"><span class="hljs-string">"/apis/custom.metrics.k8s.io/v1beta1/namespaces/default/pods/%2A/http_requests"</span></span> }, <span class="hljs-string"><span class="hljs-string">"items"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"describedObject"</span></span>: { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-string"><span class="hljs-string">"default"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"podinfo-6b86c8ccc9-kv5g9"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"/__internal"</span></span> }, <span class="hljs-string"><span class="hljs-string">"metricName"</span></span>: <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-10T16:49:07Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"901m"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"describedObject"</span></span>: { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"Pod"</span></span>, <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>: <span class="hljs-string"><span class="hljs-string">"default"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"podinfo-6b86c8ccc9-nm7bl"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"/__internal"</span></span> }, <span class="hljs-string"><span class="hljs-string">"metricName"</span></span>: <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-01-10T16:49:07Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"898m"</span></span> } ] }</code> </pre> <br>  Der Buchstabe <code>m</code> bedeutet <code>901m</code> , so dass beispielsweise 901 <code>901m</code> 901 Millisekunden sind. <br><br>  Erstellen Sie eine HPA, die die Podinfo-Bereitstellung erweitert, wenn die Anzahl der Anforderungen 10 Anforderungen pro Sekunde √ºberschreitet: <br><br><pre> <code class="go hljs">apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: podinfo spec: scaleTargetRef: apiVersion: extensions/v1beta1 kind: Deployment name: podinfo minReplicas: <span class="hljs-number"><span class="hljs-number">2</span></span> maxReplicas: <span class="hljs-number"><span class="hljs-number">10</span></span> metrics: - <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Pods pods: metricName: http_requests targetAverageValue: <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br>  Erweitern Sie HPA <code>podinfo</code> im <code>default</code> Namespace: <br><br><pre> <code class="go hljs">kubectl create -f ./podinfo/podinfo-hpa-custom.yaml</code> </pre> <br>  Nach einigen Sekunden erh√§lt der HPA den Wert <code>http_requests</code> von der Metrik-API: <br><br><pre> <code class="go hljs">kubectl get hpa NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE podinfo Deployment/podinfo <span class="hljs-number"><span class="hljs-number">899</span></span>m / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>m</code> </pre> <br>  Wenden Sie die Last f√ºr den Podinfo-Dienst mit 25 Anforderungen pro Sekunde an: <br><br><pre> <code class="go hljs">#install hey <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get -u github.com/rakyll/hey #do <span class="hljs-number"><span class="hljs-number">10</span></span>K requests rate limited at <span class="hljs-number"><span class="hljs-number">25</span></span> QPS hey -n <span class="hljs-number"><span class="hljs-number">10000</span></span> -q <span class="hljs-number"><span class="hljs-number">5</span></span> -c <span class="hljs-number"><span class="hljs-number">5</span></span> http:<span class="hljs-comment"><span class="hljs-comment">//&lt;K8S-IP&gt;:31198/healthz</span></span></code> </pre> <br>  Nach einigen Minuten beginnt der HPA mit der Skalierung der Bereitstellung: <br><br><pre> <code class="go hljs">kubectl describe hpa Name: podinfo Namespace: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Reference: Deployment/podinfo Metrics: ( current / target ) <span class="hljs-string"><span class="hljs-string">"http_requests"</span></span> on pods: <span class="hljs-number"><span class="hljs-number">9059</span></span>m / <span class="hljs-number"><span class="hljs-number">10</span></span>&lt; Min replicas: <span class="hljs-number"><span class="hljs-number">2</span></span> Max replicas: <span class="hljs-number"><span class="hljs-number">10</span></span> Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">2</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">3</span></span>; reason: pods metric http_requests above target</code> </pre> <br>  Bei der aktuellen Anzahl von Anforderungen pro Sekunde erreicht die Bereitstellung niemals maximal 10 Pods.  Drei Replikate reichen aus, um sicherzustellen, dass die Anzahl der Anforderungen pro Sekunde f√ºr jeden Pod weniger als 10 betr√§gt. <br><br>  Nach Abschluss der Auslastungstests reduziert HPA die Bereitstellungsskala auf die anf√§ngliche Anzahl von Replikaten: <br><br><pre> <code class="go hljs">Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">5</span></span>m horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">3</span></span>; reason: pods metric http_requests above target Normal SuccessfulRescale <span class="hljs-number"><span class="hljs-number">21s</span></span> horizontal-pod-autoscaler New size: <span class="hljs-number"><span class="hljs-number">2</span></span>; reason: All metrics below target</code> </pre> <br>  M√∂glicherweise haben Sie bemerkt, dass der automatische Skalierer nicht sofort auf √Ñnderungen der Metriken reagiert.  Standardm√§√üig werden sie alle 30 Sekunden synchronisiert.  Dar√ºber hinaus erfolgt die Skalierung nur, wenn die Arbeitslast in den letzten 3 bis 5 Minuten nicht erh√∂ht oder verringert wurde.  Dies hilft, widerspr√ºchliche Entscheidungen zu vermeiden, und l√§sst Zeit, um den Auto-Scaler des Clusters zu verbinden. <br><br><h2>  Fazit </h2><br>  Nicht alle Systeme k√∂nnen die SLA-Konformit√§t nur auf der Grundlage der CPU- oder Speicherauslastung (oder beider) erzwingen.  Die meisten Webserver und mobilen Server zur Verarbeitung von Verkehrsspitzen ben√∂tigen eine automatische Skalierung basierend auf der Anzahl der Anforderungen pro Sekunde. <br><br>  F√ºr ETL-Anwendungen (aus dem Eng. Extract Transform Load - ‚ÄûExtrahieren, Transformieren, Laden‚Äú) kann die automatische Skalierung beispielsweise ausgel√∂st werden, wenn die angegebene Schwellenl√§nge der Jobwarteschlange √ºberschritten wird. <br><br>  In allen F√§llen k√∂nnen Sie durch Instrumentieren von Anwendungen mit Prometheus und Hervorheben der erforderlichen Indikatoren f√ºr die automatische Skalierung die Anwendungen optimieren, um die Verarbeitung von Verkehrsspitzen zu verbessern und eine hohe Verf√ºgbarkeit der Infrastruktur sicherzustellen. <br><br>  Ideen, Fragen, Kommentare?  Nehmen Sie an der Diskussion bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack teil</a> ! <br><br>  Hier ist so ein Material.  Wir warten auf Ihre Kommentare und sehen uns auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurs</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457742/">https://habr.com/ru/post/de457742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457728/index.html">Hash-Tabellen in Go. Implementierungsdetails</a></li>
<li><a href="../de457730/index.html">Im B√ºro gibt es eine Illusion der Kontrolle - es ist nicht auf der Fernbedienung. Gespr√§ch mit Devhab</a></li>
<li><a href="../de457734/index.html">Italien Open Source Revolution beginnt</a></li>
<li><a href="../de457736/index.html">"Tools sind nicht so wichtig wie die F√§higkeit, √ºber die von ihnen erstellten Systeme nachzudenken." Tolles Interview mit Martin Kleppman</a></li>
<li><a href="../de457738/index.html">Wie wir SD-Access implementiert haben und warum es ben√∂tigt wurde</a></li>
<li><a href="../de457744/index.html">Erstellen eines Erweiterungssystems in der Qt-Bibliothek - Teil 2</a></li>
<li><a href="../de457746/index.html">Meteorologie und Fl√ºge</a></li>
<li><a href="../de457750/index.html">Arbeiten Sie mit JSON RPC in Symfony 4</a></li>
<li><a href="../de457752/index.html">Keine Mondrover und keine Joker. Was wissen wir √ºber Roboter in Fukushima?</a></li>
<li><a href="../de457754/index.html">Staats- und T-Killer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>