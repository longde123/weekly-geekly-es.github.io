<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏻 👜 🛌🏽 如何将现有项目从ASP.NET MVC升级到ASP.NET Core。 实用指南 ™️ 💅 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇文章是基于我们将现有项目从ASP.NET MVC迁移到ASP.NET Core的经验而产生的。 我们试图以结构化的形式汇总整个迁移过程，并描述各种瓶颈，以便开发人员可以继续依靠此材料并遵循解决此类问题的路线图。 

 关于我们的项目的几句话。 我们是ASP.NET上的开源电子商务平台，到转让之时...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何将现有项目从ASP.NET MVC升级到ASP.NET Core。 实用指南</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472738/"> 这篇文章是基于我们将现有项目从ASP.NET MVC迁移到ASP.NET Core的经验而产生的。 我们试图以结构化的形式汇总整个迁移过程，并描述各种瓶颈，以便开发人员可以继续依靠此材料并遵循解决此类问题的路线图。 <br><br> 关于我们的项目的几句话。 我们是ASP.NET上的开源电子商务平台，到转让之时，该平台已经成功存在了9年。 我们在2年前进行了迁移-但是直到现在我们才开始写有关迁移的文章。 当时，我们是决定采取这一步骤的首批重大项目之一。 <br><br><h2> 为什么要切换到ASP.NET Core？ </h2><br> 在继续执行从ASP.NET MVC迁移到ASP.NET Core的步骤之前，请先简单介绍一下此平台的好处。 <br><br><img src="https://habrastorage.org/webt/wo/xg/ue/woxgueorhrjz_brki1qktunkqhe.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">ASP.NET Core的好处</b> <div class="spoiler_text">因此，ASP.NET Core已经是一个相当知名的开发框架，它已经进行了几次重大更新，这意味着今天它已经相当稳定，技术先进并且可以抵抗XSRF / CSRF攻击。 <br><br>  <b>跨平台</b>是使他获得越来越多知名度的标志之一。 从现在开始，您的Web应用程序可以在Windows和Unix环境中运行。 <br><br>  <b>模块化</b> -ASP.NET Core完全以NuGet软件包的形式提供，这使您可以优化应用程序，包括所选的必需软件包。 这样可以提高解决方案的性能，并减少升级单个零件所需的时间。 这是第二个重要功能，使开发人员可以更灵活地将新功能集成到他们的解决方案中。 <br><br>  <b>性能</b>是构建高性能应用程序的又一步，ASP.NET Core每秒处理的请求比ASP.NET 4.6多2300％，比node.js每秒多800％。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>自己检查详细的性能测试。 <br><br><img src="https://habrastorage.org/webt/wb/vg/oi/wbvgoixwdbcfr0m8l0myjywrlpq.png"><br><br>  <b>中间件</b>是针对应用程序内请求的新型轻量级高性能模块化管道。 每个中间件都处理一个HTTP请求，然后决定返回结果，或者传递下一个中间件。 这种方法使开发人员可以完全控制HTTP管道，并有助于开发应用程序的简单模块，这对于不断发展的开源项目很重要。 <br><br>  ASP.NET Core MVC提供了简化Web开发的功能。  NopCommerce已经使用了诸如“模型-视图-控制器”模板，Razor语法，模型绑定和验证之类的功能，但是出现了新工具： <br><br><ul><li> 标记助手。 这是服务器端代码，用于在Razor文件中创建和呈现HTML元素。 </li><li> 查看组件。 这是一个新工具，类似于局部视图，但功能更强大。 当需要重用渲染逻辑并且任务对于部分视图而言过于复杂时，nopCommerce使用视图组件。 </li><li>  DI的观点。 尽管视图中显示的大多数数据都是从控制器传递的，但nopCommerce的视图中的依赖项注入更为方便。 </li></ul><br> 当然，ASP.NET Core具有更多功能，但是我们只是研究了最有趣的功能。 </div></div><br> 现在让我们讨论将应用程序移植到新平台时应考虑的事项。 <br><br><h2> 迁移 </h2><br> 文本将包含大量指向ASP.NET Core官方文档的链接，以帮助获取有关该主题的更多详细信息。 对于首次遇到类似任务的开发人员尤其重要。 <br><br><h3> 步骤1.准备工具 </h3><br> 您需要做的第一件事是将Visual Studio 2017升级到15.3版或更高版本。 并安装最新版本的.NET Core SDK。 <br><br> 开始迁移之前，建议您使用.NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.Net Portability Analyzer</a>可移植性分析工具。 这是了解从一个平台到另一个平台的转换过程的艰巨起点。 但是，当然，此工具不能解决所有问题，并且在此过程中会存在很多陷阱。 接下来，将描述需要通过的主要阶段，并显示本项目中使用的解决方案。 <br><br> 您需要做的第一件事就是更新指向支持.NET Standard的项目中使用的库的链接。 <br><br><h3> 步骤2.支持.Net Standard的NuGet软件包的兼容性分析 </h3><br> 如果在项目中使用NuGet软件包，则需要检查它们是否与.NET Core兼容。 一种方法是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NuGetPackageExplorer</a>工具。 <br><br><h3> 步骤3..NET Core使用新的csproj文件格式 </h3><br> 使用新方法添加.NET Core中引入的第三方链接很重要：将新的类库添加到解决方案时，您应该打开主项目文件，并将其内容替换为以下内容： <br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Sdk</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span>netcoreapp2.2<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.AspNetCore.App"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2.2.6"</span></span></span><span class="hljs-tag"> /&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 来自连接的库的链接将自动下载。 有关project.json和CSPROJ属性之间映射的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的官方文档。 <br><br><h3> 步骤4.更新名称空间 </h3><br> 您必须删除对System.Web的所有使用并将其替换为Microsoft.AspNetCore。 <br><br><h3> 步骤5.您必须配置Startup.cs文件。 而不是使用global.asax </h3><br>  ASP.NET Core具有加载应用程序的新机制。 该应用程序的入口点变成<code>Startup</code> ，并且对<i>Global.asax</i>文件的依赖关系消失了。  <code>Startup</code>在应用程序中注册中间件套件。  <code>Startup</code>必须包括<code>Configure</code>方法。 在“ <code>Configure</code>将所需的中间件添加到管道中。 <br><br>  <b>Startup.cs问题</b> <br><br><ol><li> 为MVC和WebAPI请求配置中间件 </li><li> 的配置设置： </li></ol><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异常处理</a> <br><p> 由于在过渡过程中，您不可避免地必须处理各种冲突，因此您必须立即在开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">环境中</a>准备和设置异常处理。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UseDeveloperExceptionPage</a> ，添加了中间件来捕获异常。 </p></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">路由MVC</a> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新路线的注册</a>也已更改。 现在使用IRouteBuilder代替RouteCollection，后者是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">注册约束</a>的新方法（IActionConstraint） </p></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MVC / WebAPI筛选器</a> <br><p> 有必要根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ASP.NET Core</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新实现</a>重写筛选器。 </p></li><li>  MVC / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAPI格式化程序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">绑定模型</a> </li></ul><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//add basic MVC feature var mvcBuilder = services.AddMvc(); //add custom model binder provider (to the top of the provider list) mvcBuilder.AddMvcOptions(options =&gt; options.ModelBinderProviders.Insert(0, new NopModelBinderProvider())); /// &lt;summary&gt; /// Represents model binder provider for the creating NopModelBinder /// &lt;/summary&gt; public class NopModelBinderProvider : IModelBinderProvider { /// &lt;summary&gt; /// Creates a nop model binder based on passed context /// &lt;/summary&gt; /// &lt;param name="context"&gt;Model binder provider context&lt;/param&gt; /// &lt;returns&gt;Model binder&lt;/returns&gt; public IModelBinder GetBinder(ModelBinderProviderContext context) { if (context == null) throw new ArgumentNullException(nameof(context)); var modelType = context.Metadata.ModelType; if (!typeof(BaseNopModel).IsAssignableFrom(modelType)) return null; //use NopModelBinder as a ComplexTypeModelBinder for BaseNopModel if (context.Metadata.IsComplexType &amp;&amp; !context.Metadata.IsCollectionType) { //create binders for all model properties var propertyBinders = context.Metadata.Properties .ToDictionary(modelProperty =&gt; modelProperty, modelProperty =&gt; context.CreateBinder(modelProperty)); return new NopModelBinder(propertyBinders, EngineContext.Current.Resolve&lt;ILoggerFactory&gt;()); } //or return null to further search for a suitable binder return null; } }</span></span></code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地区</a> </li></ul><br><br><pre> <code class="java hljs">app.UseMvc(routes =&gt; { routes.MapRoute(<span class="hljs-string"><span class="hljs-string">"areaRoute"</span></span>, <span class="hljs-string"><span class="hljs-string">"{area:exists}/{controller=Admin}/{action=Index}/{id?}"</span></span>); routes.MapRoute( name: <span class="hljs-string"><span class="hljs-string">"default"</span></span>, template: <span class="hljs-string"><span class="hljs-string">"{controller=Home}/{action=Index}/{id?}"</span></span>); });</code> </pre> <br> 同时，应将名称为Area的文件夹（位于Admin文件夹所在的文件夹）放置在应用程序的根目录中。 现在， <code>[Area("Admin")] [Route("admin")]</code>属性将用于将控制器与此区域连接。 <br> 仅保留为控制器中描述的所有操作创建视图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3o/eo/rp/3oeorp_vjlbwlisc1kbavvvaeoe.png"></div><br><pre> <code class="java hljs">[Area(<span class="hljs-string"><span class="hljs-string">"Admin"</span></span>)] [Route(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdminController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(); } }</code> </pre> <br>  <b>验证方式</b> <br><br> 现在，您无需将IFormCollection传递给控制器​​，因为在这种情况下，asp.net服务器验证已禁用-如果IFormCollection不为null，则MVC将禁止进一步验证。 解决问题的方法可以是将此属性添加到模型中，这将阻止我们直接传递给控制器​​方法。 仅当存在模型时此规则才有效，但是如果没有模型，则将没有验证。 <br><br> 子属性不再自动验证。 必须手动指定。 <br><br><h3> 步骤6.将HTTP处理程序和HTTP模块传输到中间件 </h3><br>  HTTP处理程序和HTTP模块在本质上与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.microsoft.com/ru-ru/aspnet/core/migration/">ASP.NET Core中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.microsoft.com/ru-ru/aspnet/core/migration/">中间件</a>概念非常相似，但是与模块不同，中间件顺序是基于将它们插入请求管道的顺序。 在大多数情况下，模块的顺序基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">应用程序生命周期</a>事件。 答案的中间件顺序与请求的顺序相反，而请求和答案的模块顺序相同，基于此，您可以继续升级。 <br><br> 因此，有待更新的内容： <br><br><ul><li> 中间件模块的迁移（AuthenticationMiddleware，CultureMiddleware等） </li><li> 中间件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.microsoft.com/en-us/aspnet/core/migration/">处理程序</a> </li><li> 使用新的中间件 </li></ul><br> 我们项目中的身份验证未使用内置的凭据系统；出于这些目的，使用了根据新ASP.NET Core结构开发的中间件AuthenticationMiddleware。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly RequestDelegate _next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AuthenticationMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IAuthenticationSchemeProvider schemes, RequestDelegate next)</span></span></span><span class="hljs-function"> </span></span>{ Schemes = schemes ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(schemes)); _next = next ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(next)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IAuthenticationSchemeProvider Schemes { get; set; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpContext context)</span></span></span><span class="hljs-function"> </span></span>{ context.Features.Set&lt;IAuthenticationFeature&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationFeature { OriginalPath = context.Request.Path, OriginalPathBase = context.Request.PathBase }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlers = context.RequestServices.GetRequiredService&lt;IAuthenticationHandlerProvider&gt;(); foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scheme in await Schemes.GetRequestHandlerSchemesAsync()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (await handlers.GetHandlerAsync(context, scheme.Name) is IAuthenticationRequestHandler handler &amp;&amp; await handler.HandleRequestAsync()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ignored } } var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync(); if (defaultAuthenticate != null) { var result = await context.AuthenticateAsync(defaultAuthenticate.Name); if (result?.Principal != null) { context.User = result.Principal; } } await _next(context); } }</span></span></code> </pre> <br>  ASP.NET提供了许多嵌入式中间件，您可以在应用程序中使用它们，但是请注意，开发人员<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以创建自己的中间件</a>并将其添加到HTTP请求管道中。 为了简化此机制，我们添加了一个特殊的接口，现在足以创建一个实现该接口的类。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INopStartup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Add and configure any of the middleware /// &lt;/summary&gt; /// &lt;param name="services"&gt;Collection of service descriptors&lt;/param&gt; /// &lt;param name="configuration"&gt;Configuration of the application&lt;/param&gt; void ConfigureServices(IServiceCollection services, IConfiguration configuration); /// &lt;summary&gt; /// Configure the using of added middleware /// &lt;/summary&gt; /// &lt;param name="application"&gt;Builder for configuring an application's request pipeline&lt;/param&gt; void Configure(IApplicationBuilder application); /// &lt;summary&gt; /// Gets order of this startup configuration implementation /// &lt;/summary&gt; int Order { get; } }</span></span></code> </pre> <br> 您可以在此处添加和配置中间件： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Represents object for the configuring authentication middleware on application startup /// &lt;/summary&gt; public class AuthenticationStartup : INopStartup { /// &lt;summary&gt; /// Add and configure any of the middleware /// &lt;/summary&gt; /// &lt;param name="services"&gt;Collection of service descriptors&lt;/param&gt; /// &lt;param name="configuration"&gt;Configuration of the application&lt;/param&gt; public void ConfigureServices(IServiceCollection services, IConfiguration configuration) { //add data protection services.AddNopDataProtection(); //add authentication services.AddNopAuthentication(); } /// &lt;summary&gt; /// Configure the using of added middleware /// &lt;/summary&gt; /// &lt;param name="application"&gt;Builder for configuring an application's request pipeline&lt;/param&gt; public void Configure(IApplicationBuilder application) { //configure authentication application.UseNopAuthentication(); } /// &lt;summary&gt; /// Gets order of this startup configuration implementation /// &lt;/summary&gt; public int Order =&gt; 500; //authentication should be loaded before MVC }</span></span></code> </pre> <br><h3> 步骤7.使用集成DI </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">依赖</a>注入是ASP.NET Core应用程序设计过程中的关键功能之一。 它使您可以创建松散耦合的应用程序，这些应用程序更易于测试，模块化并且因此更易于维护。 通过遵循依赖倒置的原理，可以实现这一点。 要安装依赖项，请使用IoC容器（控制反转）。 在ASP.NET Core中，这样的容器由IServiceProvider接口表示。 服务通过<code>Startup.ConfigureServices()</code>方法安装在应用程序中。 <br><br> 任何注册的服务都可以配置三个范围： <br><br><ul><li> 瞬态的 </li><li> 范围 </li><li> 单身人士 </li></ul><br><pre> <code class="java hljs">services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt; options.UseSqlServer(Configuration.GetConnectionString(<span class="hljs-string"><span class="hljs-string">"DefaultConnection"</span></span>))); services.AddSingleton&lt;Isingleton,MySingleton&gt;();</code> </pre> <br><h3> 步骤8.使用WebAPI项目兼容性Shell（Shim） </h3><br> 为了简化现有Web API实现的迁移，建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft.AspNetCore.Mvc.WebApiCompatShim</a> NuGet包。 支持以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">兼容功能</a> ： <br><br><ul><li> 添加ApiController类型 </li><li> 启用Web API样式模型绑定 </li><li> 扩展模型绑定，以便控制器操作可以接受HttpRequestMessage类型的参数。 </li><li> 添加消息格式化程序，该消息格式化程序允许操作返回HttpResponseMessage类型的结果 </li></ul><br><pre> <code class="java hljs">services.AddMvc().AddWebApiConventions(); routes.MapWebApiRoute(name: <span class="hljs-string"><span class="hljs-string">"DefaultApi"</span></span>, template: <span class="hljs-string"><span class="hljs-string">"api/{controller}/{id?}"</span></span> );</code> </pre> <br><h3> 步骤9.传输应用程序配置 </h3><br> 以前，一些设置保存在web.config文件中。 现在，我们正在基于<i>配置提供者</i>建立的键值对采取一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新方法</a> 。 这是ASP.NET Core中推荐的机制，我们使用appsettings.json文件。 <br><br> 如果出于某些原因要继续使用* .config，则也可以使用NuGet包<code>System.Configuration.ConfigurationManager</code> 。 在这种情况下，您将不得不放弃在Unix平台上运行该应用程序的功能，而只能在IIS下运行它。 <br><br> 如果要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Azure Key Vault</a>配置提供程序，则应参考“内容<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移到Azure Key Valut内容”</a> 。 在我们的项目中，这不是任务。 <br><br><h3> 步骤10.将静态内容传输到wwwroot </h3><br> 要提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">静态内容，</a>您必须告诉Web主机当前目录内容的根。 默认值为wwwroot。 您可以通过设置中间件来自定义目录以存储静态文件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b7/z1/s7/b7z1s7pkzbd2yrkqukxcfholuus.png"></div><br><br><h3> 步骤11.将EntityFramework移植到EF Core </h3><br> 如果项目使用了<code>EF Core</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不支持</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的Entity Framework 6的</a>某些特定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能</a> ，则可以在<code>NET Framework</code>上运行该应用程序。 但是，在这种情况下，您必须牺牲多平台。 该应用程序只能在Windows和IIS下运行。 <br><br>  <b>让我们看一下要考虑的主要变化：</b> <br><br><ul><li>  System.Data.Entity命名空间替换为Microsoft.EntityFrameworkCore </li><li>  DbContext构造函数的签名已更改。 现在您需要注入DbContextOptions </li><li>  HasDatabaseGeneratedOption（DatabaseGeneratedOption.None）方法替换为ValueGeneratedNever（） </li><li>  WillCascadeOnDelete（false）方法替换为OnDelete（DeleteBehavior.Restrict） </li><li> 被OnModelCreating（ModelBuilder modelBuilder）取代的OnModelCreating（DbModelBuilder modelBuilder）方法 </li><li>  HasOptional方法不再可用 </li><li> 对象的配置已更改，现在您需要使用OnModelCreating，因为  EntityTypeConfiguration不再可用 </li><li>  ComplexType属性不再可用 </li><li> 用DbSet替换IDbSet接口 </li><li>  ComplexType-复杂类型支持在EF Core 2中以拥有的实体类型（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.microsoft.com/en-us/ef/core/modeling/owned-entities</a> ）出现，并且在EF Core中没有带有QueryType的主键的表2.1（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://docs.microsoft.com/zh-cn/ef/core/modeling/query-types</a> ） </li><li> 与使用[Entity] _Id模式的EF6不同，EF Core中的外键使用[Entity] ID模式生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阴影属性</a> 。 因此，首先将外键作为常规属性添加到实体。 </li><li> 要为DbContext支持DI，请在<code>ConfigureServices</code>中<code>ConfigureServices</code> DbContex </li></ul><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Register base object context /// &lt;/summary&gt; /// &lt;param name="services"&gt;Collection of service descriptors&lt;/param&gt; public static void AddNopObjectContext(this IServiceCollection services) { services.AddDbContextPool&lt;NopObjectContext&gt;(optionsBuilder =&gt; { optionsBuilder.UseSqlServerWithLazyLoading(services); }); } /// &lt;summary&gt; /// SQL Server specific extension method for Microsoft.EntityFrameworkCore.DbContextOptionsBuilder /// &lt;/summary&gt; /// &lt;param name="optionsBuilder"&gt;Database context options builder&lt;/param&gt; /// &lt;param name="services"&gt;Collection of service descriptors&lt;/param&gt; public static void UseSqlServerWithLazyLoading(this DbContextOptionsBuilder optionsBuilder, IServiceCollection services) { var nopConfig = services.BuildServiceProvider().GetRequiredService&lt;NopConfig&gt;(); var dataSettings = DataSettingsManager.LoadSettings(); if (!dataSettings?.IsValid ?? true) return; var dbContextOptionsBuilder = optionsBuilder.UseLazyLoadingProxies(); if (nopConfig.UseRowNumberForPaging) dbContextOptionsBuilder.UseSqlServer(dataSettings.DataConnectionString, option =&gt; option.UseRowNumberForPaging()); else dbContextOptionsBuilder.UseSqlServer(dataSettings.DataConnectionString); }</span></span></code> </pre><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL比较</a>工具来验证<code>EF Core</code>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移</a>期间是否生成了与<code>Entity Framework</code>类似的数据库架构。 <br><br><h3> 步骤12.删除所有HttpContext引用，替换过时的类，并更改名称空间 </h3><br> 在项目迁移期间，您会发现已重命名或移动了足够多的类，现在您需要使所有内容与新要求保持一致。 这是您可能会遇到的主要过渡的列表： <br><br><ul><li>  HttpPostedFileBase-&gt; IFormFile </li><li> 现在可以通过IHttpContextAccessor访问HttpContext。 </li><li>  HtmlHelper-&gt; IHtmlHelper </li><li>  ActionResult-&gt; IActionResult </li><li>  HttpUtility-&gt; WebUtility </li><li> 可以从HttpContext.Session访问ISession而不是HttpSessionStateBase。 来自Microsoft.AspNetCore.Http </li><li>  Request.Cookies返回IRequestCookieCollection：IEnumerable &lt;KeyValuePair &lt;字符串，字符串&gt;&gt;，所以不是Microsoft.AspNetCore.Http的HttpCookie，KeyValuePair &lt;字符串，字符串&gt; </li></ul><br> 命名空间替换： <br><br><ul><li>  SelectList-&gt; Microsoft.AspNetCore.Mvc.Rendering </li><li>  UrlHelper-&gt; WebUtitlity </li><li>  MimeMapping-&gt; FileExtensionContentTypeProvider </li><li>  MvcHtmlString-&gt; IHtmlString和HtmlString </li><li>  ModelState，ModelStateDictionary，ModelError-&gt; Microsoft.AspNetCore.Mvc.ModelBinding </li><li>  FormCollection-&gt; IFormCollection </li><li>  Request.Url.Scheme-&gt; this.Url.ActionContext.HttpContext.Request.Scheme </li></ul><br> 其他： <br><br><ul><li>  MvcHtmlString.IsNullOrEmpty（IHtmlString）-&gt; String.IsNullOrEmpty（variable.ToHtmlString（）） </li><li>  [ValidateInput（false）]-通常不再使用，不需要 </li><li>  HttpUnauthorizedResult-&gt; UnauthorizedResult </li><li>  [AllowHtml]-没有更多的指令，也不需要 </li><li>  TagBuilder.SetInnerText方法已替换-现在是InnerHtml.AppendHtml </li><li> 返回Json时不再需要JsonRequestBehavior.AllowGet </li><li>  HttpUtility.JavaScriptStringEncode。  -&gt; JavaScriptEncoder.Default.Encode </li><li>  Request.RawUrl。 有必要分别连接Request.Path + Request.QueryString </li><li>  AllowHtmlAttribute-没有更多的类 </li><li>  XmlDownloadResult-现在您可以使用返回的文件（Encoding.UTF8.GetBytes（xml），“ application / xml”，“ filename.xml”）； </li><li>  [ValidateInput（false）]-不再有指令，因此不需要 </li></ul><br><h3> 步骤13.更新身份验证和授权 </h3><br> 我已经在上面写过，在我们的项目中，身份验证不是使用内置的身份系统来实现的，而是在单独的中间件层中进行的。 但是，ASP.NET Core具有自己的提供凭据的机制。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>的文档中找到更多详细信息。 <br><br> 至于数据保护-我们不再使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MachineKey</a> 。 相反，我们使用内置的数据保护功能。 默认情况下，启动应用程序时会生成密钥。 数据仓库可以是： <br><br><ul><li> 文件系统-基于文件系统的密钥库 </li><li>  Azure存储-Azure Blob存储中的数据保护密钥 </li><li>  Redis-Redis缓存中的数据保护密钥 </li><li> 注册表-如果应用程序无权访问文件系统，则必须使用注册表 </li><li>  EF Core-密钥存储在数据库中 </li></ul><br> 如果内置机制不合适，则可以通过提供自定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IXmlRepository</a>来指定自己的密钥存储机制。 <br><br><h3> 步骤14.更新JS / CSS </h3><br> 静态资源的使用方式已更改：现在，所有这些资源都应存储在<i>wwwroot</i>项目的根文件夹中，除非指定了其他设置。 <br><br> 使用javascript内置块时，建议将其移至页面末尾。 只需对标签使用asp-location =“ Footer”属性。 相同的规则适用于js文件。 <br><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BundlerMinifier</a>扩展名替代System.Web.Optimization-这将使您在构建项目时绑定并最小化JavaScript和CSS。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>到文档。 <br><br><h3> 步骤15.迁移视图 </h3><br> 不再使用子操作。 相反，ASP.NET Core提供了一个新的强大工具<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-ViewComponents</a> ，该工具被异步调用。 <br><br> 如何从ViewComponent获取字符串： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Render component to string /// &lt;/summary&gt; /// &lt;param name="componentName"&gt;Component name&lt;/param&gt; /// &lt;param name="arguments"&gt;Arguments&lt;/param&gt; /// &lt;returns&gt;Result&lt;/returns&gt; protected virtual string RenderViewComponentToString(string componentName, object arguments = null) { if (string.IsNullOrEmpty(componentName)) throw new ArgumentNullException(nameof(componentName)); var actionContextAccessor = HttpContext.RequestServices.GetService(typeof(IActionContextAccessor)) as IActionContextAccessor; if (actionContextAccessor == null) throw new Exception("IActionContextAccessor cannot be resolved"); var context = actionContextAccessor.ActionContext; var viewComponentResult = ViewComponent(componentName, arguments); var viewData = ViewData; if (viewData == null) { throw new NotImplementedException(); } var tempData = TempData; if (tempData == null) { throw new NotImplementedException(); } using (var writer = new StringWriter()) { var viewContext = new ViewContext( context, NullView.Instance, viewData, tempData, writer, new HtmlHelperOptions()); // IViewComponentHelper is stateful, we want to make sure to retrieve it every time we need it. var viewComponentHelper = context.HttpContext.RequestServices.GetRequiredService&lt;IViewComponentHelper&gt;(); (viewComponentHelper as IViewContextAware)?.Contextualize(viewContext); var result = viewComponentResult.ViewComponentType == null ? viewComponentHelper.InvokeAsync(viewComponentResult.ViewComponentName, viewComponentResult.Arguments): viewComponentHelper.InvokeAsync(viewComponentResult.ViewComponentType, viewComponentResult.Arguments); result.Result.WriteTo(writer, HtmlEncoder.Default); return writer.ToString(); } }</span></span></code> </pre> <br> 不再需要使用HtmlHelper-ASP.NET Core具有大量内置的帮助程序标记功能（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tag Helpers</a> ）。 当应用程序运行时，它们由服务器端的Razor引擎处理，并最终转换为标准html元素。 这大大简化了应用程序开发。 而且，当然，您可以实现自己的标记助手。 <br><br> 我们开始在视图中使用依赖项注入，而不是使用<code>EngineContext</code>允许设置和服务。 <br><br> 因此，关于视图迁移的要点： <br><br><ul><li> 将<code>Views/web.config  Views/_ViewImports.cshtml</code>转换<code>Views/web.config  Views/_ViewImports.cshtml</code>用于导入名称空间和<code>Views/web.config  Views/_ViewImports.cshtml</code>依赖项。 该文件不支持其他<code>Razor</code>功能，例如功能和节定义。 </li><li> 将<code>namespaces.add</code>转换为<code>@using</code> </li><li> 将所有设置转移到主应用程序配置 </li><li>  <code>Scripts.Render</code>和<code>Styles.Render</code>不存在。 用输出链接替换<code>libman</code>或<code>BundlerMinifier</code> </li></ul><br><h2> 总结 </h2><br> 从我们的经验中可以看出，迁移大型Web应用程序的过程非常耗时，如果没有陷阱就很难执行。 我们计划在第一个稳定版本发布后立即切换到新框架，但是我们无法立即完成它：到那时，一些关键功能尚未转移到.NET Core，尤其是与EntityFramework相关的功能。 因此，我们必须首先使用混合方法发布下一个版本-具有.NET Framework依赖项的.NET Core体系结构。 <br><br>  .NET Core 2.1发行后，我们能够完全适应该项目，当时有一个稳定的解决方案已在新架构上工作-剩下的就是替换一些软件包并用EF Core重写工作。 因此，完全迁移到新框架需要花费几个月的时间。 <br><br> 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库中</a>了解有关我们项目的更多信息。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472738/">https://habr.com/ru/post/zh-CN472738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472720/index.html">ERP不起作用...有什么替代方法？ 或准时。 对于俄罗斯？</a></li>
<li><a href="../zh-CN472724/index.html">skydive.network简介</a></li>
<li><a href="../zh-CN472726/index.html">Arduino噪声抗扰度增强</a></li>
<li><a href="../zh-CN472730/index.html">伊凡诺沃！ Mitap纪念Node.js十周年</a></li>
<li><a href="../zh-CN472736/index.html">开放式网络研讨会“在Selenium和Appium上测试移动应用程序自动化的简介”</a></li>
<li><a href="../zh-CN472744/index.html">MRP不起作用...有什么替代方法？</a></li>
<li><a href="../zh-CN472746/index.html">管理员终端服务器； SSH差距不大</a></li>
<li><a href="../zh-CN472748/index.html">语义浏览器或没有网站的生活</a></li>
<li><a href="../zh-CN472750/index.html">好吧，我真的需要Kubernetes吗？</a></li>
<li><a href="../zh-CN472752/index.html">CSE：适用于vCloud中任何人的Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>