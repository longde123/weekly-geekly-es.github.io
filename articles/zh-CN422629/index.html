<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📆 👩‍💼 🎅🏻 停止喂日志记录器！ 提供更多修饰符！ 延迟静态最终字段。 草图特征草图 🧑🏿‍🤝‍🧑🏻 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Java中，记录器在初始化类时就被初始化就足够了，为什么它们会乱扔整个启动程序？ 约翰·罗斯来营救！ 


 可能是这样的： 


lazy private final static Logger LOGGER = Logger.getLogger("com.foo.Bar");  


 本文档...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>停止喂日志记录器！ 提供更多修饰符！ 延迟静态最终字段。 草图特征草图</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422629/"><p> 在Java中，记录器在初始化类时就被初始化就足够了，为什么它们会乱扔整个启动程序？ 约翰·罗斯来营救！ </p><br><p> 可能是这样的： </p><br><pre><code class="java hljs">lazy <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p> 本文档扩展了最终变量的行为，使您可以选择在语言本身和JVM中支持延迟执行。 提出了通过更改粒度来改进现有懒惰计算机制的行为的方法：现在分类不是精确的，而是特定变量是精确的。 </p><br><img src="https://habrastorage.org/webt/zf/6q/yz/zf6qyzherz5jt3ufyhfp9rz70t4.png"><a name="habracut"></a><br><h1 id="motivaciya"> 动机 </h1><br><p>  Java已在延迟计算中深入构建。 几乎每个链接操作都可以提取惰性代码。 例如，执行<code>&lt;clinit&gt;</code>方法（类初始化程序的字节码）或使用引导程序方法（对于invokedynamic调用站点或<code>CONSTANT_Dynamic</code>常量）。 </p><br><p> 与使用引导程序方法的机制相比，类初始化器在粒度方面非常不礼貌，因为它们的约定是为整个类运行<em>所有</em>初始化代码，而不是将自身限于与类的特定字段相关的初始化。 这种粗略初始化的效果很难预测。 很难隔离使用<em>一</em>类静态字段的副作用，因为计算一个字段会导致计算该类的<em>所有</em>静态字段。 </p><br><p> 如果触摸一个字段，则将影响所有这些字段。 在AOT编译器中，这使得优化静态字段引用特别困难，即使对于具有易于解析的常量值的字段也是如此。 一旦在这些字段之间至少有<em>一个</em>重新设计的静态字段混乱，就不可能完全分析此类的<em>所有</em>字段。 以前提出的用于对带有复杂初始化程序的常量字段进行常量卷积（在<em>javac</em>操作期间）的机制也表现出类似的问题。 </p><br><p> 重新设计的字段初始化的一个示例是记录器的初始化，该初始化在每个文件的每个步骤的不同项目中发生。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOGGER = Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"com.foo.Bar"</span></span>);</code> </pre> <br><p> 这种无害的外观初始化将在类的初始化期间启动大量工作，但是，在类初始化时真正需要记录器的可能性很小，或者根本不需要。 将其创建推迟到第一次真正使用的能力将简化初始化，并且在某些情况下，将完全避免这种初始化。 </p><br><p> 最终变量非常有用，它们是Java API的主要机制，用于指示值的恒定性。 惰性变量也很好用。 从Java 7开始，它们在JDK的内部起着越来越重要的作用，并带有<code>@Stable</code>批注。  JIT可以优化最终变量和稳定变量-比仅某些变量好得多。 添加惰性最终变量将使这种有用的用法模式变得更加普遍，从而有可能在更多地方使用。 最后，使用惰性最终变量将使JDK之类的库减少对<code>&lt;clinit&gt;</code>代码的依赖，从而减少启动时间并提高AOT优化的质量。 </p><br><h1 id="opisanie"> 内容描述 </h1><br><p> 可以使用新的<code>lazy</code>修饰符声明该字段，这是一个上下文关键字，仅被视为修饰符。 这样的字段称为惰性<em>字段</em> ，并且还必须具有<code>static</code>和<code>final</code>修饰符。 </p><br><p> 惰性字段必须具有初始化程序。 编译器和运行时同意在首次使用变量时准确地启动初始化程序，而不是在初始化该字段所属的类时启动。 </p><br><p> 每个<code>lazy static final</code>字段在编译时都与代表其值的常量池元素相关联。 由于常量池本身的元素是惰性计算的，因此只需为与此元素关联的每个静态惰性最终变量简单分配正确的值就足够了。  （您可以将多个惰性变量绑定到一个元素，但这几乎不是有用或有意义的功能。）该属性名称为<code>LazyValue</code> ，并且它必须引用一个恒定的性别元素，该元素可以被ldc编码为可转换为惰性字段类型的值。 。 仅<code>MethodHandle.invoke</code>在<code>MethodHandle.invoke</code>使用的强制类型转换。 </p><br><p> 因此，可以将惰性静态字段视为声明该字段的类中的常量池元素的命名别名。 诸如编译器之类的工具可能会尝试使用此字段。 </p><br><p> 惰性字段永​​远不会是常量变量（在JLS 4.12.4的意义上），并且明确地不参与常量表达式（在JLS 15.28的意义上）。 因此，即使它的初始化器是一个常量表达式，它也不会捕获<code>ConstantValue</code>属性。 相反，惰性字段捕获一种称为<code>LazyValue</code>的新类文件属性，JVM在链接到此特定字段时会查询该属性。 此新属性的格式与上一个属性相似，因为它也指向常量池中的一个元素，在这种情况下，该元素被解析为字段值。 </p><br><p> 链接了惰性静态字段后，执行类初始化程序的正常过程不应消失。 而是根据JVMS 5.5中定义的规则初始化任何声明类<code>&lt;clinit&gt;</code>方法。 换句话说，惰性静态字段的<code>getstatic</code>字节码执行与<em>任何</em>静态字段相同的链接。 初始化之后（或在当前线程已经开始的初始化过程中），JVM解析与该字段关联的常量池元素，并将从常量池获得的值存储在此字段中。 </p><br><p> 由于惰性static final不能为空，因此无法为它们分配任何值-即使在少数情况下，它们也可以用于空final变量。 </p><br><p> 在编译期间，所有惰性静态字段都独立于非惰性静态字段进行初始化，无论它们在源代码中的位置如何。 因此，对静态字段位置的限制不适用于惰性静态字段。 惰性静态字段初始化程序可以使用同一类的任何静态字段，无论它们在源中出现的顺序如何。 任何非静态字段的初始化程序或类初始化程序都可以访问惰性字段，而不管它们在源中相对于彼此的顺序如何。 通常，这样做不是最明智的主意，因为会丢失惰性值的全部含义，但可以在条件表达式或控制流中以某种方式使用它。 因此，可以将惰性静态字段更像另一个类的字段，在某种意义上，可以从声明它们的类的任何部分以任何顺序对其进行引用。 </p><br><p> 可以使用反射API通过使用<code>java.lang.reflect.Field</code>两个新API方法来检测惰性字段。 当且仅当字段具有<code>lazy</code>修饰符时，新的<code>isLazy</code>方法才返回<code>true</code> 。 当且仅当字段为lazy并且在<code>isAssigned</code>时<code>isAssigned</code>初始化时，新的<code>isAssigned</code>方法才返回<code>false</code> 。  （根据种族的存在，它几乎可以在同一线程中的下一个调用上返回true）。 除了使用<code>isAssigned</code>之外，没有其他方法<code>isAssigned</code>字段是否已初始化。 </p><br><p>  （ <code>isAssigned</code>需要<code>isAssigned</code>调用才能解决与解决循环依赖相关的罕见问题。也许我们可以不用实现此方法就可以做到。但是，编写带有惰性变量的代码的人有时希望仔细了解是否将该值设置为此类变量，其方式与互斥锁用户有时希望从互斥锁中查找是否已锁定（但实际上并不想被锁定）相同。 </p><br><p> 惰性的final字段有一个不寻常的限制：永远不要将它们初始化为默认值。 也就是说，惰性引用字段不应初始化为<code>null</code> ，数字类型不应具有null值。 惰性布尔值只能使用一个值-true初始化，因为<code>false</code>是其默认值。 如果惰性静态字段的初始化程序返回其默认值，则此字段的链接将失败，并显示相应的错误。 </p><br><p> 为此引入了限制。 允许JVM实现将默认值保留为内部看门狗值，以标记未初始化字段的状态。 默认值已在准备时设置的任何字段的初始值中设置（在JLS 5.4.2中进行了描述）。 因此，该值自然会在任何字段的生命周期开始时就已经存在，因此是用作监视该字段状态的看门狗值的逻辑选择。 使用这些规则，您永远无法从惰性静态字段获取原始默认值。 为此，JVM可以例如将惰性字段实现为到相应常量池元素的不可变链接。 </p><br><p> 可以通过将值（可能等于默认值）包装在某些方便类型的盒子或容器中来避免对默认值的限制。 零数字可以包装在非零的Integer引用中。 非基本类型可以包装在Optional中，如果它为null，则为空。 </p><br><p> 为了在实现功能方面保持自由，特别低估了<code>isAssigned</code>方法的要求。 如果JVM可以证明可以在没有可观察到的外部影响的情况下初始化惰性静态变量，则它可以随时进行初始化。 在这种情况下，即使从未调用过<code>getfield</code> ， <code>isAssigned</code>也将返回<code>true</code> 。 对<code>isAssigned</code>施加的唯一要求是，如果它返回<code>false</code> ，则在当前线程中不应观察到任何变量初始化的副作用。 如果他返回<code>true</code> ，那么当前线程将来可能会观察到初始化的副作用。 这样的约定允许编译器在其自己的字段中用<code>getstatic</code>替换<code>ldc</code> ，这使JVM不监视常量池中具有公共或退化元素的最终变量的详细状态。 </p><br><p> 多个线程可以进入竞争状态以初始化惰性的final字段。 正如<code>CONSTANT_Dynamic</code>所发生的那样，JVM选择了该比赛的任意获胜者，并将该获胜者的值提供给参与该比赛的所有线程，并将其写入所有随后的获取值的尝试。 为了绕开比赛，特定的JVM实现可以尝试使用CAS操作，如果平台支持它们，则比赛的获胜者将看到先前的默认值，而失败者将看到赢得比赛的非默认值。 </p><br><p> 因此，用于最终变量的单个分配的现有规则继续有效，现在捕获了延迟计算的所有困难。 </p><br><p> 相同的逻辑适用于使用最终字段的安全发布-惰性和非惰性字段都相同。 </p><br><p> 请注意，一个类可以将静态字段转换为惰性静态字段，而不会破坏二进制兼容性。 在两种情况下， <code>getstatic</code>客户语句<code>getstatic</code>相同的。 当变量声明更改为惰性时，将以不同的方式链接<code>getstatic</code> 。 </p><br><h1 id="alternativnye-resheniya"> 替代解决方案 </h1><br><p> 您可以将嵌套类用作惰性变量的容器。 </p><br><p> 您可以定义诸如库API之类的内容，以管理惰性值或（通常）管理任何单调数据。 </p><br><p> 重构它们将要创建惰性静态变量的内容，以使它们变为空静态方法，并以某种方式使用ldc CONSTANT_Dynamic常量发布其主体。 </p><br><p>  （注意：以上变通办法没有提供一种二进制兼容的方法来从其<code>&lt;clinit&gt;</code>逐步解耦现有的静态常量） </p><br><p> 如果我们谈论提供<em>更多</em>功能，则可以允许惰性字段为非静态或非最终字段，同时保持静态字段和非静态字段的行为之间的当前对应关系和类比。 常量池不能是非静态字段的存储库，但它仍可以包含引导程序方法（取决于当前实例）。 冻结的数组（如果已实现）可以采用延迟选项。 这些研究为基于此文档的未来项目奠定了良好的基础。 顺便说一下，这些机会使我们决定禁止默认值更加有意义。 </p><br><p> 惰性变量必须使用其自己的初始化表达式进行初始化。 有时，这似乎是一个非常令人不愉快的限制，使我们回到了空的最终变量发明的时代。 回想一下，这些空的最终变量可以使用任意代码块（包括try-finally逻辑）进行初始化，并且可以成组而不是同时进行初始化。 将来，将有可能尝试将相同的可能性应用于延迟的最终变量。 可能将一个或多个惰性变量与初始化代码的专用块关联，该初始化代码的任务是恰好为每个变量分配一次，这与类初始化器或对象构造函数一样。 解构函数出现后，此类功能的体系结构会变得更加清晰，因为它们解决的任务在某种意义上是相交的。 </p><br><blockquote> 分钟的广告。  Joker 2018大会将很快举行，届时将有许多Java和JVM的知名专家。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在官方网站上</a>查看发言人和报告的完整列表。 </blockquote><br><h1 id="avtor"> 作者 </h1><br><p>  <strong>John Rose</strong>是Oracle的JVM工程师和架构师。 首席工程师达芬奇机器项目（OpenJDK的一部分）。 首席工程师JSR 292（在Java平台上支持动态类型的语言）专门研究动态调用和相关主题，例如类型分析和高级编译器优化。 以前，他从事内部类的研究，在SPARC，Unsafe API上建立了最初的HotSpot端口，还开发了许多动态，并行和混合语言，包括Common Lisp，Scheme（“ esh”）和C ++的动态绑定器。 </p><br><h1 id="perevodchik"> 译者 </h1><br><p>  <strong>Oleg Chirukhin-</strong>在撰写本文时，他正在JUG.ru Group公司担任社区经理，他从事Java平台的普及。 在加入JRG之前，他参与了银行和政府信息系统，自定义编程语言生态系统以及在线游戏的开发。 当前的研究兴趣包括虚拟机，编译器和编程语言。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422629/">https://habr.com/ru/post/zh-CN422629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422615/index.html">关于RTOS的全部真相。 第9条。 调度程序：实施</a></li>
<li><a href="../zh-CN422617/index.html">关于RTOS的全部真相。 第8条 Nucleus SE：内部设计和部署</a></li>
<li><a href="../zh-CN422623/index.html">如何保护C</a></li>
<li><a href="../zh-CN422625/index.html">我们与“神经巫师”的程序员Troy Miles进行了交谈</a></li>
<li><a href="../zh-CN422627/index.html">MongoDB和IT就业市场研究</a></li>
<li><a href="../zh-CN422631/index.html">QIWI终端。 如何充分利用简单技术</a></li>
<li><a href="../zh-CN422633/index.html">我们如何自动监控联邦加油站网络员工的工作</a></li>
<li><a href="../zh-CN422635/index.html">您尚未说“你好”一词，我们已经知道您是谁</a></li>
<li><a href="../zh-CN422637/index.html">怪胎的礼物：自动碱保护</a></li>
<li><a href="../zh-CN422641/index.html">极夜，抽水和智能保险箱：物联网领域的5个学生项目</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>