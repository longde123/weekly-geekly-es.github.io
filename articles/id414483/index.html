<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏽 📟 🔽 Ketik Safe SQL di Kotlin 🕡 🏤 👴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ekspresivitas adalah properti yang menarik dari bahasa pemrograman. Dengan hanya menggabungkan ekspresi, Anda dapat mencapai hasil yang mengesankan. B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketik Safe SQL di Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414483/"><p>  Ekspresivitas adalah properti yang menarik dari bahasa pemrograman.  Dengan hanya menggabungkan ekspresi, Anda dapat mencapai hasil yang mengesankan.  Beberapa bahasa dengan sengaja menolak gagasan ekspresif, tetapi Kotlin jelas bukan bahasa seperti itu. </p><br><p>  Menggunakan konstruksi bahasa dasar dan sedikit gula, kami akan mencoba untuk membuat ulang SQL di sintaks Kotlin sedekat mungkin. </p><br><p><img src="https://habrastorage.org/webt/hv/pn/x5/hvpnx5fkihdhd0ge8glwzjyruy0.png" alt="vs."></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan GitHub untuk yang tidak sabar</a> </p><br><p> Tujuan kami adalah untuk membantu programmer menangkap bagian kesalahan tertentu pada tahap kompilasi.  Kotlin, sebagai bahasa yang diketik sangat, akan membantu kami untuk menghilangkan ekspresi yang tidak valid dalam struktur query SQL.  Sebagai bonus, kami akan mendapatkan lebih banyak perlindungan kesalahan ketik dan bantuan dari IDE dalam menulis permintaan.  Tidak mungkin untuk memperbaiki kelemahan SQL sepenuhnya, tetapi sangat mungkin untuk memperbaiki beberapa area masalah. </p><br><p>  Artikel ini akan memberi tahu Anda tentang perpustakaan Kotlin, yang memungkinkan Anda menulis kueri SQL dalam sintaksis Kotlin.  Kami juga melihat bagian dalam perpustakaan untuk memahami cara kerjanya. </p><a name="habracut"></a><br><h1 id="nemnogo-teorii">  Sedikit teori </h1><br><p>  SQL singkatan dari Structured Query Language, mis.  struktur kueri hadir, meskipun sintaksinya buruk - bahasa dibuat sehingga dapat digunakan oleh pengguna yang bahkan tidak memiliki keterampilan pemrograman. </p><br><p>  Namun, di bawah SQL terletak fondasi yang agak kuat dalam bentuk teori database relasional - semuanya sangat logis di sana.  Untuk memahami struktur kueri, kita beralih ke pilihan sederhana: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-comment"><span class="hljs-comment">--  (projection), π(id, name) FROM employees --  (table) WHERE organization_id = 1 --    (predicate), σ(organization_id = 1)</span></span></code> </pre> <br><p>  Yang penting dipahami: permintaan terdiri dari tiga bagian berturut-turut.  Masing-masing bagian ini, pertama, tergantung pada yang sebelumnya, dan kedua, menyiratkan serangkaian ekspresi terbatas untuk melanjutkan permintaan.  Bahkan, itu tidak sepenuhnya: ekspresi FROM di sini jelas utama dalam kaitannya dengan SELECT, karena  kumpulan bidang apa yang dapat kita pilih tergantung pada tabel dari mana pemilihan dilakukan, tetapi tidak sebaliknya. </p><br><p><img src="https://habrastorage.org/webt/kw/8t/vz/kw8tvzj3r8dltbj9b5yt1llxiiq.png" alt="SQL"></p><br><h1 id="perenos-na-kotlin">  Porting ke Kotlin </h1><br><p>  Jadi, FROM adalah yang utama sehubungan dengan konstruksi bahasa permintaan lainnya.  Dari ungkapan ini semua opsi yang memungkinkan untuk melanjutkan permintaan muncul.  Di Kotlin, kami merefleksikan ini melalui fungsi from (T), yang akan mengambil objek input, yang merupakan tabel yang memiliki seperangkat kolom. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Employees : <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span>("employees") { val id = <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>("id") val <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>("name") val organizationId = <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>("organization_id") }</code> </pre><br><p>  Fungsi akan mengembalikan objek yang berisi metode yang mencerminkan kemungkinan kelanjutan dari permintaan.  Konstruk dari selalu datang terlebih dahulu, sebelum ekspresi lain, sehingga melibatkan sejumlah besar ekstensi, termasuk SELECT akhir (sebagai lawan dari SQL, di mana SELECT selalu datang sebelum DARI).  Kode yang setara dengan kueri SQL di atas akan terlihat seperti ini: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> { e -&gt; e.organizationId eq <span class="hljs-number"><span class="hljs-number">1</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { e -&gt; e.id .. e.name }</code> </pre><br><p>  Menariknya, dengan cara ini kita dapat mencegah SQL tidak valid bahkan pada waktu kompilasi.  Setiap ekspresi, setiap pemanggilan metode dalam rantai menyiratkan sejumlah ekstensi.  Kami dapat mengontrol validitas permintaan menggunakan bahasa Kotlin.  Sebagai contoh, di mana ekspresi tidak menyiratkan kelanjutan dalam bentuk yang lain di mana dan, apalagi, dari, tetapi groupBy, memiliki, orderBy, limit, offset, dan konstruksi pilih akhir semuanya valid. </p><br><p><img src="https://habrastorage.org/webt/zp/nc/xt/zpncxtqxopi2x8j1amy8mitq_6k.png" alt="Kuery"></p><br><p>  Lambdas diteruskan sebagai argumen ke mana dan pernyataan tertentu dirancang untuk membangun predikat dan proyeksi, masing-masing (kami sebutkan sebelumnya).  Sebuah tabel diteruskan ke input lambda sehingga Anda dapat mengakses kolom.  Penting bahwa keselamatan tipe dipertahankan pada level ini juga - dengan bantuan operator yang berlebihan, kami dapat memastikan bahwa predikat pada akhirnya akan menjadi ekspresi pseudo-Boolean yang tidak dapat dikompilasi jika ada kesalahan sintaks atau kesalahan terkait jenis.  Hal yang sama berlaku untuk proyeksi. </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">where</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(predicate: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Predicate): WhereClause&lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(projection: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Iterable&lt;Projection&gt;): SelectStatement&lt;T&gt;</code> </pre><br><h1 id="join">  Bergabunglah </h1><br><p>  Database relasional memungkinkan Anda untuk bekerja dengan banyak tabel dan hubungan di antara mereka.  Akan menyenangkan untuk memberi pengembang kesempatan untuk bekerja dengan BERGABUNG di perpustakaan kami.  Untungnya, model relasional cocok dengan semua yang dijelaskan sebelumnya - Anda hanya perlu menambahkan metode join, yang akan menambahkan tabel kedua ke ekspresi kami. </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T2: Table&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(table2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: JoinClause&lt;T, T2&gt;</code> </pre><br><p>  BERGABUNG, dalam hal ini, akan memiliki metode yang mirip dengan yang disediakan oleh ekspresi FROM, dengan satu-satunya perbedaan adalah bahwa proyeksi dan predikat lambda akan mengambil dua parameter masing-masing untuk dapat mengakses kolom dari kedua tabel. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(Organizations).<span class="hljs-keyword"><span class="hljs-keyword">on</span></span> { e, o -&gt; o.id eq e.organizationId } .<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> { e, o -&gt; e.organizationId eq <span class="hljs-number"><span class="hljs-number">1</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { e, o -&gt; e.id .. e.name .. o.name }</code> </pre><br><h1 id="upravlenie-dannymi">  Manajemen data </h1><br><p>  Bahasa manipulasi data adalah alat bahasa SQL yang, di samping tabel kueri, memungkinkan Anda untuk menyisipkan, memodifikasi, dan menghapus data.  Desain ini sangat cocok dengan model kami.  Untuk mendukung pembaruan dan penghapusan, kita hanya perlu menambahkan dari dan tempat ekspresi dengan varian dengan panggilan metode yang sesuai.  Untuk mendukung penyisipan, kami memperkenalkan fungsi tambahan ke dalam. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> { e -&gt; e.id eq <span class="hljs-number"><span class="hljs-number">1</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">update</span></span> { e -&gt; e.name("John Doe") } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> { e -&gt; e.id eq <span class="hljs-number"><span class="hljs-number">0</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">into</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> { e -&gt; e.name("John Doe") .. e.organizationId(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br><h1 id="opisanie-dannyh">  Deskripsi Data </h1><br><p>  SQL berfungsi dengan data terstruktur dalam bentuk tabel.  Tabel membutuhkan deskripsi sebelum bekerja dengannya.  Bagian bahasa ini disebut Bahasa definisi data. </p><br><p>  Pernyataan CREATE TABLE dan DROP TABLE diimplementasikan dengan cara yang sama - fungsi over akan berfungsi sebagai titik awal. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(Employees) .<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> { <span class="hljs-type"><span class="hljs-type">integer</span></span>(it.id).primaryKey(autoIncrement = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).. text(it.name).<span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>().<span class="hljs-keyword"><span class="hljs-keyword">notNull</span></span>().. <span class="hljs-type"><span class="hljs-type">integer</span></span>(it.organizationId).foreignKey(<span class="hljs-keyword"><span class="hljs-keyword">references</span></span> = Organizations.id) }</code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(Employees).<span class="hljs-keyword"><span class="hljs-keyword">drop</span></span>()</code> </pre><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode dan Dokumentasi</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414483/">https://habr.com/ru/post/id414483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414473/index.html">Ninja DVR: Ulasan Neoline G-Tech X27 Dual</a></li>
<li><a href="../id414475/index.html">“Pengguna akhir - kami bersama Anda”: ​​tentang pengembangan Android di CFT</a></li>
<li><a href="../id414477/index.html">Jebakan memilih layar LED untuk ruang rapat atau ruang konferensi, bukan proyektor</a></li>
<li><a href="../id414479/index.html">D-panthenol: obat untuk selamanya</a></li>
<li><a href="../id414481/index.html">Kuis PHP Jumat: beberapa petualangan programmer Brad, satu urutan aneh dan hadiah</a></li>
<li><a href="../id414485/index.html">GNMT, kegagalan epik atau seluk-beluk terjemahan mesin</a></li>
<li><a href="../id414487/index.html">Perwakilan tipe brute-force yang langka: sejarah satu serangan</a></li>
<li><a href="../id414489/index.html">AS berencana untuk secara serius mengatasi masalah puing-puing luar angkasa</a></li>
<li><a href="../id414493/index.html">Cara menulis kontrak pintar untuk ICO dalam 5 menit</a></li>
<li><a href="../id414495/index.html">toString: Hebat dan Mengerikan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>