<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéüÔ∏è üëåüèº üï∫üèΩ Archivos QVD: lo que hay dentro, parte 3 ü§Ø üôåüèª üéÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el primer art√≠culo sobre la estructura del archivo QVD, describ√≠ la estructura general y me detuve en los metadatos con suficiente detalle, y el se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Archivos QVD: lo que hay dentro, parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfastrah/blog/457102/"><p>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo</a> sobre la estructura del archivo QVD, describ√≠ la estructura general y me detuve en los metadatos con suficiente detalle, y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> sobre el almacenamiento de columnas (caracteres).  En este art√≠culo, describir√© el formato para almacenar informaci√≥n sobre cadenas, resumir y hablar sobre planes y logros. </p><br><p>  Entonces (recuerde) el archivo QVD corresponde a la tabla relacional, en el archivo QVD la tabla se almacena en dos partes conectadas indirectamente: </p><br><p>  Las tablas de caracteres (mi t√©rmino) contienen valores √∫nicos para cada columna en la tabla de origen.  Habl√© de ellos en el segundo art√≠culo. </p><br><p>  La tabla de filas contiene las filas de la tabla de origen, cada fila almacena los √≠ndices de los valores de columna (campo) de la fila en la tabla de s√≠mbolos correspondiente.  De esto se tratar√° este art√≠culo. </p><a name="habracut"></a><br><p>  En el ejemplo de nuestro plato (recuerde, de la primera parte) </p><br><pre><code class="plaintext hljs">SET NULLINTERPRET =&lt;sym&gt;; tab1: LOAD * INLINE [ ID, NAME 123.12,"Pete" 124,12/31/2018 -2,"Vasya" 1,"John" &lt;sym&gt;,"None" ];</code> </pre> <br><p>  En la tabla de filas de nuestro archivo QVD, esta etiqueta corresponder√° a 5 filas, siempre una coincidencia exacta: cu√°ntas filas hay en la tabla, cu√°ntas filas hay en la tabla de filas del archivo QVD. </p><br><p>  Una fila en la tabla de filas consta de enteros no negativos, cada uno de estos n√∫meros es un √≠ndice en la tabla de s√≠mbolos correspondiente.  En el nivel l√≥gico, todo es simple, queda por aclarar los matices y dar un ejemplo (desmontar, ya que nuestra placa de identificaci√≥n se presenta en QVD). </p><br><h2 id="format-tablicy-strok">  Formato de tabla de filas </h2><br><p>  La tabla de filas consta de K * N bytes, donde </p><br><ul><li>  K: el n√∫mero de filas en la tabla de origen (el valor de la etiqueta de metadatos "NoOfRecords") </li><li>  N - longitud de byte de la fila de la tabla de s√≠mbolos (el valor de la etiqueta de metadatos "RecordByteSize") </li></ul><br><p>  La tabla de l√≠neas comienza con el desplazamiento "Offset" (etiqueta de metadatos) relativo al comienzo de la parte binaria del archivo. </p><br><p>  La informaci√≥n sobre la tabla de filas (longitud, tama√±o de fila, desplazamiento) se almacena en la parte general de los metadatos. </p><br><h2 id="format-stroki-tablicy-strok">  Formato de fila de tabla de filas </h2><br><p>  Todas las filas de la tabla de filas tienen el mismo formato y son una concatenaci√≥n de "n√∫meros sin signo".  La longitud del n√∫mero es m√≠nimamente suficiente para representar un campo espec√≠fico: la longitud depende del n√∫mero de valores √∫nicos de un campo en particular. </p><br><p>  Para los campos con un valor (como ya escrib√≠), esta longitud ser√° cero (este valor es el mismo en cada fila de la tabla de origen y se almacena en la tabla de s√≠mbolos correspondiente). </p><br><p>  Para campos con dos valores, esta longitud ser√° igual a uno (los posibles valores de √≠ndice en la tabla de s√≠mbolos son 0 y 1), y as√≠ sucesivamente. </p><br><p>  Dado que la longitud total de la fila de la tabla de filas debe ser un m√∫ltiplo del byte, la longitud del "√∫ltimo car√°cter" est√° alineada con el l√≠mite del byte (ver m√°s abajo cuando analizaremos nuestra placa). </p><br><p>  La informaci√≥n sobre el formato de cada campo se almacena en la secci√≥n de metadatos dedicada a este campo (nos detendremos un poco m√°s abajo), la longitud de la representaci√≥n de bits del campo se almacena en la etiqueta "BitWidth". </p><br><h2 id="hranenie-znacheniy-null">  Almacenar valores NULL </h2><br><p>  ¬øC√≥mo almacenar valores perdidos?  Absteni√©ndome de discutir el tema de por qu√©, responder√© de esta manera: tal como lo entiendo, la siguiente combinaci√≥n corresponde a valores NULL </p><br><ul><li>  La etiqueta "Bias" del campo correspondiente toma el valor "-2" (en general, encontr√© dos valores posibles de esta etiqueta: "0" y "-2") </li><li>  el √≠ndice de campo para la fila donde este campo es NULL es 0 </li></ul><br><p>  En consecuencia, todos los dem√°s √≠ndices en la columna con valores NULL aumentan en 2; veremos en nuestro ejemplo un poco m√°s bajo. </p><br><h2 id="poryadok-sledovaniya-poley-v-stroke">  El orden de los campos en la fila. </h2><br><p>  El orden de los campos en la fila de la tabla de filas corresponde al desplazamiento de bits del campo, que se almacena en la etiqueta "BitOffset" de la secci√≥n de metadatos relacionada con este campo. </p><br><p>  Analicemos nuestro ejemplo (ver metadatos en la primera parte de esta serie). </p><br><p>  Campo de identificaci√≥n </p><br><ul><li>  desplazamiento de bit 0: el campo ser√° el "m√°s a la derecha" </li><li>  longitud de bit 3: el campo ocupar√° 3 bits en una fila de una tabla de filas </li><li>  El sesgo es "-2": el campo tiene valores NULL, todos los √≠ndices se incrementan en 2 </li></ul><br><p>  Campo "NOMBRE" </p><br><ul><li>  Desplazamiento de 3 bits: el campo se encuentra a la izquierda del campo ID en 3 bits. </li><li>  longitud de bit 5: el campo ocupar√° 5 bits en la fila de la tabla de filas (alineado con el l√≠mite de bytes) </li><li>  El sesgo es "0": el campo no tiene valores NULL, todos los √≠ndices son "honestos" </li></ul><br><h2 id="predstavlenie-nashey-tablichki">  Presentaci√≥n de nuestra placa de identificaci√≥n. </h2><br><p>  Veamos los "ceros y unos" reales: dar√© fragmentos del archivo QVD como una representaci√≥n binaria "en formato hexadecimal" (muy compacto). </p><br><p>  Primero, toda la parte binaria (resaltada en rosa, los metadatos se truncan, duelen muchos de ellos ...) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_1.png" alt="imagen"></p><br><p>  Suficientemente compacto, de acuerdo.  Echemos un vistazo m√°s de cerca: justo despu√©s de los metadatos hay tablas de s√≠mbolos (los metadatos, por cierto, en este archivo terminaron con un salto de l√≠nea y un byte cero - t√©cnicamente esto sucede, cero bytes despu√©s de que los metadatos deben omitirse ...). </p><br><p>  La primera tabla de s√≠mbolos se resalta en la figura a continuaci√≥n. </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_2.png" alt="imagen"></p><br><p>  Vemos: </p><br><p>  El primer valor √∫nico del <strong>campo ID</strong> es </p><br><ul><li>  El tipo "6" (el primer byte asignado) es un n√∫mero de coma flotante con una cadena (consulte el segundo art√≠culo) </li><li>  despu√©s del primer byte, 8 de los siguientes bytes es un n√∫mero binario representado en coma flotante </li><li>  despu√©s de ellos viene la representaci√≥n de cadena, muy conveniente (no es necesario recordar, cu√°l era el n√∫mero), que termina con un byte cero </li></ul><br><p>  Los tres valores √∫nicos restantes son del tipo 5 (un n√∫mero entero con una cadena): los valores son "124", "-2" y "1" (f√°ciles de ver a lo largo de las l√≠neas). </p><br><p>  En la figura a continuaci√≥n, resalt√© la segunda tabla de s√≠mbolos (para el campo "NOMBRE") </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_3.png" alt="imagen"></p><br><p>  El primer valor √∫nico del <strong>campo "NOMBRE"</strong> es el tipo "4" (el primer byte asignado), una cadena que termina en cero. </p><br><p>  Los otros cuatro valores √∫nicos son tambi√©n las cadenas "31/12/2018", "Vaysa", "John" y "Ninguno". </p><br><p>  Ahora: la tabla de filas (resaltada en la figura a continuaci√≥n) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_4.png" alt="imagen"></p><br><p>  Como se esperaba - 5 bytes (5 l√≠neas por un byte). </p><br><p>  <strong>La primera l√≠nea</strong> (correspondiente a la l√≠nea 123.12, "Pete" de nuestro plato) </p><br><p>  El valor de la cadena es el byte "02" (binario 000000010). </p><br><p>  Sep√°ralo (recuerda la descripci√≥n anterior) </p><br><ul><li>  derecha 3 bits (binario 010, en nuestra opini√≥n es 2) - este es un √≠ndice en la tabla de s√≠mbolos del campo "ID" </li><li>  tenemos el campo "ID" contiene NULL, por lo que el √≠ndice aumenta en 2, es decir  el √≠ndice resultante es 0, que corresponde al car√°cter "123.12". </li><li>  los siguientes 5 bits (binario y decimal 0) es el √≠ndice en la tabla de s√≠mbolos del campo "NOMBRE", no contiene NULL, por lo tanto, este es el √≠ndice "Pete" en la tabla de s√≠mbolos. </li></ul><br><p>  <strong>Segunda fila</strong> (124.12 / 31/2018) en la tabla de filas </p><br><p>  Valor - byte "0B" (binario 00001011) </p><br><ul><li>  derecha 3 bits (binario 011, en nuestra opini√≥n es 3) - este es el √≠ndice en la tabla de s√≠mbolos del campo "ID" </li><li>  tenemos el campo "ID" contiene NULL, por lo que el √≠ndice aumenta en 2, es decir  el √≠ndice resultante es 1, que corresponde al s√≠mbolo "124". </li><li>  los siguientes 5 bits (binario y decimal 1) es el √≠ndice en la tabla de s√≠mbolos del campo "NOMBRE", no contiene NULL, por lo que este es el √≠ndice "31/12/2018" en la tabla de s√≠mbolos. </li></ul><br><p>  Bueno y as√≠ sucesivamente, echemos un vistazo r√°pido a la <strong>√∫ltima l√≠nea</strong> : all√≠ la ten√≠amos, "Ninguna" (es decir, NULL y la cadena "Ninguna"): <br></p><p>  El valor es el byte "20" (binario 0010000) </p><br><ul><li>  derecha 3 bits (binario y decimal 0): este es el √≠ndice en la tabla de s√≠mbolos del campo "ID" </li><li>  tenemos el campo "ID" contiene NULL, por lo que el √≠ndice aumenta en 2, es decir  el √≠ndice final es -2, que corresponde al valor NULL. </li><li>  los siguientes 5 bits (binario 100, decimal 4) es el √≠ndice en la tabla de s√≠mbolos del campo "NOMBRE", no contiene NULL, por lo que este es el √≠ndice "Ninguno" en la tabla de s√≠mbolos. </li></ul><br><p>  <strong>IMPORTANTE</strong> No puedo encontrar un ejemplo que confirme esto, pero encontr√© archivos que conten√≠an un √≠ndice final de -1 para valores NULL.  Por lo tanto, en mis programas considero NULL todos los campos cuyo √≠ndice final es negativo. </p><br><h2 id="bolee-dlinnye-stroki-v-tablice-strok">  Filas m√°s largas en una tabla de filas </h2><br><p>  Al final del an√°lisis del formato QVD, me detendr√© brevemente en matices importantes: las l√≠neas largas en la tabla de filas almacenan campos en el orden de derecha a izquierda, donde el campo con desplazamiento de cero bits ser√° el m√°s a la derecha (como describ√≠ anteriormente).  <strong>PERO el</strong> orden de bytes es inverso, es decir  el primer byte ser√° el m√°s a la derecha (y contendr√° el campo "derecho" - un campo con desplazamiento de cero bits), el √∫ltimo byte ser√° el primero (es decir, contendr√° el campo m√°s "izquierdo" - un campo con el m√°ximo desplazamiento de bits). </p><br><p>  Se debe dar un ejemplo, pero no sobrecargarse con detalles.  Echemos un vistazo a dicha etiqueta (cito un fragmento; para obtener l√≠neas largas en la tabla de filas, debe aumentar el n√∫mero de valores √∫nicos). </p><br><pre> <code class="plaintext hljs">tab2: LOAD * INLINE [ ID, VAL, NAME, PHONE, SINGLE 1, 100001, "Pete1", "1234567890", "single value" 2, 200002, "Pete2", "2234567890", "single value" ... ];</code> </pre> <br><p>  Breve informaci√≥n sobre los campos (exprimir metadatos): </p><br><ul><li>  ID: ancho 8 bits, desplazamiento de bit - 0, sesgo - 0 </li><li>  VAL: ancho 5 bits, desplazamiento de bits - 8, sesgo - 0 </li><li>  NOMBRE: ancho 6 bits, desplazamiento de bit - 18, sesgo - 0 </li><li>  TEL√âFONO: ancho 5 bits, desplazamiento de bits - 13, sesgo - 0 </li><li>  INDIVIDUAL: ancho 0 bits (tiene un valor) </li></ul><br><p>  La tabla de filas consta de cadenas con una longitud de 3 bytes, respectivamente, en la fila de la tabla de filas, los datos sobre los campos se descompondr√°n l√≥gicamente de la siguiente manera: </p><br><ul><li>  primeros 6 bits - campo "NOMBRE" </li><li>  5 bits siguientes - campo "TEL√âFONO" </li><li>  luego 5 bits - campo "VAL" </li><li>  √∫ltimos 8 bits - campo ID </li></ul><br><p>  La secuencia l√≥gica se convierte en bytes f√≠sicos en el orden inverso, es decir. </p><br><ul><li>  el campo "ID" ocupa completamente el primer byte (que en la secuencia l√≥gica es el √∫ltimo) </li><li>  el campo "VAL" ocupa los 5 bits inferiores del segundo byte </li><li>  el campo "TEL√âFONO" ocupa los 3 bits superiores del segundo byte y los 2 bits inferiores del tercer byte </li><li>  el campo "NOMBRE" ocupa los 6 bits superiores del tercer byte </li></ul><br><p>  Veamos ejemplos, as√≠ es como se ve la primera fila de la tabla de filas (resaltada en rosa) </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_5.png" alt="imagen"></p><br><p>  Valores de campo </p><br><ul><li>  ID - binario 00000000, decimal 0 </li><li>  VAL - binario 00010, decimal 2, restar 2 del sesgo - obtener 0 </li><li>  TEL√âFONO - binario 00010, decimal 2, restar 2 del sesgo - obtener 0 </li><li>  NOMBRE - binario 000000, decimal 0 </li></ul><br><p>  Es decir, la primera l√≠nea contiene los primeros caracteres de las tablas de caracteres correspondientes. </p><br><p>  En general, es conveniente comenzar a analizar desde la primera l√≠nea: generalmente contiene ceros como √≠ndice (el archivo QVD est√° construido de tal manera que los valores de la primera l√≠nea entran primero en la tabla de caracteres). </p><br><p>  Veamos la segunda l√≠nea para arreglar </p><br><p><img src="http://mybizcloud.ru/wiki/lib/exe/fetch.php?cache=&amp;media=datalake:qvd_bin_7.png" alt="imagen"></p><br><p>  Valores de campo </p><br><ul><li>  ID - binario 00000001, decimal 1 </li><li>  VAL - binario 00011, decimal 3, restar 2 del sesgo - obtener 1 </li><li>  TEL√âFONO - binario 00011, decimal 3, reste 2 del sesgo - obtenga 1 </li><li>  NOMBRE - binario 000001, decimal 1 </li></ul><br><p>  Es decir, la segunda l√≠nea contiene los segundos caracteres de las tablas de caracteres correspondientes. </p><br><h2 id="effektivnyy-razbor-formata">  An√°lisis de formato eficiente </h2><br><p>  Compartir√© un poco de experiencia: c√≥mo t√©cnicamente "leo" QVD. </p><br><p>  La primera versi√≥n fue escrita en python (la ennoblecer√© y la pondr√© en github). </p><br><p>  Los principales problemas se aclararon r√°pidamente: </p><br><ul><li>  las tablas de s√≠mbolos solo se pueden leer "en una fila" (es imposible leer el n√∫mero de s√≠mbolo N sin leer todos los caracteres anteriores) </li><li>  los archivos reales no caben en la RAM </li><li>  de las operaciones m√°s lentas (excepto para trabajar con archivos): operaciones de bits (desempaquetar una fila de una tabla de cadenas) </li><li>  el rendimiento disminuye mucho en archivos QVD "anchos" (cuando hay muchas columnas) </li></ul><br><p>  Algunos de estos problemas pueden resolverse cambiando el lenguaje (de python a C, por ejemplo).  Parte requiri√≥ alguna acci√≥n adicional. </p><br><p>  La implementaci√≥n actual bastante r√°pida se ve as√≠: la l√≥gica general se implementa en python, y las operaciones m√°s cr√≠ticas se llevan a cabo en programas C separados que se ejecutan en paralelo. </p><br><p>  En breve </p><br><ul><li>  las tablas de s√≠mbolos se escriben en archivos, los √≠ndices se crean adicionalmente para campos de texto, por lo tanto, es posible leer el n√∫mero de s√≠mbolo N </li><li>  trabajar con QVD y archivos con tablas de s√≠mbolos implementadas a trav√©s de archivos mapeados en memoria (mucho m√°s r√°pido) </li><li>  primero, en paralelo (con un l√≠mite en el n√∫mero de procesadores), los archivos se crean con tablas de s√≠mbolos (e √≠ndices) </li><li>  luego en paralelo (con una restricci√≥n similar) se leen las filas de la tabla de filas y se crean archivos csv (en HDFS) </li><li>  el √∫ltimo paso es convertir estos archivos a una tabla ORC (usando las herramientas de Hive) </li><li>  en C implement√≥ la creaci√≥n de archivos con tablas de s√≠mbolos y la creaci√≥n de un archivo CSV para un rango de l√≠neas </li></ul><br><p>  No quiero dar cifras de rendimiento: requerir√°n vinculaci√≥n al hardware, a nivel cualitativo resulta que se copia el archivo QVD a la tabla ORC a la velocidad de copia de datos a trav√©s de la red.  O, en otras palabras, tomar datos de QVD es bastante realista (a nivel de hogar). </p><br><p>  Tambi√©n implement√© la l√≥gica de crear archivos QVD: funciona bastante r√°pido en Python (aparentemente, a√∫n no he alcanzado grandes vol√∫menes, no hay necesidad. Llegar√© all√≠, lo reescribir√© de la misma manera que la versi√≥n de "lectura"). </p><br><h2 id="plany-na-buduschee">  Planes futuros </h2><br><p>  ¬øQu√© sigue? </p><br><ul><li>  Planeo dise√±ar la versi√≥n de Python del c√≥digo en github (esta versi√≥n le permitir√° "explorar" el archivo QVD - ver metadatos, leer y escribir caracteres, cadenas. La versi√≥n es lo m√°s simple y obviamente m√°s lenta posible - sin archivos para tablas de caracteres, con lectura secuencial, utilizando bibliotecas est√°ndar para trabajar con bits, etc.) </li><li>  Pienso en hacer algo para los pandas (como read_qvd ()), restringe que ser√° lento en Python, as√≠ como el hecho de que obviamente no todos los QVD "encajar√°n" en la memoria, por lo tanto </li><li>  Pienso en hacer que el archivo QVD sea una fuente de datos para Spark: no deber√≠a haber este problema con "no entrar en la memoria" (y el lenguaje all√≠, scala, est√° m√°s cerca del hardware) </li></ul><br><h2 id="vmesto-poslesloviya">  En lugar de un ep√≠logo </h2><br><p>  Durante mucho tiempo estuve dando vueltas y m√°s vueltas a los archivos QVD, parec√≠a que "todo es complicado all√≠".  Result√≥ que era dif√≠cil, pero no muy bueno, un buen √≠mpetu fue Github, que mencion√© en la primera parte (una especie de catalizador).  Entonces fue una cuesti√≥n de tecnolog√≠a.  Yo y todos notamos (una confirmaci√≥n m√°s): todo se puede hacer en la programaci√≥n, la pregunta es tiempo y motivaci√≥n. </p><br><p>  Espero no estar muy cansado de los detalles, estoy listo para responder preguntas (en los comentarios o de cualquier otra manera).  Si habr√° una continuaci√≥n, definitivamente escribir√©. </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457102/">https://habr.com/ru/post/457102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457090/index.html">Cunas de seguridad: JWT</a></li>
<li><a href="../457094/index.html">Complemento de Excel que facilita la configuraci√≥n de filtros cuando se trabaja con cubos (VBA)</a></li>
<li><a href="../457096/index.html">Liberamos nuestras manos a varios analistas: API Livy para la automatizaci√≥n de tareas bancarias t√≠picas</a></li>
<li><a href="../457098/index.html">Elegante manejo de errores de JavaScript con la m√≥nada Either</a></li>
<li><a href="../457100/index.html">AWS Lambda - Teor√≠a, Conocimiento</a></li>
<li><a href="../457106/index.html">La guerra de llamadas autom√°ticas de EE. UU.</a></li>
<li><a href="../457108/index.html">WWDC19: Comenzando con el plan de prueba para XCTest</a></li>
<li><a href="../457110/index.html">Prueba unitaria de C ++ y patrones de inyecci√≥n simulados utilizando rasgos</a></li>
<li><a href="../457112/index.html">Los resultados de HolyJS 2019 Piter</a></li>
<li><a href="../457114/index.html">Elija un sistema de videovigilancia: nube frente a local con Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>