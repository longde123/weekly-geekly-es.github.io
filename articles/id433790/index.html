<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏼 😰 👨 Templat bangun multi tahap tingkat lanjut 🐵 🚹 ⏬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fungsi pembangunan multi-tahap di Dockerfiles memungkinkan Anda membuat gambar wadah kecil dengan tingkat caching yang lebih tinggi dan perlindungan y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Templat bangun multi tahap tingkat lanjut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/433790/"><p><img src="https://habrastorage.org/getpro/habr/post_images/ae4/9db/b18/ae49dbb18f8454823b9e133b737cacf0.png" alt="gambar"></p><br><p>  Fungsi pembangunan multi-tahap di Dockerfiles memungkinkan Anda membuat gambar wadah kecil dengan tingkat caching yang lebih tinggi dan perlindungan yang lebih sedikit.  Pada artikel ini, saya akan menunjukkan kepada Anda beberapa templat tingkat lanjut - sesuatu yang lebih dari menyalin file antara build dan run.  Mereka memungkinkan Anda untuk mencapai efisiensi maksimum fungsi.  Namun, jika Anda seorang pemula di bidang perakitan multi-tahap, maka pertama-tama, mungkin, tidak akan salah untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan</a> pengguna. </p><a name="habracut"></a><br><h3 id="sovmestimost-versiy">  Kompatibilitas versi </h3><br><p>  Dukungan pembangunan bertingkat ditambahkan ke Docker dalam versi v17.05.  Semua templat bekerja dengan versi berikutnya, tetapi beberapa lebih efisien, berkat tautan yang menggunakan sisi server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BuildKit</a> .  Katakanlah BuildKit secara efektif melewatkan tahapan yang tidak digunakan dan, jika mungkin, membuat tahapan pada saat yang sama (saya menyoroti contoh-contoh ini secara terpisah).  BuildKit saat ini sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditambahkan ke Moby</a> sebagai backend eksperimental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> build dan harus tersedia di Docker CE v18.06.  Ini juga dapat digunakan secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mandiri</a> atau sebagai bagian dari proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">img</a> . </p><br><hr><br><h4 id="nasledovanie-ot-etapa">  Pewarisan Tahap </h4><br><p> Build multi-stage menambahkan beberapa konsep sintaksis baru.  Pertama-tama, Anda dapat memberikan tahap dimulai dengan perintah <code>FROM</code> nama <code>AS stagename</code> dan menggunakan <code>--from=stagename</code> dalam <code>COPY</code> untuk menyalin file dari tahap ini.  Bahkan, perintah <code>FROM</code> dan label <code>--from</code> memiliki banyak kesamaan, bukan karena mereka tidak memiliki nama yang sama.  Keduanya mengambil argumen yang sama, mengenalinya, dan memulai tahap baru dari titik ini, atau menggunakannya sebagai sumber untuk menyalin file.  Artinya, untuk menggunakan tahap sebelumnya dalam kualitas gambar asli untuk tahap saat ini, Anda dapat mengambil tidak hanya <code>--from=stagename</code> , tetapi juga nama panggung <code>FROM stagename</code> .  Berguna jika Anda menggunakan bagian umum yang sama dalam beberapa perintah di Dockerfile: ini mengurangi kode umum dan menyederhanakan pemeliharaannya, menjaga langkah anak terpisah.  Jadi, membangun kembali satu tahap tidak memengaruhi cache perakitan untuk orang lain.  Dengan demikian, setiap tahap dapat dirakit secara terpisah menggunakan label <code>--target</code> saat memanggil <code>docker build</code> . </p><br><pre> <code class="plaintext hljs">FROM ubuntu AS base RUN apt-get update &amp;&amp; apt-get install git FROM base AS src1 RUN git clone … FROM base as src2 RUN git clone …</code> </pre> <br><p>  Dalam contoh ini, fase kedua dan ketiga di BuildKit dibangun secara bersamaan. </p><br><h3 id="neposredstvennoe-ispolzovanie-obrazov">  Penggunaan gambar secara langsung </h3><br><p>  Alih-alih menggunakan nama tahap perakitan dalam perintah <code>FROM</code> yang sebelumnya hanya mendukung referensi gambar, Anda dapat langsung menggunakan gambar menggunakan label <code>--from</code> .  Ternyata untuk menyalin file langsung dari gambar-gambar ini.  Sebagai contoh, <code>linuxkit/ca-certificatesimage</code> dalam kode berikut secara langsung menyalin akar TLS CA ke langkah saat ini. </p><br><pre> <code class="plaintext hljs">FROM alpine COPY --from=linuxkit/ca-certificates / /</code> </pre> <br><h3 id="psevdonim-obschego-obraza">  Alias ​​Citra Umum </h3><br><p>  Fase build tidak harus mencakup perintah apa pun;  mungkin terdiri dari satu baris <code>FROM</code> .  Jika Anda menggunakan gambar di beberapa tempat, ini akan menyederhanakan pembacaan dan membuatnya sehingga jika Anda perlu memperbarui gambar keseluruhan, Anda hanya perlu mengubah satu baris. </p><br><pre> <code class="plaintext hljs">FROM alpine:3.6 AS alpine FROM alpine RUN … FROM alpine RUN …</code> </pre> <br><p>  Dalam contoh ini, setiap tempat yang menggunakan gambar alpine sebenarnya berkomitmen untuk <code>alpine:3.6</code> , bukan <code>alpine:latest</code> .  Ketika tiba saatnya untuk meningkatkan ke <code>alpine:3.7</code> , Anda harus mengubah satu baris, dan tidak ada keraguan: sekarang semua elemen perakitan menggunakan versi yang diperbarui. </p><br><p>  Ini bahkan lebih penting ketika argumen build digunakan dalam alias.  Contoh berikut ini mirip dengan yang sebelumnya, tetapi memungkinkan pengguna untuk mendefinisikan ulang semua instance perakitan di mana gambar alpine terlibat dengan mengatur <code>--build-arg ALPINE_VERSION=value</code> opsi <code>--build-arg ALPINE_VERSION=value</code> .  Ingat: argumen apa pun yang digunakan dalam perintah <code>FROM</code> harus ditentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelum tahap pembuatan pertama</a> . </p><br><pre> <code class="plaintext hljs">ARG ALPINE_VERSION=3.6 FROM alpine:${ALPINE_VERSION} AS alpine FROM alpine RUN …</code> </pre> <br><h3 id="ispolzovanie-argumentov-sborki-v-from">  Menggunakan argumen build di "- from" </h3><br><p>  Nilai yang ditentukan dalam label <code>COPY</code> tidak boleh berisi argumen assembly.  Misalnya, contoh berikut tidak valid. </p><br><pre> <code class="plaintext hljs">// THIS EXAMPLE IS INTENTIONALLY INVALID FROM alpine AS build-stage0 RUN … FROM alpine ARG src=stage0 COPY --from=build-${src} . .</code> </pre> <br><p>  Hal ini disebabkan oleh fakta bahwa ketergantungan antara tahapan harus ditentukan sebelum perakitan dimulai.  Maka evaluasi konstan dari semua tim tidak diperlukan.  Misalnya, variabel lingkungan yang didefinisikan dalam gambar <code>alpine</code> dapat memengaruhi evaluasi nilai <code>--from</code> .  Alasan kita dapat mengevaluasi argumen dari perintah <code>FROM</code> adalah karena argumen ini didefinisikan secara global sebelum tahap apa pun dimulai.  Untungnya, seperti yang kami ketahui sebelumnya, itu sudah cukup untuk menentukan tahap alias menggunakan satu perintah <code>FROM</code> dan merujuknya. </p><br><pre> <code class="plaintext hljs">ARG src=stage0 FROM alpine AS build-stage0 RUN … FROM build-${src} AS copy-src FROM alpine COPY --from=copy-src . .</code> </pre> <br><p>  Sekarang, jika Anda menimpa argumen assembly <code>src</code> , langkah awal untuk elemen <code>COPY</code> akhir akan beralih.  Harap perhatikan: jika beberapa langkah tidak lagi digunakan, maka hanya penghubung berbasis BuildKit yang dapat melompati mereka secara efektif. </p><br><h3 id="usloviya-ispolzuyuschie-argumenty-sborki">  Ketentuan Menggunakan Argumen Build </h3><br><p>  Kami diminta untuk menambahkan dukungan untuk kondisi gaya <code>IF/ELSE</code> ke Dockerfile.  Kami belum tahu apakah kami akan menambahkan sesuatu yang serupa, tetapi di masa mendatang kami akan mencoba menggunakan dukungan klien di BuildKit.  Sementara itu, untuk mencapai perilaku serupa, Anda dapat menggunakan konsep multi-tahap saat ini (dengan beberapa perencanaan). </p><br><pre> <code class="plaintext hljs">// THIS EXAMPLE IS INTENTIONALLY INVALID FROM alpine RUN … ARG BUILD_VERSION=1 IF $BUILD_VERSION==1 RUN touch version1 ELSE IF $BUILD_VERSION==2 RUN touch version2 DONE RUN …</code> </pre> <br><p>  Contoh sebelumnya menunjukkan kode semu untuk kondisi perekaman menggunakan <code>IF/ELSE</code> .  Untuk mencapai perilaku serupa dengan pembangunan multi-tahap saat ini, Anda mungkin perlu mendefinisikan berbagai kondisi cabang sebagai langkah terpisah dan menggunakan argumen untuk memilih jalur ketergantungan yang benar. </p><br><pre> <code class="plaintext hljs">ARG BUILD_VERSION=1 FROM alpine AS base RUN … FROM base AS branch-version-1 RUN touch version1 FROM base AS branch-version-2 RUN touch version2 FROM branch-version-${BUILD_VERSION} AS after-condition FROM after-condition RUN …</code> </pre> <br><p>  Langkah terakhir di Dockerfile didasarkan pada langkah <code>after-condition</code> , yaitu alias gambar (dikenali berdasarkan <code>BUILD_VERSION</code> build <code>BUILD_VERSION</code> ).  Bergantung pada nilai <code>BUILD_VERSION</code> , tahap bagian tengah ini atau itu dipilih. </p><br><p>  Harap dicatat: hanya penghubung berbasis BuildKit yang dapat melewati cabang yang tidak digunakan.  Di versi sebelumnya dari tautan, semua tahapan akan dibangun, tetapi sebelum membuat gambar akhir, hasilnya akan dibuang. </p><br><h3 id="pomoschnik-po-razrabotketestirovaniyu-dlya-minimalnogo-proizvodstvennogo-etapa">  Asisten Pengembangan / Pengujian untuk Fase Produksi Minimum </h3><br><p>  Sebagai kesimpulan, mari kita lihat contoh menggabungkan templat sebelumnya untuk menunjukkan cara membuat Dockerfile yang menciptakan gambar produksi minimal dan kemudian dapat menggunakan kontennya untuk menguji dan membuat gambar pengembangan.  Mari kita mulai dengan contoh Dockerfile dasar: </p><br><pre> <code class="plaintext hljs">FROM golang:alpine AS stage0 … FROM golang:alpine AS stage1 … FROM scratch COPY --from=stage0 /binary0 /bin COPY --from=stage1 /binary1 /bin</code> </pre> <br><p>  Ketika gambar produksi minimal dibuat, ini adalah opsi yang cukup umum.  Tetapi bagaimana jika Anda juga perlu mendapatkan gambar pengembang alternatif atau menjalankan tes dengan binari ini pada tahap akhir?  Hal pertama yang terlintas dalam pikiran adalah menyalin binari serupa pada tahap pengujian dan pengembangan.  Masalahnya adalah ini: tidak ada jaminan bahwa Anda akan menguji semua binari produksi dalam kombinasi yang sama.  Pada tahap akhir, sesuatu mungkin berubah, tetapi Anda akan lupa untuk membuat perubahan serupa di tahap lain atau membuat kesalahan dengan cara menyalin file biner.  Pada akhirnya, kami tidak menguji file biner yang terpisah, tetapi gambar terakhir. </p><br><p>  Alternatifnya adalah menentukan fase pengembangan dan pengujian setelah fase produksi dan menyalin seluruh konten dari fase produksi.  Kemudian gunakan satu perintah <code>FROM</code> untuk langkah produksi untuk menjadikan langkah produksi default sebagai langkah terakhir lagi. </p><br><pre> <code class="plaintext hljs">FROM golang:alpine AS stage0 … FROM scratch AS release COPY --from=stage0 /binary0 /bin COPY --from=stage1 /binary1 /bin FROM golang:alpine AS dev-env COPY --from=release / / ENTRYPOINT ["ash"] FROM golang:alpine AS test COPY --from=release / / RUN go test … FROM release</code> </pre> <br><p>  Secara default, Dockerfile ini akan terus membuat gambar default minimum, sementara, misalnya, sebuah perakitan dengan opsi <code>--target=dev-env</code> akan membuat gambar dengan shell yang berisi semua binari dari versi final. </p><br><hr><br><p>  Semoga ini bermanfaat dan menyarankan cara membuat Dockerfiles multi-tahap yang lebih efisien.  Jika Anda berpartisipasi dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DockerCon2018</a> dan ingin mempelajari lebih lanjut tentang pembuatan multi-tahap, Dockerfiles, BuildKit, atau topik terkait lainnya, daftar untuk penghubung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trek Hallway</a> atau ikuti pertemuan internal platform Docker pada lagu <a href="">Contribute and Collaborate</a> atau <a href="">Black Belt</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433790/">https://habr.com/ru/post/id433790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433776/index.html">MongoDB Go Driver Tutorial</a></li>
<li><a href="../id433780/index.html">Transisi dari kit UI ke sistem desain di QIWI</a></li>
<li><a href="../id433782/index.html">Contoh praktis untuk membuat komponen View Anda sendiri</a></li>
<li><a href="../id433786/index.html">Fintech Digest: cryptocurrency adalah properti, sejumlah rekor kartu kredit telah dikeluarkan di Federasi Rusia</a></li>
<li><a href="../id433788/index.html">Transaksi Aman dan Ulasan Freelance Baru</a></li>
<li><a href="../id433792/index.html">Skrip shell dalam Ansible</a></li>
<li><a href="../id433796/index.html">Bagaimana Homo Sapiens menaklukkan dunia. Keterampilan komunikasi dan negosiasi</a></li>
<li><a href="../id433798/index.html">HomeKit dan ioBroker Mari berteman di rumah</a></li>
<li><a href="../id433800/index.html">Menggunakan pengontrol PSBC UDB Cypress untuk mengurangi interupsi pada printer 3D</a></li>
<li><a href="../id433802/index.html">Bagaimana dan mengapa kami memenangkan jalur Big Data di Urban Tech Challenge Hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>