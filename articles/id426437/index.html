<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸµ ğŸŒ‹ ğŸ§“ Bagaimana pengenalan wajah membantu Anda menemukan telepon percobaan ğŸ« ğŸ›µ ğŸ¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, warga Habrovsk! EastBanc Technologies memiliki sejumlah besar proyek yang berkaitan dengan pengembangan ponsel. Dalam hubungan ini, seluruh kebu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana pengenalan wajah membantu Anda menemukan telepon percobaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426437/">  Halo, warga Habrovsk!  EastBanc Technologies memiliki sejumlah besar proyek yang berkaitan dengan pengembangan ponsel.  Dalam hubungan ini, seluruh kebun binatang perangkat diperlukan untuk pengujian di semua tahap.  Dan, secara khas, setiap perangkat tunggal secara konstan dibutuhkan oleh berbagai orang, dan menemukannya bahkan dalam satu departemen pengembangan ponsel beberapa lusin orang adalah keseluruhan cerita.  Belum lagi ada penguji, desainer, PM, pada akhirnya! <br><br>  Dan agar tidak kehilangan telepon, tetapi untuk mengetahui dengan jelas di mana itu dan dengan siapa, kami menggunakan database online yang mengenali karyawan dari wajah mereka.  Sekarang kita akan tahu bagaimana kita sampai pada ini dan menerapkannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83e/934/a48/83e934a48d88da29a8d0d95c6aca33bc.jpg" alt="gambar"><br><a name="habracut"></a><br><h2>  Konteks sejarah </h2><br>  Kami memiliki papan dengan "kartu" perangkat dengan informasi dasar dan tempat untuk magnet yang menunjukkan seorang karyawan.  Semua orang mencatat tentang mengambil perangkat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/ec6/08d/625ec608d24c28558991679a78dab2e7.jpg" alt="gambar"><br><br>  Sistem ini memiliki kelemahan - tidak kritis, tetapi umumnya tidak nyaman: <br><br><ul><li>  Magnet tidak begitu mudah untuk dipindahkan dari satu tempat ke tempat lain. </li><li>  Untuk melihat papan seperti itu, Anda harus pergi ke kantor lain. </li><li> Dan tetap saja, seseorang mungkin membutuhkan banyak perangkat sekaligus ... Yang artinya Anda membutuhkan beberapa magnet per karyawan. </li><li>  Oh ya, bahkan karyawan kadang-kadang berhenti dan yang baru datang, yang juga perlu dibuat magnet. </li></ul><br><h4>  Aplikasi seluler </h4><br>  Dalam sebuah perusahaan yang bergerak dalam proses bisnis otomatis, menggunakan solusi "analog" yang dijelaskan di atas tidak terlalu sehat.  Secara alami, kami memutuskan untuk mengotomatiskan tugas menemukan perangkat yang tepat.  Langkah pertama adalah menulis aplikasi seluler yang dapat menentukan dan melaporkan lokasinya di kamar melalui titik akses Wi-Fi.  Sepanjang jalan, untuk kenyamanan, mereka memberi perangkat kemampuan untuk menginformasikan server tentang versi OS, dan juga menunjukkan karakteristik penting seperti pengisian baterai. <br><br>  Tampaknya masalah terpecahkan.  Anda melihat daftar di database di mana terakhir kali perangkat melihat Wi-Fi, Anda pergi ke sana dan ... <br><br>  Dalam operasi, ternyata tidak semuanya begitu sederhana.  Kami menginstal aplikasi pada perangkat uji dan bekerja dengannya selama beberapa bulan.  Ternyata opsi ini nyaman, tetapi juga tidak ideal. <br><br>  Perangkat kosong, matikan saja, titik akses Wi-Fi diatur ulang dari satu tempat ke tempat lain, dan geolokasi dengan sendirinya hanya mengatakan bahwa perangkat ada di kantor.  Kapten terima kasih! <br><br>  Anda tentu saja dapat mencoba untuk mengoptimalkan sistem yang ada, tetapi mengapa tidak menciptakannya kembali berdasarkan teknologi abad ke-21?  Tidak lebih cepat dikatakan daripada dilakukan. <br><br><h2>  Betapa kami menginginkannya </h2><br>  Kami datang dengan konsep untuk sistem yang akan mengenali karyawan dengan wajah mereka, menguji perangkat dengan tag khusus, meminta konfirmasi perubahan dalam status perangkat, dan kemudian membuat perubahan pada database online, yang dapat dilihat oleh karyawan mana pun tanpa berdiri dari kursinya. <br><br><h2>  Pengenalan wajah </h2><br>  Pengenalan wajah secara keseluruhan memecahkan masalah pada 2018.  Karena itu, kami tidak menemukan kembali roda dan mencoba melatih model kami sendiri, tetapi mengambil keuntungan dari solusi yang sudah jadi.  Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>FaceRecognition</b></a> tampaknya menjadi pilihan yang paling nyaman  itu tidak memerlukan pelatihan tambahan dan bekerja sangat cepat bahkan tanpa akselerasi pada GPU. <br><br>  Menggunakan fungsi <b>face_locations</b> , <b>wajah terdeteksi</b> dalam foto karyawan, dan menggunakan <b>face_encodings,</b> fitur wajah karyawan tertentu diekstraksi dari mereka. <br><br>  Data yang diterima dikumpulkan dalam database.  Untuk menentukan karyawan tertentu menggunakan fungsi <b>face_distance</b> , "perbedaan" antara pengkodean karyawan yang terdeteksi dan pengkodean dari database dipertimbangkan. <br><br>  Secara umum, pada tahap ini orang bisa melangkah lebih jauh dan membuat classifier, misalnya, berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KNN</a> , sehingga sistem itu kurang sensitif terhadap dinamika wajah karyawan.  Namun, dalam praktiknya ini membutuhkan waktu lebih lama.  Ya, dan dangkal rata-rata penyandian wajah seseorang antara yang sekarang ada dalam database dan yang ditemukan sistem untuk mengubah status perangkat ternyata cukup untuk menghindari akumulasi kesalahan dalam praktik. <br><br><div class="spoiler">  <b class="spoiler_title">Kode pengenalan wajah</b> <div class="spoiler_text"><pre><code class="python hljs">face_locations = face_recognition.face_locations(rgb_small_frame) face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations) face_names = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> face_encoding <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> face_encodings: matches = face_recognition.face_distance( known_face_encodings, face_encoding) name = <span class="hljs-string"><span class="hljs-string">"Unknown"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> np.min(matches) &lt;= <span class="hljs-number"><span class="hljs-number">0.45</span></span>: best_match_index = np.argmin(matches) name = known_face_info[str(best_match_index)][<span class="hljs-string"><span class="hljs-string">'name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: best_match_index = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br></div></div><br><h2>  Pengenalan perangkat </h2><br>  Awalnya, muncul ide untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode QR</a> untuk pengenalan perangkat, di mana untuk memasukkan informasi tentang perangkat secara bersamaan.  Namun, untuk pengenalan kode QR yang stabil, harus dibawa sangat dekat dengan kamera, yang merepotkan. <br><br>  Akibatnya, muncul ide untuk menggunakan penanda augmented reality.  Mereka membawa lebih sedikit informasi, tetapi lebih dikenal secara stabil.  Selama percobaan, penanda 30 milimeter dikenali oleh kamera dengan penyimpangan kecil dari vertikal (3-5 derajat) pada jarak hingga dua setengah meter. <br><br>  Opsi ini sudah terlihat jauh lebih baik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ARuco</a> dipilih dari seluruh set <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penanda</a> augmented reality, sebagai  semua alat yang diperlukan untuk bekerja dengannya hadir dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distribusi opencv-contrib-python</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Kode Pengakuan Token ARuco</b> <div class="spoiler_text"><pre> <code class="python hljs">self.video_capture = cv2.VideoCapture(<span class="hljs-number"><span class="hljs-number">0</span></span>) ret, frame = self.video_capture.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) markers = cv2.aruco.detectMarkers(gray, self.dictionary)</code> </pre> <br></div></div><br>  Akibatnya, setiap perangkat diberi indeks numerik, yang digunakan penanda untuk indeks ini. <br><br><h2>  Apakah itu topi? </h2><br>  Tampaknya kita telah belajar mengenali perangkat dan wajah, pekerjaan sudah selesai.  Gembar-gembor, tepuk tangan!  Apa lagi yang mungkin dibutuhkan? <br><br>  Faktanya, pekerjaan baru saja dimulai.  Sekarang semua komponen sistem harus dibuat agar bekerja secara stabil dan cepat "dalam pertempuran". <br><br>  Hal ini diperlukan untuk mengoptimalkan biaya sumber daya server dalam keadaan idle, memikirkan kasus-kasus pengguna dan memahami bagaimana seharusnya terlihat secara grafis. <br><br><h2>  Antarmuka </h2><br>  Mungkin titik paling penting dalam pengembangan sistem tersebut adalah antarmuka.  Seseorang mungkin berdebat, tetapi pengguna adalah elemen utama dalam situasi ini. <br><br>  Secepat mungkin, Anda dapat mengimplementasikan bagian front-end menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tkinter</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa catatan tentang Tkinter</b> <div class="spoiler_text"><ul><li>  Perhatikan unit indentasi / ukuran elemen (relatif atau absolut). </li><li>  Ingat bahwa unit relatif dan absolut dapat digunakan bersama-sama (nilainya diringkas secara sederhana). </li><li>  Parameter <pre> <code class="python hljs">.attributes(<span class="hljs-string"><span class="hljs-string">"-fullscreen"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre>  Memungkinkan Anda membuat aplikasi satu jendela, meluas ke layar penuh, agar tidak membingungkan pengguna dengan elemen antarmuka sistem. </li></ul></div></div><br>  Antarmuka terdiri dari kartu dengan informasi tentang perangkat dan pengguna yang saat ini menggunakan perangkat ini.  Sebagian besar layar ditempati oleh katalog kartu - alat akuntansi utama.  Di bagian atas terdapat filter yang dapat digunakan untuk memfilter direktori berdasarkan platform atau versi sistem operasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de5/5ee/b81/de55eeb81d57374bccd0c0c0e47ba3e6.jpg" alt="gambar"><br><br><h4>  Berikut adalah komponen utama dari antarmuka: </h4><br><ul><li>  <b>Perangkat</b> <br>  Kartu perangkat ditampilkan di layar dengan versi sistem operasi, nama dan ID perangkat, serta pengguna yang terdaftar pada perangkat ini. </li><li>  <b>Memperbaiki foto</b> <br>  Di sebelah kanan adalah unit kontrol, tempat gambar dari webcam ditampilkan, serta tombol untuk mendaftarkan dan mengedit informasi pribadi. <br><br>  Kami menampilkan gambar untuk memberikan umpan balik kepada pengguna - Anda pasti menekan layar dengan label perangkat. </li><li>  <b>Pemilihan versi OS</b> <br>  Kami membuat daftar dengan pilihan versi OS yang menarik, karena  sering untuk pengujian Anda tidak perlu perangkat tertentu, tetapi versi Android atau iOS tertentu.  Filter versi dibuat horizontal untuk menghemat ruang dan membuat daftar versi dapat diakses tanpa menggulir, pada satu layar. </li></ul><br><h2>  Optimasi </h2><br>  Satu lulus dari setiap komponen sistem tidak memerlukan terlalu banyak waktu.  Namun, jika Anda mulai mengenali marker dan wajah secara bersamaan, maka upaya untuk mengenali semua 30 frame per detik yang disediakan oleh kamera akan menyebabkan habisnya sumber daya komputer tanpa GPU. <br><br>  Jelas bahwa 99% dari waktu sistem akan melakukan pekerjaan ini menganggur. <br><br>  Untuk menghindari ini, keputusan optimasi berikut dibuat: <br><br><ol><li>  Hanya setiap frame kedelapan dimasukkan ke dalam pemrosesan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.lastseen + self.rec_threshold &gt; time.time() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> self.frame_number != <span class="hljs-number"><span class="hljs-number">8</span></span>: ret, frame = self.video_capture.read() self.frame_number += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.frame_number &gt; <span class="hljs-number"><span class="hljs-number">8</span></span>: self.frame_number = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> </div></div><br>  Penundaan respons sistem naik menjadi sekitar 8/30 detik, sedangkan waktu reaksi manusia adalah sekitar satu detik.  Karenanya, penundaan seperti itu masih tidak akan terlihat oleh pengguna.  Dan kami sudah delapan kali mengurangi beban pada sistem. </li><li>  Pertama, penanda perangkat dicari dalam bingkai, dan hanya ketika terdeteksi, pengenalan wajah diluncurkan.  Karena pencarian penanda dalam bingkai kira-kira 300 kali lebih murah daripada pencarian wajah, kami memutuskan bahwa dalam mode siaga, kami hanya akan memeriksa keberadaan penanda. </li><li>  Untuk mengurangi "rem" saat mencari wajah ketika tidak ada wajah dalam gambar, parameter number_of_time_to_upsample dinonaktifkan dalam fungsi face_locations. <br><br>  <i>face_locations = face_recognition.face_locations (rgb_small_frame, number_of_times_to_upsample = 0)</i> <br><br>  Karena ini, waktu pemrosesan bingkai, di mana tidak ada wajah, sama dengan waktu pemrosesan bingkai, di mana wajah mudah dideteksi. </li></ol><br><h2>  Apa hasilnya? </h2><br>  Saat ini, sistem telah berhasil digunakan pada MacMini Akhir 2009, yang telah datang, pada dua Core 2 Duo core.  Sebagai bagian dari pengujian, itu bekerja cukup berhasil bahkan pada satu inti virtual dengan 1024 megabita RAM dan 4 gigabita memori hanya baca dalam wadah Docker.  MacMini menghubungkan layar sentuh untuk membuat tampilan minimalis. <br><br>  Sekarang bahkan para pengguna yang tidak menggunakan papan lama dengan antusias dan tersenyum saat mendaftarkan perangkat pada diri mereka sendiri, dan ada jauh lebih sedikit kasus pencarian yang gagal! <br><br><h2>  Apa selanjutnya </h2><br>  Ada banyak poin pasti dalam sistem saat ini yang dapat dan ingin kami tingkatkan: <br><br><ul><li>  Pastikan kontrol OS tidak muncul ketika kotak dialog muncul (sekarang ini adalah kotak pesan dari paket Tkinter). </li><li>  Pisahkan perhitungan dan permintaan server ke utas berbeda dengan pemrosesan antarmuka (sekarang semuanya dilakukan di utas utama, mainloop Tkinter, yang membekukan antarmuka saat mengirim permintaan ke basis data online). </li><li>  Bawa antarmuka ke desain yang sama dengan sumber daya perusahaan lainnya. </li><li>  Buat antarmuka web lengkap untuk melihat data dari jauh. </li><li>  Gunakan pengenalan suara untuk mengkonfirmasi / membatalkan tindakan dan mengisi bidang teks. </li><li>  Menerapkan pendaftaran beberapa perangkat secara bersamaan. </li></ul><br>  <b>PS Dan begini cara kerjanya.</b> <br>  <i>Video direkam dalam versi beta GUI</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://vk.com/video_ext.php" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426437/">https://habr.com/ru/post/id426437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426427/index.html">Barang yang berguna untuk "barang": pilihan kecil dengan harga murah</a></li>
<li><a href="../id426429/index.html">Menginstal FreeSWITCH 1.8 pada Debian 9 (Raspbian Stretch, gambar dasar dari sistem Smart Home MajorDoMo di Rasbperri Pi)</a></li>
<li><a href="../id426431/index.html">Membongkar mesin novel visual Qlie</a></li>
<li><a href="../id426433/index.html">SMM lezat untuk restoran</a></li>
<li><a href="../id426435/index.html">Spesialis terbaik adalah yang saya persiapkan sendiri: kursus pengujian game dari pakar Mail.Ru Group</a></li>
<li><a href="../id426439/index.html">Pemalsuan grafik, penggantian kuotasi dan manipulasi harga: cara memecahkan aplikasi untuk perdagangan di bursa</a></li>
<li><a href="../id426441/index.html">Grup Mail.Ru 20 tahun: pos-pos pemeriksaan kode dan teknologi</a></li>
<li><a href="../id426443/index.html">Sepertinya kita mulai lupa bagaimana eksplorasi ruang angkasa terlihat.</a></li>
<li><a href="../id426449/index.html">iPhone XS: mengapa ini kamera baru</a></li>
<li><a href="../id426451/index.html">Perpisahan yang panjang dengan Baxter, raksasa terlemah di antara robot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>