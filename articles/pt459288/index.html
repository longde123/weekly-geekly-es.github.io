<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî± üë©üèª‚Äçüíº üëºüèø Implementa√ß√£o nativa da biblioteca ECS üòÅ ‚úäüèΩ üßóüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta semana, comecei a trabalhar no meu mecanismo do Vagabond e comecei a implementar o modelo de entidade-componente-sistema . 

 Neste artigo, quer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementa√ß√£o nativa da biblioteca ECS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459288/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png" alt="imagem"></div><br>  Nesta semana, comecei a trabalhar no meu mecanismo do Vagabond e comecei a implementar o modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entidade-componente-sistema</a> . <br><br>  Neste artigo, quero falar sobre minha implementa√ß√£o, dispon√≠vel gratuitamente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Mas, em vez de simplesmente comentar o c√≥digo, quero explicar como sua estrutura foi projetada.  Portanto, come√ßarei com a primeira implementa√ß√£o que escrevi, analisarei seus pontos fortes e fracos e mostrarei como a aprimorei.  No final, listarei uma lista de aspectos que tamb√©m podem ser aprimorados. <br><br><h1>  1. Introdu√ß√£o </h1><br><h2>  Motiva√ß√£o </h2><br>  N√£o falarei sobre os benef√≠cios do ECS sobre a abordagem orientada a objetos, porque muitas pessoas antes de mim fizeram isso bem.  Scott Bilas foi um dos primeiros a falar sobre ECS no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20101011021902/">GDC 2002</a> .  Outras introdu√ß√µes not√°veis ‚Äã‚Äãao t√≥pico incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evolve Your Hierarchy, de</a> Mike West, e o cap√≠tulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Components,</a> do impressionante livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Game Programming Patterns</a> de Robert Nistrom. <br><br>  Em resumo, direi que a tarefa do ECS √© criar uma abordagem orientada a dados para entidades de jogos e uma separa√ß√£o conveniente de dados e l√≥gica.  As entidades s√£o compostas de componentes que cont√™m dados.  E sistemas contendo l√≥gica processam esses componentes. <br><br>  Se voc√™ entrar em detalhes, em vez de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">heran√ßa</a> , a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">composi√ß√£o √©</a> usada no ECS.  Al√©m disso, essa abordagem orientada a dados faz melhor uso do cache, o que significa que ele atinge excelente desempenho. <br><a name="habracut"></a><br><h2>  Exemplos </h2><br>  Antes de nos aprofundarmos no c√≥digo, eu gostaria de mostrar o que vamos criar. <br><br>  A atribui√ß√£o de componentes √© muito simples: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Velocity&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  Como voc√™ pode ver, usaremos o modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRTP</a> . <br><br>  Ent√£o, por raz√µes t√©cnicas, que explicarei mais adiante, precisamos corrigir o n√∫mero de componentes e o n√∫mero de sistemas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ComponentCount = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> SystemCount = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br>  Em seguida, voc√™ pode especificar um sistema que pegue todas as entidades que possuem os dois componentes e atualize suas posi√ß√µes: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysicsSystem</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System&lt;ComponentCount, SystemCount&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PhysicsSystem(EntityManager&lt;ComponentCount, SystemCount&gt;&amp; entityManager) : mEntityManager(entityManager) { setRequirements&lt;Position, Velocity&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); position.x += velocity.x * dt; position.y += velocity.y * dt; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EntityManager&lt;ComponentCount, SystemCount&gt;&amp; mEntityManager; };</code> </pre> <br>  O sistema simplesmente usa o m√©todo <code>setRequirements</code> para <code>setRequirements</code> seus componentes de <code>setRequirements</code> .  Em seguida, no m√©todo de <code>update</code> , ele pode chamar <code>getManagedEntities</code> para percorrer iterativamente todas as entidades que atendem aos requisitos. <br><br>  Por fim, vamos criar um gerenciador de entidades, registrar os componentes, criar um sistema e v√°rias entidades e atualizar suas posi√ß√µes usando o sistema: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> manager = EntityManager&lt;ComponentCount, SystemCount&gt;(); manager.registerComponent&lt;Position&gt;(); manager.registerComponent&lt;Velocity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> system = manager.createSystem&lt;PhysicsSystem&gt;(manager); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = manager.createEntity(); manager.addComponent&lt;Position&gt;(entity); manager.addComponent&lt;Velocity&gt;(entity); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">60.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) system-&gt;update(dt);</code> </pre> <br><h3>  Benchmarks </h3><br>  N√£o pretendo criar a melhor biblioteca ECS.  Eu s√≥ queria escrever isso sozinho.  Al√©m disso, trabalhei nisso por apenas uma semana. <br><br>  No entanto, esse n√£o √© um motivo para criar algo completamente ineficaz.  Ent√£o, vamos instalar os benchmarks: <br><br><ul><li>  O primeiro criar√° entidades; </li><li>  O segundo usar√° o sistema para atravessar iterativamente entidades; </li><li>  Este √∫ltimo criar√° e destruir√° entidades; </li></ul><br>  Os par√¢metros de todos esses benchmarks s√£o o n√∫mero de entidades, o n√∫mero de componentes para cada entidade, o n√∫mero m√°ximo de componentes e o n√∫mero m√°ximo de sistemas.  Dessa maneira, podemos ver qu√£o bem nossa implementa√ß√£o √© escalada.  Em particular, mostrarei os resultados para tr√™s perfis diferentes: <br><br><ul><li>  Perfil A: 32 componentes e 16 sistemas; </li><li>  Perfil AA: 128 componentes e 32 sistemas; </li><li>  Perfil AAA: 512 componentes e 64 sistemas. </li></ul><br>  Apesar de esses benchmarks nos darem uma id√©ia da qualidade da implementa√ß√£o, eles s√£o bastante simples.  Por exemplo, nesses benchmarks, usamos apenas entidades homog√™neas e seus componentes s√£o pequenos. <br><br><h1>  Implementa√ß√£o </h1><br><h2>  Essence </h2><br>  Na minha implementa√ß√£o, uma entidade √© apenas um ID: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Entity = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>;</code> </pre> <br>  Al√©m disso, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entity.h</a> , tamb√©m definiremos um <code>Index</code> alias, que ser√° √∫til mais tarde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> InvalidIndex = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;Index&gt;::max();</code> </pre> <br>  Decidi usar o <code>uint32_t</code> vez do tipo de 64 bits ou <code>std::size_t</code> para economizar espa√ßo e melhorar a otimiza√ß√£o do cache.  N√£o perderemos tanto: √© improv√°vel que algu√©m tenha bilh√µes de entidades. <br><br><h2>  Componente </h2><br>  Agora vamos definir a classe base para os componentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(Type); };</code> </pre> <br>  A classe do modelo √© muito simples, apenas armazena o ID do tipo, que usaremos posteriormente para indexar estruturas de dados pelo tipo de componentes. <br><br>  O primeiro par√¢metro do modelo √© o tipo de componente.  O segundo √© o valor convertido em <code>std::size_t</code> , que servir√° como o ID do tipo de componente. <br><br>  Por exemplo, podemos definir o componente <code>Position</code> seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  No entanto, uma enumera√ß√£o pode ser mais conveniente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentType</span></span></span><span class="hljs-class"> {</span></span> Position }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, ComponentType::Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  No exemplo introdut√≥rio, existe apenas um par√¢metro de modelo: n√£o precisamos especificar o ID do tipo manualmente.  Mais tarde, veremos como melhorar a estrutura e gerar identificadores de tipo automaticamente. <br><br><h2>  EntityContainer </h2><br>  A classe <code>EntityContainer</code> ser√° respons√°vel por gerenciar entidades e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>std::bitset</code></a> para cada uma delas.  Este conjunto de bits indicar√° os componentes que a entidade possui. <br><br>  Como usaremos entidades para indexar cont√™ineres, e em particular <code>std::vector</code> , precisamos que o ID seja o menor poss√≠vel e ocupe menos mem√≥ria.  Portanto, reutilizaremos o ID das entidades destru√≠das.  Para isso, o ID gratuito ser√° armazenado em um cont√™iner chamado <code>mFreeEntities</code> . <br><br>  Aqui est√° a <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt; mEntityToBitset; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mFreeEntities; };</code> </pre> <br>  Vamos ver como os m√©todos s√£o implementados. <br><br>  <code>getEntityToBitset</code> e <code>getBitset</code> s√£o os pequenos getters comuns: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset[entity]; }</code> </pre> <br>  O m√©todo <code>create</code> √© mais interessante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = Entity(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFreeEntities.empty()) { entity = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Entity&gt;(mEntityToBitset.size()); mEntityToBitset.emplace_back(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { entity = mFreeEntities.back(); mFreeEntities.pop_back(); mEntityToBitset[entity].reset(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; }</code> </pre> <br>  Se houver uma entidade livre, ele a reutiliza.  Caso contr√°rio, o m√©todo cria uma nova entidade. <br><br>  O m√©todo <code>remove</code> simplesmente adiciona a entidade a ser removida no <code>mFreeEntities</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.push_back(entity); }</code> </pre> <br>  O √∫ltimo m√©todo √© <code>reserve</code> .  Sua tarefa √© reservar mem√≥ria para v√°rios cont√™ineres.  Como sabemos, alocar mem√≥ria √© uma opera√ß√£o cara, portanto, se conhecermos aproximadamente o n√∫mero de entidades futuras no jogo, a mem√≥ria de reserva acelerar√° o trabalho: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.resize(size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iota(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(mFreeEntities), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mFreeEntities), <span class="hljs-number"><span class="hljs-number">0</span></span>); mEntityToBitset.resize(size); }</code> </pre> <br>  Al√©m de um simples backup de mem√≥ria, ele tamb√©m preenche o <code>mFreeEntities</code> . <br><br><h2>  ComponentContainer </h2><br>  A classe <code>ComponentContainer</code> ser√° respons√°vel por armazenar todos os componentes do tipo especificado. <br><br>  Na minha arquitetura, todos os componentes de um determinado tipo s√£o armazenados juntos.  Ou seja, existe uma matriz grande para cada tipo de componente, chamada <code>mComponents</code> . <br><br>  Al√©m disso, para poder adicionar, receber ou remover um componente de uma entidade em tempo constante, precisamos de uma maneira de passar de uma entidade para um componente e de componente para entidade.  Para fazer isso, precisamos de mais duas estruturas de dados chamadas <code>mComponentToEntity</code> e <code>mEntityToComponent</code> . <br><br>  Aqui est√° a declara√ß√£o <code>ComponentContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentContainer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseComponentContainer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; mComponents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mComponentToEntity; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToComponent; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; mEntityToBitset; };</code> </pre> <br>  Voc√™ pode ver que ele herda do <code>BaseComponentContainer</code> , que √© definido assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseComponentContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~BaseComponentContainer() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  O √∫nico objetivo dessa classe base √© poder armazenar todas as inst√¢ncias do <code>ComponentContainer</code> em um cont√™iner. <br><br>  Vamos agora olhar para a defini√ß√£o de m√©todos. <br><br>  Primeiro, considere o construtor: ele obt√©m uma refer√™ncia a um cont√™iner contendo conjuntos de bits de entidade.  Esta classe a utilizar√° para verificar a presen√ßa de um componente em uma entidade e atualizar o conjunto de bits de uma entidade ao adicionar ou remover um componente: <br><br><pre> <code class="cpp hljs">ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset) : mEntityToBitset(entityToBitset) { }</code> </pre> <br>  O m√©todo <code>get</code> √© simples, basta usar <code>mEntityToComponent</code> para encontrar o √≠ndice de um componente de entidade em <code>mComponents</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponents[mEntityToComponent[entity]]; }</code> </pre> <br>  O m√©todo <code>add</code> usa seus argumentos para inserir um novo componente no final de <code>mComponents</code> e, em seguida, prepara os links para ir de entidade para componente e de componente para entidade.  No final, ele define o bit do conjunto de bits da <code>entity</code> que corresponde ao componente como <code>true</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mComponents.size()); mComponents.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); mComponentToEntity.emplace_back(entity); mEntityToComponent[entity] = index; mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  O m√©todo <code>remove</code> define o componente de bit correspondente como <code>false</code> e, em seguida, move o √∫ltimo componente <code>mComponents</code> no √≠ndice daquele que queremos remover.  Ele atualiza os links para o componente que acabamos de mover e remove um dos componentes que queremos destruir: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToComponent[entity]; <span class="hljs-comment"><span class="hljs-comment">// Update mComponents mComponents[index] = std::move(mComponents.back()); mComponents.pop_back(); // Update mEntityToComponent mEntityToComponent[mComponentToEntity.back()] = index; mEntityToComponent.erase(entity); // Update mComponentToEntity mComponentToEntity[index] = mComponentToEntity.back(); mComponentToEntity.pop_back(); }</span></span></code> </pre> <br>  Podemos realizar movimentos em tempo constante movendo o √∫ltimo componente no √≠ndice que queremos destruir.  De fato, basta remover o √∫ltimo componente, o que pode ser feito em <code>std::vector</code> em tempo constante. <br><br>  O m√©todo <code>tryRemove</code> verifica se uma entidade possui um componente antes de tentar remov√™-lo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToBitset[entity][T::type]) { remove(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  O m√©todo <code>getOwner</code> retorna a entidade que possui o componente, para isso usa aritm√©tica de ponteiro e <code>mComponentToEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> begin = mComponents.data(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(&amp;component - begin); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponentToEntity[index]; }</code> </pre> <br>  O √∫ltimo m√©todo √© <code>reserve</code> , ele tem o mesmo objetivo que o m√©todo semelhante no <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override </span></span>{ mComponents.reserve(size); mComponentToEntity.reserve(size); mEntityToComponent.reserve(size); }</code> </pre> <br><h2>  O sistema </h2><br>  Agora vamos olhar para a classe <code>System</code> . <br><br>  Cada sistema possui um conjunto de bits <code>mRequirements</code> que descreve os componentes necess√°rios.  Al√©m disso, ele armazena um conjunto de entidades <code>mManagedEntities</code> que atendem a esses requisitos.  Repito, para poder implementar todas as opera√ß√µes em tempo constante, precisamos de uma maneira de passar de uma entidade para seu √≠ndice em <code>mManagedEntities</code> .  Para fazer isso, usaremos <code>std::unordered_map</code> chamado <code>mEntityToManagedEntity</code> . <br><br>  Aqui est√° a apar√™ncia da declara√ß√£o do <code>System</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~System() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> EntityManager&lt;ComponentCount, SystemCount&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt; mRequirements; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mType; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mManagedEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToManagedEntity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; };</code> </pre> <br>  <code>setRequirements</code> usa uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">express√£o de convolu√ß√£o</a> para definir os valores de bits: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (mRequirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); }</code> </pre> <br>  <code>getManagedEntities</code> √© um getter que ser√° usado pelas classes geradas para acessar as entidades que est√£o sendo processadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mManagedEntities; }</code> </pre> <br>  Ele retorna uma refer√™ncia constante para que as classes geradas n√£o tentem modificar <code>mManagedEntities</code> . <br><br>  <code>onManagedEntityAdded</code> e <code>onManagedEntityRemoved</code> est√£o vazios.  Eles ser√£o redefinidos mais tarde.  Esses m√©todos ser√£o chamados ao adicionar uma entidade a <code>mManagedEntities</code> ou exclu√≠-la. <br><br>  Os m√©todos a seguir ser√£o particulares e acess√≠veis apenas no <code>EntityManager</code> , declarado como uma classe amig√°vel. <br><br>  <code>setUp</code> ser√° chamado pelo gerente da entidade para atribuir um ID ao sistema.  Em seguida, ele pode ser usado para indexar matrizes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ mType = type; }</code> </pre> <br>  <code>onEntityUpdated</code> √© chamado quando uma entidade muda, ou seja,  ao adicionar ou remover um componente.  O sistema verifica se os requisitos foram atendidos e se a entidade j√° foi processada.  Se ele atender aos requisitos e ainda n√£o tiver sido processado, o sistema o adicionar√°.  No entanto, se a entidade n√£o atender aos requisitos e j√° tiver sido processada, o sistema a excluir√°.  Em todos os outros casos, o sistema n√£o faz nada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> satisfied = (mRequirements &amp; components) == mRequirements; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> managed = mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (satisfied &amp;&amp; !managed) addEntity(entity); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!satisfied &amp;&amp; managed) removeEntity(entity); }</code> </pre> <br>  <code>onEntityRemoved</code> √© chamado pelo gerente da entidade quando uma entidade √© exclu√≠da.  Se a entidade foi processada pelo sistema, ela a exclui: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity)) removeEntity(entity); }</code> </pre> <br>  <code>removeEntity</code> e <code>removeEntity</code> s√£o apenas m√©todos auxiliares. <br><br>  <code>addEntity</code> define o link para ir da entidade adicionada pelo seu √≠ndice em <code>mManagedEntities</code> , adiciona a entidade e chama <code>onManagedEntityAdded</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToManagedEntity[entity] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mManagedEntities.size()); mManagedEntities.emplace_back(entity); onManagedEntityAdded(entity); }</code> </pre> <br>  <code>removeEntity</code> chama primeiro <code>onManagedEntityRemoved</code> .  Em seguida, move a √∫ltima entidade processada no √≠ndice da que est√° sendo exclu√≠da.  Atualiza a refer√™ncia para a entidade movida.  No final, ele exclui a entidade a ser exclu√≠da de <code>mManagedEntities</code> e <code>mEntityToManagedEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ onManagedEntityRemoved(entity); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToManagedEntity[entity]; mEntityToManagedEntity[mManagedEntities.back()] = index; mEntityToManagedEntity.erase(entity); mManagedEntities[index] = mManagedEntities.back(); mManagedEntities.pop_back(); }</code> </pre> <br><h2>  EntityManager </h2><br>  Toda l√≥gica importante est√° em outras classes.  Um gerente de entidade simplesmente une tudo. <br><br>  Vamos dar uma olhada no an√∫ncio dele: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;...&gt; getComponents(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;BaseComponentContainer&gt;, ComponentCount&gt; mComponentContainers; EntityContainer&lt;ComponentCount, SystemCount&gt; mEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;System&lt;ComponentCount, SystemCount&gt;&gt;&gt; mSystems; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  A classe <code>EntityManager</code> possui tr√™s vari√°veis ‚Äã‚Äãde membro: <code>mComponentContainers</code> , que armazena <code>std::unique_ptr</code> para <code>BaseComponentContainer</code> , <code>mEntities</code> , que √© apenas uma inst√¢ncia do <code>EntityContainer</code> e <code>mSystems</code> , que armazena ponteiros <code>unique_ptr</code> no <code>System</code> . <br><br>  Uma classe tem muitos m√©todos, mas na verdade s√£o todos muito simples. <br><br>  Vamos primeiro dar uma olhada no <code>getComponentContainer</code> , que retorna um ponteiro para um cont√™iner de componente que processa componentes do tipo <code>T</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;*&gt;(mComponentContainers[T::type].get()); }</code> </pre> <br>  Outra fun√ß√£o auxiliar √© <code>checkComponentType</code> , que simplesmente verifica se o ID do tipo de componente est√° abaixo do n√∫mero m√°ximo de componentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(T::type &lt; ComponentCount); }</code> </pre> <br>  <code>checkComponentTypes</code> usa uma express√£o de convolu√ß√£o para executar v√°rios tipos de verifica√ß√µes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ (checkComponentType&lt;Ts&gt;(), ...); }</code> </pre> <br>  <code>registerComponent</code> cria um novo cont√™iner de componentes do tipo especificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); mComponentContainers[T::type] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;&gt;( mEntities.getEntityToBitset()); }</code> </pre> <br>  <code>createSystem</code> cria um novo sistema do tipo especificado e define seu tipo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = mSystems.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; system = mSystems.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)); system-&gt;setUp(type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(system.get()); }</code> </pre> <br>  O m√©todo de <code>reserve</code> chama os m√©todos de <code>reserve</code> dos <code>EntityContainer</code> <code>ComponentContainer</code> e <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; ComponentCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mComponentContainers[i]) mComponentContainers[i]-&gt;reserve(size); } mEntities.reserve(size); }</code> </pre> <br>  O m√©todo <code>createEntity</code> retorna o resultado do m√©todo <code>create</code> do gerenciador do <code>EntityManager</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.create(); }</code> </pre> <br>  <code>hasComponent</code> usa um conjunto de bits de entidade para verificar rapidamente se essa entidade possui um componente do tipo especificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.getBitset(entity)[T::type]; }</code> </pre> <br>  <code>hasComponents</code> usa uma express√£o de convolu√ß√£o para criar um conjunto de bits que denota os componentes necess√°rios e, em seguida, usa-o com um conjunto de bits da entidade para verificar se a entidade possui todos os componentes necess√°rios: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirements = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;(); (requirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (requirements &amp; mEntities.getBitset(entity)) == requirements; }</code> </pre> <br>  <code>getComponent</code> redireciona a solicita√ß√£o para o cont√™iner de componente necess√°rio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;get(entity); }</code> </pre> <br>  <code>getComponents</code> retorna uma tupla de links para os componentes solicitados.  Para fazer isso, ele usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>std::tie</code></a> e uma express√£o de convolu√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity) { checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(getComponentContainer&lt;Ts&gt;()-&gt;get(entity)...); }</code> </pre> <br>  <code>addComponent</code> e <code>removeComponent</code> redirecionam a solicita√ß√£o para o cont√™iner de componente necess√°rio e, em seguida, chame o <code>onEntityUpdated</code> sistema <code>onEntityUpdated</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;add(entity, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-comment"><span class="hljs-comment">// Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); } template&lt;typename T&gt; void removeComponent(Entity entity) { checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;remove(entity); // Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); }</span></span></code> </pre> <br>  Por fim, <code>getOwner</code> redireciona a solicita√ß√£o para o componente de cont√™iner necess√°rio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;getOwner(component); }</code> </pre> <br>  Essa foi a minha primeira implementa√ß√£o.  Consiste em apenas 357 linhas de c√≥digo.  Todo o c√≥digo pode ser encontrado neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segmento</a> . <br><br><h1>  Perfil e benchmarks </h1><br><h2>  Benchmarks </h2><br>  Agora √© a hora de comparar minha primeira implementa√ß√£o do ECS! <br><br>  Aqui est√£o os resultados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/323/9a9/bb03239a90cccf5f95ab47ecf94e3a4d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/e54/f0e/679e54f0e32260a9f62621838b51a15e.png"></div><br>  O modelo escala bem o suficiente!  O n√∫mero de processados ‚Äã‚Äãpor segundo √© aproximadamente o mesmo ao aumentar o n√∫mero de entidades e alterar perfis (A, AA e AAA). <br><br>  Al√©m disso, ele se adapta bem a um aumento no n√∫mero de componentes nas entidades.  Quando iteramos atrav√©s de entidades com tr√™s componentes, eles ocorrem tr√™s vezes mais devagar do que atrav√©s de entidades com um componente.  Isso √© esperado porque precisamos obter tr√™s componentes. <br><br><h2>  Falhas no cache </h2><br>  Para verificar o n√∫mero de falhas de cache, executei o exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cachegrind</a> retirado <a href="">daqui</a> . <br><br>  Aqui est√° o resultado para 10.000 entidades: <br><br> <code>==1652== D refs: 277,577,353 (254,775,159 rd + 22,802,194 wr) <br> ==1652== D1 misses: 20,814,368 ( 20,759,914 rd + 54,454 wr) <br> ==1652== LLd misses: 43,483 ( 7,847 rd + 35,636 wr) <br> ==1652== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1652== LLd miss rate: 0.0% ( 0.0% + 0.2% )</code> <br> <br>  Aqui est√° o resultado para 100.000 entidades: <br><br> <code>==1738== D refs: 2,762,879,670 (2,539,368,564 rd + 223,511,106 wr) <br> ==1738== D1 misses: 207,415,181 ( 206,902,072 rd + 513,109 wr) <br> ==1738== LLd misses: 207,274,328 ( 206,789,289 rd + 485,039 wr) <br> ==1738== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1738== LLd miss rate: 7.5% ( 8.1% + 0.2% )</code> <br> <br>  Os resultados s√£o muito bons.  √â um pouco estranho o porqu√™ de tantas falhas de LLd em 100.000 entidades. <br><br><h2>  Cria√ß√£o de perfil </h2><br>  Para entender quais partes da implementa√ß√£o atual demoram mais, criei o perfil do exemplo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gprof</a> . <br><br>  Aqui est√° o resultado: <br><br> <code>Flat profile: <br> <br> Each sample counts as 0.01 seconds. <br> % cumulative self self total <br> time seconds seconds calls ms/call ms/call name <br> 57.45 1.16 1.16 200300000 0.00 0.00 std::__detail::_Map_base&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt;, true&gt;::operator[](unsigned int const&amp;) <br> 19.31 1.55 0.39 main <br> 16.34 1.88 0.33 200500000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_find_before_node(unsigned long, unsigned int const&amp;, unsigned long) const <br> 3.96 1.96 0.08 300000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node&lt;std::pair&lt;unsigned int const, unsigned int&gt;, false&gt;*) <br> 2.48 2.01 0.05 300000 0.00 0.00 unsigned int&amp; std::vector&lt;unsigned int, std::allocator&lt;unsigned int&gt; &gt;::emplace_back&lt;unsigned int&amp;&gt;(unsigned int&amp;) <br> 0.50 2.02 0.01 3 3.33 3.33 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::~_Hashtable() <br> 0.00 2.02 0.00 200000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::find(unsigned int const&amp;)</code> <br> <br>  Os resultados podem estar um pouco distorcidos porque compilei com o sinalizador <code>-O1</code> que o gprof <code>-O1</code> algo significativo.  Parece que quando o n√≠vel de otimiza√ß√£o aumenta, o compilador come√ßa a incorporar tudo agressivamente e o gprof n√£o diz quase nada. <br><br>  De acordo com o gprof, o gargalo √≥bvio nessa implementa√ß√£o √© <code>std::unordered_map</code> .  Se queremos otimiz√°-lo, vale a pena tentar nos livrar deles. <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara√ß√£o com </font></font><code>std::map</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiquei curioso sobre a diferen√ßa de desempenho entre </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, substitu√≠ tudo no c√≥digo </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta implementa√ß√£o est√° dispon√≠vel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui, e</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aqui est√£o os resultados do benchmark:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/50b/3da/61150b3da1ec1cf850a0ed5b761f03a1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/136/3be/951/1363be95163a3dfb2ab968c1591c7c60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/b4b/7f1/d08b4b7f1b5b35531bdc32a614ccbb81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ver que, desta vez, a implementa√ß√£o n√£o √© bem dimensionada com um aumento no n√∫mero de entidades. </font><font style="vertical-align: inherit;">E mesmo com 1000 entidades, √© duas vezes mais lento nas itera√ß√µes que a vers√£o c </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos uma biblioteca simples, mas j√° pr√°tica, do modelo de entidade-componente-sistema. </font><font style="vertical-align: inherit;">No futuro, vamos us√°-lo como base para melhorias e otimiza√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√≥xima parte, mostraremos como aumentar a produtividade substituindo </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al√©m disso, mostraremos como atribuir automaticamente os tipos de identifica√ß√£o aos componentes.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Substituindo std :: unordered_map por std :: vector </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vimos, eles </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eram um gargalo em nossa implementa√ß√£o. </font><font style="vertical-align: inherit;">Portanto, em vez de </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usarmos em </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>ComponentContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e in </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>System</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vetores </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altera√ß√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mudan√ßas ser√£o muito simples, voc√™ pode v√™-las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As √∫nicas mentiras sutileza no fato de que </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ter sido tempo suficiente para indexar qualquer entidade. </font><font style="vertical-align: inherit;">Para fazer isso maneira simples, eu decidi armazenar estes </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em que sabemos que a entidade m√°xima id. </font><font style="vertical-align: inherit;">Depois passo os vetores para os </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cont√™ineres </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">componente por refer√™ncia ou ponteiro no gerenciador de entidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo modificado pode ser encontrado neste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos verificar como esta vers√£o funciona melhor que a anterior: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38a/1df/4bd/38a1df4bd3c8110d3873588854ffc314.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/897/2ae/0f58972ae408b9726899597fbd774be1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22b/3f5/fcd/22b3f5fcd21c8285cc779f46ca3896a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, a cria√ß√£o e exclus√£o de um grande n√∫mero de componentes e sistemas se tornou um pouco </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais lenta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a itera√ß√£o se tornou muito mais r√°pida, quase dez vezes! </font><font style="vertical-align: inherit;">E escala muito bem. </font><font style="vertical-align: inherit;">Essa acelera√ß√£o supera muito a desacelera√ß√£o da cria√ß√£o e exclus√£o. </font><font style="vertical-align: inherit;">E isso √© l√≥gico: as itera√ß√µes da entidade ocorrer√£o muitas vezes, mas s√£o criadas e exclu√≠das apenas uma vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos ver se isso reduziu o n√∫mero de falhas de cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° a sa√≠da do cachegrind com 10.000 entidades: </font><font style="vertical-align: inherit;">E aqui est√° a sa√≠da para 100.000 entidades: </font><font style="vertical-align: inherit;">Vemos que esta vers√£o cria cerca de tr√™s vezes menos links e quatro vezes menos perdas de cache.</font></font><br><br> <code>==1374== D refs: 94,563,949 (72,082,880 rd + 22,481,069 wr) <br> ==1374== D1 misses: 4,813,780 ( 4,417,702 rd + 396,078 wr) <br> ==1374== LLd misses: 378,905 ( 9,626 rd + 369,279 wr) <br> ==1374== D1 miss rate: 5.1% ( 6.1% + 1.8% ) <br> ==1374== LLd miss rate: 0.4% ( 0.0% + 1.6% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>==1307== D refs: 938,405,796 (715,424,940 rd + 222,980,856 wr) <br> ==1307== D1 misses: 51,034,738 ( 44,045,090 rd + 6,989,648 wr) <br> ==1307== LLd misses: 5,866,508 ( 1,997,948 rd + 3,868,560 wr) <br> ==1307== D1 miss rate: 5.4% ( 6.2% + 3.1% ) <br> ==1307== LLd miss rate: 0.6% ( 0.3% + 1.7% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipos autom√°ticos </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A √∫ltima melhoria de que falarei √© a gera√ß√£o autom√°tica de identificadores de tipo de componente. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altera√ß√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as altera√ß√µes para implementar a gera√ß√£o autom√°tica de tipos de ID podem ser encontradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pois, para poder atribuir um ID exclusivo a cada tipo de componente, voc√™ precisa usar o CRTP e uma fun√ß√£o com um contador est√°tico:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> generateComponentType() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Component&lt;T&gt;::type = generateComponentType();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode perceber que o ID do tipo agora √© gerado em tempo de execu√ß√£o e era conhecido anteriormente em tempo de compila√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo ap√≥s as altera√ß√µes pode ser encontrado neste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para testar o desempenho desta vers√£o, realizei benchmarks: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bd/112/0da/7bd1120da37daac5e3ef48446776b6e7.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/f2f/937/234f2f9377a0f3ad8ea231f91e335ddf.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/101/4f2/ade/1014f2adebd6156bc48c9b6fe5670b43.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cria√ß√£o e exclus√£o, os resultados permaneceram aproximadamente os mesmos. </font><font style="vertical-align: inherit;">No entanto, voc√™ pode ver que a itera√ß√£o se tornou um pouco mais lenta, cerca de 10%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa desacelera√ß√£o pode ser explicada pelo fato de o compilador conhecer os identificadores de tipo no momento da compila√ß√£o, o que significa que ele poderia otimizar melhor o c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A atribui√ß√£o manual de tipos de identifica√ß√£o √© um pouco inconveniente e pode levar a erros. </font><font style="vertical-align: inherit;">Portanto, mesmo que reduzamos um pouco o desempenho, ainda √© uma melhoria na usabilidade da nossa biblioteca ECS.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ideias para melhorias adicionais </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de concluir este artigo, gostaria de compartilhar com voc√™ id√©ias para outras melhorias. </font><font style="vertical-align: inherit;">At√© agora, eu n√£o os implementei, mas talvez eu o fa√ßa no futuro.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√∫mero din√¢mico de componentes e sistemas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â inconveniente indicar antecipadamente o n√∫mero m√°ximo de componentes e sistemas na forma de par√¢metros do modelo. </font><font style="vertical-align: inherit;">Eu acho que vai ser poss√≠vel substituir </font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem uma degrada√ß√£o do desempenho forte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, √© </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necess√°rio conhecer o n√∫mero de bits em tempo de compila√ß√£o. </font><font style="vertical-align: inherit;">Embora eu ache que corrigir este problema, substituindo </font></font><code>std::vector&lt;bitset&lt;ComponentCount&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>std::vector&lt;char&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e liberar um n√∫mero suficiente de bytes para representar os conjuntos de bits de todas as entidades. </font><font style="vertical-align: inherit;">Em seguida, implementamos uma classe leve </font></font><code>BitsetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que recebe na entrada um par de ponteiros para o in√≠cio e o final do conjunto de bits e, em seguida, executamos todas as opera√ß√µes necess√°rias com </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esse intervalo de mem√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra id√©ia: n√£o use mais conjuntos de bits e verifique apenas </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se a entidade possui componentes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itera√ß√£o de componente simplificada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No momento, se o sistema quiser percorrer iterativamente os componentes das entidades que processa, precisamos fazer o seguinte: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seria mais bonito e mais simples se pud√©ssemos fazer algo assim: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [position, velocity] : mEntityManager.getComponents&lt;Position, Velocity&gt;(mManagedEntities)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° mais f√°cil implement√°-lo com a ajuda </font><font style="vertical-align: inherit;">da </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">biblioteca de intervalos</font></a></font><code>std::view::transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no C ++ 20 </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infelizmente, ainda n√£o est√° l√°. </font><font style="vertical-align: inherit;">Eu poderia usar </font><font style="vertical-align: inherit;">a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">biblioteca de intervalos de</font></a><font style="vertical-align: inherit;"> Eric Nibler, mas n√£o quero adicionar depend√™ncias. </font><font style="vertical-align: inherit;">A solu√ß√£o poderia ser implementar uma classe </font><font style="vertical-align: inherit;">que recebesse os tipos de componentes que precisam ser recebidos como par√¢metros de modelo e uma refer√™ncia de </font><font style="vertical-align: inherit;">entidade </font><font style="vertical-align: inherit;">como par√¢metro de construtor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ent√£o ter√≠amos apenas para perceber </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">e o tipo de iterador para obter o comportamento desejado. </font><font style="vertical-align: inherit;">N√£o √© muito dif√≠cil, mas consome um pouco de tempo para escrever.</font></font><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>EntityRangeView</code><font style="vertical-align: inherit;"></font><code>std::vector</code><font style="vertical-align: inherit;"></font><code>begin</code><font style="vertical-align: inherit;"></font><code>end</code><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otimiza√ß√£o de gerenciamento de eventos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na implementa√ß√£o atual, ao adicionar ou remover um componente de uma entidade, chamamos </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos os sistemas. </font><font style="vertical-align: inherit;">Isso √© um pouco ineficiente porque muitos sistemas n√£o est√£o interessados ‚Äã‚Äãno tipo de componente que acabou de ser alterado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para minimizar danos, podemos armazenar ponteiros para sistemas interessados ‚Äã‚Äãno tipo especificado de componentes na estrutura de dados, por exemplo </font></font><code>std::array&lt;std::vector&lt;System&lt;ComponentCount, SystemCount&gt;&gt;, ComponentCount&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ent√£o, ao adicionar ou remover um componente, chamar√≠amos simplesmente o m√©todo de </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistemas interessados ‚Äã‚Äãnesse componente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subconjuntos de entidades gerenciadas pelo gerente da entidade em vez de sistemas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minha √∫ltima id√©ia levaria a mudan√ßas mais extensas na estrutura da biblioteca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de sistemas que gerenciam seus conjuntos de entidades, um gerente de entidade faria isso. A vantagem desse esquema √© que, se dois sistemas estiverem interessados ‚Äã‚Äãem um conjunto de componentes, n√£o duplicamos um subconjunto de entidades que atendem a esses requisitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os sistemas poderiam simplesmente declarar seus requisitos a um gerente de entidade. Em seguida, o gerente da entidade armazenaria todos os diferentes subconjuntos de entidades. Por fim, os sistemas consultariam entidades usando uma sintaxe semelhante:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : mEntityManager.getEntitiesWith&lt;Position, Velocity&gt;()) { ... }</code> </pre> <br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, este √© o fim de um artigo sobre minha implementa√ß√£o do sistema de componentes de entidade. </font><font style="vertical-align: inherit;">Se eu fizer outras melhorias, talvez eu esteja escrevendo novos artigos no futuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A implementa√ß√£o descrita no artigo √© bastante simples: consiste em menos de 500 linhas de c√≥digo e tamb√©m possui bom desempenho. </font><font style="vertical-align: inherit;">Todas as transa√ß√µes s√£o realizadas por tempo constante (amortizado). </font><font style="vertical-align: inherit;">Al√©m disso, na pr√°tica, ele otimiza o uso do cache e recebe e repete muito rapidamente as entidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este artigo seja interessante ou at√© √∫til para voc√™.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leitura adicional </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui est√£o alguns recursos √∫teis para um estudo mais aprofundado do padr√£o de entidade-componente-sistema: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michelle Kayney, autora de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , escreve uma s√©rie muito interessante de artigos sobre o sistema de entidade-componente chamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Wiki do Entity Systems</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cont√©m informa√ß√µes e links muito √∫teis.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459288/">https://habr.com/ru/post/pt459288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459274/index.html">Vulnerabilidade de bloqueio de tela no Astra Linux Special Edition (Smolensk)</a></li>
<li><a href="../pt459276/index.html">Resist√™ncia √©pica a falhas 2 ou por que voc√™ n√£o deve se envolver em privacidade com os plug-ins do FireFox</a></li>
<li><a href="../pt459280/index.html">Por que os desenvolvedores adoram criar aplicativos nativos?</a></li>
<li><a href="../pt459284/index.html">Breve introdu√ß√£o √† estrat√©gia de produtos e prioriza√ß√£o de recursos</a></li>
<li><a href="../pt459286/index.html">Telureto de tungst√™nio semi-met√°lico - a faca su√≠√ßa do dia da nanotecnologia</a></li>
<li><a href="../pt459292/index.html">Automa√ß√£o de teste de aplicativos m√≥veis: compara√ß√£o de ferramentas</a></li>
<li><a href="../pt459294/index.html">O que √© mais importante: conhecer uma linguagem de programa√ß√£o ou ser capaz de resolver um problema de neg√≥cios?</a></li>
<li><a href="../pt459296/index.html">JavaScript Pre√ßo 2019</a></li>
<li><a href="../pt459298/index.html">Angular: status em 2019</a></li>
<li><a href="../pt459300/index.html">Quasar 1.0: uma nova ferramenta √∫til para desenvolvedores do Vue e n√£o apenas para eles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>