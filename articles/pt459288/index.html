<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔱 👩🏻‍💼 👼🏿 Implementação nativa da biblioteca ECS 😁 ✊🏽 🧗🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta semana, comecei a trabalhar no meu mecanismo do Vagabond e comecei a implementar o modelo de entidade-componente-sistema . 

 Neste artigo, quer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementação nativa da biblioteca ECS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459288/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png" alt="imagem"></div><br>  Nesta semana, comecei a trabalhar no meu mecanismo do Vagabond e comecei a implementar o modelo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entidade-componente-sistema</a> . <br><br>  Neste artigo, quero falar sobre minha implementação, disponível gratuitamente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Mas, em vez de simplesmente comentar o código, quero explicar como sua estrutura foi projetada.  Portanto, começarei com a primeira implementação que escrevi, analisarei seus pontos fortes e fracos e mostrarei como a aprimorei.  No final, listarei uma lista de aspectos que também podem ser aprimorados. <br><br><h1>  1. Introdução </h1><br><h2>  Motivação </h2><br>  Não falarei sobre os benefícios do ECS sobre a abordagem orientada a objetos, porque muitas pessoas antes de mim fizeram isso bem.  Scott Bilas foi um dos primeiros a falar sobre ECS no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20101011021902/">GDC 2002</a> .  Outras introduções notáveis ​​ao tópico incluem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evolve Your Hierarchy, de</a> Mike West, e o capítulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Components,</a> do impressionante livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Game Programming Patterns</a> de Robert Nistrom. <br><br>  Em resumo, direi que a tarefa do ECS é criar uma abordagem orientada a dados para entidades de jogos e uma separação conveniente de dados e lógica.  As entidades são compostas de componentes que contêm dados.  E sistemas contendo lógica processam esses componentes. <br><br>  Se você entrar em detalhes, em vez de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">herança</a> , a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">composição é</a> usada no ECS.  Além disso, essa abordagem orientada a dados faz melhor uso do cache, o que significa que ele atinge excelente desempenho. <br><a name="habracut"></a><br><h2>  Exemplos </h2><br>  Antes de nos aprofundarmos no código, eu gostaria de mostrar o que vamos criar. <br><br>  A atribuição de componentes é muito simples: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Velocity&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  Como você pode ver, usaremos o modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRTP</a> . <br><br>  Então, por razões técnicas, que explicarei mais adiante, precisamos corrigir o número de componentes e o número de sistemas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ComponentCount = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> SystemCount = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br>  Em seguida, você pode especificar um sistema que pegue todas as entidades que possuem os dois componentes e atualize suas posições: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysicsSystem</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System&lt;ComponentCount, SystemCount&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PhysicsSystem(EntityManager&lt;ComponentCount, SystemCount&gt;&amp; entityManager) : mEntityManager(entityManager) { setRequirements&lt;Position, Velocity&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); position.x += velocity.x * dt; position.y += velocity.y * dt; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EntityManager&lt;ComponentCount, SystemCount&gt;&amp; mEntityManager; };</code> </pre> <br>  O sistema simplesmente usa o método <code>setRequirements</code> para <code>setRequirements</code> seus componentes de <code>setRequirements</code> .  Em seguida, no método de <code>update</code> , ele pode chamar <code>getManagedEntities</code> para percorrer iterativamente todas as entidades que atendem aos requisitos. <br><br>  Por fim, vamos criar um gerenciador de entidades, registrar os componentes, criar um sistema e várias entidades e atualizar suas posições usando o sistema: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> manager = EntityManager&lt;ComponentCount, SystemCount&gt;(); manager.registerComponent&lt;Position&gt;(); manager.registerComponent&lt;Velocity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> system = manager.createSystem&lt;PhysicsSystem&gt;(manager); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = manager.createEntity(); manager.addComponent&lt;Position&gt;(entity); manager.addComponent&lt;Velocity&gt;(entity); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">60.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) system-&gt;update(dt);</code> </pre> <br><h3>  Benchmarks </h3><br>  Não pretendo criar a melhor biblioteca ECS.  Eu só queria escrever isso sozinho.  Além disso, trabalhei nisso por apenas uma semana. <br><br>  No entanto, esse não é um motivo para criar algo completamente ineficaz.  Então, vamos instalar os benchmarks: <br><br><ul><li>  O primeiro criará entidades; </li><li>  O segundo usará o sistema para atravessar iterativamente entidades; </li><li>  Este último criará e destruirá entidades; </li></ul><br>  Os parâmetros de todos esses benchmarks são o número de entidades, o número de componentes para cada entidade, o número máximo de componentes e o número máximo de sistemas.  Dessa maneira, podemos ver quão bem nossa implementação é escalada.  Em particular, mostrarei os resultados para três perfis diferentes: <br><br><ul><li>  Perfil A: 32 componentes e 16 sistemas; </li><li>  Perfil AA: 128 componentes e 32 sistemas; </li><li>  Perfil AAA: 512 componentes e 64 sistemas. </li></ul><br>  Apesar de esses benchmarks nos darem uma idéia da qualidade da implementação, eles são bastante simples.  Por exemplo, nesses benchmarks, usamos apenas entidades homogêneas e seus componentes são pequenos. <br><br><h1>  Implementação </h1><br><h2>  Essence </h2><br>  Na minha implementação, uma entidade é apenas um ID: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Entity = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>;</code> </pre> <br>  Além disso, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entity.h</a> , também definiremos um <code>Index</code> alias, que será útil mais tarde: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> InvalidIndex = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;Index&gt;::max();</code> </pre> <br>  Decidi usar o <code>uint32_t</code> vez do tipo de 64 bits ou <code>std::size_t</code> para economizar espaço e melhorar a otimização do cache.  Não perderemos tanto: é improvável que alguém tenha bilhões de entidades. <br><br><h2>  Componente </h2><br>  Agora vamos definir a classe base para os componentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(Type); };</code> </pre> <br>  A classe do modelo é muito simples, apenas armazena o ID do tipo, que usaremos posteriormente para indexar estruturas de dados pelo tipo de componentes. <br><br>  O primeiro parâmetro do modelo é o tipo de componente.  O segundo é o valor convertido em <code>std::size_t</code> , que servirá como o ID do tipo de componente. <br><br>  Por exemplo, podemos definir o componente <code>Position</code> seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  No entanto, uma enumeração pode ser mais conveniente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentType</span></span></span><span class="hljs-class"> {</span></span> Position }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, ComponentType::Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  No exemplo introdutório, existe apenas um parâmetro de modelo: não precisamos especificar o ID do tipo manualmente.  Mais tarde, veremos como melhorar a estrutura e gerar identificadores de tipo automaticamente. <br><br><h2>  EntityContainer </h2><br>  A classe <code>EntityContainer</code> será responsável por gerenciar entidades e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>std::bitset</code></a> para cada uma delas.  Este conjunto de bits indicará os componentes que a entidade possui. <br><br>  Como usaremos entidades para indexar contêineres, e em particular <code>std::vector</code> , precisamos que o ID seja o menor possível e ocupe menos memória.  Portanto, reutilizaremos o ID das entidades destruídas.  Para isso, o ID gratuito será armazenado em um contêiner chamado <code>mFreeEntities</code> . <br><br>  Aqui está a <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt; mEntityToBitset; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mFreeEntities; };</code> </pre> <br>  Vamos ver como os métodos são implementados. <br><br>  <code>getEntityToBitset</code> e <code>getBitset</code> são os pequenos getters comuns: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset[entity]; }</code> </pre> <br>  O método <code>create</code> é mais interessante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = Entity(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFreeEntities.empty()) { entity = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Entity&gt;(mEntityToBitset.size()); mEntityToBitset.emplace_back(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { entity = mFreeEntities.back(); mFreeEntities.pop_back(); mEntityToBitset[entity].reset(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; }</code> </pre> <br>  Se houver uma entidade livre, ele a reutiliza.  Caso contrário, o método cria uma nova entidade. <br><br>  O método <code>remove</code> simplesmente adiciona a entidade a ser removida no <code>mFreeEntities</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.push_back(entity); }</code> </pre> <br>  O último método é <code>reserve</code> .  Sua tarefa é reservar memória para vários contêineres.  Como sabemos, alocar memória é uma operação cara, portanto, se conhecermos aproximadamente o número de entidades futuras no jogo, a memória de reserva acelerará o trabalho: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.resize(size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iota(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(mFreeEntities), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mFreeEntities), <span class="hljs-number"><span class="hljs-number">0</span></span>); mEntityToBitset.resize(size); }</code> </pre> <br>  Além de um simples backup de memória, ele também preenche o <code>mFreeEntities</code> . <br><br><h2>  ComponentContainer </h2><br>  A classe <code>ComponentContainer</code> será responsável por armazenar todos os componentes do tipo especificado. <br><br>  Na minha arquitetura, todos os componentes de um determinado tipo são armazenados juntos.  Ou seja, existe uma matriz grande para cada tipo de componente, chamada <code>mComponents</code> . <br><br>  Além disso, para poder adicionar, receber ou remover um componente de uma entidade em tempo constante, precisamos de uma maneira de passar de uma entidade para um componente e de componente para entidade.  Para fazer isso, precisamos de mais duas estruturas de dados chamadas <code>mComponentToEntity</code> e <code>mEntityToComponent</code> . <br><br>  Aqui está a declaração <code>ComponentContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentContainer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseComponentContainer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; mComponents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mComponentToEntity; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToComponent; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; mEntityToBitset; };</code> </pre> <br>  Você pode ver que ele herda do <code>BaseComponentContainer</code> , que é definido assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseComponentContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~BaseComponentContainer() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  O único objetivo dessa classe base é poder armazenar todas as instâncias do <code>ComponentContainer</code> em um contêiner. <br><br>  Vamos agora olhar para a definição de métodos. <br><br>  Primeiro, considere o construtor: ele obtém uma referência a um contêiner contendo conjuntos de bits de entidade.  Esta classe a utilizará para verificar a presença de um componente em uma entidade e atualizar o conjunto de bits de uma entidade ao adicionar ou remover um componente: <br><br><pre> <code class="cpp hljs">ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset) : mEntityToBitset(entityToBitset) { }</code> </pre> <br>  O método <code>get</code> é simples, basta usar <code>mEntityToComponent</code> para encontrar o índice de um componente de entidade em <code>mComponents</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponents[mEntityToComponent[entity]]; }</code> </pre> <br>  O método <code>add</code> usa seus argumentos para inserir um novo componente no final de <code>mComponents</code> e, em seguida, prepara os links para ir de entidade para componente e de componente para entidade.  No final, ele define o bit do conjunto de bits da <code>entity</code> que corresponde ao componente como <code>true</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mComponents.size()); mComponents.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); mComponentToEntity.emplace_back(entity); mEntityToComponent[entity] = index; mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  O método <code>remove</code> define o componente de bit correspondente como <code>false</code> e, em seguida, move o último componente <code>mComponents</code> no índice daquele que queremos remover.  Ele atualiza os links para o componente que acabamos de mover e remove um dos componentes que queremos destruir: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToComponent[entity]; <span class="hljs-comment"><span class="hljs-comment">// Update mComponents mComponents[index] = std::move(mComponents.back()); mComponents.pop_back(); // Update mEntityToComponent mEntityToComponent[mComponentToEntity.back()] = index; mEntityToComponent.erase(entity); // Update mComponentToEntity mComponentToEntity[index] = mComponentToEntity.back(); mComponentToEntity.pop_back(); }</span></span></code> </pre> <br>  Podemos realizar movimentos em tempo constante movendo o último componente no índice que queremos destruir.  De fato, basta remover o último componente, o que pode ser feito em <code>std::vector</code> em tempo constante. <br><br>  O método <code>tryRemove</code> verifica se uma entidade possui um componente antes de tentar removê-lo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToBitset[entity][T::type]) { remove(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  O método <code>getOwner</code> retorna a entidade que possui o componente, para isso usa aritmética de ponteiro e <code>mComponentToEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> begin = mComponents.data(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(&amp;component - begin); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponentToEntity[index]; }</code> </pre> <br>  O último método é <code>reserve</code> , ele tem o mesmo objetivo que o método semelhante no <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override </span></span>{ mComponents.reserve(size); mComponentToEntity.reserve(size); mEntityToComponent.reserve(size); }</code> </pre> <br><h2>  O sistema </h2><br>  Agora vamos olhar para a classe <code>System</code> . <br><br>  Cada sistema possui um conjunto de bits <code>mRequirements</code> que descreve os componentes necessários.  Além disso, ele armazena um conjunto de entidades <code>mManagedEntities</code> que atendem a esses requisitos.  Repito, para poder implementar todas as operações em tempo constante, precisamos de uma maneira de passar de uma entidade para seu índice em <code>mManagedEntities</code> .  Para fazer isso, usaremos <code>std::unordered_map</code> chamado <code>mEntityToManagedEntity</code> . <br><br>  Aqui está a aparência da declaração do <code>System</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~System() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> EntityManager&lt;ComponentCount, SystemCount&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt; mRequirements; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mType; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mManagedEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToManagedEntity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; };</code> </pre> <br>  <code>setRequirements</code> usa uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">expressão de convolução</a> para definir os valores de bits: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (mRequirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); }</code> </pre> <br>  <code>getManagedEntities</code> é um getter que será usado pelas classes geradas para acessar as entidades que estão sendo processadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mManagedEntities; }</code> </pre> <br>  Ele retorna uma referência constante para que as classes geradas não tentem modificar <code>mManagedEntities</code> . <br><br>  <code>onManagedEntityAdded</code> e <code>onManagedEntityRemoved</code> estão vazios.  Eles serão redefinidos mais tarde.  Esses métodos serão chamados ao adicionar uma entidade a <code>mManagedEntities</code> ou excluí-la. <br><br>  Os métodos a seguir serão particulares e acessíveis apenas no <code>EntityManager</code> , declarado como uma classe amigável. <br><br>  <code>setUp</code> será chamado pelo gerente da entidade para atribuir um ID ao sistema.  Em seguida, ele pode ser usado para indexar matrizes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ mType = type; }</code> </pre> <br>  <code>onEntityUpdated</code> é chamado quando uma entidade muda, ou seja,  ao adicionar ou remover um componente.  O sistema verifica se os requisitos foram atendidos e se a entidade já foi processada.  Se ele atender aos requisitos e ainda não tiver sido processado, o sistema o adicionará.  No entanto, se a entidade não atender aos requisitos e já tiver sido processada, o sistema a excluirá.  Em todos os outros casos, o sistema não faz nada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> satisfied = (mRequirements &amp; components) == mRequirements; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> managed = mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (satisfied &amp;&amp; !managed) addEntity(entity); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!satisfied &amp;&amp; managed) removeEntity(entity); }</code> </pre> <br>  <code>onEntityRemoved</code> é chamado pelo gerente da entidade quando uma entidade é excluída.  Se a entidade foi processada pelo sistema, ela a exclui: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity)) removeEntity(entity); }</code> </pre> <br>  <code>removeEntity</code> e <code>removeEntity</code> são apenas métodos auxiliares. <br><br>  <code>addEntity</code> define o link para ir da entidade adicionada pelo seu índice em <code>mManagedEntities</code> , adiciona a entidade e chama <code>onManagedEntityAdded</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToManagedEntity[entity] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mManagedEntities.size()); mManagedEntities.emplace_back(entity); onManagedEntityAdded(entity); }</code> </pre> <br>  <code>removeEntity</code> chama primeiro <code>onManagedEntityRemoved</code> .  Em seguida, move a última entidade processada no índice da que está sendo excluída.  Atualiza a referência para a entidade movida.  No final, ele exclui a entidade a ser excluída de <code>mManagedEntities</code> e <code>mEntityToManagedEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ onManagedEntityRemoved(entity); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToManagedEntity[entity]; mEntityToManagedEntity[mManagedEntities.back()] = index; mEntityToManagedEntity.erase(entity); mManagedEntities[index] = mManagedEntities.back(); mManagedEntities.pop_back(); }</code> </pre> <br><h2>  EntityManager </h2><br>  Toda lógica importante está em outras classes.  Um gerente de entidade simplesmente une tudo. <br><br>  Vamos dar uma olhada no anúncio dele: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;...&gt; getComponents(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;BaseComponentContainer&gt;, ComponentCount&gt; mComponentContainers; EntityContainer&lt;ComponentCount, SystemCount&gt; mEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;System&lt;ComponentCount, SystemCount&gt;&gt;&gt; mSystems; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  A classe <code>EntityManager</code> possui três variáveis ​​de membro: <code>mComponentContainers</code> , que armazena <code>std::unique_ptr</code> para <code>BaseComponentContainer</code> , <code>mEntities</code> , que é apenas uma instância do <code>EntityContainer</code> e <code>mSystems</code> , que armazena ponteiros <code>unique_ptr</code> no <code>System</code> . <br><br>  Uma classe tem muitos métodos, mas na verdade são todos muito simples. <br><br>  Vamos primeiro dar uma olhada no <code>getComponentContainer</code> , que retorna um ponteiro para um contêiner de componente que processa componentes do tipo <code>T</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;*&gt;(mComponentContainers[T::type].get()); }</code> </pre> <br>  Outra função auxiliar é <code>checkComponentType</code> , que simplesmente verifica se o ID do tipo de componente está abaixo do número máximo de componentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(T::type &lt; ComponentCount); }</code> </pre> <br>  <code>checkComponentTypes</code> usa uma expressão de convolução para executar vários tipos de verificações: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ (checkComponentType&lt;Ts&gt;(), ...); }</code> </pre> <br>  <code>registerComponent</code> cria um novo contêiner de componentes do tipo especificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); mComponentContainers[T::type] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;&gt;( mEntities.getEntityToBitset()); }</code> </pre> <br>  <code>createSystem</code> cria um novo sistema do tipo especificado e define seu tipo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = mSystems.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; system = mSystems.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)); system-&gt;setUp(type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(system.get()); }</code> </pre> <br>  O método de <code>reserve</code> chama os métodos de <code>reserve</code> dos <code>EntityContainer</code> <code>ComponentContainer</code> e <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; ComponentCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mComponentContainers[i]) mComponentContainers[i]-&gt;reserve(size); } mEntities.reserve(size); }</code> </pre> <br>  O método <code>createEntity</code> retorna o resultado do método <code>create</code> do gerenciador do <code>EntityManager</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.create(); }</code> </pre> <br>  <code>hasComponent</code> usa um conjunto de bits de entidade para verificar rapidamente se essa entidade possui um componente do tipo especificado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.getBitset(entity)[T::type]; }</code> </pre> <br>  <code>hasComponents</code> usa uma expressão de convolução para criar um conjunto de bits que denota os componentes necessários e, em seguida, usa-o com um conjunto de bits da entidade para verificar se a entidade possui todos os componentes necessários: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirements = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;(); (requirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (requirements &amp; mEntities.getBitset(entity)) == requirements; }</code> </pre> <br>  <code>getComponent</code> redireciona a solicitação para o contêiner de componente necessário: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;get(entity); }</code> </pre> <br>  <code>getComponents</code> retorna uma tupla de links para os componentes solicitados.  Para fazer isso, ele usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>std::tie</code></a> e uma expressão de convolução: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity) { checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(getComponentContainer&lt;Ts&gt;()-&gt;get(entity)...); }</code> </pre> <br>  <code>addComponent</code> e <code>removeComponent</code> redirecionam a solicitação para o contêiner de componente necessário e, em seguida, chame o <code>onEntityUpdated</code> sistema <code>onEntityUpdated</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;add(entity, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-comment"><span class="hljs-comment">// Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); } template&lt;typename T&gt; void removeComponent(Entity entity) { checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;remove(entity); // Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); }</span></span></code> </pre> <br>  Por fim, <code>getOwner</code> redireciona a solicitação para o componente de contêiner necessário: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;getOwner(component); }</code> </pre> <br>  Essa foi a minha primeira implementação.  Consiste em apenas 357 linhas de código.  Todo o código pode ser encontrado neste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segmento</a> . <br><br><h1>  Perfil e benchmarks </h1><br><h2>  Benchmarks </h2><br>  Agora é a hora de comparar minha primeira implementação do ECS! <br><br>  Aqui estão os resultados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/323/9a9/bb03239a90cccf5f95ab47ecf94e3a4d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/e54/f0e/679e54f0e32260a9f62621838b51a15e.png"></div><br>  O modelo escala bem o suficiente!  O número de processados ​​por segundo é aproximadamente o mesmo ao aumentar o número de entidades e alterar perfis (A, AA e AAA). <br><br>  Além disso, ele se adapta bem a um aumento no número de componentes nas entidades.  Quando iteramos através de entidades com três componentes, eles ocorrem três vezes mais devagar do que através de entidades com um componente.  Isso é esperado porque precisamos obter três componentes. <br><br><h2>  Falhas no cache </h2><br>  Para verificar o número de falhas de cache, executei o exemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cachegrind</a> retirado <a href="">daqui</a> . <br><br>  Aqui está o resultado para 10.000 entidades: <br><br> <code>==1652== D refs: 277,577,353 (254,775,159 rd + 22,802,194 wr) <br> ==1652== D1 misses: 20,814,368 ( 20,759,914 rd + 54,454 wr) <br> ==1652== LLd misses: 43,483 ( 7,847 rd + 35,636 wr) <br> ==1652== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1652== LLd miss rate: 0.0% ( 0.0% + 0.2% )</code> <br> <br>  Aqui está o resultado para 100.000 entidades: <br><br> <code>==1738== D refs: 2,762,879,670 (2,539,368,564 rd + 223,511,106 wr) <br> ==1738== D1 misses: 207,415,181 ( 206,902,072 rd + 513,109 wr) <br> ==1738== LLd misses: 207,274,328 ( 206,789,289 rd + 485,039 wr) <br> ==1738== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1738== LLd miss rate: 7.5% ( 8.1% + 0.2% )</code> <br> <br>  Os resultados são muito bons.  É um pouco estranho o porquê de tantas falhas de LLd em 100.000 entidades. <br><br><h2>  Criação de perfil </h2><br>  Para entender quais partes da implementação atual demoram mais, criei o perfil do exemplo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gprof</a> . <br><br>  Aqui está o resultado: <br><br> <code>Flat profile: <br> <br> Each sample counts as 0.01 seconds. <br> % cumulative self self total <br> time seconds seconds calls ms/call ms/call name <br> 57.45 1.16 1.16 200300000 0.00 0.00 std::__detail::_Map_base&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt;, true&gt;::operator[](unsigned int const&amp;) <br> 19.31 1.55 0.39 main <br> 16.34 1.88 0.33 200500000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_find_before_node(unsigned long, unsigned int const&amp;, unsigned long) const <br> 3.96 1.96 0.08 300000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node&lt;std::pair&lt;unsigned int const, unsigned int&gt;, false&gt;*) <br> 2.48 2.01 0.05 300000 0.00 0.00 unsigned int&amp; std::vector&lt;unsigned int, std::allocator&lt;unsigned int&gt; &gt;::emplace_back&lt;unsigned int&amp;&gt;(unsigned int&amp;) <br> 0.50 2.02 0.01 3 3.33 3.33 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::~_Hashtable() <br> 0.00 2.02 0.00 200000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::find(unsigned int const&amp;)</code> <br> <br>  Os resultados podem estar um pouco distorcidos porque compilei com o sinalizador <code>-O1</code> que o gprof <code>-O1</code> algo significativo.  Parece que quando o nível de otimização aumenta, o compilador começa a incorporar tudo agressivamente e o gprof não diz quase nada. <br><br>  De acordo com o gprof, o gargalo óbvio nessa implementação é <code>std::unordered_map</code> .  Se queremos otimizá-lo, vale a pena tentar nos livrar deles. <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparação com </font></font><code>std::map</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiquei curioso sobre a diferença de desempenho entre </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, substituí tudo no código </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta implementação está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui, e</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aqui estão os resultados do benchmark:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/50b/3da/61150b3da1ec1cf850a0ed5b761f03a1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/136/3be/951/1363be95163a3dfb2ab968c1591c7c60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/b4b/7f1/d08b4b7f1b5b35531bdc32a614ccbb81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ver que, desta vez, a implementação não é bem dimensionada com um aumento no número de entidades. </font><font style="vertical-align: inherit;">E mesmo com 1000 entidades, é duas vezes mais lento nas iterações que a versão c </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h1>  Conclusão </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criamos uma biblioteca simples, mas já prática, do modelo de entidade-componente-sistema. </font><font style="vertical-align: inherit;">No futuro, vamos usá-lo como base para melhorias e otimizações. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na próxima parte, mostraremos como aumentar a produtividade substituindo </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Além disso, mostraremos como atribuir automaticamente os tipos de identificação aos componentes.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Substituindo std :: unordered_map por std :: vector </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vimos, eles </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eram um gargalo em nossa implementação. </font><font style="vertical-align: inherit;">Portanto, em vez de </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usarmos em </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>ComponentContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e in </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>System</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vetores </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterações </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mudanças serão muito simples, você pode vê-las </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As únicas mentiras sutileza no fato de que </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ter sido tempo suficiente para indexar qualquer entidade. </font><font style="vertical-align: inherit;">Para fazer isso maneira simples, eu decidi armazenar estes </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em que sabemos que a entidade máxima id. </font><font style="vertical-align: inherit;">Depois passo os vetores para os </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contêineres </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">componente por referência ou ponteiro no gerenciador de entidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código modificado pode ser encontrado neste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos verificar como esta versão funciona melhor que a anterior: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38a/1df/4bd/38a1df4bd3c8110d3873588854ffc314.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/897/2ae/0f58972ae408b9726899597fbd774be1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22b/3f5/fcd/22b3f5fcd21c8285cc779f46ca3896a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, a criação e exclusão de um grande número de componentes e sistemas se tornou um pouco </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais lenta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a iteração se tornou muito mais rápida, quase dez vezes! </font><font style="vertical-align: inherit;">E escala muito bem. </font><font style="vertical-align: inherit;">Essa aceleração supera muito a desaceleração da criação e exclusão. </font><font style="vertical-align: inherit;">E isso é lógico: as iterações da entidade ocorrerão muitas vezes, mas são criadas e excluídas apenas uma vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos ver se isso reduziu o número de falhas de cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está a saída do cachegrind com 10.000 entidades: </font><font style="vertical-align: inherit;">E aqui está a saída para 100.000 entidades: </font><font style="vertical-align: inherit;">Vemos que esta versão cria cerca de três vezes menos links e quatro vezes menos perdas de cache.</font></font><br><br> <code>==1374== D refs: 94,563,949 (72,082,880 rd + 22,481,069 wr) <br> ==1374== D1 misses: 4,813,780 ( 4,417,702 rd + 396,078 wr) <br> ==1374== LLd misses: 378,905 ( 9,626 rd + 369,279 wr) <br> ==1374== D1 miss rate: 5.1% ( 6.1% + 1.8% ) <br> ==1374== LLd miss rate: 0.4% ( 0.0% + 1.6% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>==1307== D refs: 938,405,796 (715,424,940 rd + 222,980,856 wr) <br> ==1307== D1 misses: 51,034,738 ( 44,045,090 rd + 6,989,648 wr) <br> ==1307== LLd misses: 5,866,508 ( 1,997,948 rd + 3,868,560 wr) <br> ==1307== D1 miss rate: 5.4% ( 6.2% + 3.1% ) <br> ==1307== LLd miss rate: 0.6% ( 0.3% + 1.7% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipos automáticos </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A última melhoria de que falarei é a geração automática de identificadores de tipo de componente. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterações </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas as alterações para implementar a geração automática de tipos de ID podem ser encontradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pois, para poder atribuir um ID exclusivo a cada tipo de componente, você precisa usar o CRTP e uma função com um contador estático:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> generateComponentType() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Component&lt;T&gt;::type = generateComponentType();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode perceber que o ID do tipo agora é gerado em tempo de execução e era conhecido anteriormente em tempo de compilação. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código após as alterações pode ser encontrado neste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para testar o desempenho desta versão, realizei benchmarks: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bd/112/0da/7bd1120da37daac5e3ef48446776b6e7.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/f2f/937/234f2f9377a0f3ad8ea231f91e335ddf.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/101/4f2/ade/1014f2adebd6156bc48c9b6fe5670b43.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criação e exclusão, os resultados permaneceram aproximadamente os mesmos. </font><font style="vertical-align: inherit;">No entanto, você pode ver que a iteração se tornou um pouco mais lenta, cerca de 10%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa desaceleração pode ser explicada pelo fato de o compilador conhecer os identificadores de tipo no momento da compilação, o que significa que ele poderia otimizar melhor o código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A atribuição manual de tipos de identificação é um pouco inconveniente e pode levar a erros. </font><font style="vertical-align: inherit;">Portanto, mesmo que reduzamos um pouco o desempenho, ainda é uma melhoria na usabilidade da nossa biblioteca ECS.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ideias para melhorias adicionais </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de concluir este artigo, gostaria de compartilhar com você idéias para outras melhorias. </font><font style="vertical-align: inherit;">Até agora, eu não os implementei, mas talvez eu o faça no futuro.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Número dinâmico de componentes e sistemas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É inconveniente indicar antecipadamente o número máximo de componentes e sistemas na forma de parâmetros do modelo. </font><font style="vertical-align: inherit;">Eu acho que vai ser possível substituir </font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem uma degradação do desempenho forte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, é </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necessário conhecer o número de bits em tempo de compilação. </font><font style="vertical-align: inherit;">Embora eu ache que corrigir este problema, substituindo </font></font><code>std::vector&lt;bitset&lt;ComponentCount&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>std::vector&lt;char&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e liberar um número suficiente de bytes para representar os conjuntos de bits de todas as entidades. </font><font style="vertical-align: inherit;">Em seguida, implementamos uma classe leve </font></font><code>BitsetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que recebe na entrada um par de ponteiros para o início e o final do conjunto de bits e, em seguida, executamos todas as operações necessárias com </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esse intervalo de memória. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra idéia: não use mais conjuntos de bits e verifique apenas </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se a entidade possui componentes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteração de componente simplificada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No momento, se o sistema quiser percorrer iterativamente os componentes das entidades que processa, precisamos fazer o seguinte: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seria mais bonito e mais simples se pudéssemos fazer algo assim: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [position, velocity] : mEntityManager.getComponents&lt;Position, Velocity&gt;(mManagedEntities)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Será mais fácil implementá-lo com a ajuda </font><font style="vertical-align: inherit;">da </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">biblioteca de intervalos</font></a></font><code>std::view::transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no C ++ 20 </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Infelizmente, ainda não está lá. </font><font style="vertical-align: inherit;">Eu poderia usar </font><font style="vertical-align: inherit;">a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">biblioteca de intervalos de</font></a><font style="vertical-align: inherit;"> Eric Nibler, mas não quero adicionar dependências. </font><font style="vertical-align: inherit;">A solução poderia ser implementar uma classe </font><font style="vertical-align: inherit;">que recebesse os tipos de componentes que precisam ser recebidos como parâmetros de modelo e uma referência de </font><font style="vertical-align: inherit;">entidade </font><font style="vertical-align: inherit;">como parâmetro de construtor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Então teríamos apenas para perceber </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">e o tipo de iterador para obter o comportamento desejado. </font><font style="vertical-align: inherit;">Não é muito difícil, mas consome um pouco de tempo para escrever.</font></font><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>EntityRangeView</code><font style="vertical-align: inherit;"></font><code>std::vector</code><font style="vertical-align: inherit;"></font><code>begin</code><font style="vertical-align: inherit;"></font><code>end</code><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otimização de gerenciamento de eventos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na implementação atual, ao adicionar ou remover um componente de uma entidade, chamamos </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos os sistemas. </font><font style="vertical-align: inherit;">Isso é um pouco ineficiente porque muitos sistemas não estão interessados ​​no tipo de componente que acabou de ser alterado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para minimizar danos, podemos armazenar ponteiros para sistemas interessados ​​no tipo especificado de componentes na estrutura de dados, por exemplo </font></font><code>std::array&lt;std::vector&lt;System&lt;ComponentCount, SystemCount&gt;&gt;, ComponentCount&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Então, ao adicionar ou remover um componente, chamaríamos simplesmente o método de </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistemas interessados ​​nesse componente.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subconjuntos de entidades gerenciadas pelo gerente da entidade em vez de sistemas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minha última idéia levaria a mudanças mais extensas na estrutura da biblioteca. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de sistemas que gerenciam seus conjuntos de entidades, um gerente de entidade faria isso. A vantagem desse esquema é que, se dois sistemas estiverem interessados ​​em um conjunto de componentes, não duplicamos um subconjunto de entidades que atendem a esses requisitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os sistemas poderiam simplesmente declarar seus requisitos a um gerente de entidade. Em seguida, o gerente da entidade armazenaria todos os diferentes subconjuntos de entidades. Por fim, os sistemas consultariam entidades usando uma sintaxe semelhante:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : mEntityManager.getEntitiesWith&lt;Position, Velocity&gt;()) { ... }</code> </pre> <br><h1>  Conclusão </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Até agora, este é o fim de um artigo sobre minha implementação do sistema de componentes de entidade. </font><font style="vertical-align: inherit;">Se eu fizer outras melhorias, talvez eu esteja escrevendo novos artigos no futuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A implementação descrita no artigo é bastante simples: consiste em menos de 500 linhas de código e também possui bom desempenho. </font><font style="vertical-align: inherit;">Todas as transações são realizadas por tempo constante (amortizado). </font><font style="vertical-align: inherit;">Além disso, na prática, ele otimiza o uso do cache e recebe e repete muito rapidamente as entidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este artigo seja interessante ou até útil para você.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leitura adicional </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui estão alguns recursos úteis para um estudo mais aprofundado do padrão de entidade-componente-sistema: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michelle Kayney, autora de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , escreve uma série muito interessante de artigos sobre o sistema de entidade-componente chamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Wiki do Entity Systems</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contém informações e links muito úteis.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459288/">https://habr.com/ru/post/pt459288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459274/index.html">Vulnerabilidade de bloqueio de tela no Astra Linux Special Edition (Smolensk)</a></li>
<li><a href="../pt459276/index.html">Resistência épica a falhas 2 ou por que você não deve se envolver em privacidade com os plug-ins do FireFox</a></li>
<li><a href="../pt459280/index.html">Por que os desenvolvedores adoram criar aplicativos nativos?</a></li>
<li><a href="../pt459284/index.html">Breve introdução à estratégia de produtos e priorização de recursos</a></li>
<li><a href="../pt459286/index.html">Telureto de tungstênio semi-metálico - a faca suíça do dia da nanotecnologia</a></li>
<li><a href="../pt459292/index.html">Automação de teste de aplicativos móveis: comparação de ferramentas</a></li>
<li><a href="../pt459294/index.html">O que é mais importante: conhecer uma linguagem de programação ou ser capaz de resolver um problema de negócios?</a></li>
<li><a href="../pt459296/index.html">JavaScript Preço 2019</a></li>
<li><a href="../pt459298/index.html">Angular: status em 2019</a></li>
<li><a href="../pt459300/index.html">Quasar 1.0: uma nova ferramenta útil para desenvolvedores do Vue e não apenas para eles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>