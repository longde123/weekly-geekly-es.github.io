<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé£ üßîüèº ‚òîÔ∏è Usando dados criptografados para aprendizado de m√°quina sem descriptograf√°-los üëàüèΩ üàπ üìê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usando dados criptografados para aprendizado de m√°quina sem descriptograf√°-los 
 Este artigo discute t√©cnicas criptogr√°ficas avan√ßadas. Esta √© apenas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usando dados criptografados para aprendizado de m√°quina sem descriptograf√°-los</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/478514/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/ns/yf/_pnsyfz49v6t61j8whitl-q4qw0.jpeg"></div><br>  Usando dados criptografados para aprendizado de m√°quina sem descriptograf√°-los <br>  Este artigo discute t√©cnicas criptogr√°ficas avan√ßadas.  Esta √© apenas uma vis√£o geral das pesquisas conduzidas por Julia Computing.  N√£o use os exemplos dados aqui em aplicativos comerciais.  Sempre consulte os criptografadores antes de aplicar a criptografia. <br><br>  <a href="">Aqui</a> voc√™ pode baixar o pacote que implementa toda a magia, e <a href="">aqui</a> est√° o c√≥digo discutido no artigo. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Digamos que voc√™ acabou de desenvolver um novo modelo interessante de aprendizado de m√°quina (√© claro, usando o <a href="">Flux.jl</a> ).  E agora voc√™ deseja come√ßar a implant√°-lo para seus usu√°rios.  Como voc√™ far√° isso?  Provavelmente, a maneira mais f√°cil √© fornecer o modelo aos usu√°rios e deix√°-lo executar localmente em seus dados.  Mas essa abordagem tem desvantagens: <br><br><ol><li>  Os modelos de aprendizado de m√°quina s√£o grandes e os computadores dos usu√°rios podem n√£o ter recursos suficientes de computa√ß√£o ou disco. </li><li>  Os modelos de aprendizado de m√°quina geralmente s√£o atualizados e pode n√£o ser conveniente enviar regularmente grandes quantidades de dados pela rede. <br></li><li>  O desenvolvimento do modelo √© demorado e requer uma grande quantidade de recursos de computa√ß√£o.  E voc√™ pode querer uma compensa√ß√£o por isso na forma de uma taxa pelo uso do seu modelo. </li></ol><br>  Em seguida, eles lembram que o modelo pode ser fornecido na nuvem por meio da API.  Nos √∫ltimos anos, muitos desses servi√ßos apareceram; cada grande plataforma em nuvem oferece servi√ßos semelhantes aos desenvolvedores corporativos.  Mas os usu√°rios em potencial enfrentam um dilema √≥bvio: agora seus dados s√£o processados ‚Äã‚Äãem um servidor remoto, o que pode n√£o ser confi√°vel.  Isso tem implica√ß√µes √©ticas e legais claras que limitam o uso de tais servi√ßos.  Em setores regulamentados, especialmente servi√ßos de sa√∫de e financeiros, geralmente n√£o √© poss√≠vel enviar dados de pacientes e clientes a terceiros para processamento. <br><br>  Alguma outra op√ß√£o? <br><br>  Acontece que existe!  Descobertas recentes em criptografia permitem a computa√ß√£o com dados <i>sem decodific√°-los</i> .  Por exemplo, um usu√°rio envia dados criptografados (por exemplo, imagens) para uma API da nuvem que inicia um modelo de aprendizado de m√°quina e envia uma resposta criptografada.  Em nenhum momento os dados s√£o descriptografados, o provedor de nuvem n√£o obt√©m acesso √†s imagens de origem e n√£o pode descriptografar a previs√£o calculada.  Como isso √© poss√≠vel?  Vamos descobrir o exemplo da cria√ß√£o de um servi√ßo para reconhecimento de manuscrito em imagens criptografadas do conjunto de dados MNIST. <br><br><h2>  Sobre criptografia homom√≥rfica </h2><br>  A capacidade de executar c√°lculos com dados criptografados √© comumente referida como "computa√ß√£o segura".  Essa √© uma grande √°rea para pesquisa, com in√∫meras abordagens √† criptografia, dependendo de todos os tipos de cen√°rios de aplicativos.  Vamos nos concentrar em uma t√©cnica chamada "criptografia homom√≥rfica".  Nesse sistema, as seguintes opera√ß√µes geralmente est√£o dispon√≠veis para n√≥s: <br><br><ul><li><code>pub_key, eval_key, priv_key = keygen()</code> <br> </li><li> <code>encrypted = encrypt(pub_key, plaintext)</code> <br> </li><li> <code>decrypted = decrypt(priv_key, encrypted)</code> <br> </li><li> <code>encrypted‚Ä≤ = eval(eval_key, f, encrypted)</code> <br> </li></ul><br>  As tr√™s primeiras opera√ß√µes s√£o simples e familiares para todos que j√° usaram algoritmos de criptografia assim√©trica (por exemplo, se voc√™ se conectou via TLS).  Toda m√°gica acontece na √∫ltima opera√ß√£o.  Durante a criptografia, ele avalia a fun√ß√£o <code>f</code> e retorna outro valor criptografado calculado de acordo com o resultado da avalia√ß√£o de <code>f</code> no valor criptografado.  Esse recurso deu seu nome √† abordagem.  A avalia√ß√£o est√° relacionada √† opera√ß√£o de criptografia: <br><br><pre> <code class="julia hljs">f(decrypt(priv_key, encrypted)) == decrypt(priv_key, eval(eval_key, f, encrypted))</code> </pre> <br>  Da mesma forma, usando um valor criptografado, podemos avaliar homomorfismos arbitr√°rios <code>f</code> . <br><br>  Quais fun√ß√µes <code>f</code> suportadas dependem de esquemas criptogr√°ficos e opera√ß√µes suportadas.  Se apenas um <code>f</code> suportado (por exemplo, <code>f = +</code> ), o circuito ser√° chamado de "parcialmente homom√≥rfico".  Se <code>f</code> pode ser qualquer conjunto completo de gateways, com base nos quais esquemas arbitr√°rios podem ser criados, ent√£o, para um tamanho limitado de um esquema, isso √© chamado de outro tipo de c√°lculo parcialmente homom√≥rfico - "um tanto homom√≥rfico" e para um tamanho ilimitado - c√°lculo "completamente homom√≥rfico".  Voc√™ pode transformar "de alguma forma" em uma criptografia completamente homom√≥rfica usando a t√©cnica de inicializa√ß√£o, mas isso est√° al√©m do escopo de nosso artigo.  A criptografia totalmente homom√≥rfica √© uma descoberta relativamente recente; o primeiro esquema de trabalho (embora impratic√°vel) foi publicado por <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">Craig Gentry em 2009</a> .  Existem v√°rios esquemas posteriores (e pr√°ticos) completamente homom√≥rficos.  Existem tamb√©m pacotes de software que implementam qualitativamente esses esquemas.  Na maioria das vezes, eles usam o <a href="https://github.com/microsoft/SEAL">Microsoft SEAL</a> e <a href="https://palisade-crypto.org/">PALISADE</a> .  Al√©m disso, abri recentemente o c√≥digo de implementa√ß√£o desses algoritmos <a href="">Pure Julia</a> .  Neste artigo, usaremos a criptografia CKKS implementada nele. <br><br><h2>  Vis√£o geral do CKS </h2><br>  O CKKS (pelos nomes dos autores do <a href="https://eprint.iacr.org/2016/421.pdf">trabalho cient√≠fico</a> Cheon-Kim-Kim-Song, que prop√¥s o algoritmo em 2016) √© um esquema de criptografia homom√≥rfica que permite a avalia√ß√£o homom√≥rfica das seguintes opera√ß√µes primitivas: <br><br><ul><li>  A adi√ß√£o elementar dos comprimentos de <code>n</code> vetores de n√∫meros complexos. <br></li><li>  Multiplica√ß√£o por elemento dos comprimentos de <code>n</code> vetores complexos. <br></li><li>  Gire (no contexto de <code>circshift</code> de <code>circshift</code> ) elementos em um vetor. <br></li><li>  Emparelhamento integrado de elementos do vetor. <br></li></ul><br>  O par√¢metro <code>n</code> depende do n√≠vel desejado de seguran√ßa e precis√£o, e geralmente √© bastante alto.  Em nosso exemplo, ser√° igual a 4096 (um valor mais alto aumenta a seguran√ßa, mas tamb√©m √© mais dif√≠cil nos c√°lculos, √© escalado aproximadamente como <code>n log n</code> ). <br><br>  Al√©m disso, os c√°lculos usando CKKS s√£o <i>barulhentos</i> .  Portanto, os resultados s√£o aproximados e deve-se tomar cuidado para que os resultados sejam avaliados com precis√£o suficiente para n√£o afetar a exatid√£o do resultado. <br><br>  Por outro lado, essas restri√ß√µes n√£o s√£o incomuns para os desenvolvedores de pacotes de aprendizado de m√°quina.  Aceleradores especiais como a GPU tamb√©m costumam operar com vetores num√©ricos.  Al√©m disso, para muitos desenvolvedores, os n√∫meros de ponto flutuante √†s vezes parecem barulhentos devido √† influ√™ncia de algoritmos de sele√ß√£o, multithreading etc.  Quero enfatizar que a principal diferen√ßa aqui √© que os c√°lculos aritm√©ticos com n√∫meros de ponto flutuante s√£o inicialmente determin√≠sticos, mesmo que isso n√£o seja √≥bvio devido √† complexidade da implementa√ß√£o, embora as primitivas do CKKS sejam realmente barulhentas.  Mas talvez isso permita que os usu√°rios entendam que o ru√≠do n√£o √© t√£o assustador quanto pode parecer. <br><br>  Agora vamos ver como voc√™ pode executar essas opera√ß√µes na Julia (nota: par√¢metros muito inseguros s√£o selecionados, com essas opera√ß√µes ilustramos apenas o uso da biblioteca no REPL). <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ToyFHE <span class="hljs-comment"><span class="hljs-comment"># Let's play with 8 element vectors julia&gt; N = 8; # Choose some parameters - we'll talk about it later julia&gt; ‚Ñõ = NegacyclicRing(2N, (40, 40, 40)) ‚Ñ§‚ÇÅ‚ÇÉ‚ÇÇ‚Çâ‚ÇÇ‚ÇÇ‚Çá‚Çâ‚Çâ‚Çá‚ÇÖ‚ÇÜ‚Çà‚ÇÄ‚Çà‚ÇÅ‚ÇÑ‚ÇÖ‚Çá‚ÇÑ‚ÇÄ‚ÇÇ‚Çá‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÄ‚Çá‚ÇÅ‚ÇÄ‚ÇÑ‚ÇÇ‚ÇÑ‚Çà‚ÇÇ‚ÇÖ‚Çá/(x¬π‚Å∂ + 1) # We'll use CKKS julia&gt; params = CKKSParams(‚Ñõ) CKKS parameters # We need to pick a scaling factor for a numbers - again we'll talk about that later julia&gt; Tscale = FixedRational{2^40} FixedRational{1099511627776,T} where T # Let's start with a plain Vector of zeros julia&gt; plain = CKKSEncoding{Tscale}(zero(‚Ñõ)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im # Ok, we're ready to get started, but first we'll need some keys julia&gt; kp = keygen(params) CKKS key pair julia&gt; kp.priv CKKS private key julia&gt; kp.pub CKKS public key # Alright, let's encrypt some things: julia&gt; foreach(i-&gt;plain[i] = i+1, 0:7); plain 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im 7.0 + 0.0im 8.0 + 0.0im julia&gt; c = encrypt(kp.pub, plain) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1099511627776,T} where T}) # And decrypt it again julia&gt; decrypt(kp.priv, c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.9999999999995506 - 2.7335193113350057e-16im 1.9999999999989408 - 3.885780586188048e-16im 3.000000000000205 + 1.6772825551165524e-16im 4.000000000000538 - 3.885780586188048e-16im 4.999999999998865 + 8.382500573679615e-17im 6.000000000000185 + 4.996003610813204e-16im 7.000000000001043 - 2.0024593503998215e-16im 8.000000000000673 + 4.996003610813204e-16im # Note that we had some noise. Let's go through all the primitive operations we'll need: julia&gt; decrypt(kp.priv, c+c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.9999999999991012 - 5.467038622670011e-16im 3.9999999999978817 - 7.771561172376096e-16im 6.00000000000041 + 3.354565110233105e-16im 8.000000000001076 - 7.771561172376096e-16im 9.99999999999773 + 1.676500114735923e-16im 12.00000000000037 + 9.992007221626409e-16im 14.000000000002085 - 4.004918700799643e-16im 16.000000000001346 + 9.992007221626409e-16im julia&gt; csq = c*c CKKS ciphertext (length 3, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) julia&gt; decrypt(kp.priv, csq) 8-element CKKSEncoding{FixedRational{1208925819614629174706176,T} where T} with indices 0:7: 0.9999999999991012 - 2.350516767363621e-15im 3.9999999999957616 - 5.773159728050814e-15im 9.000000000001226 - 2.534464540987068e-15im 16.000000000004306 - 2.220446049250313e-15im 24.99999999998865 + 2.0903753311370056e-15im 36.00000000000222 + 4.884981308350689e-15im 49.000000000014595 + 1.0182491378134327e-15im 64.00000000001077 + 4.884981308350689e-15im</span></span></code> </pre> <br>  T√£o simples!  Um leitor atento pode perceber que o CSQ √© um pouco diferente do texto cifrado anterior.  Em particular, o texto cifrado tem "comprimento 3" e a escala √© muito maior.  Uma explica√ß√£o do que √© e do que √© necess√°rio est√° al√©m do escopo deste artigo.  Basta dizer que precisamos diminuir os valores antes de continuar com os c√°lculos; caso contr√°rio, o "local" terminar√° no texto cifrado.  Felizmente, podemos reduzir cada um dos dois valores aumentados: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># To get back down to length 2, we need to `keyswitch` (aka # relinerarize), which requires an evaluation key. Generating # this requires the private key. In a real application we would # have generated this up front and sent it along with the encrypted # data, but since we have the private key, we can just do it now. julia&gt; ek = keygen(EvalMultKey, kp.priv) CKKS multiplication key julia&gt; csq_length2 = keyswitch(ek, csq) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) # Getting the scale back down is done using modswitching. julia&gt; csq_smaller = modswitch(csq_length2) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1.099511626783e12,T} where T}) # And it still decrypts correctly (though note we've lost some precision) julia&gt; decrypt(kp.priv, csq_smaller) 8-element CKKSEncoding{FixedRational{1.099511626783e12,T} where T} with indices 0:7: 0.9999999999802469 - 5.005163520332181e-11im 3.9999999999957723 - 1.0468514951188039e-11im 8.999999999998249 - 4.7588542623100616e-12im 16.000000000023014 - 1.0413447889166631e-11im 24.999999999955193 - 6.187833723406491e-12im 36.000000000002345 + 1.860733715346631e-13im 49.00000000001647 - 1.442396043149794e-12im 63.999999999988695 - 1.0722489563648028e-10im</span></span></code> </pre> <br>  Al√©m disso, modswitching (abrevia√ß√£o de comuta√ß√£o de m√≥dulo, comuta√ß√£o de m√≥dulo) reduz o tamanho do m√≥dulo de texto cifrado, para que n√£o possamos continuar fazendo isso indefinidamente (usamos um esquema de criptografia um tanto homom√≥rfica): <br><br><pre> <code class="julia hljs">julia&gt; ‚Ñõ <span class="hljs-comment"><span class="hljs-comment"># Remember the ring we initially created ‚Ñ§‚ÇÅ‚ÇÉ‚ÇÇ‚Çâ‚ÇÇ‚ÇÇ‚Çá‚Çâ‚Çâ‚Çá‚ÇÖ‚ÇÜ‚Çà‚ÇÄ‚Çà‚ÇÅ‚ÇÑ‚ÇÖ‚Çá‚ÇÑ‚ÇÄ‚ÇÇ‚Çá‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÄ‚Çá‚ÇÅ‚ÇÄ‚ÇÑ‚ÇÇ‚ÇÑ‚Çà‚ÇÇ‚ÇÖ‚Çá/(x¬π‚Å∂ + 1) julia&gt; ToyFHE.ring(csq_smaller) # It shrunk! ‚Ñ§‚ÇÅ‚ÇÇ‚ÇÄ‚Çà‚Çâ‚ÇÇ‚ÇÖ‚Çà‚ÇÇ‚ÇÄ‚ÇÅ‚ÇÑ‚ÇÑ‚ÇÖ‚Çâ‚ÇÉ‚Çá‚Çá‚Çâ‚ÇÉ‚ÇÉ‚ÇÅ‚ÇÖ‚ÇÖ‚ÇÉ/(x¬π‚Å∂ + 1)&lt;/code&gt;     ‚Äî  (rotations).      keyswitch,       (evaluation key,     ): &lt;source lang="julia"&gt;julia&gt; gk = keygen(GaloisKey, kp.priv; steps=2) CKKS galois key (element 25) julia&gt; decrypt(circshift(c, gk)) decrypt(kp, circshift(c, gk)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 7.000000000001042 + 5.68459112632516e-16im 8.000000000000673 + 5.551115123125783e-17im 0.999999999999551 - 2.308655353580721e-16im 1.9999999999989408 + 2.7755575615628914e-16im 3.000000000000205 - 6.009767921608429e-16im 4.000000000000538 + 5.551115123125783e-17im 4.999999999998865 + 4.133860996136768e-17im 6.000000000000185 - 1.6653345369377348e-16im # And let's compare to doing the same on the plaintext julia&gt; circshift(plain, 2) 8-element OffsetArray(::Array{Complex{Float64},1}, 0:7) with eltype Complex{Float64} with indices 0:7: 7.0 + 0.0im 8.0 + 0.0im 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im</span></span></code> </pre> <br>  Abordamos o b√°sico do uso da biblioteca HE.  Mas antes de passar a usar essas primitivas para calcular previs√µes de redes neurais, vejamos o processo de aprend√™-las. <br><br><h2>  Modelo de aprendizado de m√°quina </h2><br>  Se voc√™ n√£o estiver familiarizado com o aprendizado de m√°quina ou a biblioteca Flux.jl, recomendo uma r√°pida <a href="https://fluxml.ai/Flux.jl/stable/">pesquisa na documenta√ß√£o</a> do <a href="https://fluxml.ai/Flux.jl/stable/">Flux.jl</a> ou consulte uma <a href="https://juliaacademy.com/p/introduction-to-machine-learning">introdu√ß√£o</a> gratuita <a href="https://juliaacademy.com/p/introduction-to-machine-learning">ao aprendizado de m√°quina</a> , porque discutiremos apenas as mudan√ßas na aplica√ß√£o do modelo aos dados criptografados. <br><br>  Vamos come√ßar usando a rede neural convolucional <a href="">do zool√≥gico Flux</a> .  Vamos realizar o mesmo ciclo de treinamento, com prepara√ß√£o de dados e assim por diante, apenas configurando um pouco o modelo.  Aqui est√°: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reshape_and_vcat(x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y=reshape(x, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, size(x, <span class="hljs-number"><span class="hljs-number">4</span></span>)) vcat((y[:,i,:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=axes(y,<span class="hljs-number"><span class="hljs-number">2</span></span>))...) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> model = Chain( <span class="hljs-comment"><span class="hljs-comment"># First convolution, operating upon a 28x28 image Conv((7, 7), 1=&gt;4, stride=(3,3), x-&gt;x.^2), reshape_and_vcat, Dense(256, 64, x-&gt;x.^2), Dense(64, 10), )</span></span></code> </pre><br>  Esse √© o mesmo modelo do trabalho <a href="https://eprint.iacr.org/2018/1041.pdf">‚ÄúComputa√ß√£o matricial terceirizada segura e aplicativo para redes neurais‚Äù</a> , que usa o mesmo esquema criptogr√°fico com duas diferen√ßas: 1) por uma quest√£o de simplicidade, n√£o criptografamos o modelo em si e 2) ap√≥s cada camada que temos S√£o utilizados vetores bayesianos (isso √© feito por padr√£o no Flux), sem ter certeza se isso estava no trabalho mencionado.  Talvez, devido ao segundo ponto, a precis√£o no conjunto de testes de nosso modelo tenha sido ligeiramente maior (98,6% versus 98,1%), mas diferen√ßas hiperparam√©tricas tamb√©m possam ser o motivo. <br><br>  Incomum (para quem tem experi√™ncia em aprendizado de m√°quina) √© a ativa√ß√£o de fun√ß√µes <code>x.^2</code> .  Na maioria dos casos, nesses casos, eles usam <code>tanh</code> , <code>relu</code> ou algo mais fantasioso.  Por√©m, embora essas fun√ß√µes (especialmente <code>relu</code> ) sejam facilmente calculadas para valores de texto comuns, no entanto, elas podem exigir muitos recursos computacionais para avali√°-las em forma criptografada (geralmente estimamos a aproxima√ß√£o polinomial).  Felizmente, neste caso, <code>x.^2</code> funciona muito bem. <br><br>  O restante do ciclo de aprendizado permaneceu o mesmo.  Removemos o <code>softmax</code> do modelo para a fun√ß√£o de perda atrav√©s da <code>logitcrossentropy</code> (voc√™ pode deix√°-lo e avaliar o softmax ap√≥s a descriptografia no cliente).  O c√≥digo completo para o treinamento do modelo est√° <a href="">no GitHub</a> , ele √© executado em alguns minutos em qualquer nova placa de v√≠deo. <br><br><h2>  Opera√ß√µes efetivas </h2><br>  Agora sabemos quais opera√ß√µes precisamos executar: <br><br><ul><li>  Coagula√ß√£o. <br></li><li>  Elemento quadrado. <br></li><li>  Multiplica√ß√£o de matrizes. <br></li></ul><br>  Ao quadrado tudo √© simples, j√° o examinamos acima, portanto consideraremos duas outras opera√ß√µes.  Assumimos que o comprimento do pacote de dados √© 64 (voc√™ pode notar que os par√¢metros do modelo e o tamanho do pacote s√£o escolhidos de forma a tirar proveito do vetor de 4096 elementos que obtivemos como resultado de uma escolha realista dos par√¢metros). <br><br><h3>  Coagula√ß√£o </h3><br>  Lembre-se de como a coagula√ß√£o funciona.  Pegue uma janela (no nosso caso 7x7) da matriz de entrada original e cada elemento da janela √© multiplicado por um elemento de m√°scara de convolu√ß√£o.  Em seguida, movemos a janela para algum passo (no nosso caso, o passo √© 3, ou seja, movemos 3 elementos) e repetimos o processo (com a mesma m√°scara de convolu√ß√£o).  A anima√ß√£o do processo ( <a href="https://github.com/vdumoulin/conv_arithmetic">fonte</a> ) para a convolu√ß√£o 3x3 com a etapa <code>(2, 2)</code> mostrada abaixo (matriz azul - entrada, verde - sa√≠da): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h5/a3/q3/h5a3q3ea0pljgdagz1wd-k2igdy.gif"></div><br>  Al√©m disso, realizamos a convolu√ß√£o em quatro "canais" diferentes (ou seja, repetimos a convolu√ß√£o mais tr√™s vezes com m√°scaras diferentes). <br><br>  Agora sabemos o que fazer, resta entender como.  Temos a sorte de que a convolu√ß√£o √© a primeira opera√ß√£o em nosso modelo.  Como resultado, para economizar recursos, podemos pr√©-processar os dados no cliente e depois criptograf√°-los (sem usar pesos).  Vamos fazer o seguinte: <br><br><ul><li>  Primeiro, calculamos cada janela de convolu√ß√£o (ou seja, uma amostra 7x7 das imagens de origem), o que fornece 64 matrizes 7x7 para cada imagem de entrada.  Observe que, para uma janela 7x7 em incrementos de 2, haver√° janelas de convolu√ß√£o 8x8 para avaliar a imagem de entrada 28x28. <br></li><li>  Vamos coletar em um vetor as mesmas posi√ß√µes em cada janela.  Ou seja, para cada imagem, teremos um vetor de 64 elementos ou um vetor de 64x64 para um pacote de tamanho 64 (um total de 49 matrizes 64x64). <br></li><li>  Vamos criptografar. <br></li></ul><br>  Ent√£o a coagula√ß√£o simplesmente se transforma em multiplica√ß√£o escalar de toda a matriz com o elemento de m√°scara correspondente.  E resumindo mais tarde todos os 49 elementos, obtemos o resultado da dobragem.  Aqui est√° a apar√™ncia da implementa√ß√£o dessa estrat√©gia (em texto simples): <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> public_preprocess(batch) ka = OffsetArray(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create feature extracted matrix I = [[batch[i‚Ä≤*3 .+ (1:7), j‚Ä≤*3 .+ (1:7), 1, k] for i‚Ä≤=ka, j‚Ä≤=ka] for k = 1:64] # Reshape into the ciphertext I·µ¢‚±º = [[I[k][l...][i,j] for k=1:64, l=product(ka, ka)] for i=1:7, j=1:7] end I·µ¢‚±º = public_preprocess(batch) # Evaluate the convolution weights = model.layers[1].weight conv_weights = reverse(reverse(weights, dims=1), dims=2) conved = [sum(I·µ¢‚±º[i,j]*conv_weights[i,j,1,channel] for i=1:7, j=1:7) for channel = 1:4] conved = map(((x,b),)-&gt;x .+ b, zip(conved, model.layers[1].bias))</span></span></code> </pre> <br>  Este (m√≥dulo para alterar a dimens√£o) (m√≥dulo - alterar a ordem dos tamanhos) fornece a mesma resposta que a opera√ß√£o <code>model.layers[1](batch)</code> . <br><br>  Adicione opera√ß√µes de criptografia: <br><br><pre> <code class="julia hljs">I·µ¢‚±º = public_preprocess(batch) C_I·µ¢‚±º = map(I·µ¢‚±º) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N√∑<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_I·µ¢‚±º[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2)</code> </pre> <br>  Observe que a chave n√£o √© necess√°ria aqui porque os pesos s√£o p√∫blicos.  Portanto, n√£o aumentamos o comprimento do texto cifrado. <br><br><h3>  Multiplica√ß√£o de matrizes </h3><br>  Passando para a multiplica√ß√£o de matrizes, podemos usar a rota√ß√£o de elementos no vetor para alterar a ordem dos √≠ndices de multiplica√ß√£o.  Vamos considerar o layout da linha dos elementos da matriz em um vetor.  Se mudarmos o vetor por um m√∫ltiplo do tamanho da linha, obtemos o efeito da rota√ß√£o da coluna, que √© uma primitiva suficiente para implementar a multiplica√ß√£o de matrizes (pelo menos matrizes quadradas).  Vamos tentar: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> matmul_square_reordered(weights, x) sum(<span class="hljs-number"><span class="hljs-number">1</span></span>:size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k <span class="hljs-comment"><span class="hljs-comment"># We rotate the columns of the LHS and take the diagonal weight_diag = diag(circshift(weights, (0,(k-1)))) # We rotate the rows of the RHS x_rotated = circshift(x, (k-1,0)) # We do an elementwise, broadcast multiply weight_diag .* x_rotated end end function matmul_reorderd(weights, x) sum(partition(1:256, 64)) do range matmul_square_reordered(weights[:, range], x[range, :]) end end fc1_weights = model.layers[3].W x = rand(Float64, 256, 64) @assert (fc1_weights*x) ‚âà matmul_reorderd(fc1_weights, x)</span></span></code> </pre> <br>  Obviamente, para a multiplica√ß√£o geral da matriz, √© necess√°rio algo mais complicado, mas por enquanto isso √© suficiente. <br><br><h2>  Melhorando a t√©cnica </h2><br>  Agora todos os componentes de nossa t√©cnica funcionam.  Aqui est√° o c√≥digo inteiro (exceto para definir op√ß√µes de sele√ß√£o e coisas semelhantes): <br><br><pre> <code class="julia hljs">ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) I·µ¢‚±º = public_preprocess(batch) C_I·µ¢‚±º = map(I·µ¢‚±º) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N√∑<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_I·µ¢‚±º[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2) Csqed1 = map(x-&gt;x*x, conved1) Csqed1 = map(x-&gt;keyswitch(ek, x), Csqed1) Csqed1 = map(ToyFHE.modswitch, Csqed1) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encrypted_matmul(gk, weights, x::ToyFHE.CipherText) result = repeat(diag(weights), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>).*x rotated = x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">64</span></span> rotated = ToyFHE.rotate(gk, rotated) result += repeat(diag(circshift(weights, (<span class="hljs-number"><span class="hljs-number">0</span></span>,(k-<span class="hljs-number"><span class="hljs-number">1</span></span>)))), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>) .* rotated <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq1_weights = model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].W Cfq1 = sum(enumerate(partition(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (i,range) encrypted_matmul(gk, fq1_weights[:, range], Csqed1[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Cfq1 = Cfq1 .+ OffsetArray(repeat(model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].b, inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>) Cfq1 = modswitch(Cfq1) Csqed2 = Cfq1*Cfq1 Csqed2 = keyswitch(ek, Csqed2) Csqed2 = modswitch(Csqed2) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> naive_rectangular_matmul(gk, weights, x) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>) weights = vcat(weights, zeros(eltype(weights), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>)-size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>))) encrypted_matmul(gk, weights, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq2_weights = model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].W Cresult = naive_rectangular_matmul(gk, fq2_weights, Csqed2) Cresult = Cresult .+ OffsetArray(repeat(vcat(model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].b, zeros(<span class="hljs-number"><span class="hljs-number">54</span></span>)), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>)</code> </pre> <br>  N√£o parece muito legal, mas se voc√™ fez tudo isso, deve entender cada passo. <br>  Agora vamos pensar sobre quais abstra√ß√µes poderiam simplificar nossas vidas.  Estamos saindo do campo da cartografia e do aprendizado de m√°quina e passando para a arquitetura da linguagem de programa√ß√£o, ent√£o vamos aproveitar o fato de que Julia permite que voc√™ use e crie abstra√ß√µes poderosas.  Por exemplo, voc√™ pode encapsular todo o processo de extra√ß√£o de convolu√ß√µes no seu tipo de matriz: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BlockArrays <span class="hljs-string"><span class="hljs-string">""" ExplodedConvArray{T, Dims, Storage} &lt;: AbstractArray{T, 4} Represents a an `nxmx1xb` array of images, but rearranged into a series of convolution windows. Evaluating a convolution compatible with `Dims` on this array is achievable through a sequence of scalar multiplications and sums on the underling storage. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ExplodedConvArray{T, <span class="hljs-built_in"><span class="hljs-built_in">Dims</span></span>, Storage} &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractArray</span></span>{T, <span class="hljs-number"><span class="hljs-number">4</span></span>} <span class="hljs-comment"><span class="hljs-comment"># sx*sy matrix of b*(dx*dy) matrices of extracted elements # where (sx, sy) = kernel_size(Dims) # (dx, dy) = output_size(DenseConvDims(...)) cdims::Dims x::Matrix{Storage} function ExplodedConvArray{T, Dims, Storage}(cdims::Dims, storage::Matrix{Storage}) where {T, Dims, Storage} @assert all(==(size(storage[1])), size.(storage)) new{T, Dims, Storage}(cdims, storage) end end Base.size(ex::ExplodedConvArray) = (NNlib.input_size(ex.cdims)..., 1, size(ex.x[1], 1)) function ExplodedConvArray{T}(cdims, batch::AbstractArray{T, 4}) where {T} x, y = NNlib.output_size(cdims) kx, ky = NNlib.kernel_size(cdims) stridex, stridey = NNlib.stride(cdims) kax = OffsetArray(0:x-1, 0:x-1) kay = OffsetArray(0:x-1, 0:x-1) I = [[batch[i‚Ä≤*stridex .+ (1:kx), j‚Ä≤*stridey .+ (1:ky), 1, k] for i‚Ä≤=kax, j‚Ä≤=kay] for k = 1:size(batch, 4)] I·µ¢‚±º = [[I[k][l...][i,j] for k=1:size(batch, 4), l=product(kax, kay)] for (i,j) in product(1:kx, 1:ky)] ExplodedConvArray{T, typeof(cdims), eltype(I·µ¢‚±º)}(cdims, I·µ¢‚±º) end function NNlib.conv(x::ExplodedConvArray{&lt;:Any, Dims}, weights::AbstractArray{&lt;:Any, 4}, cdims::Dims) where {Dims&lt;:ConvDims} blocks = reshape([ Base.ReshapedArray(sum(xx[i,j]*weights[i,j,1,channel] for i=1:7, j=1:7), (NNlib.output_size(cdims)...,1,size(x, 4)), ()) for channel = 1:4 ],(1,1,4,1)) BlockArrays._BlockArray(blocks, BlockArrays.BlockSizes([8], [8], [1,1,1,1], [64])) end</span></span></code> </pre><br>  Aqui, novamente usamos o <code>BlockArrays</code> para representar uma matriz <code>8x8x4x64</code> como quatro matrizes <code>8x8x1x64</code> como no c√≥digo-fonte.  Agora, a apresenta√ß√£o do primeiro est√°gio ficou muito mais bonita, pelo menos com matrizes n√£o criptografadas: <br><br><pre> <code class="julia hljs">julia&gt; cdims = DenseConvDims(batch, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight; stride=(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), dilation=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) DenseConvDims: (<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), stride: (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) pad: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), dil: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), flip: <span class="hljs-literal"><span class="hljs-literal">false</span></span> julia&gt; a = ExplodedConvArray{eltype(batch)}(cdims, batch); julia&gt; model(a) <span class="hljs-number"><span class="hljs-number">10</span></span>√ó<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: [snip]</code> </pre><br>  Agora, como conectamos isso √† criptografia?  Para fazer isso, voc√™ precisa: <br><br><ol><li>  Criptografe a estrutura ( <code>ExplodedConvArray</code> ) para obter o texto cifrado para cada campo.  Opera√ß√µes com uma estrutura criptografada verificar√£o o que a fun√ß√£o faria com a estrutura original e far√£o a mesma coisa homomorficamente. <br></li><li>  Intercepte determinadas opera√ß√µes para execut√°-las de maneira diferente em um contexto criptografado. </li></ol><br>  Felizmente, Julia nos fornece uma abstra√ß√£o para isso: um plug-in de compilador que usa o mecanismo <a href="">Cassette.jl</a> .  N√£o vou lhe dizer o que √© e como funciona, vou dizer brevemente que ele pode determinar o contexto, por exemplo, <code>Encrypted</code> e, em seguida, define as regras de funcionamento das opera√ß√µes nesse contexto.  Por exemplo, voc√™ pode escrever isso para o segundo requisito: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted block array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{&lt;:BlockArray{T, 2}}) where {T} sum(a*b for (i,range) in enumerate(partition(1:size(a, 2), size(b.blocks[1], 1)))) end # Define Matrix multiplication between an array and an encrypted array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{Array{T, 2}}) where {T} result = repeat(diag(a), inner=size(a, 1)).*x rotated = b for k = 2:size(a, 2) rotated = ToyFHE.rotate(GaloisKey(*), rotated) result += repeat(diag(circshift(a, (0,(k-1)))), inner=size(a, 1)) .* rotated end result end</span></span></code> </pre><br>  Como resultado, o usu√°rio poder√° escrever todos os itens acima com uma quantidade m√≠nima de trabalho manual: <br><br><pre> <code class="julia hljs">kp = keygen(ckks_params) ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create evaluation context ctx = Encrypted(ek, gk) # Do public preprocessing batch = ExplodedConvArray{eltype(batch)}(cdims, batch); # Run on encrypted data under the encryption context Cresult = ctx(model)(encrypt(kp.pub, batch)) # Decrypt the answer decrypt(kp, Cresult)</span></span></code> </pre> <br> ,     .   (   ‚Ñõ,   modswitch, keyswitch  ..)       ,      .  ,    ,    ,         ,        . <br><br><h2>  Conclus√£o </h2><br>          ‚Äî      .     Julia          .  RAMPARTS ( <a href="https://eprint.iacr.org/2019/988.pdf">paper</a> , <a href="https://www.youtube.com/watch%3Fv%3D_KLlMg6jKQg">JuliaCon talk</a> )       :  Julia-   -  PALISADE. Julia Computing    RAMPARTS    Verona, <a href="https://galois.com/news/15m-iarpa-hector-contract-privacy-preserving-technology/"> </a>     .             ,     .  .     ,   ,          . <br><br>        ,   <a href=""> ToyFHE</a> .   <a href="https://juliacomputing.github.io/ToyFHE.jl/dev/man/background/"></a> , ,   ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478514/">https://habr.com/ru/post/pt478514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478500/index.html">Por que existem t√£o poucas confer√™ncias no ver√£o?</a></li>
<li><a href="../pt478502/index.html">Tecnologia inteligente para todos</a></li>
<li><a href="../pt478504/index.html">Como o local de trabalho se transforma com a evolu√ß√£o do laptop</a></li>
<li><a href="../pt478508/index.html">Telegrama como servi√ßo</a></li>
<li><a href="../pt478510/index.html">Convidamos voc√™ para o DINS QA EVENING 12/12/19: crie um pipeline Jenkins e aprenda a paralelizar o lan√ßamento de testes com a ajuda deles</a></li>
<li><a href="../pt478516/index.html">Estradas processuais em Houdini e Unity</a></li>
<li><a href="../pt478518/index.html">Experi√™ncia na implanta√ß√£o da infraestrutura do escrit√≥rio no Zextras / Zimbra OSE</a></li>
<li><a href="../pt478522/index.html">Admita, Watson, voc√™ est√° completamente perplexo?</a></li>
<li><a href="../pt478526/index.html">Um monte de OpenVPN no Windows Server e Mikrotik com a migra√ß√£o dessas coisas para o Linux</a></li>
<li><a href="../pt478528/index.html">Pet (uma hist√≥ria fant√°stica)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>