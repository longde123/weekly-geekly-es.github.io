<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶‚Äçüë¶ üì´ üë®üèø‚Äç‚öñÔ∏è Comment programmer en toute s√©curit√© dans bash ‚ò¶Ô∏è üë≤üèø üë©üèΩ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi bash? 
 Il y a des tableaux et un mode sans √©chec dans bash. Lorsqu'il est utilis√© correctement, bash est presque compatible avec les pratiqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment programmer en toute s√©curit√© dans bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Pourquoi bash? </h1><br>  Il y a des tableaux et un mode sans √©chec dans bash.  Lorsqu'il est utilis√© correctement, bash est presque compatible avec les pratiques de codage s√ªres. <br><br>  Il est plus difficile de faire une erreur dans le poisson, mais il n'y a pas de mode sans √©chec.  Par cons√©quent, le prototypage chez le poisson et la traduction du poisson en bash devraient √™tre une bonne id√©e si vous savez comment le faire correctement. <br><br><h1>  Pr√©face </h1><br>  Ce guide accompagne ShellHarden, mais l'auteur recommande √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ShellCheck</a> afin que les r√®gles ShellHarden ne s'√©cartent pas de ShellCheck. <br><br>  Bash n'est pas une langue o√π la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mani√®re</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus correcte de r√©soudre un probl√®me en m√™me temps est la plus simple</a> .  Si vous passez l'examen de programmation s√©curis√©e bash, la premi√®re r√®gle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BashPitfalls</a> serait: utilisez toujours des guillemets. <br><br><h1>  La principale chose que vous devez savoir sur la programmation en bash </h1><br>  <b>Guillemets maniaques!</b>  Une variable non cot√©e doit √™tre consid√©r√©e comme une bombe arm√©e: elle explose au contact d'un espace.  Oui, il explose dans le sens de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diviser une cha√Æne en un tableau</a> .  En particulier, les extensions de variables comme <code>$var</code> et les substitutions de commandes comme <code>$(cmd)</code> sont <i>divis√©es en mots</i> lorsque la cha√Æne interne est d√©velopp√©e dans un tableau en raison de la division en une variable <code>$IFS</code> sp√©ciale avec un espace par d√©faut.  Ceci est g√©n√©ralement invisible, car le plus souvent le r√©sultat est un tableau de 1 √©l√©ment, impossible √† distinguer de la cha√Æne attendue. <br><a name="habracut"></a><br>  Non seulement cela est √©tendu, mais aussi les caract√®res g√©n√©riques ( <code>*?</code> ).  Ce processus se produit apr√®s que le mot est divis√©, donc s'il y a au moins un caract√®re g√©n√©rique dans le mot, le mot se transforme en caract√®re g√©n√©rique qui s'applique √† tous les chemins de fichier appropri√©s.  Cette fonctionnalit√© commence donc √† s'appliquer au syst√®me de fichiers! <br><br>  La citation supprime le fractionnement de mots et l'expansion de mod√®le pour les variables et les substitutions de commandes. <br><br>  Extension variable: <br><br><ul><li>  Bon: <code>"$my_var"</code> </li><li>  Mauvais: <code>$my_var</code> </li></ul><br>  Substitution de commande: <br><br><ul><li>  Bon: <code>"$(cmd)"</code> </li><li>  Mauvais: <code>$(cmd)</code> </li></ul><br>  Il y a des exceptions avec des guillemets facultatifs, mais les guillemets ne feront jamais de mal, et la r√®gle g√©n√©rale est de faire attention √† ne pas citer de variables sans guillemets, donc nous ne chercherons pas les exceptions de bordure √† votre avantage.  Cela semble faux et la mauvaise pratique est suffisamment r√©pandue pour √©veiller les soup√ßons: de nombreux scripts ont √©t√© √©crits avec un traitement d√©fectueux des noms de fichiers et des espaces en eux ... <br><br>  ShellHarden ne mentionne que quelques exceptions - ces variables ont-elles un contenu num√©rique tel que <code>$?</code>  , <code>$#</code> et <code>${#array[@]}</code> . <br><br><h3>  Dois-je utiliser des backticks? </h3><br>  Les substitutions de commandes peuvent √©galement prendre la forme suivante: <br><br><ul><li>  Correct: <code>"`cmd`"</code> </li><li>  Mauvais: <code>`cmd`</code> </li></ul><br>  Bien que ce style puisse √™tre utilis√© correctement, il semble moins pratique entre guillemets et moins lisible lorsqu'il est imbriqu√©.  Le consensus ici est assez clair: √©vitez-le. <br><br>  ShellHarden r√©√©crit ces coches entre parenth√®ses en dollars. <br><br><h3>  Faut-il utiliser des accolades boucl√©es? </h3><br>  Les parenth√®ses sont utilis√©es pour interpoler les cha√Ænes, elles sont donc g√©n√©ralement redondantes: <br><br><ul><li>  Mauvais: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pauvre et verbeux: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bon, mais d√©taill√©: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bon: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Th√©oriquement, toujours utiliser des accolades n'est pas un probl√®me, mais selon l'exp√©rience de votre auteur, il existe une forte corr√©lation n√©gative entre l'utilisation inutile des accolades et l'utilisation correcte des guillemets - presque tout le monde choisit la forme ¬´mauvaise et verbeuse¬ª au lieu de la forme ¬´bonne mais verbeuse¬ª! <br><br>  Th√©ories de votre auteur: <br><br><ul><li>  Par crainte de faire quelque chose de mal: au lieu du vrai danger (manque de guillemets), les d√©butants peuvent craindre que la variable <code>$prefix</code> provoque l' <code>"$prefix_postfix"</code> variable <code>"$prefix_postfix"</code> , mais cela ne fonctionne pas de cette fa√ßon. </li><li>  Culte du fret: √©crire du code dans l'alliance de la mauvaise peur qui l'a pr√©c√©d√©. </li><li>  Les crochets rivalisent avec les guillemets pour la limite de verbosit√© autoris√©e. </li></ul><br>  Par cons√©quent, il a √©t√© d√©cid√© d'interdire les accolades inutiles: ShellHarden remplace ces options par la forme la plus simple. <br><br>  Et maintenant sur l'interpolation de cha√Ænes, o√π les accolades sont vraiment utiles: <br><br><ul><li>  Mauvais (concat√©nation): <code>$var1"more string content"$var2</code> </li><li>  Bon (concat√©nation): <code>"$var1""more string content""$var2"</code> </li><li>  Bon (interpolation): <code>"${var1}more string content${var2}"</code> </li></ul><br>  La concat√©nation et l'interpolation en bash sont √©quivalentes m√™me dans les tableaux (ce qui est ridicule). <br><br>  √âtant donn√© que ShellHarden ne met pas en forme les styles, il n'est pas cens√© modifier le code correct.  Cela est vrai pour l'option ¬´bonne (interpolation)¬ª: du point de vue ShellHarden, ce sera la forme canoniquement correcte. <br><br>  ShellHarden ajoute et supprime maintenant des accolades selon les besoins: dans un mauvais exemple, var1 est fourni avec des crochets, mais ils ne sont pas autoris√©s pour var2 m√™me dans le cas de "bon (interpolation)", car ils ne sont jamais n√©cessaires √† la fin de la ligne.  La derni√®re exigence pourrait bien √™tre invers√©e. <br><br><h4>  Gotcha: arguments num√©rot√©s </h4><br>  Contrairement aux noms d' <i>identificateurs de</i> variables normaux (dans l'expression rationnelle: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), les arguments num√©rot√©s n√©cessitent des crochets (l'interpolation de ligne non).  ShellCheck dit: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden refuse de le r√©parer (consid√®re la diff√©rence trop subtile). <br><br>  Comme les parenth√®ses sont autoris√©es jusqu'√† 9, ShellHarden les autorise pour tous les arguments num√©rot√©s. <br><br><h1>  Utilisation de tableaux </h1><br>  Pour pouvoir citer toutes les variables, vous devez utiliser de vrais tableaux, pas des cha√Ænes pseudo-massives s√©par√©es par des espaces. <br><br>  La syntaxe est d√©taill√©e, mais vous devez la g√©rer.  Ce bashisme n'est qu'une des raisons pour abandonner la compatibilit√© POSIX pour la plupart des scripts shell. <br><br>  Bon: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Mauvais: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  C'est pourquoi les tableaux sont une fonction de base pour un shell: les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arguments des commandes sont fondamentalement des tableaux</a> (et les scripts shell sont des commandes et des arguments).  On peut dire que la coque, qui rend artificiellement impossible de passer plusieurs arguments, sera comique et sans valeur.  Certains obus courants de cette cat√©gorie incluent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dash</a> et Busybox Ash.  Ce sont des shells compatibles POSIX minimes - mais √† quoi sert la compatibilit√© si le plus important n'est <i>pas</i> sur POSIX? <br><br><h3>  Cas exceptionnels o√π vous allez vraiment casser une ligne </h3><br>  Exemple avec <code>\v</code> comme s√©parateur de donn√©es (notez la deuxi√®me occurrence): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  De cette fa√ßon, nous √©vitons l'expansion du mod√®le et la m√©thode fonctionne m√™me si le s√©parateur de donn√©es est <code>\n</code> .  La deuxi√®me occurrence du s√©parateur de donn√©es prot√®ge le dernier √©l√©ment s'il s'av√®re √™tre un espace.  Pour une raison quelconque, l'option <code>-d</code> devrait √™tre <code>-rad ''</code> en premier, donc <code>-rad ''</code> options dans <code>-rad ''</code> tentant, mais cela ne fonctionnera pas.  Puisque read renvoie une valeur diff√©rente de z√©ro dans ce cas, elle doit √™tre prot√©g√©e contre errexit ( <code>|| true</code> ), si elle est activ√©e.  Test√© en bash 4.0, 4.1, 4.2, 4.3 et 4.4. <br><br>  Alternative pour bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  O√π d√©marrer un script bash </h1><br>  De quelque chose comme √ßa: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Cela comprend: <br><br><ul><li>  Shebang: <br><ul><li>  Probl√®mes de portabilit√©: le chemin absolu vers <code>env</code> probablement meilleur pour la portabilit√© que le chemin absolu vers <code>bash</code> .  Vous pouvez regarder l'exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NixOS</a> .  POSIX n√©cessite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">env</a> , mais pas bash. </li><li>  Probl√®mes de s√©curit√©: Pour aucune langue, les options telles que <code>-euo pipefail</code> ne seront pas accept√©es favorablement <code>-euo pipefail</code> !  Cela devient impossible lorsque vous utilisez la redirection <code>env</code> , mais m√™me si votre shebang commence par <code>#!/bin/bash</code> , ce n'est pas l'endroit pour les param√®tres qui affectent la valeur du script, car ils peuvent √™tre remplac√©s, ce qui permettra d'ex√©cuter le script de mani√®re incorrecte.  Cependant, en bonus, les options qui n'affectent pas la valeur du script, telles que <code>set -x</code> , si elles sont utilis√©es, peuvent √™tre red√©finies. </li></ul></li><li>  De quoi avons-nous besoin du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode strict non officiel de Bash</a> , avec la v√©rification de la fonction <code>set -u</code> .  Nous n'avons pas besoin de tout le mode Bash strict, car la compatibilit√© shellcheck / shellharden signifie citer tout et tout ce qui est beaucoup plus strict.  De plus, l'option <code>set -u</code> <b>ne doit pas √™tre utilis√©e</b> dans Bash 4.3 et versions ant√©rieures.  √âtant donn√© que cette option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consid√®re les tableaux vides comme ignor√©s</a> dans ces versions, les tableaux ne peuvent pas √™tre utilis√©s aux fins d√©crites ici.  L'utilisation de tableaux est la deuxi√®me astuce la plus importante de ce guide (apr√®s les guillemets) et la seule raison pour laquelle nous sacrifions la compatibilit√© avec POSIX, donc ce n'est en aucun cas inacceptable: soit n'utilisez pas du tout <code>set -u</code> , soit utilisez Bash 4.4 ou un autre shell normal comme Zsh.  C'est plus facile √† dire qu'√† faire, car il est possible que quelqu'un ex√©cute toujours votre script dans l'ancienne version de Bash.  Heureusement, tout ce qui fonctionne avec <code>set -u</code> fonctionnera sans lui (pour <code>set -e</code> vous ne pouvez pas le dire).  C'est pourquoi il est important d'utiliser la v√©rification de version.  M√©fiez-vous de l'hypoth√®se que les tests et le d√©veloppement ont lieu dans un shell compatible avec Bash 4.4 (donc l'aspect <code>set -u</code> est test√©).  Si cela vous d√©range, une autre option consiste √† refuser la compatibilit√© (le script √©choue lorsque la v√©rification de la version √©choue), ou √† refuser <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> oblige <code>for f in *.txt</code> √† fonctionner correctement si <code>*.txt</code> ne trouve pas de fichiers.  Le comportement par d√©faut (aka <i>passglob</i> ) transmet le mod√®le inchang√©, ce qui en cas de r√©sultat nul est dangereux pour plusieurs raisons.  Pour <i>globstar,</i> cela active la recherche r√©cursive.  La substitution est plus facile √† utiliser qu'√† <code>find</code> .  Alors utilisez-le. </li></ul><br>  Mais pas: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  La d√©finition du <i>d√©limiteur de champ interne sur</i> une cha√Æne vide rend impossible le fractionnement du mot.  Cela ressemble √† la solution parfaite.  Malheureusement, il s'agit d'un remplacement incomplet pour les guillemets et les substitutions de commandes, et puisque vous allez utiliser des guillemets, cela ne donne rien.  La raison pour laquelle les guillemets doivent encore √™tre utilis√©s est que, sinon, les cha√Ænes vides deviennent des tableaux vides (comme dans le <code>test $x = ""</code> ) et l'expansion indirecte du mod√®le est toujours possible.  De plus, des probl√®mes avec cette variable entra√Æneront √©galement des probl√®mes avec des commandes comme <code>read</code> , ce qui casse des constructions comme <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  L'extension du mod√®le est d√©sactiv√©e: non seulement l'extension indirecte inf√¢me, mais aussi l'extension directe sans tracas, que, comme je l'ai dit, vous devriez utiliser.  C'est donc difficile √† accepter.  Et cela est √©galement compl√®tement facultatif pour un script compatible shellcheck / shellharden. </li><li>  Contrairement √† <i>nullglob</i> , <i>failglob</i> √©choue avec un r√©sultat nul.  Bien que cela soit logique pour la plupart des commandes, par exemple, <code>rm -- *.txt</code> (car pour la plupart des commandes, il n'est pas pr√©vu de l'ex√©cuter avec un r√©sultat nul), √©videmment <i>failglob</i> ne peut √™tre utilis√© que si vous n'attendez pas un r√©sultat nul.  Cela signifie qu'en g√©n√©ral, vous ne placerez pas de mod√®les de groupe dans les arguments de commande, sauf si vous supposez la m√™me chose.  Mais ce qui peut toujours arriver, c'est d'utiliser <i>nullglob</i> et d'√©tendre le mod√®le √† des arguments null dans des constructions qui peuvent les prendre, comme une boucle ou assigner des valeurs √† un tableau ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Comment terminer un script bash </h1><br>  L'√©tat de sortie du script est l'√©tat de la derni√®re commande ex√©cut√©e.  Assurez-vous qu'il repr√©sente un v√©ritable succ√®s ou un √©chec. <br><br>  Le pire est de laisser la solution √† une condition ind√©pendante sous la forme d'une liste ET √† la fin du script.  Si la condition est fausse, la derni√®re commande ex√©cut√©e sera la condition elle-m√™me. <br><br>  Pour errexit, les conditions sous la forme d'une liste ET ne sont jamais utilis√©es en premier lieu.  Si errexit n'est pas utilis√©, envisagez de g√©rer les erreurs m√™me pour la derni√®re commande, afin que son √©tat de sortie ne soit pas masqu√© si du code suppl√©mentaire est ajout√© au script. <br><br>  Mauvais: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bon (option errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bon (option de gestion des erreurs): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Comment utiliser errexit </h1><br>  Comme <code>set -e</code> . <br><br><h3>  Nettoyage diff√©r√© au niveau du programme </h3><br>  Si errexit fonctionne comme il se doit, utilisez-le pour installer tout nettoyage n√©cessaire √† la sortie. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Pris: errexit est ignor√© dans les arguments de commande </h3><br>  Voici une "bombe" de branchement tr√®s d√©licate, dont la compr√©hension valait beaucoup pour moi.  Mon script de build a bien fonctionn√© sur diff√©rentes machines de d√©veloppement, mais a mis le serveur de build √† genoux: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correct (substitution de commande dans la t√¢che): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Avertissement: <code>local</code> commandes int√©gr√©es <code>local</code> et d' <code>export</code> restent des commandes, donc cela reste faux: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck ne met en garde que contre les commandes sp√©ciales comme <code>local</code> dans ce cas. <br><br>  Pour utiliser <code>local</code> , s√©parez la d√©claration du travail: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Pris: l'errexit est ignor√© selon le contexte de l'appelant </h3><br>  Parfois, POSIX est terrible.  Errexit est ignor√© dans les fonctions, les commandes de groupe et m√™me les sous-coquilles si l'appelant v√©rifie sa r√©ussite.  Tous ces exemples impriment <code>Unreachable</code> <code>Great success</code> <code>Unreachable</code> et <code>Great success</code> , aussi √©trange que cela puisse para√Ætre. <br><br>  Sous-coque: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  √âquipe de groupe: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Fonction: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Pour cette raison, bash avec errexit est pratiquement inappropri√© pour la liaison: oui, <i>il est possible d'</i> envelopper les fonctions errexit pour qu'elles fonctionnent, mais il y a des doutes que l'effort √©conomis√© (sur la gestion explicite des erreurs) en vaut la peine.  Envisagez plut√¥t de vous scinder en scripts enti√®rement autonomes. <br><br><h1>  √âviter d'appeler le shell avec des guillemets incorrects </h1><br>  Lors de l'appel de commandes √† partir d'autres langages de programmation, il est plus facile de faire une erreur et d'appeler implicitement le shell.  Si cette commande shell est statique, c'est bien - √ßa marche ou pas.  Mais si votre programme traite en quelque sorte les lignes pour construire cette commande, alors vous devez comprendre - vous <b>g√©n√©rez un script shell</b> !  J'ai rarement envie de faire √ßa, et c'est tr√®s fatigant de tout arranger correctement: <br><br><ul><li>  citer chaque argument; </li><li>  √©chapper les caract√®res correspondants dans les arguments. </li></ul><br>  Quel que soit le langage de programmation dans lequel vous effectuez cette op√©ration, il existe au moins trois fa√ßons de constituer correctement une √©quipe.  Par ordre de pr√©f√©rence: <br><br><h3>  Plan A: se passer d'une coque </h3><br>  S'il s'agit simplement d'une commande avec des arguments (c'est-√†-dire, aucune fonction shell comme le pipelining ou la redirection), s√©lectionnez une option de tableau. <br><br><ul><li>  Mauvais (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bon (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Mauvais (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bon (C / POSIX), moins la gestion des erreurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plan B: un script shell statique </h3><br>  Si un shell est requis, laissez les arguments √™tre des arguments.  Vous pourriez penser qu'il √©tait fastidieux d'√©crire un script shell sp√©cial dans votre propre fichier et d'y acc√©der jusqu'√† ce que vous voyiez une telle astuce: <br><br>  Mauvais (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bon (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  Pouvez-vous remarquer le script shell? <br><br>  C'est vrai, la commande printf est redirig√©e.  Faites attention aux arguments num√©rot√©s correctement cit√©s.  L'impl√©mentation d'un script shell statique est tr√®s bien. <br><br>  Ces exemples s'ex√©cutent dans Docker car sinon ils ne seront pas aussi utiles, mais Docker est √©galement un excellent exemple de commande qui ex√©cute d'autres commandes bas√©es sur des arguments.  Contrairement √† Ssh, comme nous le verrons plus loin. <br><br><h3>  Derni√®re option: le traitement en ligne </h3><br>  S'il <i>doit</i> s'agir d'une cha√Æne (par exemple, car elle doit fonctionner via <code>ssh</code> ), elle ne peut pas √™tre contourn√©e.  Vous devrez citer chaque argument et √©chapper tous les caract√®res n√©cessaires pour quitter ces guillemets.  Le moyen le plus simple est de passer aux guillemets simples, car ils ont les r√®gles d'√©chappement les plus simples.  Une seule r√®gle: <code>'</code> ‚Üí <code>'\"</code> . <br><br>  Nom de fichier entre guillemets typique: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Comment utiliser cette astuce pour ex√©cuter en toute s√©curit√© les commandes ssh?  C'est impossible!  Eh bien, voici la solution ¬´souvent correcte¬ª: <br><br><ul><li>  La solution "souvent correcte" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Nous devons nous-m√™mes combiner tous les arguments dans une cha√Æne afin que Ssh ne se trompe pas: si vous essayez de passer plusieurs arguments ssh, il commencera √† combiner perfidement les arguments sans guillemets. <br><br>  La raison pour laquelle cela n'est g√©n√©ralement pas possible est que la bonne d√©cision d√©pend des pr√©f√©rences de l'utilisateur √† l'autre extr√©mit√©, √† savoir le shell distant, qui peut √™tre n'importe quoi.  En gros, √ßa pourrait m√™me √™tre ta maman.  Il est ¬´souvent correct¬ª de supposer que le shell distant est bash ou un autre shell compatible POSIX, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poisson est incompatible √† ce stade</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413117/">https://habr.com/ru/post/fr413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413105/index.html">Notes du fournisseur IoT. Activation et s√©curit√© dans LoraWAN</a></li>
<li><a href="../fr413107/index.html">Traduction du wiki du projet Svelto.ECS. Cadre ECS pour Unity3D</a></li>
<li><a href="../fr413109/index.html">Comment cr√©er une plate-forme d'int√©gration de produits SaaS: exp√©rience de v√©rification d'affiches</a></li>
<li><a href="../fr413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../fr413113/index.html">Prise en charge de la s√©rialisation JavaScript de classe JavaScript</a></li>
<li><a href="../fr413119/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 317 (28 mai - 3 juin 2018)</a></li>
<li><a href="../fr413121/index.html">Visite photo du coworking √† Moscou #tceh</a></li>
<li><a href="../fr413123/index.html">JOIN dans les bases de donn√©es NoSQL</a></li>
<li><a href="../fr413125/index.html">La th√©rapie g√©nique donne aux petits patients atteints d'atrophie musculaire une chance de survivre</a></li>
<li><a href="../fr413127/index.html">Quelques mots sur les performances r√©elles de l'hyperviseur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>