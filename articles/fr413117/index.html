<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦‍👦 📫 👨🏿‍⚖️ Comment programmer en toute sécurité dans bash ☦️ 👲🏿 👩🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi bash? 
 Il y a des tableaux et un mode sans échec dans bash. Lorsqu'il est utilisé correctement, bash est presque compatible avec les pratiqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment programmer en toute sécurité dans bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413117/"><h1>  Pourquoi bash? </h1><br>  Il y a des tableaux et un mode sans échec dans bash.  Lorsqu'il est utilisé correctement, bash est presque compatible avec les pratiques de codage sûres. <br><br>  Il est plus difficile de faire une erreur dans le poisson, mais il n'y a pas de mode sans échec.  Par conséquent, le prototypage chez le poisson et la traduction du poisson en bash devraient être une bonne idée si vous savez comment le faire correctement. <br><br><h1>  Préface </h1><br>  Ce guide accompagne ShellHarden, mais l'auteur recommande également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ShellCheck</a> afin que les règles ShellHarden ne s'écartent pas de ShellCheck. <br><br>  Bash n'est pas une langue où la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manière</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus correcte de résoudre un problème en même temps est la plus simple</a> .  Si vous passez l'examen de programmation sécurisée bash, la première règle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BashPitfalls</a> serait: utilisez toujours des guillemets. <br><br><h1>  La principale chose que vous devez savoir sur la programmation en bash </h1><br>  <b>Guillemets maniaques!</b>  Une variable non cotée doit être considérée comme une bombe armée: elle explose au contact d'un espace.  Oui, il explose dans le sens de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diviser une chaîne en un tableau</a> .  En particulier, les extensions de variables comme <code>$var</code> et les substitutions de commandes comme <code>$(cmd)</code> sont <i>divisées en mots</i> lorsque la chaîne interne est développée dans un tableau en raison de la division en une variable <code>$IFS</code> spéciale avec un espace par défaut.  Ceci est généralement invisible, car le plus souvent le résultat est un tableau de 1 élément, impossible à distinguer de la chaîne attendue. <br><a name="habracut"></a><br>  Non seulement cela est étendu, mais aussi les caractères génériques ( <code>*?</code> ).  Ce processus se produit après que le mot est divisé, donc s'il y a au moins un caractère générique dans le mot, le mot se transforme en caractère générique qui s'applique à tous les chemins de fichier appropriés.  Cette fonctionnalité commence donc à s'appliquer au système de fichiers! <br><br>  La citation supprime le fractionnement de mots et l'expansion de modèle pour les variables et les substitutions de commandes. <br><br>  Extension variable: <br><br><ul><li>  Bon: <code>"$my_var"</code> </li><li>  Mauvais: <code>$my_var</code> </li></ul><br>  Substitution de commande: <br><br><ul><li>  Bon: <code>"$(cmd)"</code> </li><li>  Mauvais: <code>$(cmd)</code> </li></ul><br>  Il y a des exceptions avec des guillemets facultatifs, mais les guillemets ne feront jamais de mal, et la règle générale est de faire attention à ne pas citer de variables sans guillemets, donc nous ne chercherons pas les exceptions de bordure à votre avantage.  Cela semble faux et la mauvaise pratique est suffisamment répandue pour éveiller les soupçons: de nombreux scripts ont été écrits avec un traitement défectueux des noms de fichiers et des espaces en eux ... <br><br>  ShellHarden ne mentionne que quelques exceptions - ces variables ont-elles un contenu numérique tel que <code>$?</code>  , <code>$#</code> et <code>${#array[@]}</code> . <br><br><h3>  Dois-je utiliser des backticks? </h3><br>  Les substitutions de commandes peuvent également prendre la forme suivante: <br><br><ul><li>  Correct: <code>"`cmd`"</code> </li><li>  Mauvais: <code>`cmd`</code> </li></ul><br>  Bien que ce style puisse être utilisé correctement, il semble moins pratique entre guillemets et moins lisible lorsqu'il est imbriqué.  Le consensus ici est assez clair: évitez-le. <br><br>  ShellHarden réécrit ces coches entre parenthèses en dollars. <br><br><h3>  Faut-il utiliser des accolades bouclées? </h3><br>  Les parenthèses sont utilisées pour interpoler les chaînes, elles sont donc généralement redondantes: <br><br><ul><li>  Mauvais: <code>some_command $arg1 $arg2 $arg3</code> </li><li>  Pauvre et verbeux: <code>some_command ${arg1} ${arg2} ${arg3}</code> </li><li>  Bon, mais détaillé: <code>some_command "${arg1}" "${arg2}" "${arg3}"</code> </li><li>  Bon: <code>some_command "$arg1" "$arg2" "$arg3"</code> </li></ul><br>  Théoriquement, toujours utiliser des accolades n'est pas un problème, mais selon l'expérience de votre auteur, il existe une forte corrélation négative entre l'utilisation inutile des accolades et l'utilisation correcte des guillemets - presque tout le monde choisit la forme «mauvaise et verbeuse» au lieu de la forme «bonne mais verbeuse»! <br><br>  Théories de votre auteur: <br><br><ul><li>  Par crainte de faire quelque chose de mal: au lieu du vrai danger (manque de guillemets), les débutants peuvent craindre que la variable <code>$prefix</code> provoque l' <code>"$prefix_postfix"</code> variable <code>"$prefix_postfix"</code> , mais cela ne fonctionne pas de cette façon. </li><li>  Culte du fret: écrire du code dans l'alliance de la mauvaise peur qui l'a précédé. </li><li>  Les crochets rivalisent avec les guillemets pour la limite de verbosité autorisée. </li></ul><br>  Par conséquent, il a été décidé d'interdire les accolades inutiles: ShellHarden remplace ces options par la forme la plus simple. <br><br>  Et maintenant sur l'interpolation de chaînes, où les accolades sont vraiment utiles: <br><br><ul><li>  Mauvais (concaténation): <code>$var1"more string content"$var2</code> </li><li>  Bon (concaténation): <code>"$var1""more string content""$var2"</code> </li><li>  Bon (interpolation): <code>"${var1}more string content${var2}"</code> </li></ul><br>  La concaténation et l'interpolation en bash sont équivalentes même dans les tableaux (ce qui est ridicule). <br><br>  Étant donné que ShellHarden ne met pas en forme les styles, il n'est pas censé modifier le code correct.  Cela est vrai pour l'option «bonne (interpolation)»: du point de vue ShellHarden, ce sera la forme canoniquement correcte. <br><br>  ShellHarden ajoute et supprime maintenant des accolades selon les besoins: dans un mauvais exemple, var1 est fourni avec des crochets, mais ils ne sont pas autorisés pour var2 même dans le cas de "bon (interpolation)", car ils ne sont jamais nécessaires à la fin de la ligne.  La dernière exigence pourrait bien être inversée. <br><br><h4>  Gotcha: arguments numérotés </h4><br>  Contrairement aux noms d' <i>identificateurs de</i> variables normaux (dans l'expression rationnelle: <code>[_a-zA-Z][_a-zA-Z0-9]*</code> ), les arguments numérotés nécessitent des crochets (l'interpolation de ligne non).  ShellCheck dit: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$10</span></span></span><span class="hljs-string">"</span></span> ^-- SC1037: Braces are required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> positionals over 9, eg <span class="hljs-variable"><span class="hljs-variable">${10}</span></span>.</code> </pre> <br>  ShellHarden refuse de le réparer (considère la différence trop subtile). <br><br>  Comme les parenthèses sont autorisées jusqu'à 9, ShellHarden les autorise pour tous les arguments numérotés. <br><br><h1>  Utilisation de tableaux </h1><br>  Pour pouvoir citer toutes les variables, vous devez utiliser de vrais tableaux, pas des chaînes pseudo-massives séparées par des espaces. <br><br>  La syntaxe est détaillée, mais vous devez la gérer.  Ce bashisme n'est qu'une des raisons pour abandonner la compatibilité POSIX pour la plupart des scripts shell. <br><br>  Bon: <br><br><pre> <code class="bash hljs">array=( a b ) array+=(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ <span class="hljs-variable"><span class="hljs-variable">${#array[@]}</span></span> -gt 0 ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${array[@]}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Mauvais: <br><br><pre> <code class="bash hljs">pseudoarray=<span class="hljs-string"><span class="hljs-string">" \ a \ b \ "</span></span> pseudoarray=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string"> c"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pseudoarray</span></span></span><span class="hljs-string">"</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> rm -- <span class="hljs-variable"><span class="hljs-variable">$pseudoarray</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  C'est pourquoi les tableaux sont une fonction de base pour un shell: les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arguments des commandes sont fondamentalement des tableaux</a> (et les scripts shell sont des commandes et des arguments).  On peut dire que la coque, qui rend artificiellement impossible de passer plusieurs arguments, sera comique et sans valeur.  Certains obus courants de cette catégorie incluent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dash</a> et Busybox Ash.  Ce sont des shells compatibles POSIX minimes - mais à quoi sert la compatibilité si le plus important n'est <i>pas</i> sur POSIX? <br><br><h3>  Cas exceptionnels où vous allez vraiment casser une ligne </h3><br>  Exemple avec <code>\v</code> comme séparateur de données (notez la deuxième occurrence): <br><br><pre> <code class="bash hljs">IFS=$<span class="hljs-string"><span class="hljs-string">'\v'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -d <span class="hljs-string"><span class="hljs-string">''</span></span> -ra a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>) || <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  De cette façon, nous évitons l'expansion du modèle et la méthode fonctionne même si le séparateur de données est <code>\n</code> .  La deuxième occurrence du séparateur de données protège le dernier élément s'il s'avère être un espace.  Pour une raison quelconque, l'option <code>-d</code> devrait être <code>-rad ''</code> en premier, donc <code>-rad ''</code> options dans <code>-rad ''</code> tentant, mais cela ne fonctionnera pas.  Puisque read renvoie une valeur différente de zéro dans ce cas, elle doit être protégée contre errexit ( <code>|| true</code> ), si elle est activée.  Testé en bash 4.0, 4.1, 4.2, 4.3 et 4.4. <br><br>  Alternative pour bash 4.4: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">readarray</span></span> -td $<span class="hljs-string"><span class="hljs-string">'\v'</span></span> a &lt; &lt;(<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\v'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$s</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br><h1>  Où démarrer un script bash </h1><br>  De quelque chose comme ça: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash if test "$BASH" = "" || "$BASH" -uc "a=();true \"\${a[@]}\"" 2&gt;/dev/null; then # Bash 4.4, Zsh set -euo pipefail else # Bash 4.3 and older chokes on empty arrays with set -u. set -eo pipefail fi shopt -s nullglob globstar</span></span></code> </pre> <br>  Cela comprend: <br><br><ul><li>  Shebang: <br><ul><li>  Problèmes de portabilité: le chemin absolu vers <code>env</code> probablement meilleur pour la portabilité que le chemin absolu vers <code>bash</code> .  Vous pouvez regarder l'exemple de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NixOS</a> .  POSIX nécessite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">env</a> , mais pas bash. </li><li>  Problèmes de sécurité: Pour aucune langue, les options telles que <code>-euo pipefail</code> ne seront pas acceptées favorablement <code>-euo pipefail</code> !  Cela devient impossible lorsque vous utilisez la redirection <code>env</code> , mais même si votre shebang commence par <code>#!/bin/bash</code> , ce n'est pas l'endroit pour les paramètres qui affectent la valeur du script, car ils peuvent être remplacés, ce qui permettra d'exécuter le script de manière incorrecte.  Cependant, en bonus, les options qui n'affectent pas la valeur du script, telles que <code>set -x</code> , si elles sont utilisées, peuvent être redéfinies. </li></ul></li><li>  De quoi avons-nous besoin du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode strict non officiel de Bash</a> , avec la vérification de la fonction <code>set -u</code> .  Nous n'avons pas besoin de tout le mode Bash strict, car la compatibilité shellcheck / shellharden signifie citer tout et tout ce qui est beaucoup plus strict.  De plus, l'option <code>set -u</code> <b>ne doit pas être utilisée</b> dans Bash 4.3 et versions antérieures.  Étant donné que cette option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">considère les tableaux vides comme ignorés</a> dans ces versions, les tableaux ne peuvent pas être utilisés aux fins décrites ici.  L'utilisation de tableaux est la deuxième astuce la plus importante de ce guide (après les guillemets) et la seule raison pour laquelle nous sacrifions la compatibilité avec POSIX, donc ce n'est en aucun cas inacceptable: soit n'utilisez pas du tout <code>set -u</code> , soit utilisez Bash 4.4 ou un autre shell normal comme Zsh.  C'est plus facile à dire qu'à faire, car il est possible que quelqu'un exécute toujours votre script dans l'ancienne version de Bash.  Heureusement, tout ce qui fonctionne avec <code>set -u</code> fonctionnera sans lui (pour <code>set -e</code> vous ne pouvez pas le dire).  C'est pourquoi il est important d'utiliser la vérification de version.  Méfiez-vous de l'hypothèse que les tests et le développement ont lieu dans un shell compatible avec Bash 4.4 (donc l'aspect <code>set -u</code> est testé).  Si cela vous dérange, une autre option consiste à refuser la compatibilité (le script échoue lorsque la vérification de la version échoue), ou à refuser <code>set -u</code> . </li><li>  <code>shopt -s nullglob</code> oblige <code>for f in *.txt</code> à fonctionner correctement si <code>*.txt</code> ne trouve pas de fichiers.  Le comportement par défaut (aka <i>passglob</i> ) transmet le modèle inchangé, ce qui en cas de résultat nul est dangereux pour plusieurs raisons.  Pour <i>globstar,</i> cela active la recherche récursive.  La substitution est plus facile à utiliser qu'à <code>find</code> .  Alors utilisez-le. </li></ul><br>  Mais pas: <br><br><pre> <code class="bash hljs">IFS=<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -f <span class="hljs-built_in"><span class="hljs-built_in">shopt</span></span> -s failglob</code> </pre> <br><ul><li>  La définition du <i>délimiteur de champ interne sur</i> une chaîne vide rend impossible le fractionnement du mot.  Cela ressemble à la solution parfaite.  Malheureusement, il s'agit d'un remplacement incomplet pour les guillemets et les substitutions de commandes, et puisque vous allez utiliser des guillemets, cela ne donne rien.  La raison pour laquelle les guillemets doivent encore être utilisés est que, sinon, les chaînes vides deviennent des tableaux vides (comme dans le <code>test $x = ""</code> ) et l'expansion indirecte du modèle est toujours possible.  De plus, des problèmes avec cette variable entraîneront également des problèmes avec des commandes comme <code>read</code> , ce qui casse des constructions comme <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code>  <code>cat /etc/fstab | while read -r dev mnt fs opt dump pass; do echo "$fs"; done'</code> . </li><li>  L'extension du modèle est désactivée: non seulement l'extension indirecte infâme, mais aussi l'extension directe sans tracas, que, comme je l'ai dit, vous devriez utiliser.  C'est donc difficile à accepter.  Et cela est également complètement facultatif pour un script compatible shellcheck / shellharden. </li><li>  Contrairement à <i>nullglob</i> , <i>failglob</i> échoue avec un résultat nul.  Bien que cela soit logique pour la plupart des commandes, par exemple, <code>rm -- *.txt</code> (car pour la plupart des commandes, il n'est pas prévu de l'exécuter avec un résultat nul), évidemment <i>failglob</i> ne peut être utilisé que si vous n'attendez pas un résultat nul.  Cela signifie qu'en général, vous ne placerez pas de modèles de groupe dans les arguments de commande, sauf si vous supposez la même chose.  Mais ce qui peut toujours arriver, c'est d'utiliser <i>nullglob</i> et d'étendre le modèle à des arguments null dans des constructions qui peuvent les prendre, comme une boucle ou assigner des valeurs à un tableau ( <code>txt_files=(*.txt)</code> ). </li></ul><br><h1>  Comment terminer un script bash </h1><br>  L'état de sortie du script est l'état de la dernière commande exécutée.  Assurez-vous qu'il représente un véritable succès ou un échec. <br><br>  Le pire est de laisser la solution à une condition indépendante sous la forme d'une liste ET à la fin du script.  Si la condition est fausse, la dernière commande exécutée sera la condition elle-même. <br><br>  Pour errexit, les conditions sous la forme d'une liste ET ne sont jamais utilisées en premier lieu.  Si errexit n'est pas utilisé, envisagez de gérer les erreurs même pour la dernière commande, afin que son état de sortie ne soit pas masqué si du code supplémentaire est ajouté au script. <br><br>  Mauvais: <br><br><pre> <code class="bash hljs">condition &amp;&amp; extra_stuff</code> </pre> <br>  Bon (option errexit): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Bon (option de gestion des erreurs): <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> extra_stuff || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre> <br><h1>  Comment utiliser errexit </h1><br>  Comme <code>set -e</code> . <br><br><h3>  Nettoyage différé au niveau du programme </h3><br>  Si errexit fonctionne comme il se doit, utilisez-le pour installer tout nettoyage nécessaire à la sortie. <br><br><pre> <code class="bash hljs">tmpfile=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(mktemp -t myprogram-XXXXXX)</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span></span>() { rm -f <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tmpfile</span></span></span><span class="hljs-string">"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> cleanup EXIT</code> </pre> <br><h3>  Pris: errexit est ignoré dans les arguments de commande </h3><br>  Voici une "bombe" de branchement très délicate, dont la compréhension valait beaucoup pour moi.  Mon script de build a bien fonctionné sur différentes machines de développement, mais a mis le serveur de build à genoux: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed make -j"$(nproc)"</span></span></code> </pre> <br>  Correct (substitution de commande dans la tâche): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  Avertissement: <code>local</code> commandes intégrées <code>local</code> et d' <code>export</code> restent des commandes, donc cela reste faux: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br>  ShellCheck ne met en garde que contre les commandes spéciales comme <code>local</code> dans ce cas. <br><br>  Pour utiliser <code>local</code> , séparez la déclaration du travail: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-comment"><span class="hljs-comment"># Fail if nproc is not installed local jobs jobs="$(nproc)" make -j"$jobs"</span></span></code> </pre> <br><h3>  Pris: l'errexit est ignoré selon le contexte de l'appelant </h3><br>  Parfois, POSIX est terrible.  Errexit est ignoré dans les fonctions, les commandes de groupe et même les sous-coquilles si l'appelant vérifie sa réussite.  Tous ces exemples impriment <code>Unreachable</code> <code>Great success</code> <code>Unreachable</code> et <code>Great success</code> , aussi étrange que cela puisse paraître. <br><br>  Sous-coque: <br><br><pre> <code class="bash hljs">( <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable ) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Équipe de groupe: <br><br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Fonction: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> -e <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Unreachable } f &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Great success</code> </pre> <br>  Pour cette raison, bash avec errexit est pratiquement inapproprié pour la liaison: oui, <i>il est possible d'</i> envelopper les fonctions errexit pour qu'elles fonctionnent, mais il y a des doutes que l'effort économisé (sur la gestion explicite des erreurs) en vaut la peine.  Envisagez plutôt de vous scinder en scripts entièrement autonomes. <br><br><h1>  Éviter d'appeler le shell avec des guillemets incorrects </h1><br>  Lors de l'appel de commandes à partir d'autres langages de programmation, il est plus facile de faire une erreur et d'appeler implicitement le shell.  Si cette commande shell est statique, c'est bien - ça marche ou pas.  Mais si votre programme traite en quelque sorte les lignes pour construire cette commande, alors vous devez comprendre - vous <b>générez un script shell</b> !  J'ai rarement envie de faire ça, et c'est très fatigant de tout arranger correctement: <br><br><ul><li>  citer chaque argument; </li><li>  échapper les caractères correspondants dans les arguments. </li></ul><br>  Quel que soit le langage de programmation dans lequel vous effectuez cette opération, il existe au moins trois façons de constituer correctement une équipe.  Par ordre de préférence: <br><br><h3>  Plan A: se passer d'une coque </h3><br>  S'il s'agit simplement d'une commande avec des arguments (c'est-à-dire, aucune fonction shell comme le pipelining ou la redirection), sélectionnez une option de tableau. <br><br><ul><li>  Mauvais (python3): <code>subprocess.check_call('rm -rf ' + path)</code> </li><li>  Bon (python3): <code>subprocess.check_call(['rm', '-rf', path])</code> </li></ul><br>  Mauvais (C ++): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> cmd = <span class="hljs-string"><span class="hljs-string">"rm -rf "</span></span>; cmd += path; system(cmd);</code> </pre> <br>  Bon (C / POSIX), moins la gestion des erreurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args[] = {<span class="hljs-string"><span class="hljs-string">"rm"</span></span>, <span class="hljs-string"><span class="hljs-string">"-rf"</span></span>, path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">pid_t</span></span> child; posix_spawnp(&amp;child, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, args, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; waitpid(child, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Plan B: un script shell statique </h3><br>  Si un shell est requis, laissez les arguments être des arguments.  Vous pourriez penser qu'il était fastidieux d'écrire un script shell spécial dans votre propre fichier et d'y accéder jusqu'à ce que vous voyiez une telle astuce: <br><br>  Mauvais (python3): <code>subprocess.check_call('docker exec {} bash -ec "printf %s {} &gt; {}"'.format(instance, content, path))</code> <br>  Bon (python3): <code>subprocess.check_call(['docker', 'exec', instance, 'bash', '-ec', 'printf %s "$0" &gt; "$1"', content, path])</code> <br><br>  Pouvez-vous remarquer le script shell? <br><br>  C'est vrai, la commande printf est redirigée.  Faites attention aux arguments numérotés correctement cités.  L'implémentation d'un script shell statique est très bien. <br><br>  Ces exemples s'exécutent dans Docker car sinon ils ne seront pas aussi utiles, mais Docker est également un excellent exemple de commande qui exécute d'autres commandes basées sur des arguments.  Contrairement à Ssh, comme nous le verrons plus loin. <br><br><h3>  Dernière option: le traitement en ligne </h3><br>  S'il <i>doit</i> s'agir d'une chaîne (par exemple, car elle doit fonctionner via <code>ssh</code> ), elle ne peut pas être contournée.  Vous devrez citer chaque argument et échapper tous les caractères nécessaires pour quitter ces guillemets.  Le moyen le plus simple est de passer aux guillemets simples, car ils ont les règles d'échappement les plus simples.  Une seule règle: <code>'</code> → <code>'\"</code> . <br><br>  Nom de fichier entre guillemets typique: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Don'</span></span>\<span class="hljs-string"><span class="hljs-string">''</span></span>t stop (12<span class="hljs-string"><span class="hljs-string">" dub mix).mp3'</span></span></code> </pre> <br>  Comment utiliser cette astuce pour exécuter en toute sécurité les commandes ssh?  C'est impossible!  Eh bien, voici la solution «souvent correcte»: <br><br><ul><li>  La solution "souvent correcte" (python3): <code>subprocess.check_call(['ssh', 'user@host', "sha1sum '{}'".format(path.replace("'", "'\\''"))])</code> </li></ul><br>  Nous devons nous-mêmes combiner tous les arguments dans une chaîne afin que Ssh ne se trompe pas: si vous essayez de passer plusieurs arguments ssh, il commencera à combiner perfidement les arguments sans guillemets. <br><br>  La raison pour laquelle cela n'est généralement pas possible est que la bonne décision dépend des préférences de l'utilisateur à l'autre extrémité, à savoir le shell distant, qui peut être n'importe quoi.  En gros, ça pourrait même être ta maman.  Il est «souvent correct» de supposer que le shell distant est bash ou un autre shell compatible POSIX, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poisson est incompatible à ce stade</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413117/">https://habr.com/ru/post/fr413117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413105/index.html">Notes du fournisseur IoT. Activation et sécurité dans LoraWAN</a></li>
<li><a href="../fr413107/index.html">Traduction du wiki du projet Svelto.ECS. Cadre ECS pour Unity3D</a></li>
<li><a href="../fr413109/index.html">Comment créer une plate-forme d'intégration de produits SaaS: expérience de vérification d'affiches</a></li>
<li><a href="../fr413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../fr413113/index.html">Prise en charge de la sérialisation JavaScript de classe JavaScript</a></li>
<li><a href="../fr413119/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 317 (28 mai - 3 juin 2018)</a></li>
<li><a href="../fr413121/index.html">Visite photo du coworking à Moscou #tceh</a></li>
<li><a href="../fr413123/index.html">JOIN dans les bases de données NoSQL</a></li>
<li><a href="../fr413125/index.html">La thérapie génique donne aux petits patients atteints d'atrophie musculaire une chance de survivre</a></li>
<li><a href="../fr413127/index.html">Quelques mots sur les performances réelles de l'hyperviseur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>