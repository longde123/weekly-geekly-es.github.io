<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº ü•ì ‚è≤Ô∏è Nous rendons le processus de d√©veloppement de logiciels lourds pour microcontr√¥leurs plus pratique (non) üõ∑ üíá üî∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√©sormais, personne ne peut √™tre surpris par les microcontr√¥leurs avec une m√©moire non volatile (le plus souvent Flash) de 512 kilo-octets ou plus. Le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous rendons le processus de d√©veloppement de logiciels lourds pour microcontr√¥leurs plus pratique (non)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437848/"> D√©sormais, personne ne peut √™tre surpris par les microcontr√¥leurs avec une m√©moire non volatile (le plus souvent Flash) de 512 kilo-octets ou plus.  Leur co√ªt diminue progressivement et l'accessibilit√©, au contraire, augmente.  La pr√©sence d'un tel volume de m√©moire non volatile permet d'√©crire des applications ¬´lourdes¬ª en termes de m√©moire occup√©e, tout en facilitant la maintenance ult√©rieure du code gr√¢ce √† l'utilisation de solutions toutes faites de diff√©rentes biblioth√®ques standard.  Cependant, cela conduit √† une augmentation du volume du fichier firmware de l'appareil cible, qui doit √† chaque fois √™tre compl√®tement recharg√© dans la m√©moire non volatile du microcontr√¥leur au moindre changement de code. <br><br>  Le but de l'article est de parler de la m√©thode de construction d'un projet en C et / ou C ++, dans laquelle, en cas de modification de la section de code, qui est d√©bogu√©e le plus souvent, la majeure partie du projet n'avait pas besoin d'√™tre r√©√©crite.  Et montrez √©galement pourquoi cette m√©thode n'est pas toujours une solution efficace. <br><a name="habracut"></a><br><h2>  Exigences du lecteur </h2><br>  Au cours du r√©cit, je suppose que le lecteur: <br><br><ul><li>  Il parle couramment le C et le C ++; </li><li>  poss√®de une exp√©rience de travail avec des microcontr√¥leurs bas√©s sur des c≈ìurs Cortex-M3 / Cortex-M4 (par exemple, la s√©rie stm32f4); </li><li>  sait comment construire le fichier de couture final (elf / bin) √† partir des sources du projet; </li><li>  Imagine √† quoi servent les fichiers de script de l'√©diteur de liens; </li><li>  a une id√©e du texte, des bss, des donn√©es et d'autres sections; </li><li>  travaill√© avec l'une des distributions Linux; </li><li>  poss√®de au minimum bash; </li><li>  a de l'exp√©rience avec gcc pour l'architecture des processeurs Cortex-M3 / Cortex-M4 (toolchain arm-none-eabi); </li><li>  a des comp√©tences initiales avec cmake. </li></ul><br><h2>  L'essence de la m√©thode </h2><br>  Dans un projet ¬´classique¬ª pour les microcontr√¥leurs, toutes les donn√©es immuables (texte, sections rodata, valeurs de donn√©es initiales et autres) sont g√©n√©ralement situ√©es ¬´en ligne¬ª, √† partir de l'adresse de d√©but de la m√©moire non volatile (dans le cas d'un microcontr√¥leur bas√© sur le noyau Cortex-M3 / Cortex-M4 - c Adresse 0x08000000).  Sous une forme simplifi√©e, la carte d'utilisation de la m√©moire non volatile d'un programme de microcontr√¥leur bas√© sur le noyau Cortex-M3 / Cortex-M4, √©crite en C ++, ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/hl/dw/jx/hldwjx8d-f6k7ogodnjthokeefc.png"><br><br>  Le fichier mem.ld d'un tel projet ressemble le plus souvent √† ceci: <br><br><pre><code class="bash hljs">MEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 768K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 112K }</code> </pre> <br>  Ici, toute la m√©moire non volatile est une seule partition nomm√©e "FLASH", et toute la RAM est une partition nomm√©e "RAM".  Sous cette forme, lorsque l'une des sections de code change, tout le reste commence √† ¬´d√©caler¬ª.  Pour √©viter cela, vous pouvez ¬´diviser¬ª le fichier du firmware en certains blocs logiques.  Par exemple, comme suit: <br><br><ul><li>  tableau des vecteurs d'interruption; </li><li>  propres biblioth√®ques; </li><li>  biblioth√®ques tierces (qui ne devraient pas √™tre modifi√©es); </li><li>  code fr√©quemment modifiable. </li></ul><br>  Dans ce cas, lors de la modification d'une section de code, dans le fichier bin final, seule la section dans laquelle le code a chang√© et la section qui y √©tait en quelque sorte connect√©e seront modifi√©es (par exemple, la table des vecteurs d'interruption si la position du gestionnaire dans certains des sections). <br><br>  Essentiellement, <b>des biblioth√®ques statiques</b> sont ajout√©es au projet. <br><br>  Apr√®s avoir re√ßu le bac du fichier de projet, il peut √™tre divis√© en sections et flasher chaque section ind√©pendamment.  Ainsi, seules les zones modifi√©es seront cousues.  Cela entra√Æne √©galement le manque de micrologiciel avant le d√©bogage, car il est suppos√© que le microcontr√¥leur aura imm√©diatement le dernier micrologiciel dans le microcontr√¥leur et vous pouvez imm√©diatement commencer le d√©bogage. <br><br>  Ensuite, je vais d√©crire en d√©tail comment impl√©menter cela sur un vrai projet.  Les avantages et les inconv√©nients d'une telle d√©cision seront donn√©s √† la fin de l'article. <br><br><h2>  Champ d'exp√©rimentation </h2><br>  Avant de sugg√©rer toute sorte d'innovation au travail, j'essaie ceci sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet domestique</a> .  √âtant donn√© que sa taille est proche de celle des projets de routine au travail, il est possible de comprendre si l'innovation est viable ou non et quelles nuances elle comporte. <br><br><h2>  Description du projet </h2><br>  Le projet contient: <br><br><ul><li>  le code du projet principal en C ++ 14 utilisant des tables virtuelles, new / delete (en utilisant un tas de FreeRTOS), shared_ptr (et d'autres pointeurs intelligents) et d'autres d√©lices des biblioth√®ques C ++ 14 standard; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FreeRTOS</a> utilisant environ 6 t√¢ches pour maintenir l'infrastructure mat√©rielle p√©riph√©rique et environ 10 sur la logique m√©tier ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que</a> graphique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MakiseGUI</a> , traitement des clics, travail avec fat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FatFS</a> ), etc.); </li><li>  16 r√©f√©rentiels avec leurs propres biblioth√®ques pour interagir avec les p√©riph√©riques mat√©riels de la carte, les talons pour les appels syst√®me, etc. </li></ul><br>  Avec les param√®tres d'assemblage -O0 -g3, le code dans une impl√©mentation compl√®te avec prise en charge de l'unicode, du cyrillique et d'autres choses prend environ 700 Ko.  Cependant, au stade actuel, lorsque les p√©riph√©riques mat√©riels sont stables et que seule la logique m√©tier doit √™tre d√©bogu√©e, la quantit√© de code √† modifier est d'environ 20 Ko.  Pour cette raison, √† premi√®re vue, il semble que l'approche actuelle soit une solution id√©ale au probl√®me (l'option avec simulation sur ordinateur n'est pas envisag√©e pour une raison quelconque). <br><br><h2>  Liste d'actions </h2><br>  Pour impl√©menter la m√©thode d√©crite, vous aurez besoin de: <br><br><ul><li>  assembler tous les sous-modules en tant que biblioth√®ques statiques (la description de cet √©l√©ment n'est pas incluse dans la liste des √©l√©ments analys√©s de cet article); </li><li>  r√©√©crire mem.ld; </li><li>  r√©√©crire section.ld; </li><li>  ajouter un utilitaire au projet principal pour extraire des sections du fichier bin final; </li><li>  ajouter au projet un appel au script pour mettre √† jour la m√©moire non volatile du microcontr√¥leur lors de la mise √† jour du fichier firmware. </li></ul><br><h2>  R√©√©criture mem.ld </h2><br>  La premi√®re √©tape consiste √† affiner la m√©moire ¬´standard¬ª du concept actuel.  Lors de la finalisation, il convient de garder √† l'esprit que la m√©moire non volatile est nettoy√©e par secteurs.  Pour en savoir plus sur la structure des secteurs dans un microcontr√¥leur particulier, lisez la documentation (dans le cas des microcontr√¥leurs stm32 - dans le manuel de r√©f√©rence).  Chaque section peut occuper au moins un secteur (d'autres peuvent l'√™tre), sinon une section en √©crasera une autre. <br><br>  Il convient √©galement de garder √† l'esprit que si une biblioth√®que utilise des variables globales, pour cette biblioth√®que, vous devez r√©server une place dans la RAM au stade de la liaison.  Sinon, vous pourriez rencontrer des bogues d√©sagr√©ables qui seront extr√™mement difficiles √† attraper.  Par exemple, le code de la biblioth√®que FatFS sera dans la section ROM_EXTERNAL_LIBRARIES, mais il n√©cessite 4 octets de RAM au stade de la construction.  Vous devez donc vous assurer qu'il existe une section dans la RAM pour les champs que le code de ROM_EXTERNAL_LIBRARIES utilisera.  Dans cet exemple, il s'agit de RAM_EXTERNAL_LIBRARIES. <br><br>  La derni√®re section de la m√©moire non volatile m√©rite une attention particuli√®re.  Tout ce qui n'a pas √©t√© d√©compos√© dans les sections correspondantes plus t√¥t, selon section.ld (√† ce sujet plus tard), y entrera. <br><br><div class="spoiler">  <b class="spoiler_title">Dans le contexte du projet en cours, mem.ld ressemblera √† ceci.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*    stm32f405rgt6   ChiptunePlayer-2.22-MainBoard-v2-Firmware. */ MEMORY { /*-----------------------------FLASH-------------------------------*/ /*  0-1  . */ ROM_BOOTLOADER (RX) : ORIGIN = 0x08000000, LENGTH = 32K /*  2     . */ ROM_SYSCFG_PAGE_1 (R) : ORIGIN = 0x08008000, LENGTH = 16K /*  3      . */ ROM_SYSCFG_PAGE_2 (R) : ORIGIN = 0x0800C000, LENGTH = 16K /*  4 . */ ROM_RESERVE (R) : ORIGIN = 0x08010000, LENGTH = 16K /*  5, 6, 7      (FATFS, FREERTOS...). */ ROM_EXTERNAL_LIBRARIES (RX) : ORIGIN = 0x08020000, LENGTH = 384K /*  8, 9      ( ,  ...). */ ROM_USER_LIBRARIES (RX) : ORIGIN = 0x08080000, LENGTH = 384K /*  5, 6      . */ ROM_MAIN_PROGRAMM (RX) : ORIGIN = 0x080E0000, LENGTH = 128K /*-----------------------------RAM---------------------------------*/ /*      RAM    . */ RAM_PAGE_1 (RW) : ORIGIN = 0x20000000, LENGTH = 112K RAM_PAGE_2 (RW) : ORIGIN = 0x2001C000, LENGTH = 16K /*           FATFS  FreeRTOS. */ RAM_EXTERNAL_LIBRARIES (RW) : ORIGIN = 0x20000000, LENGTH = 10K /*        . */ RAM_USER_LIBRARIES (RW) : ORIGIN = 0x20002800, LENGTH = 90K /*    RAM    . */ RAM_MAIN_PROGRAMM (RW) : ORIGIN = 0x20019000, LENGTH = 27K /*   RAM    .    FreeRTOS. */ RAM_MAIN_PROGRAMM_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> </div></div><br><h2>  R√©√©crire section.ld </h2><br>  Une fois que la carte m√©moire existante a √©t√© divis√©e en sections, il convient de d√©crire la partition qui sera plac√©e.  Pour chaque biblioth√®que (s'il existe une section correspondante dans la biblioth√®que), indiquez o√π se trouvent les sections .text, .rodata, .data, .bss et autres.  La liste des sections disponibles dans la biblioth√®que peut √™tre consult√©e √† l'aide de objdump.  Par exemple, pour la biblioth√®que libstdc ++ _ nano.a, vous devez sp√©cifier o√π placer le texte, ARM.attributes, rodata, data, bss, COMMON sections. <br><br><div class="spoiler">  <b class="spoiler_title">Dans le contexte du projet en cours, section.ld ressemblera √† ceci.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*             RAM. */ __estack = ORIGIN(RAM_MAIN_PROGRAMM_STACK) + LENGTH(RAM_MAIN_PROGRAMM_STACK); /*   . */ __stack_size = LENGTH(RAM_MAIN_PROGRAMM_STACK); /*     Reset_Handler. */ ENTRY(Reset_Handler) /*  . */ SECTIONS { /*---------------------ROM  ------------------------*/ .section_bootloader : ALIGN(4) { /*     .             .          .o ,     .*/ . = ALIGN(4); KEEP(*(.user_code_isr_vector .user_code_isr_vector*)) . = ALIGN(4); } &gt;ROM_BOOTLOADER /*----------------ROM    -----------------*/ /* . */ .section_external_libraries_text : ALIGN(4) { /*  . */ . = ALIGN(4); *libstdc++_nano.a:*(.text .text*); . = ALIGN(4); *libgcc.a:*(.text .text*); . = ALIGN(4); *libg_nano.a:*(.text .text*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.text .text*); . = ALIGN(4); *libFATFS.a:*(.text .text*); . = ALIGN(4); *libFREERTOS.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /* ,   */ .section_external_libraries_required_by_the_compiler : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libstdc++_nano.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libg_nano.a:*(.ARM.attributes .ARM.attributes*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFATFS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFREERTOS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_external_libraries_rodata : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.rodata .rodata*); . = ALIGN(4); *libstdc++_nano.a:*(.rodata .rodata*); . = ALIGN(4); *libg_nano.a:*(.rodata .rodata*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.rodata .rodata*); . = ALIGN(4); *libFATFS.a:*(.rodata .rodata*); . = ALIGN(4); *libFREERTOS.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*----------------------- ---------------------*/ /* . */ .section_user_libraries_text : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.text .text*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.text .text*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libUSER_STARTUP.a:*(.text .text*); . = ALIGN(4); *libBUTTONS.a:*(.text .text*); . = ALIGN(4); *libCHIPTUNE.a:*(.text .text*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.text .text*); . = ALIGN(4); *libLCD_DRIVER.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.text .text*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.text .text*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.text .text*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.text .text*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /* ,   */ .section_user_libraries_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_STARTUP.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_CODE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libBUTTONS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libCHIPTUNE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libLCD_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_rodata : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_STARTUP.a:*(.rodata .rodata*); . = ALIGN(4); *libBUTTONS.a:*(.rodata .rodata*); . = ALIGN(4); *libCHIPTUNE.a:*(.rodata .rodata*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.rodata .rodata*); . = ALIGN(4); *libLCD_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.rodata .rodata*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.rodata .rodata*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.rodata .rodata*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /*------------------------- ------------------------*/ /* . */ .section_user_code_text : ALIGN(4) { . = ALIGN(4); *(.text .text.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /* ,   */ .sections_user_code_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *(.glue_7 .glue_7*) /*  -  ARMv7 */ . = ALIGN(4); *(.glue_7t .glue_7t*) . = ALIGN(4); *(.vfp11_veneer .vfp11_veneer*) /*   . */ . = ALIGN(4); *(.v4_bx .v4_bx*) . = ALIGN(4); *(.iplt .iplt*) . = ALIGN(4); *(.rel.dyn .rel.dyn*) . = ALIGN(4); KEEP(*(.eh_frame .eh_frame*)) /*     CPP. */ . = ALIGN(4); *(.eh_framehdr .eh_framehdr*) . = ALIGN(4); *(.ARM.attributes .ARM.attributes.*) /*    ,  . */ . = ALIGN(4); *(vtable) /* C++ virtual tables */ PROVIDE_HIDDEN (__preinit_array_start = .); /*  ,   . */ . = ALIGN(4); KEEP(*(.preinit_array_sysinit .preinit_array_sysinit*)) . = ALIGN(4); KEEP(*(.preinit_array_platform .preinit_array_platform.*)) . = ALIGN(4); KEEP(*(.preinit_array .preinit_array.*)) PROVIDE_HIDDEN (__preinit_array_end = .); PROVIDE_HIDDEN (__init_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.init_array.*))) . = ALIGN(4); KEEP(*(.init_array)) . = ALIGN(4); PROVIDE_HIDDEN (__init_array_end = .); PROVIDE_HIDDEN (__fini_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.fini_array.*))) . = ALIGN(4); KEEP(*(.fini_array)) . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); KEEP(*(.cfmconfig)) . = ALIGN(4); *(.after_vectors .after_vectors.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*    . */ .section_user_code_rodata : ALIGN(4) { . = ALIGN(4); *(.rodata .rodata.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*  stack trace. */ .ARM.exidx : { . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); *(.ARM.exidx* .gnu.linkonce.armexidx.*) . = ALIGN(4); } &gt; ROM_MAIN_PROGRAMM /*-------------------------------RAM-----------------------------*/ /*    . */ .section_external_libraries_data : ALIGN(4) { . = ALIGN(4); __external_lib_data_start = . ; /*  . */ . = ALIGN(4); *libgcc.a:*(.data .data*); . = ALIGN(4); *libstdc++_nano.a:*(.data .data*); . = ALIGN(4); *libg_nano.a:*(.data .data*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.data .data*); . = ALIGN(4); *libFATFS.a:*(.data .data*); . = ALIGN(4); *libFREERTOS.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI.a:*(.data .data*); . = ALIGN(4); __external_lib_data_end = . ; } &gt;RAM_EXTERNAL_LIBRARIES AT&gt; ROM_EXTERNAL_LIBRARIES /*       RAM */ .section_external_libraries_bss : ALIGN(4) { . = ALIGN(4); __external_lib_bss_start = .; /*  . */ . = ALIGN(4); *libgcc.a:*(.bss .bss*); . = ALIGN(4); *libstdc++_nano.a:*(.bss .bss*); . = ALIGN(4); *libg_nano.a:*(*COMMON); . = ALIGN(4); *libgcc.a:*(*COMMON); . = ALIGN(4); *libstdc++_nano.a:*(*COMMON); . = ALIGN(4); *libg_nano.a:*(*COMMON); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.bss .bss*); . = ALIGN(4); *libFATFS.a:*(.bss .bss*); . = ALIGN(4); *libFREERTOS.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI.a:*(.bss .bss*); . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(*COMMON); . = ALIGN(4); *libFATFS.a:*(*COMMON); . = ALIGN(4); *libFREERTOS.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI.a:*(*COMMON); . = ALIGN(4); __external_lib_bss_end = .; } &gt;RAM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_data : ALIGN(4) { . = ALIGN(4); __user_lib_data_start = . ; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.data .data*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.data .data*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libUSER_STARTUP.a:*(.data .data*); . = ALIGN(4); *libBUTTONS.a:*(.data .data*); . = ALIGN(4); *libCHIPTUNE.a:*(.data .data*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.data .data*); . = ALIGN(4); *libLCD_DRIVER.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.data .data*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.data .data*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.data .data*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.data .data*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.data .data*); . = ALIGN(4); __user_lib_data_end = . ; } &gt;RAM_USER_LIBRARIES AT&gt; ROM_USER_LIBRARIES .section_user_libraries_bss : ALIGN(4) { . = ALIGN(4); __user_lib_bss_start = .; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libUSER_CODE.a:*(.bss .bss*); . = ALIGN(4); *libBUTTONS.a:*(.bss .bss*); . = ALIGN(4); *libCHIPTUNE.a:*(.bss .bss*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.bss .bss*); . = ALIGN(4); *libLCD_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.bss .bss*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.bss .bss*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.bss .bss*); . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(*COMMON); . = ALIGN(4); *libMC_INTERRUPT.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libPCB_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libUSER_CODE.a:*(*COMMON); . = ALIGN(4); *libBUTTONS.a:*(*COMMON); . = ALIGN(4); *libCHIPTUNE.a:*(*COMMON); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(*COMMON); . = ALIGN(4); *libLCD_DRIVER.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(*COMMON); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(*COMMON); . = ALIGN(4); *libSHIFT_REGISTER.a:*(*COMMON); . = ALIGN(4); *libWAVE_GENERATORS.a:*(*COMMON); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.COMMON*); . = ALIGN(4); __user_lib_bss_end = .; } &gt;RAM_USER_LIBRARIES /*    . */ .section_user_code_data : ALIGN(4) { . = ALIGN(4); __user_code_data_start = . ; . = ALIGN(4); *(.data .data.*) . = ALIGN(4); __user_code_data_end = . ; } &gt;RAM_MAIN_PROGRAMM AT&gt; ROM_MAIN_PROGRAMM .section_user_code_bss : ALIGN(4) { . = ALIGN(4); __bss_start__ = .; __user_code_bss_start = .; *(.bss .bss.*) *(COMMON) . = ALIGN(4); __bss_end__ = .; __user_code_bss_end = .; } &gt;RAM_MAIN_PROGRAMM __external_lib_data_in_rom_start = LOADADDR(.section_external_libraries_data); __user_lib_data_in_rom_start = LOADADDR(.section_user_libraries_data); __user_code_data_in_rom_start = LOADADDR(.section_user_code_data); /*------------------------- -----------------*/ /* Stabs debugging sections. */ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) } /* * DWARF debug sections. * Symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : { *(.debug) } .line 0 : { *(.line) } /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } /* DWARF 2 */ .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) } .debug_macro 0 : { *(.debug_macro) } .debug_ranges 0 : { *(.debug_ranges) } }</code> </pre> </div></div><br><h2>  Ajouter un utilitaire au projet principal pour extraire des sections du fichier bin final </h2><br>  Malheureusement, il n'a pas √©t√© possible de trouver des indicateurs dans objcopy ou objdump pour extraire le code entre des adresses sp√©cifiques du fichier elf.  Il existe un indicateur <b>--only-section</b> , cependant, il ne prend pas en compte le fait qu'apr√®s toutes les entit√©s de la section r√©pertori√©es dans section.ld, les informations de d√©bogage sont toujours plac√©es dans la m√©moire non volatile.  Sans cela, le firmware final, assembl√© √† partir de morceaux, ne fonctionnera pas (pour des raisons √©videntes).  Par cons√©quent, j'ai d√ª √©crire un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilitaire</a> simple qui prend un fichier bin commun et extrait la section requise dans un fichier s√©par√© pour la plage d'adresses sp√©cifi√©e.  Cependant, la nuance suivante appara√Æt ici.  Par d√©faut, objcopy remplit l'espace entre les sections avec 0s.  Cependant, l'espace vide dans la m√©moire flash est 0xFF.  Pour r√©soudre ce probl√®me, vous devez composer le fichier bin de sortie avec l'indicateur <b>--gap-fill = 0xff</b> . <br><br><h2>  Ajouter au projet un appel au script pour mettre √† jour la m√©moire non volatile du microcontr√¥leur lors de la mise √† jour du fichier firmware </h2><br>  Pour suivre les modifications dans le projet, apr√®s chaque reconstruction du fichier elf, vous devez appeler un script de validation qui extraira le fichier bin final du fichier elf, en comparera la section souhait√©e, le comparera avec le fichier pr√©c√©demment extrait et, s'il y a des diff√©rences, mettez √† jour la section dans la m√©moire du microcontr√¥leur. <br><br><div class="spoiler">  <b class="spoiler_title">Code de script de comparaison</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # $1 -  .   ,    . # $2 -     elf . # $3 -      STM32. # echo "Old file name: $1" echo "New file name: $2" # ,     . flag_rewrite=0 #    ,         #  ,      (   #     ). #    ,   ,   -    #  ,     .  ,   . if [ -e $1 ] then #         . echo "Both files exist." #  md5   ,     . buf=$(md5sum $1 --binary) md5_old=${buf:0:32} #      md5   . #   32 . buf=$(md5sum $2 --binary) md5_new=${buf:0:32} echo "Started file comparison." if [ $md5_old == $md5_new ] then #     ,  . echo "The file has not been updated." echo "The new file will be deleted." rm $2 echo "Removed." else #   ,    . echo "The file has been modified." echo "Old will be replaced by new." mv $2 $1 echo "Replaced." flag_rewrite=1 #    . fi else #    . echo "Old file does not exist." echo "New will be renamed to old." mv $2 $1 #    . flag_rewrite=1 #    . echo "Renamed." fi #       ,     . if [ $flag_rewrite -eq 1 ] then echo "Started flashing." echo "CMD params: $3" $3 fi</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le projet lui-m√™me, vous pouvez appeler la fonction cmake, qui fera tout ce dont vous avez besoin: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction de mise √† jour de Cmake</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(write_sector SECTOR ADDR_BASE ADDR_START ADDR_END) <span class="hljs-keyword"><span class="hljs-keyword">add_custom_command</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf POST_BUILD <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${ARM_OBJCOPY}</span></span> --output-<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=binary --gap-fill=<span class="hljs-number"><span class="hljs-number">0</span></span>xff <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin COMMENT <span class="hljs-string"><span class="hljs-string">"Creating a binary file of the &lt;&lt;${SECTOR}&gt;&gt; sector"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${BIN_EXTRACTOR}</span></span> -p <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin -o <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin -b <span class="hljs-variable"><span class="hljs-variable">${ADDR_BASE}</span></span> -s <span class="hljs-variable"><span class="hljs-variable">${ADDR_START}</span></span> -e <span class="hljs-variable"><span class="hljs-variable">${ADDR_END}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> cd <span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span> &amp;&amp; ./cmp.sh <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>.bin <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin <span class="hljs-string"><span class="hljs-string">"${STM32PROG} -c port=${STM32PROG_PORT} freq=${STM32PROG_FREQ} -w ${PROJECT_BINARY_DIR}/${PROJECT_NAME}_section_${SECTOR}.bin ${ADDR_START}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endfunction</span></span>(write_sector)</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La fonction utilise stm32programmer pour l'√©criture. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple d'utilisation d'une fonction du code de projet</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (STM32PROG_USE <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"bootloader"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_SYSCFG_PAGE_1_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"external_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_EXTERNAL_LIB_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"user_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"main_programm"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${ADDR_END_FLASH}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span> ()</code> </pre> </div></div><br><br><h2>  Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les avantages de cette approche: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans 95% des cas, ce qui est vraiment n√©cessaire est mis √† jour; </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inconv√©nients de cette approche: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de gain de vitesse, car avant chaque firmware, il est n√©cessaire de charger un chargeur de d√©marrage dans le microcontr√¥leur pour flasher la m√©moire non volatile (cela se fait automatiquement par stm32programmer). </font><font style="vertical-align: inherit;">Au contraire, lorsque le projet est compl√®tement remont√©, vous devez souvent recoudre toutes les sections;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la taille de section.ld d√©courage tout d√©sir d'ajouter ou de modifier quoi que ce soit. </font><font style="vertical-align: inherit;">Si vous devez appliquer cette m√©thodologie dans un projet r√©el, vous devrez √©crire une interface graphique pratique pour √©diter ce fichier;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si l'appareil contr√¥le sa propre alimentation, vous ne remarquerez peut-√™tre pas que l'une des partitions n'√©tait pas correctement c√¢bl√©e (avec une chute de tension, par exemple) et d√©boguez les partitions de diff√©rents assemblages pendant longtemps :). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir la version de travail de la m√©thode actuelle dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce commit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le projet peut √™tre assembl√© dans CLion, apr√®s avoir pr√©alablement compil√© un utilitaire pour extraire la section du fichier bin.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437848/">https://habr.com/ru/post/fr437848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437836/index.html">Under the hood Screeps - virtualisation dans le sandbox MMO pour les programmeurs</a></li>
<li><a href="../fr437838/index.html">Les technologies d'apprentissage automatique acc√©l√®rent parfois le processus d'adaptation des patients aux proth√®ses bioniques</a></li>
<li><a href="../fr437842/index.html">L'histoire secr√®te de Donkey Kong: des machines d'arcade √† NES</a></li>
<li><a href="../fr437844/index.html">Les conflits persistants entre le typage statique et le typage dynamique - TypeScript n'aidera pas</a></li>
<li><a href="../fr437846/index.html">bobaoskit - accessoires, dnssd et WebSocket</a></li>
<li><a href="../fr437850/index.html">Qui est le plus efficace dans la disposition des PCB?</a></li>
<li><a href="../fr437852/index.html">Histoire de Shipastik</a></li>
<li><a href="../fr437858/index.html">Conf√©rences suppl√©mentaires du cours ¬´Designing Highly Loaded Systems¬ª (automne 2018) √† Technopolis</a></li>
<li><a href="../fr437864/index.html">Syst√®me de surveillance pour les serveurs Windows sur SQL pur, et comment je l'avais secr√®tement gliss√© dans la production</a></li>
<li><a href="../fr437868/index.html">Semaine de la s√©curit√© 05: imprimantes, appareils photo, 7zip et √©thique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>