<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏿 ➿ 👨🏿‍🎤 Kurzreferenz der C ++ - Wertkategorien: Teil 2 👨‍👩‍👧 👆🏾 🐊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="← Weiter mit Teil 1 
 Parameter an eine Funktion übergeben 


 Wenn Parameter an eine Funktion übergeben werden, wird die Kategorie eines übergebenen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurzreferenz der C ++ - Wertkategorien: Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479358/"><img src="https://habrastorage.org/webt/nh/rz/-s/nhrz-smfzjdftvbzeuurpb7tpsu.png"><br><hr><br><p>  ← <a href="https://habr.com/en/post/479342/">Weiter mit Teil 1</a> </p><br><h1 id="passing-parameters-to-a-function">  Parameter an eine Funktion übergeben </h1><br><p> Wenn Parameter an eine Funktion übergeben werden, wird die Kategorie eines übergebenen Ausdrucks implizit in die Kategorie des Funktionsparameters konvertiert: <code>void f(TO_TYPE p); FROM_TYPE x; f(x);</code> <code>void f(TO_TYPE p); FROM_TYPE x; f(x);</code>  Diese implizite Konvertierung erfolgt auf dieselbe Weise wie während einer Zuweisung (siehe Abschnitt "Zuweisung" oben), außer dass die Funktionsdefinition keine "auto" -Typen enthalten kann. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o5/e9/c1/o5e9c1gvz6zisyjjkjvvu7elmsu.png"></div><a name="habracut"></a><br><p>  Wenn die Funktion mehrere Überladungen mit der gleichen Anzahl und Art von Parametern, aber verschiedenen Kategorien von Parametern aufweist, wählt der Überladungsmechanismus die am besten geeignete Funktionsüberladung basierend auf der Kategorie aus.  In der folgenden Tabelle wird Funktionsüberladungen eine Reihenfolge zugewiesen, in der jede Überladung ausgewählt wird, wenn ein Ausdruck einer bestimmten Kategorie übergeben wird (z. B. bedeutet 1, dass diese Überladung immer zuerst ausgewählt wird, wenn verfügbar): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/e9/6t/gke96tfgahczmsch_fihgqmf0tw.png"></div><br><p>  <strong>Fußnoten:</strong> </p><br><p>  1 - Ein temporäres Objekt, das zur Speicherung eines Referenzinitialisierers erstellt wurde, bleibt bis zum Ende des Funktionsumfangs bestehen. </p><br><p>  <strong>Hinweis:</strong> </p><br><ul><li>  Wenn eine Funktion Parameter nach Wert annimmt, bedeutet dies nicht, dass immer eine Kopie des Objekts erstellt wird und das Quellobjekt nicht geändert werden kann.  Wenn zum Beispiel der Wert dieser Funktion verschoben wird, wird der Konstruktor move aufgerufen und das Quellobjekt wird geändert. </li><li>  Sie können nicht sowohl <code>T f()</code> als auch <code>const T f()</code> Funktionsüberladungen haben </li><li>  Die Funktion kann abhängig davon, ob ein Parameter eine Referenz ist oder nicht, überladen werden.  Wenn jedoch beide Funktionen argumentieren können, muss die Mehrdeutigkeit manuell behoben werden (indem auf den entsprechenden Funktionszeigertyp gewechselt wird). </li><li>  Die Weiterleitungsreferenz ist am "gierigsten" - sie gewinnt, sobald keine Überlastung mit exakter Übereinstimmung vorliegt.  Aus diesem Grund wird das Überladen einer Weiterleitungsreferenz normalerweise nicht empfohlen (vermeiden Sie stattdessen FR oder das Überladen oder verwenden Sie Tag Dispatch oder SFINAE).  Konstruktor mit einem Weiterleitungsreferenzparameter sollte nicht verwendet werden, da dies zu Konflikten mit Konstruktoren zum Kopieren und Verschieben führen kann. </li><li>  Durch das Weiterleiten von Referenzen können Compiler-Fehler schwerer zu verstehen und zu beheben sein, insbesondere wenn sie mehrmals nacheinander verwendet werden. </li><li>  Die Weiterleitungsreferenz funktioniert in den folgenden Situationen nicht: <br><ul><li>  Sie können <code>{1, 2, 3}</code> an einen <code>vector&lt;int&gt;</code> mit einer Weiterleitungsreferenz weiterleiten. </li><li>  Sie können <code>0</code> oder <code>NULL</code> an einen Zeiger mit einer Weiterleitungsreferenz weiterleiten (verwenden <code>nullptr</code> stattdessen <code>nullptr</code> ). </li><li>  Sie können statische konstante und constexpr-Membervariablen für Ganzzahlen nicht mit einer Weiterleitungsreferenz weiterleiten, wenn sie keine Definitionen haben. </li><li>  Sie können überladene Funktionen oder Vorlagen nicht mit einer Weiterleitungsreferenz weiterleiten, da dies zu Mehrdeutigkeiten führt (die durch Angabe des Typs eindeutig werden können). </li></ul></li></ul><br><p>  <strong>Beispiele und Tests von Optionen mit Drucken jedes aufgerufenen Konstruktors und Operators:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Beispiele und Tests mit Drucken jedes aufgerufenen Konstruktors und Operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; template&lt;class C, class T&gt; auto contains(const C&amp; v, const T&amp; x) -&gt; decltype(end(v), true) { return end(v) != std::find(begin(v), end(v), x); } template &lt;class... Types&gt; constexpr inline __attribute__((__always_inline__)) int UNUSED(Types&amp;&amp;...) { return 0; }; map&lt;string, map&lt;string, string&gt;&gt; res; vector&lt;string&gt; froms; vector&lt;string&gt; tos; string from; string to; int ready = 0; void report(string st) { if (!from.empty() &amp;&amp; !to.empty()) { res[from][to] += st; } if (ready) cout &lt;&lt; st &lt;&lt; " "; } struct T { T() { report("Dc"); } T(int va) : a(va) { report("Pc"); } T(const T&amp; other) : a(other.a) { report("Cc"); } T(T&amp;&amp; other) : a(std::exchange(other.a, 0)) { report("Mc"); } T&amp; operator=(int va) { report("Va"); a = va; return *this; } T&amp; operator=(const T&amp; rhs) { report("Ca"); // check for self-assignment if(&amp;rhs == this) return *this; a = rhs.a; return *this; } T&amp; operator=(T&amp;&amp; rhs) { report("Ma"); // check for self-assignment if(&amp;rhs == this) return *this; a = std::exchange(rhs.a, 0); return *this; } ~T() { report("D"); } int a = 1; }; void func_start() { cout &lt;&lt; "|"; } T Fprv() { return T(4); } const T Fcprv() { return T(5); } T gs; void t(T s) { func_start(); cout &lt;&lt; sa; } void ct(const T s) { func_start(); cout &lt;&lt; sa; } void tr(T&amp; s) { func_start(); cout &lt;&lt; sa; } void ctr(const T&amp; s) { func_start(); cout &lt;&lt; sa; } void trr(T&amp;&amp; s) { func_start(); cout &lt;&lt; sa; } void ctrr(const T&amp;&amp; s) { func_start(); cout &lt;&lt; sa; } template&lt;typename Z&gt; void pf(Z&amp;&amp; s) { func_start(); gs = forward&lt;Z&gt;(s); cout &lt;&lt; gs.a; } void print_col(const string &amp;st, int width) { cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st; } void test_pass(string lto, string lfrom) { from = lfrom; to = lto; res[from][to] = ""; if (!from.empty() &amp;&amp; !to.empty()) { if (!contains(froms, from)) froms.push_back(from); if (!contains(tos, to)) tos.push_back(to); } print_col(lto + "(" + lfrom + "): ", 20); } #define EVAL(x) #x #define TEST_PASS(t, v) { \ test_pass(EVAL(t), #v); \ t(v); \ cout &lt;&lt; "-"; \ } void test_conversion() { ready = 1; T LV; const T CLV; T&amp; LR = LV; const T&amp; CLR = LV; //T&amp;&amp; XV = T(); -- actually LR //const T&amp;&amp; CXV = T(); -- actually LR auto &amp;&amp;fr = T(); #undef DT #define DT t TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); TEST_PASS(DT, Fcprv()); TEST_PASS(DT, LV); TEST_PASS(DT, CLV); TEST_PASS(DT, LR); TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); TEST_PASS(DT, move(CLV)); TEST_PASS(DT, fr); #undef DT #define DT ct TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); TEST_PASS(DT, Fcprv()); TEST_PASS(DT, LV); TEST_PASS(DT, CLV); TEST_PASS(DT, LR); TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); TEST_PASS(DT, move(CLV)); TEST_PASS(DT, fr); #undef DT #define DT tr //TEST_PASS(DT, 2); //TEST_PASS(DT, Fprv()); //TEST_PASS(DT, Fcprv()); TEST_PASS(DT, LV); //TEST_PASS(DT, CLV); TEST_PASS(DT, LR); //TEST_PASS(DT, CLR); //TEST_PASS(DT, move(LV)); //TEST_PASS(DT, move(CLV)); TEST_PASS(DT, fr); #undef DT #define DT ctr TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); TEST_PASS(DT, Fcprv()); TEST_PASS(DT, LV); TEST_PASS(DT, CLV); TEST_PASS(DT, LR); TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); TEST_PASS(DT, move(CLV)); TEST_PASS(DT, fr); #undef DT #define DT trr TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); //TEST_PASS(DT, Fcprv()); //TEST_PASS(DT, LV); //TEST_PASS(DT, CLV); //TEST_PASS(DT, LR); //TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); //TEST_PASS(DT, move(CLV)); //TEST_PASS(DT, fr); #undef DT #define DT ctrr TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); TEST_PASS(DT, Fcprv()); //TEST_PASS(DT, LV); //TEST_PASS(DT, CLV); //TEST_PASS(DT, LR); //TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); TEST_PASS(DT, move(CLV)); //TEST_PASS(DT, fr); #undef DT #define DT pf TEST_PASS(DT, 2); TEST_PASS(DT, Fprv()); TEST_PASS(DT, Fcprv()); TEST_PASS(DT, LV); TEST_PASS(DT, CLV); TEST_PASS(DT, LR); TEST_PASS(DT, CLR); TEST_PASS(DT, move(LV)); TEST_PASS(DT, move(CLV)); TEST_PASS(DT, fr); cout &lt;&lt; endl; const int twidth = 10; cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "From:"; for (const auto&amp; lto : tos) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lto; } cout &lt;&lt; endl; for (const auto&amp; lfrom : froms) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lfrom; for (const auto&amp; lto : tos) { if (!res.count(lfrom) || !res[lfrom].count(lto)) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "-"; } else if (res[lfrom][lto].empty()) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "+"; } else { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; res[lfrom][lto]; } } cout &lt;&lt; endl; } cout &lt;&lt; endl; } int main() { test_conversion(); cout &lt;&lt; endl; return 0; } /* Output: Dc Dc Dc t(2): Pc |2D - t(Fprv()): Pc |4D - t(Fcprv()): Pc |5D - t(LV): Cc |1D - t(CLV): Cc |1D - t(LR): Cc |1D - t(CLR): Cc |1D - t(move(LV)): Mc |1D - t(move(CLV)): Cc |1D - t(fr): Cc |1D - ct(2): Pc |2D - ct(Fprv()): Pc |4D - ct(Fcprv()): Pc |5D - ct(LV): Cc |0D - ct(CLV): Cc |1D - ct(LR): Cc |0D - ct(CLR): Cc |0D - ct(move(LV)): Mc |0D - ct(move(CLV)): Cc |1D - ct(fr): Cc |1D - tr(LV): |0- tr(LR): |0- tr(fr): |1- ctr(2): Pc |2D - ctr(Fprv()): Pc |4D - ctr(Fcprv()): Pc |5D - ctr(LV): |0- ctr(CLV): |1- ctr(LR): |0- ctr(CLR): |0- ctr(move(LV)): |0- ctr(move(CLV)): |1- ctr(fr): |1- trr(2): Pc |2D - trr(Fprv()): Pc |4D - trr(move(LV)): |0- ctrr(2): Pc |2D - ctrr(Fprv()): Pc |4D - ctrr(Fcprv()): Pc |5D - ctrr(move(LV)): |0- ctrr(move(CLV)): |1- pf(2): |Va 2- pf(Fprv()): Pc |Ma 4D - pf(Fcprv()): Pc |Ca 5D - pf(LV): |Ca 0- pf(CLV): |Ca 1- pf(LR): |Ca 0- pf(CLR): |Ca 0- pf(move(LV)): |Ma 0- pf(move(CLV)): |Ca 1- pf(fr): |Ca 1- From: t ct tr ctr trr ctrr pf 2 PcD PcD - PcD PcD PcD Va Fprv() PcD PcD - PcD PcD PcD PcMaD Fcprv() PcD PcD - PcD - PcD PcCaD LV CcD CcD + + - - Ca CLV CcD CcD - + - - Ca LR CcD CcD + + - - Ca CLR CcD CcD - + - - Ca move(LV) McD McD - + + + Ma move(CLV) CcD CcD - + - + Ca fr CcD CcD + + - - Ca DDD */</span></span></span></span></code> </pre> </div></div><br><p>  <strong>Links:</strong> </p><br><p>  <a href="https://en.cppreference.com/w/cpp/language/overload_resolution" rel="nofollow">Überlastungsauflösung</a> <br>  <a href="https://stackoverflow.com/questions/17642357/const-reference-vs-move-semantics" rel="nofollow">Konst-Referenz vs. Bewegungssemantik</a> <br>  <a href="https://stackoverflow.com/questions/51705967/advantages-of-pass-by-value-and-stdmove-over-pass-by-reference" rel="nofollow">Vorteile von Wertübergabe und std :: Referenzübergabe</a> </p><br><h1 id="returning-from-a-function">  Rückkehr von einer Funktion </h1><br><p>  Wenn ein Ausdruck von einer Funktion zurückgegeben wird, kann die Kategorie des zurückgegebenen Ausdrucks FROM_TYPE nicht mit der Kategorie des Funktionsrückgabetyps RETURN_TYPE übereinstimmen, der mit der Kategorie der zugewiesenen Variablen TO_TYPE nicht übereinstimmen kann: <code>RETURN_TYPE f() { FROM_TYPE x; return x; } TO_TYPE y = f();</code> <code>RETURN_TYPE f() { FROM_TYPE x; return x; } TO_TYPE y = f();</code> </p><br><p>  In diesem Fall kann die implizite Konvertierung zweimal erfolgen: </p><br><ul><li>  Bei der Konvertierung von FROM_TYPE nach RETURN TYPE.  Diese Konvertierung ist dieselbe wie während der Zuweisung, außer dass versucht wird, PRV oder CPRV in T &amp;&amp;, const T &amp;&amp; oder const T &amp; umzuwandeln (solche Konvertierungen können nicht durchgeführt werden, da die Lebensdauer des temporären Objekts nicht länger als der Funktionsumfang, <a href="https://stackoverflow.com/questions/1116641/is-returning-by-rvalue-reference-more-efficient" rel="nofollow">link, sein kann</a> ). </li><li>  Bei der Konvertierung von RETURN_TYPE nach TO_TYPE - eine übliche Zuweisungskonvertierung (siehe "Zuweisen von Wertkategorien" oben). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/70/gb/av/70gbav3z_faiwbacrdwoywvgnyw.png"></div><br><p>  <strong>Fußnoten:</strong> </p><br><p>  1 - Ein temporäres Objekt, das während der Zuweisung zum Halten eines Referenzinitialisierers erstellt wurde, bleibt bis zum Ende des Gültigkeitsbereichs der Referenz bestehen (rote Schrift). </p><br><p>  <strong>Beispiele und Tests von Optionen beim Drucken von verwendeten Copy / Move-Konstruktoren und Operatoren:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Beispiele und Tests mit Drucken jedes aufgerufenen Konstruktors und Operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;map&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; template&lt;class C, class T&gt; auto contains(const C&amp; v, const T&amp; x) -&gt; decltype(end(v), true) { return end(v) != std::find(begin(v), end(v), x); } template &lt;class... Types&gt; constexpr inline __attribute__((__always_inline__)) int UNUSED(Types&amp;&amp;...) { return 0; }; map&lt;string, map&lt;string, string&gt;&gt; res; vector&lt;string&gt; froms; vector&lt;string&gt; tos; string from; string to; int ready = 0; void report(string st) { if (!from.empty() &amp;&amp; !to.empty()) { res[from][to] += st; } if (ready) cout &lt;&lt; st &lt;&lt; " "; } struct T { T() { report("Dc"); } T(int va) : a(va) { report("Pc"); } T(const T&amp; other) : a(other.a) { report("Cc"); } T(T&amp;&amp; other) : a(std::exchange(other.a, 0)) { report("Mc"); } T&amp; operator=(int va) { report("Va"); a = va; return *this; } T&amp; operator=(const T&amp; rhs) { report("Ca"); // check for self-assignment if(&amp;rhs == this) return *this; a = rhs.a; return *this; } T&amp; operator=(T&amp;&amp; rhs) { report("Ma"); // check for self-assignment if(&amp;rhs == this) return *this; a = std::exchange(rhs.a, 0); return *this; } ~T() { report("D"); } int a = 1; }; T lv; const T clv; T&amp; lr = lv; T&amp;&amp; rr = std::move(lv); const T&amp; clr = clv; const T&amp;&amp; crr = std::move(clv); auto&amp;&amp; arr = std::move(lv); T Fprv() { return T(); } const T Fcprv() { return T(); } void func_start() { cout &lt;&lt; "|"; } T prv_t() { func_start(); return T(2); } const T prv_ct() { func_start(); return T(2); } // Prohibited (returning reference to temporary object): // T&amp; prv_tr() { func_start(); return T(2); } // const T&amp; prv_ctr() { func_start(); return T(2); } // T&amp;&amp; prv_trr() { func_start(); return T(2); } // const T&amp;&amp; prv_ctrr() { func_start(); return T(2); } template&lt;typename Z&gt; Z&amp;&amp; prv_fr() { func_start(); return Z(2); } /* Same as prv_ (I tested) T cprv_t() { func_start(); return Fcprv(); } const T cprv_ct() { func_start(); return Fcprv(); } // Prohibited (returning reference to temporary object): // T&amp; cprv_tr() { func_start(); return Fcprv(); } // const T&amp; cprv_ctr() { func_start(); return Fcprv(); } // T&amp;&amp; cprv_trr() { func_start(); return Fcprv(); } // const T&amp;&amp; cprv_ctrr() { func_start(); return Fcprv(); } template&lt;typename Z&gt; Z&amp;&amp; cprv_fr() { func_start(); return Fcprv(); } */ /* Same as prv_ (I tested) T lit_t() { func_start(); return 3; } const T lit_ct() { func_start(); return 3; } //T&amp; lit_tr() { func_start(); return 3; } //const T&amp; lit_ctr() { func_start(); return 3; } //T&amp;&amp; lit_trr() { func_start(); return 3; } //const T&amp;&amp; lit_ctrr() { func_start(); return 3; } template&lt;typename Z&gt; Z&amp;&amp; lit_fr() { func_start(); return 3; } */ T lr_t() { func_start(); return lr; } const T lr_ct() { func_start(); return lr; } T&amp; lr_tr() { func_start(); return lr; } const T&amp; lr_ctr() { func_start(); return lr; } //T&amp;&amp; lr_trr() { func_start(); return lr; } //const T&amp;&amp; lr_ctrr() { func_start(); return lr; } template&lt;typename Z&gt; Z&amp;&amp; lr_fr() { func_start(); return lr; } T clr_t() { func_start(); return clr; } const T clr_ct() { func_start(); return clr; } //T&amp; clr_tr() { func_start(); return clr; } const T&amp; clr_ctr() { func_start(); return clr; } //T&amp;&amp; clr_trr() { func_start(); return clr; } //const T&amp;&amp; clr_ctrr() { func_start(); return clr; } template&lt;typename Z&gt; Z&amp;&amp; clr_fr() { func_start(); return clr; } /* This is the same as xv and cxv (I tested it) T rr_t() { func_start(); return move(rr); } const T rr_ct() { func_start(); return move(rr); } //T&amp; rr_tr() { func_start(); return move(rr); } const T&amp; rr_ctr() { func_start(); return move(rr); } T&amp;&amp; rr_trr() { func_start(); return move(rr); } const T&amp;&amp; rr_ctrr() { func_start(); return move(rr); } template&lt;typename Z&gt; Z&amp;&amp; rr_fr() { func_start(); return move(rr); } T crr_t() { func_start(); return move(crr); } const T crr_ct() { func_start(); return move(crr); } //T&amp; crr_tr() { func_start(); return move(crr); } const T&amp; crr_ctr() { func_start(); return move(crr); } //T&amp;&amp; crr_trr() { func_start(); return move(crr); } const T&amp;&amp; crr_ctrr() { func_start(); return move(crr); } template&lt;typename Z&gt; Z&amp;&amp; crr_fr() { func_start(); return move(crr); } */ /* Same as lr_ (I tested) T arr_t() { func_start(); return arr; } const T arr_ct() { func_start(); return arr; } T&amp; arr_tr() { func_start(); return arr; } const T&amp; arr_ctr() { func_start(); return arr; } //T&amp;&amp; arr_trr() { func_start(); return arr; } //const T&amp;&amp; arr_ctrr() { func_start(); return arr; } template&lt;typename Z&gt; Z&amp;&amp; arr_fr() { func_start(); return arr; } */ T lv_t() { func_start(); return lv; } const T lv_ct() { func_start(); return lv; } T&amp; lv_tr() { func_start(); return lv; } const T&amp; lv_ctr() { func_start(); return lv; } //T&amp;&amp; lv_trr() { func_start(); return lv; } //const T&amp;&amp; lv_ctrr() { func_start(); return lv; } template&lt;typename Z&gt; Z&amp;&amp; lv_fr() { func_start(); return lv; } T xv_t() { func_start(); return move(lv); } const T xv_ct() { func_start(); return move(lv); } //T&amp; xv_tr() { func_start(); return move(lv); } const T&amp; xv_ctr() { func_start(); return move(lv); } T&amp;&amp; xv_trr() { func_start(); return move(lv); } const T&amp;&amp; xv_ctrr() { func_start(); return move(lv); } template&lt;typename Z&gt; Z&amp;&amp; xv_fr() { func_start(); return move(lv); } T clv_t() { func_start(); return clv; } const T clv_ct() { func_start(); return clv; } //T&amp; clv_tr() { func_start(); return clv; } const T&amp; clv_ctr() { func_start(); return clv; } //T&amp;&amp; clv_trr() { func_start(); return clv; } //const T&amp;&amp; clv_ctrr() { func_start(); return clv; } template&lt;typename Z&gt; Z&amp;&amp; clv_fr() { func_start(); return clv; } T cxv_t() { func_start(); return move(clv); } const T cxv_ct() { func_start(); return move(clv); } //T&amp; cxv_tr() { func_start(); return move(clv); } const T&amp; cxv_ctr() { func_start(); return move(clv); } //T&amp;&amp; cxv_trr() { func_start(); return move(clv); } const T&amp;&amp; cxv_ctrr() { func_start(); return move(clv); } template&lt;typename Z&gt; Z&amp;&amp; cxv_fr() { func_start(); return move(clv); } void print_col(const string &amp;st, int width) { cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st; } void test_call(string lto, string lfrom) { from = lfrom; to = lto; res[from][to] = ""; if (!from.empty() &amp;&amp; !to.empty()) { if (!contains(froms, from)) froms.push_back(from); if (!contains(tos, to)) tos.push_back(to); } print_col(lto + " = " + lfrom + ": ", 20); } #define EVAL(x) #x #define TEST_CALL(t, v) { \ test_call(EVAL(t), #v); \ ts = v(); \ cout &lt;&lt; sa; \ UNUSED(s); \ cout &lt;&lt; "-"; \ } void test_return() { ready = 1; cout &lt;&lt; endl; #define DT T TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT const T TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT T&amp; //TEST_CALL(DT, prv_t); //TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); //TEST_CALL(DT, lr_t); //TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); //TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); //TEST_CALL(DT, clr_t); //TEST_CALL(DT, clr_ct); //TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); //TEST_CALL(DT, lv_t); //TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); //TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); //TEST_CALL(DT, xv_t); //TEST_CALL(DT, xv_ct); //TEST_CALL(DT, xv_ctr); //TEST_CALL(DT, xv_trr); //TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); //TEST_CALL(DT, clv_t); //TEST_CALL(DT, clv_ct); //TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); //TEST_CALL(DT, cxv_t); //TEST_CALL(DT, cxv_ct); //TEST_CALL(DT, cxv_ctr); //TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT T&amp;&amp; TEST_CALL(DT, prv_t); //TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); //TEST_CALL(DT, lr_ct); //TEST_CALL(DT, lr_tr); //TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); //TEST_CALL(DT, clr_ct); //TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); //TEST_CALL(DT, lv_ct); //TEST_CALL(DT, lv_tr); //TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); //TEST_CALL(DT, xv_ct); //TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); //TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); //TEST_CALL(DT, clv_ct); //TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); //TEST_CALL(DT, cxv_ct); //TEST_CALL(DT, cxv_ctr); //TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT const T&amp;&amp; TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); //TEST_CALL(DT, lr_tr); //TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); //TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); //TEST_CALL(DT, lv_tr); //TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); //TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); //TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); //TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT const auto&amp;&amp; TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); //TEST_CALL(DT, lr_tr); //TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); //TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); //TEST_CALL(DT, lv_tr); //TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); //TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); //TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); //TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT auto&amp; //TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); //TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); //TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); //TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); //TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); //TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); //TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); //TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT const T&amp; TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT const auto&amp; TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); #undef DT #define DT auto&amp;&amp; TEST_CALL(DT, prv_t); TEST_CALL(DT, prv_ct); //TEST_CALL(DT, prv_fr); TEST_CALL(DT, lr_t); TEST_CALL(DT, lr_ct); TEST_CALL(DT, lr_tr); TEST_CALL(DT, lr_ctr); //TEST_CALL(DT, lr_fr); TEST_CALL(DT, clr_t); TEST_CALL(DT, clr_ct); TEST_CALL(DT, clr_ctr); //TEST_CALL(DT, clr_fr); TEST_CALL(DT, lv_t); TEST_CALL(DT, lv_ct); TEST_CALL(DT, lv_tr); TEST_CALL(DT, lv_ctr); //TEST_CALL(DT, lv_fr); TEST_CALL(DT, xv_t); TEST_CALL(DT, xv_ct); TEST_CALL(DT, xv_ctr); TEST_CALL(DT, xv_trr); TEST_CALL(DT, xv_ctrr); //TEST_CALL(DT, xv_fr); TEST_CALL(DT, clv_t); TEST_CALL(DT, clv_ct); TEST_CALL(DT, clv_ctr); //TEST_CALL(DT, clv_fr); TEST_CALL(DT, cxv_t); TEST_CALL(DT, cxv_ct); TEST_CALL(DT, cxv_ctr); TEST_CALL(DT, cxv_ctrr); //TEST_CALL(DT, cxv_fr); cout &lt;&lt; endl; const int twidth = 9; cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "From:"; for (const auto&amp; lto : tos) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lto; } cout &lt;&lt; endl; for (const auto&amp; lfrom : froms) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; lfrom; for (const auto&amp; lto : tos) { if (!res.count(lfrom) || !res[lfrom].count(lto)) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "-"; } else if (res[lfrom][lto].empty()) { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; "+"; } else { cout &lt;&lt; left &lt;&lt; setw(twidth) &lt;&lt; res[lfrom][lto]; } } cout &lt;&lt; endl; } } int main() { test_return(); return 0; } /* Output: T = prv_t: |Pc 2-D T = prv_ct: |Pc 2-D T = lr_t: |Cc 1-D T = lr_ct: |Cc 1-D T = lr_tr: |Cc 1-D T = lr_ctr: |Cc 1-D T = clr_t: |Cc 1-D T = clr_ct: |Cc 1-D T = clr_ctr: |Cc 1-D T = lv_t: |Cc 1-D T = lv_ct: |Cc 1-D T = lv_tr: |Cc 1-D T = lv_ctr: |Cc 1-D T = xv_t: |Mc 1-D T = xv_ct: |Mc 0-D T = xv_ctr: |Cc 0-D T = xv_trr: |Mc 0-D T = xv_ctrr: |Cc 0-D T = clv_t: |Cc 1-D T = clv_ct: |Cc 1-D T = clv_ctr: |Cc 1-D T = cxv_t: |Cc 1-D T = cxv_ct: |Cc 1-D T = cxv_ctr: |Cc 1-D T = cxv_ctrr: |Cc 1-D const T = prv_t: |Pc 2-D const T = prv_ct: |Pc 2-D const T = lr_t: |Cc 0-D const T = lr_ct: |Cc 0-D const T = lr_tr: |Cc 0-D const T = lr_ctr: |Cc 0-D const T = clr_t: |Cc 1-D const T = clr_ct: |Cc 1-D const T = clr_ctr: |Cc 1-D const T = lv_t: |Cc 0-D const T = lv_ct: |Cc 0-D const T = lv_tr: |Cc 0-D const T = lv_ctr: |Cc 0-D const T = xv_t: |Mc 0-D const T = xv_ct: |Mc 0-D const T = xv_ctr: |Cc 0-D const T = xv_trr: |Mc 0-D const T = xv_ctrr: |Cc 0-D const T = clv_t: |Cc 1-D const T = clv_ct: |Cc 1-D const T = clv_ctr: |Cc 1-D const T = cxv_t: |Cc 1-D const T = cxv_ct: |Cc 1-D const T = cxv_ctr: |Cc 1-D const T = cxv_ctrr: |Cc 1-D T&amp; = lr_tr: |0- T&amp; = lv_tr: |0- T&amp;&amp; = prv_t: |Pc 2-D T&amp;&amp; = lr_t: |Cc 0-D T&amp;&amp; = clr_t: |Cc 1-D T&amp;&amp; = lv_t: |Cc 0-D T&amp;&amp; = xv_t: |Mc 0-D T&amp;&amp; = xv_trr: |0- T&amp;&amp; = clv_t: |Cc 1-D T&amp;&amp; = cxv_t: |Cc 1-D const T&amp;&amp; = prv_t: |Pc 2-D const T&amp;&amp; = prv_ct: |Pc 2-D const T&amp;&amp; = lr_t: |Cc 0-D const T&amp;&amp; = lr_ct: |Cc 0-D const T&amp;&amp; = clr_t: |Cc 1-D const T&amp;&amp; = clr_ct: |Cc 1-D const T&amp;&amp; = lv_t: |Cc 0-D const T&amp;&amp; = lv_ct: |Cc 0-D const T&amp;&amp; = xv_t: |Mc 0-D const T&amp;&amp; = xv_ct: |Mc 0-D const T&amp;&amp; = xv_trr: |0- const T&amp;&amp; = xv_ctrr: |0- const T&amp;&amp; = clv_t: |Cc 1-D const T&amp;&amp; = clv_ct: |Cc 1-D const T&amp;&amp; = cxv_t: |Cc 1-D const T&amp;&amp; = cxv_ct: |Cc 1-D const T&amp;&amp; = cxv_ctrr: |1- const auto&amp;&amp; = prv_t: |Pc 2-D const auto&amp;&amp; = prv_ct: |Pc 2-D const auto&amp;&amp; = lr_t: |Cc 0-D const auto&amp;&amp; = lr_ct: |Cc 0-D const auto&amp;&amp; = clr_t: |Cc 1-D const auto&amp;&amp; = clr_ct: |Cc 1-D const auto&amp;&amp; = lv_t: |Cc 0-D const auto&amp;&amp; = lv_ct: |Cc 0-D const auto&amp;&amp; = xv_t: |Mc 0-D const auto&amp;&amp; = xv_ct: |Mc 0-D const auto&amp;&amp; = xv_trr: |0- const auto&amp;&amp; = xv_ctrr: |0- const auto&amp;&amp; = clv_t: |Cc 1-D const auto&amp;&amp; = clv_ct: |Cc 1-D const auto&amp;&amp; = cxv_t: |Cc 1-D const auto&amp;&amp; = cxv_ct: |Cc 1-D const auto&amp;&amp; = cxv_ctrr: |1- auto&amp; = prv_ct: |Pc 2-D auto&amp; = lr_ct: |Cc 0-D auto&amp; = lr_tr: |0- auto&amp; = lr_ctr: |0- auto&amp; = clr_ct: |Cc 1-D auto&amp; = clr_ctr: |1- auto&amp; = lv_ct: |Cc 0-D auto&amp; = lv_tr: |0- auto&amp; = lv_ctr: |0- auto&amp; = xv_ct: |Mc 0-D auto&amp; = xv_ctr: |0- auto&amp; = xv_ctrr: |0- auto&amp; = clv_ct: |Cc 1-D auto&amp; = clv_ctr: |1- auto&amp; = cxv_ct: |Cc 1-D auto&amp; = cxv_ctr: |1- auto&amp; = cxv_ctrr: |1- const T&amp; = prv_t: |Pc 2-D const T&amp; = prv_ct: |Pc 2-D const T&amp; = lr_t: |Cc 0-D const T&amp; = lr_ct: |Cc 0-D const T&amp; = lr_tr: |0- const T&amp; = lr_ctr: |0- const T&amp; = clr_t: |Cc 1-D const T&amp; = clr_ct: |Cc 1-D const T&amp; = clr_ctr: |1- const T&amp; = lv_t: |Cc 0-D const T&amp; = lv_ct: |Cc 0-D const T&amp; = lv_tr: |0- const T&amp; = lv_ctr: |0- const T&amp; = xv_t: |Mc 0-D const T&amp; = xv_ct: |Mc 0-D const T&amp; = xv_ctr: |0- const T&amp; = xv_trr: |0- const T&amp; = xv_ctrr: |0- const T&amp; = clv_t: |Cc 1-D const T&amp; = clv_ct: |Cc 1-D const T&amp; = clv_ctr: |1- const T&amp; = cxv_t: |Cc 1-D const T&amp; = cxv_ct: |Cc 1-D const T&amp; = cxv_ctr: |1- const T&amp; = cxv_ctrr: |1- const auto&amp; = prv_t: |Pc 2-D const auto&amp; = prv_ct: |Pc 2-D const auto&amp; = lr_t: |Cc 0-D const auto&amp; = lr_ct: |Cc 0-D const auto&amp; = lr_tr: |0- const auto&amp; = lr_ctr: |0- const auto&amp; = clr_t: |Cc 1-D const auto&amp; = clr_ct: |Cc 1-D const auto&amp; = clr_ctr: |1- const auto&amp; = lv_t: |Cc 0-D const auto&amp; = lv_ct: |Cc 0-D const auto&amp; = lv_tr: |0- const auto&amp; = lv_ctr: |0- const auto&amp; = xv_t: |Mc 0-D const auto&amp; = xv_ct: |Mc 0-D const auto&amp; = xv_ctr: |0- const auto&amp; = xv_trr: |0- const auto&amp; = xv_ctrr: |0- const auto&amp; = clv_t: |Cc 1-D const auto&amp; = clv_ct: |Cc 1-D const auto&amp; = clv_ctr: |1- const auto&amp; = cxv_t: |Cc 1-D const auto&amp; = cxv_ct: |Cc 1-D const auto&amp; = cxv_ctr: |1- const auto&amp; = cxv_ctrr: |1- auto&amp;&amp; = prv_t: |Pc 2-D auto&amp;&amp; = prv_ct: |Pc 2-D auto&amp;&amp; = lr_t: |Cc 0-D auto&amp;&amp; = lr_ct: |Cc 0-D auto&amp;&amp; = lr_tr: |0- auto&amp;&amp; = lr_ctr: |0- auto&amp;&amp; = clr_t: |Cc 1-D auto&amp;&amp; = clr_ct: |Cc 1-D auto&amp;&amp; = clr_ctr: |1- auto&amp;&amp; = lv_t: |Cc 0-D auto&amp;&amp; = lv_ct: |Cc 0-D auto&amp;&amp; = lv_tr: |0- auto&amp;&amp; = lv_ctr: |0- auto&amp;&amp; = xv_t: |Mc 0-D auto&amp;&amp; = xv_ct: |Mc 0-D auto&amp;&amp; = xv_ctr: |0- auto&amp;&amp; = xv_trr: |0- auto&amp;&amp; = xv_ctrr: |0- auto&amp;&amp; = clv_t: |Cc 1-D auto&amp;&amp; = clv_ct: |Cc 1-D auto&amp;&amp; = clv_ctr: |1- auto&amp;&amp; = cxv_t: |Cc 1-D auto&amp;&amp; = cxv_ct: |Cc 1-D auto&amp;&amp; = cxv_ctr: |1- auto&amp;&amp; = cxv_ctrr: |1- From: T const T T&amp; T&amp;&amp; const T&amp;&amp;const auto&amp;&amp;auto&amp; const T&amp; const auto&amp;auto&amp;&amp; prv_t PcD PcD - PcD PcD PcD - PcD PcD PcD prv_ct PcD PcD - - PcD PcD PcD PcD PcD PcD lr_t CcD CcD - CcD CcD CcD - CcD CcD CcD lr_ct CcD CcD - - CcD CcD CcD CcD CcD CcD lr_tr CcD CcD + - - - + + + + lr_ctr CcD CcD - - - - + + + + clr_t CcD CcD - CcD CcD CcD - CcD CcD CcD clr_ct CcD CcD - - CcD CcD CcD CcD CcD CcD clr_ctr CcD CcD - - - - + + + + lv_t CcD CcD - CcD CcD CcD - CcD CcD CcD lv_ct CcD CcD - - CcD CcD CcD CcD CcD CcD lv_tr CcD CcD + - - - + + + + lv_ctr CcD CcD - - - - + + + + xv_t McD McD - McD McD McD - McD McD McD xv_ct McD McD - - McD McD McD McD McD McD xv_ctr CcD CcD - - - - + + + + xv_trr McD McD - + + + - + + + xv_ctrr CcD CcD - - + + + + + + clv_t CcD CcD - CcD CcD CcD - CcD CcD CcD clv_ct CcD CcD - - CcD CcD CcD CcD CcD CcD clv_ctr CcD CcD - - - - + + + + cxv_t CcD CcD - CcD CcD CcD - CcD CcD CcD cxv_ct CcD CcD - - CcD CcD CcD CcD CcD CcD cxv_ctr CcD CcD - - - - + + + + cxv_ctrr CcD CcD - - + + + + + + */</span></span></span></span></code> </pre> </div></div><br><p>  std :: move oder std :: forward sollten bei der Rückkehr von der Funktion nicht auf lokale Objekte angewendet werden, wenn die Rückgabewertoptimierung (RVO) verwendet werden kann, um ein lokales Objekt nach Wert zurückzugeben, da die Konvertierung von LV nach XV verhindert, dass der Compiler RVO anwendet und bewegliches Objekt statt.  Bei der Anwendung ist RVO effektiver, da keine zusätzlichen Konstruktoren oder Operatoren zum Kopieren / Verschieben aufgerufen werden müssen. </p><br><p>  Auf der anderen Seite können verschiedene Compiler RVO nicht in verschiedenen Situationen anwenden, aber in den meisten Situationen wird der Compiler in der Lage sein, mindestens einen Verschiebungszuweisungsoperator anzuwenden.  Wenn das Risiko besteht, dass der Kopierkonstruktor anstelle von RVO aufgerufen wird, können Sie std :: move oder std :: forward verwenden, um das Objekt nach Wert zurückzugeben. Soweit ich weiß, kann dies jedoch nur unter Verwendung von geschehen ternärer Operator in return-Anweisung wie <code>return param ? a : b</code>  <code>return param ? a : b</code> , die normalerweise leicht durch if-Anweisung ersetzt werden kann.  Weitere Informationen darüber, welche Compiler RVO in welchen Situationen anwenden, finden Sie https: // hier und https: // hier. </p><br><p>  <strong>Test von RVO mit neuestem Clang auf Ubuntu (Jahr 2019):</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Beispiele und Tests mit Drucken jedes aufgerufenen Konstruktors und Operators</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; using namespace std; void report(string st) { cout &lt;&lt; st &lt;&lt; " "; } struct T { T() { report("Dc"); } T(int va) : a(va) { report("Pc"); } T(const T&amp; other) : a(other.a) { report("Cc"); } T(T&amp;&amp; other) : a(std::exchange(other.a, 0)) { report("Mc"); } T&amp; operator=(int va) { report("Va"); a = va; return *this; } T&amp; operator=(const T&amp; rhs) { report("Ca"); // check for self-assignment if(&amp;rhs == this) return *this; a = rhs.a; return *this; } T&amp; operator=(T&amp;&amp; rhs) { report("Ma"); // check for self-assignment if(&amp;rhs == this) return *this; a = std::exchange(rhs.a, 0); return *this; } ~T() { report("D"); } int a = 1; }; T urvo_single() { //const bool param = true; return T(); } T urvo_two() { const bool param = true; if(param) return T(); else return T(); } T urvo_two_with_param(bool param) { if(param) return T(); else return T(); } T urvo_with_exception_1(bool param) { if(!param) throw std::exception(); return T(); } T urvo_with_exception_2(bool param) { if(param) return T(); else throw std::exception(); } T urvo_with_exception_3() { const bool param = true; if(param) return T(); else throw std::exception(); } static T make_X() { return T(); } T rrvo_single() { //const bool param = true; return make_X(); } T rrvo_two() { const bool param = true; if(param) return make_X(); else return make_X(); } T rrvo_two_with_param(bool param) { if(param) return make_X(); else return make_X(); } T rrvo_with_exception_1(bool param) { if(!param) throw std::exception(); return make_X(); } T rrvo_with_exception_2(bool param) { if(param) return make_X(); else throw std::exception(); } T rrvo_with_exception_3() { const bool param = true; if(param) return make_X(); else throw std::exception(); } T nrvo_single_1() { T a; return a; } T nrvo_single_2() { { T a; return a; } } T nrvo_single_with_exception_1(bool param) { T a; if(!param) throw std::exception(); return a; } T nrvo_single_with_exception_1a(bool param) { if(!param) throw std::exception(); T a; return a; } T nrvo_single_with_exception_2(bool param) { T a; if(param) return a; else throw std::exception(); // Silence compilation error, does not count as an additional // return statement as it is unreachable code return a; } T nrvo_single_with_exception_2a(bool param) { if(param) { T a; return a; } else throw std::exception(); } T nrvo_single_with_exception_3() { const bool param = true; T a; if(param) return a; else throw std::exception(); } T nrvo_single_with_exception_3a() { const bool param = true; if(param) { T a; return a; } else throw std::exception(); } T nrvo_two_different_tern() { const bool param = true; T a, b; return param ? a : b; } T nrvo_two_different_if() { const bool param = true; T a, b; if(param) return a; else return b; } T nrvo_two_different_if_2() { const bool param = true; if(param) { T a; return a; } else { T b; return b; } } T nrvo_two_different_with_param_tern(bool param) { T a, b; return param ? a : b; } T nrvo_two_different_with_param_if(bool param) { T a, b; if(param) return a; else return b; } T nrvo_two_different_with_param_if_2(bool param) { if(param) { T a; return a; } else { T b; return b; } } T nrvo_two_equal_tern() { const bool param = true; T a; return param ? a : a; } T nrvo_two_equal_if() { const bool param = true; T a; if(param) return a; else return a; } T nrvo_two_equal_with_param_tern(bool param) { T a; return param ? a : a; } T nrvo_two_equal_with_param_if(bool param) { T a; if(param) return a; else return a; } T nrvo_urvo_mixed_static() { static const bool param = true; if (param) return T(); T a; return a; } T nrvo_urvo_mixed_dynamic(bool param) { if (param) return T(); T a; return a; } void print_col(const string &amp;st, int width) { cout &lt;&lt; endl &lt;&lt; left &lt;&lt; setw(width) &lt;&lt; st; } #define CHECK_COPIES(stmt) { \ print_col(#stmt ": ", 20); \ try { \ stmt; \ } \ catch(...) { \ } \ } \ int main() { CHECK_COPIES( T a = urvo_single()); CHECK_COPIES( T a = urvo_two()); CHECK_COPIES( T a = urvo_two_with_param(true)); CHECK_COPIES( T a = urvo_with_exception_1(true)); CHECK_COPIES( T a = urvo_with_exception_2(true)); CHECK_COPIES( T a = urvo_with_exception_3()); cerr &lt;&lt; " "; CHECK_COPIES( T a = rrvo_single()); CHECK_COPIES( T a = rrvo_two()); CHECK_COPIES( T a = rrvo_two_with_param(true)); CHECK_COPIES( T a = rrvo_with_exception_1(true)); CHECK_COPIES( T a = rrvo_with_exception_2(true)); CHECK_COPIES( T a = rrvo_with_exception_3()); cerr &lt;&lt; " "; CHECK_COPIES( T a = nrvo_single_1()); CHECK_COPIES( T a = nrvo_single_2()); CHECK_COPIES( T a = nrvo_single_with_exception_1(true)); CHECK_COPIES( T a = nrvo_single_with_exception_1a(true)); CHECK_COPIES( T a = nrvo_single_with_exception_2(true)); CHECK_COPIES( T a = nrvo_single_with_exception_2a(true)); CHECK_COPIES( T a = nrvo_single_with_exception_3()); CHECK_COPIES( T a = nrvo_single_with_exception_3a()); cerr &lt;&lt; " "; CHECK_COPIES( T a = nrvo_two_different_tern()); CHECK_COPIES( T a = nrvo_two_different_if()); CHECK_COPIES( T a = nrvo_two_different_if_2()); CHECK_COPIES( T a = nrvo_two_different_with_param_tern(true)); CHECK_COPIES( T a = nrvo_two_different_with_param_if(true)); CHECK_COPIES( T a = nrvo_two_different_with_param_if_2(true)); CHECK_COPIES( T a = nrvo_two_equal_tern()); CHECK_COPIES( T a = nrvo_two_equal_if()); CHECK_COPIES( T a = nrvo_two_equal_with_param_tern(true)); CHECK_COPIES( T a = nrvo_two_equal_with_param_if(true)); cerr &lt;&lt; " "; CHECK_COPIES( T a = nrvo_urvo_mixed_static()); CHECK_COPIES( T a = nrvo_urvo_mixed_dynamic(true)); } /* Output: T a = urvo_single(): Dc D T a = urvo_two(): Dc D T a = urvo_two_with_param(true): Dc D T a = urvo_with_exception_1(true): Dc D T a = urvo_with_exception_2(true): Dc D T a = urvo_with_exception_3(): Dc D T a = rrvo_single(): Dc D T a = rrvo_two(): Dc D T a = rrvo_two_with_param(true): Dc D T a = rrvo_with_exception_1(true): Dc D T a = rrvo_with_exception_2(true): Dc D T a = rrvo_with_exception_3(): Dc D T a = nrvo_single_1(): Dc D T a = nrvo_single_2(): Dc D T a = nrvo_single_with_exception_1(true): Dc D T a = nrvo_single_with_exception_1a(true): Dc D T a = nrvo_single_with_exception_2(true): Dc D T a = nrvo_single_with_exception_2a(true): Dc D T a = nrvo_single_with_exception_3(): Dc D T a = nrvo_single_with_exception_3a(): Dc D T a = nrvo_two_different_tern(): Dc Dc Cc DDD T a = nrvo_two_different_if(): Dc Dc Mc DDD T a = nrvo_two_different_if_2(): Dc D T a = nrvo_two_different_with_param_tern(true): Dc Dc Cc DDD T a = nrvo_two_different_with_param_if(true): Dc Dc Mc DDD T a = nrvo_two_different_with_param_if_2(true): Dc D T a = nrvo_two_equal_tern(): Dc Cc DD T a = nrvo_two_equal_if(): Dc D T a = nrvo_two_equal_with_param_tern(true): Dc Cc DD T a = nrvo_two_equal_with_param_if(true): Dc D T a = nrvo_urvo_mixed_static(): Dc D T a = nrvo_urvo_mixed_dynamic(true): Dc D */</span></span></span></span></code> </pre> </div></div><br><p> <strong>Links:</strong> </p><br><p> <a href="https://en.cppreference.com/w/cpp/language/copy_elision" rel="nofollow">Copy elision</a> <br> <a href="https://www.docdroid.net/lEI1j0g/copy-elision-revisited.pdf" rel="nofollow">Copy elision revisited</a> <br> <a href="https://godbolt.org/z/BPQEH6" rel="nofollow">Compare clang and gcc copy elision (tests with similar results are commented out)</a> </p><br><h1 id="passing-and-returning-trivially-copyable-objects-of-small-size"> Passing and returning trivially copyable objects of small size </h1><br><p> Trivially copyable struct or class: </p><br><ul><li> has no virtual members or virtual base classes </li><li> has default copy and move constructors and operators </li></ul><br><p> Trivially copyable objects of small size (up to 16 bytes) can be passed in CPU registers when passed to function by value — like scalar types. </p><br><p> Also, when passing it by value, compiler has additional guarantee that object will not change during the course of the function even if other functions are called — this is why compiler can generate more effective code in this situations. If passed by const T&amp;, there is no such guarantee, because object passed by constant reference can still be changed from other function, or multiple passed objects can use shared memory. </p><br><p> For the same reason, std::string_view should be passed by value. </p><br><p> <strong>Links:</strong> </p><br><p> <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable" rel="nofollow">Trivially copyable</a> </p><br><h1 id="returning-from-a-function-with-a-reference-parameter"> Returning from a function with a reference parameter </h1><br><p> A reference to an object can be passed to a function so that function can change source object: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ X.change(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X; }</code> </pre> <br><p> This method should not be used if temporary object can be created inside function and returned by value, because returning by value can take advantage of return value optimization (see above). </p><br><h1 id="passing-multiple-parameters-and-returning-one-of-them-from-function"> Passing multiple parameters and returning one of them from function </h1><br><p> If all passed parameters are lvalues, you can pass and return by const T&amp;. This gives high performance, because no copy/move constructors or operators are called: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-comment"><span class="hljs-comment">/* something */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre> <br><p> prvalue cannot be passed to get function, because this would result in returning a reference to a temporary object. If prvalue has to be passed, </p><br><p> If both parameters are temporary objects (prvalues), T&amp;&amp; can be returned, which also gives high performance (no copy/move constructors or operators are called): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; a, T&amp;&amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-comment"><span class="hljs-comment">/* something */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre> <br><p> If some of parameters are temporary objects (prvalues) and other are lvalues, it is difficult to high performance without complicating the function interface. In the following example if lvalue and prvalue are passed as A and B arguments into the function, copy constructor will be called if A is chosen and move constructor if B is chosen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; a, T&amp;&amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-comment"><span class="hljs-comment">/* something */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre> <br><h1 id="passing-to-constructor-or-setter"> Passing to constructor or setter </h1><br><p> In this section I describe passing an object of type T to an object of type C during construction of type C or by calling a setter: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(TX) : x(X) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TX)</span></span></span><span class="hljs-function"> </span></span>{ x = X; } T x; }; T y; <span class="hljs-function"><span class="hljs-function">C </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y)</span></span></span></span>; c.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(y);</code> </pre> <br><ul><li> For copying an lvalue to x member variable in an object of class C: <br><ul><li> with class C constructor: any of the following variants is good ("T move" variant is a bit less efficient due to calling an additional move constructor) </li><li> with class C set(T): </li><li> if T is copy-on-write (like CString in MFC/ATL) and x will not change later, any of the following variants is good ("T move" variant is a bit less efficient due to calling an additional move constructor) </li><li> if T is not copy-on write or x can change later, "T move" variant becomes inefficient, because it does not allow to avoid deallocation, even if already allocated memory in existing object x is enough for new object and class can reuse allocated memory (like std::string) </li></ul></li><li> For moving an xvalue or prvalue to x member variable in an object of class C with C's constructor or C's <code>set</code> member function any of the following variants is good except "const T&amp;" (because it requires copying). Perfect forwarding has a slight performance advantage due to avoiding calling move constructor when converting from different type, instead forwarding parameter of a different type to a parametrized constructor </li></ul><br><p> <strong>Variants:</strong> </p><br><ul><li> const T&amp; — optimal if we do not need to move objects or store them in dynamically growing containers <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; X) : x(X) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = X; } T x; };</code> </pre> </li><li> const T&amp; + T&amp;&amp; move — optimized variant if we need to support both lvalue copy and rvalue move. Can lead to code duplication, especially if constructors with different combinations of &amp; and &amp;&amp; are needed. Provides simple implementation of noexcept for effective use with containers. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; X) : x(X) {} C(T&amp;&amp; X) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X); } T x; };</code> </pre> </li><li> T move — looks simple, but not very intuitive (can avoid copying and change object, passed with std::move as xvalue). Less efficient than perfect forwarding and &amp;+&amp;&amp; in some situations (does not allow to avoid deallocation, even if already allocated memory in existing object x is enough for new object and class can reuse allocated memory, calls excessive moves and destructors) <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(TX) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TX)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X); } T x; };</code> </pre> </li><li> Perfect forwarding (PF) — most effective variant (especially when forwarding literals or other types, which can be converted to class with parametrized constructors), but it is more difficult to write, which increases risk of mistakes. Does not support virtual functions and has to be implemented in header file. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Z&gt; C(Z&amp;&amp; X) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X)) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Z&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z&amp;&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X); } T x; };</code> </pre> </li><li> Strict perfect forwarding (PF Strict). Has same qualities as perfect forwarding, but is more safe, because it does not allow to convert types and thus cannot receive literals (actually, it is the only variant among discussed in this section, which does not allow to convert types). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Z</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;Z&gt;, T&gt;::value&gt;&gt; C(Z&amp;&amp; X) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X)) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Z</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;Z&gt;, T&gt;::value&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Z&amp;&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X); } T x; };</code> </pre> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4w/0q/ee/4w0qee7m2_tsrnmaaximni3awf4.png"></div><br><p> In the comparison tables below constructor properties are highlighted with green, setter member function properties are highlighted with yellow. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8w/0n/rt/8w0nrtcbpggu66xhxnc1dm9ecrk.png"></div><br><p> <strong>Annotations:</strong> <br> 1 — Becomes combinatorial if constructor has multiple parameters <br> 2 — Function is technically noexcept, but copy before function call can result in exception <br> 3 — Requires noexcept(std::is_nothrow_assignable&lt;Type&amp;, T&gt;::value) <br> 4 — Does not accept conversion <br> 5 — Unconditional deallocation leads to inability to reuse allocated storage (std::string). Not a problem for copy-on-write implementations (Tstring) <br> 6 — If you do not have overloaded assignment operator for value type in object class, this will be: VcMaD </p><br><p> <strong>Examples and tests of variants with printing of used copy/move constructors and operators:</strong> </p><br><div class="spoiler"> <b class="spoiler_title">Examples and tests with printing of each called constructor and operator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; struct TStruct { TStruct() { cout &lt;&lt; "Dc"; } TStruct(int va) : a(va) { cout &lt;&lt; "Vc"; } TStruct(const TStruct&amp; other) : a(other.a) { cout &lt;&lt; "Cc"; } TStruct(TStruct&amp;&amp; other) : a(std::exchange(other.a, 0)) { cout &lt;&lt; "Mc"; } TStruct&amp; operator=(int va) { cout &lt;&lt; "Va"; a = va; return *this; } TStruct&amp; operator=(const TStruct&amp; rhs) { cout &lt;&lt; "Ca"; // check for self-assignment if(&amp;rhs == this) return *this; a = rhs.a; return *this; } TStruct&amp; operator=(TStruct&amp;&amp; rhs) { cout &lt;&lt; "Ma"; // check for self-assignment if(&amp;rhs == this) return *this; a = std::exchange(rhs.a, 0); return *this; } ~TStruct() { cout &lt;&lt; "D"; } int a = 1; }; struct TRef { TRef(TStruct&amp; tsv) : ts(tsv) {} void set(TStruct&amp; tsv) { ts = tsv; } TStruct ts; }; struct TConstRef { TConstRef(const TStruct&amp; tsv) : ts(tsv) {} void set(const TStruct&amp; tsv) { ts = tsv; } TStruct ts; }; struct TConstRefAndRvalueRef { TConstRefAndRvalueRef(const TStruct&amp; tsv) : ts(tsv) { cout &lt;&lt; "Lr"; } TConstRefAndRvalueRef(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) { cout &lt;&lt; "Rr"; } void set(const TStruct&amp; tsv) { cout &lt;&lt; "Sl"; ts = tsv; } void set(TStruct&amp;&amp; tsv) { cout &lt;&lt; "Sr"; ts = std::move(tsv); } TStruct ts; }; struct TConstRvalueRef { TConstRvalueRef(const TStruct&amp;&amp; tsv) : ts(std::move(tsv)) { } void set(const TStruct&amp;&amp; tsv) { ts = std::move(tsv); } TStruct ts; }; struct TValueMove { TValueMove(TStruct tsv) : ts(std::move(tsv)) {} void set(TStruct tsv) { ts = std::move(tsv); } TStruct ts; }; struct TConstValueMove { TConstValueMove(const TStruct tsv) : ts(std::move(tsv)) {} void set(const TStruct tsv) { ts = std::move(tsv); } TStruct ts; }; struct TPerfectForward { template&lt;class T&gt; TPerfectForward(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {} template&lt;class T&gt; void set(T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); } TStruct ts; }; struct TConstPerfectForward { template&lt;class T&gt; TConstPerfectForward(const T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {} template&lt;class T&gt; void set(const T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); } TStruct ts; }; struct TPerfectForwardStrict { template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt; TPerfectForwardStrict(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) {} template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt; void set(T&amp;&amp; tsv) { ts = std::forward&lt;T&gt;(tsv); } TStruct ts; }; struct TMultiVariant { TMultiVariant(const TStruct&amp; tsv) : ts(tsv) { cout &lt;&lt; "Lr"; } TMultiVariant(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) { cout &lt;&lt; "Rr"; } void set(const TStruct&amp; tsv) { cout &lt;&lt; "Sl"; ts = tsv; } void set(TStruct&amp;&amp; tsv) { cout &lt;&lt; "Sr"; ts = std::move(tsv); } template&lt;class T&gt; TMultiVariant(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) { cout &lt;&lt; "Pf"; } template&lt;class T&gt; void set(T&amp;&amp; tsv) { cout &lt;&lt; "Sp"; ts = std::forward&lt;T&gt;(tsv); } TStruct ts; }; struct TMultiVariantStrict { TMultiVariantStrict(const TStruct&amp; tsv) : ts(tsv) { cout &lt;&lt; "Lr"; } TMultiVariantStrict(TStruct&amp;&amp; tsv) : ts(std::move(tsv)) { cout &lt;&lt; "Rr"; } void set(const TStruct&amp; tsv) { cout &lt;&lt; "Sl"; ts = tsv; } void set(TStruct&amp;&amp; tsv) { cout &lt;&lt; "Sr"; ts = std::move(tsv); } template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt; TMultiVariantStrict(T&amp;&amp; tsv) : ts(std::forward&lt;T&gt;(tsv)) { cout &lt;&lt; "Pf"; } template&lt;class T, class=std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, TStruct&gt;::value&gt;&gt; void set(T&amp;&amp; tsv) { cout &lt;&lt; "Sp"; ts = std::forward&lt;T&gt;(tsv); } TStruct ts; }; TStruct get_st() { return TStruct(7); } void detect_change(int&amp; param, int val) { if (param != val) { cout &lt;&lt; "!"; param = val; } else { cout &lt;&lt; "-"; } } void test_passing() { cout &lt;&lt; "TStruct st(100): "; TStruct st(100); // Test constructing with object cout &lt;&lt; endl &lt;&lt; "TRef (st): "; TRef rf(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRef (st): "; TConstRef crf(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (st): "; TConstRefAndRvalueRef crf_rvf(st); detect_change(st.a, 100); // Will not compile // cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (st): "; // TConstRvalueRef crvf(st); // detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TValueMove (st): "; TValueMove vm(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstValueMove (st): "; TConstValueMove cvm(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForward (st): "; TPerfectForward pf(st); detect_change(st.a, 100); // Will not compile // cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (st): "; // TConstPerfectForward cpf(st); // detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (st): "; TPerfectForwardStrict pft(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariant (st): "; TMultiVariant mv(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (st): "; TMultiVariantStrict mvt(st); detect_change(st.a, 100); // Test constructing with moved object // Will not compile because of std::move // cout &lt;&lt; endl &lt;&lt; "TRef (std::move(st)): "; // TRef rf4(std::move(st)); // detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRef (std::move(st)): "; TConstRef crf4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (std::move(st)): "; TConstRefAndRvalueRef crf_rvf4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (std::move(st)): "; TConstRvalueRef crvf4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TValueMove (std::move(st)): "; TValueMove vm4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstValueMove (std::move(st)): "; TConstValueMove cvm4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForward (std::move(st)): "; TPerfectForward pf4(std::move(st)); detect_change(st.a, 100); // Will not compile // cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (std::move(st)): "; // TConstPerfectForward cpf4(std::move(st)); // detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (std::move(st)): "; TPerfectForwardStrict pft4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariant (std::move(st)): "; TMultiVariant mv4(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (std::move(st)): "; TMultiVariantStrict mvt4(std::move(st)); detect_change(st.a, 100); // Test constructing with temporary object // Will not compile // cout &lt;&lt; endl &lt;&lt; "TRef (TStruct(6)): "; // TRef rf3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TConstRef (TStruct(6)): "; TConstRef crf3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (TStruct(6)): "; TConstRefAndRvalueRef crf_rvf3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (TStruct(6)): "; TConstRvalueRef crvf3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TValueMove (TStruct(6)): "; TValueMove vm3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TConstValueMove (TStruct(6)): "; TConstValueMove cvm3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TPerfectForward (TStruct(6)): "; TPerfectForward pf3(TStruct(6)); // Will not compile //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (TStruct(6)): "; //TConstPerfectForward cpf3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (TStruct(6)): "; TPerfectForwardStrict pft3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TMultiVariant (TStruct(6)): "; TMultiVariant mv3(TStruct(6)); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (TStruct(6)): "; TMultiVariantStrict mvt3(TStruct(6)); // Test constructing with RVO object // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef (get_st()): "; //TRef rf5(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRef (get_st()): "; TConstRef crf5(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (get_st()): "; TConstRefAndRvalueRef crf_rvf5(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (get_st()): "; TConstRvalueRef crvf5(get_st()); cout &lt;&lt; endl &lt;&lt; "TValueMove (get_st()): "; TValueMove vm5(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstValueMove (get_st()): "; TConstValueMove cvm5(get_st()); cout &lt;&lt; endl &lt;&lt; "TPerfectForward (get_st()): "; TPerfectForward pf5(get_st()); //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (get_st()): "; //TConstPerfectForward cpf5(get_st()); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (get_st()): "; TPerfectForwardStrict pft5(get_st()); cout &lt;&lt; endl &lt;&lt; "TMultiVariant (get_st()): "; TMultiVariant mv5(get_st()); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (get_st()): "; TMultiVariantStrict mvt5(get_st()); // Test constructing with literal // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef (5): "; //TRef rf2(5); cout &lt;&lt; endl &lt;&lt; "TConstRef (5): "; TConstRef crf2(5); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef (5): "; TConstRefAndRvalueRef crf_rvf2(5); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef (5): "; TConstRvalueRef crvf2(5); cout &lt;&lt; endl &lt;&lt; "TValueMove (5): "; TValueMove vm2(5); cout &lt;&lt; endl &lt;&lt; "TConstValueMove (5): "; TConstValueMove cvm2(5); cout &lt;&lt; endl &lt;&lt; "TPerfectForward (5): "; TPerfectForward pf2(5); // Will not compile //cout &lt;&lt; endl &lt;&lt; "TConstPerfectForward (5): "; //TConstPerfectForward cpf2(5); // Will not compile due to SFINAE test //cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict (5): "; //TPerfectForwardStrict pft2(5); cout &lt;&lt; endl &lt;&lt; "TMultiVariant (5): "; TMultiVariant mv2(5); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict (5): "; TMultiVariantStrict mvt2(5); // Test setting with object st.a = 100; cout &lt;&lt; endl &lt;&lt; "TRef set(st): "; rf.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRef set(st): "; crf.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(st): "; crf_rvf.set(st); detect_change(st.a, 100); // Will not compile // cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(st): "; // crvf2.set(st); // detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TValueMove set(st): "; vm.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(st): "; cvm.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(st): "; pf.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(st): "; pft.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(st): "; mv.set(st); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(st): "; mvt.set(st); detect_change(st.a, 100); // Test setting with moved object // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef set(std::move(st)): "; //rf.set(std::move(st)); //detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRef set(std::move(st)): "; crf.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(std::move(st)): "; crf_rvf.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(std::move(st)): "; crvf2.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TValueMove set(std::move(st)): "; vm.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(std::move(st)): "; cvm.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(std::move(st)): "; pf.set(std::move(st)); detect_change(st.a, 100); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(std::move(st)): "; pft.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(std::move(st)): "; mv.set(std::move(st)); detect_change(st.a, 100); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(std::move(st)): "; mvt.set(std::move(st)); detect_change(st.a, 100); // Test setting with constructed temporary object // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef set(TStruct(8)): "; //rf.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TConstRef set(TStruct(8)): "; crf.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(TStruct(8)): "; crf_rvf.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(TStruct(8)): "; crvf2.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TValueMove set(TStruct(8)): "; vm.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(TStruct(8)): "; cvm.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(TStruct(8)): "; pf.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(TStruct(8)): "; pft.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(TStruct(8)): "; mv.set(TStruct(8)); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(TStruct(8)): "; mvt.set(TStruct(8)); // Test setting with RVO object // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef set(get_st()): "; //rf.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRef set(get_st()): "; crf.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(get_st()): "; crf_rvf.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(get_st()): "; crvf2.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TValueMove set(get_st()): "; vm.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(get_st()): "; cvm.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(get_st()): "; pf.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(get_st()): "; pft.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(get_st()): "; mv.set(get_st()); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(get_st()): "; mvt.set(get_st()); cout &lt;&lt; endl &lt;&lt; "st = 3: "; st = 3; // Test setting with literal // Will not compile //cout &lt;&lt; endl &lt;&lt; "TRef set(4): "; //rf.set(4); cout &lt;&lt; endl &lt;&lt; "TConstRef set(4): "; crf.set(4); cout &lt;&lt; endl &lt;&lt; "TConstRefAndRvalueRef set(4): "; crf_rvf.set(4); cout &lt;&lt; endl &lt;&lt; "TConstRvalueRef set(4): "; crvf2.set(4); cout &lt;&lt; endl &lt;&lt; "TValueMove set(4): "; vm.set(4); cout &lt;&lt; endl &lt;&lt; "TConstValueMove set(4): "; cvm.set(4); cout &lt;&lt; endl &lt;&lt; "TPerfectForward set(4): "; pf.set(4); // Will not compile due to SFINAE test //cout &lt;&lt; endl &lt;&lt; "TPerfectForwardStrict set(st): "; //pft.set(4); cout &lt;&lt; endl &lt;&lt; "TMultiVariant set(4): "; mv.set(4); cout &lt;&lt; endl &lt;&lt; "TMultiVariantStrict set(4): "; mvt.set(4); cout &lt;&lt; endl; } int main() { test_passing(); return 0; } /* Output: TStruct st(100): Vc TRef (st): Cc- TConstRef (st): Cc- TConstRefAndRvalueRef (st): CcLr- TValueMove (st): CcMcD- TConstValueMove (st): CcCcD- TPerfectForward (st): Cc- TPerfectForwardStrict (st): Cc- TMultiVariant (st): CcPf- TMultiVariantStrict (st): CcPf- TConstRef (std::move(st)): Cc- TConstRefAndRvalueRef (std::move(st)): McRr! TConstRvalueRef (std::move(st)): Cc- TValueMove (std::move(st)): McMcD! TConstValueMove (std::move(st)): McCcD! TPerfectForward (std::move(st)): Mc! TPerfectForwardStrict (std::move(st)): Mc! TMultiVariant (std::move(st)): McRr! TMultiVariantStrict (std::move(st)): McRr! TConstRef (TStruct(6)): VcCcD TConstRefAndRvalueRef (TStruct(6)): VcMcRrD TConstRvalueRef (TStruct(6)): VcCcD TValueMove (TStruct(6)): VcMcD TConstValueMove (TStruct(6)): VcCcD TPerfectForward (TStruct(6)): VcMcD TPerfectForwardStrict (TStruct(6)): VcMcD TMultiVariant (TStruct(6)): VcMcRrD TMultiVariantStrict (TStruct(6)): VcMcRrD TConstRef (get_st()): VcCcD TConstRefAndRvalueRef (get_st()): VcMcRrD TConstRvalueRef (get_st()): VcCcD TValueMove (get_st()): VcMcD TConstValueMove (get_st()): VcCcD TPerfectForward (get_st()): VcMcD TPerfectForwardStrict (get_st()): VcMcD TMultiVariant (get_st()): VcMcRrD TMultiVariantStrict (get_st()): VcMcRrD TConstRef (5): VcCcD TConstRefAndRvalueRef (5): VcMcRrD TConstRvalueRef (5): VcCcD TValueMove (5): VcMcD TConstValueMove (5): VcCcD TPerfectForward (5): Vc TMultiVariant (5): VcPf TMultiVariantStrict (5): VcMcRrD TRef set(st): Ca- TConstRef set(st): Ca- TConstRefAndRvalueRef set(st): SlCa- TValueMove set(st): CcMaD- TConstValueMove set(st): CcCaD- TPerfectForward set(st): Ca- TPerfectForwardStrict set(st): Ca- TMultiVariant set(st): SpCa- TMultiVariantStrict set(st): SpCa- TConstRef set(std::move(st)): Ca- TConstRefAndRvalueRef set(std::move(st)): SrMa! TConstRvalueRef set(std::move(st)): Ca- TValueMove set(std::move(st)): McMaD! TConstValueMove set(std::move(st)): McCaD! TPerfectForward set(std::move(st)): Ma!- TPerfectForwardStrict set(std::move(st)): Ma! TMultiVariant set(std::move(st)): SrMa! TMultiVariantStrict set(std::move(st)): SrMa! TConstRef set(TStruct(8)): VcCaD TConstRefAndRvalueRef set(TStruct(8)): VcSrMaD TConstRvalueRef set(TStruct(8)): VcCaD TValueMove set(TStruct(8)): VcMaD TConstValueMove set(TStruct(8)): VcCaD TPerfectForward set(TStruct(8)): VcMaD TPerfectForwardStrict set(TStruct(8)): VcMaD TMultiVariant set(TStruct(8)): VcSrMaD TMultiVariantStrict set(TStruct(8)): VcSrMaD TConstRef set(get_st()): VcCaD TConstRefAndRvalueRef set(get_st()): VcSrMaD TConstRvalueRef set(get_st()): VcCaD TValueMove set(get_st()): VcMaD TConstValueMove set(get_st()): VcCaD TPerfectForward set(get_st()): VcMaD TPerfectForwardStrict set(get_st()): VcMaD TMultiVariant set(get_st()): VcSrMaD TMultiVariantStrict set(get_st()): VcSrMaD st = 3: Va TConstRef set(4): VcCaD TConstRefAndRvalueRef set(4): VcSrMaD TConstRvalueRef set(4): VcCaD TValueMove set(4): VcMaD TConstValueMove set(4): VcCaD TPerfectForward set(4): Va TMultiVariant set(4): SpVa TMultiVariantStrict set(4): VcSrMaD DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD */</span></span></span></span></code> </pre> </div></div><br><p> <strong>Links:</strong> <br> <a href="https://www.youtube.com/watch%3Fv%3DxnqTKD8uD64%26feature%3Dyoutu.be%26t%3D3209" rel="nofollow">CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"</a> <br> <a href="https://github.com/CppCon/CppCon2014/blob/master/Presentations/Back%2520to%2520the%2520Basics!%2520Essentials%2520of%2520Modern%2520C%252B%252B%2520Style/Back%2520to%2520the%2520Basics!%2520Essentials%2520of%2520Modern%2520C%252B%252B%2520Style%2520-%2520Herb%2520Sutter%2520-%2520CppCon%25202014.pdf" rel="nofollow">PDF presentation</a> <br> <a href="https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring" rel="nofollow">Meaning of acronym SSO in the context of std::string</a> <br> <a href="https://stackoverflow.com/questions/26261007/why-is-value-taking-setter-member-functions-not-recommended-in-herb-sutters-cpp" rel="nofollow">Why is value taking setter member functions not recommended in Herb Sutter's CppCon 2014 talk (Back to Basics: Modern C++ Style)?</a> <br> <a href="https://stackoverflow.com/questions/26147491/whats-the-correct-enable-if-constraint-on-perfect-forwarding-setter" rel="nofollow"><code>What's the correct enable_if</code> constraint on perfect forwarding setter?</a> <br> <a href="https://mpark.github.io/programming/2014/06/07/beware-of-perfect-forwarding-constructors/" rel="nofollow">Beware of Perfect Forwarding Constructors</a> </p><br><h1 id="why-other-variants-of-passing-to-constructor-or-setter-are-less-used"> Why other variants of passing to constructor or setter are less used </h1><br><ul><li> T&amp; — cannot accept rvalue. Is the same as "const T&amp;" variant, but less safe. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> C(T&amp; X) : x(X) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = X; } T x; };</code> </pre> </li><li> const T&amp;&amp; move — does not allow move due to prohibiting change of passed object. Not used. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp;&amp; X) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp;&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X); } T x; };</code> </pre> </li><li> const T move — does not allow move due to prohibiting change of passed object. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> C(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TX) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X)) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TX)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(X); } T x; };</code> </pre> </li><li> const Perfect forwarding (PF) — will not compile <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Z&gt; C(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Z&amp;&amp; X) : x(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X)) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Z&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Z&amp;&amp; X)</span></span></span><span class="hljs-function"> </span></span>{ x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Z&gt;(X); } T x; };</code> </pre> </li></ul><br><img src="https://habrastorage.org/webt/yh/yw/lu/yhywlupwrd8x9mkmessxd8tohoc.png"><br><br><h1 id="working-with-smart-pointers"> Working with smart pointers </h1><br><ul><li> Do not pass shared_ptr (or other countref alternatives) by value, if you do not need to count references (reduces performance due to atomic operations with counter) — prefer passing objects by * or &amp; as usual. </li><li> Do not pass shared_ptr (or other countref alternatives) by reference or const reference, if you do not need to count references — prefer passing objects by * or &amp; as usual. </li><li> If fabric has to return a polymorphic type (and thus cannot return by value), return unique_ptr, which can be converted to shared_ptr if needed (or return shared_ptr if you are sure that it will always be needed intead of unique_ptr) </li><li> If a function will need to decide if it wants to copy a shared_ptr or not — you can pass a const shared_ptr&amp; to it </li><li> Never dereference or call a method of non-local shared_ptr, because this puts object outside of shared_ptr control (instead, first make a local copy of shared_ptr). Example: </li></ul><br><img src="https://habrastorage.org/webt/oz/kw/dd/ozkwddosyw2igdar_pdmycwws0m.png"><br><hr><br><p> <strong>Links:</strong> </p><br><p> <a href="https://www.youtube.com/watch%3Fv%3DxnqTKD8uD64%26feature%3Dyoutu.be%26t%3D3209" rel="nofollow">CppCon 2014: Herb Sutter "Back to the Basics! Essentials of Modern C++ Style"</a> <br> <a href="https://github.com/CppCon/CppCon2014/blob/master/Presentations/Back%2520to%2520the%2520Basics!%2520Essentials%2520of%2520Modern%2520C%252B%252B%2520Style/Back%2520to%2520the%2520Basics!%2520Essentials%2520of%2520Modern%2520C%252B%252B%2520Style%2520-%2520Herb%2520Sutter%2520-%2520CppCon%25202014.pdf" rel="nofollow">PDF presentation</a> <br> <a href="https://stackoverflow.com/questions/57714186/what-is-an-aliased-local-shared-ptr-in-this-example" rel="nofollow">What is an 'aliased local shared_ptr' in this example?</a> </p><br><p> <em>Some of the used images were taken from the linked articles</em> </p><br><hr><br><p> <a href="https://habr.com/en/post/479342/">Go to Part 1</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479358/">https://habr.com/ru/post/de479358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479348/index.html">Roscosmos wäre eine sinnvolle Entsprechung zum Spinoff-Programm</a></li>
<li><a href="../de479350/index.html">Tooltips in FAQ.Net beachten Programm oder Navigation in RTF-Dokumenten, ohne die Dokumente selbst zu ändern</a></li>
<li><a href="../de479352/index.html">Enter IT: Meine Forschung zum Umstieg auf IT aus anderen Branchen</a></li>
<li><a href="../de479354/index.html">Telegram Open Network: Theorie und Praxis vom Netzwerkvalidator</a></li>
<li><a href="../de479356/index.html">Hintergrund: Das Wichtigste an den neuen "Steckern" AirPods Pro</a></li>
<li><a href="../de479360/index.html">Erstellen Sie mit wenigen Klicks ein Open-Source-Projekt für Angels</a></li>
<li><a href="../de479364/index.html">Bewertung der besten CPUs für Gaming-PCs im Jahr 2019</a></li>
<li><a href="../de479366/index.html">Mobile Umfrageergebnisse von Freitag</a></li>
<li><a href="../de479368/index.html">So erreichen Sie CMM Level 5 QS und Testen</a></li>
<li><a href="../de479370/index.html">Selbstgemachte Erfassung von Mifare-Kryptoschlüsseln und Selbstkopieren von IronLogic-Türsprechschlüsseln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>