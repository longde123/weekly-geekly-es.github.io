<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞 🧙🏿 📥 Déploiement sans interruption et bases de données 🙍🏿 🤳🏾 🙎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explique en détail comment résoudre les problèmes associés à la compatibilité de la base de données lors du déploiement. Nous vous dirons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Déploiement sans interruption et bases de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/481932/"><p><img src="https://habrastorage.org/webt/hr/vy/qq/hrvyqqi2mmitehw9vx_xklbofj8.png" alt="image"></p><br><p>  Cet article explique en détail comment résoudre les problèmes associés à la compatibilité de la base de données lors du déploiement.  Nous vous dirons ce qui peut arriver à vos applications sur le prod si vous essayez d'effectuer un déploiement sans aucune préparation préalable.  Ensuite, nous passerons par les étapes du cycle de vie de l'application, qui sont nécessaires pour avoir un temps d'arrêt nul ( <em>environ Transl.: Plus loin - zéro temps d'arrêt</em> ).  Le résultat de nos opérations sera l'application d'un changement de base de données incompatible en amont d'une manière compatible en amont. </p><a name="habracut"></a><br><p>  Si vous voulez comprendre les exemples de code de l'article, vous les trouverez sur <a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">GitHub</a> . </p><br><h2 id="vvedenie">  Présentation </h2><br><h3 id="zero-downtime-deployment">  Déploiement sans temps d'arrêt </h3><br><p>  Qu'est-ce que le <strong>déploiement</strong> mystique <strong>zéro temps d'arrêt</strong> ?  Nous pouvons le dire lorsque votre application est déployée afin que vous puissiez introduire avec succès une nouvelle version de l'application pour la production, tandis que l'utilisateur ne remarque pas son inaccessibilité.  Du point de vue de l'utilisateur et de l'entreprise, c'est le meilleur scénario de déploiement possible, car vous pouvez ainsi introduire de nouvelles fonctions et éliminer les erreurs sans interruption. </p><br><p>  Comment y parvenir?  Il y a plusieurs façons, en voici une: </p><br><ul><li>  étendre la version 1 de votre service </li><li>  migrer la base de données </li><li>  déployer la version 2 de votre service en parallèle avec la version 1 </li><li>  dès que vous voyez que la version numéro 2 fonctionne comme il se doit, supprimez la version numéro 1 </li><li>  c'est fait! </li></ul><br><p>  Facile, non?  Malheureusement, ce n'est pas si simple, et nous l'examinerons en détail plus tard.  Voyons maintenant un autre processus de déploiement assez courant - le déploiement bleu vert. </p><br><p>  Avez-vous déjà entendu parler du <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">déploiement bleu vert</a> ?  Avec Cloud Foundry, c'est extrêmement facile à faire.  Jetez un œil à <a href="https://spring.io/blog/2014/04/04/project-sagan-zero-downtime-deployments">cet article</a> où nous le décrivons plus en détail.  En résumant brièvement, nous rappelons comment faire un déploiement bleu vert: </p><br><ul><li>  <em>Assurer le fonctionnement de deux copies de votre code de production («bleu» et «vert»);</em> </li><li>  <em>diriger tout le trafic vers l'environnement bleu, c'est-à-dire</em>  <em>afin que les URL de production y soient pointées;</em> </li><li>  <em>Déployez et testez toutes les modifications apportées aux applications dans un environnement vert</em> </li><li>  <em>passer des URL du bleu au vert</em> </li></ul><br><p>  Le déploiement Blue Green est une approche qui vous permet d'introduire facilement de nouvelles fonctionnalités sans craindre une interruption de la production.  Cela est dû au fait que même si quelque chose se produit, vous pouvez facilement revenir à l'environnement précédent en cliquant simplement sur un commutateur. </p><br><p>  Après avoir lu tout ce qui précède, vous pouvez vous poser la question: qu'est-ce que le temps d'arrêt zéro a à voir avec le déploiement Blue green? </p><br><p>  Eh bien, ils ont beaucoup en commun, car prendre en charge deux copies du même environnement nécessite un double effort pour les maintenir.  C'est pourquoi certaines équipes, selon <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html">Martin Fowler</a> , adhèrent aux variations de cette approche: </p><br><p> <em>une autre option consiste à utiliser la même base de données, créant des commutateurs bleu-vert pour les couches Web et de domaine.</em>  <em>Dans cette approche, les bases de données peuvent souvent être un problème, en particulier lorsque vous devez modifier son schéma pour prendre en charge une nouvelle version du logiciel.</em> </p><br><p>  Et nous arrivons ici au problème principal de cet article.  <strong>La base de données</strong> .  Jetons un autre regard sur cette phrase. </p><br><p>  <em>migrer la base de données.</em> </p><br><p>  Maintenant, vous devez vous poser la question - que faire si le changement de la base de données est incompatible en amont?  Ma première version de l'application ne se cassera-t-elle pas?  En fait, c'est exactement ce qui va se passer ... </p><br><p>  Ainsi, même en dépit des avantages énormes d'un déploiement sans interruption de service / bleu vert, les entreprises ont tendance à suivre le processus de déploiement plus sûr suivant pour leurs applications: </p><br><ul><li>  préparer un package avec une nouvelle version de l'application </li><li>  fermer une application en cours d'exécution </li><li>  exécuter des scripts pour la migration de la base de données </li><li>  déployer et lancer la nouvelle version de l'application </li></ul><br><p>  Dans cet article, nous décrirons en détail comment vous pouvez travailler avec une base de données et du code pour tirer parti du déploiement sans interruption de service. </p><br><h3 id="problemy-s-bazoy-dannyh">  Problèmes de base de données </h3><br><p>  Si vous avez une application sans état qui ne stocke aucune donnée dans la base de données, vous pouvez obtenir immédiatement un déploiement sans interruption.  Malheureusement, la plupart des logiciels doivent stocker des données quelque part.  C'est pourquoi vous devriez réfléchir à deux fois avant d'apporter des modifications au circuit.  Avant de nous plonger dans les détails de la façon de modifier le schéma afin qu'il devienne possible de le déployer sans temps d'arrêt, concentrons-nous d'abord sur le schéma de contrôle de version. </p><br><h3 id="shema-upravleniya-versiyami">  Schéma de contrôle de version </h3><br><p> Dans cet article, nous utiliserons <a href="https://flywaydb.org/">Flyway</a> comme outil de contrôle de version ( <em>environ Transl.: Nous parlons de migration de base de données</em> ).  Naturellement, nous écrirons également une application Spring Boot qui prend en charge Flyway et migrera le circuit lors de la configuration du contexte de l'application.  Lorsque vous utilisez Flyway, vous pouvez stocker des scripts de migration dans votre dossier de projets (par défaut dans <code>classpath:db/migration</code> ).  Ici, vous pouvez voir un exemple de ces fichiers de migration. </p><br><pre> <code class="plaintext hljs">└── db └── migration ├── V1__init.sql ├── V2__Add_surname.sql ├── V3__Final_migration.sql └── V4__Remove_lastname.sql</code> </pre> <br><p>  Dans cet exemple, nous voyons 4 scénarios de migration qui, s'ils n'ont pas été exécutés plus tôt, seront exécutés l'un après l'autre au démarrage de l'application.  Regardons un des fichiers ( <code>V1__init.sql</code> ) comme exemple. </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Tout parle parfaitement de lui-même: vous pouvez utiliser SQL pour déterminer comment votre base de données doit être modifiée.  Pour plus d'informations sur Spring Boot et Flyway, consultez <a href="https://docs.spring.io/spring-boot/docs/1.3.5.RELEASE/reference/html/howto-database-initialization.html">Spring Boot Docs</a> . </p><br><p>  L'utilisation du contrôle de version avec Spring Boot vous offre 2 grands avantages: </p><br><ul><li>  vous séparez les modifications de la base de données des modifications du code </li><li>  la migration de la base de données se produit lors du déploiement de votre application, c'est-à-dire  votre processus de déploiement est simplifié </li></ul><br><h2 id="reshenie-problem-s-bazoy-dannyh">  Résolution des problèmes de base de données </h2><br><p>  Dans la prochaine section de l'article, nous nous concentrerons sur l'examen de deux approches des modifications de la base de données. </p><br><ul><li>  incompatibilité vers l'arrière </li><li>  compatibilité descendante </li></ul><br><p>  Le premier sera considéré comme un avertissement selon lequel vous ne devez pas effectuer un déploiement sans interruption de service sans préparation préalable ... Le second offre une solution sur la façon dont vous pouvez effectuer un déploiement sans interruption de service et en même temps maintenir la compatibilité descendante. </p><br><p>  Notre projet, sur lequel nous travaillerons, sera une simple application Spring Boot Flyway dans laquelle il y a une <code>Person</code> avec <code>first_name</code> et <code>last_name</code> dans la base de données ( <em>environ par <code>Person</code> : <code>Person</code> est une table, et <code>irst_name</code> et nom de <code>last_name</code> sont les champs qu'elle <code>last_name</code></em> ).  Nous voulons renommer <code>last_name</code> en <code>surname</code> de <code>surname</code> . </p><br><h3 id="dopuscheniya">  Hypothèses </h3><br><p>  Avant de nous plonger dans les détails, nous devons définir quelques hypothèses sur nos applications.  Le principal résultat que nous voulons atteindre sera un processus assez simple. </p><br><blockquote>  <strong>Remarque</strong>  Entreprise PRO-TIP.  La rationalisation des processus peut vous faire économiser beaucoup d'argent en support (plus il y a de personnes travaillant dans votre entreprise, plus vous pouvez économiser)! </blockquote><br><h3 id="ne-nado-delat-otkat-bazy-dannyh">  Pas besoin de restaurer la base de données </h3><br><p>  Cela simplifie le processus de déploiement (certaines restaurations de base de données sont presque impossibles, par exemple, la suppression de la restauration).  Nous préférons annuler uniquement les demandes.  De cette façon, même si vous avez différentes bases de données (par exemple SQL et NoSQL), votre pipeline de déploiement sera identique. </p><br><p>  <strong>Il doit être TOUJOURS possible de restaurer l'application d'une version en arrière (pas plus)</strong> </p><br><p>  La restauration ne doit être effectuée que si nécessaire.  S'il y a une erreur dans la version actuelle qui n'est pas facile à corriger, nous devrions pouvoir renvoyer la dernière version de travail.  Nous supposons que cette dernière version de travail est la précédente.  Maintenir la compatibilité du code et de la base de données pour plusieurs déploiements serait extrêmement difficile et coûteux. </p><br><blockquote>  <strong>Remarque</strong>  Pour une meilleure lisibilité, dans le cadre de cet article nous allons changer la version majeure de l'application. </blockquote><br><h3 id="shag-1-ishodnoe-sostoyanie">  Étape 1: état initial </h3><br><p>  Version d'application: <code>1.0.0</code> <br>  Version DB: <code>v1</code> </p><br><h3 id="kommentariy">  Commentaire </h3><br><p>  Ce sera l'état initial de l'application. </p><br><h3 id="izmeneniya-bd">  Modifications de la base de données </h3><br><p>  La base de données contient <code>last_name.</code> </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><h3 id="izmeneniya-koda">  Modifications du code </h3><br><p>  L'application enregistre les données de la personne dans <code>last_name</code> : </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return this.lastName; } public void setLastName(String lastname) { this.lastName = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + "]"; } }</code> </pre> <br><h3 id="obratno-nesovmestimoe-pereimenovanie-stolbca">  Renommage de colonne incompatible </h3><br><p>  Voyons un exemple de modification d'un nom de colonne: </p><br><blockquote>  <strong>Attention</strong>  L'exemple suivant se casse intentionnellement.  Nous le montrons afin de démontrer le problème de compatibilité de la base de données. </blockquote><p>  Version d'application: <code>2.0.0.BAD</code> </p><br><p>  Version DB: <code>v2bad</code> </p><br><h3 id="kommentariy-1">  Commentaire </h3><br><p>  Les modifications actuelles ne nous permettent PAS d'exécuter deux instances (ancienne et nouvelle) en même temps.  Ainsi, un déploiement sans temps d'arrêt sera difficile à réaliser (hypothèses prises en compte, cela est pratiquement impossible). </p><br><h3 id="ab-testirovanie">  Test A / B </h3><br><p>  La situation actuelle est que nous avons une version d'application <code>1.0.0,</code> déployée dans prod, et une base de données <code>v1</code> .  Nous devons déployer la deuxième instance de l'application, la version <code>2.0.0.BAD</code> , et mettre à niveau la base de données vers <code>v2bad</code> . </p><br><p>  Étapes: </p><br><ol><li>  déployé une nouvelle instance de la version d'application <code>2.0.0.BAD</code> , qui met à jour la base de données vers <code>v2bad</code> </li><li>  la colonne <code>last_name</code> n'existe plus dans la base de données <code>v2bad</code> - elle a été changée en <code>surname</code> </li><li>  Les mises à jour des bases de données et des applications ont réussi et certaines instances fonctionnent dans <code>1.0.0</code> , d'autres dans <code>2.0.0.BAD</code> .  Toutes liées à la <code>v2bad</code> </li><li>  toutes les instances de la version <code>1.0.0</code> commenceront à générer des erreurs car elles essaieront d'insérer des données dans la colonne <code>last_name</code> , qui n'est plus </li><li>  toutes les instances de la version <code>2.0.0.BAD</code> fonctionneront sans problème </li></ol><br><p>  Comme vous pouvez le voir, si nous apportons des modifications incompatibles à la base de données et aux applications, les tests A / B sont impossibles. </p><br><h3 id="otkat-prilozheniya">  Application de restauration </h3><br><p>  Supposons qu'après avoir essayé d'effectuer un déploiement A / B ( <em>environ. Transl.: Probablement, l'auteur faisait référence aux tests A / B ici</em> ), nous avons décidé que nous devions restaurer l'application à la version <code>1.0.0.</code>  Supposons que nous ne voulons pas restaurer la base de données. </p><br><p>  Étapes: </p><br><ol><li>  nous arrêtons l'instance d'application version <code>2.0.0.BAD</code> </li><li>  la base de données est toujours <code>v2bad</code> </li><li>  comme la version <code>1.0.0</code> ne comprend pas le <code>surname</code> , nous verrons des erreurs </li><li>  l'enfer s'est libéré, nous ne pouvons plus revenir </li></ol><br><p>  Comme vous pouvez le voir, si nous apportons des modifications incompatibles à la base de données et aux applications, nous ne pouvons pas revenir à la version précédente. </p><br><h3 id="logi-ispolneniya-skripta">  Journaux d'exécution des scripts </h3><br><pre> <code class="plaintext hljs">Backward incompatible scenario: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0.BAD 05) Wait for the app (2.0.0.BAD) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 &lt;-- this should fail 07) Generate a person by calling POST localhost:9992/person to version 2.0.0.BAD &lt;-- this should pass Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"b73f639f-e176-4463-bf26-1135aace2f57","lastName":"b73f639f-e176-4463-bf26-1135aace2f57"} Starting app in version 2.0.0.BAD Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: curl: (22) The requested URL returned error: 500 Internal Server Error Generate a person in version 2.0.0.BAD Sending a post to 127.0.0.1:9995/person. This is the response: {"firstName":"e156be2e-06b6-4730-9c43-6e14cfcda125","surname":"e156be2e-06b6-4730-9c43-6e14cfcda125"}</code> </pre> <br><h3 id="izmeneniya-bd-1">  Modifications de la base de données </h3><br><p>  Script de migration qui renomme <code>last_name</code> en <code>surname</code> de <code>surname</code> </p><br><p>  Script source Flyway: </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Un script qui renomme <code>last_name</code> . </p><br><pre> <code class="plaintext hljs">-- This change is backward incompatible - you can't do A/B testing ALTER TABLE PERSON CHANGE last_name surname VARCHAR;</code> </pre> <br><h3 id="izmeneniya-koda-1">  Modifications du code </h3><br><p>  Nous avons changé le nom du champ <code>lastName</code> nom de <code>surname</code> . </p><br><h3 id="pereimenovanie-stolbca-obratno-sovmestimym-sposobom">  Renommer une colonne d'une manière rétrocompatible </h3><br><p>  C'est la situation la plus courante que nous pouvons rencontrer.  Nous devons apporter des modifications incompatibles en amont.  Nous avons déjà prouvé que pour un déploiement sans temps d'arrêt, nous ne devons pas simplement appliquer la migration de base de données sans actions supplémentaires.  Dans cette section de l'article, nous effectuerons 3 déploiements de l'application ainsi que des migrations de base de données afin d'atteindre le résultat souhaité et en même temps de maintenir la compatibilité descendante. </p><br><blockquote>  <strong>Remarque</strong>  Rappelons que nous avons une version de base de données <code>v1</code> .  Il contient les colonnes <code>last_name</code> et <code>last_name</code> .  Nous devons changer le <code>last_name</code> de <code>surname</code> en <code>surname</code> de <code>surname</code> .  Nous avons également une version d'application <code>1.0.0,</code> qui n'utilise pas encore de <code>surname</code> . </blockquote><br><h3 id="shag-2-dobavlyaem-surname">  Étape 2: ajouter le nom de famille </h3><br><p>  Version d'application: <code>2.0.0</code> <br>  Version DB: <code>v2</code> </p><br><h3 id="kommentariy-2">  Commentaire </h3><br><p>  En ajoutant une nouvelle colonne et en copiant son contenu, nous créons des modifications de base de données rétrocompatibles.  Dans le même temps, si nous restaurons le JAR ou si nous avons un ancien JAR fonctionnel, il ne se cassera pas lors de l'exécution. </p><br><h3 id="vykatyvaem-novuyu-versiyu">  Nous déployons la nouvelle version </h3><br><p>  Étapes: </p><br><ol><li>  migrer la base de données pour créer une nouvelle colonne de <code>surname</code> .  Maintenant, votre version db <code>v2</code> </li><li>  copier les données du <code>last_name</code> de <code>surname</code> vers le <code>surname</code> de <code>surname</code> .  <strong>Notez</strong> que si vous avez beaucoup de ces données, vous devriez envisager la migration par lots! </li><li>  écrire du code où les deux la <strong>nouvelle</strong> et l' <strong>ancienne</strong> colonne sont utilisées.  Maintenant, votre application version <code>2.0.0</code> </li><li>  lire la valeur de la colonne du <code>surname</code> si elle n'est pas <code>null</code> , ou de l <code>ast_name</code> si le <code>surname</code> pas spécifié.  Vous pouvez supprimer <code>getLastName()</code> du code, car il renverra <code>null</code> lorsque vous restaurez votre application de <code>3.0.0</code> à <code>2.0.0</code> . </li></ol><br><p>  Si vous utilisez Spring Boot Flyway, ces deux étapes seront effectuées lors du lancement de la version <code>2.0.0</code> application.  Si vous exécutez manuellement l'outil de gestion des versions de la base de données, vous devrez effectuer deux opérations différentes pour cela (mettre à jour la version db manuellement, puis déployer une nouvelle application). </p><br><blockquote>  <strong>C'est important.</strong>  N'oubliez pas qu'une colonne nouvellement créée <strong>NE</strong> <strong>DOIT</strong> <strong>PAS</strong> être <strong>NON NULL</strong> .  Si vous rétrogradez, l'ancienne application ne connaît pas la nouvelle colonne et ne l'installe pas lors de l' <code>Insert.</code>  Mais si vous ajoutez cette restriction, et votre base de données sera <code>v2</code> , il faudra définir la valeur de la nouvelle colonne.  Ce qui entraînera des violations des restrictions. <br><br>  <strong>C'est important.</strong>  Vous devez supprimer la méthode <code>getLastName()</code> , car la version <code>3.0.0</code> <code>getLastName()</code> pas le concept d'une colonne <code>last_name</code> dans le code.  Cela signifie que null y sera défini.  Vous pouvez quitter la méthode et ajouter <code>null</code> vérifications <code>null</code> , mais une bien meilleure solution serait de vous assurer que dans la logique <code>getSurname()</code> vous avez choisi la bonne valeur non nulle. </blockquote><br><h3 id="ab-testirovanie-1">  Test A / B </h3><br><p>  La situation actuelle est que nous avons une version d'application <code>1.0.0</code> déployée sur le prod et une base de données en <code>v1</code> .  Nous devons déployer la deuxième instance de la version <code>2.0.0</code> de l'application, qui mettra à niveau la base de données vers la <code>v2</code> . </p><br><p>  Étapes: </p><br><ol><li>  déployé une nouvelle instance de l'application version <code>2.0.0</code> , qui met à jour la base de données vers la <code>v2</code> </li><li>  Pendant ce temps, certaines demandes ont été traitées par des instances de la version <code>1.0.0</code> </li><li>  la mise à jour a réussi et vous disposez de plusieurs instances de travail de la version d'application <code>1.0.0</code> et du reste de la version <code>2.0.0.</code>  Tout le monde communique avec la base de données en <code>v2</code> </li><li>  la version <code>1.0.0</code> n'utilise pas la colonne de nom de famille dans la base de données, mais la version <code>2.0.0</code> utilise.  Ils n'interfèrent pas entre eux et il ne devrait pas y avoir d'erreurs. </li><li>  la version <code>2.0.0</code> stocke les données dans l'ancienne et la nouvelle colonne, ce qui offre une compatibilité descendante </li></ol><br><blockquote>  <strong>C'est important.</strong>  Si vous avez des requêtes qui comptent les éléments en fonction des valeurs de l'ancienne / nouvelle colonne, vous devez vous rappeler que vous avez maintenant des valeurs en double (très probablement, elles migrent toujours).  Par exemple, si vous souhaitez compter le nombre d'utilisateurs dont le nom de famille (quel que soit le nom de la colonne) commence par la lettre <code>A</code> , avant que la migration des données ( <code>old</code> → <code>new</code> colonne) ne soit terminée, vous risquez d'avoir des données incohérentes si vous exécutez une requête sur une nouvelle colonne. </blockquote><br><h3 id="otkat-prilozheniya-1">  Application de restauration </h3><br><p>  Nous avons maintenant une version d'application <code>2.0.0</code> et une base de données en <code>v2</code> . </p><br><p>  Étapes: </p><br><ol><li>  restaurez votre application à la version <code>1.0.0</code> . </li><li>  la version <code>1.0.0</code> n'utilise pas la colonne de <code>surname</code> dans la base de données, donc la restauration doit être réussie </li></ol><br><h3 id="izmeneniya-db">  Modifications de la base de données </h3><br><p>  La base de données contient une colonne nommée <code>last_name</code> . </p><br><p>  Script source Flyway: </p><br><pre> <code class="plaintext hljs">CREATE TABLE PERSON ( id BIGINT GENERATED BY DEFAULT AS IDENTITY, first_name varchar(255) not null, last_name varchar(255) not null ); insert into PERSON (first_name, last_name) values ('Dave', 'Syer');</code> </pre> <br><p>  Le script pour ajouter le <code>surname</code> . </p><br><blockquote>  <strong>Attention</strong>  N'oubliez pas que vous NE POUVEZ PAS AJOUTER de contraintes NOT NULL à la colonne ajoutée.  Si vous restaurez le JAR, l'ancienne version n'a aucune idée de la colonne ajoutée et la définira automatiquement sur NULL.  S'il existe une telle restriction, l'ancienne application se cassera simplement. </blockquote><br><pre> <code class="plaintext hljs">-- NOTE: This field can't have the NOT NULL constraint cause if you rollback, the old version won't know about this field -- and will always set it to NULL ALTER TABLE PERSON ADD surname varchar(255); -- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES UPDATE PERSON SET PERSON.surname = PERSON.last_name</code> </pre> <br><h3 id="izmeneniya-koda-2">  Modifications du code </h3><br><p>  Nous stockons les données dans le <code>last_name</code> et le <code>surname</code> .  Dans le même temps, nous lisons dans <code>last_name</code> , car cette colonne est la plus pertinente.  Au cours du processus de déploiement, certaines demandes peuvent avoir été traitées par une instance d'application qui n'a pas encore été mise à jour. </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String lastName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } /** * Reading from the new column if it's set. If not the from the old one. * * When migrating from version 1.0.0 -&gt; 2.0.0 this can lead to a possibility that some data in * the surname column is not up to date (during the migration process lastName could have been updated). * In this case one can run yet another migration script after all applications have been deployed in the * new version to ensure that the surname field is updated. * * However it makes sense since when looking at the migration from 2.0.0 -&gt; 3.0.0. In 3.0.0 we no longer * have a notion of lastName at all - so we don't update that column. If we rollback from 3.0.0 -&gt; 2.0.0 if we * would be reading from lastName, then we would have very old data (since not a single datum was inserted * to lastName in version 3.0.0). */ public String getSurname() { return this.surname != null ? this.surname : this.lastName; } /** * Storing both FIRST_NAME and SURNAME entries */ public void setSurname(String surname) { this.lastName = surname; this.surname = surname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", lastName=" + this.lastName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-3-udalenie-last_name-iz-koda">  Étape 3: suppression du nom de famille du code </h3><br><p>  Version d'application: <code>3.0.0</code> </p><br><p>  Version DB: <code>v3</code> </p><br><h3 id="kommentariy-3">  Commentaire </h3><br><p>  <em>Remarque</em>  <em>Lane: Apparemment, dans l'article d'origine, l'auteur a copié par erreur le texte de ce bloc de l'étape 2. À cette étape, des modifications doivent être apportées au code d'application visant à supprimer la fonctionnalité qui utilise la colonne <code>last_name</code> .</em> </p><br><p>  En ajoutant une nouvelle colonne et en copiant son contenu, nous avons créé des modifications de base de données rétrocompatibles.  De plus, si nous rétrogradons le JAR ou si nous avons un ancien JAR fonctionnel, il ne se cassera pas lors de l'exécution. </p><br><h3 id="otkat-prilozheniya-2">  Application de restauration </h3><br><p>  Nous avons actuellement l'application version <code>3.0.0</code> et la base de données <code>v3</code> .  La version <code>3.0.0</code> n'enregistre pas les données dans <code>last_name</code> .  Cela signifie que le <code>surname</code> stocke les informations les plus récentes. </p><br><p>  Étapes: </p><br><ol><li>  restaurez votre application à la version <code>2.0.0</code> . </li><li>  la version <code>2.0.0</code> utilise à la fois le <code>last_name</code> et le <code>surname</code> . </li><li>  la version <code>2.0.0</code> prendra le <code>surname</code> s'il n'est pas nul, sinon <code>last_name</code> </li></ol><br><h3 id="izmeneniya-bd-2">  Modifications de la base de données </h3><br><p>  Il n'y a aucun changement structurel dans la base de données.  Le script suivant est exécuté, qui effectue la migration finale des anciennes données: </p><br><pre> <code class="plaintext hljs">-- WE'RE ASSUMING THAT IT'S A FAST MIGRATION - OTHERWISE WE WOULD HAVE TO MIGRATE IN BATCHES -- ALSO WE'RE NOT CHECKING IF WE'RE NOT OVERRIDING EXISTING ENTRIES. WE WOULD HAVE TO COMPARE -- ENTRY VERSIONS TO ENSURE THAT IF THERE IS ALREADY AN ENTRY WITH A HIGHER VERSION NUMBER -- WE WILL NOT OVERRIDE IT. UPDATE PERSON SET PERSON.surname = PERSON.last_name; -- DROPPING THE NOT NULL CONSTRAINT; OTHERWISE YOU WILL TRY TO INSERT NULL VALUE OF THE LAST_NAME -- WITH A NOT_NULL CONSTRAINT. ALTER TABLE PERSON MODIFY COLUMN last_name varchar(255) NULL DEFAULT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-3">  Modifications du code </h3><br><p>  <em>Remarque</em>  <em>trans.: La description de ce bloc a également été copiée par erreur par l'auteur de l'étape 2. Conformément à la logique de l'histoire de l'article, les modifications du code à cette étape devraient viser à en supprimer les éléments qui fonctionnent avec la colonne <code>last_name</code> .</em> </p><br><p>  Nous stockons les données dans le <code>last_name</code> et le <code>surname.</code>  De plus, nous lisons dans la colonne <code>last_name</code> , car elle est la plus pertinente.  Au cours du processus de déploiement, certaines demandes peuvent être traitées par une instance qui n'a pas encore été mise à jour. </p><br><pre> <code class="plaintext hljs">/* * Copyright 2012-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package sample.flyway; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; @Entity public class Person { @Id @GeneratedValue private Long id; private String firstName; private String surname; public String getFirstName() { return this.firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getSurname() { return this.surname; } public void setSurname(String lastname) { this.surname = lastname; } @Override public String toString() { return "Person [firstName=" + this.firstName + ", surname=" + this.surname + "]"; } }</code> </pre> <br><h3 id="shag-4-udalenie-last_name-iz-bd">  Étape 4: suppression de last_name de la base de données </h3><br><p>  Version d'application: <code>4.0.0</code> </p><br><p>  Version DB: <code>v4</code> </p><br><h3 id="kommentariy-4">  Commentaire </h3><br><p>  Étant donné que le code de la version <code>3.0.0</code> n'utilisait pas la colonne <code>last_name</code> , rien de mal ne se produira pendant l'exécution si nous revenons à <code>3.0.0</code> après avoir supprimé la colonne de la base de données. </p><br><h3 id="logi-ispolneniya-skripta-1">  Journaux d'exécution des scripts </h3><br><pre> <code class="plaintext hljs">We will do it in the following way: 01) Run 1.0.0 02) Wait for the app (1.0.0) to boot 03) Generate a person by calling POST localhost:9991/person to version 1.0.0 04) Run 2.0.0 05) Wait for the app (2.0.0) to boot 06) Generate a person by calling POST localhost:9991/person to version 1.0.0 07) Generate a person by calling POST localhost:9992/person to version 2.0.0 08) Kill app (1.0.0) 09) Run 3.0.0 10) Wait for the app (3.0.0) to boot 11) Generate a person by calling POST localhost:9992/person to version 2.0.0 12) Generate a person by calling POST localhost:9993/person to version 3.0.0 13) Kill app (3.0.0) 14) Run 4.0.0 15) Wait for the app (4.0.0) to boot 16) Generate a person by calling POST localhost:9993/person to version 3.0.0 17) Generate a person by calling POST localhost:9994/person to version 4.0.0 Starting app in version 1.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2","lastName":"52b6e125-4a5c-429b-a47a-ef18bbc639d2"} Starting app in version 2.0.0 Generate a person in version 1.0.0 Sending a post to 127.0.0.1:9991/person. This is the response: {"firstName":"e41ee756-4fa7-4737-b832-e28827a00deb","lastName":"e41ee756-4fa7-4737-b832-e28827a00deb"} Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","lastName":"0c1240f5-649a-4bc5-8aa9-cff855f3927f","surname":"0c1240f5-649a-4bc5-8aa9-cff855f3927f"} Killing app 1.0.0 Starting app in version 3.0.0 Generate a person in version 2.0.0 Sending a post to 127.0.0.1:9992/person. This is the response: {"firstName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","lastName":"74d84a9e-5f44-43b8-907c-148c6d26a71b","surname":"74d84a9e-5f44-43b8-907c-148c6d26a71b"} Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"c6564dbe-9ab5-40ae-9077-8ae6668d5862","surname":"c6564dbe-9ab5-40ae-9077-8ae6668d5862"} Killing app 2.0.0 Starting app in version 4.0.0 Generate a person in version 3.0.0 Sending a post to 127.0.0.1:9993/person. This is the response: {"firstName":"cbe942fc-832e-45e9-a838-0fae25c10a51","surname":"cbe942fc-832e-45e9-a838-0fae25c10a51"} Generate a person in version 4.0.0 Sending a post to 127.0.0.1:9994/person. This is the response: {"firstName":"ff6857ce-9c41-413a-863e-358e2719bf88","surname":"ff6857ce-9c41-413a-863e-358e2719bf88"}</code> </pre> <br><h3 id="izmeneniya-db-1">  Modifications de la base de données </h3><br><p>  Pour la <code>v3</code> nous <code>last_name</code> simplement la colonne <code>last_name</code> et ajoutons les contraintes manquantes. </p><br><pre> <code class="plaintext hljs">-- REMOVE THE COLUMN ALTER TABLE PERSON DROP last_name; -- ADD CONSTRAINTS UPDATE PERSON SET surname='' WHERE surname IS NULL; ALTER TABLE PERSON ALTER COLUMN surname VARCHAR NOT NULL;</code> </pre> <br><h3 id="izmeneniya-koda-4">  Modifications du code </h3><br><p>  Il n'y a aucun changement dans le code. </p><br><h3 id="vyvod">  Conclusion </h3><br><p>  Nous avons réussi à appliquer le changement de nom de colonne incompatible en amont en effectuant plusieurs déploiements compatibles en amont.  Voici un résumé des étapes franchies: </p><br><ol><li>  déploiement d'application version <code>1.0.0</code> avec schéma de base de données <code>v1</code> (nom de colonne = nom) </li><li>  déployer l'application version <code>2.0.0,</code> qui enregistre les données dans le <code>last_name</code> et le <code>surname</code> .  L'application lit à partir de <code>last_name</code> .  La base de données est en version <code>v2</code> , qui contient les colonnes du <code>surname. surname</code> et du <code>surname. surname</code>  <code>surname. surname</code> est une copie de l <code>ast_name</code> .  (REMARQUE: cette colonne ne doit pas avoir de contrainte non nulle) </li><li>    <code>3.0.0</code> ,      <code>surname</code>    surname.   ,     <code>last_name</code>  <code>surname</code> .   <strong>NOT NULL</strong>   <code>last_name</code> .     <code>v3</code> </li><li>    <code>4.0.0</code> —      .    <code>v4</code> ,   <code>last_name</code> .         . </li></ol><br><p>   ,        ,      / . </p><br><h3 id="kod">  Code </h3><br><p>  ,    ,   <a href="https://github.com/spring-cloud-samples/zero-downtime-deployment">Github</a> .   . </p><br><h3 id="proekty">  Les projets </h3><br><p>   ,     . </p><br><pre> <code class="plaintext hljs">├── boot-flyway-v1 - 1.0.0 version of the app with v1 of the schema ├── boot-flyway-v2 - 2.0.0 version of the app with v2 of the schema (backward-compatible - app can be rolled back) ├── boot-flyway-v2-bad - 2.0.0.BAD version of the app with v2bad of the schema (backward-incompatible - app cannot be rolled back) ├── boot-flyway-v3 - 3.0.0 version of the app with v3 of the schema (app can be rolled back) └── boot-flyway-v4 - 4.0.0 version of the app with v4 of the schema (app can be rolled back)</code> </pre> <br><h3 id="skripty">  </h3><br><p>    ,    ,         . </p><br><p>   <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_compatible.sh</code> </pre> <br><p>    <strong>    </strong> , : </p><br><pre> <code class="plaintext hljs">./scripts/scenario_backward_incompatible.sh</code> </pre> <br><h3 id="spring-boot-sample-flyway"> Spring Boot Sample Flyway </h3><br><p>     <code>Spring Boot Sample Flyway.</code> </p><br><p>     <code>http://localhost:8080/flyway</code> ,   . </p><br><p>        H2 (  <code>http://localhost:8080/h2-console</code> ),        (URL jdbc   — <code>jdbc:h2:mem:testdb</code> ). </p><br><h2 id="dopolnitelno">  En option </h2><br><ul><li> <a href="https://databaserefactoring.com/">Database Refactoring patterns</a> </li><li> <a href="https://martinfowler.com/bliki/ContinuousDelivery.html">Continuous Delivery</a> </li></ul><br><h2 id="takzhe-chitayte-drugie-stati-v-nashem-bloge">  Lisez également d'autres articles sur notre blog: </h2><br><ul><li>  <a href="https://habr.com/ru/company/nixys/blog/480072/">Kubernetes: pourquoi est-il si important de configurer la gestion des ressources système?</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/481992/">Tekton Pipeline - Pipelines natifs de Kubernetes</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473578/">Création de modules dynamiques pour Nginx</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/473014/">Présentation de l'autorisation Kubernetes du consul Hashicorp</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/468779/">Quel a été le résultat de la migration de ClickHouse sans autorisation vers ClickHouse avec autorisation</a> </li><li>  <a href="https://habr.com/ru/company/nixys/blog/470568/">Déploiement bleu-vert des applications Spring avec Nginx Web Server</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481932/">https://habr.com/ru/post/fr481932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481916/index.html">Pour quelle année 2019 en développement s'est-elle souvenue?</a></li>
<li><a href="../fr481922/index.html">Nouvel an IMaskjs 6 - React Native, Pipes, ESM</a></li>
<li><a href="../fr481924/index.html">Apache Spark, évaluation paresseuse et requêtes SQL multi-pages</a></li>
<li><a href="../fr481926/index.html">Découvrez la nouvelle solution Veeam Backup pour AWS</a></li>
<li><a href="../fr481930/index.html">Culture du développement: comment les performances et l'efficacité sont évaluées</a></li>
<li><a href="../fr481934/index.html">Analyse: pourquoi les actions Tesla augmentent dans le prix</a></li>
<li><a href="../fr481936/index.html">Avantages et inconvénients des tests A / B: expérience des grandes entreprises</a></li>
<li><a href="../fr481940/index.html">Travail rapide et efficace en ligne de commande</a></li>
<li><a href="../fr481942/index.html">Retour vers le futur: quel jeu moderne a été présenté en 2010</a></li>
<li><a href="../fr481944/index.html">Qu'est-ce qui détermine la position du site sur la page de recherche?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>