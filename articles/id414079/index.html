<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¶ ğŸ‘¨ğŸ¾â€ğŸ”¬ ğŸ‘¨â€ğŸŒ¾ Fitur kerja dan perangkat internal express.js ğŸ¤´ğŸ¼ ğŸš‹ ğŸ‘©ğŸ½â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda mengembangkan untuk platform node.js, maka Anda mungkin pernah mendengar tentang express.js . Ini adalah salah satu kerangka kerja ringan pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur kerja dan perangkat internal express.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414079/"> Jika Anda mengembangkan untuk platform node.js, maka Anda mungkin pernah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">express.js</a> .  Ini adalah salah satu kerangka kerja ringan paling populer yang digunakan untuk membuat aplikasi web untuk simpul. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/bs/np/1r/bsnp1rphnfiib_l1tjzaauvcs48.jpeg"></a> <br><br>  Penulis bahan, terjemahan yang kami terbitkan hari ini, menawarkan untuk mempelajari fitur-fitur struktur internal kerangka kerja ekspresinya melalui analisis kode sumbernya dan pertimbangan contoh penggunaannya.  Dia percaya bahwa studi tentang mekanisme yang mendasari perpustakaan open source populer berkontribusi untuk pemahaman yang lebih mendalam tentang mereka, menghilangkan tirai "misteri" dari mereka dan membantu untuk membuat aplikasi yang lebih baik berdasarkan pada mereka. <br><a name="habracut"></a><br>  Anda mungkin merasa nyaman untuk menjaga kode sumber ekspres berguna saat membaca materi ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi ini</a> digunakan di sini.  Anda dapat membaca artikel ini tanpa membuka kode kilat, karena di sini, di mana pun sesuai, bagian kode dari perpustakaan ini diberikan.  Di tempat-tempat di mana kode disingkat, komentar dari formulir <code>// ...</code> <br><br><h2>  <font color="#3AC1EF">Contoh dasar menggunakan express</font> </h2><br>  Untuk mulai dengan, mari kita lihat "Hello World!" Tradisional dalam pengembangan teknologi komputer baru - sebuah contoh.  Ini dapat ditemukan di situs web resmi kerangka kerja, ini akan berfungsi sebagai titik awal dalam penelitian kami. <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> res.send(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>)) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Example app listening on port 3000!'</span></span>))</code> </pre> <br>  Kode ini memulai server HTTP baru pada port 3000 dan mengirimkan <code>Hello World!</code>  untuk permintaan yang diterima pada <code>GET /</code> rute.  Jika Anda tidak merinci, maka kami dapat membedakan empat tahap dari apa yang terjadi, yang dapat kami analisis: <br><br><ol><li>  Buat aplikasi ekspres baru. </li><li>  Buat rute baru. </li><li>  Memulai server HTTP pada nomor port yang ditentukan. </li><li>  Memproses permintaan masuk ke server. </li></ol><br><h2>  <font color="#3AC1EF">Membuat aplikasi ekspres baru</font> </h2><br>  Perintah <code>var app = express()</code> memungkinkan Anda membuat aplikasi ekspres baru.  Fungsi <code>createApplication</code> dari file <a href="">lib / express.js</a> adalah fungsi default yang diekspor; kita yang mengaksesnya dengan memanggil fungsi <code>express()</code> .  Berikut adalah beberapa hal penting yang harus Anda perhatikan: <br><br><pre> <code class="hljs powershell">// ... var mixin = require(<span class="hljs-string"><span class="hljs-string">'merge-descriptors'</span></span>); var proto = require(<span class="hljs-string"><span class="hljs-string">'./application'</span></span>); // ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createApplication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { //    ,     . //     : `function(req, res, next)` var app = function(req, res, next) {   app.handle(req, res, next); }; // ... //  `mixin`    `proto`  `app` //     -  `get`,     . mixin(app, proto, false); // ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app; }</code> </pre> <br>  Objek <code>app</code> dikembalikan dari fungsi ini adalah salah satu objek yang digunakan dalam kode aplikasi kami.  Metode <code>app.get</code> ditambahkan menggunakan fungsi <code>mixin</code> dari pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabungan-deskriptor</a> , yang bertanggung jawab untuk menetapkan metode <code>app</code> yang dinyatakan dalam <code>proto</code> .  Objek <code>proto</code> sendiri diimpor dari <a href="">lib / application.js</a> . <br><br><h2>  <font color="#3AC1EF">Buat rute baru</font> </h2><br>  Sekarang mari kita lihat <a href="">kode</a> yang bertanggung jawab untuk membuat metode <code>app.get</code> dari contoh kita. <br><br><pre> <code class="hljs powershell">var slice = Array.prototype.slice; // ... /** *   `.VERB(...)` `router.VERB(...)`. */ // `methods`    HTTP, (  [<span class="hljs-string"><span class="hljs-string">'get'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>,<span class="hljs-type"><span class="hljs-type">...</span></span>]) methods.forEach(function(method){ //    app.get app[<span class="hljs-type"><span class="hljs-type">method</span></span>] = function(path){   //     //          var route = this._router.route(path);   //        route[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(route, slice.call(arguments, <span class="hljs-number"><span class="hljs-number">1</span></span>));   //   `app`,          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  Sangat menarik untuk dicatat bahwa, di samping fitur semantik, semua metode yang menerapkan tindakan HTTP, seperti <code>app.get</code> , <code>app.post</code> , <code>app.put</code> dan sejenisnya, dalam hal fungsionalitas, dapat dianggap sama.  Jika Anda menyederhanakan kode di atas, menguranginya menjadi implementasi hanya satu metode <code>get</code> , Anda mendapatkan sesuatu seperti berikut: <br><br><pre> <code class="hljs sql">app.get = function(path, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>){ // ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> route = this._router.route(<span class="hljs-keyword"><span class="hljs-keyword">path</span></span>); route.get(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this }</code> </pre> <br>  Meskipun fungsi di atas memiliki 2 argumen, ini mirip dengan <code>app[method] = function(path){...}</code> fungsi <code>app[method] = function(path){...}</code> .  Argumen kedua, <code>handler</code> , diperoleh dengan memanggil <code>slice.call(arguments, 1)</code> . <br><br>  Singkatnya, <code>app.&lt;method&gt;</code> hanya menyimpan rute di router aplikasi menggunakan metode <code>route</code> , dan kemudian melewati <code>handler</code> ke <code>route.&lt;method&gt;</code> . <br><br>  Metode <code>route()</code> router dideklarasikan di <a href="">lib / router / index.js</a> : <br><br><pre> <code class="hljs pgsql">// proto -     `_router` proto.route = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> route(<span class="hljs-type"><span class="hljs-type">path</span></span>) { var route = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Route(<span class="hljs-type"><span class="hljs-type">path</span></span>); var layer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Layer(<span class="hljs-type"><span class="hljs-type">path</span></span>, {   sensitive: this.caseSensitive,   <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: this.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>,   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> route; };</code> </pre> <br>  Tidak mengejutkan, deklarasi metode <code>route.get</code> di <a href="">lib / router / route.js</a> mirip dengan deklarasi <code>app.get</code> : <br><br><pre> <code class="hljs powershell">methods.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span></span> { Route.prototype[<span class="hljs-type"><span class="hljs-type">method</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   // `flatten`   ,  [<span class="hljs-number"><span class="hljs-number">1</span></span>,[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]],      var handles = flatten(slice.call(arguments));   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; handles.length; i++) {     var handle = handles[<span class="hljs-type"><span class="hljs-type">i</span></span>];         // ...     //   ,  ,    Layer,     //            var layer = Layer(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, {}, handle);     // ...     this.stack.push(layer);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  Setiap rute dapat memiliki beberapa penangan, atas dasar setiap penangan, variabel tipe <code>Layer</code> dibangun, yang merupakan lapisan pemrosesan data, yang kemudian masuk ke stack. <br><br><h2>  <font color="#3AC1EF">Objek Lapisan</font> </h2><br>  Baik <code>_router</code> dan <code>route</code> menggunakan objek bertipe <code>Layer</code> .  Untuk memahami esensi dari objek semacam itu, mari kita lihat <a href="">konstruktornya</a> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Layer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, options, fn)</span></span></span></span> { // ... this.handle = fn; this.regexp = pathRegexp(path, this.keys = [], opts); // ... }</code> </pre> <br>  Saat membuat objek bertipe <code>Layer</code> mereka diberi jalur, parameter tertentu, dan fungsi.  Dalam kasus router kami, fungsi ini adalah <code>route.dispatch</code> (kami akan membicarakan lebih lanjut di bawah ini, secara umum, ini dirancang untuk mengirimkan permintaan ke rute yang terpisah).  Dalam kasus rute itu sendiri, fungsi ini adalah fungsi handler yang dideklarasikan dalam kode contoh kita. <br><br>  Setiap objek bertipe <code>Layer</code> memiliki metode <a href="">handle_request</a> , yang bertanggung jawab untuk mengeksekusi fungsi yang diteruskan ketika objek diinisialisasi. <br><br>  Ingat apa yang terjadi ketika membuat rute menggunakan metode <code>app.get</code> : <br><br><ol><li>  Sebuah rute dibuat di router aplikasi ( <code>this._router</code> ). </li><li>  Metode rute <code>dispatch</code> ditugaskan sebagai metode handler dari objek <code>Layer</code> sesuai, dan objek ini didorong ke stack router. </li><li>  Penangan permintaan diteruskan ke objek <code>Layer</code> sebagai metode penangan, dan objek ini didorong ke tumpukan rute. </li></ol><br>  Akibatnya, semua penangan disimpan di dalam instance <code>app</code> dalam bentuk objek dari tipe <code>Layer</code> yang ada di dalam route stack, yang metode <code>dispatch</code> ditugaskan ke objek <code>Layer</code> yang ada di stack router: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a9/e8c/5b0/4a9e8c5b056ef1e8ce1e36503ab8c0f0.png"></div><br>  <i><font color="#999999">Lapisan objek pada stack router dan stack route</font></i> <br><br>  Permintaan HTTP yang masuk diproses sesuai dengan logika ini.  Kami akan membicarakannya di bawah. <br><br><h2>  <font color="#3AC1EF">Startup server HTTP</font> </h2><br>  Setelah mengkonfigurasi rute, Anda harus memulai server.  Dalam contoh kita, kita beralih ke metode <code>app.listen</code> , meneruskannya nomor port dan fungsi panggilan balik sebagai argumen.  Untuk memahami fitur-fitur metode ini, kita dapat merujuk ke file <a href="">lib / application.js</a> : <br><br><pre> <code class="hljs pgsql">app.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>() { var <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http.createServer(this); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>.apply(<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, arguments); };</code> </pre> <br>  <code>app.listen</code> hanya pembungkus di sekitar <code>http.createServer</code> .  Sudut pandang seperti itu masuk akal, karena jika Anda mengingat apa yang kita bicarakan di awal, <code>app</code> hanyalah sebuah fungsi dengan <code>function(req, res, next) {...}</code> tanda tangan <code>function(req, res, next) {...}</code> , yang kompatibel dengan argumen yang diperlukan untuk <code>http.createServer</code> (tanda tangan dari metode ini adalah <code>function (req, res) {...}</code> ). <br><br>  Setelah menyadari bahwa, pada akhirnya, segala sesuatu yang diekspresikan. <br><br><h2>  <font color="#3AC1EF">Pemrosesan permintaan HTTP</font> </h2><br>  Sekarang kami tahu bahwa <code>app</code> hanyalah penangan permintaan, kami akan mengikuti jalur yang dilewati permintaan HTTP di dalam aplikasi ekspres.  Jalan ini membawanya ke pawang yang dinyatakan oleh kami. <br><br>  Pertama, permintaan pergi ke fungsi <code>createApplication</code> ( <a href="">lib / express.js</a> ): <br><br><pre> <code class="hljs matlab">var app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function">; };</span></span></code> </pre> <br>  Kemudian masuk ke metode <code>app.handle</code> ( <a href="">lib / application.js</a> ): <br><br><pre> <code class="hljs powershell">app.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, callback)</span></span></span></span> { // `this._router` -  ,    ,  `app.get` var router = this._router; // ... //     `handle` router.handle(req, res, done); };</code> </pre> <br>  Metode <code>router.handle</code> dideklarasikan di <a href="">lib / router / index.js</a> : <br><br><pre> <code class="hljs lua">proto.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, out)</span></span></span></span> { var self = this; //... // self.stack -  ,      // Layer (  ) var stack = self.stack; // ... <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   //        var <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = getPathname(req);   // ...   var layer;   var <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>;   var route;   <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; idx &lt; stack.length) {     layer = stack[idx++];     <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> = matchLayer(layer, <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>);     route = layer.route;     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span>) {       continue;     }     // ...      HTTP,       }  // ...      // process_params    ,          self.process_params(layer, paramcalled, req, res, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (route) {       //       `layer.handle_request`       //         `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`       //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`     ,              //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`   ,            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.handle_request(req, res, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>);     }     // ...   }); } };</code> </pre> <br>  Singkatnya, fungsi <code>router.handle</code> melewati semua lapisan pada stack sampai menemukan yang cocok dengan jalur yang ditentukan dalam permintaan.  Kemudian, metode layer <code>handle_request</code> akan dipanggil, yang akan menjalankan fungsi handler yang telah ditentukan.  Fungsi pengendali ini adalah metode rute <code>dispatch</code> , yang dideklarasikan di <a href="">lib / route / route.js</a> : <br><br><pre> <code class="hljs powershell">Route.prototype.dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, done)</span></span></span></span> { var stack = this.stack; // ... next(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   var layer = stack[<span class="hljs-type"><span class="hljs-type">idx</span></span>++];   // ...    layer.handle_request(req, res, next);   // ... } };</code> </pre> <br>  Sama seperti dalam kasus router, selama pemrosesan setiap rute, lapisan yang rute ini telah disebutkan dan metode <code>handle_request</code> mereka yang menjalankan metode layer handler <code>handle_request</code> .  Dalam kasus kami, ini adalah penangan permintaan, yang dinyatakan dalam kode aplikasi. <br><br>  Di sini, akhirnya, permintaan HTTP masuk ke area kode aplikasi kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/0d1/5fb/afb0d15fbe71236ed615f88fe61bf062.png"></div><br>  <i><font color="#999999">Jalur permintaan dalam aplikasi ekspres</font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Di sini kami hanya memeriksa mekanisme dasar dari perpustakaan express.js, yang bertanggung jawab atas pengoperasian server web, tetapi perpustakaan ini juga memiliki banyak fitur lainnya.  Kami tidak berhenti pada pemeriksaan yang diminta melalui permintaan sebelum mereka mencapai penangan, kami tidak berbicara tentang metode pembantu yang tersedia ketika bekerja dengan variabel <code>res</code> dan <code>req</code> .  Dan akhirnya, kami tidak menyentuh salah satu fitur ekspres yang paling kuat.  Ini terdiri dari penggunaan middleware, yang dapat ditujukan untuk menyelesaikan hampir semua masalah - mulai dari penguraian permintaan hingga penerapan sistem otentikasi lengkap. <br><br>  Kami berharap materi ini membantu Anda memahami fitur utama perangkat ekspres, dan sekarang, jika perlu, Anda dapat memahami semua hal lainnya dengan menganalisis secara independen bagian-bagian dari kode sumber perpustakaan ini yang menarik minat Anda. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan express.js? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414079/">https://habr.com/ru/post/id414079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414065/index.html">Smartphone Cina terbaik "hingga 10 ribu rubel" dengan AliExpress vs Xiaomi Redmi 5</a></li>
<li><a href="../id414067/index.html">Luncurkan penargetan ulang seluler dengan Sesuaikan: pengaturan, laporan, dan tautan</a></li>
<li><a href="../id414069/index.html">Droning pembatasan selama Piala Dunia FIFA 2018 (FIFA 2018)</a></li>
<li><a href="../id414071/index.html">Dari pemantauan hingga manajemen insiden. Laporan dari DevOps Moscow Meetup</a></li>
<li><a href="../id414073/index.html">Bermigrasi dari jQuery ke Vue.js</a></li>
<li><a href="../id414081/index.html">Pengembangan Chatbot untuk Facebook Messenger di node.js</a></li>
<li><a href="../id414083/index.html">Musim panas mitap Apache Ignite di St. Petersburg</a></li>
<li><a href="../id414085/index.html">Cara membuat sampel untuk Unified Biometric System dan mengapa itu bisa berbahaya</a></li>
<li><a href="../id414087/index.html">Otomasi segera atau bagaimana bisnis dapat bekerja online hari ini</a></li>
<li><a href="../id414089/index.html">Pemblokiran Telegram ditegakkan oleh keputusan Pengadilan Kota Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>