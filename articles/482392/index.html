<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 锔  Trucos de ELF en Go  锔 </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta nota, aprenderemos c贸mo obtener el c贸digo de m谩quina de una funci贸n Go directamente en tiempo de ejecuci贸n, imprimirlo usando un desensamblado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trucos de ELF en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482392/"><p><img src="https://habrastorage.org/webt/hd/mj/7h/hdmj7hkb2kyjkyyybccynazhd7s.png"></p><br><p>  En esta nota, aprenderemos c贸mo obtener el c贸digo de m谩quina de una funci贸n Go directamente en tiempo de ejecuci贸n, imprimirlo usando un desensamblador, y en el camino descubriremos varios trucos como obtener la direcci贸n de una funci贸n sin llamarla. </p><br><p>  <strong>Advertencia</strong> : este mini art铆culo no le ense帽ar谩 nada 煤til. </p><a name="habracut"></a><br><h1 id="function-value-v-go">  Valor de funci贸n en Go </h1><br><p>  Primero, determinemos qu茅 es una funci贸n Go y por qu茅 necesitamos el concepto de <strong>valor</strong> de <strong>funci贸n</strong> . </p><br><p>  Esto se explica mejor con el documento <a href="https://golang.org/s/go11func" rel="nofollow">Go 1.1 Function Calls</a> .  El documento no es nuevo, pero la mayor parte de la informaci贸n en 茅l sigue siendo relevante. </p><br><p> En el nivel m谩s bajo, siempre es un puntero al c贸digo ejecutable, pero cuando usamos funciones / cierres an贸nimos o pasamos una funci贸n como <code>interface{}</code> , este puntero est谩 oculto dentro de alguna estructura. </p><br><p>  El nombre de la funci贸n en s铆 no es una expresi贸n, por lo tanto, dicho c贸digo no funciona: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/wXeVLU7nLPs package main func add1(x int) int { return 1 } func main() { addr := &amp;add1 println(addr) }</span></span></code> </pre> <br><blockquote> <code>compile: cannot take the address of add1</code> </blockquote> <p>  Pero al mismo tiempo, podemos obtener el <code>function value</code> la <code>function value</code> trav茅s del mismo nombre de funci贸n: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/oWqv_FQq4hy package main func add1(x int) int { return 1 } func main() { f := add1 // &lt;-------- addr := &amp;f println(addr) }</span></span></code> </pre> <br><p>  Este c贸digo se inicia, pero imprimir谩 la direcci贸n de una variable local en la pila, que no es exactamente lo que quer铆amos.  Pero, como se mencion贸 anteriormente, la direcci贸n de la funci贸n todav铆a est谩 all铆, solo necesita saber c贸mo acceder a ella. </p><br><p>  El paquete <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect.Value.Call()</code></a> depende de este detalle de implementaci贸n para ejecutar exitosamente <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect.Value.Call()</code></a> .  <a href="" rel="nofollow">All铆 (reflect / makefunc.go)</a> puede espiar el siguiente paso para obtener la direcci贸n de la funci贸n: </p><br><pre> <code class="go hljs">dummy := makeFuncStub code := **(**<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>)(unsafe.Pointer(&amp;dummy))</code> </pre> <br><p>  El c贸digo anterior muestra una idea b谩sica que puede refinar a una funci贸n: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// funcAddr returns function value fn executable code address. func funcAddr(fn interface{}) uintptr { // emptyInterface is the header for an interface{} value. type emptyInterface struct { typ uintptr value *uintptr } e := (*emptyInterface)(unsafe.Pointer(&amp;fn)) return *e.value }</span></span></code> </pre> <br><p>  La <code>add1</code> funci贸n <code>add1</code> se puede <code>add1</code> llamando a <code>funcAddr(add1)</code> . </p><br><h1 id="poluchenie-bloka-mashinnogo-koda-funkcii">  Obtener un bloque de c贸digo de funci贸n de m谩quina </h1><br><p>  Ahora que tenemos la direcci贸n del comienzo del c贸digo de funci贸n de la m谩quina, nos gustar铆a obtener el c贸digo completo de la funci贸n.  Aqu铆 debe poder determinar d贸nde termina el c贸digo de la funci贸n actual. </p><br><p>  Si la arquitectura x86 tuviera instrucciones de longitud fija, no ser铆a tan dif铆cil y varias heur铆sticas podr铆an ayudarnos, entre las cuales: </p><br><ul><li>  Como regla, al final del c贸digo de funci贸n hay una paliza de <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)" rel="nofollow"><code>INT3</code></a> instrucciones <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)" rel="nofollow"><code>INT3</code></a> .  Este es un buen marcador para el final del c贸digo de funci贸n, pero puede faltar. </li><li>  Las funciones con un marco distinto de cero para la pila tienen un pr贸logo que verifica si esta pila necesita expandirse.  En caso afirmativo, se realiza un salto al c贸digo inmediatamente despu茅s del c贸digo de la funci贸n, y luego un salto al inicio de la funci贸n.  El c贸digo que nos interesa estar谩 en el medio. </li></ul><br><p>  Pero deber谩 decodificar honestamente las instrucciones, porque un byte by-pass puede encontrar el byte <code>INT3</code> dentro de otra instrucci贸n.  Calcular la longitud de una instrucci贸n para omitir tampoco es tan f谩cil, <a href="https://stackoverflow.com/questions/45801447/x86-assembly-how-to-calculate-instruction-opcodes-length-in-bytes" rel="nofollow">porque es x86, beb茅</a> . </p><br><p>  La direcci贸n de una funci贸n en el contexto del paquete de <a href="https://golang.org/pkg/runtime" rel="nofollow"><code>runtime</code></a> de <a href="https://golang.org/pkg/runtime" rel="nofollow"><code>runtime</code></a> veces se denomina <code>PC</code> , para enfatizar la capacidad de usar la direcci贸n en alg煤n lugar dentro de la funci贸n, y no solo el punto de entrada de la funci贸n.  El resultado de <code>funcAddr</code> puede usarse como argumento para la funci贸n <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.FuncForPC()</code></a> para obtener <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.Func</code></a> sin llamar a la funci贸n en s铆.  A trav茅s de transformaciones inseguras de A帽o Nuevo, podemos acceder a <a href="https://play.golang.org/p/lQxxK36ZXru" rel="nofollow"><code>runtime._func</code></a> , que es informativo, pero no muy 煤til: no hay informaci贸n sobre el tama帽o del bloque de c贸digo de funci贸n. </p><br><p>  Parece que sin la ayuda de los <a href="https://golang.org/pkg/debug/elf/" rel="nofollow">ELF</a> no podemos hacer frente. </p><br><blockquote>  Para las plataformas donde los ejecutables tienen un formato diferente, la mayor parte del art铆culo seguir谩 siendo relevante, pero deber谩 usar no <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>debug/elf</code></a> , sino otro paquete de <a href="https://golang.org/pkg/debug/" rel="nofollow"><code>debug</code></a> . </blockquote><br><h1 id="elf-kotoryy-pryachetsya-v-vashey-programme">  El ELF que se esconde en tu programa </h1><br><p>  La informaci贸n que necesitamos ya est谩 contenida en los metadatos del archivo <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="nofollow">ELF</a> . </p><br><p>  A trav茅s de <a href="https://golang.org/pkg/os/" rel="nofollow"><code>os.Args[0]</code></a> podemos acceder al archivo ejecutable en s铆, y ya obtener la tabla de s铆mbolos. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readELF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*elf.File, error)</span></span></span></span> { f, err := os.Open(os.Args[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"open argv[0]: %w"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elf.NewFile(f) }</code> </pre> <br><h1 id="poisk-simvola-vnutri-elffilehttpsgolangorgpkgdebugelffile">  Busca un personaje dentro de <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>elf.File</code></a> </h1><br><p>  Todos los caracteres se pueden <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> utilizando el m茅todo <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> .  Este m茅todo devuelve <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>[]elf.Symbol</code></a> , que contiene el campo <code>Symbol.Size</code> : este es el "tama帽o de la funci贸n" que estamos <code>Symbol.Size</code> .  El campo <code>Symbol.Value</code> debe coincidir con el valor devuelto por <code>funcAddr</code> . </p><br><p>  Puede buscar el s铆mbolo deseado por direcci贸n ( <code>Symbol.Value</code> ) o por nombre ( <code>Symbol.Name</code> ).  Si los caracteres se ordenaran por nombre, ser铆a posible usar <a href="https://golang.org/pkg/sort/" rel="nofollow"><code>sort.Search()</code></a> , pero esto no es as铆: </p><br><blockquote>  Los s铆mbolos se enumerar谩n en el orden en que aparecen en el archivo. </blockquote><p>  Si a menudo necesita encontrar caracteres en la tabla, debe crear un 铆ndice adicional, por ejemplo, a trav茅s de <code>map[string]*elf.Symbol</code> o <code>map[uintptr]*elf.Symbol</code> . </p><br><p>  Como ya sabemos c贸mo obtener la direcci贸n de una funci贸n por su valor, la buscaremos: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elfLookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *elf.File, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Symbol</span></span></span></span> { symbols, err := f.Symbols() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, sym := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> symbols { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym.Value == value { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;sym } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><blockquote>  <strong>Nota</strong> : para que este enfoque funcione, necesitamos una tabla de caracteres.  Si el binario est谩 construido con ` <code>-ldflags "-s"</code> ', entonces <code>elfLookup()</code> siempre devolver谩 <code>nil</code> .  Si ejecuta el programa a trav茅s de <code>go run</code> , puede encontrar el mismo problema.  Para ver ejemplos del art铆culo, se recomienda hacer ' <code>go build</code> ' o ' <code>go install</code> ' para obtener archivos ejecutables. </blockquote><br><h1 id="poluchenie-mashinnogo-koda-funkcii">  Obtener el c贸digo de funci贸n de la m谩quina </h1><br><p>  Conociendo el rango de direcciones en las que se encuentra el c贸digo ejecutable, solo queda extraerlo en forma de <code>[]byte</code> para un procesamiento conveniente. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { elffile, err := readELF() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"read elf: %w"</span></span>, err) } sym := elfLookup(elffile, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(addr)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"can't lookup symbol for %x"</span></span>, addr) } code := *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;reflect.SliceHeader{ Data: addr, Len: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), Cap: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), })) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Este c贸digo se simplifica intencionalmente para la demostraci贸n.  No debe leer <code>ELF</code> cada vez y hacer una b煤squeda lineal en su tabla. </p><br><p>  El resultado de la funci贸n <code>funcCode()</code> es un segmento con bytes del c贸digo de funci贸n de la m谩quina.  Deber铆a <code>funcAddr()</code> resultado de llamar a <code>funcAddr()</code> . </p><br><pre> <code class="go hljs">code, err := funcCode(funcAddr(add1)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panicf(<span class="hljs-string"><span class="hljs-string">"can't get function code: %v"</span></span>, err) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"% x\n"</span></span>, code) <span class="hljs-comment"><span class="hljs-comment">// =&gt; 48 8b 44 24 08 48 ff c0 48 89 44 24 10 c3</span></span></code> </pre> <br><h1 id="dizassemblirovanie-mashinnogo-koda">  Desmontaje del c贸digo de m谩quina </h1><br><p>  Para facilitar la lectura del c贸digo de la m谩quina, utilizaremos un desensamblador. </p><br><p>  Estoy m谩s familiarizado con los proyectos <a href="https://github.com/zyantific/zydis" rel="nofollow">zydis</a> e <a href="https://github.com/intelxed/xed" rel="nofollow">Intel XED</a> , por lo que, en primer lugar, mi elecci贸n recae en ellos. </p><br><p>  Para Go, puede <a href="https://github.com/jpap/go-zydis" rel="nofollow">utilizar el enlace go-zydis</a> , que es lo suficientemente bueno y f谩cil de instalar para nuestra tarea. </p><br><p>  Describamos la abstracci贸n de "omitir las instrucciones de la m谩quina", con la ayuda de la cual puede implementar otras operaciones: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walkDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, visit </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(*zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { dec := zydis.NewDecoder(zydis.MachineMode64, zydis.AddressWidth64) buf := code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { instr, err := dec.Decode(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := visit(instr); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } buf = buf[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(instr.Length):] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Esta funci贸n toma un segmento de c贸digo de m谩quina como entrada y llama a una funci贸n de devoluci贸n de llamada para cada instrucci贸n decodificada. </p><br><p>  En base a esto, podemos escribir el <code>printDisasm</code> que <code>printDisasm</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ZYDIS_RUNTIME_ADDRESS_NONE = math.MaxUint64 formatter, err := zydis.NewFormatter(zydis.FormatterStyleIntel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walkDisasm(code, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(instr *zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s, err := formatter.FormatInstruction(instr, ZYDIS_RUNTIME_ADDRESS_NONE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) }</code> </pre> <br><p>  Si ejecutamos <code>printDisasm</code> en el <code>add1</code> funci贸n <code>add1</code> , obtenemos el resultado esperado: </p><br><pre> <code class="plaintext hljs">mov rax, [rsp+0x08] inc rax mov [rsp+0x10], rax ret</code> </pre> <br><h2 id="validaciya-rezultata">  Validaci贸n de resultados </h2><br><p>  Ahora intentaremos asegurarnos de que el c贸digo de ensamblador obtenido en la secci贸n anterior sea correcto. </p><br><p>  Como ya tenemos un binario compilado, puede usar el <code>objdump</code> suministrado con Go: </p><br><pre> <code class="bash hljs">$ go tool objdump -s <span class="hljs-string"><span class="hljs-string">'add1'</span></span> exe TEXT main.add1(SB) example.go example.go:15 0x4bb760 488b442408 MOVQ 0x8(SP), AX example.go:15 0x4bb765 48ffc0 INCQ AX example.go:15 0x4bb768 4889442410 MOVQ AX, 0x10(SP) example.go:15 0x4bb76d c3 RET</code> </pre> <br><p>  Todo converge, solo la sintaxis es ligeramente diferente, lo que se espera. </p><br><h1 id="method-expressions">  Expresiones del m茅todo </h1><br><p>  Si necesitamos hacer lo mismo con los m茅todos, entonces, en lugar del nombre de la funci贸n, usaremos la <a href="https://golang.org/ref/spec" rel="nofollow">expresi贸n del m茅todo</a> . </p><br><p>  Digamos que nuestro <code>add1</code> no es realmente una funci贸n, sino un m茅todo de tipo <code>adder</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> adder <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(adder)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  Luego, la llamada para obtener la direcci贸n de la funci贸n se ver谩 como <code>funcAddr(adder.add1)</code> . </p><br><h1 id="zaklyuchenie">  Conclusi贸n </h1><br><p>  Llegu茅 a estas cosas no por casualidad y, tal vez, en uno de los siguientes art铆culos le dir茅 c贸mo se plane贸 utilizar todos estos mecanismos.  Mientras tanto, propongo tratar este art铆culo como una descripci贸n superficial de c贸mo el <code>runtime</code> de <code>runtime</code> y el <code>reflect</code> miran nuestras funciones Go a trav茅s del valor de la funci贸n. </p><br><p>  Lista de recursos utilizados: </p><br><ul><li>  <a href="https://golang.org/s/go11func" rel="nofollow">Ir 1.1 Llamadas de funci贸n</a> </li><li>  <a href="https://www.pnfsoftware.com/blog/analyzing-golang-executables/" rel="nofollow">Analizando ejecutables de Golang</a> </li><li>  <a href="" rel="nofollow">Ir dise帽o "ABI interno"</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482392/">https://habr.com/ru/post/482392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482374/index.html">Desarrollo de juegos en LibGDX utilizando la plantilla del sistema de componentes de la entidad</a></li>
<li><a href="../482378/index.html">Una breve historia de Wacom: c贸mo la tecnolog铆a de tabletas gr谩ficas lleg贸 a los lectores electr贸nicos</a></li>
<li><a href="../482382/index.html">驴Cuatro principios de traducci贸n, o de qu茅 manera una persona no ceder谩 ante un traductor autom谩tico?</a></li>
<li><a href="../482384/index.html">Mi proyecto no realizado. Red de 200 enrutadores MikroTik</a></li>
<li><a href="../482390/index.html">Tutorial de Ember.js tutorial. Aplicaci贸n Super Rentals. Parte 1.2</a></li>
<li><a href="../482396/index.html">C贸mo elegir cursos comerciales que ense帽en profesiones de TI</a></li>
<li><a href="../482398/index.html">Replicaci贸n l贸gica de PostgreSQL a Erlang</a></li>
<li><a href="../482400/index.html">Una selecci贸n de datos estad铆sticos entretenidos # 2</a></li>
<li><a href="../482402/index.html">Patr贸n de f谩brica Ejemplo de aplicaci贸n en Unity</a></li>
<li><a href="../482404/index.html">Nemotecnia: explorando m茅todos para aumentar la memoria cerebral</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>