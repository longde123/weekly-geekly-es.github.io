<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔈 ☪️ 🍵 Trucos de ELF en Go 🦉 ♟️ 🐉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta nota, aprenderemos cómo obtener el código de máquina de una función Go directamente en tiempo de ejecución, imprimirlo usando un desensamblado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trucos de ELF en Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482392/"><p><img src="https://habrastorage.org/webt/hd/mj/7h/hdmj7hkb2kyjkyyybccynazhd7s.png"></p><br><p>  En esta nota, aprenderemos cómo obtener el código de máquina de una función Go directamente en tiempo de ejecución, imprimirlo usando un desensamblador, y en el camino descubriremos varios trucos como obtener la dirección de una función sin llamarla. </p><br><p>  <strong>Advertencia</strong> : este mini artículo no le enseñará nada útil. </p><a name="habracut"></a><br><h1 id="function-value-v-go">  Valor de función en Go </h1><br><p>  Primero, determinemos qué es una función Go y por qué necesitamos el concepto de <strong>valor</strong> de <strong>función</strong> . </p><br><p>  Esto se explica mejor con el documento <a href="https://golang.org/s/go11func" rel="nofollow">Go 1.1 Function Calls</a> .  El documento no es nuevo, pero la mayor parte de la información en él sigue siendo relevante. </p><br><p> En el nivel más bajo, siempre es un puntero al código ejecutable, pero cuando usamos funciones / cierres anónimos o pasamos una función como <code>interface{}</code> , este puntero está oculto dentro de alguna estructura. </p><br><p>  El nombre de la función en sí no es una expresión, por lo tanto, dicho código no funciona: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/wXeVLU7nLPs package main func add1(x int) int { return 1 } func main() { addr := &amp;add1 println(addr) }</span></span></code> </pre> <br><blockquote> <code>compile: cannot take the address of add1</code> </blockquote> <p>  Pero al mismo tiempo, podemos obtener el <code>function value</code> la <code>function value</code> través del mismo nombre de función: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/oWqv_FQq4hy package main func add1(x int) int { return 1 } func main() { f := add1 // &lt;-------- addr := &amp;f println(addr) }</span></span></code> </pre> <br><p>  Este código se inicia, pero imprimirá la dirección de una variable local en la pila, que no es exactamente lo que queríamos.  Pero, como se mencionó anteriormente, la dirección de la función todavía está allí, solo necesita saber cómo acceder a ella. </p><br><p>  El paquete <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect.Value.Call()</code></a> depende de este detalle de implementación para ejecutar exitosamente <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect.Value.Call()</code></a> .  <a href="" rel="nofollow">Allí (reflect / makefunc.go)</a> puede espiar el siguiente paso para obtener la dirección de la función: </p><br><pre> <code class="go hljs">dummy := makeFuncStub code := **(**<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>)(unsafe.Pointer(&amp;dummy))</code> </pre> <br><p>  El código anterior muestra una idea básica que puede refinar a una función: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// funcAddr returns function value fn executable code address. func funcAddr(fn interface{}) uintptr { // emptyInterface is the header for an interface{} value. type emptyInterface struct { typ uintptr value *uintptr } e := (*emptyInterface)(unsafe.Pointer(&amp;fn)) return *e.value }</span></span></code> </pre> <br><p>  La <code>add1</code> función <code>add1</code> se puede <code>add1</code> llamando a <code>funcAddr(add1)</code> . </p><br><h1 id="poluchenie-bloka-mashinnogo-koda-funkcii">  Obtener un bloque de código de función de máquina </h1><br><p>  Ahora que tenemos la dirección del comienzo del código de función de la máquina, nos gustaría obtener el código completo de la función.  Aquí debe poder determinar dónde termina el código de la función actual. </p><br><p>  Si la arquitectura x86 tuviera instrucciones de longitud fija, no sería tan difícil y varias heurísticas podrían ayudarnos, entre las cuales: </p><br><ul><li>  Como regla, al final del código de función hay una paliza de <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)" rel="nofollow"><code>INT3</code></a> instrucciones <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)" rel="nofollow"><code>INT3</code></a> .  Este es un buen marcador para el final del código de función, pero puede faltar. </li><li>  Las funciones con un marco distinto de cero para la pila tienen un prólogo que verifica si esta pila necesita expandirse.  En caso afirmativo, se realiza un salto al código inmediatamente después del código de la función, y luego un salto al inicio de la función.  El código que nos interesa estará en el medio. </li></ul><br><p>  Pero deberá decodificar honestamente las instrucciones, porque un byte by-pass puede encontrar el byte <code>INT3</code> dentro de otra instrucción.  Calcular la longitud de una instrucción para omitir tampoco es tan fácil, <a href="https://stackoverflow.com/questions/45801447/x86-assembly-how-to-calculate-instruction-opcodes-length-in-bytes" rel="nofollow">porque es x86, bebé</a> . </p><br><p>  La dirección de una función en el contexto del paquete de <a href="https://golang.org/pkg/runtime" rel="nofollow"><code>runtime</code></a> de <a href="https://golang.org/pkg/runtime" rel="nofollow"><code>runtime</code></a> veces se denomina <code>PC</code> , para enfatizar la capacidad de usar la dirección en algún lugar dentro de la función, y no solo el punto de entrada de la función.  El resultado de <code>funcAddr</code> puede usarse como argumento para la función <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.FuncForPC()</code></a> para obtener <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.Func</code></a> sin llamar a la función en sí.  A través de transformaciones inseguras de Año Nuevo, podemos acceder a <a href="https://play.golang.org/p/lQxxK36ZXru" rel="nofollow"><code>runtime._func</code></a> , que es informativo, pero no muy útil: no hay información sobre el tamaño del bloque de código de función. </p><br><p>  Parece que sin la ayuda de los <a href="https://golang.org/pkg/debug/elf/" rel="nofollow">ELF</a> no podemos hacer frente. </p><br><blockquote>  Para las plataformas donde los ejecutables tienen un formato diferente, la mayor parte del artículo seguirá siendo relevante, pero deberá usar no <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>debug/elf</code></a> , sino otro paquete de <a href="https://golang.org/pkg/debug/" rel="nofollow"><code>debug</code></a> . </blockquote><br><h1 id="elf-kotoryy-pryachetsya-v-vashey-programme">  El ELF que se esconde en tu programa </h1><br><p>  La información que necesitamos ya está contenida en los metadatos del archivo <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="nofollow">ELF</a> . </p><br><p>  A través de <a href="https://golang.org/pkg/os/" rel="nofollow"><code>os.Args[0]</code></a> podemos acceder al archivo ejecutable en sí, y ya obtener la tabla de símbolos. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readELF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*elf.File, error)</span></span></span></span> { f, err := os.Open(os.Args[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"open argv[0]: %w"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elf.NewFile(f) }</code> </pre> <br><h1 id="poisk-simvola-vnutri-elffilehttpsgolangorgpkgdebugelffile">  Busca un personaje dentro de <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>elf.File</code></a> </h1><br><p>  Todos los caracteres se pueden <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> utilizando el método <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> .  Este método devuelve <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>[]elf.Symbol</code></a> , que contiene el campo <code>Symbol.Size</code> : este es el "tamaño de la función" que estamos <code>Symbol.Size</code> .  El campo <code>Symbol.Value</code> debe coincidir con el valor devuelto por <code>funcAddr</code> . </p><br><p>  Puede buscar el símbolo deseado por dirección ( <code>Symbol.Value</code> ) o por nombre ( <code>Symbol.Name</code> ).  Si los caracteres se ordenaran por nombre, sería posible usar <a href="https://golang.org/pkg/sort/" rel="nofollow"><code>sort.Search()</code></a> , pero esto no es así: </p><br><blockquote>  Los símbolos se enumerarán en el orden en que aparecen en el archivo. </blockquote><p>  Si a menudo necesita encontrar caracteres en la tabla, debe crear un índice adicional, por ejemplo, a través de <code>map[string]*elf.Symbol</code> o <code>map[uintptr]*elf.Symbol</code> . </p><br><p>  Como ya sabemos cómo obtener la dirección de una función por su valor, la buscaremos: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elfLookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *elf.File, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Symbol</span></span></span></span> { symbols, err := f.Symbols() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, sym := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> symbols { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym.Value == value { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;sym } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><blockquote>  <strong>Nota</strong> : para que este enfoque funcione, necesitamos una tabla de caracteres.  Si el binario está construido con ` <code>-ldflags "-s"</code> ', entonces <code>elfLookup()</code> siempre devolverá <code>nil</code> .  Si ejecuta el programa a través de <code>go run</code> , puede encontrar el mismo problema.  Para ver ejemplos del artículo, se recomienda hacer ' <code>go build</code> ' o ' <code>go install</code> ' para obtener archivos ejecutables. </blockquote><br><h1 id="poluchenie-mashinnogo-koda-funkcii">  Obtener el código de función de la máquina </h1><br><p>  Conociendo el rango de direcciones en las que se encuentra el código ejecutable, solo queda extraerlo en forma de <code>[]byte</code> para un procesamiento conveniente. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { elffile, err := readELF() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"read elf: %w"</span></span>, err) } sym := elfLookup(elffile, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(addr)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"can't lookup symbol for %x"</span></span>, addr) } code := *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;reflect.SliceHeader{ Data: addr, Len: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), Cap: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), })) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Este código se simplifica intencionalmente para la demostración.  No debe leer <code>ELF</code> cada vez y hacer una búsqueda lineal en su tabla. </p><br><p>  El resultado de la función <code>funcCode()</code> es un segmento con bytes del código de función de la máquina.  Debería <code>funcAddr()</code> resultado de llamar a <code>funcAddr()</code> . </p><br><pre> <code class="go hljs">code, err := funcCode(funcAddr(add1)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panicf(<span class="hljs-string"><span class="hljs-string">"can't get function code: %v"</span></span>, err) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"% x\n"</span></span>, code) <span class="hljs-comment"><span class="hljs-comment">// =&gt; 48 8b 44 24 08 48 ff c0 48 89 44 24 10 c3</span></span></code> </pre> <br><h1 id="dizassemblirovanie-mashinnogo-koda">  Desmontaje del código de máquina </h1><br><p>  Para facilitar la lectura del código de la máquina, utilizaremos un desensamblador. </p><br><p>  Estoy más familiarizado con los proyectos <a href="https://github.com/zyantific/zydis" rel="nofollow">zydis</a> e <a href="https://github.com/intelxed/xed" rel="nofollow">Intel XED</a> , por lo que, en primer lugar, mi elección recae en ellos. </p><br><p>  Para Go, puede <a href="https://github.com/jpap/go-zydis" rel="nofollow">utilizar el enlace go-zydis</a> , que es lo suficientemente bueno y fácil de instalar para nuestra tarea. </p><br><p>  Describamos la abstracción de "omitir las instrucciones de la máquina", con la ayuda de la cual puede implementar otras operaciones: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walkDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, visit </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(*zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { dec := zydis.NewDecoder(zydis.MachineMode64, zydis.AddressWidth64) buf := code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { instr, err := dec.Decode(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := visit(instr); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } buf = buf[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(instr.Length):] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Esta función toma un segmento de código de máquina como entrada y llama a una función de devolución de llamada para cada instrucción decodificada. </p><br><p>  En base a esto, podemos escribir el <code>printDisasm</code> que <code>printDisasm</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ZYDIS_RUNTIME_ADDRESS_NONE = math.MaxUint64 formatter, err := zydis.NewFormatter(zydis.FormatterStyleIntel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walkDisasm(code, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(instr *zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s, err := formatter.FormatInstruction(instr, ZYDIS_RUNTIME_ADDRESS_NONE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) }</code> </pre> <br><p>  Si ejecutamos <code>printDisasm</code> en el <code>add1</code> función <code>add1</code> , obtenemos el resultado esperado: </p><br><pre> <code class="plaintext hljs">mov rax, [rsp+0x08] inc rax mov [rsp+0x10], rax ret</code> </pre> <br><h2 id="validaciya-rezultata">  Validación de resultados </h2><br><p>  Ahora intentaremos asegurarnos de que el código de ensamblador obtenido en la sección anterior sea correcto. </p><br><p>  Como ya tenemos un binario compilado, puede usar el <code>objdump</code> suministrado con Go: </p><br><pre> <code class="bash hljs">$ go tool objdump -s <span class="hljs-string"><span class="hljs-string">'add1'</span></span> exe TEXT main.add1(SB) example.go example.go:15 0x4bb760 488b442408 MOVQ 0x8(SP), AX example.go:15 0x4bb765 48ffc0 INCQ AX example.go:15 0x4bb768 4889442410 MOVQ AX, 0x10(SP) example.go:15 0x4bb76d c3 RET</code> </pre> <br><p>  Todo converge, solo la sintaxis es ligeramente diferente, lo que se espera. </p><br><h1 id="method-expressions">  Expresiones del método </h1><br><p>  Si necesitamos hacer lo mismo con los métodos, entonces, en lugar del nombre de la función, usaremos la <a href="https://golang.org/ref/spec" rel="nofollow">expresión del método</a> . </p><br><p>  Digamos que nuestro <code>add1</code> no es realmente una función, sino un método de tipo <code>adder</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> adder <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(adder)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  Luego, la llamada para obtener la dirección de la función se verá como <code>funcAddr(adder.add1)</code> . </p><br><h1 id="zaklyuchenie">  Conclusión </h1><br><p>  Llegué a estas cosas no por casualidad y, tal vez, en uno de los siguientes artículos le diré cómo se planeó utilizar todos estos mecanismos.  Mientras tanto, propongo tratar este artículo como una descripción superficial de cómo el <code>runtime</code> de <code>runtime</code> y el <code>reflect</code> miran nuestras funciones Go a través del valor de la función. </p><br><p>  Lista de recursos utilizados: </p><br><ul><li>  <a href="https://golang.org/s/go11func" rel="nofollow">Ir 1.1 Llamadas de función</a> </li><li>  <a href="https://www.pnfsoftware.com/blog/analyzing-golang-executables/" rel="nofollow">Analizando ejecutables de Golang</a> </li><li>  <a href="" rel="nofollow">Ir diseño "ABI interno"</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482392/">https://habr.com/ru/post/482392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482374/index.html">Desarrollo de juegos en LibGDX utilizando la plantilla del sistema de componentes de la entidad</a></li>
<li><a href="../482378/index.html">Una breve historia de Wacom: cómo la tecnología de tabletas gráficas llegó a los lectores electrónicos</a></li>
<li><a href="../482382/index.html">¿Cuatro principios de traducción, o de qué manera una persona no cederá ante un traductor automático?</a></li>
<li><a href="../482384/index.html">Mi proyecto no realizado. Red de 200 enrutadores MikroTik</a></li>
<li><a href="../482390/index.html">Tutorial de Ember.js tutorial. Aplicación Super Rentals. Parte 1.2</a></li>
<li><a href="../482396/index.html">Cómo elegir cursos comerciales que enseñen profesiones de TI</a></li>
<li><a href="../482398/index.html">Replicación lógica de PostgreSQL a Erlang</a></li>
<li><a href="../482400/index.html">Una selección de datos estadísticos entretenidos # 2</a></li>
<li><a href="../482402/index.html">Patrón de fábrica Ejemplo de aplicación en Unity</a></li>
<li><a href="../482404/index.html">Nemotecnia: explorando métodos para aumentar la memoria cerebral</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>