<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♠️ 🚴🏾 📆 تجاوز يساوي و GetHashCode. لكن هل هو ضروري؟ ⚗️ 🍍 🐔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="إذا كنت معتادًا على C # ، فأنت على الأرجح تعرف أنه يجب عليك دائمًا تجاوز Equals ، وكذلك GetHashCode ، لتجنب GetHashCode الأداء. ولكن ماذا سيحدث إذا لم...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تجاوز يساوي و GetHashCode. لكن هل هو ضروري؟</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/" style=";text-align:right;direction:rtl"> إذا كنت معتادًا على C # ، فأنت على الأرجح تعرف أنه يجب عليك دائمًا تجاوز <code>Equals</code> ، وكذلك <code>GetHashCode</code> ، لتجنب <code>GetHashCode</code> الأداء.  ولكن ماذا سيحدث إذا لم يتم ذلك؟  اليوم ، نقارن الأداء مع خيارين للضبط ونأخذ في الاعتبار الأدوات التي تساعد على تجنب الأخطاء. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2 style=";text-align:right;direction:rtl">  ما مدى خطورة هذه المشكلة؟ </h2><br>  لا تؤثر كل مشكلة أداء محتملة على وقت تشغيل التطبيق.  طريقة <code>Enum.HasFlag</code> ليست فعالة للغاية (*) ، ولكن إذا لم تستخدمها على جزء من التعليمات البرمجية التي تستهلك موارد كثيرة ، فلن تكون هناك مشاكل خطيرة في المشروع.  هذا هو الحال أيضًا مع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">النسخ المحمية</a> التي تم إنشاؤها بواسطة أنواع هيكلية غير للقراءة فقط في سياق للقراءة فقط.  المشكلة موجودة ، ولكن من غير المحتمل أن تكون ملحوظة في التطبيقات العادية. <br><br>  <i>(*) تم إصلاحه في .NET Core 2.1 ، وكما ذكرت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">في منشور سابق</a> ، يمكن الآن تخفيف العواقب باستخدام HasFlag ذاتي التكوين للإصدارات الأقدم.</i> <br><br>  لكن المشكلة التي سنتحدث عنها اليوم هي مشكلة خاصة.  إذا لم يتم إنشاء طريقتين <code>Equals</code> و <code>GetHashCode</code> في البنية ، فسيتم استخدام إصداراتهما القياسية من <code>System.ValueType</code> .  ويمكن أن تقلل بشكل كبير من أداء التطبيق النهائي. <br><br><h2 style=";text-align:right;direction:rtl">  لماذا الإصدارات القياسية بطيئة؟ </h2><br>  بذل مؤلفو CLR قصارى جهدهم لجعل الإصدارات القياسية من Equals و GetHashCode فعالة قدر الإمكان لأنواع القيم.  ولكن هناك عدة أسباب لفقدان هذه الأساليب في فعالية إصدار المستخدم ، المكتوب لنوع معين يدويًا (أو تم إنشاؤه بواسطة المترجم). <br><br>  1. توزيع تحويل العبوة.  تم تصميم CLR بطريقة تجعل كل استدعاء لعنصر محدد في <code>System.ValueType</code> أو <code>System.Enum</code> يؤدي إلى تحويل التفاف (**). <br><br>  <i>(**) إذا كانت الطريقة لا تدعم تجميع JIT.</i>  <i>على سبيل المثال ، في Core CLR 2.1 ، يتعرف برنامج التحويل البرمجي JIT على طريقة <code>Enum.HasFlag</code> ويقوم بإنشاء رمز مناسب لا يبدأ الالتفاف.</i> <br><br>  2. التعارضات المحتملة في الإصدار القياسي من طريقة <code>GetHashCode</code> .  عند تنفيذ دالة التجزئة ، نواجه معضلة: لجعل توزيع دالة التجزئة جيدًا أو سريعًا.  في بعض الحالات ، يمكنك القيام بالأمرين معًا ، ولكن في نوع <code>ValueType.GetHashCode</code> ، يكون هذا صعبًا عادةً. <br><br>  دالة التجزئة التقليدية لبنية النوع "تجمع" رموز التجزئة في جميع المجالات.  ولكن الطريقة الوحيدة للحصول على رمز تجزئة الحقل في أسلوب <code>ValueType</code> هي استخدام الانعكاس.  هذا هو السبب في أن مؤلفي CLR قرروا التضحية بالسرعة من أجل التوزيع ، والإصدار القياسي من <code>GetHashCode</code> يُرجع فقط رمز التجزئة للحقل غير الصفري الأول و <a href="">"يفسد" عليه بمعرف النوع</a> (***) (لمزيد من التفاصيل ، انظر <code>RegularGetValueTypeHashCode</code> في coreclr repo على github). <br><br>  <i>(***) استنادًا إلى التعليقات الموجودة في مستودع CoreCLR ، قد يتغير الوضع في المستقبل.</i> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  هذه خوارزمية معقولة حتى يحدث خطأ ما.  ولكن إذا كنت محظوظًا وكانت قيمة الحقل الأول من نوع البنية هي نفسها في معظم الحالات ، فستنتج وظيفة التجزئة دائمًا نفس النتيجة.  كما كنت قد خمنت ، إذا قمت بحفظ هذه الحالات في مجموعة تجزئة أو جدول تجزئة ، فسوف ينخفض ​​الأداء. <br><br>  3. سرعة التنفيذ على أساس التفكير منخفضة.  منخفض جدا.  التأمل هو أداة قوية إذا تم استخدامه بشكل صحيح.  لكن العواقب ستكون رهيبة إذا قمت بتشغيله على جزء من التعليمات البرمجية التي تتطلب موارد مكثفة. <br><br>  دعونا نرى كيف تؤثر وظيفة التجزئة الفاشلة ، التي قد تنتج عن (2) والتطبيق القائم على الانعكاس ، على الأداء: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  إذا كانت قيمة الحقل الأول هي نفسها دائمًا ، فعندئذٍ تقوم دالة التجزئة تلقائيًا بإرجاع قيمة متساوية لجميع العناصر ويتم تحويل مجموعة التجزئة بشكل فعال إلى قائمة مرتبطة باستخدام عمليات البحث والبحث O (N).  يصبح عدد العمليات لملء المجموعة O (N ^ 2) (حيث N هو عدد الإدخالات ذات التعقيد O (N) لكل إدراج).  وهذا يعني أن الإدراج في مجموعة من 1000 عنصر سيؤدي إلى إجراء 500000 مكالمة تقريبًا مع <code>ValueType.Equals</code> .  هنا عواقب طريقة باستخدام التفكير! <br><br>  كما يظهر الاختبار ، سيكون الأداء مقبولًا إذا كنت محظوظًا وكان العنصر الأول للهيكل فريدًا (في حالة <code>Position_Path_DefaultEquality</code> ).  ولكن إذا لم يكن الأمر كذلك ، فستكون الإنتاجية منخفضة للغاية. <br><br><h2 style=";text-align:right;direction:rtl">  مشكلة حقيقية </h2><br>  أعتقد الآن أنه يمكنك تخمين المشكلة التي واجهتها مؤخرًا.  منذ أسبوعين تلقيت رسالة خطأ: زاد وقت تشغيل التطبيق الذي أعمل عليه من 10 إلى 60 ثانية.  لحسن الحظ ، كان التقرير مفصلاً للغاية واحتوى على أثر لأحداث Windows ، لذلك تم اكتشاف نقطة المشكلة بسرعة - <code>ValueType.Equals</code> . <br><br>  بعد إلقاء نظرة سريعة على الشفرة ، أصبح من الواضح ما هي المشكلة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  لقد استخدمت مجموعة تحتوي على نوع هيكل مخصص مع الإصدار القياسي من <code>Equals</code> .  ولسوء الحظ ، كان يحتوي على حقل أول اختياري ، يساوي دائمًا <code>String.equals</code> .  ظلت الإنتاجية عالية حتى زاد عدد العناصر في المجموعة بشكل ملحوظ.  في غضون دقائق ، تمت تهيئة مجموعة تحتوي على عشرات الآلاف من العناصر. <br><br><h2 style=";text-align:right;direction:rtl">  هل تطبيق <code>ValueType.Equals/GetHashCode</code> الافتراضي يعمل دائمًا ببطء؟ </h2><br>  لكل من <code>ValueType.Equals</code> و <code>ValueType.GetHashCode</code> طرق تحسين خاصة.  إذا كان النوع لا يحتوي على "مؤشرات" وتم تعبئته بشكل صحيح (سأعرض مثالاً في دقيقة) ، فسيتم استخدام الإصدارات المحسنة: يتم تنفيذ عمليات تكرار <code>GetHashCode</code> على كتل المثيلات ، ويتم استخدام XOR من 4 بايت ، ويقارن أسلوب <code>Equals</code> مثيلين باستخدام <code>memcmp</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  يتم تنفيذ الفحص نفسه في <code>ValueTypeHelper::CanCompareBits</code> ، ويسمى من تكرار <code>ValueType.Equals</code> ومن تكرار <code>ValueType.GetHashCode</code> . <br><br>  لكن التحسين شيء خبيث للغاية. <br><br>  أولاً ، من الصعب فهمه عند تشغيله ؛  حتى التغييرات الطفيفة على الرمز يمكن تشغيلها وإيقافها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  لمزيد من المعلومات حول بنية الذاكرة ، راجع مدونتي ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"العناصر الداخلية لكائن مُدار ، الجزء 4. البنية الميدانية"</a> . <br><br>  ثانياً ، مقارنة الذاكرة لا تعطيك بالضرورة النتيجة الصحيحة.  هنا مثال بسيط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> و <code>+0,0</code> متساويان ، لكن لهما تمثيلات ثنائية مختلفة.  هذا يعني أن <code>Double.Equals</code> صحيح و <code>MyDouble.Equals</code> خطأ.  في معظم الحالات ، لا يكون الفرق كبيرًا ، ولكن تخيل عدد الساعات التي ستقضيها في إصلاح المشكلة الناتجة عن هذا الاختلاف. <br><br><h2 style=";text-align:right;direction:rtl">  كيف تتجنب مشكلة مماثلة؟ </h2><br>  هل يمكنك أن تسألني كيف يمكن أن يحدث ما سبق في موقف حقيقي؟  إحدى الطرق الواضحة لتشغيل أساليب <code>Equals</code> و <code>GetHashCode</code> في أنواع البنية هي استخدام قاعدة FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CA1815</a> .  لكن هناك مشكلة واحدة: هذا نهج صارم للغاية. <br><br>  يمكن أن يكون للتطبيق الذي يعتبر الأداء حاسمًا فيه مئات الأنواع الهيكلية التي لا تستخدم بالضرورة في مجموعات التجزئة أو القواميس.  لذلك ، يمكن لمطوري التطبيقات تعطيل القاعدة ، مما سيؤدي إلى عواقب غير سارة إذا كان نوع البنية يستخدم وظائف معدلة. <br><br>  الطريقة الأكثر صحة هي تحذير المطور إذا تم تخزين بنية نوع "غير مناسب" مع قيم افتراضية متساوية للعناصر (المحددة في التطبيق أو مكتبة خارجية) في مجموعة تجزئة.  بالطبع أتحدث عن <a href="">ErrorProne.NET</a> والقاعدة التي أضفتها بمجرد أن واجهت هذه المشكلة: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  إصدار ErrorProne.NET ليس مثالياً و "يلوم" الكود الصحيح إذا تم استخدام محلل مساواة مخصص في المنشئ: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  ولكن ما زلت أعتقد أن الأمر يستحق التحذير إذا لم يتم استخدام بنية ذات عناصر متساوية افتراضيًا عند إنتاجها.  على سبيل المثال ، عندما راجعت <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> بنية <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> المحددة في mscorlib لا تستبدل <code>Equals</code> و <code>GetHashCode</code> .  من غير المحتمل أن يقوم أي شخص بتعريف متغير مثل <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> اليوم ، ولكن أعتقد أنه حتى BCL يمكنه كسر القاعدة.  لذلك ، من المفيد اكتشاف ذلك قبل فوات الأوان. <br><br><h2 style=";text-align:right;direction:rtl">  الخلاصة </h2><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن أن يكون لتطبيق المساواة الافتراضية للأنواع الهيكلية عواقب وخيمة على تطبيقك.  هذه مشكلة حقيقية وليست نظرية. </li><li style=";text-align:right;direction:rtl">  تستند عناصر المساواة الافتراضية لأنواع القيم إلى التفكير. </li><li style=";text-align:right;direction:rtl">  سيكون التوزيع الذي يقوم به الإصدار القياسي من <code>GetHashCode</code> سيئًا جدًا إذا كان الحقل الأول من العديد من الحالات له نفس القيمة. </li><li style=";text-align:right;direction:rtl">  هناك إصدارات محسنة لطرق <code>Equals</code> و <code>GetHashCode</code> القياسية ، ولكن لا يجب الاعتماد عليها ، لأنه حتى تغيير الرمز الصغير يمكن أن يوقف تشغيلها. </li><li style=";text-align:right;direction:rtl">  استخدم قاعدة FxCop للتأكد من أن كل نوع هيكل يتجاوز عناصر المساواة.  ومع ذلك ، فمن الأفضل منع المشكلة مع المحلل إذا تم تخزين البنية "غير المناسبة" في مجموعة تجزئة أو في جدول تجزئة. </li></ul><br><h2 style=";text-align:right;direction:rtl">  موارد إضافية </h2><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="">ErrorProne.NET على جيثب</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ErrorProne.NET بنيات في المخزن</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar418515/">https://habr.com/ru/post/ar418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar418503/index.html">بعد عام 2020 ، ستحصل المملكة المتحدة على أول ميناء فضائي - في اسكتلندا</a></li>
<li><a href="../ar418505/index.html">نظرة عامة ومقارنة منصات البرمجيات الكمومية ذات مستوى البوابة</a></li>
<li><a href="../ar418507/index.html">ماذا قدم لنا رواد الفضاء؟</a></li>
<li><a href="../ar418509/index.html">يعترف Amazon Rekognition بـ 28 عضوًا في الكونغرس الأمريكي كمجرمين</a></li>
<li><a href="../ar418513/index.html">كيف تكتب كود جيد فقط</a></li>
<li><a href="../ar418517/index.html">تغطية الكود: كيفية تحسين جودة الاختبار</a></li>
<li><a href="../ar418519/index.html">ما الذي يمكن العثور عليه في كود شخص آخر؟ مجموعة مختارة من المواد المفيدة لـ .NET</a></li>
<li><a href="../ar418521/index.html">حجاب السرية على الإطلاق من ألاسكا</a></li>
<li><a href="../ar418523/index.html">لماذا يقوم تجار التجزئة "بالتنصت" على موظفيهم ولماذا لا يزالون يستخدمون التكنولوجيا الصوتية</a></li>
<li><a href="../ar418525/index.html">أصبحت أوبرا متاحة للجميع</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>