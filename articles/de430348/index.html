<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòß üí≤ üïù OpenSceneGraph: Kapselung einer OpenGL-Zustandsmaschine üé´ üßòüèª üîå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Bei der Arbeit mit Rendering-Parametern fungiert OpenGL in der Regel als Zustandsmaschine. Ein Rendering-Status ist eine Sammlung von Sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Kapselung einer OpenGL-Zustandsmaschine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430348/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Bei der Arbeit mit Rendering-Parametern fungiert OpenGL in der Regel als Zustandsmaschine.  Ein Rendering-Status ist eine Sammlung von Statusattributen wie Lichtquellen, Materialien, Texturen und Anzeigemodi, die von den Funktionen glEnable () und glDisable () ein- und ausgeschaltet werden.  Wenn ein bestimmter Status festgelegt ist, bleibt er wirksam, bis eine andere Funktion ihn √§ndert.  Die OpenGL-Pipeline unterst√ºtzt einen Statusstapel zum Speichern und Wiederherstellen von Status zu einem bestimmten Zeitpunkt.  Die Zustandsmaschine gibt dem Entwickler die vollst√§ndige Kontrolle √ºber die aktuellen und gespeicherten Renderzust√§nde auf dem Stapel. <br><br>  Dieser Ansatz ist jedoch bei der Arbeit mit OSG unpraktisch.  Aus diesem Grund wird die OpenGL-Zustandsmaschine von der Klasse osg :: StateSet gekapselt, die sich darum k√ºmmert, mit dem Zustandsstapel zu arbeiten und sie beim Durchlaufen des Szenendiagramms einzurichten. <br><a name="habracut"></a><br>  Eine Instanz der osg :: StateSet-Klasse enth√§lt eine Teilmenge der verschiedenen Rendering-Zust√§nde und kann sie mit der setStateSet () -Methode auf die osg :: Node-Szenenknoten und osg :: Drawable-geometrischen Objekte anwenden <br><br><pre><code class="cpp hljs">osg::StateSet *stateset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::StateSet; node-&gt;setStateSet(stateset);</code> </pre> <br>  Ein sicherer Weg w√§re die Verwendung der Methode getOrCreateStateSet (), die die R√ºckgabe des korrekten Status und dessen Verkn√ºpfung mit dem Knoten oder dem zeichnbaren Objekt garantiert <br><br><pre> <code class="cpp hljs">osg::StateSet *stateset = node-&gt;getOrCreateStateSet();</code> </pre><br>  Die Klassen osg :: Node und osg :: Drawable steuern die Mitgliedsvariable osg :: StateSet √ºber den Smart Pointer osg :: ref_ptr &lt;&gt;.  Dies bedeutet, dass eine Reihe von Zust√§nden auf mehrere Objekte in der Szene aufgeteilt werden kann und nur dann zerst√∂rt wird, wenn alle diese Objekte zerst√∂rt werden. <br><br><h1>  1. Attribute und Modi </h1><br>  OSG definiert die osg :: StateAttribute-Klasse zum Speichern von Rendering-Attributen.  Dies ist eine virtuelle Basisklasse, die von verschiedenen Rendering-Attributen wie Licht, Material und Nebel geerbt wird. <br><br>  Die Rendering-Modi funktionieren wie Schalter, die ein- und ausgeschaltet werden k√∂nnen.  Dar√ºber hinaus sind sie Enumeratoren zugeordnet, mit denen der Typ des OpenGL-Modus angegeben wird.  Manchmal ist der Rendering-Modus einem Attribut zugeordnet. Beispielsweise enth√§lt der GL_LIGHTING-Modus Variablen f√ºr Lichtquellen, die beim Einschalten an die OpenGL-Pipeline gesendet werden, und schaltet die Beleuchtung ansonsten aus. <br><br>  Die osg :: StateSet-Klasse unterteilt Attribute und Modi in zwei Gruppen: Textur und Nicht-Textur.  Es gibt verschiedene √∂ffentliche Methoden zum Hinzuf√ºgen von Nicht-Textur-Attributen und -Modi zu einer Reihe von Zust√§nden: <br><br><ol><li>  setAttribute () - F√ºgt der Menge der Zust√§nde ein Objekt vom Typ osg :: StateAttribute hinzu.  Attribute desselben Typs k√∂nnen nicht in derselben Gruppe von Zust√§nden koexistieren.  Der vorherige Sollwert wird mit dem neuen √ºberschrieben. <br></li><li>  setMode () - H√§ngt einen Modus-Enumerator an eine Reihe von Zust√§nden an und setzt seinen Wert auf osg :: StateAttribute :: ON oder auf osg :: StateAttribute :: OFF, was bedeutet, dass der Modus aktiviert oder deaktiviert wird. <br></li><li>  setAttributeAndModes () - H√§ngt das Rendering-Attribut und den zugeh√∂rigen Modus an und legt den Wert des Switch fest (standardm√§√üig ON).  Es sollte beachtet werden, dass nicht jedes Attribut einen entsprechenden Modus hat, aber Sie k√∂nnen diese Methode in jedem Fall verwenden. <br></li></ol><br>  Mit diesem Code k√∂nnen Sie das Attribut und den zugeh√∂rigen Modus festlegen <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(attr, osg::StateAttribute::ON);</code> </pre><br>  Um Texturattribute festzulegen, muss ein zus√§tzlicher Parameter √ºbergeben werden, der die Textur angibt, auf die er angewendet werden soll.  Osg :: StateSet bietet hierf√ºr mehrere andere √∂ffentliche Methoden an, z. B. setTextureAttribute (), setTextureMode () und setTextureAttributeAndModes (). <br><br><pre> <code class="cpp hljs">stateset-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, textattr, osg::StateAttribute::ON);</code> </pre><br>  Wendet das textattr-Attribut auf die Textur mit dem Bezeichner 0 an. <br><br><h1>  2. Einstellen des Polygon-Anzeigemodus f√ºr Szenenknoten </h1><br>  Wir veranschaulichen die obige Theorie anhand eines praktischen Beispiels: √Ñndern des Rasterisierungsmodus von OpenGL-Polygonen mithilfe der Klasse osg :: PolygonMode, die von osg :: StateAttribute erbt.  Diese Klasse kapselt die Funktion glPolygonMode () und bietet eine Schnittstelle zum Festlegen des Polygonanzeigemodus f√ºr einen bestimmten Szenenknoten. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr einen Polygonmodus</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::PolygonMode&gt; pm = new osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Hier laden wir das Modell unserer geliebten Cessna hoch und wenden Transformationen darauf an. Wir erhalten zwei Instanzen des Modells.  Links von ihnen wenden wir ein Attribut an, das den Modus der Drahtgitteranzeige von Polygonen festlegt <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::PolygonMode&gt; pm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::PolygonMode; pm-&gt;setMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE); transform1-&gt;getOrCreateStateSet()-&gt;setAttribute(pm.get());</code> </pre><br><img src="https://habrastorage.org/webt/pg/v5/ew/pgv5ewaulc_tfjztw5h8gyyap1i.png"><br><br>  Wenn wir uns der OpenGL-Spezifikation zuwenden, k√∂nnen wir uns leicht vorstellen, welche Polygonanzeigeoptionen uns in diesem speziellen Fall bei Verwendung von setMode () zur Verf√ºgung stehen.  Der erste Parameter kann die Werte osg :: PolygonMode :: FRONT, BACK und FRONT_AND_BACK annehmen, die den OpenGL-Enumeratoren GL_FRONT, GL_BACK, GL_FRONT_AND_BACK entsprechen.  Der zweite Parameter kann die Werte osg :: PolygonMode :: POINT, LINE und FILL annehmen, die GL_POINT, GL_LINE und GL_FILL entsprechen.  Keine anderen Tricks, wie sie h√§ufig bei der Entwicklung auf einem reinen OpenGL der Fall sind, werden hier nicht ben√∂tigt - OSG k√ºmmert sich um den gr√∂√üten Teil der Arbeit.  Der Polygon-Anzeigemodus hat keinen zugeordneten Modus und erfordert keinen Aufruf des Paares glEnable () / glDisable ().  Die setAttributeAndModes () -Methode funktioniert auch in diesem Fall einwandfrei, aber der Wert des dritten Parameters ist unbrauchbar. <br><br><h1>  3. Vererbung von Renderzust√§nden.  Anwenden von Attributen und Modi </h1><br>  Die Menge der Knotenzust√§nde wirkt sich auf den aktuellen Knoten und alle seine untergeordneten Knoten aus.  Beispielsweise wird das Attribut osg :: PolygonMode, das im vorherigen Beispiel f√ºr transform1 festgelegt wurde, auf alle untergeordneten Elemente dieses Knotens angewendet.  Der untergeordnete Knoten kann jedoch die √ºbergeordneten Attribute √ºberschreiben. Das hei√üt, der Renderstatus wird vom √ºbergeordneten Knoten geerbt, wenn der untergeordnete Knoten das Verhalten nicht √§ndert. <br><br>  Manchmal m√ºssen Sie das Verhalten eines Knotens in Bezug auf die Attributverwendung neu definieren.  In den meisten 3D-Editoren kann der Benutzer beispielsweise mehrere Modelle laden und den Anzeigemodus f√ºr alle geladenen Modelle gleichzeitig √§ndern, unabh√§ngig davon, wie sie zuvor angezeigt wurden.  Mit anderen Worten, alle Modelle im Editor m√ºssen ein einzelnes Attribut erben, unabh√§ngig davon, wie sie zuvor f√ºr jedes der Modelle festgelegt wurden.  In OSG kann dies beispielsweise mit dem Flag osg :: StateAttribute :: OVERRIDE implementiert werden <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttribute(attr, osg::StateAttribute::OVERRIDE);</code> </pre><br>  Beim Festlegen von Modi und Modi mit Attributen wird der bitweise ODER-Operator verwendet <br><br><pre> <code class="cpp hljs">stateset-&gt;StateAttributeAndModes(attr, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE);</code> </pre><br>  Dar√ºber hinaus kann das Attribut auch vor dem √úberschreiben gesch√ºtzt werden. Dazu muss es mit dem Flag osg :: StateAttribute :: PROTECTED gekennzeichnet werden. <br><br>  Es gibt ein drittes Flag, osg :: StateAttribute :: INHERIT, das angibt, dass dieses Attribut von der Gruppe der Zust√§nde des √ºbergeordneten Knotens geerbt werden soll. <br><br>  Hier ist ein kurzes Beispiel mit den Flags OVERRIDE und PROTECTED.  Der Stammknoten wird auf OVERRIDE gesetzt, um alle untergeordneten Knoten zu zwingen, ihre Attribute und Modi zu erben.  In diesem Fall versuchen die untergeordneten Knoten, ihren Status mit oder ohne Hilfe des Flag PROTECTED zu √§ndern, was zu unterschiedlichen Ergebnissen f√ºhrt. <br><br><div class="spoiler">  <b class="spoiler_title">Beispieltext erben</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/PolygonMode&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/glider.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-0.5f, 0.0f, 0.0f)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(0.5f, 0.0f, 0.0f)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::ON | osg::StateAttribute::OVERRIDE); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/lf/8h/u4/lf8hu4n3ii1bor6lgsktbischd0.png"><br><br>  Um zu verstehen, was los ist, m√ºssen Sie sich ansehen, wie ein normal beleuchteter Drachen aussieht, indem Sie seinen Vollzeit-OSG-Osgviewer herunterladen <br><br><pre> <code class="bash hljs">$ osgviewer glider.osg</code> </pre><br>  In diesem Beispiel versuchen wir, den Beleuchtungsmodus f√ºr die Knoten transform1 und transform2 zu √§ndern, indem wir die Beleuchtung vollst√§ndig ausschalten. <br><br><pre> <code class="cpp hljs">transform1-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF); transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  In diesem Fall aktivieren wir den Beleuchtungsmodus f√ºr den Stammknoten und verwenden das OVERRIDE-Flag f√ºr alle untergeordneten Knoten, damit diese den Status des Stammknotens erben.  Trnsform2 verwendet jedoch das Flag PROTECTED, um zu verhindern, dass sich die Einstellungen des Stammknotens auswirken. <br><br><pre> <code class="cpp hljs">transform2-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::PROTECTED);</code> </pre><br>  Trotz der Tatsache, dass wir die Beleuchtung am Knoten transform1 ausschalten, leuchtet der linke H√§ngegleiter weiterhin, da die Einstellungen des Szenenstamms unseren Versuch blockierten, die Beleuchtung daf√ºr auszuschalten.  Der rechte H√§ngegleiter wird ohne Beleuchtung angezeigt (er sieht nur heller aus, weil er mit einer einfachen Farbe √ºberflutet ist, ohne dass die Beleuchtung wiedergegeben wird), da transform2 vor dem Erben der Attribute des Wurzelknotens gesch√ºtzt ist. <br><br><h1>  4. Liste der in OpenSceneGraph unterst√ºtzten OpenGL-Attribute </h1><br>  OSG unterst√ºtzt fast alle Attribute und Rendering-Modi, die von OpenGL durch von osg :: StateAttribute abgeleitete Klassen unterst√ºtzt werden.  Die Tabelle zeigt alle Parameter der OpenGL-Zustandsmaschine, die von der Engine verf√ºgbar sind. <br><table><thead><tr><th>  Attributtyp-ID </th><th>  Klassenname </th><th>  Zugeh√∂riger Modus </th><th>  √Ñquivalente OpenGL-Funktion </th></tr></thead><tbody><tr><td>  ALPHEFUNC </td><td>  osg :: AlphaFunc </td><td>  GL_ALPHA_TEST </td><td>  glAlphaFunc () </td></tr><tr><td>  BLENDFUNC </td><td>  osg :: BlendFunc </td><td>  GL_BLEND </td><td>  glBlendFunc () und glBlendFuncSeparate () </td></tr><tr><td>  CLIPPLANE </td><td>  osg :: ClipPlane </td><td>  GL_CLIP_PLANEi (i von 1 bis 5) </td><td>  glClipPlane () </td></tr><tr><td>  Farbmaske </td><td>  osg :: ColorMask </td><td>  - - </td><td>  glColorMask () </td></tr><tr><td>  CULLFACE </td><td>  osg :: CullFace </td><td>  GL_CULLFACE </td><td>  glCullFace () </td></tr><tr><td>  Tiefe </td><td>  osg :: Tiefe </td><td>  GL_DEPTH_TEST </td><td>  glDepthFunc (), glDepthRange () und glDepthMask () </td></tr><tr><td>  NEBEL </td><td>  osg :: Nebel </td><td>  GL_FOG </td><td>  glFog () </td></tr><tr><td>  VORNE </td><td>  osg :: FrontFace </td><td>  - - </td><td>  glFrontFace () </td></tr><tr><td>  Licht </td><td>  osg :: Licht </td><td>  GL_LIGHTi (i von 1 bis 7) </td><td>  glLight () </td></tr><tr><td>  LICHTMODELL </td><td>  osg :: LightModel </td><td>  - - </td><td>  glLightModel () </td></tr><tr><td>  LINESTRIPPEL </td><td>  osg :: LineStripple </td><td>  GL_LINE_STRIPPLE </td><td>  glLineStripple () </td></tr><tr><td>  LINIENBREITE </td><td>  osg :: LineWidth </td><td>  - - </td><td>  glLineWidht () </td></tr><tr><td>  LOGICOP </td><td>  osg :: LogicOp </td><td>  GL_COLOR_LOGIC_OP </td><td>  glLogicOp () </td></tr><tr><td>  MATERIAL </td><td>  osg :: Material </td><td>  - - </td><td>  glMaterial () und glColorMaterial () </td></tr><tr><td>  PUNKT </td><td>  osg :: Point </td><td>  GL_POINT_SMOOTH </td><td>  glPointParameter () </td></tr><tr><td>  POINTSPRITE </td><td>  osg :: PointSprite </td><td>  GL_POINT_SPRITE_ARB </td><td>  Funktionen zum Arbeiten mit OpenGL-Sprites </td></tr><tr><td>  POLYGONMODE </td><td>  osg :: PolygonMode </td><td>  - - </td><td>  glPolygonMode () </td></tr><tr><td>  POLYGONOFFSET </td><td>  osg :: PolygonOffset </td><td>  GL_POLYGON_OFFSET_POINT </td><td>  glPolygonOffset () </td></tr><tr><td>  POLYGONSTRIPPEL </td><td>  osg :: PolygonStripple </td><td>  GL_POLYGON_STRIPPLE </td><td>  glPolygonStripple () </td></tr><tr><td>  SCHERE </td><td>  osg :: Scissor </td><td>  GL_SCISSOR_TEST </td><td>  glScissor () </td></tr><tr><td>  SHADEMODEL </td><td>  osg :: ShadeModel </td><td>  - - </td><td>  glShadeModel () </td></tr><tr><td>  Schablone </td><td>  osg :: Schablone </td><td>  GL_STENCIL_TEST </td><td>  glStencilFunc (), glStencilOp () und glStencilMask () </td></tr><tr><td>  Texenv </td><td>  osg :: TexEnv </td><td>  - - </td><td>  glTexEnv () </td></tr><tr><td>  Texgen </td><td>  osg :: TexGen </td><td>  GL_TEXTURE_GEN_S </td><td>  glTexGen () </td></tr></tbody></table><br>  Die Spalte Attributtyp-ID gibt den spezifischen OSG-Bezeichner an, der dieses Attribut in den Enumeratoren der Klasse osg :: StateAttribute identifiziert.  Es kann in der Methode getAttribute verwendet werden, um den Wert eines bestimmten Attributs abzurufen. <br><br><pre> <code class="cpp hljs">osg::PolygonMode *pm = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::PolygonMode *&gt;(stateset-&gt;getAttribute(osg::StateAttribute::POLYGONMODE));</code> </pre><br>  Ein g√ºltiger Zeiger zeigt an, dass das Attribut zuvor festgelegt wurde.  Andernfalls liegt die Methode bei NULL.  Sie k√∂nnen den Wert des aktuellen Modus auch √ºber den Aufruf abrufen <br><br><pre> <code class="cpp hljs">osg::StateAttribute::GLModeValue value = stateset-&gt;getMode(GL_LIGHTING);</code> </pre><br>  Hier wird der GL_LIGHTING-Enumerator verwendet, um die Beleuchtung in der gesamten Szene zu aktivieren / deaktivieren. <br><br><h1>  5. Wenden Sie Nebel auf das Modell in der Szene an </h1><br>  Lassen Sie uns den Nebeleffekt als ideale Methode anf√ºhren, um zu zeigen, wie mit verschiedenen Attributen und Rendering-Modi gearbeitet wird.  OpenGL verwendet eine lineare und zwei exponentielle Gleichungen, die das Nebelmodell beschreiben und von der Klasse osg :: Fog unterst√ºtzt werden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispieltext Nebel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Fog&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Fog&gt; fog = new osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(500.0f); fog-&gt;setEnd(2500.0f); fog-&gt;setColor(osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/lz.osg"); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get()); osgViewer::Viewer viewer; viewer.setSceneData(model.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Erstellen Sie zun√§chst das Nebelattribut.  Wir verwenden ein lineares Modell und passen den Bereich der Nebelanzeige an den Abstand zum Modell an <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Fog&gt; fog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Fog; fog-&gt;setMode(osg::Fog::LINEAR); fog-&gt;setStart(<span class="hljs-number"><span class="hljs-number">500.0f</span></span>); fog-&gt;setEnd(<span class="hljs-number"><span class="hljs-number">2500.0f</span></span>); fog-&gt;setColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Wir laden das Landschaftsbeispiel lz.osg und wenden dieses Attribut darauf an <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/lz.osg"</span></span>); model-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(fog.get());</code> </pre><br>  Im Viewer-Fenster sehen wir eine unscharfe Landschaft und k√∂nnen sehen, wie sich die Nebeldichte in Abh√§ngigkeit von der Entfernung zum Modell √§ndert <br><br><img src="https://habrastorage.org/webt/gq/8f/fu/gq8ffuswpsbsl1-xxqzprwvprle.png"><br><br><img src="https://habrastorage.org/webt/3z/st/f6/3zstf6mlxlvenapqhvj3zsxyh2i.png"><br><br><img src="https://habrastorage.org/webt/k-/mc/cj/k-mccjrssmakzwwrht-b5azkzg4.png"><br><br><h1>  6. Arbeiten Sie mit Lichtquellen und Licht </h1><br>  Wie bei OpenGL unterst√ºtzt OSG bis zu acht Lichtquellen, um Szenenobjekte direkt zu treffen.  Wie OpenGL berechnet OSG Schatten nicht automatisch.  Lichtstrahlen kommen von Quellen in geraden Linien, werden von Objekten reflektiert und von diesen gestreut, wonach sie von den Augen des Betrachters wahrgenommen werden.  F√ºr eine qualitativ hochwertige Verarbeitung der Beleuchtung m√ºssen Materialeigenschaften, normale Geometrie von Objekten usw. eingestellt werden. <br><br>  Die Klasse osg :: Light bietet Methoden zum Steuern von Lichtquellen, einschlie√ülich: setLightNum () und getLightNum () - zum Arbeiten mit der Anzahl der Quellen;  setAmbient () und getAmbient () zur Steuerung der umgebenden Komponente;  setDiffuse () und getDiffuse () - zum Arbeiten mit einer verstreuten Komponente usw. <br><br>  OSG beschreibt auch die osg :: LightSource-Klasse zum Hinzuf√ºgen von Lichtquellen zur Szene.  Es stellt die setLight () -Methode bereit und ist der Blattknoten des Szenendiagramms mit einem einzelnen Attribut.  Alle anderen Knoten des Szenendiagramms sind von der Lichtquelle betroffen, wenn der entsprechende Modus f√ºr GL_LIGHTi eingestellt ist.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1 osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum( 1 ); ... //       osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight( light.get() ); ... //             root-&gt;addChild( lightSource.get() ); root-&gt;getOrCreateStateSet()-&gt;setMode( GL_LIGHT1, osg::StateAttribute::ON );</span></span></code> </pre><br>  Eine weitere, bequemere L√∂sung ist die Methode setStateSetModes (), mit der die Lichtquelle mit der gew√ºnschten Nummer automatisch an den Wurzelknoten angeh√§ngt wird <br><br><pre> <code class="cpp hljs">root-&gt;addChild( lightSource.get() ); lightSource-&gt;setStateSetModes( root-&gt;getOrCreateStateSet(), osg::StateAttribute::ON );</code> </pre><br>  Sie k√∂nnen der Lichtquelle untergeordnete Knoten hinzuf√ºgen, dies bedeutet jedoch keineswegs, dass Sie den damit verbundenen Untergraphen auf besondere Weise beleuchten.  Es wird als Geometrie verarbeitet, die durch die physikalische Form der Lichtquelle dargestellt wird. <br><br>  Der Knoten osg :: LightSource kann an den Transformationsknoten angeh√§ngt werden, und beispielsweise kann eine Punktlichtquelle im Raum verschoben werden.  Dies kann deaktiviert werden, indem das absolute Koordinatensystem f√ºr die Lichtquelle eingestellt wird. <br><br><pre> <code class="cpp hljs">lightSource-&gt;setReferenceFrame( osg::LightSource::ABSOLUTE_RF );</code> </pre><br><h1>  7. Erstellen von Lichtquellen in der Szene </h1><br>  Standardm√§√üig setzt OSG die Lichtquelle automatisch auf die Nummer 0, wodurch ein gleichm√§√üiges Richtungslicht an die Szene abgegeben wird.  Sie k√∂nnen jedoch jederzeit mehrere zus√§tzliche Lichtquellen hinzuf√ºgen und diese sogar mithilfe der Koordinatentransformationsknoten steuern.  Es k√∂nnen nur Positionsquellen (Punktquellen) verschoben werden.  Richtungslicht hat nur eine Richtung (ein Strom paralleler Strahlen aus dem Unendlichen) und ist nicht an eine bestimmte Position auf der B√ºhne gebunden.  OpenGL und OSG verwenden die vierte Komponente des Positionsparameters, um den Typ der Lichtquelle anzugeben.  Wenn es 0 ist, wird das Licht als gerichtet betrachtet;  mit einem Wert von 1 - positionell. <br><br>  Betrachten Sie ein kleines Beispiel f√ºr die Arbeit mit Beleuchtung. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler √úberschrift</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osg/LightSource&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Node *createLightSource(int num, const osg::Vec3 &amp;trans, const osg::Vec4 &amp;color) { osg::ref_ptr&lt;osg::Light&gt; light = new osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = new osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = new osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); return sourceTrans.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); osg::Node *light0 = createLightSource(0, osg::Vec3(-20.0f, 0.0f, 0.0f), osg::Vec4(1.0f, 1.0f, 0.0f, 1.0f)); osg::Node *light1 = createLightSource(1, osg::Vec3(0.0f, -20.0f, 0.0f), osg::Vec4(0.0f, 1.0f, 1.0f, 1.0f)); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Um eine Lichtquelle zu erstellen, haben wir eine separate Funktion <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Node *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createLightSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;trans, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec4 &amp;color)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; light-&gt;setLightNum(num); light-&gt;setDiffuse(color); light-&gt;setPosition(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light); osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release(); }</code> </pre><br>  In dieser Funktion bestimmen wir zuerst die von der Quelle angegebenen Beleuchtungsparameter und erstellen dabei das Attribut GL_LIGHTi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Light&gt; light = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Light; <span class="hljs-comment"><span class="hljs-comment">//    light-&gt;setLightNum(num); //   light-&gt;setDiffuse(color); //  .     ,    light-&gt;setPosition(osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f));</span></span></code> </pre><br>  Danach wird eine Lichtquelle erstellt, der dieses Attribut zugeordnet ist. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::LightSource&gt; lightSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::LightSource; lightSource-&gt;setLight(light);</code> </pre><br>  Wir erstellen und konfigurieren den Transformationsknoten und √ºbergeben ihm unsere Lichtquelle als untergeordneten Knoten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; sourceTrans = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; sourceTrans-&gt;setMatrix(osg::Matrix::translate(trans)); sourceTrans-&gt;addChild(lightSource.get());</code> </pre><br>  Geben Sie einen Zeiger auf den Transformationsknoten zur√ºck <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourceTrans.release();</code> </pre><br>  Im Hauptteil des Hauptprogramms laden wir ein dreidimensionales Modell (wieder unsere Lieblings-Cessna). <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get());</code> </pre><br>  Wir erstellen zwei Lichtquellen mit den Nummern 0 und 1. Die erste leuchtet gelb, die zweite blau-gr√ºn <br><br><pre> <code class="cpp hljs">osg::Node *light0 = createLightSource(<span class="hljs-number"><span class="hljs-number">0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); osg::Node *light1 = createLightSource(<span class="hljs-number"><span class="hljs-number">1</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-20.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br>  Wir informieren die OpenGL-Zustandsmaschine dar√ºber, dass 0 und 1 Lichtquellen eingeschaltet und die von uns erstellten Quellen zur Szene hinzugef√ºgt werden m√ºssen <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT0, osg::StateAttribute::ON); root-&gt;getOrCreateStateSet()-&gt;setMode(GL_LIGHT1, osg::StateAttribute::ON); root-&gt;addChild(light0); root-&gt;addChild(light1);</code> </pre><br>  Nach dem Initialisieren und Starten des Viewers erhalten wir ein Bild <br><br><img src="https://habrastorage.org/webt/0s/or/ph/0sorphad56jc2zc8iwfb591qcxk.png"><br><br><h1>  Fazit </h1><br>  Sehr bewegt von der Aufmerksamkeit interessierter Menschen auf diesen Zyklus.  Diese Aktion hat nicht sehr viel begonnen, aber ich bin der Meinung, dass die Community Artikel braucht.  Vielen Dank f√ºr alle m√∂glichen positiven R√ºckmeldungen. <br><br>  Heute habe ich versucht, noch einmal die ziemlich grundlegenden Dinge der OSG-Engine zu betrachten.  Ich bin mir nicht sicher, was cool herausgekommen ist.  Aber bisher stelle ich genau primitive Dinge dar, in dem Sinne, wie ich sie selbst verstanden habe.  Ich habe alle Beispiele pers√∂nlich √ºberpr√ºft, mein Repository ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar.  Vielen Dank, liebe Kollegen, ich werde versuchen, diese Geschichte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fortzusetzen</a> ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430348/">https://habr.com/ru/post/de430348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430336/index.html">Als Programmierer nahm er eine neue Maschine in die Hand</a></li>
<li><a href="../de430340/index.html">Wir warten auf Apples Kopfh√∂rer: AirPods 2019 und die Prognose eines Erstgeborenen in voller Gr√∂√üe</a></li>
<li><a href="../de430342/index.html">Goldratt und Tanken</a></li>
<li><a href="../de430344/index.html">Dell XPS 15 9575: Leistungsstarker und tragbarer konvertierbarer Laptop f√ºr ernsthafte Arbeiten</a></li>
<li><a href="../de430346/index.html">Scrum und Agile retten Ihr Projekt nicht vor einem Fehler</a></li>
<li><a href="../de430352/index.html">Erstes SSL-Zertifikat mit kyrillischen Zeichen</a></li>
<li><a href="../de430354/index.html">Was ist China vor den anderen?</a></li>
<li><a href="../de430356/index.html">Digitale Veranstaltungen in Moskau vom 19. bis 25. November</a></li>
<li><a href="../de430358/index.html">Offene Lektion "Begr√ºndung technischer Aktivit√§ten"</a></li>
<li><a href="../de430360/index.html">Warum und f√ºr wen ist maschinelle √úbersetzung geeignet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>