<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåì üëãüèº üëü Situasi luar biasa: bagian 1 dari 4 üòÆ üåõ üîª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Sudah waktunya untuk berbicara tentang pengecualian atau, lebih tepatnya, situasi luar biasa. Sebelum kita mulai, mari kita lihat defi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Situasi luar biasa: bagian 1 dari 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454630/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="introduction">  Pendahuluan </h2><br><p>  Sudah waktunya untuk berbicara tentang pengecualian atau, lebih tepatnya, situasi luar biasa.  Sebelum kita mulai, mari kita lihat definisi.  Apa situasi yang luar biasa? </p><br><p>  Ini adalah situasi yang membuat eksekusi kode saat ini atau selanjutnya salah.  Maksud saya berbeda dari bagaimana itu dirancang atau dimaksudkan.  Situasi seperti itu membahayakan integritas aplikasi atau bagiannya, misalnya suatu objek.  Ini membawa aplikasi ke keadaan luar biasa atau luar biasa. </p><br><p>  Tetapi mengapa kita perlu mendefinisikan terminologi ini?  Karena itu akan menjaga kita dalam beberapa batasan.  Jika kita tidak mengikuti terminologi, kita bisa terlalu jauh dari konsep yang dirancang yang dapat mengakibatkan banyak situasi ambigu.  Mari kita lihat beberapa contoh praktis: <br><br></p><br><pre><code class="plaintext hljs">struct Number { public static Number Parse(string source) { // ... if(!parsed) { throw new ParsingException(); } // ... } public static bool TryParse(string source, out Number result) { // .. return parsed; } }</code> </pre> <br><p>  Contoh ini agak aneh, dan itu karena suatu alasan.  Saya membuat kode ini sedikit buatan untuk menunjukkan pentingnya masalah yang muncul di dalamnya.  Pertama, mari kita lihat metode <code>Parse</code> .  Mengapa harus membuang pengecualian? </p><a name="habracut"></a><br><ul><li>  Karena parameter yang diterimanya adalah string, tetapi outputnya adalah angka, yang merupakan tipe nilai.  Angka ini tidak dapat menunjukkan validitas perhitungan: hanya ada.  Dengan kata lain, metode ini tidak memiliki antarmuka untuk mengomunikasikan masalah potensial. </li><li>  Di sisi lain, metode ini mengharapkan string yang benar yang berisi beberapa angka dan tidak ada karakter yang berlebihan.  Jika tidak berisi, ada masalah dalam prasyarat untuk metode ini: kode yang memanggil metode kami telah melewati data yang salah. </li></ul><br><p>  Dengan demikian, situasi ketika metode ini mendapatkan string dengan data yang salah luar biasa karena metode ini tidak dapat mengembalikan nilai yang benar atau apa pun.  Dengan demikian, satu-satunya cara adalah dengan melemparkan pengecualian. </p><br><p>  Varian kedua dari metode ini dapat menandakan beberapa masalah dengan data input: nilai kembali di sini adalah <code>boolean</code> yang menunjukkan keberhasilan pelaksanaan metode.  Metode ini tidak perlu menggunakan pengecualian untuk menandakan masalah: mereka semua tercakup oleh nilai balik <code>false</code> . </p><br><h2 id="overview">  Ikhtisar </h2><br><p>  Penanganan pengecualian mungkin terlihat semudah ABC: kita hanya perlu menempatkan blok <code>try-catch</code> dan menunggu acara yang sesuai.  Namun, kesederhanaan ini menjadi mungkin karena pekerjaan yang luar biasa dari tim CLR dan CoreCLR yang menyatukan semua kesalahan yang datang dari semua arah dan sumber ke dalam CLR.  Untuk memahami apa yang akan kita bicarakan selanjutnya, mari kita lihat diagram: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e12/163/521/e121635214ad6b5b5675ba4231eb85e7.png"></p><br><p>  Kita dapat melihat bahwa di dalam .NET Framework besar ada dua dunia: semua yang menjadi milik CLR dan semua yang tidak, termasuk semua kemungkinan kesalahan yang muncul di Windows dan bagian lain dari dunia yang tidak aman. </p><br><ul><li>  Structured Exception Handling (SEH) adalah cara standar Windows menangani pengecualian.  Ketika metode <code>unsafe</code> dipanggil dan pengecualian dilemparkan, ada konversi pengecualian CLR yang tidak aman di kedua arah: dari tidak aman ke CLR dan mundur.  Ini karena CLR dapat memanggil metode yang tidak aman yang pada gilirannya dapat memanggil metode CLR. </li><li>  Vectored Exception Handling (VEH) adalah akar dari SEH dan memungkinkan Anda untuk meletakkan penangan Anda di tempat-tempat di mana pengecualian mungkin dilemparkan.  Secara khusus, ini digunakan untuk menempatkan <code>FirstChanceException</code> . </li><li>  Pengecualian COM + muncul ketika sumber masalah adalah komponen COM.  Dalam kasus ini, lapisan antara COM dan metode .NET harus mengubah kesalahan COM menjadi pengecualian .NET. </li><li>  Dan, tentu saja, pembungkus untuk HRESULT.  Mereka diperkenalkan untuk mengkonversi model WinAPI (kode kesalahan terkandung dalam nilai kembali, sementara nilai kembali diperoleh dengan menggunakan parameter metode) menjadi model pengecualian karena ini merupakan pengecualian yang merupakan standar untuk .NET. </li></ul><br><p>  Di sisi lain, ada bahasa di atas CLI yang masing-masing kurang lebih memiliki fungsi untuk menangani pengecualian.  Misalnya, baru-baru ini VB.NET atau F # memiliki fungsi penanganan pengecualian yang lebih kaya yang dinyatakan dalam sejumlah filter yang tidak ada di C #. </p><br><h2 id="return-codes-vs-exception">  Kembali kode vs  pengecualian </h2><br><p>  Secara terpisah, saya harus menyebutkan model penanganan kesalahan aplikasi menggunakan kode kembali.  Gagasan mengembalikan kesalahan itu jelas dan jelas.  Selain itu, jika kami memperlakukan pengecualian sebagai operator <code>goto</code> , penggunaan kode pengembalian menjadi lebih masuk akal: dalam hal ini, pengguna metode melihat kemungkinan kesalahan dan dapat memahami kesalahan yang mungkin terjadi.  Namun, jangan menebak apa yang lebih baik dan untuk apa, tetapi diskusikan masalah pilihan dengan menggunakan teori yang beralasan. </p><br><p>  Misalkan semua metode memiliki antarmuka untuk mengatasi kesalahan.  Maka semua metode akan terlihat seperti: </p><br><pre> <code class="plaintext hljs">public bool TryParseInteger(string source, out int result); public DialogBoxResult OpenDialogBox(...); public WebServiceResult IWebService.GetClientsList(...); public class DialogBoxResult : ResultBase { ... } public class WebServiceResult : ResultBase { ... }</code> </pre> <br><p>  Dan penggunaannya akan terlihat seperti: </p><br><pre> <code class="plaintext hljs">public ShowClientsResult ShowClients(string group) { if(!TryParseInteger(group, out var clientsGroupId)) return new ShowClientsResult { Reason = ShowClientsResult.Reason.ParsingFailed }; var webResult = _service.GetClientsList(clientsGroupId); if(!webResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.ServiceFailed, WebServiceResult = webResult }; } var dialogResult = _dialogsService.OpenDialogBox(webResult.Result); if(!dialogResult.Successful) { return new ShowClientsResult { Reason = ShowClientsResult.Reason.DialogOpeningFailed, DialogServiceResult = dialogResult }; } return ShowClientsResult.Success(); }</code> </pre> <br><p>  Anda mungkin berpikir kode ini kelebihan beban dengan penanganan kesalahan.  Namun, saya ingin Anda mempertimbangkan kembali posisi Anda: semuanya di sini adalah persaingan dari mekanisme yang melempar dan menangani pengecualian. </p><br><p>  Bagaimana metode melaporkan masalah?  Itu bisa melakukannya dengan menggunakan antarmuka untuk melaporkan kesalahan.  Misalnya, dalam metode <code>TryParseInteger</code> antarmuka tersebut diwakili oleh nilai kembali: jika semuanya OK, metode akan mengembalikan <code>true</code> .  Jika tidak OK, itu akan kembali <code>false</code> .  Namun, ada kerugian di sini: nilai riil dikembalikan melalui parameter <code>out int result</code> .  Kerugiannya adalah bahwa di satu sisi nilai kembali secara logis dan oleh persepsi memiliki esensi "nilai kembali" lebih dari yang <code>out</code> dari parameter. Di sisi lain, kami tidak selalu peduli tentang kesalahan. Memang, jika string dimaksudkan untuk parsing berasal dari layanan yang menghasilkan string ini, kami tidak perlu memeriksanya untuk kesalahan: string akan selalu benar dan baik untuk parsing. Namun, misalkan kita mengambil implementasi lain dari metode ini: </p><br><pre> <code class="plaintext hljs">public int ParseInt(string source);</code> </pre> <br><p>  Lalu, ada pertanyaan: jika string memang memiliki kesalahan, apa yang harus dilakukan metode ini?  Haruskah mengembalikan nol?  Ini tidak benar: tidak ada nol dalam string.  Dalam kasus ini, kami memiliki konflik kepentingan: varian pertama memiliki terlalu banyak kode, sedangkan varian kedua tidak memiliki sarana untuk melaporkan kesalahan.  Namun, sebenarnya mudah untuk memutuskan kapan harus menggunakan kode pengembalian dan kapan harus menggunakan pengecualian. </p><br><blockquote>  Jika mendapatkan kesalahan adalah norma, pilih kode kembali.  Sebagai contoh, adalah normal ketika algoritma penguraian teks menemukan kesalahan dalam teks, tetapi jika algoritma lain yang bekerja dengan string yang diuraikan mendapat kesalahan dari pengurai, itu bisa kritis atau, dengan kata lain, luar biasa. </blockquote><br><h2 id="try-catch-finally-in-brief">  Coba-tangkap-akhirnya secara singkat </h2><br><p>  Blok <code>try</code> mencakup bagian di mana programmer berharap mendapatkan situasi kritis yang diperlakukan sebagai norma oleh kode eksternal.  Dengan kata lain, jika beberapa kode menganggap keadaan internal tidak konsisten berdasarkan pada beberapa aturan dan melempar pengecualian, sistem eksternal, yang memiliki pandangan yang lebih luas dari situasi yang sama, dapat menangkap pengecualian ini menggunakan blok <code>catch</code> dan menormalkan pelaksanaan kode aplikasi .  Dengan demikian, <em>Anda melegalkan pengecualian di bagian kode ini dengan menangkapnya</em> .  Saya pikir ini adalah ide penting yang membenarkan larangan menangkap semua <code>try-catch(Exception ex){ ...}</code> <em>berjaga-jaga</em> . </p><br><p>  Itu tidak berarti bahwa menangkap pengecualian bertentangan dengan beberapa ideologi.  Saya mengatakan bahwa Anda harus menangkap hanya kesalahan yang Anda harapkan dari bagian kode tertentu.  Misalnya, Anda tidak bisa mengharapkan semua jenis pengecualian yang diwarisi dari <code>ArgumentException</code> atau Anda tidak bisa mendapatkan <code>NullReferenceException</code> , karena seringkali itu berarti bahwa masalah lebih pada kode <em>Anda</em> daripada dalam yang disebut.  Tetapi patut untuk berharap bahwa Anda tidak akan dapat membuka file yang dimaksud.  Bahkan jika Anda 200% yakin Anda akan bisa, jangan lupa untuk memeriksanya. </p><br><p>  Blok <code>finally</code> juga terkenal.  Sangat cocok untuk semua kasus yang dicakup oleh blok <code>try-catch</code> .  Kecuali untuk beberapa situasi <em>khusus yang</em> jarang, blok ini akan <em>selalu</em> berfungsi.  Mengapa jaminan kinerja seperti itu diperkenalkan?  Untuk membersihkan sumber daya dan kelompok objek yang dialokasikan atau ditangkap di blok <code>try</code> dan yang menjadi tanggung jawab blok ini. </p><br><p>  Blok ini sering digunakan tanpa blok <code>catch</code> ketika kita tidak peduli kesalahan mana yang memecahkan suatu algoritma, tetapi kita perlu membersihkan semua sumber daya yang dialokasikan untuk algoritma ini.  Mari kita lihat contoh sederhana: algoritma penyalinan file membutuhkan dua file terbuka dan rentang memori untuk buffer uang tunai.  Bayangkan kita mengalokasikan memori dan membuka satu file, tetapi tidak bisa membuka yang lain.  Untuk membungkus semuanya dalam satu "transaksi" secara atomis, kami menempatkan ketiga operasi dalam satu blok <code>try</code> (sebagai varian implementasi) dengan sumber daya yang dibersihkan pada <code>finally</code> . Ini mungkin tampak seperti contoh yang disederhanakan tetapi yang paling penting adalah menunjukkan esensinya. </p><br><p>  Apa yang sebenarnya tidak dimiliki C # adalah blok <code>fault</code> yang diaktifkan setiap kali terjadi kesalahan.  Ini seperti <code>finally</code> menggunakan steroid.  Jika kita punya ini, kita bisa, misalnya, membuat titik masuk tunggal untuk mencatat situasi luar biasa: </p><br><pre> <code class="plaintext hljs">try { //... } fault exception { _logger.Warn(exception); }</code> </pre><br><p>  Hal lain yang harus saya sentuh dalam pengantar ini adalah filter pengecualian.  Ini bukan fitur baru pada platform .NET tetapi pengembang C # mungkin baru di dalamnya: penyaringan pengecualian hanya muncul di v.  6.0  Filter harus menormalkan situasi ketika ada satu jenis pengecualian yang menggabungkan beberapa jenis kesalahan.  Itu akan membantu kita ketika kita ingin berurusan dengan skenario tertentu tetapi harus menangkap seluruh kelompok kesalahan terlebih dahulu dan memfilternya nanti.  Tentu saja, maksud saya kode dari jenis berikut: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) { switch(exception.ErrorCode) { case ErrorCode.MissingModifier: // ... break; case ErrorCode.MissingBracket: // ... break; default: throw; } }</code> </pre> <br><p>  Nah, sekarang kita dapat menulis ulang kode ini dengan benar: </p><br><pre> <code class="plaintext hljs">try { //... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingModifier) { // ... } catch (ParserException exception) when (exception.ErrorCode == ErrorCode.MissingBracket) { // ... }</code> </pre> <br><p>  Perbaikan di sini bukan karena kurangnya <code>switch</code> .  Saya percaya konstruksi baru ini lebih baik dalam beberapa hal: </p><br><ul><li>  menggunakan <code>when</code> untuk menyaring kita menangkap apa yang kita inginkan dan itu benar dalam hal ideologi; </li><li>  kode menjadi lebih mudah dibaca dalam bentuk baru ini.  Melihat melalui kode, otak kita dapat mengidentifikasi blok untuk menangani kesalahan dengan lebih mudah karena pada awalnya mencari <code>catch</code> dan bukan <code>switch-case</code> ; </li><li>  yang terakhir tetapi tidak kalah pentingnya: perbandingan pendahuluan adalah SEBELUM memasuki blok tangkapan.  Ini berarti bahwa jika kita membuat perkiraan yang salah tentang situasi potensial, konstruk ini akan bekerja lebih cepat daripada <code>switch</code> jika melemparkan pengecualian lagi. </li></ul><br><p>  Banyak sumber mengatakan bahwa fitur khusus dari kode ini adalah pemfilteran terjadi <em>sebelum</em> tumpukan dibuka.  Anda dapat melihat ini dalam situasi ketika tidak ada panggilan lain kecuali biasanya antara tempat di mana pengecualian dilemparkan dan tempat di mana pemeriksaan pemfilteran terjadi. </p><br><pre> <code class="plaintext hljs">static void Main() { try { Foo(); } catch (Exception ex) when (Check(ex)) { ; } } static void Foo() { Boo(); } static void Boo() { throw new Exception("1"); } static bool Check(Exception ex) { return ex.Message == "1"; }</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/e41/c44/c6b/e41c44c6b41164af3aff1aa9489f417f.png" alt="Tumpukan tanpa membuka gulungan"></p><br><p>  Anda dapat melihat dari gambar bahwa jejak stack tidak hanya berisi panggilan pertama <code>Main</code> sebagai titik untuk menangkap pengecualian, tetapi seluruh tumpukan sebelum titik melempar pengecualian ditambah yang kedua masuk ke <code>Main</code> melalui kode yang tidak dikelola.  Kita dapat menganggap bahwa kode ini adalah kode yang tepat untuk melempar pengecualian yang ada dalam tahap penyaringan dan memilih penangan akhir.  Namun, <em>tidak semua panggilan dapat ditangani tanpa tumpukan membuka gulungan</em> .  Saya percaya bahwa keseragaman yang berlebihan dari platform menghasilkan terlalu banyak kepercayaan di dalamnya.  Misalnya, ketika satu domain memanggil metode dari domain lain itu benar-benar transparan dalam hal kode.  Namun, cara metode panggilan bekerja adalah cerita yang sangat berbeda.  Kita akan membicarakannya di bagian selanjutnya. </p><br><h3 id="serialization">  Serialisasi </h3><br><p>  Mari kita mulai dengan melihat hasil menjalankan kode berikut (saya menambahkan transfer panggilan melintasi batas antara dua domain aplikasi). </p><br><pre> <code class="plaintext hljs"> class Program { static void Main() { try { ProxyRunner.Go(); } catch (Exception ex) when (Check(ex)) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { throw new Exception("1"); } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner) dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } } }</code> </pre><br><p>  Kita dapat melihat bahwa tumpukan membuka gulungan terjadi sebelum kita mulai memfilter.  Mari kita lihat screenshot.  Yang pertama diambil sebelum generasi pengecualian: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bda/8d8/792/bda8d87928516a8213cafdf953d029b6.png" alt="Stackunnroll"></p><br><p>  Yang kedua adalah setelahnya: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c2b/f45/dee/c2bf45dee3a13091259468415719dbea.png" alt="Stackacknroll2"></p><br><p>  Mari pelajari penelusuran panggilan sebelum dan sesudah pengecualian difilter.  Apa yang terjadi di sini  Kita dapat melihat bahwa pengembang platform membuat sesuatu yang sekilas tampak seperti perlindungan subdomain.  Pelacakan dipotong setelah metode terakhir dalam rantai panggilan dan kemudian ada transfer ke domain lain.  Tapi saya pikir ini terlihat aneh.  Untuk memahami mengapa hal ini terjadi, mari kita ingat aturan utama untuk tipe yang mengatur interaksi antar domain.  Jenis-jenis ini harus mewarisi <code>MarshalByRefObject</code> dan dapat serial.  Namun, meskipun ketatnya tipe pengecualian C # dapat bersifat apa saja.  Apa artinya  Ini berarti bahwa situasi dapat terjadi ketika pengecualian di dalam subdomain dapat ditangkap dalam domain induk.  Juga, jika objek data yang bisa masuk ke situasi luar biasa memiliki beberapa metode yang berbahaya dalam hal keamanan mereka dapat dipanggil dalam domain induk.  Untuk menghindari ini, pengecualian pertama adalah serial dan kemudian melintasi batas antara domain aplikasi dan muncul lagi dengan tumpukan baru.  Mari kita periksa teori ini: </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] class Cast { [FieldOffset(0)] public Exception Exception; [FieldOffset(0)] public object obj; } static void Main() { try { ProxyRunner.Go(); Console.ReadKey(); } catch (RuntimeWrappedException ex) when (ex.WrappedException is Program) { ; } } static bool Check(Exception ex) { var domain = AppDomain.CurrentDomain.FriendlyName; // -&gt; TestApp.exe return ex.Message == "1"; } public class ProxyRunner : MarshalByRefObject { private void MethodInsideAppDomain() { var x = new Cast {obj = new Program()}; throw x.Exception; } public static void Go() { var dom = AppDomain.CreateDomain("PseudoIsolated", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory }); var proxy = (ProxyRunner)dom.CreateInstanceAndUnwrap(typeof(ProxyRunner).Assembly.FullName, typeof(ProxyRunner).FullName); proxy.MethodInsideAppDomain(); } }</code> </pre> <br><p>  Untuk kode C # bisa melempar pengecualian dari jenis apa pun (saya tidak ingin menyiksa Anda dengan MSIL) Saya melakukan trik dalam contoh ini melemparkan jenis ke jenis yang tidak dapat dibandingkan, sehingga kami dapat melempar pengecualian untuk jenis apa pun, tetapi penerjemah akan berpikir bahwa kami menggunakan tipe <code>Exception</code> .  Kami membuat turunan dari jenis <code>Program</code> , yang tidak dapat dipastikan serial, dan melemparkan pengecualian menggunakan jenis ini sebagai beban kerja.  Berita baiknya adalah Anda mendapatkan pembungkus untuk pengecualian non-pengecualian dari <code>RuntimeWrappedException</code> yang akan menyimpan instance objek tipe <code>Program</code> kami di dalam dan kami akan dapat menangkap pengecualian ini.  Namun, ada berita buruk yang mendukung ide kami: memanggil <code>proxy.MethodInsideAppDomain();</code>  akan menghasilkan <code>SerializationException</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1ad/ace/7f1/1adace7f1c21e2ad7edc51b36f343dc9.png"></p><br><p>  Dengan demikian, Anda tidak dapat mentransfer pengecualian antara domain karena tidak mungkin untuk membuat serial.  Ini, pada gilirannya, berarti bahwa menggunakan filter pengecualian untuk metode pembungkus panggilan di domain lain akan tetap menyebabkan tumpukan membuka gulungan meskipun serialisasi tampaknya tidak perlu dengan pengaturan <code>FullTrust</code> dari subdomain. </p><br><blockquote>  Kita harus memberi perhatian tambahan pada alasan mengapa serialisasi antar domain sangat diperlukan.  Dalam contoh buatan kami, kami membuat subdomain yang tidak memiliki pengaturan apa pun.  Itu berarti ia bekerja dengan cara FullTrust.  CLR sepenuhnya mempercayai kontennya dan tidak menjalankan pemeriksaan tambahan apa pun.  Namun, ketika Anda memasukkan setidaknya satu pengaturan keamanan, kepercayaan penuh akan hilang dan CLR akan mulai mengendalikan semua yang terjadi di dalam subdomain.  Jadi, ketika Anda memiliki domain yang sepenuhnya tepercaya Anda tidak perlu serialisasi.  Akui, kita tidak perlu melindungi diri kita sendiri.  Tetapi serialisasi ada tidak hanya untuk perlindungan.  Setiap domain memuat semua rakitan yang diperlukan untuk kedua kalinya dan membuat salinannya.  Dengan demikian, itu membuat salinan dari semua jenis dan semua VMT.  Tentu saja, ketika meneruskan objek dari domain ke domain Anda akan mendapatkan objek yang sama.  Tetapi VMT-nya tidak akan menjadi miliknya dan objek ini tidak dapat dilemparkan ke tipe lain.  Dengan kata lain, jika kita membuat instance dari tipe <code>Boo</code> dan mendapatkannya di domain lain, casting <code>(Boo)boo</code> tidak akan berfungsi.  Dalam hal ini, serialisasi dan deserialisasi akan menyelesaikan masalah karena objek akan ada di dua domain secara bersamaan.  Itu akan ada dengan semua data di mana ia dibuat dan itu akan ada di domain penggunaan sebagai objek proxy, memastikan bahwa metode objek asli disebut. </blockquote><p>  Dengan mentransfer objek serial antara domain Anda mendapatkan salinan penuh objek dari satu domain di domain lain sambil menyimpan beberapa batasan dalam memori.  Namun, batasan ini adalah fiksi.  Ini digunakan hanya untuk tipe-tipe yang tidak ada dalam <code>Shared AppDomain</code> .  Dengan demikian, jika Anda melempar sesuatu yang non-serializable sebagai pengecualian, tetapi dari <code>Shared AppDomain</code> , Anda tidak akan mendapatkan kesalahan serialisasi (kami dapat mencoba melempar <code>Action</code> alih-alih <code>Program</code> ).  Namun, tumpukan membuka gulungan akan tetap terjadi dalam kasus ini: karena kedua varian harus bekerja dengan cara standar.  Sehingga tidak ada yang akan bingung. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Bab ini diterjemahkan dari bahasa Rusia bersama oleh penulis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah profesional</a> .  Anda dapat membantu kami dengan terjemahan dari bahasa Rusia atau Inggris ke bahasa lain, terutama ke bahasa Cina atau Jerman. <br><br>  Juga, jika Anda ingin berterima kasih kepada kami, cara terbaik yang dapat Anda lakukan adalah memberi kami bintang di github atau untuk repositori garpu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454630/">https://habr.com/ru/post/id454630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454618/index.html">Lubang Produktivitas: Bagaimana Slack Menyakiti Alur Kerja Kami</a></li>
<li><a href="../id454620/index.html">#NoDeployFriday: membantu atau membahayakan?</a></li>
<li><a href="../id454622/index.html">Kreisel EVEX 910e: model historis - kehidupan baru</a></li>
<li><a href="../id454626/index.html">DevOops kemarin dan hari ini</a></li>
<li><a href="../id454628/index.html">Membangun sistem moderasi pesan otomatis</a></li>
<li><a href="../id454634/index.html">Minggu Keamanan 23: Kerentanan notepad, sejuta sistem dengan RDP yang tidak ditatch</a></li>
<li><a href="../id454640/index.html">Melakukan debug layanan microser jarak jauh melalui SSH di bawah VPN dalam 4 putaran</a></li>
<li><a href="../id454642/index.html">"" Buat aplikasi untuk orang-orang "- ini tidak harus dituliskan di lutut": tentang pengembangan ponsel di CFT</a></li>
<li><a href="../id454644/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 8. Beralih pengaturan</a></li>
<li><a href="../id454646/index.html">@Pythonetc kompilasi, Mei 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>