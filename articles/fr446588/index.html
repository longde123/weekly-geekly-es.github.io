<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèª ‚öóÔ∏è üë®‚Äç‚ù§Ô∏è‚Äçüë® V√©rification du code source de Roslyn üôå üë¥üèΩ üöΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, nous revenons aux projets que nous avons pr√©c√©demment v√©rifi√©s √† l'aide de PVS-Studio, ce qui se traduit par leurs descriptions dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>V√©rification du code source de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  De temps en temps, nous revenons aux projets que nous avons pr√©c√©demment v√©rifi√©s √† l'aide de PVS-Studio, ce qui se traduit par leurs descriptions dans divers articles.  Deux raisons rendent ces retours passionnants pour nous.  Tout d'abord, l'occasion d'√©valuer les progr√®s de notre analyseur.  Deuxi√®mement, suivre les retours des auteurs du projet sur notre article et le rapport d'erreurs que nous leur fournissons g√©n√©ralement.  Bien s√ªr, les erreurs peuvent √™tre corrig√©es sans notre participation.  Cependant, c'est toujours agr√©able lorsque nos efforts contribuent √† am√©liorer un projet.  Roslyn ne faisait pas exception.  L'article pr√©c√©dent sur cette v√©rification de projet remonte au 23 d√©cembre 2015. C'est assez long, compte tenu des progr√®s r√©alis√©s par notre analyseur depuis lors.  √âtant donn√© que le c≈ìur C # de l'analyseur PVS-Studio est bas√© sur Roslyn, il nous donne un int√©r√™t suppl√©mentaire pour ce projet.  En cons√©quence, nous tenons autant que la moutarde √† la qualit√© du code de ce projet.  Maintenant, testons-le √† nouveau et d√©couvrons quelques probl√®mes nouveaux et int√©ressants (mais esp√©rons que rien de significatif) que PVS-Studio sera en mesure de trouver. <br><a name="habracut"></a><br>  Beaucoup de nos lecteurs connaissent probablement Roslyn (ou .NET Compiler Platform).  En bref, il s'agit d'un ensemble de compilateurs open source et d'une API pour l'analyse de code des langages C # et Visual Basic .NET de Microsoft.  Le code source du projet est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Je ne donnerai pas une description d√©taill√©e de cette plate-forme et je recommanderai de lire l'article de mon coll√®gue Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† Roslyn et son utilisation dans le d√©veloppement de programmes</a> " √† tous les lecteurs int√©ress√©s.  √Ä partir de cet article, vous pouvez d√©couvrir non seulement les caract√©ristiques de l'architecture de Roslyn, mais aussi la fa√ßon dont nous utilisons exactement cette plate-forme. <br><br>  Comme je l'ai mentionn√© plus t√¥t, cela fait plus de 3 ans que mon coll√®gue Andrey Karpov a √©crit le dernier article sur le ch√®que de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nouvelle ann√©e PVS-Studio 6.00 Release: Scanning Roslyn</a> ".  Depuis lors, l'analyseur C # PVS-Studio avait de nombreuses nouvelles fonctionnalit√©s.  En fait, l'article d'Andrey √©tait un cas de test, car √† ce moment-l√†, l'analyseur C # venait d'√™tre ajout√© dans PVS-Studio.  Malgr√© cela, nous avons r√©ussi √† d√©tecter des erreurs dans le projet Roslyn, qui √©tait certainement de haute qualit√©.  Alors, qu'est-ce qui a chang√© dans l'analyseur de code C # √† ce moment qui nous permettra d'effectuer une analyse plus approfondie? <br><br>  Depuis lors, le c≈ìur et l'infrastructure se sont d√©velopp√©s.  Nous avons ajout√© la prise en charge de Visual Studio 2017 et Roslyn 2.0, ainsi qu'une int√©gration approfondie avec MSBuild.  L'article de mon coll√®gue Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de Visual Studio 2017 et Roslyn 2.0 dans PVS-Studio: parfois ce n'est pas si facile √† utiliser des solutions pr√™tes √† l'emploi que cela puisse para√Ætre</a> " d√©crit notre approche de l'int√©gration avec MSBuild et les raisons de cette d√©cision. <br><br>  Pour le moment, nous travaillons activement √† passer √† Roslyn 3.0 de la m√™me mani√®re que nous avons initialement pris en charge Visual Studio 2017. Cela n√©cessite l'utilisation de notre propre ensemble d'outils, inclus dans la distribution PVS-Studio en tant que "stub", qui est un MSBuild vide Fichier .exe.  Malgr√© le fait qu'il ressemble √† une "b√©quille" (l'API MSBuild n'est pas tr√®s conviviale pour la r√©utilisation dans des projets tiers en raison de la faible portabilit√© des biblioth√®ques), une telle approche nous a d√©j√† aid√© √† surmonter relativement facilement plusieurs mises √† jour de Roslyn en termes de Visual Studio 2017. Jusqu'√† pr√©sent, il aidait (m√™me avec certains d√©fis) √† passer par la mise √† jour de Visual Studio 2019 et √† maintenir une compatibilit√© descendante et des performances compl√®tes pour les syst√®mes avec des versions MSBuild plus anciennes. <br><br>  Le c≈ìur de l'analyseur a √©galement subi un certain nombre d'am√©liorations.  L'une des principales caract√©ristiques est une analyse interproc√©durale compl√®te prenant en compte les valeurs des m√©thodes d'entr√©e et de sortie, √©valuant (en fonction de ces param√®tres) l'accessibilit√© des branches d'ex√©cution et des points de retour. <br><br>  Nous sommes sur le point de terminer la t√¢che de surveillance des param√®tres √† l'int√©rieur des m√©thodes (par exemple, les d√©r√©f√©rences potentiellement dangereuses) et d'enregistrer leurs auto-annotations.  Pour un diagnostic utilisant un m√©canisme de flux de donn√©es, cela permettra de prendre en compte des situations dangereuses, survenant lors du passage d'un param√®tre dans une m√©thode.  Avant cela, lors de l'analyse de ces endroits dangereux, aucun avertissement n'√©tait g√©n√©r√©, car nous ne pouvions pas conna√Ætre toutes les valeurs d'entr√©e possibles dans une telle m√©thode.  Maintenant, nous pouvons d√©tecter le danger, comme dans tous les endroits o√π l'on appelle cette m√©thode, ces param√®tres d'entr√©e seront pris en compte. <br><br>  Remarque: vous pouvez lire sur les m√©canismes de base de l'analyseur, tels que le flux de donn√©es et autres dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologies utilis√©es dans l'analyseur de code PVS-Studio pour trouver des bogues et des vuln√©rabilit√©s potentielles</a> ". <br><br>  L'analyse interproc√©durale dans PVS-Studio C # n'est limit√©e ni par les param√®tres d'entr√©e, ni par la profondeur.  La seule limitation r√©side dans les m√©thodes virtuelles dans les classes, ouvertes √† l'h√©ritage, ainsi que dans la r√©cursivit√© (l'analyse s'arr√™te lorsqu'elle tombe sur un appel r√©p√©t√© de la m√©thode d√©j√† √©valu√©e).  Ce faisant, la m√©thode r√©cursive elle-m√™me sera finalement √©valu√©e en supposant que la valeur de retour de sa r√©cursivit√© est inconnue. <br><br>  Une autre grande nouvelle fonctionnalit√© de l'analyseur C # est devenue la prise en compte d'une √©ventuelle d√©r√©f√©rence d'un pointeur potentiellement nul.  Avant cela, l'analyseur s'est plaint d'une √©ventuelle exception de r√©f√©rence nulle, √©tant assur√© que dans toutes les branches d'ex√©cution, la valeur de la variable serait nulle.  Bien s√ªr, c'√©tait faux dans certains cas, c'est pourquoi le diagnostic du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> avait pr√©c√©demment appel√© r√©f√©rence nulle potentielle. <br><br>  L'analyseur est maintenant conscient du fait que la variable peut √™tre nulle dans l'une des branches d'ex√©cution (par exemple, sous une certaine condition <i>if</i> ).  S'il remarque l'acc√®s √† une telle variable sans v√©rification, il √©mettra l'avertissement V3080, mais √† un niveau de certitude inf√©rieur, que s'il voit null dans toutes les branches.  Parall√®lement √† l'analyse interproc√©durale am√©lior√©e, un tel m√©canisme permet de trouver des erreurs tr√®s difficiles √† d√©tecter.  Voici un exemple - imaginez une longue cha√Æne d'appels de m√©thode, dont le dernier ne vous est pas familier.  Dans certaines circonstances, il retourne null dans le bloc <i>catch</i> , mais vous ne l'avez pas prot√©g√©, car vous ne le savez pas.  Dans ce cas, l'analyseur ne se plaint que lorsqu'il voit exactement l'affectation nulle.  √Ä notre avis, il distingue qualitativement notre approche de cette fonctionnalit√© de C # 8.0 en tant que r√©f√©rence de type nullable, ce qui, en fait, se limite √† d√©finir des contr√¥les pour null pour chaque m√©thode.  Cependant, nous sugg√©rons l'alternative - d'effectuer des v√©rifications uniquement dans les endroits o√π la valeur null peut r√©ellement se produire, et notre analyseur peut d√©sormais rechercher de tels cas. <br><br>  Alors, ne retardons pas trop longtemps le point principal et passons au bl√¢me - en analysant les r√©sultats du contr√¥le Roslyn.  Tout d'abord, consid√©rons les erreurs trouv√©es en raison des fonctionnalit√©s d√©crites ci-dessus.  En somme, il y a eu beaucoup d'avertissements pour le code Roslyn cette fois.  Je pense que cela est li√© au fait que la plate-forme √©volue tr√®s activement (√† ce stade, la base de code est d'environ 2 770 000 lignes hors vide), et nous n'avons pas analys√© ce projet depuis longtemps.  N√©anmoins, il n'y a pas autant d'erreurs critiques, alors qu'elles pr√©sentent le plus d'int√©r√™t pour l'article.  Comme d'habitude, j'ai exclu les tests du ch√®que, il y en a beaucoup √† Roslyn. <br><br>  Je vais commencer par les erreurs V3080 de niveau de certitude Moyen, dans lesquelles l'analyseur a d√©tect√© un acc√®s possible par r√©f√©rence nulle, mais pas dans tous les cas possibles (branches de code). <br><br>  <b>D√©r√©f√©rence nulle possible - Moyenne</b> <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter ¬´actuel¬ª.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Prenons la m√©thode <i>GetNode</i> .  L'analyseur sugg√®re que l'acc√®s par r√©f√©rence nulle est possible dans l'√©tat du bloc <i>while</i> <i>.</i>  La variable re√ßoit une valeur dans le corps du bloc <i>while</i> , qui est le r√©sultat de la m√©thode <i>AsNode</i> .  Dans certains cas, cette valeur sera <i>nulle</i> .  Un bon exemple d'analyse interproc√©durale en action. <br><br>  Consid√©rons maintenant un cas similaire, dans lequel l'analyse interproc√©durale a √©t√© effectu√©e via deux appels de m√©thode. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter le ¬´r√©pertoire¬ª.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  La variable de <i>r√©pertoire</i> dans le corps de la m√©thode <i>ExpandFileNamePattern</i> obtient la valeur de la m√©thode <i>GetDirectoryName (cha√Æne)</i> .  Cela, √† son tour, renvoie le r√©sultat de la m√©thode surcharg√©e <i>GetDirectoryName (cha√Æne, bool)</i> dont la valeur peut √™tre <i>nulle</i> .  √âtant donn√© que le <i>r√©pertoire des</i> variables est utilis√© sans v√©rification pr√©alable de null dans le corps de la m√©thode <i>ExpandFileNamePattern</i> - nous pouvons proclamer que l'analyseur a correctement √©mis l'avertissement.  Il s'agit d'une construction potentiellement dangereuse. <br><br>  Un autre fragment de code avec l'erreur V3080, plus pr√©cis√©ment, avec deux erreurs, √©mis pour une seule ligne de code.  L'analyse interproc√©durale n'√©tait pas n√©cessaire ici. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter ¬´spanStartLocation¬ª.  TestWorkspace.cs 574 <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter ¬´spanEndLocationExclusive¬ª.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Les variables <i>spanStartLocation</i> et <i>spanEndLocationExclusive</i> sont de type <i>int</i> <i>nullable</i> et sont initialis√©es par <i>null</i> .  Plus loin dans le code, des valeurs peuvent leur √™tre attribu√©es, mais uniquement sous certaines conditions.  Dans certains cas, leur valeur reste <i>nulle</i> .  Apr√®s cela, ces variables sont accessibles par r√©f√©rence sans v√©rification pr√©alable de null, ce que l'analyseur indique. <br><br>  Le code Roslyn contient un grand nombre de ces erreurs, plus de 100. Souvent, le mod√®le de ces erreurs est le m√™me.  Il existe une sorte de m√©thode g√©n√©rale qui retourne potentiellement <i>null</i> .  Le r√©sultat de cette m√©thode est utilis√© √† de nombreux endroits, parfois par le biais de dizaines d'appels de m√©thode interm√©diaires ou de v√©rifications suppl√©mentaires.  Il est important de comprendre que ces erreurs ne sont pas fatales, mais qu'elles peuvent potentiellement conduire √† un acc√®s par r√©f√©rence nulle.  Tout en d√©tectant de telles erreurs est assez difficile.  C'est pourquoi dans certains cas, il faut envisager une refactorisation de code, auquel cas si la valeur <i>null est</i> renvoy√©e, la m√©thode l√®ve une exception.  Sinon, vous ne pouvez s√©curiser votre code qu'avec des v√©rifications g√©n√©rales, ce qui est assez fatigant et parfois peu fiable.  Quoi qu'il en soit, il est clair que chaque cas sp√©cifique n√©cessite une solution bas√©e sur les sp√©cifications du projet. <br><br>  Remarque  Il se trouve qu'√† un moment donn√©, il n'y a pas de tels cas (donn√©es d'entr√©e), lorsque la m√©thode retourne <i>null</i> et qu'il n'y a pas d'erreur r√©elle.  Cependant, un tel code n'est toujours pas fiable, car tout peut changer lors de l'introduction de certaines modifications de code. <br><br>  Afin d'abandonner le sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> , regardons les erreurs √©videntes de niveau de haute certitude, lorsque l'acc√®s par r√©f√©rence nulle est le plus probable, voire in√©vitable. <br><br>  <b>D√©r√©f√©rence nulle possible - √âlev√©</b> <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  En raison de la faute de frappe dans la condition ( <i>&amp;&amp;</i> est utilis√© √† la place de l'op√©rateur <i>||</i> ), le code fonctionne diff√©remment que pr√©vu et l'acc√®s √† la variable <i>collectionType.Type</i> sera ex√©cut√© lorsqu'il est <i>nul</i> .  La condition doit √™tre corrig√©e comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Soit dit en passant, les choses peuvent se d√©rouler d'une autre mani√®re: dans la premi√®re partie de la condition, les op√©rateurs <i>==</i> et <i>! =</i> Sont foir√©s <i>.</i>  Ensuite, le code correct ressemblerait √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Cette version du code est moins logique, mais corrige √©galement l'erreur.  La solution finale appartient aux auteurs du projet de d√©cider. <br><br>  Une autre erreur similaire. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter ¬´l'action¬ª.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  L'erreur se produit lors de la g√©n√©ration du message pour l'exception.  Elle est suivie de la tentative d'acc√®s √† la propri√©t√© <i>action.DisplayText</i> via la variable d' <i>action</i> , connue pour √™tre <i>nulle</i> . <br><br>  Voici la derni√®re erreur V3080 du niveau haut. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter le ¬´type¬ª.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  La m√©thode est assez petite, donc je la cite enti√®rement.  La condition dans le bloc de <i>retour</i> est incorrecte.  Dans certains cas, lors de l'acc√®s √† <i>type.FullName</i> , une exception peut se produire.  Je vais utiliser des parenth√®ses pour que ce soit clair (ils ne changeront pas le comportement): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Selon la priorit√© des op√©rations, le code fonctionnera exactement comme ceci.  Dans le cas o√π la variable de <i>type</i> est <i>nulle</i> , nous tomberons dans le else-check, o√π nous utiliserons la r√©f√©rence de <i>type</i> null, apr√®s avoir v√©rifi√© la variable <i>targetTypeName</i> pour <i>null</i> .  Le code peut √™tre fix√©, par exemple, comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Je pense que c'est suffisant pour revoir les erreurs du V3080.  Il est maintenant grand temps de voir d'autres choses int√©ressantes que l'analyseur PVS-Studio a r√©ussi √† trouver. <br><br>  <b>Typo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3005</a> La variable 'SourceCodeKind' est assign√©e √† elle-m√™me.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  En raison de l'√©chec du nommage des variables, une faute de frappe a √©t√© effectu√©e dans le constructeur de la classe <i>DynamicFileInfo</i> .  Le champ <i>SourceCodeKind</i> se voit attribuer sa propre valeur au lieu d'utiliser le param√®tre <i>sourceCodeKind</i> .  Pour minimiser la probabilit√© de telles erreurs, nous vous recommandons d'utiliser le pr√©fixe de soulignement pour les noms de param√®tres dans de tels cas.  Voici un exemple d'une version corrig√©e du code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Par inadvertance</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3006</a> L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© 'throw' peut √™tre manquant: lancez une nouvelle exception InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Sous une certaine condition, le destructeur doit lever une exception, mais cela ne se produit pas pendant que l'objet d'exception est simplement cr√©√©.  Le mot cl√© <i>throw a</i> √©t√© manqu√©.  Voici la version corrig√©e du code: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Le probl√®me avec les destructeurs en C # et leur lev√©e d'exceptions est un sujet pour une autre discussion, qui d√©passe le cadre de cet article. <br><br>  <b>Quand le r√©sultat n'est pas important</b> <br><br>  Les m√©thodes, qui ont re√ßu la m√™me valeur dans tous les cas, ont d√©clench√© un certain nombre d'avertissements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3009</a> .  Dans certains cas, cela peut ne pas √™tre critique ou la valeur de retour n'est tout simplement pas v√©rifi√©e dans le code appelant.  J'ai ignor√© ces avertissements.  Mais quelques extraits de code semblaient suspects.  En voici un: <br><br>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  La m√©thode <i>TryExecuteCommand</i> ne renvoie que <i>true</i> .  Ce faisant, dans le code appelant, la valeur retourn√©e est impliqu√©e dans certains contr√¥les. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Il est difficile de dire exactement dans quelle mesure un tel comportement est dangereux.  Mais si le r√©sultat n'est pas n√©cessaire, peut-√™tre que le type de la valeur de retour devrait √™tre chang√© en void et que l'on devrait faire de petites modifications dans la m√©thode d'appel.  Cela rendra le code plus lisible et s√©curis√©. <br><br>  Avertissements similaires de l'analyseur: <br><br><ul><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  JsonRpcClient.cs 138 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Il est √©trange que cette m√©thode retourne toujours une seule et m√™me valeur de 'false'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  ObjectList.cs 173 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  ObjectList.cs 249 </li></ul><br>  <b>V√©rifi√© la mauvaise chose</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  La variable de <i>valeur</i> est <i>convertie en</i> type <i>NamingStylePreferences</i> .  Le probl√®me r√©side dans la v√©rification qui suit.  M√™me si la variable de <i>valeur</i> n'√©tait pas nulle, cela ne garantit pas que le transtypage de type a r√©ussi et <i>valueToSerialize</i> ne contient pas <i>null</i> .  Possibilit√© de <i>lever</i> l'exception <i>NullReferenceException</i> .  Le code doit √™tre corrig√© comme suit: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Un autre bug similaire: <br><br>  V3019 Il est possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  La variable <i>columnState</i> est <i>convertie en</i> type <i>ColumnState2</i> .  Cependant, le r√©sultat de l'op√©ration, qui est la variable <i>columnState2,</i> n'est plus v√©rifi√© pour <i>null</i> .  Au lieu de cela, la variable <i>columnState</i> est v√©rifi√©e √† l'aide de l'op√©rateur <i>null</i> conditionnel.  Pourquoi ce code est-il dangereux?  Tout comme dans l'exemple pr√©c√©dent, la conversion avec l'op√©rateur <i>as</i> peut √©chouer et la variable sera <i>nulle,</i> ce qui entra√Ænera une exception.  Soit dit en passant, une faute de frappe peut √™tre √† bl√¢mer ici.  Jetez un ≈ìil √† la condition dans le bloc <i>if</i> . <br><br>  Peut-√™tre, au lieu de <i>columnState? .Name,</i> l'auteur voulait √©crire <i>columnState2? .Name</i> .  C'est tr√®s probable, compte tenu des noms de variable plut√¥t d√©fectueux <i>columnState</i> et <i>columnState2.</i> <br><br>  <b>Contr√¥les redondants</b> <br><br>  Un grand nombre d'avertissements (plus de 100) ont √©t√© √©mis sur des constructions non critiques, mais potentiellement dangereuses, li√©es √† des contr√¥les redondants.  Par exemple, c'est l'un d'entre eux. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022 L'</a> expression 'navInfo == null' est toujours fausse.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Il se peut qu'il n'y ait pas de bug r√©el ici.  C'est juste une bonne raison de d√©montrer que "l'analyse interproc√©durale + l'analyse du flux de donn√©es" fonctionne en remorque.  L'analyseur sugg√®re que la deuxi√®me v√©rification <i>navInfo == null</i> est redondante.  En effet, avant cela, la valeur affect√©e √† <i>navInfo</i> sera obtenue √† partir de la m√©thode <i>libraryService.NavInfoFactory.CreateForProject</i> , qui va construire et retourner un nouvel objet de la classe <i>NavInfo</i> .  En aucun cas, il retournera <i>null</i> .  Ici, la question se pose, pourquoi l'analyseur n'a-t-il pas √©mis d'avertissement pour la premi√®re v√©rification <i>navInfo == null</i> ?  Il y a quelques raisons.  Premi√®rement, si la variable de <i>symbole</i> est <i>nulle</i> , la valeur <i>navInfo</i> restera √©galement une r√©f√©rence nulle.  Deuxi√®mement, m√™me si <i>navInfo</i> obtient la valeur de la m√©thode <i>ibraryService.NavInfoFactory.CreateForSymbol</i> , cette valeur peut √©galement √™tre <i>nulle</i> .  Ainsi, la premi√®re v√©rification <i>navInfo == null</i> est vraiment n√©cessaire. <br><br>  <b>Contr√¥les insuffisants</b> <br><br>  Maintenant, la situation inverse de la discussion ci-dessus.  Plusieurs avertissements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3042</a> ont √©t√© d√©clench√©s pour le code, dans lesquels l'acc√®s par r√©f√©rence nulle est possible.  M√™me un ou deux petits ch√®ques auraient pu tout r√©parer. <br><br>  Prenons un autre fragment de code int√©ressant, qui contient deux de ces erreurs. <br><br>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'r√©cepteur' Binder_Expressions.cs 7770 <br><br>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'r√©cepteur' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  La variable <i>r√©cepteur</i> peut √™tre nulle.  L'auteur du code le sait, car il utilise l'op√©rateur <i>nul</i> conditionnel dans la condition du bloc <i>if</i> pour acc√©der au <i>r√©cepteur ?</i> . <i>Syntaxe</i> .  De plus, la variable <i>receiver</i> est utilis√©e sans aucun contr√¥le pour acc√©der √† <i>receiver.Type</i> , <i>receiver.Syntax</i> et <i>receiver.HasErrors</i> .  Ces erreurs doivent √™tre corrig√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Nous devons √©galement √™tre s√ªrs que le constructeur prend en charge l'obtention de valeurs <i>nulles</i> pour ses param√®tres ou nous devons effectuer un refactoring suppl√©mentaire. <br><br>  Autres erreurs similaires: <br><br><ul><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'containerType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'expression' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'expression' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Erreur dans la condition</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3057</a> La fonction 'Sous-cha√Æne' pourrait recevoir la valeur '-1' alors qu'une valeur non n√©gative est attendue.  Inspectez le deuxi√®me argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Dans le cas o√π la variable <i>deux</i> - <i>points</i> est 0, ce qui est <i>correct</i> selon la condition dans le code, la m√©thode <i>Substring l√®vera</i> une exception.  Cela doit √™tre corrig√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Faute de frappe possible</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3065 Le</a> param√®tre 't2' n'est pas utilis√© dans le corps de la m√©thode.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  L'expression lambda accepte deux param√®tres: t1 et t2.  Cependant, seul t1 est utilis√©.  Cela semble suspect, compte tenu du fait qu'il est facile de faire une erreur lors de l'utilisation de variables avec de tels noms. <br><br>  <b>Par inadvertance</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3083 Invocation</a> non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√ªre</a> de l'√©v√©nement 'TagsChanged', NullReferenceException est possible.  Pensez √† affecter un √©v√©nement √† une variable locale avant de l'invoquer.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  L'√©v√©nement <i>TagsChanged</i> est invoqu√© de mani√®re non s√©curis√©e.  Entre la v√©rification de <i>null</i> et l'invocation de l'√©v√©nement, quelqu'un peut se d√©sinscrire de celui-ci, puis une exception sera lev√©e.  De plus, d'autres op√©rations sont effectu√©es dans le corps du bloc <i>if</i> juste avant d'invoquer l'√©v√©nement.  J'ai appel√© cette erreur "Inadvertence", car cet √©v√©nement est g√©r√© plus soigneusement dans d'autres endroits, comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  L'utilisation d'une variable de <i>gestionnaire</i> suppl√©mentaire √©vite le probl√®me.  Dans la m√©thode <i>OnTextBufferChanged,</i> il faut effectuer des modifications afin de g√©rer l'√©v√©nement en toute s√©curit√©. <br><br>  <b>Gammes d'intersection</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3092 Les</a> intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Pour une meilleure compr√©hension, permettez-moi de r√©√©crire ce code, en changeant les noms des constantes avec leurs valeurs r√©elles: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Probablement, il n'y a pas de v√©ritable erreur, mais la condition semble √©trange.  Sa deuxi√®me partie ( <i>sinon si</i> ) sera ex√©cut√©e uniquement pour la plage de 2147483648 + 1 √† 4294967295. <br><br>  Un autre couple d'avertissements similaires: <br><br><ul><li>  V3092 Les intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Les intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>En savoir plus sur les contr√¥les pour null (ou leur absence)</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelques</a> erreurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> sur la v√©rification d'une variable pour null juste apr√®s son utilisation.  Le premier est ambigu, consid√©rons le code. <br><br>  V3095 L'objet 'displayName' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Il est suppos√© que la r√©f√©rence <i>displayName</i> peut √™tre nulle.  Pour cela, la v√©rification <i>Debug.Assert a</i> √©t√© effectu√©e.  On ne sait pas pourquoi il va apr√®s avoir utilis√© une cha√Æne.  Il faut √©galement tenir compte du fait que pour les configurations diff√©rentes de Debug, le compilateur supprimera <i>Debug.Assert</i> <i>.</i>  Cela signifie-t-il que l'obtention d'une r√©f√©rence nulle n'est possible que pour le d√©bogage?  Si ce n'est pas le cas, pourquoi l'auteur a-t-il effectu√© la v√©rification de <i>string.IsNullOrEmpty (string)</i> , par exemple.  C'est la question aux auteurs du code. <br><br>  L'erreur suivante est plus √©vidente. <br><br>  V3095 L'objet 'scriptArgsOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Je pense que ce code n'a pas besoin d'explications.  Permettez-moi de vous donner la version fixe: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Dans le code Roslyn, il y avait 15 autres erreurs similaires: <br><br><ul><li>  V3095 L'objet 'LocalFunctions' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 L'objet 'resolution.OverloadResolutionResult' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 L'objet 'resolution.MethodGroup' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 L'objet 'touchedFilesLogger' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 L'objet 'newExceptionRegionsOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 L'objet 'symbole' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 L'objet '_state.BaseTypeOrInterfaceOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 L'objet 'element' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 L'objet 'languages' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 L'objet 'memberType' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 L'objet 'validTypeDeclarations' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 L'objet 'texte' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 L'objet 'nameOrMemberAccessExpression' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 L'objet 'simpleName' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 L'objet 'option' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 23, 28. OptionKey.cs 23 </li></ul><br>  Prenons les erreurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3105</a> .  Ici, l'op√©rateur <i>nul</i> conditionnel est utilis√© lors de l'initialisation de la variable, mais en outre, la variable est utilis√©e sans v√©rification de <i>null</i> . <br><br>  Deux avertissements indiquent l'erreur suivante: <br><br>  V3105 La variable 'documentId' a √©t√© utilis√©e apr√®s son affectation via un op√©rateur conditionnel nul.  NullReferenceException est possible.  CodeLensReferencesService.cs 138 <br><br>  V3105 La variable 'documentId' a √©t√© utilis√©e apr√®s son affectation via un op√©rateur conditionnel nul.  NullReferenceException est possible.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  La variable <i>documentId</i> peut √™tre initialis√©e par <i>null</i> .  Par cons√©quent, la cr√©ation d'un objet <i>ReferenceLocationDescriptor</i> entra√Ænera la lev√©e d'une exception.  Le code doit √™tre fixe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Les d√©veloppeurs devraient √©galement couvrir la possibilit√© que les variables, pass√©es √† un constructeur, soient <i>nulles.</i> <br><br>  Autres erreurs similaires dans le code: <br><br><ul><li>  V3105 La variable 'symbol' a √©t√© utilis√©e apr√®s avoir √©t√© affect√©e via un op√©rateur conditionnel nul.  NullReferenceException est possible.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 La variable 'symbol' a √©t√© utilis√©e apr√®s avoir √©t√© affect√©e via un op√©rateur conditionnel nul.  NullReferenceException est possible.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Priorit√©s et parenth√®ses</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3123</a> L'op√©rateur '?:' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionne</a> peut-√™tre d'une mani√®re diff√©rente de celle attendue.  Sa priorit√© est inf√©rieure √† la priorit√© des autres op√©rateurs dans son √©tat.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  La condition dans le bloc de retour n'est pas √©valu√©e comme pr√©vu par le d√©veloppeur.  Il a √©t√© suppos√© que la premi√®re condition sera <i>_kind == other._kin</i> d, (c'est pourquoi apr√®s cette condition il y a un saut de ligne), et ensuite que les blocs de conditions avec l'op√©rateur " <i>?</i> " Seront √©valu√©s en s√©quence.  En fait, la premi√®re condition est <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Cela est d√ª au fait que l'op√©rateur <i>&amp;&amp;</i> a une priorit√© plus √©lev√©e que l'op√©rateur " <i>?</i> ".  Pour r√©soudre ce probl√®me, un d√©veloppeur doit prendre toutes les expressions de l'op√©rateur " <i>?</i> " Entre parenth√®ses: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Ceci conclut ma description des erreurs trouv√©es. <br><br>  <b>Conclusion</b> <br><br>  Malgr√© le grand nombre d'erreurs, que j'ai r√©ussi √† trouver, en termes de taille du code du projet Roslyn (2 770 000 lignes), ce n'est pas trop.  Comme Andrey l'a √©crit dans un article pr√©c√©dent, je suis √©galement pr√™t √† reconna√Ætre la haute qualit√© de ce projet. <br><br>  Je voudrais noter que de telles v√©rifications de code occasionnelles n'ont rien √† voir avec la m√©thodologie de l'analyse statique et sont presque inutiles.  L'analyse statique doit √™tre appliqu√©e r√©guli√®rement, et non au cas par cas.  De cette fa√ßon, de nombreuses erreurs seront corrig√©es d√®s les premi√®res √©tapes, et donc le co√ªt de leur correction sera dix fois moins √©lev√©.  Cette id√©e est pr√©sent√©e plus en d√©tail dans cette petite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note</a> , veuillez la v√©rifier. <br><br>  Vous pouvez v√©rifier vous-m√™me quelques erreurs dans ce projet et dans un autre.  Pour ce faire, il vous suffit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©charger</a> et d'essayer notre analyseur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446588/">https://habr.com/ru/post/fr446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446572/index.html">Editor.js est un excellent √©diteur qui enregistre le code source au format JSON</a></li>
<li><a href="../fr446576/index.html">Substitution √† l'importation ou comment les h√©licopt√®res russes ont fait quelque chose de mal</a></li>
<li><a href="../fr446578/index.html">Langage de programmation bas√© sur une carte postale</a></li>
<li><a href="../fr446582/index.html">R√©flexions sur l'h√©bergement solaire pour les abeilles</a></li>
<li><a href="../fr446586/index.html">Param√®tres r√©seau de FreeRadius via DHCP</a></li>
<li><a href="../fr446590/index.html">39 nouvelles fonctionnalit√©s disponibles dans Java 12</a></li>
<li><a href="../fr446592/index.html">V√©rification du code source de Roslyn</a></li>
<li><a href="../fr446598/index.html">Recr√©ation de polices CRT</a></li>
<li><a href="../fr446602/index.html">Transistor √† effet de champ √† courant continu maximal</a></li>
<li><a href="../fr446604/index.html">ESET: Nouveaux sch√©mas de livraison de porte d√©rob√©e OceanLotus Cybergroup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>