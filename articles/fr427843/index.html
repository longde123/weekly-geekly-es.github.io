<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖 🤜🏿 🙋 Comment bien dormir et bien dormir ☝🏾 👞 ↔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il n'y a pas si longtemps, un bon article nous est parvenu sur le terrible état de performance des logiciels modernes (l' original en anglais , traduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment bien dormir et bien dormir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/427843/">  Il n'y a pas si longtemps, un bon article nous est parvenu sur le terrible état de performance des logiciels modernes (l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">original en anglais</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction en Habré</a> ).  Cet article m'a rappelé un contre-modèle du code, qui est très commun et fonctionne généralement d'une manière ou d'une autre, mais conduit à de petites pertes de performances ici et là.  Eh bien, vous savez, une bagatelle, que les mains n'atteindront en aucune façon.  Le seul problème est qu'une douzaine de ces "bagatelles" dispersées à différents endroits du code commencent à poser des problèmes tels que "J'ai le dernier Intel Core i7 et les secousses de défilement". <br><br><img src="https://habrastorage.org/webt/ri/na/rs/rinarsug4i1qt6b8kzc0i-6tcjy.png" align="right">  Je parle de l'utilisation incorrecte de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">veille</a> (le cas peut varier en fonction du langage de programmation et de la plate-forme).  Alors qu'est-ce que le sommeil?  La documentation répond très simplement à cette question: il s'agit d'une pause dans l'exécution du thread courant pendant le nombre de millisecondes spécifié.  Il convient de noter la beauté esthétique du prototype de cette fonction: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwMilliseconds)</span></span></span></span>;</code> </pre> <br>  Un seul paramètre (extrêmement clair), aucun code d'erreur ni exception - cela fonctionne toujours.  Il y a très peu de fonctions aussi agréables et compréhensibles! <br><br><div class="spoiler">  <b class="spoiler_title">Vous obtenez encore plus de respect pour cette fonction lorsque vous lisez son fonctionnement.</b> <div class="spoiler_text">  La fonction va au planificateur de threads du système d'exploitation et lui dit: «Mon thread et moi aimerions refuser le temps CPU qui nous est alloué, maintenant et pour autant de millisecondes à l'avenir.  Donnez aux pauvres! "  L'ordonnanceur, légèrement surpris par une telle générosité, supprime les fonctions de gratitude au nom du processeur, donne le temps restant à la personne suivante (et il y en a toujours) et n'inclut pas le thread qui a fait que Sleep a été prétendu pour transmettre le contexte d'exécution pendant le nombre spécifié de millisecondes.  La beauté! <br></div></div><br>  Qu'est-ce qui aurait pu mal tourner?  Le fait que les programmeurs utilisent cette merveilleuse fonctionnalité n'est pas pour ce à quoi elle est destinée. <br><a name="habracut"></a><br>  Et il est destiné à la simulation logicielle de certains processus externes, définis par quelque chose de réel, de pause. <br><br><h3>  Exemple correct numéro 1 </h3><br>  Nous écrivons l'application «horloge», dans laquelle une fois par seconde vous devez changer le nombre sur l'écran (ou la position de la flèche).  La fonction Sleep ici est parfaitement adaptée: nous n'avons vraiment rien à faire pendant une période de temps clairement définie (exactement une seconde).  Pourquoi ne pas dormir? <br><br><h3>  Exemple correct numéro 2 </h3><br>  Nous écrivons un contrôleur de <s>lune pour une machine à</s> pain.  L'algorithme d'opération est défini par l'un des programmes et ressemble à ceci: <br><br><ol><li>  Passez en mode 1. </li><li>  Travaillez dedans pendant 20 minutes </li><li>  Passez en mode 2. </li><li>  Travaillez dedans pendant 10 minutes </li><li>  Éteignez. </li></ol><br>  Ici aussi, tout est clair: nous travaillons avec le temps, il est déterminé par le processus technologique.  Utiliser Sleep est acceptable. <br><br>  Voyons maintenant des exemples d'utilisation abusive du sommeil. <br><br>  Lorsque j'ai besoin d'un exemple de code C ++ incorrect, je vais dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel de</a> code de l'éditeur de texte Notepad ++.  Son code est si terrible que tout anti-modèle est définitivement là, j'ai même écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> à ce sujet une fois.  Notepad ++ ne m'a pas déçu cette fois non plus!  Voyons comment il utilise Sleep. <br><br><h3>  Mauvais exemple numéro 1 </h3><br>  Au démarrage, Notepad ++ vérifie si une autre instance de son processus est déjà en cours d'exécution et, si tel est le cas, recherche sa fenêtre et lui envoie un message, puis se ferme.  Pour détecter un autre processus, une méthode standard est utilisée - le mutex global nommé.  Mais le code suivant a été écrit pour rechercher des fenêtres: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!isMultiInst) &amp;&amp; (!TheFirstOne)) { HWND hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ;!hNotepad_plus &amp;&amp; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> ; ++i) { Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); hNotepad_plus = ::FindWindow(Notepad_plus_Window::getClassName(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hNotepad_plus) { ... } ... }</code> </pre> <br><br>  Le programmeur qui a écrit ce code a essayé de trouver une fenêtre pour Notepad ++ qui était déjà lancée et envisageait même une situation où deux processus étaient démarrés littéralement en même temps, donc le premier d'entre eux a déjà créé un mutex global, mais n'a pas encore créé de fenêtre d'éditeur.  Dans ce cas, le deuxième processus attendra la création de la fenêtre "5 fois en 100 ms".  Par conséquent, soit nous n'attendrons pas du tout, soit nous perdrons jusqu'à 100 ms entre le moment de la création réelle de la fenêtre et la sortie de Sleep. <br><br>  C'est le premier (et l'un des principaux) contre-modes d'utilisation du sommeil.  Nous n'attendons pas l'occurrence de l'événement, mais "pendant quelques millisecondes, il aura soudain de la chance".  Nous attendons tellement que, d'une part, nous n'ennuyons pas vraiment l'utilisateur, et d'autre part, nous ayons la chance d'attendre l'événement dont nous avons besoin.  Oui, l'utilisateur peut ne pas remarquer de pause de 100 ms lors du démarrage de l'application.  Mais si une telle pratique consistant à «attendre un peu du bulldozer» est acceptée et acceptable dans le projet, elle peut se terminer par le fait que nous attendrons à chaque étape pour les raisons les plus mesquines.  Ici 100 ms, il y a encore 50 ms, et ici 200 ms - et ici notre programme "ralentit en quelque sorte pendant quelques secondes". <br><br>  De plus, il est simplement esthétiquement désagréable de voir du code qui fonctionne pendant longtemps alors qu'il pourrait fonctionner rapidement.  Dans ce cas particulier, on pourrait utiliser la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SetWindowsHookEx</a> , en s'abonnant à l'événement HSHELL_WINDOWCREATED - et recevoir instantanément une notification de création de fenêtre.  Oui, le code devient un peu plus compliqué, mais littéralement 3-4 lignes.  Et nous gagnons jusqu'à 100 ms!  Et le plus important - nous n'utilisons plus les fonctions de l'attente inconditionnelle où l'attente n'est pas inconditionnelle. <br><br><h3>  Mauvais exemple numéro 2 </h3><br><pre> <code class="cpp hljs">HANDLE hThread = ::CreateThread(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, threadTextTroller, &amp;trollerParams, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sleepTime = <span class="hljs-number"><span class="hljs-number">1000</span></span> / x * y; ::Sleep(sleepTime);</code> </pre> <br>  Je ne comprenais pas vraiment exactement et pendant combien de temps ce code attendait dans Notepad ++, mais je voyais souvent l'anti-modèle général "démarrer le flux et attendre".  Les gens attendent des choses différentes: le début d'un autre flux, la réception de certaines données de celui-ci, la fin de son travail.  Deux choses sont mauvaises ici tout de suite: <br><br><ol><li>  La programmation multithread est nécessaire pour faire quelque chose de multithread.  C'est-à-dire  le lancement du deuxième thread suppose que nous continuerons à faire quelque chose dans le premier, à ce moment-là, le deuxième thread fera d'autres travaux, et le premier, ayant terminé son travail (et, peut-être, ayant attendu un peu plus), obtiendra son résultat et l'utilisera d'une manière ou d'une autre.  Si nous commençons à "dormir" immédiatement après le démarrage du deuxième thread - pourquoi est-il nécessaire? </li><li>  Il faut s'y attendre correctement.  Pour une attente correcte, il existe des pratiques éprouvées: l'utilisation d'événements, de fonctions d'attente, d'appels de rappel.  Si nous attendons que le code commence à fonctionner dans le deuxième thread, configurez un événement pour cela et signalez-le dans le deuxième thread.  Si nous attendons que le deuxième thread finisse de fonctionner - en C ++, il existe une merveilleuse classe de threads et sa méthode de jointure (enfin, ou, encore une fois, des méthodes spécifiques à la plate-forme comme WaitForSingleObject et HANDLE sous Windows).  Attendre que le travail soit terminé dans un autre thread "pendant quelques millisecondes" est tout simplement stupide, car si nous n'avons pas de système d'exploitation en temps réel, personne ne vous donnera aucune garantie pour combien de temps ce deuxième thread démarrera ou atteindra une étape de son travail. </li></ol><br><h3>  Mauvais exemple numéro 3 </h3><br>  Ici, nous voyons un fil d'arrière-plan qui dort en attendant certains événements. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CReadChangesServer</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (m_nOutstandingRequests || !m_bTerminate) { ::SleepEx(INFINITE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestTermination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_bTerminate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ... } ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_bTerminate; };</code> </pre><br>  Je dois admettre que ce n'est pas Sleep qui est utilisé ici, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SleepEx</a> , qui est plus intelligent et peut interrompre l'attente de certains événements (comme la fin d'opérations asynchrones).  Mais cela n'aide pas du tout!  Le fait est que la boucle while (! M_bTerminate) a le droit de fonctionner sans fin, ignorant la méthode RequestTermination () appelée à partir d'un autre thread, réinitialisant la variable m_bTerminate à true.  J'ai écrit sur les causes et les conséquences de cela dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> .  Pour éviter cela, vous devez utiliser quelque chose garanti pour fonctionner correctement entre les threads: atomique, événement ou quelque chose de similaire. <br><br>  Oui, formellement SleepEx n'est pas à blâmer pour le problème de l'utilisation de la variable booléenne habituelle pour synchroniser les threads, il s'agit d'une erreur distincte d'une autre classe.  Mais pourquoi est-ce devenu possible dans ce code?  Parce qu'au début, le programmeur a pensé «vous devez dormir ici», puis a réfléchi à la durée et aux conditions pour arrêter de le faire.  Et dans le bon scénario, il ne devrait même pas avoir une première pensée.  La pensée «devrait attendre un événement» aurait dû surgir dans ma tête - et à partir de maintenant, la pensée aurait fonctionné pour choisir le bon mécanisme de synchronisation des données entre les threads, ce qui exclurait à la fois la variable booléenne et l'utilisation de SleepEx. <br><br><h3>  Mauvais exemple numéro 4 </h3><br>  Dans cet exemple, nous allons examiner la fonction backupDocument, qui agit comme une «sauvegarde automatique», utile en cas de plantage inattendu de l'éditeur.  Par défaut, elle dort pendant 7 secondes, puis donne la commande pour enregistrer les modifications (si elles l'ont été). <br><br><pre> <code class="cpp hljs">DWORD WINAPI Notepad_plus::backupDocument(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-comment"><span class="hljs-comment">/*param*/</span></span>) { ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isSnapshotMode) { ... ::Sleep(DWORD(timer)); ... ::PostMessage(Notepad_plus_Window::gNppHWND, NPPM_INTERNAL_SAVEBACKUP, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; }</code> </pre> <br>  L'intervalle peut être modifié, mais ce n'est pas le problème.  Tout intervalle sera trop long et trop court en même temps.  Si nous tapons une lettre par minute, cela n'a aucun sens de dormir pendant seulement 7 secondes.  Si nous copions-collons 10 mégaoctets de texte quelque part, nous n'avons pas à attendre 7 secondes après cela, c'est un volume suffisamment important pour lancer immédiatement la sauvegarde (tout d'un coup, nous la coupons de quelque part et elle est partie, et l'éditeur se bloque après une seconde). <br><br>  C'est-à-dire  avec une simple attente, nous remplaçons ici l'algorithme plus intelligent manquant. <br><br><h3>  Mauvais exemple numéro 5 </h3><br>  Notepad ++ peut "taper du texte" - c'est-à-dire  émuler la saisie de texte humain en faisant une pause entre l'insertion de lettres.  Il semble être écrit comme un "œuf de Pâques", mais vous pouvez trouver une sorte d'application fonctionnelle de cette fonctionnalité ( <s>duper Upwork, oui</s> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pauseTimeArray[nbPauseTime] = {<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">600</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRange = <span class="hljs-number"><span class="hljs-number">200</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ranNum = getRandomNumber(maxRange); ::Sleep(ranNum + pauseTimeArray[ranNum%nbPauseTime]); ::SendMessage(pCurrentView-&gt;getHSelf(), SCI_DELETEBACK, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Le problème ici est que le code a une idée d'une sorte de «personne moyenne» faisant une pause de 400 à 800 ms entre chaque touche enfoncée.  Ok, c'est peut-être "moyen" et normal.  Mais vous savez, si le programme que j'utilise fait des pauses dans mon travail simplement parce qu'ils semblent beaux et appropriés pour elle - cela ne signifie pas du tout que je partage son avis.  Je voudrais pouvoir ajuster la durée des données de pause.  Et, si dans le cas de Notepad ++ ce n'est pas très critique, alors dans d'autres programmes, je suis parfois tombé sur des paramètres tels que «mise à jour des données: souvent, normalement, rarement», où «souvent» ne me suffisait pas souvent, et «rarement» ne suffisait pas rarement.  Oui, et «normal» n'était pas normal.  Cette fonctionnalité doit permettre à l'utilisateur d'indiquer avec précision le nombre de millisecondes qu'il souhaite attendre jusqu'à ce que l'action souhaitée soit terminée.  Avec l'option obligatoire pour entrer "0".  De plus, 0 dans ce cas ne doit même pas être passé comme argument à la fonction Sleep, mais simplement exclure son appel (Sleep (0) ne retourne pas réellement instantanément, mais donne la partie restante de la tranche de temps donnée par le planificateur à un autre thread). <br><br><h2>  Conclusions </h2><br>  Avec l'aide du sommeil, on peut et doit répondre à une attente quand il s'agit d'une attente assignée inconditionnellement pour une période de temps spécifique et il y a une explication logique pour laquelle il en est ainsi: «selon le processus technologique», «le temps est calculé selon cette formule», «attendez tellement dit le client. "  L'attente de certains événements ou la synchronisation des threads ne doivent pas être implémentées à l'aide de la fonction Veille. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427843/">https://habr.com/ru/post/fr427843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427829/index.html">Supervision ou externalisation? Telle est la question</a></li>
<li><a href="../fr427833/index.html">Rapport de la conférence Joker 2018</a></li>
<li><a href="../fr427837/index.html">Les premiers jours dans l'équipe de développement - comme cela arrive avec nous</a></li>
<li><a href="../fr427839/index.html">Autorisation utilisateur dans Django via GSSAPI et délégation de droits utilisateur au serveur</a></li>
<li><a href="../fr427841/index.html">Escroquerie Magic Leap</a></li>
<li><a href="../fr427845/index.html">Comment installer un million d'étoiles dans un iPhone</a></li>
<li><a href="../fr427847/index.html">Curiosité et procrastination dans l'apprentissage automatique</a></li>
<li><a href="../fr427849/index.html">Ligne droite avec TM. v3.0</a></li>
<li><a href="../fr427853/index.html">Réflexions sur TDD. Pourquoi cette méthodologie n'est pas largement reconnue</a></li>
<li><a href="../fr427855/index.html">Mitaps MOSDROID dans FunCorp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>