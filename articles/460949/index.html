<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 😎 ✡️ "Y lo imposible es posible": convertimos un cuadro negro en blanco mediante análisis binario ⭐️ 👸🏽 🈶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por el momento, hay dos enfoques principales para la búsqueda de vulnerabilidades en las aplicaciones: análisis estático y dinámico. Ambos enfoques ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Y lo imposible es posible": convertimos un cuadro negro en blanco mediante análisis binario</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="imagen"></div><br>  Por el momento, hay dos enfoques principales para la búsqueda de vulnerabilidades en las aplicaciones: análisis estático y dinámico.  Ambos enfoques tienen sus pros y sus contras.  El mercado llega a la conclusión de que ambos enfoques deben usarse: resuelven problemas ligeramente diferentes con resultados diferentes.  Sin embargo, en algunos casos, el uso del análisis estático es limitado, por ejemplo, cuando no hay código fuente.  En este artículo, hablaremos sobre una tecnología bastante rara pero muy útil que le permite combinar las ventajas de los enfoques estáticos y dinámicos: el análisis estático del código ejecutable. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Vamos de lejos</b> <div class="spoiler_text"> Según la compañía de antivirus McAfee, el daño global provocado por el cibercrimen en 2017 ascendió a alrededor de $ 600 mil millones, lo que equivale al 0,8% del PIB mundial.  Vivimos en la era de la tecnología de la información, cuyos detalles específicos han sido la rápida integración de la red global y las tecnologías de Internet en todas las esferas de la actividad humana.  Ahora los delitos cibernéticos ya no están fuera de lo común.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las estadísticas</a> muestran un aumento en el cibercrimen exponencialmente. <br><br>  La vulnerabilidad de las aplicaciones se ha convertido en un problema grave: según el Departamento de Seguridad Nacional de EE. UU., Más del 90% de los ciberataques exitosos se implementan utilizando diversas vulnerabilidades en las aplicaciones.  Los métodos de explotación de vulnerabilidades más famosos son: <br><br><ul><li>  Inyección SQL </li><li>  desbordamiento de búfer </li><li>  secuencias de comandos de crossite </li><li>  Usando una configuración insegura. </li></ul><br></div></div><br>  El análisis de software (software) para detectar la presencia de capacidades no declaradas (NDV) y vulnerabilidades es la tecnología principal para garantizar la seguridad de las aplicaciones. <br>  Hablando de tecnologías clásicas y bien establecidas para analizar software en busca de vulnerabilidades y NDV (para el cumplimiento de los requisitos de seguridad de la información), podemos distinguir: <br><br><ul><li>  análisis de código estático (pruebas de seguridad de aplicaciones estáticas); </li><li>  análisis de código dinámico (Dynamic Application Security Testing). </li></ul><br>  Existe IAST (análisis interactivo), sin embargo, es esencialmente dinámico (en el proceso de análisis, un agente adicional observa lo que sucede durante la ejecución de la aplicación).  RASP (Runtime Application Self-Defense), que a veces también se menciona en varias herramientas de análisis, es más probable que sea una herramienta de protección. <br><br>  El análisis dinámico (el método "Black Box") es una verificación del programa durante su ejecución.  Las siguientes ventajas se pueden distinguir de este enfoque. <br><br><ol><li>  Dado que las vulnerabilidades están en el programa ejecutable y el error se detecta utilizando su operación, la generación de falsos positivos es menor que la del análisis estático. </li><li>  No se necesita código fuente para realizar el análisis. </li></ol><br>  Pero también hay desventajas. <br><br><ol><li>  Cobertura incompleta del código y, por lo tanto, existen riesgos de vulnerabilidades faltantes.  Por ejemplo, el análisis dinámico no puede encontrar vulnerabilidades asociadas con el uso de criptografía débil o marcadores como "bomba temporal". </li><li>  La necesidad de ejecutar la aplicación, que en algunos casos puede ser difícil.  El lanzamiento de la aplicación puede requerir una configuración compleja y la configuración de varias integraciones.  Además, para que los resultados sean lo más precisos posible, es necesario reproducir el "entorno de combate", pero es difícil darse cuenta de esto sin dañar el software. </li></ol><br>  El análisis estático (el método de la "Caja blanca") es un tipo de prueba de programa en el que el programa no se ejecuta. <br><br>  Enumeramos los beneficios. <br><br><ol><li>  Cobertura completa del código, lo que lleva a la búsqueda de más vulnerabilidades. </li><li>  Sin dependencia del entorno en el que se ejecutará el programa. </li><li>  La capacidad de implementar pruebas en las etapas iniciales de escritura de código para un módulo o programa en ausencia de archivos ejecutables.  Esto le permite integrar de manera flexible una solución similar en el SDLC (Ciclo de vida de desarrollo de software  ciclo de vida de desarrollo de software) al comienzo del desarrollo. </li></ol><br>  El único inconveniente del método es la presencia de falsos positivos: la necesidad de evaluar si el analizador indica un error real o si es probable que este falso positivo. <br><br>  Como podemos ver, ambos métodos de análisis tienen ventajas y desventajas.  Sin embargo, ¿es posible de alguna manera utilizar las ventajas de estos métodos y minimizar las desventajas?  Sí, si aplica el análisis binario: la búsqueda de vulnerabilidades en archivos ejecutables mediante análisis estático. <br><br><h2>  Análisis binario o tecnología de análisis de archivos ejecutables </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="imagen"></div><br>  El análisis binario permite el análisis estático sin código fuente, por ejemplo, en el caso de contratistas externos.  Además, la cobertura del código será completa, en contraste con la aplicación del método de análisis dinámico.  Mediante el análisis binario, puede verificar las bibliotecas de terceros utilizadas en el proceso de desarrollo para las que no hay código fuente.  Además, mediante el análisis binario, puede realizar una verificación de control de la versión, comparando los resultados del análisis del código fuente del repositorio y el código ejecutable del servidor de combate. <br><br>  En el proceso de análisis binario, la imagen binaria se transforma en una representación intermedia (representación interna o modelo de código) para su posterior análisis.  Después de eso, los algoritmos de análisis estático se aplican a la representación interna.  Como resultado, el modelo actual se complementa con la información necesaria para la detección adicional de vulnerabilidades y NDV.  En la siguiente etapa, la aplicación de las reglas para buscar vulnerabilidades y NDV. <br><br>  Escribimos más sobre el esquema de análisis estático <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un artículo anterior</a> .  A diferencia del análisis de código fuente, que utiliza elementos de teoría de compilación (análisis léxico, sintáctico) para construir el modelo, el análisis binario utiliza la teoría de traducción inversa para desmontar, descompilar y desofuscar el modelo. <br><br><h2>  Un poco sobre los términos </h2><br>  Estamos hablando de analizar archivos ejecutables que no tienen información de depuración.  Con la información de depuración, la tarea se simplifica enormemente, pero si hay información de depuración, lo más probable es que el código fuente sea irrelevante. <br><br>  En este artículo, llamamos al análisis de bytecode de Java también análisis binario, aunque esto no es del todo correcto.  Hacemos esto para simplificar el texto.  Por supuesto, la tarea de analizar el bytecode JVM es más simple que analizar el código binario C / C ++ y Objective-C / Swift.  Pero el esquema de análisis general es similar en el caso de bytecode y código binario.  Las principales dificultades descritas en el artículo se relacionan específicamente con el análisis del código binario. <br><br>  La descompilación es el proceso de recuperación del código fuente del código binario.  Puede hablar sobre los elementos de la traducción inversa: desmontaje (obtención del código del ensamblador a partir de una imagen binaria), traducción del ensamblador a un código de tres direcciones u otra representación, restauración de las construcciones del nivel del código fuente. <br><br>  Ofuscación: transformaciones que preservan la funcionalidad del código fuente, pero dificultan la descompilación y la comprensión de la imagen binaria resultante.  La desofuscación es la transformación inversa.  La ofuscación se puede aplicar tanto a nivel de código fuente como a nivel de código binario. <br><br><h2>  ¿Cómo ver los resultados? </h2><br>  Comencemos un poco desde el final, pero la cuestión de ver los resultados del análisis binario generalmente se hace primero. <br><br>  Es importante que un especialista analice el código binario para asignar vulnerabilidades y NDV al código fuente.  Para hacer esto, en la etapa final, el proceso de desofuscación (desentrañamiento) se inicia si se aplicaron conversiones confusas, y el código binario se descompiló en la fuente.  Es decir, las vulnerabilidades se pueden demostrar en el código descompilado. <br><br>  En el proceso de descompilación, incluso si descompilamos el bytecode de JVM, parte de la información no se restaura correctamente, por lo que el análisis en sí tiene lugar en una representación cercana al código binario.  En consecuencia, surge la pregunta: ¿cómo, al encontrar vulnerabilidades en el código binario, localizarlas en la fuente?  La solución al problema para el código de bytes JVM se describió <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestro artículo sobre la búsqueda de vulnerabilidades en el código de bytes Java</a> .  La solución para el código binario es similar, es decir, una pregunta técnica. <br><br>  Repitamos la advertencia importante: estamos hablando del análisis de código binario sin información de depuración.  En presencia de información de depuración, la tarea se simplifica enormemente. <br><br>  La pregunta principal que se nos hace para mostrar los resultados es si el código descompilado es suficiente para comprender y localizar la vulnerabilidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="imagen"></div><br>  A continuación se presentan algunos pensamientos sobre este tema. <br><br><ol><li>  Si estamos hablando del código de bytes JVM, entonces en general la respuesta es "sí": la calidad de descompilación del código de bytes es excelente.  Casi siempre puedes descubrir cuál es la vulnerabilidad. </li><li>  Lo que puede interferir con la localización cualitativa de la vulnerabilidad es una simple ofuscación, como renombrar nombres de clase y funciones.  Sin embargo, en la práctica a menudo resulta que es más importante comprender la vulnerabilidad que determinar en qué archivo se encuentra.  La localización es necesaria cuando alguien puede corregir la vulnerabilidad, pero en este caso, el desarrollador también comprenderá de dónde proviene la vulnerabilidad del código descompilado. </li><li>  Cuando hablamos del análisis del código binario (por ejemplo, C ++), por supuesto, todo es mucho más complicado.  No hay ninguna herramienta que recupere completamente el código aleatorio de C ++.  Sin embargo, la peculiaridad de nuestro caso es que no necesitamos compilar el código más tarde: necesitamos calidad suficiente para comprender la vulnerabilidad. </li><li>  Muy a menudo, puede lograr una calidad de descompilación suficiente para comprender la vulnerabilidad encontrada.  Para hacer esto, debe resolver muchos problemas complejos, pero puede resolverlos (a continuación, hablaremos brevemente al respecto). </li><li>  Para C / C ++, es aún más difícil localizar la vulnerabilidad: los nombres de los caracteres se pierden de muchas maneras durante el proceso de compilación, no puede restaurarlos. </li><li>  La situación en Objective-C es ligeramente mejor: hay nombres de funciones allí y es más fácil localizar la vulnerabilidad. </li><li>  Los problemas de ofuscación se distinguen.  Hay una serie de transformaciones complejas que pueden complicar la descompilación y el mapeo de vulnerabilidades.  En la práctica, resulta que un buen descompilador puede manejar la mayoría de las conversiones confusas (recuerde que necesitamos suficiente calidad de código para comprender la vulnerabilidad). </li></ol><br>  Como conclusión, la mayoría de las veces muestra la vulnerabilidad para que se pueda entender y verificar. <br><br><h2>  Complejidades y detalles del análisis binario. </h2><br>  Aquí no hablaremos sobre el bytecode: todas las cosas interesantes sobre él ya se han dicho anteriormente.  Lo más interesante es el análisis del código binario real.  Aquí hablaremos sobre el análisis de C / C ++, Objective-C y Swift como ejemplo. <br><br>  Surgen dificultades significativas incluso cuando se desmonta.  La etapa más importante es la división de la imagen binaria en subprogramas.  Luego, seleccione las instrucciones del ensamblador en las subrutinas, una cuestión técnica.  Escribimos sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un artículo para la revista "Issues of Cybersecurity No. 1 (14) - 2016"</a> , aquí describiremos brevemente. <br><br>  Como ejemplo, hablaremos de la arquitectura x86.  Las instrucciones que contiene no tienen una longitud fija.  En las imágenes binarias, no hay una división clara en secciones de código y datos: las tablas de importación, las tablas de funciones virtuales pueden estar en la sección de códigos, las tablas de transición pueden estar en los intervalos entre los bloques de funciones base en la sección de códigos.  En consecuencia, debe poder separar el código de los datos y comprender dónde comienzan y dónde terminan las rutinas. <br><br>  Los más comunes son dos métodos para resolver el problema de determinar las direcciones iniciales de los subprogramas.  En el primer método, las direcciones de los subprogramas están determinadas por el prólogo estándar (para la arquitectura x86 es push ebp; mov ebp, esp).  En el segundo método, una sección de código se atraviesa recursivamente desde el punto de entrada con reconocimiento de instrucciones de llamada de subrutina.  La anulación se realiza reconociendo las instrucciones de ramificación.  Las combinaciones de los métodos descritos también se utilizan cuando se inicia un recorrido recursivo desde las direcciones de inicio encontradas por el prólogo. <br><br>  En la práctica, resulta que tales enfoques dan un porcentaje bastante bajo de código reconocido, ya que no todas las funciones tienen un prólogo estándar, y hay llamadas y transiciones indirectas. <br><br>  Los algoritmos básicos se pueden mejorar mediante las siguientes heurísticas. <br><br><ol><li>  En una gran base de prueba de imágenes, encuentre una lista más precisa de los prólogos (nuevos prólogos o variaciones de los estándares). </li><li>  Puede buscar automáticamente tablas de funciones virtuales y, a partir de ellas, seleccionar las direcciones iniciales de los subprogramas. </li><li>  Las direcciones iniciales de subprogramas y algunas otras construcciones se pueden encontrar en base a secciones de código binario asociadas con el mecanismo de manejo de excepciones. </li><li>  Puede verificar las direcciones de inicio buscando estas direcciones en la imagen y reconociendo las instrucciones de llamada. </li><li>  Para buscar límites, puede hacer un recorrido recursivo de la subrutina con el reconocimiento de las instrucciones de la dirección de inicio.  Hay una dificultad con las transiciones indirectas y las funciones sin retorno.  El análisis de la tabla de importación y el reconocimiento de construcciones de conmutadores pueden ayudar. <br></li></ol><br>  Otra cosa importante que debe hacerse durante la traducción inversa, para buscar normalmente una vulnerabilidad más adelante, es reconocer las funciones estándar en una imagen binaria.  Las funciones estándar pueden estar vinculadas estáticamente a la imagen, o incluso pueden estar en línea.  El algoritmo de reconocimiento principal es una búsqueda por firma con variaciones; para la solución, puede ofrecer el algoritmo Aho-Korasik adaptado.  Para recopilar firmas, debe analizar previamente las imágenes de la biblioteca recopiladas con diferentes condiciones y seleccionarlas como bytes que no cambian. <br><br><h2>  Que sigue </h2><br>  En la sección anterior, examinamos la etapa inicial de la traducción inversa de una imagen binaria: el desmontaje.  La etapa, de hecho, es inicial, pero determinante.  En esta etapa, puede perder parte del código, lo que tendrá un efecto dramático en los resultados del análisis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="imagen"></div><br>  Entonces suceden muchas cosas interesantes.  Diga brevemente sobre las tareas principales.  No hablaremos en detalle: ya sea el conocimiento, sobre el cual no podemos escribir explícitamente aquí, o no hay soluciones técnicas y de ingeniería muy interesantes en los detalles. <br><br><ol><li>  Convertir el código de ensamblaje en una representación intermedia en la que se puede realizar el análisis.  Puede usar varios bytecodes.  Para los lenguajes C, LLVM parece ser una buena opción.  LLVM es activamente apoyado y desarrollado por la comunidad, la infraestructura, incluso útil para el análisis estático, es actualmente impresionante.  En esta etapa, hay una gran cantidad de detalles a los que debe prestar atención.  Por ejemplo, debe detectar qué variables se abordan en la pila para no multiplicar entidades en la vista resultante.  Debe configurar la visualización óptima de los conjuntos de instrucciones de ensamblador en las instrucciones de bytecode. </li><li>  Restaurar estructuras de alto nivel (por ejemplo, bucles, ramas).  Cuanto más exactamente sea posible restaurar las construcciones originales del código del ensamblador, mejor será la calidad del análisis.  La restauración de tales construcciones se lleva a cabo utilizando elementos de la teoría de grafos en CFG (control de flujo) y algunas otras representaciones gráficas del programa. </li><li>  Realización de algoritmos de análisis estático.  Hay detalles.  En general, no es muy importante si obtuvimos la representación interna de la fuente o del binario: todos también necesitamos construir CFG, aplicar algoritmos de análisis de flujo de datos y otros algoritmos típicos de la estática.  Existen algunas características al analizar la vista obtenida del binario, pero son más técnicas. </li></ol><br><h2>  Conclusiones </h2><br>  Hablamos sobre cómo hacer análisis estáticos cuando no hay código fuente.  Según la experiencia de comunicación con los clientes, resulta que la tecnología es muy demandada.  Sin embargo, la tecnología es rara: el problema del análisis binario no es trivial, su solución requiere algoritmos complejos de alta tecnología de análisis estático y traducción inversa. <br><br>  <i>Este artículo fue escrito en colaboración con Anton Prokofiev, analista de Solar appScreener</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460949/">https://habr.com/ru/post/460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460939/index.html">Longrid sobre la historia de la minería rusa y la actitud de los reguladores hacia ella</a></li>
<li><a href="../460941/index.html">Compromiso de correo electrónico comercial: no hay defensa contra el ataque</a></li>
<li><a href="../460943/index.html">Cómo elegir claves prometedoras para SEO basadas en pronósticos de escenarios en Google Data Studio (+ plantilla)</a></li>
<li><a href="../460945/index.html">Experiencia en el uso de un canal de telegramas para aumentar el reconocimiento y el crecimiento de los ingresos de un estudio de juegos.</a></li>
<li><a href="../460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../460951/index.html">Crear fondos de pantalla animados de Android</a></li>
<li><a href="../460953/index.html">Los punteros son complejos, ¿o qué se almacena en un byte?</a></li>
<li><a href="../460955/index.html">Programa educativo para pasar parámetros por valor a constructores y setters (C ++ moderno, ejemplos)</a></li>
<li><a href="../460959/index.html">La nueva tecnología de Microsoft permite que las copias en 3D de una persona real hablen cualquier idioma</a></li>
<li><a href="../460961/index.html">Configuración de pruebas unitarias en proyectos mixtos Swift + Objective-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>