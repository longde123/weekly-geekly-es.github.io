<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游댟 游땙 九뫮잺 "Y lo imposible es posible": convertimos un cuadro negro en blanco mediante an치lisis binario 救넖잺 游놎游낗 游걌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por el momento, hay dos enfoques principales para la b칰squeda de vulnerabilidades en las aplicaciones: an치lisis est치tico y din치mico. Ambos enfoques ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Y lo imposible es posible": convertimos un cuadro negro en blanco mediante an치lisis binario</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="imagen"></div><br>  Por el momento, hay dos enfoques principales para la b칰squeda de vulnerabilidades en las aplicaciones: an치lisis est치tico y din치mico.  Ambos enfoques tienen sus pros y sus contras.  El mercado llega a la conclusi칩n de que ambos enfoques deben usarse: resuelven problemas ligeramente diferentes con resultados diferentes.  Sin embargo, en algunos casos, el uso del an치lisis est치tico es limitado, por ejemplo, cuando no hay c칩digo fuente.  En este art칤culo, hablaremos sobre una tecnolog칤a bastante rara pero muy 칰til que le permite combinar las ventajas de los enfoques est치ticos y din치micos: el an치lisis est치tico del c칩digo ejecutable. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Vamos de lejos</b> <div class="spoiler_text"> Seg칰n la compa침칤a de antivirus McAfee, el da침o global provocado por el cibercrimen en 2017 ascendi칩 a alrededor de $ 600 mil millones, lo que equivale al 0,8% del PIB mundial.  Vivimos en la era de la tecnolog칤a de la informaci칩n, cuyos detalles espec칤ficos han sido la r치pida integraci칩n de la red global y las tecnolog칤as de Internet en todas las esferas de la actividad humana.  Ahora los delitos cibern칠ticos ya no est치n fuera de lo com칰n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las estad칤sticas</a> muestran un aumento en el cibercrimen exponencialmente. <br><br>  La vulnerabilidad de las aplicaciones se ha convertido en un problema grave: seg칰n el Departamento de Seguridad Nacional de EE. UU., M치s del 90% de los ciberataques exitosos se implementan utilizando diversas vulnerabilidades en las aplicaciones.  Los m칠todos de explotaci칩n de vulnerabilidades m치s famosos son: <br><br><ul><li>  Inyecci칩n SQL </li><li>  desbordamiento de b칰fer </li><li>  secuencias de comandos de crossite </li><li>  Usando una configuraci칩n insegura. </li></ul><br></div></div><br>  El an치lisis de software (software) para detectar la presencia de capacidades no declaradas (NDV) y vulnerabilidades es la tecnolog칤a principal para garantizar la seguridad de las aplicaciones. <br>  Hablando de tecnolog칤as cl치sicas y bien establecidas para analizar software en busca de vulnerabilidades y NDV (para el cumplimiento de los requisitos de seguridad de la informaci칩n), podemos distinguir: <br><br><ul><li>  an치lisis de c칩digo est치tico (pruebas de seguridad de aplicaciones est치ticas); </li><li>  an치lisis de c칩digo din치mico (Dynamic Application Security Testing). </li></ul><br>  Existe IAST (an치lisis interactivo), sin embargo, es esencialmente din치mico (en el proceso de an치lisis, un agente adicional observa lo que sucede durante la ejecuci칩n de la aplicaci칩n).  RASP (Runtime Application Self-Defense), que a veces tambi칠n se menciona en varias herramientas de an치lisis, es m치s probable que sea una herramienta de protecci칩n. <br><br>  El an치lisis din치mico (el m칠todo "Black Box") es una verificaci칩n del programa durante su ejecuci칩n.  Las siguientes ventajas se pueden distinguir de este enfoque. <br><br><ol><li>  Dado que las vulnerabilidades est치n en el programa ejecutable y el error se detecta utilizando su operaci칩n, la generaci칩n de falsos positivos es menor que la del an치lisis est치tico. </li><li>  No se necesita c칩digo fuente para realizar el an치lisis. </li></ol><br>  Pero tambi칠n hay desventajas. <br><br><ol><li>  Cobertura incompleta del c칩digo y, por lo tanto, existen riesgos de vulnerabilidades faltantes.  Por ejemplo, el an치lisis din치mico no puede encontrar vulnerabilidades asociadas con el uso de criptograf칤a d칠bil o marcadores como "bomba temporal". </li><li>  La necesidad de ejecutar la aplicaci칩n, que en algunos casos puede ser dif칤cil.  El lanzamiento de la aplicaci칩n puede requerir una configuraci칩n compleja y la configuraci칩n de varias integraciones.  Adem치s, para que los resultados sean lo m치s precisos posible, es necesario reproducir el "entorno de combate", pero es dif칤cil darse cuenta de esto sin da침ar el software. </li></ol><br>  El an치lisis est치tico (el m칠todo de la "Caja blanca") es un tipo de prueba de programa en el que el programa no se ejecuta. <br><br>  Enumeramos los beneficios. <br><br><ol><li>  Cobertura completa del c칩digo, lo que lleva a la b칰squeda de m치s vulnerabilidades. </li><li>  Sin dependencia del entorno en el que se ejecutar치 el programa. </li><li>  La capacidad de implementar pruebas en las etapas iniciales de escritura de c칩digo para un m칩dulo o programa en ausencia de archivos ejecutables.  Esto le permite integrar de manera flexible una soluci칩n similar en el SDLC (Ciclo de vida de desarrollo de software  ciclo de vida de desarrollo de software) al comienzo del desarrollo. </li></ol><br>  El 칰nico inconveniente del m칠todo es la presencia de falsos positivos: la necesidad de evaluar si el analizador indica un error real o si es probable que este falso positivo. <br><br>  Como podemos ver, ambos m칠todos de an치lisis tienen ventajas y desventajas.  Sin embargo, 쯘s posible de alguna manera utilizar las ventajas de estos m칠todos y minimizar las desventajas?  S칤, si aplica el an치lisis binario: la b칰squeda de vulnerabilidades en archivos ejecutables mediante an치lisis est치tico. <br><br><h2>  An치lisis binario o tecnolog칤a de an치lisis de archivos ejecutables </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="imagen"></div><br>  El an치lisis binario permite el an치lisis est치tico sin c칩digo fuente, por ejemplo, en el caso de contratistas externos.  Adem치s, la cobertura del c칩digo ser치 completa, en contraste con la aplicaci칩n del m칠todo de an치lisis din치mico.  Mediante el an치lisis binario, puede verificar las bibliotecas de terceros utilizadas en el proceso de desarrollo para las que no hay c칩digo fuente.  Adem치s, mediante el an치lisis binario, puede realizar una verificaci칩n de control de la versi칩n, comparando los resultados del an치lisis del c칩digo fuente del repositorio y el c칩digo ejecutable del servidor de combate. <br><br>  En el proceso de an치lisis binario, la imagen binaria se transforma en una representaci칩n intermedia (representaci칩n interna o modelo de c칩digo) para su posterior an치lisis.  Despu칠s de eso, los algoritmos de an치lisis est치tico se aplican a la representaci칩n interna.  Como resultado, el modelo actual se complementa con la informaci칩n necesaria para la detecci칩n adicional de vulnerabilidades y NDV.  En la siguiente etapa, la aplicaci칩n de las reglas para buscar vulnerabilidades y NDV. <br><br>  Escribimos m치s sobre el esquema de an치lisis est치tico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art칤culo anterior</a> .  A diferencia del an치lisis de c칩digo fuente, que utiliza elementos de teor칤a de compilaci칩n (an치lisis l칠xico, sint치ctico) para construir el modelo, el an치lisis binario utiliza la teor칤a de traducci칩n inversa para desmontar, descompilar y desofuscar el modelo. <br><br><h2>  Un poco sobre los t칠rminos </h2><br>  Estamos hablando de analizar archivos ejecutables que no tienen informaci칩n de depuraci칩n.  Con la informaci칩n de depuraci칩n, la tarea se simplifica enormemente, pero si hay informaci칩n de depuraci칩n, lo m치s probable es que el c칩digo fuente sea irrelevante. <br><br>  En este art칤culo, llamamos al an치lisis de bytecode de Java tambi칠n an치lisis binario, aunque esto no es del todo correcto.  Hacemos esto para simplificar el texto.  Por supuesto, la tarea de analizar el bytecode JVM es m치s simple que analizar el c칩digo binario C / C ++ y Objective-C / Swift.  Pero el esquema de an치lisis general es similar en el caso de bytecode y c칩digo binario.  Las principales dificultades descritas en el art칤culo se relacionan espec칤ficamente con el an치lisis del c칩digo binario. <br><br>  La descompilaci칩n es el proceso de recuperaci칩n del c칩digo fuente del c칩digo binario.  Puede hablar sobre los elementos de la traducci칩n inversa: desmontaje (obtenci칩n del c칩digo del ensamblador a partir de una imagen binaria), traducci칩n del ensamblador a un c칩digo de tres direcciones u otra representaci칩n, restauraci칩n de las construcciones del nivel del c칩digo fuente. <br><br>  Ofuscaci칩n: transformaciones que preservan la funcionalidad del c칩digo fuente, pero dificultan la descompilaci칩n y la comprensi칩n de la imagen binaria resultante.  La desofuscaci칩n es la transformaci칩n inversa.  La ofuscaci칩n se puede aplicar tanto a nivel de c칩digo fuente como a nivel de c칩digo binario. <br><br><h2>  쮺칩mo ver los resultados? </h2><br>  Comencemos un poco desde el final, pero la cuesti칩n de ver los resultados del an치lisis binario generalmente se hace primero. <br><br>  Es importante que un especialista analice el c칩digo binario para asignar vulnerabilidades y NDV al c칩digo fuente.  Para hacer esto, en la etapa final, el proceso de desofuscaci칩n (desentra침amiento) se inicia si se aplicaron conversiones confusas, y el c칩digo binario se descompil칩 en la fuente.  Es decir, las vulnerabilidades se pueden demostrar en el c칩digo descompilado. <br><br>  En el proceso de descompilaci칩n, incluso si descompilamos el bytecode de JVM, parte de la informaci칩n no se restaura correctamente, por lo que el an치lisis en s칤 tiene lugar en una representaci칩n cercana al c칩digo binario.  En consecuencia, surge la pregunta: 쯖칩mo, al encontrar vulnerabilidades en el c칩digo binario, localizarlas en la fuente?  La soluci칩n al problema para el c칩digo de bytes JVM se describi칩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestro art칤culo sobre la b칰squeda de vulnerabilidades en el c칩digo de bytes Java</a> .  La soluci칩n para el c칩digo binario es similar, es decir, una pregunta t칠cnica. <br><br>  Repitamos la advertencia importante: estamos hablando del an치lisis de c칩digo binario sin informaci칩n de depuraci칩n.  En presencia de informaci칩n de depuraci칩n, la tarea se simplifica enormemente. <br><br>  La pregunta principal que se nos hace para mostrar los resultados es si el c칩digo descompilado es suficiente para comprender y localizar la vulnerabilidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="imagen"></div><br>  A continuaci칩n se presentan algunos pensamientos sobre este tema. <br><br><ol><li>  Si estamos hablando del c칩digo de bytes JVM, entonces en general la respuesta es "s칤": la calidad de descompilaci칩n del c칩digo de bytes es excelente.  Casi siempre puedes descubrir cu치l es la vulnerabilidad. </li><li>  Lo que puede interferir con la localizaci칩n cualitativa de la vulnerabilidad es una simple ofuscaci칩n, como renombrar nombres de clase y funciones.  Sin embargo, en la pr치ctica a menudo resulta que es m치s importante comprender la vulnerabilidad que determinar en qu칠 archivo se encuentra.  La localizaci칩n es necesaria cuando alguien puede corregir la vulnerabilidad, pero en este caso, el desarrollador tambi칠n comprender치 de d칩nde proviene la vulnerabilidad del c칩digo descompilado. </li><li>  Cuando hablamos del an치lisis del c칩digo binario (por ejemplo, C ++), por supuesto, todo es mucho m치s complicado.  No hay ninguna herramienta que recupere completamente el c칩digo aleatorio de C ++.  Sin embargo, la peculiaridad de nuestro caso es que no necesitamos compilar el c칩digo m치s tarde: necesitamos calidad suficiente para comprender la vulnerabilidad. </li><li>  Muy a menudo, puede lograr una calidad de descompilaci칩n suficiente para comprender la vulnerabilidad encontrada.  Para hacer esto, debe resolver muchos problemas complejos, pero puede resolverlos (a continuaci칩n, hablaremos brevemente al respecto). </li><li>  Para C / C ++, es a칰n m치s dif칤cil localizar la vulnerabilidad: los nombres de los caracteres se pierden de muchas maneras durante el proceso de compilaci칩n, no puede restaurarlos. </li><li>  La situaci칩n en Objective-C es ligeramente mejor: hay nombres de funciones all칤 y es m치s f치cil localizar la vulnerabilidad. </li><li>  Los problemas de ofuscaci칩n se distinguen.  Hay una serie de transformaciones complejas que pueden complicar la descompilaci칩n y el mapeo de vulnerabilidades.  En la pr치ctica, resulta que un buen descompilador puede manejar la mayor칤a de las conversiones confusas (recuerde que necesitamos suficiente calidad de c칩digo para comprender la vulnerabilidad). </li></ol><br>  Como conclusi칩n, la mayor칤a de las veces muestra la vulnerabilidad para que se pueda entender y verificar. <br><br><h2>  Complejidades y detalles del an치lisis binario. </h2><br>  Aqu칤 no hablaremos sobre el bytecode: todas las cosas interesantes sobre 칠l ya se han dicho anteriormente.  Lo m치s interesante es el an치lisis del c칩digo binario real.  Aqu칤 hablaremos sobre el an치lisis de C / C ++, Objective-C y Swift como ejemplo. <br><br>  Surgen dificultades significativas incluso cuando se desmonta.  La etapa m치s importante es la divisi칩n de la imagen binaria en subprogramas.  Luego, seleccione las instrucciones del ensamblador en las subrutinas, una cuesti칩n t칠cnica.  Escribimos sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en</a> detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art칤culo para la revista "Issues of Cybersecurity No. 1 (14) - 2016"</a> , aqu칤 describiremos brevemente. <br><br>  Como ejemplo, hablaremos de la arquitectura x86.  Las instrucciones que contiene no tienen una longitud fija.  En las im치genes binarias, no hay una divisi칩n clara en secciones de c칩digo y datos: las tablas de importaci칩n, las tablas de funciones virtuales pueden estar en la secci칩n de c칩digos, las tablas de transici칩n pueden estar en los intervalos entre los bloques de funciones base en la secci칩n de c칩digos.  En consecuencia, debe poder separar el c칩digo de los datos y comprender d칩nde comienzan y d칩nde terminan las rutinas. <br><br>  Los m치s comunes son dos m칠todos para resolver el problema de determinar las direcciones iniciales de los subprogramas.  En el primer m칠todo, las direcciones de los subprogramas est치n determinadas por el pr칩logo est치ndar (para la arquitectura x86 es push ebp; mov ebp, esp).  En el segundo m칠todo, una secci칩n de c칩digo se atraviesa recursivamente desde el punto de entrada con reconocimiento de instrucciones de llamada de subrutina.  La anulaci칩n se realiza reconociendo las instrucciones de ramificaci칩n.  Las combinaciones de los m칠todos descritos tambi칠n se utilizan cuando se inicia un recorrido recursivo desde las direcciones de inicio encontradas por el pr칩logo. <br><br>  En la pr치ctica, resulta que tales enfoques dan un porcentaje bastante bajo de c칩digo reconocido, ya que no todas las funciones tienen un pr칩logo est치ndar, y hay llamadas y transiciones indirectas. <br><br>  Los algoritmos b치sicos se pueden mejorar mediante las siguientes heur칤sticas. <br><br><ol><li>  En una gran base de prueba de im치genes, encuentre una lista m치s precisa de los pr칩logos (nuevos pr칩logos o variaciones de los est치ndares). </li><li>  Puede buscar autom치ticamente tablas de funciones virtuales y, a partir de ellas, seleccionar las direcciones iniciales de los subprogramas. </li><li>  Las direcciones iniciales de subprogramas y algunas otras construcciones se pueden encontrar en base a secciones de c칩digo binario asociadas con el mecanismo de manejo de excepciones. </li><li>  Puede verificar las direcciones de inicio buscando estas direcciones en la imagen y reconociendo las instrucciones de llamada. </li><li>  Para buscar l칤mites, puede hacer un recorrido recursivo de la subrutina con el reconocimiento de las instrucciones de la direcci칩n de inicio.  Hay una dificultad con las transiciones indirectas y las funciones sin retorno.  El an치lisis de la tabla de importaci칩n y el reconocimiento de construcciones de conmutadores pueden ayudar. <br></li></ol><br>  Otra cosa importante que debe hacerse durante la traducci칩n inversa, para buscar normalmente una vulnerabilidad m치s adelante, es reconocer las funciones est치ndar en una imagen binaria.  Las funciones est치ndar pueden estar vinculadas est치ticamente a la imagen, o incluso pueden estar en l칤nea.  El algoritmo de reconocimiento principal es una b칰squeda por firma con variaciones; para la soluci칩n, puede ofrecer el algoritmo Aho-Korasik adaptado.  Para recopilar firmas, debe analizar previamente las im치genes de la biblioteca recopiladas con diferentes condiciones y seleccionarlas como bytes que no cambian. <br><br><h2>  Que sigue </h2><br>  En la secci칩n anterior, examinamos la etapa inicial de la traducci칩n inversa de una imagen binaria: el desmontaje.  La etapa, de hecho, es inicial, pero determinante.  En esta etapa, puede perder parte del c칩digo, lo que tendr치 un efecto dram치tico en los resultados del an치lisis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="imagen"></div><br>  Entonces suceden muchas cosas interesantes.  Diga brevemente sobre las tareas principales.  No hablaremos en detalle: ya sea el conocimiento, sobre el cual no podemos escribir expl칤citamente aqu칤, o no hay soluciones t칠cnicas y de ingenier칤a muy interesantes en los detalles. <br><br><ol><li>  Convertir el c칩digo de ensamblaje en una representaci칩n intermedia en la que se puede realizar el an치lisis.  Puede usar varios bytecodes.  Para los lenguajes C, LLVM parece ser una buena opci칩n.  LLVM es activamente apoyado y desarrollado por la comunidad, la infraestructura, incluso 칰til para el an치lisis est치tico, es actualmente impresionante.  En esta etapa, hay una gran cantidad de detalles a los que debe prestar atenci칩n.  Por ejemplo, debe detectar qu칠 variables se abordan en la pila para no multiplicar entidades en la vista resultante.  Debe configurar la visualizaci칩n 칩ptima de los conjuntos de instrucciones de ensamblador en las instrucciones de bytecode. </li><li>  Restaurar estructuras de alto nivel (por ejemplo, bucles, ramas).  Cuanto m치s exactamente sea posible restaurar las construcciones originales del c칩digo del ensamblador, mejor ser치 la calidad del an치lisis.  La restauraci칩n de tales construcciones se lleva a cabo utilizando elementos de la teor칤a de grafos en CFG (control de flujo) y algunas otras representaciones gr치ficas del programa. </li><li>  Realizaci칩n de algoritmos de an치lisis est치tico.  Hay detalles.  En general, no es muy importante si obtuvimos la representaci칩n interna de la fuente o del binario: todos tambi칠n necesitamos construir CFG, aplicar algoritmos de an치lisis de flujo de datos y otros algoritmos t칤picos de la est치tica.  Existen algunas caracter칤sticas al analizar la vista obtenida del binario, pero son m치s t칠cnicas. </li></ol><br><h2>  Conclusiones </h2><br>  Hablamos sobre c칩mo hacer an치lisis est치ticos cuando no hay c칩digo fuente.  Seg칰n la experiencia de comunicaci칩n con los clientes, resulta que la tecnolog칤a es muy demandada.  Sin embargo, la tecnolog칤a es rara: el problema del an치lisis binario no es trivial, su soluci칩n requiere algoritmos complejos de alta tecnolog칤a de an치lisis est치tico y traducci칩n inversa. <br><br>  <i>Este art칤culo fue escrito en colaboraci칩n con Anton Prokofiev, analista de Solar appScreener</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460949/">https://habr.com/ru/post/460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460939/index.html">Longrid sobre la historia de la miner칤a rusa y la actitud de los reguladores hacia ella</a></li>
<li><a href="../460941/index.html">Compromiso de correo electr칩nico comercial: no hay defensa contra el ataque</a></li>
<li><a href="../460943/index.html">C칩mo elegir claves prometedoras para SEO basadas en pron칩sticos de escenarios en Google Data Studio (+ plantilla)</a></li>
<li><a href="../460945/index.html">Experiencia en el uso de un canal de telegramas para aumentar el reconocimiento y el crecimiento de los ingresos de un estudio de juegos.</a></li>
<li><a href="../460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../460951/index.html">Crear fondos de pantalla animados de Android</a></li>
<li><a href="../460953/index.html">Los punteros son complejos, 쯢 qu칠 se almacena en un byte?</a></li>
<li><a href="../460955/index.html">Programa educativo para pasar par치metros por valor a constructores y setters (C ++ moderno, ejemplos)</a></li>
<li><a href="../460959/index.html">La nueva tecnolog칤a de Microsoft permite que las copias en 3D de una persona real hablen cualquier idioma</a></li>
<li><a href="../460961/index.html">Configuraci칩n de pruebas unitarias en proyectos mixtos Swift + Objective-C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>