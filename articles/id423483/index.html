<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📺 🙂 🈳 Menemukan Cara yang Tepat untuk Memisahkan Konten Situs Web Menggunakan Webpack 🔶 👆 🤬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menemukan cara terbaik untuk mengatur materi proyek web bisa menjadi tugas yang menakutkan. Ada banyak skenario berbeda untuk pengguna yang bekerja de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menemukan Cara yang Tepat untuk Memisahkan Konten Situs Web Menggunakan Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423483/">  Menemukan cara terbaik untuk mengatur materi proyek web bisa menjadi tugas yang menakutkan.  Ada banyak skenario berbeda untuk pengguna yang bekerja dengan proyek, banyak teknologi dan faktor lain yang perlu diperhitungkan. <br><br>  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa ia ingin memberi tahu semua yang perlu Anda ketahui di sini untuk persiapan materi proyek web yang kompeten untuk pekerjaan.  Pertama, tentang bagaimana memilih strategi untuk memisahkan file situs yang paling cocok untuk proyek tertentu dan bagi penggunanya.  Kedua, cara menerapkan strategi yang dipilih akan dipertimbangkan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/7fe/270/c2c/7fe270c2cd5aad585ca616a6f3704704.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informasi umum</font> </h2><br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Glosarium Webpack</a> , ada dua strategi berbagi file.  Ini adalah pemecahan berkas dan pemecahan kode.  Istilah-istilah ini tampaknya digunakan secara bergantian, tetapi tidak. <br><br><ul><li>  Memisahkan bundel adalah teknik untuk memecah bundel besar menjadi beberapa bagian, yaitu file yang lebih kecil.  File seperti itu, dalam hal apa pun, seperti ketika bekerja dengan satu bundel, akan diunduh oleh semua pengguna situs.  Kekuatan dari teknik ini adalah untuk meningkatkan penggunaan mekanisme caching berbasis browser. </li><li>  Pemisahan kode adalah pendekatan yang melibatkan pemuatan kode secara dinamis saat diperlukan.  Ini mengarah pada fakta bahwa pengguna hanya mengunduh kode yang ia perlukan untuk bekerja dengan bagian tertentu dari situs pada titik waktu tertentu. </li></ul><br>  Pemecahan kode tampaknya jauh lebih menarik daripada pemecahan kode.  Dan, pada kenyataannya, ada perasaan bahwa dalam banyak artikel tentang topik kita, fokus utamanya adalah pada pemisahan kode, teknik ini dianggap sebagai satu-satunya cara yang bermanfaat untuk mengoptimalkan materi situs. <br><br>  Namun, saya ingin mengatakan bahwa bagi banyak situs itu adalah strategi pertama yang jauh lebih berharga - pemisahan bundel.  Dan, mungkin, secara harfiah semua proyek web dapat menang dari implementasinya. <br><br>  Mari kita bicarakan ini secara lebih rinci. <br><br><h2>  <font color="#3AC1EF">Pemisahan bundel</font> </h2><br>  Teknik untuk memisahkan bundel didasarkan pada ide yang sangat sederhana.  Jika Anda memiliki satu file besar dan Anda mengubah satu baris kode di dalamnya, pengguna biasa harus mengunduh seluruh file saat berikutnya dia mengunjungi situs.  Namun, jika Anda membagi file ini menjadi dua file, maka pengguna yang sama hanya perlu mengunduh satu yang telah diubah, dan file kedua akan diambil dari cache browser. <br><br>  Perlu dicatat bahwa karena pengoptimalan materi situs dengan memisahkan bundel terkait dengan caching, pengguna yang mengunjungi situs untuk pertama kali harus mengunduh semua materi, sehingga tidak ada bedanya bagi mereka apakah materi ini akan disajikan sebagai satu file atau beberapa . <br><br>  Menurut saya terlalu banyak bicara tentang kinerja proyek web didedikasikan untuk pengguna yang mengunjungi situs untuk pertama kalinya.  Mungkin demikian, sebagian, karena pentingnya kesan pertama bahwa proyek akan membuat pada pengguna, serta fakta bahwa jumlah data yang dikirimkan kepada pengguna ketika mereka pertama kali mengunjungi situs itu sederhana dan nyaman untuk diukur. <br><br>  Ketika datang ke pengunjung reguler, mungkin sulit untuk mengukur dampak teknik pengoptimalan materi yang diterapkan pada mereka.  Tetapi kita harus tahu tentang konsekuensi dari optimasi tersebut. <br><br>  Untuk menganalisis hal-hal ini, Anda memerlukan sesuatu seperti spreadsheet.  Anda juga perlu membuat daftar kondisi yang ketat di mana kami dapat menguji setiap strategi caching yang dipelajari. <br><br>  Berikut ini adalah skrip yang sesuai dengan deskripsi umum yang diberikan pada paragraf sebelumnya: <br><br><ul><li>  Alice mengunjungi situs kami seminggu sekali selama 10 minggu. </li><li>  Kami memperbarui situs seminggu sekali. </li><li>  Setiap minggu, kami memperbarui halaman daftar produk. </li><li>  Selain itu, kami memiliki halaman dengan detail produk, tetapi kami belum mengerjakannya. </li><li>  Pada minggu kelima, kami menambahkan paket npm baru ke materi proyek. </li><li>  Pada minggu kedelapan, kami memperbarui salah satu paket npm yang sudah digunakan dalam proyek. </li></ul><br>  Ada orang (seperti saya) yang akan mencoba membuat skenario sedemikian realistis mungkin.  Tetapi Anda tidak perlu melakukan itu.  Skenario nyata di sini tidak terlalu penting.  Mengapa demikian - kita akan segera tahu. <br><br><h3>  <font color="#3AC1EF">▍ Kondisi awal</font> </h3><br>  Misalkan ukuran total paket JavaScript kami adalah 400 Kb dan kami, dalam kondisi saat ini, mentransfer semua ini kepada pengguna sebagai file <code>main.js</code> tunggal.  Kami memiliki konfigurasi Webpack, yang, secara umum, mirip dengan yang berikut (Saya menghapus hal-hal yang tidak relevan dengan percakapan kami): <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, };</code> </pre> <br>  Webpack memberi nama file <code>main.js</code> dihasilkan ketika ada satu entri dalam konfigurasi. <br><br>  Jika Anda tidak memiliki ide bagus untuk bekerja dengan cache, perlu diingat bahwa setiap kali saya menulis <code>main.js</code> sini, saya sebenarnya berarti sesuatu seperti <code>main.xMePWxHo.js</code> .  Urutan karakter yang gila adalah hash dari isi file, apa yang disebut <code>contenthash</code> dalam konfigurasi.  Menggunakan pendekatan ini mengarah pada fakta bahwa, ketika mengubah kode, nama file juga berubah, yang memaksa browser untuk mengunduh file baru. <br><br>  Sesuai dengan skenario di atas, ketika kami membuat beberapa perubahan pada kode situs setiap minggu, garis konten <code>contenthash</code> dari paket berubah.  Akibatnya, setiap minggu mengunjungi situs kami, Alice terpaksa mengunggah file baru 400 Kb. <br><br>  Jika kami membuat tablet yang bagus (dengan garis hasil yang tidak berguna sejauh ini) yang berisi data volume mingguan pemuatan data per file ini, maka kami mendapatkan yang berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/fa6/424/3b6fa6424d43c147b40c5347e4dfa104.png"></div><br>  <i><font color="#999999">Jumlah data yang diunggah oleh pengguna</font></i> <br><br>  Hasilnya, ternyata pengguna, dalam 10 minggu, mengunduh kode 4,12 MB.  Indikator ini dapat ditingkatkan. <br><br><h3>  <font color="#3AC1EF">▍Paket paket pihak ketiga dari kode utama</font> </h3><br>  Bagilah paket besar menjadi dua bagian.  Kode kita sendiri akan berada di file <code>main.js</code> , dan kode pihak ketiga di file <code>vendor.js</code> .  Sangat mudah untuk melakukan ini, konfigurasi Webpack berikut akan membantu kami dengan ini: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, optimization: {   splitChunks: {     chunks: <span class="hljs-string"><span class="hljs-string">'all'</span></span>,   }, }, };</code> </pre> <br>  Webpack 4 mencoba membuat hidup semudah mungkin bagi pengembang, jadi dia melakukan semua yang dia bisa, dan tidak mengharuskannya untuk diberi tahu persis bagaimana memecah bundel menjadi beberapa bagian. <br><br>  Jenis perilaku otomatis dari program ini mengarah pada beberapa kesenangan, seperti: "Wah, betapa menariknya Webpack ini", dan banyak pertanyaan dalam semangat: "Apa ini dilakukan dengan bundel saya?". <br><br>  Bagaimanapun, menambahkan <code>optimization.splitChunks.chunks = 'all'</code> ke konfigurasi konfigurasi memberitahu Webpack bahwa kita memerlukannya untuk mengambil semuanya dari <code>node_modules</code> dan memasukkannya ke file <code>vendors~main.js</code> <br><br>  Setelah kami membuat pemisahan dasar bundel itu, Alice, yang secara teratur mengunjungi situs kami setiap minggu, akan mengunduh file <code>main.js</code> sebesar 200 Kb setiap kali dia mengunjungi.  Tapi dia akan mengunduh file <code>vendor.js</code> hanya tiga kali.  Ini akan terjadi selama kunjungan di minggu pertama, kelima dan kedelapan.  Berikut adalah tabel terkait, di mana, dengan kehendak nasib, ukuran <code>vendor.js</code> dan <code>vendor.js</code> dalam empat minggu pertama bertepatan dan sama dengan 200 Kb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f52/61f/49f/f5261f49f5f3dba9c34fec5f83a142b2.png"></div><br>  <i><font color="#999999">Jumlah data yang diunggah oleh pengguna</font></i> <br><br>  Hasilnya, ternyata jumlah data yang diunduh oleh pengguna selama 10 minggu adalah 2,64 MB.  Artinya, dibandingkan dengan apa yang sebelum pemisahan bundel, volumenya menurun sebesar 36%.  Bukan hasil yang buruk yang dicapai dengan menambahkan beberapa baris ke file konfigurasi.  By the way, sebelum membaca lebih lanjut - melakukan hal yang sama dalam proyek Anda.  Dan jika Anda perlu memutakhirkan dari Webpack 3 ke 4 - lakukan dan jangan khawatir, karena prosesnya cukup sederhana dan masih gratis. <br><br>  Tampaknya bagi saya bahwa peningkatan yang dipertimbangkan di sini terlihat agak abstrak, karena ini berlangsung lebih dari 10 minggu.  Namun, jika kami mempertimbangkan jumlah data yang dikirim ke pengguna yang loyal, maka ini adalah pengurangan jujur ​​dalam volume ini sebesar 36%.  Ini adalah hasil yang sangat bagus, tetapi dapat ditingkatkan. <br><br><h3>  <font color="#3AC1EF">▍ Sorot paket dalam file terpisah</font> </h3><br>  File <code>vendor.js</code> menderita masalah yang sama dengan <code>main.js</code>  Terdiri dari kenyataan bahwa mengubah paket apa pun yang termasuk dalam file ini mengarah pada kebutuhan pengguna biasa untuk mengunduh kembali seluruh file. <br><br>  Mengapa kita tidak membuat file terpisah untuk setiap paket npm?  Tidak sulit untuk melakukan ini, jadi mari kita dekomposisi <code>react</code> kita, <code>lodash</code> , <code>lodash</code> , <code>moment</code> , dan sebagainya menjadi file terpisah.  Konfigurasi Webpack berikut akan membantu kami dalam hal ini: <br><br><pre> <code class="hljs markdown">const path = require('path'); const webpack = require('webpack'); module.exports = { entry: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'), plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], output: {   path: path.resolve(__</span></span>dirname, 'dist'),   filename: '[<span class="hljs-string"><span class="hljs-string">name</span></span>].[<span class="hljs-string"><span class="hljs-string">contenthash</span></span>].js', }, optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules[\\/]/,         name(module) {           //  ,   node_</span></span>modules/packageName/not/this/part.js           //  node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName           const packageName = module.context.match(/[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Anda dapat menemukan penjelasan yang sangat baik tentang konstruksi yang digunakan di sini, tapi saya masih mencurahkan waktu untuk menceritakan beberapa hal, karena saya butuh banyak waktu untuk menggunakannya dengan benar. <br><br><ul><li>  Webpack memiliki instalasi standar yang cukup masuk akal, yang, pada kenyataannya, tidak begitu masuk akal.  Misalnya, jumlah maksimum file output diatur ke 3, ukuran file minimum adalah 30 KB (yaitu, file yang lebih kecil akan digabung).  Saya mendefinisikannya kembali. </li><li>  <code>cacheGroups</code> adalah tempat kami menetapkan aturan tentang bagaimana Webpack harus mengelompokkan data dalam file output.  Saya punya satu grup di sini, <code>vendor</code> , yang akan digunakan untuk modul apa saja yang diambil dari <code>node_modules</code> .  Biasanya nama untuk file output diberikan sebagai string.  Tapi saya memberi <code>name</code> sebagai fungsi yang akan dipanggil untuk setiap file yang diproses.  Lalu saya mengambil nama paket dari jalur modul.  Akibatnya, kami mendapatkan satu file untuk setiap paket.  Misalnya, <code>npm.react-dom.899sadfhj4.js</code> . </li><li>  Nama paket, sehingga mereka dapat dipublikasikan dalam npm, harus sesuai untuk digunakan dalam <a href="">URL</a> , jadi kita tidak perlu melakukan operasi <code>encodeURI</code> pada nama <code>packageName</code> .  Namun, saya mengalami masalah bahwa server .NET menolak untuk bekerja dengan file yang namanya mengandung simbol <code>@</code> (nama tersebut digunakan untuk paket dengan cakupan nama tertentu, paket lingkup yang disebut paket), jadi saya, dalam korespondensi fragmen kode, saya menyingkirkan karakter tersebut. </li></ul><br>  Konfigurasi Webpack di atas bagus karena Anda dapat mengonfigurasinya sekali, lalu lupakan.  Itu tidak perlu merujuk ke paket spesifik dengan nama, oleh karena itu, setelah dibuat, itu, bahkan ketika mengubah komposisi paket, tetap relevan. <br><br>  Alice, pengunjung tetap kami, masih <code>main.js</code> 200-kilobyte setiap minggu, dan pertama kali ia mengunjungi situs tersebut, ia dipaksa untuk mengunduh 200 KB paket npm, tetapi ia tidak harus mengunduh paket yang sama dua kali. <br><br>  Di bawah ini adalah versi baru tabel dengan informasi tentang volume unduhan data mingguan.  Secara kebetulan aneh, ukuran setiap file dengan paket npm adalah 20 Kb. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/787/006/f98787006dc9320ca37b680b23534e71.png"></div><br>  <i><font color="#999999">Jumlah data yang diunggah oleh pengguna</font></i> <br><br>  Sekarang volume data yang diunduh dalam 10 minggu adalah 2,24 Mb.  Ini berarti bahwa kami telah meningkatkan tarif dasar sebesar 44%.  Hasilnya sudah sangat layak, tetapi muncul pertanyaan apakah mungkin untuk mencapai hasil yang melebihi 50%.  Jika ini terjadi, itu akan menjadi luar biasa. <br><br><h3>  <font color="#3AC1EF">▍ Memecah kode aplikasi menjadi beberapa bagian</font> </h3><br>  Kami kembali ke file <code>main.js</code> , yang harus selalu diunduh Alice yang malang. <br><br>  Seperti yang saya katakan di atas, ada dua bagian terpisah di situs web kami.  Yang pertama adalah daftar produk, yang kedua adalah halaman dengan informasi terperinci tentang produk.  Ukuran kode, unik untuk masing-masing, adalah 25 Kb (dan 150 Kb kode digunakan di sana dan di sana). <br><br>  Halaman informasi produk tidak dapat berubah, karena kami telah menyempurnakannya.  Karenanya, jika kami mengekstrak kodenya ke file terpisah, file ini, sebagian besar waktu bekerja dengan situs, akan diunduh ke browser dari cache. <br><br>  Selain itu, ternyata, kami memiliki file SVG built-in besar yang digunakan untuk rendering ikon, yang beratnya mencapai 25 KB dan jarang berubah. <br><br>  Sesuatu harus dilakukan dengan ini. <br><br>  Kami secara manual membuat beberapa titik masuk, memberi tahu Webpack bahwa diperlukan untuk membuat file terpisah untuk masing-masing entitas ini. <br><br><pre> <code class="hljs markdown">module.exports = { entry: {   main: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'),   ProductList: path.resolve(__</span></span>dirname, 'src/ProductList/ProductList.js'),   ProductPage: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/ProductPage/ProductPage.js'),   Icon: path.resolve(__</span></span>dirname, 'src/Icon/Icon.js'), }, output: {   path: path.resolve(<span class="hljs-emphasis"><span class="hljs-emphasis">__dirname, 'dist'),   filename: '[name].[contenthash:8].js', }, plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]/,         name(module) {           //  ,   node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName/not/this/part.js           //  node_</span></span>modules/packageName           const packageName = module.context.match(/[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node_modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  Webpack yang bekerja keras, di samping itu, akan membuat file untuk apa yang umum, misalnya, <code>ProductList</code> dan <code>ProductPage</code> , yaitu, tidak akan ada kode duplikat. <br><br>  Apa yang baru saja kami lakukan akan memungkinkan Alice menghemat lalu lintas 50 Kb hampir setiap minggu.  Harap perhatikan bahwa kami mengedit file deskripsi ikon pada minggu keenam.  Ini meja tradisional kami. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/b9e/8ed/62fb9e8ed563fd4aa7a61fdcec61fc2d.png"></div><br>  <i><font color="#999999">Jumlah data yang diunggah oleh pengguna</font></i> <br><br>  Sekarang hanya dalam sepuluh minggu, hanya 1.815 MB data telah diunduh.  Ini berarti bahwa penghematan lalu lintas adalah 56% yang mengesankan.  Sesuai dengan skenario teoretis kami, pengguna biasa akan selalu bekerja dengan tingkat penghematan ini. <br><br>  Semua ini dilakukan karena perubahan yang dilakukan pada konfigurasi Webpack.  Kami tidak mengubah kode aplikasi untuk mencapai hasil seperti itu. <br><br>  Sebelumnya, saya berbicara tentang fakta bahwa skenario spesifik di mana tes semacam itu dilakukan, pada kenyataannya, tidak memainkan peran khusus.  Ini dikatakan karena fakta bahwa, terlepas dari skenario yang digunakan, kesimpulan dari semua yang kita bicarakan akan sama: membelah aplikasi menjadi file kecil yang masuk akal dalam aplikasi untuk arsitekturnya memungkinkan kita untuk mengurangi volume data situs, dimuat oleh pengguna regulernya. <br><br>  Segera kita akan mulai berbicara tentang pemisahan kode, tetapi pertama-tama saya ingin menjawab tiga pertanyaan yang mungkin Anda pikirkan sekarang. <br><br><h3>  <font color="#3AC1EF">▍ Pertanyaan nomor 1.</font>  <font color="#3AC1EF">Apakah kebutuhan untuk melakukan banyak permintaan tidak merusak kecepatan memuat situs?</font> </h3><br>  Anda dapat memberikan jawaban singkat sederhana untuk pertanyaan ini: "Tidak, itu tidak berbahaya."  Situasi serupa menghasilkan masalah di masa lalu, ketika protokol HTTP / 1.1 digunakan, dan ketika menggunakan HTTP / 2, ini tidak lagi relevan. <br><br>  Meskipun, perlu dicatat bahwa dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://medium.com/%40asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-">ini</a> , yang diterbitkan pada 2016, dan dalam artikel Khan Academy 2015 ini, kesimpulan ditarik bahwa bahkan ketika menggunakan HTTP / 2, menggunakan terlalu banyak file memperlambat pengunduhan.  Tetapi dalam kedua materi ini, "terlalu banyak" berarti "beberapa ratus."  Oleh karena itu, perlu diingat bahwa jika Anda harus bekerja dengan ratusan file, pembatasan pemrosesan data paralel dapat memengaruhi kecepatan unduhan mereka. <br><br>  Jika Anda tertarik, dukungan HTTP / 2 tersedia di IE 11 pada Windows 10. Selain itu, saya melakukan studi komprehensif di antara mereka yang menggunakan sistem yang lebih lama.  Mereka dengan suara bulat menyatakan bahwa kecepatan memuat situs web mereka tidak terlalu mengkhawatirkan. <br><br><h3>  <font color="#3AC1EF">▍ Pertanyaan nomor 2.</font>  <font color="#3AC1EF">Bundel Webpack memiliki kode pembantu.</font>  <font color="#3AC1EF">Apakah ini membuat beban tambahan pada sistem?</font> </h3><br>  Ya itu. <br><br><h3>  <font color="#3AC1EF">▍ Pertanyaan nomor 3.</font>  <font color="#3AC1EF">Ketika bekerja dengan banyak file kecil, tingkat kompresinya memburuk, bukan?</font> </h3><br>  Ya itu juga benar.  Sebenarnya, saya ingin mengatakan ini: <br><br><ul><li>  Lebih banyak file berarti lebih banyak kode pembantu Webpack. </li><li>  Lebih banyak file berarti lebih sedikit kompresi. </li></ul><br>  Mari kita mencari tahu untuk memahami seberapa buruk ini. <br><br>  Saya baru saja melakukan tes di mana kode dari file 190 Kb dipecah menjadi 19 bagian.  Ini menambahkan sekitar 2% ke jumlah data yang dikirim ke browser. <br><br>  Akibatnya, ternyata pada kunjungan pertama ke situs, pengguna akan mengunggah 2% lebih banyak data, dan pada kunjungan berikutnya - 60% lebih sedikit, dan ini akan berlanjut untuk waktu yang sangat, sangat lama. <br>  Jadi, apakah itu layak untuk dikhawatirkan?  Tidak, tidak sepadan. <br><br>  Ketika saya membandingkan sistem menggunakan 1 file dan sistem dengan 19 file, saya mengujinya menggunakan berbagai protokol, termasuk HTTP / 1.1.  Tabel di bawah ini sangat mendukung gagasan bahwa memiliki lebih banyak file berarti lebih baik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/2fa/47c/a852fa47c36befc2234794c9cae1b9c1.png"></div><br>  <i><font color="#999999">Data tentang bekerja dengan 2 versi situs yang di-host pada hosting statis Firebase, yang kodenya berukuran 190 Kb, tetapi, dalam kasus pertama, itu diolah menjadi 1 file, dan yang kedua itu dibagi menjadi 19</font></i> <br><br>  Saat bekerja di jaringan 3G dan 4G, mengunduh situs dengan 19 file membutuhkan waktu 30% lebih sedikit daripada mengunduh situs dengan satu file. <br><br>  Ada banyak suara dalam data yang disajikan dalam tabel.  Misalnya, satu sesi mengunduh situs dengan 4G (Jalankan 2 dalam tabel) mengambil 646 ms, yang lain (Jalankan 4) - 1116 ms, yang merupakan 73% lebih lama.  Oleh karena itu, ada perasaan yang mengatakan bahwa HTTP / 2 adalah "30% lebih cepat" agak tidak jujur. <br><br>  Saya membuat tabel ini untuk melihat apa yang diberikan oleh penggunaan HTTP / 2.  Tetapi, pada kenyataannya, satu-satunya hal yang dapat dikatakan di sini adalah bahwa penggunaan HTTP / 2 mungkin tidak terlalu mempengaruhi pemuatan halaman. <br><br>  Dua baris terakhir dalam tabel ini adalah kejutan nyata.  Berikut adalah hasil untuk bukan versi Windows terbaru dengan IE11 dan HTTP / 1.1.  Jika saya mencoba memprediksi hasil tes di muka, saya pasti akan mengatakan bahwa konfigurasi seperti itu akan memuat bahan jauh lebih lambat daripada yang lain.  Benar, koneksi jaringan yang sangat cepat digunakan di sini, dan saya, untuk tes seperti itu, mungkin harus menggunakan sesuatu yang lebih lambat. <br><br>  Dan sekarang saya akan menceritakan satu cerita kepada Anda.  Untuk menjelajahi situs saya pada sistem yang sangat kuno, saya mengunduh mesin virtual Windows 7 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web</a> Microsoft.  IE8 diinstal di sana, yang saya putuskan untuk ditingkatkan ke IE9.  Untuk melakukan ini, saya pergi ke halaman Microsoft yang dirancang untuk mengunduh IE 9. Tapi saya tidak bisa melakukan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/ee6/529/a3bee65295b45bf2467da37252674cf0.png"></div><br>  <i><font color="#999999">Nasib buruk itu ...</font></i> <br><br>  Omong-omong, jika kita berbicara tentang HTTP / 2, saya ingin mencatat bahwa protokol ini diintegrasikan ke dalam Node.js.  Jika Anda ingin bereksperimen, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">server HTTP / 2 kecil yang</a> saya tulis dengan dukungan untuk cache respons, gzip dan brotli. <br><br>  Mungkin, saya mengatakan semua yang saya inginkan tentang metode pemisahan bundel.  Saya pikir satu-satunya minus dari pendekatan ini, ketika menggunakan pengguna mana yang harus mengunggah banyak file, pada kenyataannya, bukan "minus". <br><br>  Sekarang mari kita bicara tentang pemisahan kode. <br><br><h2>  <font color="#3AC1EF">Pemisahan kode</font> </h2><br>  Gagasan utama dari teknik pemecahan kode adalah: "Jangan mengunduh kode yang tidak perlu."  Saya diberitahu bahwa menggunakan pendekatan ini hanya masuk akal untuk beberapa situs. <br><br>  Saya lebih suka, ketika datang ke pemisahan kode, untuk menggunakan aturan 20/20 yang baru saja saya rumuskan.  Jika ada beberapa bagian dari situs yang dikunjungi oleh hanya 20% pengguna, dan fungsinya disediakan oleh lebih dari 20% dari kode JavaScript situs, maka kode ini perlu diunduh hanya atas permintaan. <br><br>  Ini, tentu saja, bukan angka absolut, mereka dapat disesuaikan dengan situasi tertentu, dan pada kenyataannya ada skenario yang jauh lebih kompleks daripada yang dijelaskan di atas.  Yang paling penting di sini adalah keseimbangan, dan sangat normal untuk tidak menggunakan pemisahan kode sama sekali, jika ini tidak masuk akal untuk situs Anda. <br><br><h3>  <font color="#3AC1EF">▍ Pisahkan atau tidak?</font> </h3><br>  Bagaimana menemukan jawaban untuk pertanyaan apakah Anda memerlukan pemisahan kode atau tidak?  Misalkan Anda memiliki toko online, dan Anda berpikir untuk memisahkan dari sisa kode, kode yang digunakan untuk menerima pembayaran dari pelanggan, karena hanya 30% pengunjung yang membeli sesuatu dari Anda. <br><br>  Apa yang bisa saya katakan?  Pertama, Anda harus berupaya mengisi toko dan menjual sesuatu yang akan menarik lebih banyak pengunjung ke situs.  Kedua, Anda perlu memahami berapa banyak kode yang benar-benar unik untuk bagian situs tempat pembayaran diterima.  Karena Anda harus selalu melakukan "bundle splitting" sebelum "code splitting", dan semoga Anda melakukannya, Anda mungkin sudah tahu ukuran kode apa yang kami minati. <br><br>  Mungkin kode ini ternyata lebih kecil dari yang Anda pikirkan, jadi sebelum Anda bersukacita pada kesempatan baru untuk mengoptimalkan situs Anda, Anda harus menghitung semuanya dengan aman.  Jika Anda, misalnya, memiliki situs Bereaksi, maka repositori, reduksi, sistem perutean, tindakan akan dibagikan oleh semua bagian situs.  Unik untuk berbagai bagian kode situs akan diwakili terutama oleh komponen dan fungsi tambahan untuk mereka. <br><br>  Jadi, Anda mengetahui bahwa kode yang benar-benar unik dari bagian situs yang digunakan untuk membayar pembelian membutuhkan 7 Kb.  Ukuran kode situs lainnya adalah 300 Kb.  Dalam situasi seperti itu, saya tidak akan melakukan pemisahan kode karena beberapa alasan: <br><br><ul><li>  Jika Anda mengunduh 7 Kb ini sebelumnya, situs tidak akan melambat.  Ingat bahwa file diunduh secara paralel dan coba ukur perbedaan yang diperlukan untuk mengunduh 300 Kb dan 307 Kb kode. </li><li>  Jika Anda mengunduh kode ini nanti, maka pengguna harus menunggu setelah mengklik tombol "Bayar".  Dan inilah saat ketika Anda perlu segalanya berjalan semulus mungkin. </li><li>  Pemisahan kode memerlukan perubahan pada aplikasi.  Dalam kode, di tempat-tempat di mana semuanya dilakukan secara sinkron sebelumnya, logika asinkron muncul.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentu saja, tidak ada kesulitan kosmik dalam transformasi kode seperti itu, tetapi ini masih merupakan pekerjaan tambahan, yang menurut saya, harus dilakukan demi peningkatan nyata dalam pengalaman pengguna dengan situs. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, kami membahas alasan mengapa pemisahan kode mungkin tidak cocok untuk Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang perhatikan beberapa contoh penerapan teknologi ini.</font></font><br><br><h3> <font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OlPolyphylls</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mulai dengan contoh ini, karena apa yang akan kita lihat di sini hanya diterapkan dan berlaku untuk sebagian besar situs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menggunakan di situs saya banyak alat bermanfaat dalam bentuk polyfill. </font><font style="vertical-align: inherit;">Oleh karena itu, saya memiliki file di mana semua ini terhubung. </font><font style="vertical-align: inherit;">Ini terdiri dari delapan baris berikut:</font></font><br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'whatwg-fetch'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'intl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url-polyfill'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/web/dom-collections'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/string'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/array'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/object'</span></span>);</code> </pre> <br>         <code>index.js</code> ,      : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> render = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root')); } render(); // ,     </span></span></code> </pre> <br>    Webpack   ,        ,        npm-.     25 , 90%    ,      . <br><br>   Webpack 4    <code>import()</code> (      <code>import</code> ),      : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; const render = () =&gt; { ReactDOM.render(&lt;App /&gt;, document.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-string"><span class="hljs-string">'fetch'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Intl'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'URL'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Map'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'forEach'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> NodeList.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'startsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'endsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'assign'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'entries'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'keys'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> ) { render(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(render); }</code> </pre> <br>  ,  ,   ,  —     .   —        <code>render()</code> .      ,  Webpack     npm-,       ,    <code>render()</code>   . <br><br>  ,   <code>import()</code>    Babel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dynamic-import</a> .  ,      Webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">import()</a>  ,           . <br><br>    ,   .    . <br><br><h3> <font color="#3AC1EF">▍    React,   </font> </h3><br>     . ,          ,      ,    . <br><br>       ,     npm-    .        ,   ,      100 . <br><br>       , ,    URL <code>/admin</code> ,  <code>&lt;AdminPage&gt;</code> . Webpack    ,      <code>import AdminPage from './AdminPage.js'</code>       . <br><br>     .           ,   ,  <code>import('./AdminPage.js')</code> ,   Webpack    ,      . <br><br> ,      . <br><br> ,  ,    <code>AdminPage</code> ,     ,        URL <code>/admin</code> . ,    : <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdminPageLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ constructor(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {     <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,   } } componentDidMount() {   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>('./<span class="hljs-type"><span class="hljs-type">AdminPage</span></span>').then(module =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: module.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> });   }); } render() {   const { <span class="hljs-type"><span class="hljs-type">AdminPage</span></span> } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>     ? &lt;<span class="hljs-type"><span class="hljs-type">AdminPage</span></span> {...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props} /&gt;     : &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Loading</span></span>...&lt;/div&gt;; } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-type"><span class="hljs-type">AdminPageLoader</span></span>;</code> </pre> <br>        .     (,     URL <code>/admin</code> ),    <code>./AdminPage.js</code> ,          . <br><br>   <code>render()</code>   ,   <code>&lt;AdminPage&gt;</code> ,  <code>&lt;div&gt;Loading...&lt;/div&gt;</code> ,   <code>&lt;AdminPage&gt;</code>  ,         . <br><br>        ,       <code>react-loadable</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> React   . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br> ,   ,   (,  ,      CSS).   : <br><br><ul><li>          —      . </li><li>       ,      —    . </li></ul><br>  <b>Pembaca yang budiman!</b>           ? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423483/">https://habr.com/ru/post/id423483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423469/index.html">Nomor floating point liar barat tercepat</a></li>
<li><a href="../id423475/index.html">Meretas kode penuaan: ilmu baru tentang penuaan dan apa artinya tetap muda</a></li>
<li><a href="../id423477/index.html">Jadilah seorang ninja keamanan: mulai jalan Anda ke ketinggian IB</a></li>
<li><a href="../id423479/index.html">"Pertama": apakah akan terbang ke Mars</a></li>
<li><a href="../id423481/index.html">Saya perlu meningkatkan cluster Kubernetes, tapi saya hanya seorang programmer kode. Ada jalan keluar</a></li>
<li><a href="../id423485/index.html">Malas memuat gambar menggunakan IntersectionObserver</a></li>
<li><a href="../id423487/index.html">Node.js tanpa node_modules</a></li>
<li><a href="../id423489/index.html">Saya seorang dokter darurat dan saya ingin berbicara tentang elektrokardiogram Apple Watch yang baru</a></li>
<li><a href="../id423491/index.html">PHP Digest No. 139 (3 - 17 September 2018)</a></li>
<li><a href="../id423493/index.html">Android Go adalah miliar perangkat masa depan dan batas 50 MB. Kuliah Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>