<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨 👲 🤷🏻 ¿Es cierto que GOPATH y GOROOT ya no son necesarios? 😶 🧝🏾 🦕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dio la casualidad de que los desarrolladores que recién comienzan a familiarizarse con Go a menudo encuentran el problema de elegir un directorio de t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Es cierto que GOPATH y GOROOT ya no son necesarios?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/467697/"><p>  Dio la casualidad de que los desarrolladores que recién comienzan a familiarizarse con Go a menudo encuentran el problema de elegir un directorio de trabajo para los proyectos de Go.  Entonces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el chat de la conferencia GolangConf</a> , también se hizo esta pregunta.  Los nuevos gophers a menudo se asustan con las palabras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GOPATH y GOROOT</a> .  Sin embargo, en las guías de inicio rápido con la versión actual de Go (1.13), estas dos palabras "aterradoras" no se mencionan en absoluto. </p><a name="habracut"></a><br><p>  A ver por qué.  Para la pureza del experimento, implementé Ubuntu nuevo en una máquina virtual e instalé Go de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acuerdo con las instrucciones de Wiki</a> : </p><br><pre><code class="plaintext hljs">sudo add-apt-repository ppa:longsleep/golang-backports sudo apt-get update sudo apt-get install golang-go</code> </pre> <br><p>  Go 1.13 está instalado y listo para usar: </p><br><pre> <code class="plaintext hljs">$ go version go version go1.13 linux/amd64 $ which go /usr/bin/go $ whereis go go: /usr/bin/go /usr/lib/go /usr/share/go /usr/share/man/man1/go.1.gz</code> </pre> <br><h2 id="goroot">  GOROOT </h2><br><p>  Acerca de <code>GOROOT</code> ya se ha escrito perfectamente en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo de 2015</a> , y esta información sigue siendo relevante. </p><br><p>  Es curioso que entre la lista de directorios emitidos por el último comando ( <code>whereis go</code> ), <code>GOROOT</code> realidad no es: </p><br><pre> <code class="plaintext hljs">$ go env GOROOT /usr/lib/go-1.13</code> </pre> <br><p>  Entonces, por ejemplo, si para el IDE necesito especificar la ruta a los archivos de la biblioteca Go estándar, especificaré <code>/usr/lib/go-1.13</code> .  Quizás, en este escenario, el uso de <code>GOROOT</code> en la vida cotidiana termina. </p><br><h2 id="gopath-i-moduli">  GOPATH y módulos </h2><br><p>  Parece que en este lugar es necesario apresurarse para instalar <code>GOPATH</code> , pero no lo haré.  En realidad, <code>GOPATH</code> ya <code>GOPATH</code> configurado: </p><br><pre> <code class="plaintext hljs">$ go env GOPATH /home/elena/go</code> </pre> <br><p>  Me siento cómodo con la <code>GOPATH</code> en <code>~/go</code> , lo que significa que no la cambiaré. </p><br><p>  Inmediatamente crearé un directorio para mi primer proyecto en Go.  Esto se puede hacer en cualquier lugar, por ejemplo, directamente en su directorio de inicio.  Además, comenzaré a trabajar inmediatamente con la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go Modules</a> : </p><br><pre> <code class="plaintext hljs">$ mkdir ~/hello $ go mod init github.com/rumyantseva/hello go: creating new go.mod: module github.com/rumyantseva/hello</code> </pre> <br><p>  Para el comando <code>go mod init</code> , especifiqué una ruta de módulo de módulo única para mi proyecto.  De esta manera, un proxy u otra herramienta, si es necesario, puede encontrar los archivos de mi proyecto. </p><br><p>  Después de llamar al comando <code>go mod init</code> , el directorio <code>go mod init</code> apareció en mi directorio de inicio: </p><br><pre> <code class="plaintext hljs">$ tree ~/go /home/elena/go └── pkg └── mod └── cache └── lock 3 directories, 1 file</code> </pre> <br><p>  En este caso, el archivo de bloqueo (en la parte inferior del árbol) todavía está vacío. </p><br><p>  El archivo <code>go.mod</code> apareció en el <code>go.mod</code> <code>~/hello</code> con los siguientes contenidos: </p><br><pre> <code class="plaintext hljs">module github.com/rumyantseva/hello go 1.13</code> </pre> <br><p>  Es en <code>go.mod</code> que toda la información sobre las dependencias de mi módulo se almacenará posteriormente. </p><br><p>  Ahora escribamos una aplicación usando una dependencia externa.  En el directorio <code>~/hello</code> , creo el archivo <code>main.go</code> y escribo el siguiente código: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/sirupsen/logrus"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { logrus.Info(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>) }</code> </pre> <br><p>  Por supuesto en la vida real por escribir "¡Hola, mundo!"  Puede prescindir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">logrus</a> , pero en este ejemplo, esta biblioteca nos ayudará a descubrir dónde se almacenan los archivos de dependencias externas. </p><br><p>  Lanzo la aplicación de la manera más simple: </p><br><pre> <code class="plaintext hljs">$ go run main.go go: finding github.com/sirupsen/logrus v1.4.2 go: downloading github.com/sirupsen/logrus v1.4.2 go: extracting github.com/sirupsen/logrus v1.4.2 go: downloading golang.org/x/sys v0.0.0-20190422165155-953cdadca894 go: extracting golang.org/x/sys v0.0.0-20190422165155-953cdadca894 go: finding golang.org/x/sys v0.0.0-20190422165155-953cdadca894 INFO[0000] Hello, world!</code> </pre> <br><p>  Antes de que la aplicación fuera construida y lanzada, la herramienta <code>go mod</code> funcionaba.  Definió mi dependencia externa <code>github.com/sirupsen/logrus</code> , tomó su última versión <code>v1.4.2</code> y <code>v1.4.2</code> por dependencias transitivas. </p><br><p>  Se agregó una línea al archivo <code>go.mod</code> con una descripción de la dependencia de <code>logrus</code> : </p><br><pre> <code class="plaintext hljs">module github.com/rumyantseva/hello go 1.13 require github.com/sirupsen/logrus v1.4.2 // indirect</code> </pre> <br><p>  También apareció el archivo <code>go.sum</code> , en el que, además del hash de la dependencia <code>logrus</code> , se almacena información sobre hash de dependencias transitivas: </p><br><pre> <code class="plaintext hljs">github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38= github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ= github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4= github.com/sirupsen/logrus v1.4.2 h1:SPIRibHv4MatM3XXNO2BJeFLZwZ2LvZgfQ5+UNI2im4= github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE= github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME= github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs= golang.org/x/sys v0.0.0-20190422165155-953cdadca894 h1:Cz4ceDQGXuKRnVBDTS23GTn/pU5OE2C0WrNTOYK1Uuc= golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=</code> </pre> <br><p>  ¿Dónde está el código de dependencia en sí?  Se puede encontrar en <code>~/go/pkg/mod</code> .  Además, las sumas de verificación y otra información general para trabajar con dependencias se almacenarán en <code>~/go/pkg</code> . </p><br><p>  Si ya ha encontrado la herramienta <code>go get</code> , sabe que al extraer dependencias, en realidad clona los repositorios (por ejemplo, en el caso de git con <code>git clone</code> ).  Pero <code>go mod</code> no funciona de esa manera.  Para <code>go mod</code> unidad principal de código es el módulo.  Los módulos son archivos.  Cuando se trabaja con dependencias <code>go mod</code> , explícitamente (si invocó el comando <code>go mod download</code> ) o implícitamente (si comenzó a compilar la aplicación) descarga y desempaqueta archivos a través de <code>GOPROXY</code> .  Veamos cómo se establece el proxy en Go 1.13 de manera predeterminada: </p><br><pre> <code class="plaintext hljs">$ go env GOPROXY https://proxy.golang.org,direct</code> </pre> <br><p>  Entonces, como proxy cuando construyo mi "¡Hola, Mundo!"  utilizado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proxy.golang.org</a> .  Por supuesto, esta variable se puede cambiar eligiendo un repositorio diferente de módulos.  Por ejemplo, puede implementar su propia compañía de proxy interna, que se almacenará, incluidas las bibliotecas internas, cuyo código no se publicó en código abierto. </p><br><p>  En general, si estoy comenzando un nuevo proyecto y no me importa usar Go Modules, es posible que no sepa nada sobre <code>GOPATH</code> .  Go creará el directorio <code>~/go</code> por sí solo cuando sea necesario. </p><br><h2 id="kogda-nuzhen-gopath">  ¿Cuándo se necesita GOPATH? </h2><br><p>  Si básicamente no utiliza los módulos Go (por ejemplo, en un proyecto heredado), alejarse del trabajo más explícito con <code>GOPATH</code> puede no ser tan simple. </p><br><p>  Para ver qué sucederá con mi proyecto, si decido no usar <code>go mod</code> , elimine los archivos <code>~/hello/go.mod</code> y <code>~/hello/go.sum</code> .  También eliminaré <code>~/go</code> para volver al estado del sistema que tenía al principio: </p><br><pre> <code class="plaintext hljs">rm -rf ~/go ~/hello/go.mod ~/hello/go.sum</code> </pre> <br><p>  Solo el archivo <code>main.go</code> permanece en el <code>main.go</code> <code>~/hello</code> .  ¿Qué sucede ahora si trato de ejecutarlo con <code>go run</code> ? </p><br><pre> <code class="plaintext hljs">$ go run main.go main.go:4:2: cannot find package "github.com/sirupsen/logrus" in any of: /usr/lib/go-1.13/src/github.com/sirupsen/logrus (from $GOROOT) /home/elena/go/src/github.com/sirupsen/logrus (from $GOPATH)</code> </pre> <br><p>  Aquí están, estos terroríficos <code>GOROOT</code> y <code>GOPATH</code> :) </p><br><p>  Para compilar la aplicación, necesito extraer la dependencia en <code>GOPATH</code> .  Hago esto con el buen viejo <code>go get</code> : </p><br><pre> <code class="plaintext hljs">$ go get -v github.com/sirupsen/logrus github.com/sirupsen/logrus (download) created GOPATH=/home/elena/go; see 'go help gopath' get "golang.org/x/sys/unix": found meta tag get.metaImport{Prefix:"golang.org/x/sys", VCS:"git", RepoRoot:"https://go.googlesource.com/sys"} at //golang.org/x/sys/unix?go-get=1 get "golang.org/x/sys/unix": verifying non-authoritative meta tag golang.org/x/sys (download) golang.org/x/sys/unix github.com/sirupsen/logrus</code> </pre> <br><p>  Que paso  En primer lugar, <code>go get</code> crear el directorio <code>~/go</code> (el especificado como <code>GOPATH</code> ).  Entonces comenzó el proceso de clonación de los repositorios con dependencias.  Es curioso que los repositorios de clonación parezcan notablemente más lentos que la opción cuando usamos <code>go mod</code> para descargar y descomprimir módulos.  Sin embargo, el código de dependencia ahora se puede encontrar dentro de <code>~/go/src/</code> . </p><br><p>  Por cierto, todavía no había un cliente git en mi instalación limpia de Ubuntu, y para <code>go get</code> trabajar, tuve que instalarlo. </p><br><p>  Lanzo la aplicación: </p><br><pre> <code class="plaintext hljs">$ go run main.go INFO[0000] Hello, world!</code> </pre> <br><p>  Funciona! </p><br><p>  Eso es solo en el nivel de la aplicación, ahora no hago un seguimiento de la versión de las dependencias externas.  ¿Qué <code>github.com/sirupsen/logrus</code> si, debido a una vulnerabilidad, en algún momento en el repositorio <code>github.com/sirupsen/logrus</code> no es el registrador que esperaba, sino algún código malicioso?  Tarde o temprano, todavía necesito una herramienta para trabajar con dependencias, y si Go Modules por alguna razón no encaja, debe buscar otra cosa ... </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Este artículo no abordó algunos puntos específicos, y trabajar con dependencias externas en Go todavía puede causar muchas preguntas.  Sin embargo, las nuevas versiones de Go al menos no imponen restricciones sobre dónde se pueden crear los directorios de trabajo de sus proyectos. </p><br><p>  Si está comenzando un nuevo proyecto, pruebe Go Modules!  Volver al viejo enfoque para trabajar con dependencias solo tiene sentido si algo sale mal.  Por cierto, si prefiere almacenar todas las dependencias dentro del proyecto, Go Modules admite el modo de proveedor. </p><br><p>  Si necesita trabajar con un proyecto existente y, por alguna razón, no desea traducirlo a Go Modules, es importante indicar en la documentación del proyecto las características de su implementación y administración de dependencias.  Si los recién llegados que no están familiarizados con los viejos enfoques para trabajar con dependencias llegan al proyecto, será mucho más fácil para ellos lidiar con el proyecto si toda la documentación está en su lugar. </p><br><p>  Por cierto, el 7 de octubre en la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GolangConf</a> , como una de las actividades especiales, estamos planeando una zona de expertos donde cualquiera puede hacer cualquier pregunta sobre Ir a los miembros del comité del programa de la conferencia y los entusiastas de la comunidad rusa de Go.  Instalar Ir?  Lidiar con las adicciones?  ¿Escribir un microservicio?  Esto es para nosotros! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467697/">https://habr.com/ru/post/467697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467681/index.html">Vulnerabilidad de desvíos de enrutamiento SOAP</a></li>
<li><a href="../467683/index.html">Tratando de componer lo no composable: esquemas de acoplamiento</a></li>
<li><a href="../467689/index.html">Una pequeña descripción de SIMD en .NET / C #</a></li>
<li><a href="../467691/index.html">Intel Nervana NNP-T y NNP-I: chips especializados para IA</a></li>
<li><a href="../467693/index.html">Resumen de eventos de TI de septiembre (segunda parte)</a></li>
<li><a href="../467699/index.html">Cómo no hacer el más rápido y encontrar un defecto en la comunidad de Visual Studio 2019</a></li>
<li><a href="../467701/index.html">Categorías en lugar de directorios. Una herramienta para el almacenamiento conveniente de archivos</a></li>
<li><a href="../467703/index.html">IT África: las empresas y startups tecnológicas más interesantes del continente</a></li>
<li><a href="../467705/index.html">Paramagnones y magnones: energía del calor.</a></li>
<li><a href="../467707/index.html">Cómo configurar Linux para ingresar al dominio usando algoritmos GOST</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>