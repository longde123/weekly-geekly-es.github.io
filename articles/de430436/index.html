<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÄ üïµüèø ‚åöÔ∏è Auf dem Weg zu QUIC: Was liegt unter HTTP / 3? üò• ü§í üëàüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor unseren Augen beginnt ein neuer Meilenstein in der Internetgeschichte: Wir k√∂nnen davon ausgehen, dass HTTP / 3 bereits angek√ºndigt wurde. Ende Ok...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auf dem Weg zu QUIC: Was liegt unter HTTP / 3?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/430436/"> Vor unseren Augen beginnt ein neuer Meilenstein in der Internetgeschichte: Wir k√∂nnen davon ausgehen, dass HTTP / 3 bereits angek√ºndigt wurde.  Ende Oktober schlug Mark Nottingham von der IETF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor, bereits einen Namen</a> f√ºr das neue Protokoll festzulegen, √ºber das die IETF seit 2015 baut.  Anstelle von QUIC-√§hnlichen Namen erschien also lautes HTTP / 3.  Westliche Publikationen haben bereits und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.zdnet.com/article/http-over-quic-to-be-renamed-">mehr als einmal dar√ºber geschrieben</a> .  Die Geschichte von QUIC begann 2012 im Herzen der Good Corporation. Seitdem unterst√ºtzten nur die Server von Google HTTP-over-QUIC-Verbindungen. Die Zeit vergeht jedoch und Facebook hat bereits begonnen, diese Technologie zu implementieren (7. November, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Facebook</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LiteSpeed</a> haben die erste Interaktion √ºber HTTP / 3 durchgef√ºhrt );  Derzeit betr√§gt der Anteil der Websites, die QUIC unterst√ºtzen, 1,2%.  Schlie√ülich befasst sich die WebRTC-Arbeitsgruppe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch mit QUIC</a> (siehe auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QUIC-API</a> ), sodass in absehbarer Zukunft Echtzeit-Video / Audio √ºber QUIC anstelle von RTP / RTCP √ºbertragen wird.  Aus diesem Grund haben wir beschlossen, dass es gro√üartig w√§re, die Details des IETF QUIC zu enth√ºllen: Speziell f√ºr Habr haben wir eine √úbersetzung des Longread Dotting i vorbereitet.  Viel Spa√ü! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r4/ee/3s/r4ee3svcbqzrlxwfzuajri7go04.png"></div><a name="habracut"></a><br>  QUIC (Quick UDP Internet Connections) ist ein neues, verschl√ºsseltes Standardprotokoll f√ºr die Transportschicht, das viele HTTP-Verbesserungen aufweist: sowohl zur Beschleunigung des Datenverkehrs als auch zur Erh√∂hung der Sicherheit.  QUIC hat auch ein langfristiges Ziel - TCP und TLS zu ersetzen.  In diesem Artikel werden sowohl die wichtigsten QUIC-Chips als auch die Gr√ºnde, warum das Web davon profitieren wird, sowie die Probleme bei der Unterst√ºtzung dieses v√∂llig neuen Protokolls untersucht. <br><br>  Tats√§chlich gibt es zwei Protokolle mit demselben Namen: Google QUIC (gQUIC), das urspr√ºngliche Protokoll, das vor einigen Jahren von Google-Ingenieuren entwickelt wurde und nach einer Reihe von Experimenten von der Internet Engineering Task Force (IETF) zur Standardisierung √ºbernommen wurde. <br><br>  IETF QUIC (im Folgenden einfach QUIC) weist bereits so starke Unterschiede zu gQUIC auf, dass es als separates Protokoll betrachtet werden kann.  Vom Paketformat √ºber Handshake bis hin zur HTTP-Zuordnung hat QUIC die urspr√ºngliche gQUIC-Architektur durch die Zusammenarbeit mit vielen Organisationen und Entwicklern verbessert, die ein gemeinsames Ziel verfolgen: das Internet schneller und sicherer zu machen. <br><br>  Welche Verbesserungen bietet QUIC? <br><br><h2>  Integrierte Sicherheit (und Leistung) </h2><br>  Einer der auff√§lligsten Unterschiede zwischen QUIC und ehrw√ºrdigem TCP ist das urspr√ºnglich festgelegte Ziel, ein <b>standardm√§√üig sicheres</b> Transportprotokoll zu sein.  QUIC erreicht dies durch die Verwendung von Authentifizierung und Verschl√ºsselung, die normalerweise auf einer h√∂heren Ebene (z. B. in TLS) und nicht im Transportprotokoll selbst erfolgt. <br><br>  Der urspr√ºngliche QUIC-Handshake kombiniert die √ºbliche Drei-Wege-Kommunikation √ºber TCP mit dem TLS 1.3-Handshake, der die Authentifizierung der Teilnehmer sowie die Koordination der kryptografischen Parameter erm√∂glicht.  F√ºr diejenigen, die mit TLS vertraut sind: QUIC ersetzt die TLS-Aufnahmeebene durch ein eigenes Frame-Format, verwendet jedoch gleichzeitig TLS-Handshakes. <br><br>  Dies erm√∂glicht nicht nur, dass die Verbindung immer verschl√ºsselt und authentifiziert wird, sondern auch schneller, um die anf√§ngliche Verbindung herzustellen: Ein gew√∂hnlicher QUIC-Handshake f√ºhrt den Austausch zwischen Client und Server in einem Durchgang durch, w√§hrend TCP + TLS 1.3 zwei Durchg√§nge durchf√ºhrt. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h2/lq/o4/h2lqo4o2itthtb_h7qopgt7kbc4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/ne/vg/g6nevg964eqgvmzillfvnet3lus.png"></div><br>  QUIC geht jedoch noch weiter und verschl√ºsselt auch Verbindungsmetadaten, die von Dritten leicht kompromittiert werden k√∂nnen.  Beispielsweise k√∂nnen Angreifer Paketnummern verwenden, um Benutzer √ºber mehrere Netzwerkpfade zu leiten, wenn die Verbindungsmigration verwendet wird (siehe unten).  QUIC verschl√ºsselt Paketnummern, sodass sie nur von den tats√§chlichen Teilnehmern der Verbindung korrigiert werden k√∂nnen. <br><br>  Die Verschl√ºsselung kann auch gegen ‚ÄûStagnation‚Äú wirksam sein - ein Ph√§nomen, bei dem die Flexibilit√§t des Protokolls aufgrund falscher Annahmen in Implementierungen (Ossifikation - in der Praxis nicht genutzt werden kann). Aus diesem Grund wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS 1.3 lange Zeit entwickelt</a> . Wir haben es erst nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einigen √Ñnderungen ver√∂ffentlicht</a> unerw√ºnschte Blockierungen f√ºr neue TLS-Revisionen verhindern). <br><br><h2>  Blockieren des Warteschlangenanfangs (Head-of-Line-Blockieren) </h2><br>  Eine der wichtigsten Verbesserungen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.cloudflare.com/introducing-">HTTP / 2</a> uns gebracht hat, ist die M√∂glichkeit, verschiedene HTTP-Anforderungen in einer TCP-Verbindung zu kombinieren.  Dadurch k√∂nnen HTTP / 2-Anwendungen Anforderungen parallel verarbeiten und den Netzwerkkanal besser nutzen. <br><br>  Dies war nat√ºrlich ein bedeutender Schritt nach vorne.  Weil fr√ºhere Anwendungen viele TCP + TLS-Verbindungen initiieren mussten, wenn sie mehrere HTTP-Anforderungen gleichzeitig verarbeiten wollten (z. B. wenn der Browser sowohl CSS als auch JavaScript zum Rendern der Seite empfangen muss).  Das Erstellen neuer Verbindungen erfordert mehrere Handshakes sowie das Initialisieren des √úberlastungsfensters. Dies bedeutet, dass das Rendern der Seite verlangsamt wird.  Kombinierte HTTP-Anforderungen vermeiden dies. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lj/rc/lb/ljrclbypotymwhoajopsze57jry.jpeg"></div><br><br>  Es gibt jedoch einen Nachteil: Da mehrere Anforderungen / Antworten √ºber dieselbe TCP-Verbindung √ºbertragen werden, sind sie alle gleicherma√üen vom Paketverlust abh√§ngig, selbst wenn die verlorenen Daten nur eine der Anforderungen betreffen.  Dies wird als "Blockieren des Beginns der Warteschlange" bezeichnet. <br><br>  QUIC geht tiefer und bietet erstklassige Unterst√ºtzung f√ºr das Kombinieren von Anforderungen. Beispielsweise k√∂nnen verschiedene HTTP-Anforderungen als unterschiedliche Transport-QUIC-Anforderungen angesehen werden. Gleichzeitig verwenden sie jedoch alle dieselbe QUIC-Verbindung. Das hei√üt, zus√§tzliche Handshakes sind nicht erforderlich, es gibt eine √úberlastungsstatus: QUIC-Anforderungen werden unabh√§ngig zugestellt. In den meisten F√§llen betrifft der Paketverlust daher nur eine Anforderung. <br><br>  So ist es m√∂glich, die Zeit beispielsweise f√ºr das vollst√§ndige Rendern einer Webseite (CSS, JavaScript, Bilder und andere Ressourcen) erheblich zu verk√ºrzen, insbesondere bei einem √ºberlasteten Netzwerk mit hohem Paketverlust. <br><br><h2>  So einfach, oder? </h2><br>  Um sein Versprechen zu erf√ºllen, muss das QUIC-Protokoll einige der Annahmen √ºberwinden, die viele Netzwerkanwendungen f√ºr selbstverst√§ndlich gehalten haben.  Dies kann die Implementierung und Implementierung von QUIC erschweren. <br><br>  QUIC kann √ºber UDP-Datagramme bereitgestellt werden, um die Entwicklung zu erleichtern und Probleme mit Netzwerkger√§ten zu vermeiden, die Pakete unbekannter Protokolle verwerfen (da die meisten Ger√§te UDP unterst√ºtzen).  Au√üerdem kann QUIC im Benutzerbereich leben, sodass Browser beispielsweise neue Protokollfunktionen implementieren und an Endbenutzer weitergeben k√∂nnen, ohne auf Betriebssystemaktualisierungen warten zu m√ºssen. <br><br>  Das gute Ziel, Netzwerkprobleme zu reduzieren, macht es jedoch schwieriger, Pakete zu sch√ºtzen und ordnungsgem√§√ü weiterzuleiten. <br><br><h2>  Ein NAT, um alle zusammen zu kommen und sich mit einem einzigen schwarzen Willen zu vereinen </h2><br>  In der Regel arbeiten NAT-Router mit TCP-Verbindungen, indem sie ein Tupel von 4 Werten (Quell-IP und -Port plus IP- und Zielport) verwenden und √ºber das Netzwerk √ºbertragene TCP-SYN-, ACK- und FIN-Pakete √ºberwachen.  Router k√∂nnen bestimmen, wann eine neue Verbindung hergestellt und wann sie beendet wird.  Daher ist eine pr√§zise Verwaltung von NAT-Bindungen (Kommunikation zwischen internen und externen IP-Adressen und Ports) m√∂glich. <br><br>  Bei QUIC ist dies noch nicht m√∂glich, weil  Moderne NAT-Router kennen QUIC noch nicht, daher werden sie normalerweise auf die standardm√§√üige und weniger genaue UDP-Verarbeitung heruntergestuft. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies</a> bedeutet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeit√ºberschreitungen von beliebiger (manchmal kurzer) Dauer</a> , die sich auf langfristige Verbindungen auswirken k√∂nnen. <br><br>  Wenn eine erneute Bindung auftritt (z. B. aufgrund eines Timeouts), beginnt das Ger√§t au√üerhalb des NAT-Perimeters mit dem Empfang von Paketen von einer anderen Quelle, wodurch es unm√∂glich wird, die Verbindung nur mit einem Tupel von 4 Werten aufrechtzuerhalten. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xg/ze/kz/xgzekzn8kq0nhe9--wkbotrxxmq.png"></div><br><br>  Und es ist nicht nur NAT!  Eine QUIC-Funktion wird als Verbindungsmigration bezeichnet und erm√∂glicht es Ger√§ten, nach eigenem Ermessen Verbindungen zu anderen IP-Adressen / Pfaden zu √ºbertragen.  Beispielsweise kann ein mobiler Client eine QUIC-Verbindung von einem Mobilfunknetz zu einem bereits bekannten WiFi-Netzwerk √ºbertragen (der Benutzer hat ein Lieblingscaf√© betreten usw.). <br><br>  QUIC versucht, dieses Problem mit dem Konzept der Verbindungs-ID zu l√∂sen: Eine Information beliebiger L√§nge, die in QUIC-Paketen √ºbertragen wird und die Identifizierung der Verbindung erm√∂glicht.  Endpoint-Ger√§te k√∂nnen diese ID verwenden, um ihre Verbindungen zu verfolgen, ohne sich mit dem Tupel abzustimmen.  In der Praxis sollten viele IDs vorhanden sein, die dieselbe Verbindung angeben, um beispielsweise zu vermeiden, dass bei der Migration der Verbindung unterschiedliche Pfade verbunden werden, da der gesamte Prozess nur von den Endger√§ten und nicht von den Middleboxen gesteuert wird. <br><br>  Es kann jedoch ein Problem f√ºr Telekommunikationsbetreiber geben, die Anycast- und ECMP-Routing verwenden, bei dem eine IP m√∂glicherweise Hunderte oder Tausende von Servern identifizieren kann.  Da die Grenzrouter in diesen Netzwerken noch nicht wissen, wie sie mit QUIC-Verkehr umgehen sollen, kann es vorkommen, dass UDP-Pakete von derselben QUIC-Verbindung, jedoch mit unterschiedlichen Tupeln, an unterschiedliche Server gesendet werden, was eine Trennung bedeutet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d4/vq/us/d4vqusefrkw1ideoglo-_heq8py.png"></div><br><br>  Um dies zu vermeiden, m√ºssen Bediener m√∂glicherweise einen intelligenteren Level-Balancer implementieren.  Dies kann programmgesteuert erreicht werden, ohne die Grenzrouter selbst zu beeintr√§chtigen (siehe beispielsweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Katran-</a> Projekt von Facebook). <br><br><h2>  Qpack </h2><br>  Eine weitere n√ºtzliche Funktion von HTTP / 2 war die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.cloudflare.com/hpack-the-silent-killer-feature-of-">Header-Komprimierung (HPACK)</a> , mit der Endger√§te die Gr√∂√üe der gesendeten Daten reduzieren k√∂nnen, indem unn√∂tige Anforderungen und Antworten verworfen werden. <br><br>  Insbesondere verwendet HPACK unter anderem dynamische Tabellen mit Headern, die bereits von fr√ºheren HTTP-Anforderungen / -Antworten gesendet / empfangen wurden, sodass Ger√§te neue Anforderungen / Antworten auf zuvor angetroffene Header verweisen k√∂nnen (anstatt sie erneut zu senden). . <br><br>  HPACK-Tabellen m√ºssen zwischen dem Codierer (der Partei, die die Anforderung / Antwort sendet) und dem Decodierer (der empfangenden Seite) synchronisiert werden, andernfalls kann der Decodierer einfach nicht dekodieren, was er empf√§ngt. <br><br>  Bei HTTP / 2 √ºber TCP ist diese Synchronisation transparent, da die Transportschicht (TCP) Anforderungen / Antworten in derselben Reihenfolge liefert, in der sie gesendet wurden.  Das hei√üt, Sie k√∂nnen Anweisungen an den Decoder senden, um die Tabellen in einer einfachen Anforderung / Antwort zu aktualisieren.  Aber mit QUIC sind die Dinge viel komplizierter. <br><br>  QUIC kann mehrere HTTP-Anfragen / -Antworten gleichzeitig in verschiedene Richtungen liefern, was bedeutet, dass QUIC den Lieferauftrag in eine Richtung garantiert, w√§hrend es bei mehreren Richtungen keine solche Garantie gibt. <br><br>  Wenn ein Client beispielsweise eine HTTP-Anforderung A in QUIC-Stream A sowie eine Anforderung B in Stream B sendet, empf√§ngt der Server aufgrund von Paketpermutation oder Netzwerkverlusten Anforderung B vor Anforderung A. Und wenn Anforderung B als codiert wurde wurde im Header von Anfrage A angegeben, dann kann der Server Anfrage B einfach nicht dekodieren, da er Anfrage A noch nicht gesehen hat. <br><br>  Das gQUIC-Protokoll l√∂ste dieses Problem, indem einfach alle Header (aber nicht die K√∂rper) der HTTP-Anforderungen / -Antworten innerhalb eines einzelnen gQUIC-Streams <b>sequentiell</b> gemacht wurden.  Dadurch wurde sichergestellt, dass alle Header in der richtigen Reihenfolge angezeigt werden, unabh√§ngig davon, was passiert.  Dies ist ein sehr einfaches Schema. Mit seiner Hilfe k√∂nnen vorhandene L√∂sungen weiterhin Code verwenden, der unter HTTP / 2 gesch√§rft wurde.  Dies erh√∂ht andererseits die Wahrscheinlichkeit, den Beginn der Warteschlange zu blockieren, was durch QUIC verringert werden soll.  Daher entwickelte die IETF QUIC-Arbeitsgruppe eine neue Zuordnung zwischen HTTP und QUIC (HTTP / QUIC) sowie ein neues Prinzip der Header-Komprimierung, QPACK. <br><br>  Im endg√ºltigen Entwurf der HTTP / QUIC- und QPACK-Spezifikationen verwendet jeder HTTP-Anforderungs- / Antwortaustausch seinen eigenen bidirektionalen QUIC-Fluss, sodass der Start der Warteschlange nicht blockiert wird.  Um QPACK zu unterst√ºtzen, erstellt jeder Teilnehmer zwei zus√§tzliche, unidirektionale QUIC-Streams, von denen einer Tabellenaktualisierungen sendet und der andere den Empfang best√§tigt.  Somit kann der QPACK-Codierer die Verkn√ºpfung zur dynamischen Tabelle erst verwenden, nachdem der Decodierer seinen Empfang best√§tigt hat. <br><br><h2>  Reflexion brechen </h2><br>  Ein h√§ufiges Problem bei UDP-basierten Protokollen ist ihre Anf√§lligkeit f√ºr Reflexionsangriffe, wenn der Angreifer einen Server zwingt, eine gro√üe Datenmenge an das Opfer zu senden.  Der Angreifer f√§lscht seine IP, sodass der Server denkt, dass die Datenanforderung von der Adresse des Opfers stammt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/ee/ov/4eeeovjfl-9or5j0uq-9he0btrg.png"></div><br>  Diese Art von Angriff kann sehr effektiv sein, wenn die Serverantwort unvergleichlich gr√∂√üer als die Anforderung ist.  In diesem Fall sprechen sie von "Gewinn". <br><br>  TCP wird normalerweise nicht f√ºr solche Angriffe verwendet, da die Pakete im urspr√ºnglichen Handshake (SYN, SYN + ACK, ...) dieselbe L√§nge haben und daher kein Potenzial f√ºr eine "Verst√§rkung" haben. <br><br>  Andererseits ist der QUIC-Handshake sehr asymmetrisch: Wie bei TLS sendet der QUIC-Server zun√§chst seine Zertifikatkette, die sehr gro√ü sein kann, obwohl der Client nur wenige Bytes senden sollte (eine Nachricht vom ClientHello-TLS-Client ist in das QUIC-Paket integriert )  Aus diesem Grund muss das urspr√ºngliche QUIC-Paket auf eine bestimmte Mindestl√§nge erh√∂ht werden, auch wenn der Inhalt des Pakets viel kleiner ist.  Wie dem auch sei, diese Ma√ünahme ist immer noch nicht sehr effektiv, da eine typische Serverantwort mehrere Pakete enth√§lt und daher mehr als ein erweitertes Client-Paket sein kann. <br><br>  Das QUIC-Protokoll definiert auch einen expliziten Quellverifizierungsmechanismus: Anstatt eine gro√üe Antwort zu geben, sendet der Server nur ein Wiederholungspaket mit einem eindeutigen Token, das der Client dann in einem neuen Paket an den Server sendet.  Der Server hat also mehr Vertrauen, dass der Client keine Ersatz-IP-Adresse hat und Sie den Handshake beenden k√∂nnen.  Abz√ºglich der Entscheidung - die Zeit des Handshakes erh√∂ht sich, statt eines Durchgangs sind bereits zwei erforderlich. <br><br>  Eine alternative L√∂sung besteht darin, die Serverantwort auf eine Gr√∂√üe zu reduzieren, bei der der Reflexionsangriff weniger effektiv ist - beispielsweise mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ECDSA-Zertifikaten</a> (normalerweise sind sie viel kleiner als RSA).  Wir haben auch mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS-Zertifikat-Komprimierungsmechanismus</a> experimentiert, der handels√ºbliche Komprimierungsalgorithmen wie zlib und brotli verwendet.  Dies ist eine Funktion, die zuerst in gQUIC angezeigt wurde, derzeit jedoch in TLS nicht unterst√ºtzt wird. <br><br><h2>  UDP-Leistung </h2><br>  Eines der st√§ndigen Probleme von QUIC ist die vorhandene Hardware und Software, die nicht mit QUIC arbeiten kann.  Wir haben bereits untersucht, wie QUIC versucht, mit Netzwerk-Middleboxen wie Routern umzugehen. Ein weiterer potenziell problematischer Bereich ist die Leistung beim Senden / Empfangen von Daten zwischen QUIC-Ger√§ten √ºber UDP.  Seit vielen Jahren werden Anstrengungen unternommen, um TCP-Implementierungen so weit wie m√∂glich zu optimieren, einschlie√ülich integrierter Offload-Funktionen in Software (z. B. Betriebssystemen) und Hardware (Netzwerkschnittstellen), aber nichts davon betrifft UDP. <br><br>  Es ist jedoch nur eine Frage der Zeit, bis QUIC-Implementierungen diese Verbesserungen und Vorteile √ºbertreffen.  Werfen Sie einen Blick auf die j√ºngsten Bem√ºhungen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UDP-Offloading unter Linux</a> zu implementieren, mit dem Anwendungen mehrere UDP-Segmente zwischen dem User-Space- und dem Kernel-Space-Netzwerkstapel kombinieren und √ºbertragen k√∂nnen, und zwar auf Kosten von etwa einem Segment.  Ein weiteres Beispiel ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullkopie-</a> Unterst√ºtzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr Sockets unter Linux</a> , dank derer Anwendungen die Kosten f√ºr das Kopieren von User-Space-Speicher in den Kernel-Space vermeiden k√∂nnten. <br><br><h2>  Fazit </h2><br>  Wie HTTP / 2 und TLS 1.3 sollte das QUIC-Protokoll eine Menge neuer Funktionen bieten, die die Leistung und Sicherheit sowohl von Websites als auch von anderen Teilnehmern der Internetinfrastruktur verbessern.  Die IETF-Arbeitsgruppe beabsichtigt, die erste Version der QUIC-Spezifikationen bis Ende des Jahres herauszubringen. Daher ist es an der Zeit, dar√ºber nachzudenken, wie wir die Vorteile von QUIC optimal nutzen k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430436/">https://habr.com/ru/post/de430436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430426/index.html">Rebranding westlicher digitaler Produkte: Was hat sich ge√§ndert?</a></li>
<li><a href="../de430428/index.html">Die Seite "Escher II" in der Nominierung "People's Internet Project" Runet Prizes 2018</a></li>
<li><a href="../de430430/index.html">Fullstack - warum ist es cool oder wie man Freude an der Arbeit hat</a></li>
<li><a href="../de430432/index.html">Das modale Fenster, auf das Sie gewartet haben. Oder wie man ein Popup von verschiedenen Schaltfl√§chen auf reinem JS aufruft</a></li>
<li><a href="../de430434/index.html">Starten des Bildbetrachters unter Windows XP unter modernen Windows</a></li>
<li><a href="../de430438/index.html">Realistische Schatten f√ºr Roguelike</a></li>
<li><a href="../de430446/index.html">Noch einmal √ºber die Profis der "mobilen Sklaverei"</a></li>
<li><a href="../de430448/index.html">Was gibt maschinelles Lernen im Einzelhandel: ein Projektbeispiel</a></li>
<li><a href="../de430450/index.html">Entwicklungsmodell am Beispiel einer stapelbasierten CPU</a></li>
<li><a href="../de430452/index.html">Feuer, Wasser und feines Spray. Wie Bewohner und Besucher des Lakhta Centers vor Feuer gesch√ºtzt werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>