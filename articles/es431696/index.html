<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòé üë®üèæ‚Äçüöí üßîüèΩ Kodein Los fundamentos üëåüèº üë®üèø‚Äçüç≥ üëµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No encontr√© gu√≠as comprensibles para aquellos que Kodein por primera vez, y la documentaci√≥n no es transparente y consistente en todos los lugares, po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kodein Los fundamentos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431696/"> No encontr√© gu√≠as comprensibles para aquellos que <code>Kodein</code> por primera vez, y la documentaci√≥n no es transparente y consistente en todos los lugares, por lo que quiero compartir las caracter√≠sticas principales de la biblioteca con ustedes.  Se lanzar√°n algunas caracter√≠sticas de la biblioteca, pero esta es b√°sicamente la parte avanzada.  Aqu√≠ encontrar√° todo para comenzar normalmente y comenzar a implementar dependencias con <code>Kodein</code> medida que lee el art√≠culo.  El art√≠culo se basa en <code>Kodein 5.3.0</code> , ya que <code>Kodein 6.0.0</code> requiere <code>Support Library 28</code> o <code>AndroidX</code> y de ninguna manera todos cambiar√°n a ellos, ya que muchas bibliotecas de terceros a√∫n no ofrecen versiones compatibles. <br><img src="https://habrastorage.org/webt/uj/ve/am/ujveamkhrxko4wle8mcfugfzjvc.png"><br><a name="habracut"></a><br>  <code>Kodein</code> es una biblioteca para implementar la inyecci√≥n de dependencia (DI).  Si no est√° familiarizado con este concepto, lea el comienzo del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre Dagger2</a> , donde el autor explica brevemente los aspectos te√≥ricos de la DI. <br><br>  En este art√≠culo, consideraremos todo con el ejemplo de Android, pero, seg√∫n los desarrolladores, Kodein se comporta igual en todas las plataformas compatibles con Kotlin (JVM, Android, JS, Native). <br><br><h3>  Instalaci√≥n </h3><br>  Debido al hecho de que Java tiene <code>type erasure</code> , surge un problema: el compilador borra el tipo gen√©rico.  En el nivel de bytecode, <code>List&lt;String&gt;</code> y <code>List&lt;Date&gt;</code> son solo <code>List</code> .  A√∫n as√≠, queda una forma de obtener informaci√≥n sobre los tipos gen√©ricos, pero costar√° mucho y solo funcionar√° en JVM y Android.  En este sentido, los desarrolladores de <code>Kodein</code> sugieren usar una de dos dependencias: una recibe informaci√≥n sobre tipos generalizados ( <code>kodein-generic</code> ) mientras trabaja, y la otra no ( <code>kodein-erased</code> ).  Por ejemplo, cuando use <code>kodein-erased</code> <code>List&lt;String&gt;</code> y <code>List&lt;Date</code> &gt; se guardar√°n como <code>List&lt;*&gt;</code> , y cuando use <code>kodein-generic</code> todo se guardar√° junto con el tipo especificado, es decir, como <code>List&lt;String&gt;</code> y <code>List&lt;Date&gt;</code> respectivamente. <br><br>  ¬øC√≥mo elegir? <br><br>  <b>No</b> escriba debajo de la JVM: use <code>kodein-erased</code> , de lo contrario es imposible. <br>  Escriba debajo de la JVM y el problema de rendimiento es muy importante para usted: puede usar <code>kodein-erased</code> , pero tenga cuidado, esta experiencia puede ser inesperada en el mal sentido de estas palabras.  Si est√° creando una aplicaci√≥n regular sin requisitos especiales de rendimiento, use <code>kodein-generic</code> . <br><br>  En √∫ltima instancia, si piensa en el impacto de la DI en el rendimiento, la mayor√≠a de las dependencias se crean una vez, o las dependencias se crean para su reutilizaci√≥n repetida, es poco probable que con tales acciones pueda afectar en gran medida el rendimiento de su aplicaci√≥n. <br><br>  Entonces, instale: <br><br>  Primero, en build.gradle entre los repositorios deber√≠a estar jcenter (), si no est√° all√≠, agregue. <br><br><pre> <code class="plaintext hljs">buildscript { repositories { jcenter() } }</code> </pre><br>  A continuaci√≥n, en el bloque de dependencias, agregue una de las dependencias b√°sicas mencionadas anteriormente: <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-generic-jvm:$version"</code> </pre><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-erased-jvm:$version"</code> </pre><br>  Como estamos hablando de Android, habr√° m√°s dependencias.  Por supuesto, puede prescindir de √©l, Kodein funcionar√° normalmente, pero ¬øpor qu√© rechazar funciones adicionales √∫tiles para Android (hablar√© de ellas al final del art√≠culo)?  La elecci√≥n es suya, pero propongo agregar. <br><br>  Tambi√©n hay opciones aqu√≠. <br><br>  Primero, no est√°s usando <code>SupportLibrary</code> <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-core:$version"</code> </pre><br>  El segundo - uso <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-support:$version"</code> </pre><br>  Tercero: est√°s usando AndroidX <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-x:$version"</code> </pre><br><h3>  Empezamos a crear dependencias. </h3><br>  Con <code>Dagger2</code> , estoy acostumbrado a crear e inicializar dependencias al inicio de la aplicaci√≥n, en la clase Aplicaci√≥n. <br><br>  Con Kodein, esto se hace as√≠: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> } }</code> </pre><br>  Las declaraciones de dependencia siempre comienzan con <br><br><pre> <code class="kotlin hljs">bind&lt;TYPE&gt;() with</code> </pre><br><h4>  Etiquetas </h4><br>  El etiquetado de dependencia de Kodein es una caracter√≠stica similar en funcionalidad a <code>Qualifier</code> de <code>Dagger2</code> .  En <code>Dagger2</code> necesitas hacer un <code>Qualifier</code> separado o usar <code>@Named("someTag")</code> , que de hecho tambi√©n es <code>Qualifier</code> .  El resultado final es simple: de esta manera se distinguen dos dependencias del mismo tipo.  Por ejemplo, debe obtener el <code>ontext</code> aplicaci√≥n o una <code>Activity</code> espec√≠fica seg√∫n la situaci√≥n, por lo tanto, debe especificar etiquetas para esto al declarar dependencias.  <code>Kodein</code> permite declarar una dependencia sin una etiqueta, ser√° la base y si no especifica la etiqueta al recibir la dependencia, la obtendremos, las otras deben etiquetarse y cuando se reciba la dependencia, se deber√° especificar la etiqueta. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Context&gt;() with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"main_activity"</span></span>) with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"sale_activity"</span></span>) with ... }</code> </pre><br>  El par√°metro de <code>tag</code> es del tipo <code>Any</code> , por lo que puede usar m√°s que solo cadenas.  Pero recuerde que las clases utilizadas como etiquetas deben implementar los m√©todos <code>equals</code> y <code>hashCode</code> .  Siempre es necesario pasar una etiqueta a una funci√≥n como argumento con nombre, independientemente de si crea una dependencia o la recibe. <br><br><h3>  Tipos de inyecci√≥n de dependencia </h3><br>  Hay varias formas de proporcionar dependencias en <code>Kodein</code> , <code>Kodein</code> con lo esencial: crear singletones.  El singleton vivir√° dentro del marco de la instancia creada de <code>Kodein</code> . <br><br><h4>  Introduciendo singleton </h4><br>  Comencemos con un ejemplo: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton { RoomDb() } }</code> </pre><br>  Por lo tanto, proporcionamos (proporcionamos) <code>IMyDatabase</code> , detr√°s del cual se <code>RoomDb</code> una instancia de <code>RoomDb</code> .  Se <code>RoomDb</code> una instancia de <code>RoomDb</code> a la primera solicitud de la dependencia; no se volver√° a <code>Kodein</code> hasta que se <code>Kodein</code> una nueva instancia de <code>Kodein</code> .  Se crea un singleton sincronizado, pero si se desea, se puede hacer sin sincronizar.  Esto aumentar√° la productividad, pero debe comprender los riesgos que siguen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { RoomDb() } }</code> </pre><br>  Si necesita crear una instancia de dependencia no en la primera llamada, sino inmediatamente despu√©s de crear la instancia de <code>Kodein</code> , use otra funci√≥n: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with eagerSingleton { RoomDb() } }</code> </pre><br><h4>  Crear constantemente una nueva instancia de la dependencia </h4><br>  Es posible crear no singletones, pero constantemente al acceder a una dependencia para obtener una nueva instancia de la misma.  Para esto, se utiliza la funci√≥n de <code>provider</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMainPresenter&gt;() with provider { QuantityPresenter() } }</code> </pre><br>  En este caso, cada vez que solicitemos una dependencia <code>IMainPresenter</code> , se <code>IMainPresenter</code> una nueva instancia de <code>QuantityPresenter</code> . <br><br><h4>  Cree constantemente una nueva instancia de la dependencia y pase los par√°metros al constructor de la dependencia </h4><br>  Puede obtener una nueva instancia cada vez que agrega una dependencia, como en el ejemplo anterior, pero especifique los par√°metros para crear la dependencia.  Los par√°metros pueden ser un m√°ximo de <b>5</b> .  Para este comportamiento, utilice el m√©todo de <code>factory</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } }</code> </pre><br><h4>  Cada vez que creamos una instancia en cach√© dependiendo de los par√°metros </h4><br>  Al leer el p√°rrafo anterior, podr√≠a pensar que ser√≠a bueno recibir no una nueva instancia cada vez de acuerdo con los par√°metros pasados, sino recibir la misma instancia de la dependencia del mismo par√°metro. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br>  En el ejemplo anterior, cuando obtenemos la dependencia por primera vez con los par√°metros <code>5</code> y <code>10</code> crearemos una nueva instancia de <code>IntRandom(5, 10)</code> , cuando volvamos a llamar a la dependencia con los mismos par√°metros, obtendremos la instancia creada anteriormente.  Por lo tanto, se obtiene un <code>map</code> de singleton con inicializaci√≥n diferida.  Los argumentos, como en el caso de la <code>factory</code> m√°ximos <b>5</b> . <br><br>  Al igual que con los singletones, puede desactivar la sincronizaci√≥n aqu√≠. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br><h4>  Uso de enlaces d√©biles y d√©biles en Kodein </h4><br>  Al proporcionar dependencias mediante <code>singleton</code> o <code>multiton</code> puede especificar el tipo de referencia a la instancia almacenada.  En el caso habitual, que consideramos anteriormente, este ser√° el v√≠nculo <code>strong</code> habitual.  Pero es posible usar enlaces <code>soft</code> y <code>weak</code> .  Si eres nuevo en estos conceptos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">echa</a> un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vistazo aqu√≠</a> . <br><br>  Por lo tanto, sus singletones pueden recrearse como parte del ciclo de vida de la aplicaci√≥n, o pueden no serlo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyMap&gt;() with singleton(ref = softReference) { WorldMap() } bind&lt;IClient&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } }</code> </pre><br><h4>  Singleton separado para cada flujo </h4><br>  Este es el mismo singleton, pero para cada hilo que solicite una dependencia, se crear√° un singleton.  Para hacer esto, use el par√°metro familiar <code>ref</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(<span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) } }</code> </pre><br><h4>  Constantes como dependencias integrables </h4><br>  Puede proporcionar constantes como dependencias.  La documentaci√≥n llama la atenci√≥n sobre el hecho de que con <code>Kodein</code> debe <code>Kodein</code> constantes de tipos simples sin herencia o interfaces, por ejemplo, primitivas o clases de datos. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { constant(tag = <span class="hljs-string"><span class="hljs-string">"maxThread"</span></span>) with <span class="hljs-number"><span class="hljs-number">8</span></span> constant(tag = <span class="hljs-string"><span class="hljs-string">"serverURL"</span></span>) with <span class="hljs-string"><span class="hljs-string">"https://my.server.url"</span></span></code> </pre><br><h4>  Crea dependencias sin cambiar el tipo </h4><br>  Por ejemplo, desea proporcionar la dependencia como un singleton, pero no la oculta detr√°s de la interfaz.  Simplemente no puede especificar el tipo al llamar a <code>bind</code> y usar <code>from</code> lugar de <code>with</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind() from singleton { Gson() }</code> </pre><br>  La dependencia en el ejemplo anterior tendr√° el tipo de retorno de la funci√≥n, es decir, se proporcionar√° una dependencia de tipo <code>Gson</code> . <br><br><h4>  Crear dependencias de subclase de una superclase o interfaz </h4><br>  <code>Kodein</code> permite proporcionar dependencia de diferentes maneras para los descendientes de una clase particular o clases que implementan una sola interfaz. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Animal&gt;().subTypes() with { animalType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (animalType.jvmType) { Dog::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eagerSingleton</span></span></span><span class="hljs-class"> </span></span>{ Dog() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; provider { WildAnimal(animalType) } } }</code> </pre><br>  La clase <code>Animal</code> puede ser una superclase o una interfaz, usando <code>.subtypes</code> obtenemos <code>animalType</code> con el tipo <code>TypeToken&lt;*&gt;</code> , del cual ya podemos obtener la clase Java y, dependiendo de ello, proporcionar la dependencia de diferentes maneras.  Esta caracter√≠stica puede ser √∫til si usa <code>TypeToken</code> o sus derivados como un par√°metro de construcci√≥n para varios casos.  Tambi√©n de esta manera puede evitar c√≥digo innecesario con la misma creaci√≥n de dependencias para diferentes tipos. <br><br><h4>  Crear dependencias que necesiten otras dependencias como par√°metros. </h4><br>  Muy a menudo, no solo creamos una clase sin par√°metros como una dependencia, sino que creamos una clase a la que necesitamos pasar par√°metros al constructor. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGateway</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: IProductApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchers: IDispatchersContainer) : IProductGateway</code> </pre><br>  Para crear una clase con dependencias que se crearon previamente en <code>Kodein</code> suficiente pasar una llamada a la funci√≥n instancia () como par√°metros.  En este caso, el orden de creaci√≥n no es importante. <br><br><pre> <code class="kotlin hljs">bind&lt;IDispatchersContainer&gt;() with singleton { DispatchersContainer() } bind&lt;IProductGateway&gt;() with singleton { ProductGateway(instance(), instance()) } bind&lt;IProductApi&gt;() with singleton { ProductApi() }</code> </pre><br>  En lugar de <code>instance()</code> puede haber llamadas al <code>provider()</code> o a la <code>factory()</code> ; veremos m√°s de cerca estos m√©todos en la secci√≥n sobre c√≥mo obtener e implementar dependencias. <br><br><h4>  Cree una dependencia llamando al m√©todo de dependencia creado anteriormente </h4><br>  No suena muy bien, pero puede llamar a la <code>instance&lt;TYPE&gt;</code> para obtener una clase que ya proporcionamos en alg√∫n lugar y llamar al m√©todo de esta clase para obtener una nueva dependencia. <br><br><pre> <code class="kotlin hljs">bind&lt;DataSource&gt;() with singleton { MySQLDataSource() } bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() }</code> </pre><br><h3>  M√≥dulos </h3><br>  Usando <code>Dagger2</code> , estoy acostumbrado a <code>Dagger2</code> dependencias del <code>Dagger2</code> .  En <code>Kodein</code> , a primera vista, todo no se ve muy bien.  Necesita crear muchas dependencias directamente en la clase <code>Application</code> , y personalmente no me gusta.  Pero hay una soluci√≥n, <code>Kodein</code> tambi√©n le permite crear m√≥dulos y luego conectarlos en esos lugares cuando sea necesario. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Pero tenga cuidado, los m√≥dulos son solo contenedores que declaran m√©todos para obtener dependencias; ellos mismos no crean clases.  Por lo tanto, si declara la recepci√≥n de la dependencia como un singleton en el m√≥dulo y luego importa este m√≥dulo en dos instancias diferentes de <code>Kodein</code> , obtendr√° dos singlets diferentes, uno por instancia de <code>Kodein</code> . <br><br>  Adem√°s, el nombre de cada m√≥dulo debe ser √∫nico.  Sin embargo, si necesita importar un m√≥dulo de otro proyecto, es dif√≠cil garantizar la unicidad del nombre; para esto, puede cambiar el nombre del m√≥dulo o agregar un prefijo a su nombre. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(apiModule.copy(name = <span class="hljs-string"><span class="hljs-string">"firstAPI"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondApiModule.copy(prefix = <span class="hljs-string"><span class="hljs-string">"secondAPI-"</span></span>))</code> </pre><br>  Estoy acostumbrado a trabajar cuando los m√≥dulos dependen unos de otros y forman alg√∫n tipo de jerarqu√≠a.  <code>Kodein</code> importar cada m√≥dulo a <code>Kodein</code> una vez, por lo tanto, si intenta importar dos m√≥dulos que tienen los mismos m√≥dulos dependientes en un <code>Kodein</code> , la aplicaci√≥n se bloquear√°.  La soluci√≥n es simple: debe usar la <code>importOnce(someModule)</code> para importar, que verificar√° si el m√≥dulo con el mismo nombre se import√≥ previamente y luego importar√° si es necesario. <br><br>  Por ejemplo, en tales casos, la aplicaci√≥n se bloquear√°: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br>  Pero si la llamada <code>importOnce</code> est√° en un segundo intento de conexi√≥n, entonces todo funcionar√°.  Ten cuidado <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><h4>  Herencia </h4><br>  Si usa el mismo m√≥dulo dos veces, se crear√°n diferentes dependencias, pero ¬øqu√© pasa con la herencia y el comportamiento de implementaci√≥n similar a los <code>Subcomponents</code> en <code>Dagger2</code> ?  Todo es simple, solo necesita heredar de la instancia de <code>Kodein</code> y obtendr√° acceso a todas las dependencias del padre en el heredero. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   } val subKodein = Kodein { extend(kodein) //   }</span></span></code> </pre><br><h4>  Redefinici√≥n </h4><br>  De forma predeterminada, no puede anular la dependencia, de lo contrario los usuarios se volver√≠an locos buscando razones para que la aplicaci√≥n funcione incorrectamente.  Pero es posible hacer esto usando un par√°metro adicional de la funci√≥n de <code>bind</code> .  Esta funcionalidad ser√° √∫til, por ejemplo, para organizar pruebas. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Api&gt;() with singleton { ApiImpl() } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> bind&lt;Api&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { OtherApiImpl() } }</code> </pre><br>  De forma predeterminada, los m√≥dulos y sus dependencias no pueden anular las dependencias ya declaradas en el objeto <code>Kodein</code> , pero al importar un m√≥dulo, puede indicar que las dependencias existentes pueden anular sus dependencias, y dentro de este m√≥dulo ya puede especificar dependencias que otros pueden anular. <br><br>  No suena muy claro, usemos ejemplos.  En estos casos, la aplicaci√≥n se bloquear√°: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Y en esto, la dependencia del m√≥dulo sobrescribe la dependencia declarada en el objeto <code>Kodein</code> . <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Pero si realmente quiere y comprende lo que est√° haciendo, puede crear un m√≥dulo que, si existen dependencias id√©nticas con el objeto <code>Kodein</code> redefinir√° y la aplicaci√≥n no se bloquear√°.  Usamos el par√°metro <code>allowSilentOverride</code> para el m√≥dulo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = Kodein.Module(name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } }</code> </pre><br>  La documentaci√≥n analiza situaciones m√°s complejas con la herencia y la redefinici√≥n de dependencias, as√≠ como con la copia de dependencias en herederos, pero estas situaciones no se considerar√°n aqu√≠. <br><br><h3>  Recuperando e inyectando dependencias </h3><br>  Finalmente, descubrimos c√≥mo declarar dependencias de muchas maneras, es hora de descubrir c√≥mo incluirlas en sus clases. <br><br>  <code>Kodein</code> desarrolladores de <code>Kodein</code> comparten dos formas de obtener dependencias: <code>injection</code> y <code>retieval</code> .  En resumen, la <code>injection</code> es cuando la clase recibe todas las dependencias cuando se crea, es decir, en el constructor, y la <code>retrieval</code> es cuando la clase misma es responsable de obtener sus dependencias. <br><br>  Cuando usa la <code>injection</code> su clase no sabe nada sobre <code>Kodein</code> y el c√≥digo en la clase es m√°s limpio, pero si usa la <code>retrieval</code> , entonces tiene la oportunidad de administrar las dependencias de manera m√°s flexible.  En el caso de la <code>retrieval</code> todas las dependencias se obtienen perezosamente, solo en el momento de la primera apelaci√≥n a la dependencia. <br><br><h4>  M√©todos de <code>Kodein</code> para usar dependencias </h4><br>  Una instancia de la clase <code>Kodein</code> tiene tres m√©todos que devuelven una dependencia, una f√°brica de dependencias o un proveedor de dependencias: <code>instance()</code> , <code>factory()</code> y <code>provider()</code> respectivamente.  Por lo tanto, si proporciona una dependencia utilizando una <code>factory</code> o un <code>provider</code> , puede recibir no solo el resultado de la ejecuci√≥n de la funci√≥n, sino tambi√©n la funci√≥n misma.  Recuerde que puede usar etiquetas en todas las variaciones. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> provider()</code> </pre><br><h4>  Inyecci√≥n de dependencias a trav√©s del constructor </h4><br>  Como ya entendi√≥, se tratar√° de la <code>injection</code> .  Para implementar, primero debe tomar todas las dependencias de la clase en su constructor, y luego crear una instancia de la clase llamando a <code>kodein.newInstance</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h4>  Inyecci√≥n de dependencia en propiedades anulables </h4><br>  Es muy posible que no sepas si se ha declarado una dependencia.  Si la dependencia no se declara en la instancia de <code>Kodein</code> , entonces el c√≥digo del ejemplo anterior dar√° como resultado una <code>Kodein.NotFoundException</code> .  Si desea obtener un <code>null</code> como resultado, si no hay dependencia, existen tres funciones auxiliares para esto: <code>instanceOrNull()</code> , <code>factoryOrNull()</code> y <code>providerOrNull()</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient?, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instanceOrNull(), instance()) } }</code> </pre><br><h4>  Obtenga dependencias dentro de la clase. </h4><br>  Como ya se mencion√≥, en el caso en que usamos la <code>retrieval</code> , la inicializaci√≥n de todas las dependencias es lenta por defecto.  Esto le permite obtener dependencias solo cuando son necesarias y obtener dependencias en las clases que crea el sistema. <br><br>  <code>Activity</code> , <code>Fragment</code> y otras clases con su propio ciclo de vida, se trata de ellos. <br><br>  Para implementar dependencias en <code>Activity</code> solo necesitamos un enlace a una instancia de Kodein, despu√©s de lo cual podemos usar m√©todos conocidos.  De hecho, ya ha visto ejemplos de <code>retrieval</code> anteriores, solo necesita declarar una propiedad y delegarla en una de las funciones: <code>instance()</code> , <code>factory()</code> o <code>provider()</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instanceOrNull() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: (() -&gt; Random)? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.providerOrNull()</code> </pre><br><h4>  Pasar par√°metros a f√°bricas </h4><br>  Ya ha visto que para pasar un par√°metro a la f√°brica, es suficiente usar el par√°metro <code>arg</code> de la funci√≥n de <code>instance</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¬øqu√© pasa si hay varios par√°metros (dije anteriormente que puede haber hasta </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par√°metros en una f√°brica </font><font style="vertical-align: inherit;">)? </font><font style="vertical-align: inherit;">Solo necesita pasar una </font></font><code>arg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clase </font><font style="vertical-align: inherit;">al par√°metro </font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que ha sobrecargado a los constructores y puede tomar de 2 a 5 argumentos.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> picker: IColorPicker <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = M(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>))</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forzar inicializaci√≥n de dependencia </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como dijeron: de forma predeterminada, la inicializaci√≥n es lenta, pero puede crear un desencadenador, vincularlo a una propiedad, varias propiedades o una instancia completa </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despu√©s de tirar de este desencadenador y las dependencias se inicializar√°n.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(trigger = myTrigger).instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//     Gson</span></span></code> </pre><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinWithTrigger = kodein.on(trigger = myTrigger) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodeinWithTrigger.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//        kodeinWithTrigger</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creaci√≥n de instancia de Lazy Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de eso, constantemente creamos expl√≠citamente una instancia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero es posible diferir la inicializaci√≥n de esta propiedad usando una clase </font></font><code>LazyKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que toma una funci√≥n en el constructor que deber√≠a devolver un objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este enfoque puede ser √∫til si, por ejemplo, no se sabe si se necesitan dependencias de una instancia de Kodein determinada.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = LazyKodein { Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una llamada a Kodein.lazy dar√° lugar a un resultado similar. </font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein.lazy { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicializaci√≥n retrasada de Kodein </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la inicializaci√≥n retrasada, </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe un objeto </font></font><code>LateInitKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puede crear este objeto, delegarle la creaci√≥n de propiedades y, despu√©s de inicializar el objeto en s√≠, establecer la propiedad en √©l </font></font><code>baseKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, despu√©s de lo cual ya puede acceder a las dependencias.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = LateInitKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> kodein.baseKodein = <span class="hljs-comment"><span class="hljs-comment">/*     Kodein */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> gson.fromJson(someStr)</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtenga todas las instancias del tipo especificado </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede pedirle a Kodein una instancia del tipo especificado y todos sus descendientes en el formulario </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Todo est√° solo dentro de la etiqueta especificada. </font><font style="vertical-align: inherit;">Para ello, existen m√©todos </font></font><code>allInstances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allProviders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allFactories</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.allInstances()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si imprime en el registro, ver√° all√≠ [32767, 136.88, 4562, 12.46]. </font><font style="vertical-align: inherit;">La dependencia con la etiqueta no est√° en la lista.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifique la adquisici√≥n de dependencias utilizando la interfaz KodeinAware </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta interfaz le obliga a anular la propiedad type </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, a cambio, proporciona acceso a todas las funciones disponibles para la instancia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, ahora puede simplemente escribir en </font></font><code>by allInstances()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar de </font></font><code>by kodein.allInstances()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, ya hablamos sobre el desencadenante para recibir dependencias. </font><font style="vertical-align: inherit;">En la interfaz, </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede anular un disparador y obtener todas las dependencias declaradas cuando se llama a este disparador.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() kodeinTrigger.trigger() } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el acceso a las dependencias y la instancia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es diferido, puede delegar la inicializaci√≥n de la instancia a la </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funci√≥n integrada en Kotlin </font></font><code>lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tal enfoque puede ser √∫til en clases dependiendo de su contexto, por ejemplo, en </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por las mismas razones, puede usar un modificador </font></font><code>lateinit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) kodein = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceso a dependencias sin delegar propiedades </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si por alguna raz√≥n no desea utilizar la delegaci√≥n de propiedades, puede utilizar el acceso directo a trav√©s de </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(desde directo). </font><font style="vertical-align: inherit;">La diferencia principal es que la inicializaci√≥n perezosa se ha ido, se obtendr√° la dependencia de inmediato en el momento de la llamada </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y funciones similares. </font><font style="vertical-align: inherit;">Puede obtenerlo </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de una instancia de Kodein existente o construir desde cero.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.TEN } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein: DKodein = kodein.direct <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein2: DKodein = Kodein.direct { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.ONE } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber:BigDecimal = directKodein.instance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber2:BigDecimal = directKodein2.instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kodein se puede usar en el marco </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el marco </font></font><code>DKodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puedes experimentar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtenga dependencias en cualquier contexto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varias dependencias del mismo tipo </font><font style="vertical-align: inherit;">de un objeto, </font><font style="vertical-align: inherit;">ya hemos examinado la opci√≥n de usar etiquetas y f√°bricas con argumentos, pero hay una cosa m√°s: usar el contexto (y este no es el contexto que est√° en Android). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferencias de dependencia con etiqueta:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No se puede usar una etiqueta dentro de una funci√≥n en la que creamos una dependencia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al usar el contexto, tenemos acceso a la instancia de contexto en la funci√≥n de creaci√≥n de dependencia </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo, en lugar de contexto, puede usar una f√°brica con un argumento, y los desarrolladores </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomiendan hacerlo si no est√° seguro de qu√© usar. Pero el contexto puede ser √∫til, por ejemplo, cuando no puede lanzar dos argumentos al mismo tipo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, tiene </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desea usar un objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para proporcionar varias dependencias de diferentes tipos de diferentes maneras, dependiendo de la clase en la que se reciban. Para dirigir </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para un tipo - que necesita una interfaz opcional, y la f√°brica tendr√° que comprobar el tipo del argumento resultante. El esquema no es muy conveniente. Por lo tanto, miramos c√≥mo usar el contexto:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesActivity&gt;().provider { context.getActivityBigDecimal() } bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesPresenter&gt;().factory { initialValue:BigDecimal -&gt; context.getPresenterBigDecimal(initialValue) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), AppKodeinAware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActivityBigDecimal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = BigDecimal(<span class="hljs-string"><span class="hljs-string">"16.34"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activityBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppKodeinAware { fun getPresenterBigDecimal</span></span></span></span>(initialValue: BigDecimal) = initialValue * BigDecimal.TEN <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> presenterBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance(arg = BigDecimal(<span class="hljs-string"><span class="hljs-string">"31.74"</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ejemplo, por supuesto, pasar√° por encima de las orejas y en la pr√°ctica real es poco probable que se encuentre con tal situaci√≥n, pero este ejemplo muestra c√≥mo funciona el contexto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para declarar una dependencia, especifique no </font></font><code>with provider()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero </font></font><code>with contexted&lt;OurContextClass&gt;().provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donde </font></font><code>OurContextClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el tipo de clase, una instancia de la cual actuar√° como contexto. </font></font><code>contexted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo puede ser proveedor o f√°brica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El acceso a este contexto en la funci√≥n que devuelve la dependencia es a trav√©s de una variable bajo el nombre </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener una dependencia adjunta a un contexto, primero debe especificar el contexto para el objeto a </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trav√©s de la funci√≥n </font></font><code>on()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego solicitar la dependencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Del mismo modo, el contexto se utiliza en el caso de </font></font><code>injection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = someContext).newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extensiones de Android </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al comienzo del art√≠culo, promet√≠ considerar opciones de expansi√≥n para </font></font><code>Android</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nada le impide usarlo </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como discutimos anteriormente, pero puede hacer que todo sea un orden de magnitud m√°s conveniente.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein incorporado para Android </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una cosa muy √∫til es un m√≥dulo preparado para Android. </font><font style="vertical-align: inherit;">Para conectarlo, es necesario que la clase </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implemente </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e inicialice la propiedad </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perezosamente (para acceder a la instancia </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">A cambio, obtienes una gran cantidad de dependencias declaradas que puedes obtener de la clase </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluido todo lo que necesitas </font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C√≥mo conectarse: vea un ejemplo.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein.lazy { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(androidModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MyApplication</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  } val inflater: LayoutInflater by instance() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se puede ver - se puede obtener, por ejemplo </font></font><code>LayoutInflater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para obtener una lista completa de las dependencias declaradas en el m√≥dulo, </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consulte aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea obtener estas dependencias fuera de las clases de Android que conocen su contexto, especifique el contexto expl√≠citamente.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = getActivity()).instance()</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtenga r√°pidamente el padre Kodein a trav√©s del m√°s cercanoKodein () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es simple, en Android, algunos objetos dependen de otros. </font><font style="vertical-align: inherit;">En el nivel superior hay Aplicaci√≥n, debajo de la cual est√° Actividad, luego Fragmento. </font><font style="vertical-align: inherit;">Puede implementar en Activity </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y como inicializaci√≥n, llamar </font></font><code>closestKodein()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y obtener una instancia </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br> <code>closestKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n puede obtenerlo fuera de las clases de Android, pero necesita un contexto de Android desde el que pueda llamar a la funci√≥n. </font><font style="vertical-align: inherit;">Si lo usa </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, especifique tambi√©n el contexto (anule la propiedad correspondiente y pase el contexto de Android a la funci√≥n </font></font><code>kcontext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span></span>(androidContext: Context) : KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> androidContext.closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinContext = kcontext(androidContext) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear un Kodein separado en Actividad </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ser necesario heredar del padre Kodein en la Actividad y expandirlo. </font><font style="vertical-align: inherit;">La soluci√≥n es bastante simple.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kodein.lazy { extend(parentKodein) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein que est√° experimentando un cambio de configuraci√≥n </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si puedes. </font><font style="vertical-align: inherit;">Hay una funci√≥n para esto </font></font><code>retainedKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al usarlo, el objeto </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se volver√° a crear despu√©s de un cambio de configuraci√≥n.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> retainedKodein { extend(parentKodein) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øQu√© no se dice en el art√≠culo? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No pretend√≠ estar completo, y yo mismo no entiendo algunas cosas lo suficientemente bien como para tratar de decirlas. </font><font style="vertical-align: inherit;">Aqu√≠ hay una lista de lo que puede aprender por su cuenta, conociendo los principios b√°sicos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alcances </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enlace de instancia </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multi-vinculante </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Callbacks ya preparados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fuente externa </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Errores de la versi√≥n borrada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein configurable </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidad JSR-330 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien y enlaces a la documentaci√≥n: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P√°gina de inicio</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gracias por leer, ¬°espero que el art√≠culo te sea √∫til! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431696/">https://habr.com/ru/post/es431696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431686/index.html">Excepto IoT: la botnet Mirai lanz√≥ un ataque en m√°quinas Linux</a></li>
<li><a href="../es431688/index.html">C√≥mo Clang compila una funci√≥n</a></li>
<li><a href="../es431690/index.html">Resolviendo crackme de Kaspersky Lab</a></li>
<li><a href="../es431692/index.html">Avances en inmunoterapia en el tratamiento de la esclerosis m√∫ltiple.</a></li>
<li><a href="../es431694/index.html">Ordenar "Torre de Hanoi"</a></li>
<li><a href="../es431698/index.html">An√°lisis de preguntas en el stand hh.ru en # HolyJS18</a></li>
<li><a href="../es431700/index.html">Un mult√≠metro dom√©stico que nunca encontr√© en el mercado</a></li>
<li><a href="../es431702/index.html">HI-FI sovi√©tico y sus creadores: auriculares para un disco o una historia olvidada Electr√≥nica TDK-3 "Quad"</a></li>
<li><a href="../es431704/index.html">Lectura de fin de semana: c√≥mo no estropear su audici√≥n y escapar del ruido de la ciudad - 17 art√≠culos y gu√≠as pr√°cticas</a></li>
<li><a href="../es431706/index.html">Teor√≠a de la felicidad. ¬øLos accidentes no son accidentales?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>