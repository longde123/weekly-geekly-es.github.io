<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜ ü•† üò° Encore une fois sur le principe de substitution de Lisk, ou la s√©mantique de l'h√©ritage en POO ‚ôäÔ∏è üîß üîü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'h√©r√©dit√© est l'un des piliers de la POO. L'h√©ritage est utilis√© pour r√©utiliser le code commun. Mais le code commun n'est pas toujours n√©cessaire po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Encore une fois sur le principe de substitution de Lisk, ou la s√©mantique de l'h√©ritage en POO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463385/"> <b>L'h√©r√©dit√© est l'un des piliers de la POO.</b>  L'h√©ritage est utilis√© pour r√©utiliser le code commun.  Mais le code commun n'est pas toujours n√©cessaire pour r√©utiliser, et l'h√©ritage n'est pas toujours le meilleur moyen de r√©utiliser le code.  Il s'av√®re souvent, de sorte qu'il existe un code similaire dans deux morceaux de code (classes) diff√©rents, mais les exigences pour eux sont diff√©rentes, c'est-√†-dire  les classes h√©ritent en fait les unes des autres et peuvent ne pas en valoir la peine. <br><a name="habracut"></a><br>  Habituellement, pour illustrer ce probl√®me, ils utilisent un exemple d'h√©ritage de la classe Square de la classe Rectangle, ou vice versa. <br><br>  Ayons une classe rectangle: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._width * self._height ...</code> </pre> <br>  Nous voulions maintenant √©crire la classe Square, mais afin de r√©utiliser le code de calcul d'aire, il semble logique d'h√©riter du Square du Rectangle: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._width = height self._height = height</code> </pre><br>  Il semble que le code des classes Square et Rectangle soit coh√©rent.  Il semble que Square pr√©serve les propri√©t√©s math√©matiques du carr√©, c'est-√†-dire  et un rectangle.  Cela signifie que nous pouvons passer des objets carr√©s au lieu de rectangle. <br><br>  Mais si nous le faisons, nous pouvons violer le <i>comportement</i> de la classe Rectangle: <br><br>  Par exemple, il existe un code client: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect)</span></span></span><span class="hljs-function">:</span></span> rect.set_height(<span class="hljs-number"><span class="hljs-number">10</span></span>) rect.set_width(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> rect.get_area() == <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre><br>  Si vous passez une instance de la classe Square comme argument √† cette fonction, la fonction se comportera diff√©remment.  Ce qui est une violation du contrat pour le comportement de la classe Rectangle, car les actions avec un objet de la classe de base doivent donner exactement le m√™me r√©sultat qu'avec l'objet de la classe descendante. <br><br>  Si la classe carr√©e est un descendant de la classe rectangle, alors en travaillant avec le carr√© et en appliquant les m√©thodes du rectangle, nous ne devrions m√™me pas remarquer qu'il ne s'agit pas d'un rectangle. <br><br>  Vous pouvez r√©soudre ce probl√®me, par exemple, comme ceci: <br><br><ol><li>  faire une affirmation pour correspondre exactement √† la classe, ou faire un if qui fonctionnera diff√©remment pour diff√©rentes classes </li><li>  dans Square, cr√©ez la m√©thode set_size () et remplacez les m√©thodes set_height, set_width afin qu'elles l√®vent des exceptions <br>  etc etc </li></ol><br>  Un tel code et de telles classes fonctionneront, dans le sens o√π le code fonctionnera. <br><br>  Une autre question est que le code client qui utilise la classe Square ou la classe Rectangle devra conna√Ætre soit la classe de base et son comportement, soit la classe descendante et son comportement. <br><br>  Au fil du temps, nous pouvons obtenir cela: <br><br><ul><li>  la classe descendante remplacera la plupart des m√©thodes </li><li>  la refactorisation ou l'ajout de m√©thodes √† la classe de base rompra le code √† l'aide de descendants </li><li>  dans le code qui utilise les objets de la classe de base, il y aura des ifs, v√©rifiant la classe de l'objet et le comportement des descendants et de la classe de base est diff√©rent </li></ul><br>  Il s'av√®re que le code client √©crit pour la classe de base d√©pend de l'impl√©mentation de la classe de base et de la classe descendante.  Ce qui complique grandement le d√©veloppement au fil du temps.  Et la POO a √©t√© cr√©√©e juste pour que vous puissiez √©diter la classe de base et la classe descendante ind√©pendamment l'une de l'autre. <br><br>  Dans les ann√©es 80 du si√®cle dernier, nous avons remarqu√© que pour que l'h√©ritage de classe fonctionne bien pour la r√©utilisation de code, nous devons savoir avec certitude que la classe descendante peut √™tre utilis√©e √† la place de la classe de base.  C'est-√†-dire  s√©mantique d'h√©ritage - cela ne devrait pas √™tre seulement et pas autant de donn√©es que de comportement.  Les h√©ritiers ne doivent pas "casser" le comportement de la classe de base. <br><br>  En fait, c'est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de la substitution Lisk</a> ou le principe de la d√©termination d'un sous-type bas√© sur le comportement d'un typage comportemental fort des classes: <b>si vous pouvez √©crire au moins un code significatif dans lequel le remplacement de l'objet de classe de base par l'objet de classe descendant, il se cassera, alors cela ne vaut pas la peine les h√©riter les uns des autres.</b>  Nous devons √©tendre le comportement de la classe de base dans les descendants et ne pas le modifier de mani√®re significative.  Les fonctions qui utilisent la classe de base doivent pouvoir utiliser des objets de sous-classe sans le savoir.  En fait, c'est la s√©mantique de l'h√©ritage dans la POO. <br><br>  Et dans le vrai code industriel, il est fortement recommand√© que ce principe soit suivi et respect√© la s√©mantique d√©crite de l'h√©ritage.  Et avec ce principe, il y a plusieurs subtilit√©s. <br><br>  <b>Le principe devrait √™tre satisfait non pas avec des abstractions du niveau de domaine, mais avec des abstractions de code - classes.</b>  D'un point de vue g√©om√©trique, un carr√© est un rectangle.  Du point de vue de la hi√©rarchie d'h√©ritage de classe, le fait que la classe d'un carr√© soit l'h√©riti√®re du rectangle de classe d√©pend du comportement que nous exigeons de ces classes.  Cela d√©pend de la fa√ßon dont et dans quelles situations nous utilisons ce code. <br><br>  Si la classe Rectangle n'a que deux m√©thodes - calculer la zone et le rendu, sans possibilit√© de redessiner et de redimensionner, alors dans ce cas, Square avec un constructeur surcharg√© satisfera le principe de remplacement Liskov. <br><br>  C'est-√†-dire  ces classes satisfont au principe de substitution: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Bien s√ªr, ce n'est pas un tr√®s bon code, et m√™me, probablement, l'anti-mod√®le de la conception de classes, mais d'un point de vue formel, il satisfait le principe de Liskov. <br><br>  Un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> .  Un ensemble est un sous-type d'un multiset.  Il s'agit du rapport des abstractions de domaine.  Mais le code peut √™tre √©crit de sorte que nous h√©ritons de la classe Set de Bag et que le principe de substitution soit viol√©, ou nous pouvons √©crire pour que le principe soit respect√©.  Avec la m√™me s√©mantique du domaine. <br><br>  En g√©n√©ral, l'h√©ritage des classes peut √™tre consid√©r√© comme la mise en ≈ìuvre de la relation ¬´IS¬ª, mais pas entre les entit√©s du domaine, mais entre les classes.  Et si la classe descendante est un sous-type de la classe de base est d√©termin√©e par les restrictions et les contrats de comportement de classe que le code client utilise (et en principe peuvent utiliser). <br><br>  <b>Les contraintes, les invariants, un contrat de classe de base ne sont pas fig√©s dans le code, mais fig√©s dans les t√™tes des d√©veloppeurs qui √©ditent et lisent le code.</b>  Ce qui ¬´casse¬ª, ce qui rompt le ¬´contrat¬ª n'est pas d√©termin√© par le code, mais par la s√©mantique de la classe dans la t√™te du d√©veloppeur. <br><br>  Tout code significatif pour un objet d'une classe de base ne doit pas se casser si nous le rempla√ßons par un objet d'une classe descendante.  Le code significatif est tout code client qui utilise un objet d'une classe de base (et ses descendants) dans le cadre de la s√©mantique et des restrictions de la classe de base. <br><br>  Ce qui est extr√™mement important √† comprendre, c'est que les limitations de l'abstraction impl√©ment√©e dans la classe de base ne sont g√©n√©ralement pas contenues dans le code du programme.  Ces restrictions sont comprises, connues et prises en charge par le d√©veloppeur.  Il surveille la coh√©rence de l'abstraction et du code.  Pour que le code exprime ce qu'il signifie. <br><br>  Par exemple, un rectangle a une autre m√©thode qui renvoie une vue dans json <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"height"</span></span>: self.height, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: self.width}</code> </pre><br>  Et dans Square, nous le red√©finissons: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"size"</span></span>: self.height}</code> </pre><br>  Si nous consid√©rons que le contrat de base pour le comportement de la classe Rectangle to_json a une hauteur et une largeur, alors le code <br><br><pre> <code class="python hljs">r = rect.to_dict() log(r[<span class="hljs-string"><span class="hljs-string">'height'</span></span>], r[<span class="hljs-string"><span class="hljs-string">'width'</span></span>])</code> </pre><br>  aura un sens pour un objet de la classe de base Rectangle.  Lors du remplacement d'un objet d'une classe de base par une classe, le code h√©ritier Square change son comportement et viole le contrat, et viole ainsi le principe de substitution Lisk. <br><br>  Si nous pensons que le contrat de base pour le comportement de la classe Rectangle est que to_dict retourne un dictionnaire qui peut √™tre s√©rialis√© sans poser sur des champs sp√©cifiques, alors une telle m√©thode to_dict sera correcte. <br><br>  Soit dit en passant, c'est un bon exemple, d√©truisant le mythe selon lequel l'immuabilit√© sauve de la violation du principe. <br><br>  Formellement, tout remplacement d'une m√©thode dans une classe descendante est dangereux, ainsi que les modifications de la logique dans la classe de base.  Par exemple, assez souvent, les classes descendantes s'adaptent au comportement ¬´incorrect¬ª de la classe de base, et lorsque le bogue est corrig√© dans la classe de base, elles se cassent. <br><br>  Il est possible de transf√©rer toutes les conditions du contrat et des invariants dans le code autant que possible, mais dans le cas g√©n√©ral, la s√©mantique du comportement se situe tout de m√™me en dehors du code - dans la zone de probl√®me et est prise en charge par le d√©veloppeur.  L'exemple sur to_dict est un exemple o√π le contrat peut √™tre d√©crit dans le code, mais par exemple, pour v√©rifier que la m√©thode get_hash renvoie vraiment un hachage avec toutes les propri√©t√©s du hachage, et pas seulement une ligne, est impossible. <br><br>  Lorsqu'un d√©veloppeur utilise du code √©crit par d'autres d√©veloppeurs, il peut comprendre ce que la s√©mantique d'une classe n'est que directement par le code, les noms de m√©thode, la documentation et les commentaires.  Mais en tout cas, la s√©mantique est souvent un domaine humain, et donc erron√©e.  La cons√©quence la plus importante: uniquement par le code - syntaxiquement - est impossible de v√©rifier la conformit√© avec le principe de Liskov, et vous devez vous appuyer sur une s√©mantique (souvent) vague.  Il n'y a aucun moyen formel (math√©matique) d'un moyen v√©rifiable et garanti de v√©rifier un typage comportemental fort. <br><br>  Par cons√©quent, souvent au lieu du principe Liskov, des r√®gles formelles pour les conditions pr√©alables et postconditions de la programmation des contrats sont utilis√©es: <br><br><ul><li>  les conditions pr√©alables dans une sous-classe ne peuvent pas √™tre renforc√©es - une sous-classe ne devrait pas exiger plus que la classe de base </li><li>  les postconditions de la sous-classe ne peuvent pas √™tre assouplies - la sous-classe ne doit pas fournir (promettre) moins que la classe de base </li><li>  les invariants de la classe de base doivent √™tre conserv√©s dans la classe descendante. </li></ul><br>  Par exemple, dans une m√©thode de classe descendante, nous ne pouvons pas ajouter un param√®tre requis qui n'√©tait pas dans la classe de base, car c'est ainsi que nous renfor√ßons les conditions pr√©alables.  Ou nous ne pouvons pas lever d'exceptions dans la m√©thode substitu√©e, car  violer les invariants de la classe de base.  Etc. <br><br>  <b>Ce qui importe n'est pas le comportement actuel de la classe, mais les changements de classe impliquent la responsabilit√© ou la s√©mantique de la classe.</b> <b><br></b> <br>  Le code est constamment corrig√© et chang√©.  Par cons√©quent, si en ce moment le code satisfait au principe de substitution, cela ne signifie pas que les changements dans le code ne changeront pas cela. <br><br>  Supposons qu'il existe un d√©veloppeur de la classe de biblioth√®que Rectangle et un d√©veloppeur d'applications qui h√©rite de Square de Rectangle.  Au moment o√π le d√©veloppeur de l'application a h√©rit√© Square de Rectangle - tout allait bien, les classes satisfaisaient au principe de substitution. <br><br>  Et √† un moment donn√©, le d√©veloppeur en charge de la biblioth√®que a ajout√© une m√©thode remodeler ou set_width / set_height √† la classe de base Rectangle.  De son point de vue, une extension de la classe de base vient de se produire.  Mais en fait, il y a eu un changement dans la s√©mantique et les contrats sur lesquels la classe descendante s'est appuy√©e.  D√©sormais, les classes ne satisfont plus au principe. <br><br>  En g√©n√©ral, lors de l'h√©ritage dans la POO, les changements dans la classe de base qui ressemblent √† une extension de l'interface - une autre m√©thode ou un nouveau champ peut √™tre ajout√© peuvent violer les contrats ¬´naturels¬ª pr√©c√©dents, et donc changer r√©ellement la s√©mantique ou les responsabilit√©s.  Par cons√©quent, l'ajout d'une m√©thode √† la classe de base est dangereux.  Vous pouvez accidentellement par inadvertance modifier le contrat. <br><br>  Et d'un point de vue pratique, dans l'exemple avec un rectangle et une classe, il est important qu'il y ait maintenant une m√©thode remodeler ou set_width / set_height.  D'un point de vue pratique, il est important de savoir quelle est la probabilit√© de tels changements dans le code de la biblioth√®que.  La s√©mantique ou les limites de la responsabilit√© de classe impliquent-elles de tels changements?  Si cela est implicite, la probabilit√© d'une erreur et / ou d'un besoin suppl√©mentaire de refactorisation est consid√©rablement augment√©e.  Et s'il y a m√™me une petite possibilit√©, il vaut probablement mieux ne pas h√©riter de telles classes les unes des autres. <br><br>  <b>Il est difficile de maintenir des d√©finitions de sous-types bas√©es sur le comportement, m√™me pour des classes simples avec une s√©mantique claire</b> , sans parler d'une entreprise avec une logique m√©tier complexe.  Malgr√© le fait que la classe de base et la classe h√©riti√®re sont des morceaux de code diff√©rents, pour eux, vous devez r√©fl√©chir soigneusement et soigneusement aux interfaces et aux responsabilit√©s.  Et m√™me avec un l√©ger changement dans la s√©mantique de la classe - qui ne peut en aucun cas √™tre √©vit√©, nous devons regarder le code des classes li√©es, v√©rifier si le nouveau contrat ou l'invariant viole ce qui est d√©j√† √©crit (!) Et utilis√©.  Avec presque tout changement dans la hi√©rarchie des classes branch√©es, nous devons regarder et v√©rifier beaucoup d'autres codes. <br><br>  C'est l'une des raisons pour lesquelles certaines personnes n'aiment pas vraiment l'h√©ritage classique dans la POO.  Et donc, ils pr√©f√®rent souvent la composition des classes, l'h√©ritage des interfaces, etc., etc.  au lieu de l'h√©ritage classique du comportement. <br><br>  En toute honn√™tet√©, certaines r√®gles ne risquent pas de violer le principe de substitution.  Vous pouvez vous prot√©ger autant que possible si vous interdisez toutes les structures dangereuses.  Par exemple, pour C ++, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oleg a</a> √©crit √† ce sujet.  Mais en g√©n√©ral, de telles r√®gles ne transforment pas les classes en classes au sens classique. <br><br>  En utilisant des m√©thodes administratives, la t√¢che n'est pas non plus tr√®s bien r√©solue.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire comment l'oncle Martin a fait en C ++ et comment cela n'a pas fonctionn√©. <br><br>  <b>Mais dans le vrai code industriel, bien souvent, le principe de Liskov est viol√©, et ce n'est pas effrayant</b> .  Il est difficile de suivre le principe, car  1) la responsabilit√© et la s√©mantique d'une classe ne sont souvent pas explicites et ne sont pas exprim√©es dans le code 2) la responsabilit√© d'une classe peut changer - √† la fois dans la classe de base et dans la classe descendante.  Mais cela n'entra√Æne pas toujours des cons√©quences vraiment terribles.  La violation la plus courante, la plus simple et la plus √©l√©mentaire est qu'une m√©thode substitu√©e modifie le comportement.  Comme par exemple ici: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.status = CLOSED ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectTask</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status == STARTED: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Cannot close a started Project Task"</span></span>) ...</code> </pre><br>  La m√©thode close de ProjectTask l√®vera une exception dans les cas o√π les objets de la classe Task fonctionnent correctement.  En g√©n√©ral, la red√©finition des m√©thodes d'une classe de base conduit tr√®s souvent √† une violation du principe de substitution, mais ne devient pas un probl√®me. <br><br>  En fait, dans ce cas, le d√©veloppeur ne per√ßoit pas l'h√©ritage comme une impl√©mentation de la relation ¬´IS¬ª, mais simplement comme un moyen de r√©utiliser le code.  C'est-√†-dire  une sous-classe n'est qu'une sous-classe, pas un sous-type.  Dans ce cas, d'un point de vue pragmatique et pratique, cela importe plus - mais quelle est la probabilit√© qu'il y aura ou existe d√©j√† du code client qui remarquera une s√©mantique diff√©rente des m√©thodes de la classe descendante et de la classe de base? <br><br>  Existe-t-il beaucoup de code qui attend un objet d'une classe de base, mais auquel nous passons l'objet de la classe descendante?  Pour de nombreuses t√¢ches, un tel code n'existera jamais du tout. <br><br>  Quand une violation LSP entra√Æne-t-elle de gros probl√®mes?  Lorsque, en raison de diff√©rences de comportement, le code client devra √™tre r√©√©crit avec des modifications dans la classe descendante et vice versa.  Cela devient particuli√®rement probl√©matique si ce code client est un code de biblioth√®que qui ne peut pas √™tre modifi√©.  Si la r√©utilisation du code ne sera pas en mesure de cr√©er des d√©pendances entre le code client et le code de classe √† l'avenir, m√™me en d√©pit de la violation du principe de substitution Liskov, un tel code ne peut pas causer de gros probl√®mes. <br><br>  En g√©n√©ral, pendant le d√©veloppement, l'h√©ritage peut √™tre consid√©r√© sous deux angles: les sous-classes sont des sous-types, avec toutes les limites de la programmation par contrat et le principe Lisk, et les sous-classes sont un moyen de r√©utiliser le code, avec tous ses probl√®mes potentiels.  C'est-√†-dire  vous pouvez soit penser et concevoir des responsabilit√©s et des contrats de classe et ne pas vous soucier du code client.  Soit pensez √† ce que pourrait √™tre le code c√¥t√© client, comment les classes seront utilis√©es et pr√©parez-vous aux probl√®mes potentiels, mais dans une moindre mesure, vous vous souciez du respect du principe de substitution.  La d√©cision, comme d'habitude, appartient au d√©veloppeur, le plus important est que le choix dans une situation particuli√®re soit conscient et qu'il y ait une compr√©hension des avantages, des inconv√©nients et des pi√®ges qui accompagnent telle ou telle solution. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463385/">https://habr.com/ru/post/fr463385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463367/index.html">Apprentissage automatique et th√©orie des contraintes</a></li>
<li><a href="../fr463369/index.html">√Ä propos des services pour les rendez-vous chez le m√©decin</a></li>
<li><a href="../fr463371/index.html">IT en dehors de Moscou</a></li>
<li><a href="../fr463373/index.html">Portfolio de conception UX: Meilleures pratiques</a></li>
<li><a href="../fr463375/index.html">Wine sur Windows 10. Cela fonctionne</a></li>
<li><a href="../fr463387/index.html">Path QA Fighter</a></li>
<li><a href="../fr463389/index.html">Personnalisez-le: comment nous travaillons avec les recommandations QIWI</a></li>
<li><a href="../fr463391/index.html">Comment √©pouser tout le monde (mariage √† un, deux et trois sexes) du point de vue des math√©matiques et pourquoi les hommes gagnent toujours</a></li>
<li><a href="../fr463393/index.html">Votre entreprise est-elle une famille ou une √©quipe sportive?</a></li>
<li><a href="../fr463397/index.html">March√© des changes et ing√©nierie financi√®re au Moyen √Çge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>