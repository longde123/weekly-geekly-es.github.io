<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞ üë©üèº‚Äç‚öñÔ∏è üí† Rendern von Schriftarten mit Abdeckungsmasken, Teil 1 ü¶Ñ üë©üèΩ‚Äçüè≠ üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als wir mit der Entwicklung unseres Leistungsprofilers begannen, wussten wir, dass wir fast das gesamte UI-Rendering selbst durchf√ºhren w√ºrden. Bald m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendern von Schriftarten mit Abdeckungsmasken, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="Bild"></div><br>  Als wir mit der Entwicklung unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsprofilers</a> begannen, wussten wir, dass wir fast das gesamte UI-Rendering selbst durchf√ºhren w√ºrden.  Bald mussten wir uns entscheiden, welchen Ansatz wir zum Rendern von Schriftarten w√§hlen sollten.  Wir hatten folgende Anforderungen: <br><br><ol><li>  Wir m√ºssen in der Lage sein, jede Schriftart beliebiger Gr√∂√üe in Echtzeit zu rendern, um sie an die Systemschriftarten und deren Gr√∂√üe anzupassen, die von Windows-Benutzern ausgew√§hlt wurden. </li><li>  Das Rendern von Schriftarten sollte sehr schnell sein. Beim Rendern von Schriftarten ist kein Bremsen zul√§ssig. </li><li>  Unsere Benutzeroberfl√§che verf√ºgt √ºber eine Reihe fl√ºssiger Animationen, sodass sich der Text reibungslos auf dem Bildschirm bewegen kann. </li><li>  Es sollte mit kleinen Schriftgr√∂√üen lesbar sein. </li></ol><br>  Da ich zu dieser Zeit kein gro√üer Spezialist war, suchte ich im Internet nach Informationen und fand viele Techniken zum Rendern von Schriftarten.  Ich habe auch mit dem technischen Direktor von Guerilla Games, Michail van der Leu, gesprochen.  Dieses Unternehmen experimentierte mit vielen M√∂glichkeiten zum Rendern von Schriftarten, und die Rendering-Engine war eine der besten der Welt.  Mihil skizzierte kurz seine Idee f√ºr eine neue Technik zum Rendern von Schriftarten.  Obwohl wir genug von den bereits verf√ºgbaren Techniken gehabt h√§tten, faszinierte mich diese Idee und ich begann sie umzusetzen, ohne auf die wunderbare Welt der Schriftwiedergabe zu achten, die sich mir √∂ffnete. <br><a name="habracut"></a><br>  In dieser Artikelserie werde ich die von uns verwendete Technik detailliert beschreiben und die Beschreibung in drei Teile unterteilen: <br><br><ul><li>  Im <strong>ersten Teil</strong> lernen wir, wie man Glyphen in Echtzeit mit 16xAA rendert, die aus einem einheitlichen Raster abgetastet wurden. </li><li>  Im <strong>zweiten Teil werden</strong> wir zum gedrehten Gitter √ºbergehen, um das Antialiasing horizontaler und vertikaler Kanten auf wunderbare Weise durchzuf√ºhren.  Wir werden auch sehen, wie der fertige Shader fast vollst√§ndig auf eine Textur und eine Nachschlagetabelle reduziert wird. </li><li>  Im <strong>dritten Teil</strong> lernen wir, wie Sie Glyphen mithilfe von Compute und CPU in Echtzeit rastern. </li></ul><br>  Sie k√∂nnen die fertigen Ergebnisse auch im Profiler anzeigen. Hier ist jedoch ein Beispiel f√ºr einen Bildschirm mit der mit unserem Font-Renderer gerenderten Segoe-UI-Schriftart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Hier ist eine Erh√∂hung des Buchstabens S, einer gerasterten Gr√∂√üe von nur 6x9 Texel.  Die urspr√ºnglichen Vektordaten werden als Pfad gerendert, und das gedrehte Abtastmuster wird aus gr√ºnen und roten Rechtecken gerendert.  Da es mit einer Aufl√∂sung von viel mehr als 6 √ó 9 gerendert wird, werden die Graustufen nicht im endg√ºltigen Pixelton dargestellt, sondern es wird der Farbton des Subpixels angezeigt.  Dies ist eine sehr n√ºtzliche Debugging-Visualisierung, um sicherzustellen, dass alle Berechnungen auf Subpixel-Ebene ordnungsgem√§√ü funktionieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Idee: Beschichtung statt Schatten lagern </h1><br>  Das Hauptproblem, mit dem sich Schriftrenderer befassen m√ºssen, ist die Anzeige skalierbarer Vektorschriftdaten in einem festen Pixelraster.  Die Methode des √úbergangs vom Vektorraum zu fertigen Pixeln in verschiedenen Techniken ist sehr unterschiedlich.  Bei den meisten dieser Techniken werden Kurvendaten vor dem Rendern in einen tempor√§ren Speicher (z. B. eine Textur) gerastert, um eine bestimmte Gr√∂√üe in Pixel zu erhalten.  Tempor√§rer Speicher wird als Glyphen-Cache verwendet: Wenn dieselbe Glyphe mehrmals gerendert wird, werden Glyphen aus dem Cache entnommen und wiederverwendet, um eine erneute Rasterung zu vermeiden. <br><br>  Der Unterschied in der Technik zeigt sich deutlich darin, wie Daten in einem Zwischendatenformat gespeichert werden.  Das Windows-Schriftsystem rastert beispielsweise Glyphen auf eine bestimmte Gr√∂√üe in Pixel.  Daten werden als <strong>Farbton</strong> pro Pixel gespeichert.  Der Farbton beschreibt die beste Ann√§herung an die Abdeckung durch die Glyphe dieses Pixels.  Beim Rendern werden die Pixel einfach aus dem Glyphencache in das Zielpixelraster kopiert.  Wenn Sie Daten in ein Pixelformat konvertieren, werden sie nicht gut skaliert. Beim Verkleinern werden daher unscharfe Glyphen angezeigt, und beim Vergr√∂√üern werden Glyphen angezeigt, in denen Bl√∂cke deutlich sichtbar sind.  Daher werden die Glyphen f√ºr jede endg√ºltige Gr√∂√üe in den Glyphencache gerendert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signierte Distanzfelder</a> verwenden einen anderen Ansatz.  Anstelle des Farbtons f√ºr das Pixel wird der <strong>Abstand</strong> zum n√§chsten Rand des Glyphen beibehalten.  Der Vorteil dieser Methode besteht darin, dass Daten bei gekr√ºmmten Kanten viel besser skaliert werden als Schattierungen.  Beim Vergr√∂√üern der Glyphe bleiben die Kurven glatt.  Der Nachteil dieses Ansatzes ist, dass gerade und scharfe Kanten gegl√§ttet werden.  Viel besser als SDF werden fortschrittliche L√∂sungen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeType erreicht</a> , in denen Farbdaten gespeichert werden. <br><br>  In F√§llen, in denen ein Farbton f√ºr ein Pixel beibehalten wird, m√ºssen Sie zuerst dessen Abdeckung berechnen.  Zum Beispiel enth√§lt stb_truetype gute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele daf√ºr,</a> wie Sie die Abdeckung und den Farbton berechnen k√∂nnen.  Eine andere beliebte Methode zur Ann√§herung an die Abdeckung besteht darin, die Glyphe mit einer h√∂heren Frequenz als der endg√ºltigen Aufl√∂sung abzutasten.  Dies z√§hlt die Anzahl der Abtastwerte, die in die Glyphe im Zielpixelbereich passen.  Die Anzahl der Treffer geteilt durch die maximale Anzahl m√∂glicher Samples bestimmt den Farbton.  Da die Abdeckung bereits f√ºr eine bestimmte Pixelgitteraufl√∂sung und <strong>-ausrichtung</strong> in einen Farbton konvertiert wurde, ist es unm√∂glich, Glyphen zwischen den Zielpixeln zu platzieren: Der Farbton kann die tats√§chliche Abdeckung mit Abtastwerten des Zielpixelfensters nicht korrekt wiedergeben.  Aus diesem Grund und aus einigen anderen Gr√ºnden, die wir sp√§ter betrachten werden, unterst√ºtzen solche Systeme keine Subpixel-Bewegung. <br><br>  Aber was ist, wenn wir die Glyphe zwischen den Pixeln frei bewegen m√ºssen?  Wenn der Farbton im Voraus berechnet wird, k√∂nnen wir nicht herausfinden, wie der Farbton sein soll, wenn Sie sich zwischen Pixeln im Zielpixelbereich bewegen.  Wir k√∂nnen jedoch die Konvertierung von der Abdeckung in den Farbton zum Zeitpunkt des Renderns verz√∂gern.  Dazu speichern wir nicht den Schatten, sondern die <strong>Beschichtung</strong> .  Wir tasten eine Glyphe mit einer Frequenz von 16 Zielaufl√∂sungen ab und speichern f√ºr jede Probe ein einzelnes Bit.  Bei der Abtastung in einem 4 √ó 4-Raster reicht es aus, nur 16 Bit pro Pixel zu speichern.  Dies wird unsere <strong>Deckmaske sein</strong> .  W√§hrend des Renderns m√ºssen wir z√§hlen, wie viele Bits in das Zielpixelfenster gelangen, das dieselbe Aufl√∂sung wie das Texel-Repository hat, aber nicht physisch daran gebunden ist.  Die folgende Animation zeigt einen Teil des Glyphen (blau), der in vier Texel gerastert ist.  Jedes Texel ist in ein Raster von 4 √ó 4 Zellen unterteilt.  Ein graues Rechteck zeigt ein Pixelfenster an, das sich dynamisch √ºber die Glyphe bewegt.  Zur Laufzeit wird die Anzahl der Abtastwerte, die in das Pixelfenster fallen, gez√§hlt, um den Farbton zu bestimmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Kurz zu den grundlegenden Techniken zum Rendern von Schriftarten </h2><br>  Bevor ich mit der Implementierung unseres Font-Rendering-Systems fortfahre, m√∂chte ich kurz auf die wichtigsten Techniken eingehen, die in diesem Prozess verwendet werden: Hinweise auf Font und Subpixel-Rendering (diese Technik wird unter Windows als ClearType bezeichnet).  Sie k√∂nnen diesen Abschnitt √ºberspringen, wenn Sie nur an Antialiasing-Techniken interessiert sind. <br><br>  W√§hrend der Implementierung des Renderers habe ich immer mehr √ºber die lange Geschichte der Entwicklung des Font-Renderings erfahren.  Die Forschung konzentriert sich ausschlie√ülich auf den einzigen Aspekt der Schriftwiedergabe - die Lesbarkeit bei kleinen Gr√∂√üen.  Das Erstellen eines hervorragenden Renderers f√ºr gro√üe Schriftarten ist recht einfach, aber es ist unglaublich schwierig, ein System zu schreiben, das die Lesbarkeit bei kleinen Gr√∂√üen gew√§hrleistet.  Das Studium der Schriftwiedergabe hat eine lange Geschichte, die in ihrer Tiefe auff√§llt.  Lesen Sie zum Beispiel √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raster-Trag√∂die</a> .  Es ist logisch, dass dies das Hauptproblem f√ºr Computerspezialisten war, da in den fr√ºhen Stadien von Computern die Bildschirmaufl√∂sung ziemlich niedrig war.  Dies muss eine der ersten Aufgaben gewesen sein, mit denen sich Betriebssystementwickler befassen mussten: Wie kann Text auf Ger√§ten mit niedriger Bildschirmaufl√∂sung lesbar gemacht werden?  Zu meiner √úberraschung sind hochwertige Schriftwiedergabesysteme sehr pixelorientiert.  Beispielsweise wird eine Glyphe so konstruiert, dass sie am Rand des Pixels beginnt, ihre Breite ein Vielfaches der Anzahl der Pixel betr√§gt und der Inhalt an die Pixel angepasst wird.  Diese Technik wird als Vernetzung bezeichnet.  Ich bin es gewohnt, mit Computerspielen und 3D-Grafiken zu arbeiten, bei denen die Welt aus Einheiten besteht und in Pixel projiziert wird. Ich war also ein wenig √ºberrascht.  Ich fand heraus, dass dies im Bereich der Schriftwiedergabe eine sehr wichtige Wahl ist. <br><br>  Schauen wir uns ein m√∂gliches Szenario f√ºr die Glyphenrasterung an, um die Bedeutung der Vernetzung zu demonstrieren.  Stellen Sie sich vor, eine Glyphe wird auf einem Pixelraster gerastert, aber die Form der Glyphe stimmt nicht perfekt mit der Rasterstruktur √ºberein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  Durch Antialiasing werden die Pixel rechts und links von der Glyphe gleich grau.  Wenn die Glyphe leicht verschoben wird, damit sie besser mit den R√§ndern der Pixel √ºbereinstimmt, wird nur ein Pixel gef√§rbt und vollst√§ndig schwarz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Jetzt, da die Glyphe gut mit den Pixeln √ºbereinstimmt, sind die Farben weniger verschwommen.  Der Unterschied in der Sch√§rfe ist sehr gro√ü.  Westliche Schriftarten haben viele Glyphen mit horizontalen und vertikalen Linien. Wenn sie nicht gut mit dem Pixelraster √ºbereinstimmen, verschwimmen die Graustufen durch die Graustufen.  Selbst die beste Anti-Aliasing-Technik kann dieses Problem nicht bew√§ltigen. <br><br>  Als L√∂sung wurde ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis auf Schriftarten</a> vorgeschlagen.  Schriftautoren sollten ihren Schriftarten Informationen dar√ºber hinzuf√ºgen, wie Glyphen an Pixeln ausgerichtet werden sollen, wenn sie nicht perfekt passen.  Das Schriftwiedergabesystem verzerrt diese Kurven, um sie am Pixelraster auszurichten.  Dies erh√∂ht die Klarheit der Schriftart erheblich, hat jedoch einen Preis: <br><br><ul><li>  Schriftarten werden leicht <em>verzerrt</em> .  Schriftarten sehen nicht genau wie beabsichtigt aus. </li><li>  Alle Glyphen m√ºssen an das Pixelraster angeh√§ngt werden: der Anfang der Glyphe und die Breite der Glyphe.  Daher ist es unm√∂glich, sie zwischen Pixeln zu animieren. </li></ul><br>  Interessanterweise gingen Apple und Microsoft bei der L√∂sung dieses Problems unterschiedliche Wege.  Microsoft h√§lt an absoluter Klarheit fest, und Apple versucht, Schriftarten genauer anzuzeigen.  Im Internet finden Sie Leute, die sich √ºber verschwommene Schriftarten auf Apple-Computern beschweren, aber viele Leute m√∂gen, was sie auf Apple sehen.  Das ist teilweise Geschmackssache.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Beitrag von Joel √ºber Software und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier der</a> Beitrag von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Bilak</a> zu diesem Thema. Wenn Sie jedoch im Internet suchen, finden Sie viel mehr Informationen. <br><br>  Da die DPI-Aufl√∂sung in modernen Bildschirmen rapide zunimmt, stellt sich die Frage, ob in Zukunft wie heute Hinweise auf Schriftarten erforderlich sind.  In meinem aktuellen Zustand finde ich Schriftarten, die eine sehr wertvolle Technik zum klaren Rendern von Schriftarten darstellen.  Die in meinem Artikel beschriebene Technik k√∂nnte jedoch in Zukunft eine interessante Alternative werden, da Glyphen ohne Verzerrung frei auf der Leinwand platziert werden k√∂nnen.  Und da dies im Wesentlichen eine Anti-Aliasing-Technik ist, kann sie f√ºr jeden Zweck verwendet werden und nicht nur zum Rendern von Schriftarten. <br><br>  Abschlie√üend werde ich kurz auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendern</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subpixeln eingehen</a> .  In der Vergangenheit wurde den Menschen klar, dass Sie die horizontale Aufl√∂sung des Bildschirms mithilfe der einzelnen roten, gr√ºnen und blauen Strahlen eines Computermonitors verdreifachen k√∂nnen.  Jedes Pixel wird aus diesen Strahlen aufgebaut, die physikalisch getrennt sind.  Unser Auge mischt ihre Werte und erzeugt eine einzelne Pixelfarbe.  Wenn die Glyphe nur einen Teil des Pixels bedeckt, wird nur der Strahl eingeschaltet, der der Glyphe √ºberlagert ist, wodurch sich die horizontale Aufl√∂sung verdreifacht.  Wenn Sie das Bildschirmbild mit einer Technik wie ClearType vergr√∂√üern, k√∂nnen Sie die Farben an den R√§ndern des Glyphen sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Interessanterweise kann der Ansatz, den ich in diesem Artikel diskutieren werde, auf das Rendern von Subpixeln erweitert werden.  Ich habe den Prototyp bereits implementiert.  Der einzige Nachteil ist, dass wir aufgrund der zus√§tzlichen Filterung in Techniken wie ClearType mehr Texturproben nehmen m√ºssen.  Vielleicht werde ich das in Zukunft in Betracht ziehen. <br><br><h1>  Glyphen-Rendering mit einem einheitlichen Raster </h1><br>  Angenommen, wir haben eine Glyphe mit einer 16-fachen Aufl√∂sung des Ziels abgetastet und in einer Textur gespeichert.  Wie das geht, werde ich im dritten Teil des Artikels beschreiben.  Ein Abtastmuster ist ein einheitliches Gitter, dh 16 Abtastpunkte sind gleichm√§√üig √ºber das Texel verteilt.  Jede Glyphe wird mit der gleichen Aufl√∂sung wie die Zielaufl√∂sung gerendert, wir speichern 16 Bits pro Texel und jedes Bit entspricht einem Sample.  Wie wir bei der Berechnung der Abdeckungsmaske sehen werden, ist die Speicherreihenfolge der Proben wichtig.  Im Allgemeinen sehen die Abtastpunkte und ihre Positionen f√ºr ein Texel folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Texel bekommen </h2><br>  Wir werden das Pixelfenster um die in den Texeln gespeicherten Abdeckungsbits verschieben.  Wir m√ºssen die folgende Frage beantworten: Wie viele Samples werden in unser Pixelfenster gelangen?  Es wird durch das folgende Bild veranschaulicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Hier sehen wir vier Texel, denen teilweise eine Glyphe √ºberlagert ist.  Ein Pixel (blau markiert) bedeckt einen Teil der Texel.  Wir m√ºssen bestimmen, wie viele Abtastwerte unser Pixelfenster kreuzt.  Zuerst brauchen wir folgendes: <br><br><ul><li>  Berechnen Sie die relative Position des Pixelfensters im Vergleich zu 4 Texeln. </li><li>  Holen Sie sich die Texel, mit denen sich unser Pixelfenster schneidet. </li></ul><br>  Unsere Implementierung basiert auf OpenGL, daher beginnt der Ursprung des Texturraums unten links.  Beginnen wir mit der Berechnung der relativen Position des Pixelfensters.  Die an den Pixel-Shader √ºbergebene UV-Koordinate ist die UV-Koordinate der Pixelmitte.  Unter der Annahme, dass UVs normalisiert sind, k√∂nnen wir UVs zun√§chst in Texelraum konvertieren, indem wir sie mit der Gr√∂√üe der Textur multiplizieren.  Wenn Sie 0,5 von der Mitte des Pixels abziehen, erhalten Sie die untere linke Ecke des Pixelfensters.  Durch Abrunden dieses Wertes berechnen wir die untere linke Position des linken unteren Texels.  Das Bild zeigt ein Beispiel f√ºr diese drei Punkte im Texelraum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  Der Unterschied zwischen der unteren linken Ecke des Pixels und der unteren linken Ecke des Texelgitters ist die relative Position des Pixelfensters in normalisierten Koordinaten.  In diesem Bild betr√§gt die Position des Pixelfensters [0,69, 0,37].  Im Code: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Mit der Anweisung texturGather k√∂nnen vier Texel gleichzeitig abgerufen werden.  Es ist nur in OpenGL 4.0 und h√∂her verf√ºgbar, sodass Sie stattdessen vier texelFetch ausf√ºhren k√∂nnen.  Wenn wir nur die Textur-Gather-UV-Koordinaten √ºbergeben, entsteht bei einer perfekten √úbereinstimmung des Pixelfensters mit dem Texel ein Problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Hier sehen wir drei horizontale Texel mit einem Pixelfenster (blau dargestellt), das genau zum zentralen Texel passt.  Das berechnete Gewicht liegt nahe bei 1,0, aber textureGather w√§hlte stattdessen das mittlere und das rechte Texel.  Der Grund daf√ºr ist, dass die von textureGather durchgef√ºhrten Berechnungen geringf√ºgig von der Berechnung des Gleitkommagewichts abweichen k√∂nnen.  Der Unterschied bei der Abrundung von GPU-Berechnungen und Gleitkomma-Gewichtsberechnungen f√ºhrt zu St√∂rungen um die Pixelzentren. <br><br>  Um dieses Problem zu l√∂sen, m√ºssen Sie sicherstellen, dass die Gewichtsberechnungen garantiert mit der Textur-Gather-Stichprobe √ºbereinstimmen.  Zu diesem Zweck werden niemals Pixelzentren abgetastet, sondern immer in der Mitte des 2 √ó 2-Texelgitters.  Aus der berechneten und bereits abgerundeten unteren Position des linken Texels f√ºgen wir das vollst√§ndige Texel hinzu, um in die Mitte des Texelgitters zu gelangen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Dieses Bild zeigt, dass bei Verwendung der Mitte des Texelgitters die vier von textureGather aufgenommenen Abtastpunkte immer in der Mitte der Texel liegen.  Im Code: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  Horizontale Maske des Pixelfensters </h2><br>  Wir haben vier Texel und zusammen bilden sie ein Raster von 8 √ó 8 Abdeckungsbits.  Um die Bits in einem Pixelfenster zu z√§hlen, m√ºssen wir zuerst die Bits au√üerhalb des Pixelfensters zur√ºcksetzen.  Dazu erstellen wir eine Pixelfenstermaske und f√ºhren ein bitweises UND zwischen der Pixelmaske und den Texelabdeckungsmasken durch.  Horizontale und vertikale Maskierung werden getrennt durchgef√ºhrt. <br><br>  Die horizontale Pixelmaske sollte sich zusammen mit dem horizontalen Gewicht bewegen, wie in dieser Animation gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  Das Bild zeigt eine 8-Bit-Maske mit dem Wert 0x0F0 nach rechts verschoben (Nullen werden links eingef√ºgt).  In der Animation wird eine Maske linear mit dem Gewicht animiert, in der Realit√§t ist eine Bitverschiebung jedoch eine schrittweise Operation.  Die Maske √§ndert ihren Wert, wenn das Pixelfenster den Rand des Samples √ºberschreitet.  In der n√§chsten Animation wird dies in roten und gr√ºnen Spalten angezeigt, die Schritt f√ºr Schritt animiert werden.  Der Wert √§ndert sich nur, wenn sich die Zentren der Stichproben schneiden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Damit sich die Maske nur in der Mitte der Zelle, aber nicht an ihren R√§ndern bewegt, reicht eine einfache Rundung aus: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Jetzt haben wir eine Pixelmaske aus einer vollst√§ndigen 8-Bit-Zeichenfolge, die zwei Texel umfasst.  Wenn wir den richtigen Speichertyp in unserer 16-Bit-Abdeckungsmaske ausw√§hlen, gibt es M√∂glichkeiten, linkes und rechtes Texel zu kombinieren und eine horizontale Pixelmaskierung f√ºr jeweils eine vollst√§ndige 8-Bit-Zeile durchzuf√ºhren.  Dies wird jedoch bei der vertikalen Maskierung problematisch, wenn wir zu gedrehten Gittern wechseln.  Daher kombinieren wir stattdessen zwei linke und zwei rechte Texel miteinander, um zwei 32-Bit-Abdeckungsmasken zu erstellen.  Wir maskieren die linken und rechten Ergebnisse getrennt. <br><br>  Masken f√ºr linke Texel verwenden die oberen 4 Bits der Pixelmaske, und Masken f√ºr rechte Texel verwenden die unteren 4 Bits.  In einem einheitlichen Raster hat jede Zeile dieselbe horizontale Maske, sodass wir die Maske f√ºr jede Zeile einfach kopieren k√∂nnen. Danach ist die horizontale Maske fertig: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Zum Maskieren kombinieren wir zwei linke und zwei rechte Texel und maskieren dann die horizontalen Linien: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Das Ergebnis k√∂nnte nun so aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  Wir k√∂nnen die Bits dieses Ergebnisses bereits mit der Anweisung bitCount z√§hlen.  Wir sollten nicht durch 16, sondern durch 32 teilen, da wir nach der vertikalen Maskierung immer noch 32 potenzielle Bits haben k√∂nnen und nicht 16. Hier ist das vollst√§ndige Rendern des Glyphen in diesem Stadium: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Hier sehen wir einen vergr√∂√üerten Buchstaben S, der basierend auf den urspr√ºnglichen Vektordaten (wei√üer Umriss) und der Visualisierung der Abtastpunkte gerendert wurde.  Wenn der Punkt gr√ºn ist, befindet er sich innerhalb der Glyphe, wenn rot, dann nicht.  Graustufen zeigt die zu diesem Zeitpunkt berechneten Farbt√∂ne an.  Beim Rendern von Schriftarten gibt es viele M√∂glichkeiten f√ºr Fehler, von der Rasterung √ºber die Speicherung von Daten in einem Texturatlas bis hin zur Berechnung des endg√ºltigen Farbtons.  Solche Visualisierungen sind unglaublich n√ºtzlich f√ºr die Validierung von Berechnungen.  Sie sind besonders wichtig f√ºr das Debuggen von Artefakten auf Subpixel-Ebene. <br><br><h2>  Vertikale Maskierung </h2><br>  Jetzt sind wir bereit, die vertikalen Bits zu maskieren.  Um vertikal zu maskieren, verwenden wir eine etwas andere Methode.  Um mit der vertikalen Verschiebung fertig zu werden, ist es wichtig, sich daran zu erinnern, wie wir die Bits gespeichert haben: in zeilenweiser Reihenfolge.  Die unterste Zeile sind die vier niedrigstwertigen Bits, und die oberste Zeile sind die vier h√∂chstwertigen Bits.  Wir k√∂nnen einfach eins nach dem anderen reinigen und sie basierend auf der vertikalen Position des Pixelfensters verschieben. <br><br>  Wir werden eine einzige Maske erstellen, die die gesamte H√∂he von zwei Texeln abdeckt.  Infolgedessen m√∂chten wir vier <strong>vollst√§ndige</strong> Zeilen Texel speichern und den Rest maskieren, dh die Maske besteht aus 4 √ó 4 Bits, was 0xFFFF entspricht.  Basierend auf der Position des Pixelfensters verschieben wir die unteren Linien und l√∂schen die oberen Linien. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  Infolgedessen haben wir auch die vertikalen Bits au√üerhalb des Pixelfensters maskiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Jetzt reicht es aus, die in den Texeln verbleibenden Bits zu z√§hlen, was mit der bitCount-Operation m√∂glich ist. Teilen Sie dann das Ergebnis durch 16 und erhalten Sie den gew√ºnschten Farbton! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Jetzt sieht das vollst√§ndige Rendern des Briefes folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  Fortsetzung folgt ... </h1><br>  Im zweiten Teil werden wir den n√§chsten Schritt machen und sehen, wie Sie diese Technik auf gedrehte Gitter anwenden k√∂nnen.  Wir werden dieses Schema berechnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  Und wir werden sehen, dass fast alles auf mehrere Tabellen reduziert werden kann. <br><br>  Vielen Dank an Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">@SebAaltonen</a> ) f√ºr seine Hilfe bei der L√∂sung des TexturGather-Problems und nat√ºrlich an Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">@MvdleeuwGG</a> ) f√ºr seine Ideen und interessanten Gespr√§che am Abend. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433670/">https://habr.com/ru/post/de433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433652/index.html">5G durch die Augen der Benutzer. Erwartungen und Bedenken</a></li>
<li><a href="../de433658/index.html">IT in Deutschland - wie man Arbeit in Gro√üst√§dten in Deutschland sucht</a></li>
<li><a href="../de433660/index.html">Wie ich zum f√ºnften Mal im DefCamp gesprochen habe</a></li>
<li><a href="../de433664/index.html">SATA SSD Enterprise im Infortrend 2-Controller-Speicher - Leistungsmessung</a></li>
<li><a href="../de433666/index.html">Funcorp W√∂rterbuch</a></li>
<li><a href="../de433672/index.html">Leute, ist Ruby tot oder nicht?</a></li>
<li><a href="../de433674/index.html">Der Testtunnel der Boring Company wird heute Abend in Kalifornien er√∂ffnet</a></li>
<li><a href="../de433676/index.html">Wer verdient mehr Geld in der IT: B√ºro- oder Remote-Mitarbeiter?</a></li>
<li><a href="../de433678/index.html">Krypto-Hacking - eine neue Art von Angriff auf das Rechenzentrum</a></li>
<li><a href="../de433680/index.html">Winterereignisse f√ºr die Spielebranche im HSE- und Desktop-Gamedev-Simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>