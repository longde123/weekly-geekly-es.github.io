<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰 👩🏼‍⚖️ 💠 Rendern von Schriftarten mit Abdeckungsmasken, Teil 1 🦄 👩🏽‍🏭 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als wir mit der Entwicklung unseres Leistungsprofilers begannen, wussten wir, dass wir fast das gesamte UI-Rendering selbst durchführen würden. Bald m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendern von Schriftarten mit Abdeckungsmasken, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="Bild"></div><br>  Als wir mit der Entwicklung unseres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsprofilers</a> begannen, wussten wir, dass wir fast das gesamte UI-Rendering selbst durchführen würden.  Bald mussten wir uns entscheiden, welchen Ansatz wir zum Rendern von Schriftarten wählen sollten.  Wir hatten folgende Anforderungen: <br><br><ol><li>  Wir müssen in der Lage sein, jede Schriftart beliebiger Größe in Echtzeit zu rendern, um sie an die Systemschriftarten und deren Größe anzupassen, die von Windows-Benutzern ausgewählt wurden. </li><li>  Das Rendern von Schriftarten sollte sehr schnell sein. Beim Rendern von Schriftarten ist kein Bremsen zulässig. </li><li>  Unsere Benutzeroberfläche verfügt über eine Reihe flüssiger Animationen, sodass sich der Text reibungslos auf dem Bildschirm bewegen kann. </li><li>  Es sollte mit kleinen Schriftgrößen lesbar sein. </li></ol><br>  Da ich zu dieser Zeit kein großer Spezialist war, suchte ich im Internet nach Informationen und fand viele Techniken zum Rendern von Schriftarten.  Ich habe auch mit dem technischen Direktor von Guerilla Games, Michail van der Leu, gesprochen.  Dieses Unternehmen experimentierte mit vielen Möglichkeiten zum Rendern von Schriftarten, und die Rendering-Engine war eine der besten der Welt.  Mihil skizzierte kurz seine Idee für eine neue Technik zum Rendern von Schriftarten.  Obwohl wir genug von den bereits verfügbaren Techniken gehabt hätten, faszinierte mich diese Idee und ich begann sie umzusetzen, ohne auf die wunderbare Welt der Schriftwiedergabe zu achten, die sich mir öffnete. <br><a name="habracut"></a><br>  In dieser Artikelserie werde ich die von uns verwendete Technik detailliert beschreiben und die Beschreibung in drei Teile unterteilen: <br><br><ul><li>  Im <strong>ersten Teil</strong> lernen wir, wie man Glyphen in Echtzeit mit 16xAA rendert, die aus einem einheitlichen Raster abgetastet wurden. </li><li>  Im <strong>zweiten Teil werden</strong> wir zum gedrehten Gitter übergehen, um das Antialiasing horizontaler und vertikaler Kanten auf wunderbare Weise durchzuführen.  Wir werden auch sehen, wie der fertige Shader fast vollständig auf eine Textur und eine Nachschlagetabelle reduziert wird. </li><li>  Im <strong>dritten Teil</strong> lernen wir, wie Sie Glyphen mithilfe von Compute und CPU in Echtzeit rastern. </li></ul><br>  Sie können die fertigen Ergebnisse auch im Profiler anzeigen. Hier ist jedoch ein Beispiel für einen Bildschirm mit der mit unserem Font-Renderer gerenderten Segoe-UI-Schriftart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Hier ist eine Erhöhung des Buchstabens S, einer gerasterten Größe von nur 6x9 Texel.  Die ursprünglichen Vektordaten werden als Pfad gerendert, und das gedrehte Abtastmuster wird aus grünen und roten Rechtecken gerendert.  Da es mit einer Auflösung von viel mehr als 6 × 9 gerendert wird, werden die Graustufen nicht im endgültigen Pixelton dargestellt, sondern es wird der Farbton des Subpixels angezeigt.  Dies ist eine sehr nützliche Debugging-Visualisierung, um sicherzustellen, dass alle Berechnungen auf Subpixel-Ebene ordnungsgemäß funktionieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Idee: Beschichtung statt Schatten lagern </h1><br>  Das Hauptproblem, mit dem sich Schriftrenderer befassen müssen, ist die Anzeige skalierbarer Vektorschriftdaten in einem festen Pixelraster.  Die Methode des Übergangs vom Vektorraum zu fertigen Pixeln in verschiedenen Techniken ist sehr unterschiedlich.  Bei den meisten dieser Techniken werden Kurvendaten vor dem Rendern in einen temporären Speicher (z. B. eine Textur) gerastert, um eine bestimmte Größe in Pixel zu erhalten.  Temporärer Speicher wird als Glyphen-Cache verwendet: Wenn dieselbe Glyphe mehrmals gerendert wird, werden Glyphen aus dem Cache entnommen und wiederverwendet, um eine erneute Rasterung zu vermeiden. <br><br>  Der Unterschied in der Technik zeigt sich deutlich darin, wie Daten in einem Zwischendatenformat gespeichert werden.  Das Windows-Schriftsystem rastert beispielsweise Glyphen auf eine bestimmte Größe in Pixel.  Daten werden als <strong>Farbton</strong> pro Pixel gespeichert.  Der Farbton beschreibt die beste Annäherung an die Abdeckung durch die Glyphe dieses Pixels.  Beim Rendern werden die Pixel einfach aus dem Glyphencache in das Zielpixelraster kopiert.  Wenn Sie Daten in ein Pixelformat konvertieren, werden sie nicht gut skaliert. Beim Verkleinern werden daher unscharfe Glyphen angezeigt, und beim Vergrößern werden Glyphen angezeigt, in denen Blöcke deutlich sichtbar sind.  Daher werden die Glyphen für jede endgültige Größe in den Glyphencache gerendert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signierte Distanzfelder</a> verwenden einen anderen Ansatz.  Anstelle des Farbtons für das Pixel wird der <strong>Abstand</strong> zum nächsten Rand des Glyphen beibehalten.  Der Vorteil dieser Methode besteht darin, dass Daten bei gekrümmten Kanten viel besser skaliert werden als Schattierungen.  Beim Vergrößern der Glyphe bleiben die Kurven glatt.  Der Nachteil dieses Ansatzes ist, dass gerade und scharfe Kanten geglättet werden.  Viel besser als SDF werden fortschrittliche Lösungen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeType erreicht</a> , in denen Farbdaten gespeichert werden. <br><br>  In Fällen, in denen ein Farbton für ein Pixel beibehalten wird, müssen Sie zuerst dessen Abdeckung berechnen.  Zum Beispiel enthält stb_truetype gute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele dafür,</a> wie Sie die Abdeckung und den Farbton berechnen können.  Eine andere beliebte Methode zur Annäherung an die Abdeckung besteht darin, die Glyphe mit einer höheren Frequenz als der endgültigen Auflösung abzutasten.  Dies zählt die Anzahl der Abtastwerte, die in die Glyphe im Zielpixelbereich passen.  Die Anzahl der Treffer geteilt durch die maximale Anzahl möglicher Samples bestimmt den Farbton.  Da die Abdeckung bereits für eine bestimmte Pixelgitterauflösung und <strong>-ausrichtung</strong> in einen Farbton konvertiert wurde, ist es unmöglich, Glyphen zwischen den Zielpixeln zu platzieren: Der Farbton kann die tatsächliche Abdeckung mit Abtastwerten des Zielpixelfensters nicht korrekt wiedergeben.  Aus diesem Grund und aus einigen anderen Gründen, die wir später betrachten werden, unterstützen solche Systeme keine Subpixel-Bewegung. <br><br>  Aber was ist, wenn wir die Glyphe zwischen den Pixeln frei bewegen müssen?  Wenn der Farbton im Voraus berechnet wird, können wir nicht herausfinden, wie der Farbton sein soll, wenn Sie sich zwischen Pixeln im Zielpixelbereich bewegen.  Wir können jedoch die Konvertierung von der Abdeckung in den Farbton zum Zeitpunkt des Renderns verzögern.  Dazu speichern wir nicht den Schatten, sondern die <strong>Beschichtung</strong> .  Wir tasten eine Glyphe mit einer Frequenz von 16 Zielauflösungen ab und speichern für jede Probe ein einzelnes Bit.  Bei der Abtastung in einem 4 × 4-Raster reicht es aus, nur 16 Bit pro Pixel zu speichern.  Dies wird unsere <strong>Deckmaske sein</strong> .  Während des Renderns müssen wir zählen, wie viele Bits in das Zielpixelfenster gelangen, das dieselbe Auflösung wie das Texel-Repository hat, aber nicht physisch daran gebunden ist.  Die folgende Animation zeigt einen Teil des Glyphen (blau), der in vier Texel gerastert ist.  Jedes Texel ist in ein Raster von 4 × 4 Zellen unterteilt.  Ein graues Rechteck zeigt ein Pixelfenster an, das sich dynamisch über die Glyphe bewegt.  Zur Laufzeit wird die Anzahl der Abtastwerte, die in das Pixelfenster fallen, gezählt, um den Farbton zu bestimmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Kurz zu den grundlegenden Techniken zum Rendern von Schriftarten </h2><br>  Bevor ich mit der Implementierung unseres Font-Rendering-Systems fortfahre, möchte ich kurz auf die wichtigsten Techniken eingehen, die in diesem Prozess verwendet werden: Hinweise auf Font und Subpixel-Rendering (diese Technik wird unter Windows als ClearType bezeichnet).  Sie können diesen Abschnitt überspringen, wenn Sie nur an Antialiasing-Techniken interessiert sind. <br><br>  Während der Implementierung des Renderers habe ich immer mehr über die lange Geschichte der Entwicklung des Font-Renderings erfahren.  Die Forschung konzentriert sich ausschließlich auf den einzigen Aspekt der Schriftwiedergabe - die Lesbarkeit bei kleinen Größen.  Das Erstellen eines hervorragenden Renderers für große Schriftarten ist recht einfach, aber es ist unglaublich schwierig, ein System zu schreiben, das die Lesbarkeit bei kleinen Größen gewährleistet.  Das Studium der Schriftwiedergabe hat eine lange Geschichte, die in ihrer Tiefe auffällt.  Lesen Sie zum Beispiel über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raster-Tragödie</a> .  Es ist logisch, dass dies das Hauptproblem für Computerspezialisten war, da in den frühen Stadien von Computern die Bildschirmauflösung ziemlich niedrig war.  Dies muss eine der ersten Aufgaben gewesen sein, mit denen sich Betriebssystementwickler befassen mussten: Wie kann Text auf Geräten mit niedriger Bildschirmauflösung lesbar gemacht werden?  Zu meiner Überraschung sind hochwertige Schriftwiedergabesysteme sehr pixelorientiert.  Beispielsweise wird eine Glyphe so konstruiert, dass sie am Rand des Pixels beginnt, ihre Breite ein Vielfaches der Anzahl der Pixel beträgt und der Inhalt an die Pixel angepasst wird.  Diese Technik wird als Vernetzung bezeichnet.  Ich bin es gewohnt, mit Computerspielen und 3D-Grafiken zu arbeiten, bei denen die Welt aus Einheiten besteht und in Pixel projiziert wird. Ich war also ein wenig überrascht.  Ich fand heraus, dass dies im Bereich der Schriftwiedergabe eine sehr wichtige Wahl ist. <br><br>  Schauen wir uns ein mögliches Szenario für die Glyphenrasterung an, um die Bedeutung der Vernetzung zu demonstrieren.  Stellen Sie sich vor, eine Glyphe wird auf einem Pixelraster gerastert, aber die Form der Glyphe stimmt nicht perfekt mit der Rasterstruktur überein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  Durch Antialiasing werden die Pixel rechts und links von der Glyphe gleich grau.  Wenn die Glyphe leicht verschoben wird, damit sie besser mit den Rändern der Pixel übereinstimmt, wird nur ein Pixel gefärbt und vollständig schwarz: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Jetzt, da die Glyphe gut mit den Pixeln übereinstimmt, sind die Farben weniger verschwommen.  Der Unterschied in der Schärfe ist sehr groß.  Westliche Schriftarten haben viele Glyphen mit horizontalen und vertikalen Linien. Wenn sie nicht gut mit dem Pixelraster übereinstimmen, verschwimmen die Graustufen durch die Graustufen.  Selbst die beste Anti-Aliasing-Technik kann dieses Problem nicht bewältigen. <br><br>  Als Lösung wurde ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinweis auf Schriftarten</a> vorgeschlagen.  Schriftautoren sollten ihren Schriftarten Informationen darüber hinzufügen, wie Glyphen an Pixeln ausgerichtet werden sollen, wenn sie nicht perfekt passen.  Das Schriftwiedergabesystem verzerrt diese Kurven, um sie am Pixelraster auszurichten.  Dies erhöht die Klarheit der Schriftart erheblich, hat jedoch einen Preis: <br><br><ul><li>  Schriftarten werden leicht <em>verzerrt</em> .  Schriftarten sehen nicht genau wie beabsichtigt aus. </li><li>  Alle Glyphen müssen an das Pixelraster angehängt werden: der Anfang der Glyphe und die Breite der Glyphe.  Daher ist es unmöglich, sie zwischen Pixeln zu animieren. </li></ul><br>  Interessanterweise gingen Apple und Microsoft bei der Lösung dieses Problems unterschiedliche Wege.  Microsoft hält an absoluter Klarheit fest, und Apple versucht, Schriftarten genauer anzuzeigen.  Im Internet finden Sie Leute, die sich über verschwommene Schriftarten auf Apple-Computern beschweren, aber viele Leute mögen, was sie auf Apple sehen.  Das ist teilweise Geschmackssache.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Beitrag von Joel über Software und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier der</a> Beitrag von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peter Bilak</a> zu diesem Thema. Wenn Sie jedoch im Internet suchen, finden Sie viel mehr Informationen. <br><br>  Da die DPI-Auflösung in modernen Bildschirmen rapide zunimmt, stellt sich die Frage, ob in Zukunft wie heute Hinweise auf Schriftarten erforderlich sind.  In meinem aktuellen Zustand finde ich Schriftarten, die eine sehr wertvolle Technik zum klaren Rendern von Schriftarten darstellen.  Die in meinem Artikel beschriebene Technik könnte jedoch in Zukunft eine interessante Alternative werden, da Glyphen ohne Verzerrung frei auf der Leinwand platziert werden können.  Und da dies im Wesentlichen eine Anti-Aliasing-Technik ist, kann sie für jeden Zweck verwendet werden und nicht nur zum Rendern von Schriftarten. <br><br>  Abschließend werde ich kurz auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendern</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subpixeln eingehen</a> .  In der Vergangenheit wurde den Menschen klar, dass Sie die horizontale Auflösung des Bildschirms mithilfe der einzelnen roten, grünen und blauen Strahlen eines Computermonitors verdreifachen können.  Jedes Pixel wird aus diesen Strahlen aufgebaut, die physikalisch getrennt sind.  Unser Auge mischt ihre Werte und erzeugt eine einzelne Pixelfarbe.  Wenn die Glyphe nur einen Teil des Pixels bedeckt, wird nur der Strahl eingeschaltet, der der Glyphe überlagert ist, wodurch sich die horizontale Auflösung verdreifacht.  Wenn Sie das Bildschirmbild mit einer Technik wie ClearType vergrößern, können Sie die Farben an den Rändern des Glyphen sehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Interessanterweise kann der Ansatz, den ich in diesem Artikel diskutieren werde, auf das Rendern von Subpixeln erweitert werden.  Ich habe den Prototyp bereits implementiert.  Der einzige Nachteil ist, dass wir aufgrund der zusätzlichen Filterung in Techniken wie ClearType mehr Texturproben nehmen müssen.  Vielleicht werde ich das in Zukunft in Betracht ziehen. <br><br><h1>  Glyphen-Rendering mit einem einheitlichen Raster </h1><br>  Angenommen, wir haben eine Glyphe mit einer 16-fachen Auflösung des Ziels abgetastet und in einer Textur gespeichert.  Wie das geht, werde ich im dritten Teil des Artikels beschreiben.  Ein Abtastmuster ist ein einheitliches Gitter, dh 16 Abtastpunkte sind gleichmäßig über das Texel verteilt.  Jede Glyphe wird mit der gleichen Auflösung wie die Zielauflösung gerendert, wir speichern 16 Bits pro Texel und jedes Bit entspricht einem Sample.  Wie wir bei der Berechnung der Abdeckungsmaske sehen werden, ist die Speicherreihenfolge der Proben wichtig.  Im Allgemeinen sehen die Abtastpunkte und ihre Positionen für ein Texel folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Texel bekommen </h2><br>  Wir werden das Pixelfenster um die in den Texeln gespeicherten Abdeckungsbits verschieben.  Wir müssen die folgende Frage beantworten: Wie viele Samples werden in unser Pixelfenster gelangen?  Es wird durch das folgende Bild veranschaulicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Hier sehen wir vier Texel, denen teilweise eine Glyphe überlagert ist.  Ein Pixel (blau markiert) bedeckt einen Teil der Texel.  Wir müssen bestimmen, wie viele Abtastwerte unser Pixelfenster kreuzt.  Zuerst brauchen wir folgendes: <br><br><ul><li>  Berechnen Sie die relative Position des Pixelfensters im Vergleich zu 4 Texeln. </li><li>  Holen Sie sich die Texel, mit denen sich unser Pixelfenster schneidet. </li></ul><br>  Unsere Implementierung basiert auf OpenGL, daher beginnt der Ursprung des Texturraums unten links.  Beginnen wir mit der Berechnung der relativen Position des Pixelfensters.  Die an den Pixel-Shader übergebene UV-Koordinate ist die UV-Koordinate der Pixelmitte.  Unter der Annahme, dass UVs normalisiert sind, können wir UVs zunächst in Texelraum konvertieren, indem wir sie mit der Größe der Textur multiplizieren.  Wenn Sie 0,5 von der Mitte des Pixels abziehen, erhalten Sie die untere linke Ecke des Pixelfensters.  Durch Abrunden dieses Wertes berechnen wir die untere linke Position des linken unteren Texels.  Das Bild zeigt ein Beispiel für diese drei Punkte im Texelraum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  Der Unterschied zwischen der unteren linken Ecke des Pixels und der unteren linken Ecke des Texelgitters ist die relative Position des Pixelfensters in normalisierten Koordinaten.  In diesem Bild beträgt die Position des Pixelfensters [0,69, 0,37].  Im Code: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Mit der Anweisung texturGather können vier Texel gleichzeitig abgerufen werden.  Es ist nur in OpenGL 4.0 und höher verfügbar, sodass Sie stattdessen vier texelFetch ausführen können.  Wenn wir nur die Textur-Gather-UV-Koordinaten übergeben, entsteht bei einer perfekten Übereinstimmung des Pixelfensters mit dem Texel ein Problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Hier sehen wir drei horizontale Texel mit einem Pixelfenster (blau dargestellt), das genau zum zentralen Texel passt.  Das berechnete Gewicht liegt nahe bei 1,0, aber textureGather wählte stattdessen das mittlere und das rechte Texel.  Der Grund dafür ist, dass die von textureGather durchgeführten Berechnungen geringfügig von der Berechnung des Gleitkommagewichts abweichen können.  Der Unterschied bei der Abrundung von GPU-Berechnungen und Gleitkomma-Gewichtsberechnungen führt zu Störungen um die Pixelzentren. <br><br>  Um dieses Problem zu lösen, müssen Sie sicherstellen, dass die Gewichtsberechnungen garantiert mit der Textur-Gather-Stichprobe übereinstimmen.  Zu diesem Zweck werden niemals Pixelzentren abgetastet, sondern immer in der Mitte des 2 × 2-Texelgitters.  Aus der berechneten und bereits abgerundeten unteren Position des linken Texels fügen wir das vollständige Texel hinzu, um in die Mitte des Texelgitters zu gelangen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Dieses Bild zeigt, dass bei Verwendung der Mitte des Texelgitters die vier von textureGather aufgenommenen Abtastpunkte immer in der Mitte der Texel liegen.  Im Code: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  Horizontale Maske des Pixelfensters </h2><br>  Wir haben vier Texel und zusammen bilden sie ein Raster von 8 × 8 Abdeckungsbits.  Um die Bits in einem Pixelfenster zu zählen, müssen wir zuerst die Bits außerhalb des Pixelfensters zurücksetzen.  Dazu erstellen wir eine Pixelfenstermaske und führen ein bitweises UND zwischen der Pixelmaske und den Texelabdeckungsmasken durch.  Horizontale und vertikale Maskierung werden getrennt durchgeführt. <br><br>  Die horizontale Pixelmaske sollte sich zusammen mit dem horizontalen Gewicht bewegen, wie in dieser Animation gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  Das Bild zeigt eine 8-Bit-Maske mit dem Wert 0x0F0 nach rechts verschoben (Nullen werden links eingefügt).  In der Animation wird eine Maske linear mit dem Gewicht animiert, in der Realität ist eine Bitverschiebung jedoch eine schrittweise Operation.  Die Maske ändert ihren Wert, wenn das Pixelfenster den Rand des Samples überschreitet.  In der nächsten Animation wird dies in roten und grünen Spalten angezeigt, die Schritt für Schritt animiert werden.  Der Wert ändert sich nur, wenn sich die Zentren der Stichproben schneiden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Damit sich die Maske nur in der Mitte der Zelle, aber nicht an ihren Rändern bewegt, reicht eine einfache Rundung aus: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Jetzt haben wir eine Pixelmaske aus einer vollständigen 8-Bit-Zeichenfolge, die zwei Texel umfasst.  Wenn wir den richtigen Speichertyp in unserer 16-Bit-Abdeckungsmaske auswählen, gibt es Möglichkeiten, linkes und rechtes Texel zu kombinieren und eine horizontale Pixelmaskierung für jeweils eine vollständige 8-Bit-Zeile durchzuführen.  Dies wird jedoch bei der vertikalen Maskierung problematisch, wenn wir zu gedrehten Gittern wechseln.  Daher kombinieren wir stattdessen zwei linke und zwei rechte Texel miteinander, um zwei 32-Bit-Abdeckungsmasken zu erstellen.  Wir maskieren die linken und rechten Ergebnisse getrennt. <br><br>  Masken für linke Texel verwenden die oberen 4 Bits der Pixelmaske, und Masken für rechte Texel verwenden die unteren 4 Bits.  In einem einheitlichen Raster hat jede Zeile dieselbe horizontale Maske, sodass wir die Maske für jede Zeile einfach kopieren können. Danach ist die horizontale Maske fertig: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Zum Maskieren kombinieren wir zwei linke und zwei rechte Texel und maskieren dann die horizontalen Linien: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Das Ergebnis könnte nun so aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  Wir können die Bits dieses Ergebnisses bereits mit der Anweisung bitCount zählen.  Wir sollten nicht durch 16, sondern durch 32 teilen, da wir nach der vertikalen Maskierung immer noch 32 potenzielle Bits haben können und nicht 16. Hier ist das vollständige Rendern des Glyphen in diesem Stadium: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Hier sehen wir einen vergrößerten Buchstaben S, der basierend auf den ursprünglichen Vektordaten (weißer Umriss) und der Visualisierung der Abtastpunkte gerendert wurde.  Wenn der Punkt grün ist, befindet er sich innerhalb der Glyphe, wenn rot, dann nicht.  Graustufen zeigt die zu diesem Zeitpunkt berechneten Farbtöne an.  Beim Rendern von Schriftarten gibt es viele Möglichkeiten für Fehler, von der Rasterung über die Speicherung von Daten in einem Texturatlas bis hin zur Berechnung des endgültigen Farbtons.  Solche Visualisierungen sind unglaublich nützlich für die Validierung von Berechnungen.  Sie sind besonders wichtig für das Debuggen von Artefakten auf Subpixel-Ebene. <br><br><h2>  Vertikale Maskierung </h2><br>  Jetzt sind wir bereit, die vertikalen Bits zu maskieren.  Um vertikal zu maskieren, verwenden wir eine etwas andere Methode.  Um mit der vertikalen Verschiebung fertig zu werden, ist es wichtig, sich daran zu erinnern, wie wir die Bits gespeichert haben: in zeilenweiser Reihenfolge.  Die unterste Zeile sind die vier niedrigstwertigen Bits, und die oberste Zeile sind die vier höchstwertigen Bits.  Wir können einfach eins nach dem anderen reinigen und sie basierend auf der vertikalen Position des Pixelfensters verschieben. <br><br>  Wir werden eine einzige Maske erstellen, die die gesamte Höhe von zwei Texeln abdeckt.  Infolgedessen möchten wir vier <strong>vollständige</strong> Zeilen Texel speichern und den Rest maskieren, dh die Maske besteht aus 4 × 4 Bits, was 0xFFFF entspricht.  Basierend auf der Position des Pixelfensters verschieben wir die unteren Linien und löschen die oberen Linien. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  Infolgedessen haben wir auch die vertikalen Bits außerhalb des Pixelfensters maskiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Jetzt reicht es aus, die in den Texeln verbleibenden Bits zu zählen, was mit der bitCount-Operation möglich ist. Teilen Sie dann das Ergebnis durch 16 und erhalten Sie den gewünschten Farbton! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Jetzt sieht das vollständige Rendern des Briefes folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  Fortsetzung folgt ... </h1><br>  Im zweiten Teil werden wir den nächsten Schritt machen und sehen, wie Sie diese Technik auf gedrehte Gitter anwenden können.  Wir werden dieses Schema berechnen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  Und wir werden sehen, dass fast alles auf mehrere Tabellen reduziert werden kann. <br><br>  Vielen Dank an Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">@SebAaltonen</a> ) für seine Hilfe bei der Lösung des TexturGather-Problems und natürlich an Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">@MvdleeuwGG</a> ) für seine Ideen und interessanten Gespräche am Abend. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433670/">https://habr.com/ru/post/de433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433652/index.html">5G durch die Augen der Benutzer. Erwartungen und Bedenken</a></li>
<li><a href="../de433658/index.html">IT in Deutschland - wie man Arbeit in Großstädten in Deutschland sucht</a></li>
<li><a href="../de433660/index.html">Wie ich zum fünften Mal im DefCamp gesprochen habe</a></li>
<li><a href="../de433664/index.html">SATA SSD Enterprise im Infortrend 2-Controller-Speicher - Leistungsmessung</a></li>
<li><a href="../de433666/index.html">Funcorp Wörterbuch</a></li>
<li><a href="../de433672/index.html">Leute, ist Ruby tot oder nicht?</a></li>
<li><a href="../de433674/index.html">Der Testtunnel der Boring Company wird heute Abend in Kalifornien eröffnet</a></li>
<li><a href="../de433676/index.html">Wer verdient mehr Geld in der IT: Büro- oder Remote-Mitarbeiter?</a></li>
<li><a href="../de433678/index.html">Krypto-Hacking - eine neue Art von Angriff auf das Rechenzentrum</a></li>
<li><a href="../de433680/index.html">Winterereignisse für die Spielebranche im HSE- und Desktop-Gamedev-Simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>