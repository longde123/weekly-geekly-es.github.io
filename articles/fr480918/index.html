<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 🏇🏼 🖥️ Apache Hadoop Code Quality: Production VS Test 🙇🏼 📑 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour obtenir un code de production de haute qualité, il ne suffit pas d'assurer une couverture maximale avec les tests. Aucun doute, de bons résultats...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: Production VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Figure 1"></div><br>  Pour obtenir un code de production de haute qualité, il ne suffit pas d'assurer une couverture maximale avec les tests.  Aucun doute, de bons résultats nécessitent que le code principal du projet et les tests fonctionnent efficacement ensemble.  Par conséquent, les tests doivent recevoir autant d'attention que le code principal.  Un test décent est un facteur clé de succès, car il entraînera une régression de la production.  Jetons un coup d'œil aux avertissements de l'analyseur statique PVS-Studio pour voir l'importance du fait que les erreurs dans les tests ne sont pas pires que celles en production.  Objectif d'aujourd'hui: Apache Hadoop. <br><a name="habracut"></a><br><h2>  À propos du projet </h2><br>  Ceux qui étaient auparavant intéressés par le Big Data ont probablement entendu parler ou même travaillé avec le projet <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  En un mot, Hadoop est un framework qui peut être utilisé comme base pour construire des systèmes Big Data et travailler avec eux. <br><br>  Hadoop se compose de quatre modules principaux, chacun d'eux effectue une tâche spécifique requise pour un système d'analyse de Big Data: <br><br><ul><li>  Hadoop commun </li><li>  Mapreduce </li><li>  Système de fichiers distribué Hadoop </li><li>  Fil </li></ul><br>  Quoi qu'il en soit, il existe de nombreux documents à ce sujet sur Internet. <br><br><h2>  À propos du chèque </h2><br>  Comme indiqué dans la documentation, PVS-Studio peut être intégré au projet de différentes manières: <br><br><ul><li>  Utilisation du plugin maven; </li><li>  Utilisation du plugin gradle; </li><li>  Utilisation du Gradle IntellJ IDEA; </li><li>  Utilisation directe de l'analyseur. </li></ul><br>  Hadoop est basé sur le système de construction maven, par conséquent, il n'y avait aucun obstacle avec le chèque. <br><br>  Après avoir intégré le script de la documentation et édité l'un des fichiers pom.xml (il y avait des modules dans des dépendances qui n'étaient pas disponibles), l'analyse a commencé! <br><br>  Une fois l'analyse terminée, j'ai choisi les avertissements les plus intéressants et j'ai remarqué que j'avais le même nombre d'avertissements dans le code de production et dans les tests.  Normalement, je ne considère pas les avertissements de l'analyseur, donnés pour les tests.  Mais quand je les ai divisés, je ne pouvais pas laisser les avertissements «tests» sans surveillance.  «Pourquoi ne pas y jeter un coup d'œil?» - pensais-je, car les bogues dans les tests pouvaient également avoir des conséquences néfastes.  Ils peuvent conduire à des tests incorrects ou partiels, voire à des méli-mélo (ils existent juste pour cocher la case, ils sont toujours verts). <br><br>  Après avoir sélectionné les avertissements les plus intrigants, je les ai divisés par les groupes suivants: production, test et les quatre principaux modules Hadoop.  Et maintenant, je suis heureux d'offrir à votre attention l'examen des avertissements de l'analyseur. <br><br><h2>  Code de production </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Un élément avec la même clé 'KDC_BIND_ADDRESS' a déjà été ajouté.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  La valeur ajoutée deux fois dans <i>HashSet</i> est un défaut très courant lors de la vérification des projets.  Le deuxième ajout sera en fait ignoré.  J'espère que cette duplication n'est qu'une tragédie inutile.  Et si une autre valeur devait être ajoutée? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «localFiles» devrait être utilisée à la place de «localArchives».  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Le diagnostic V6072 donne parfois des résultats intéressants.  Le but de ce diagnostic est de détecter les fragments de code de même type résultant du copier-coller et du remplacement de une à deux variables.  Dans ce cas, certaines variables sont même restées "sous-modifiées". <br><br>  Le code ci-dessus le démontre.  Dans le premier bloc, la variable <i>localArchives</i> est utilisée, dans le deuxième fragment similaire - <i>localFiles</i> .  Si vous étudiez ce code avec une diligence raisonnable, plutôt que de le parcourir rapidement, comme cela arrive souvent lors de la révision du code, vous remarquerez le fragment, où l'auteur a oublié de remplacer la variable <i>localArchives</i> . <br><br>  Cette gaffe peut conduire au scénario suivant: <br><br><ul><li>  Supposons que nous ayons <i>localArchives</i> (taille = 4) et <i>localFiles</i> (taille = 2); </li><li>  Lors de la création du tableau <i>localFiles.toArray (new String [localArchives.size ()])</i> , les 2 derniers éléments seront <i>nuls</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Ensuite, <i>org.apache.hadoop.util.StringUtils.arrayToString</i> renverra la représentation sous forme de chaîne de notre tableau, dans laquelle les derniers noms de fichiers seront présentés comme "null" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Tout cela sera passé plus loin et Dieu sait seulement quel genre de contrôles il y a pour de tels cas =). </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'children.size ()&gt; 0' est toujours vraie.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  Étant donné que le nombre d'éléments est vérifié séparément pour 0, la vérification supplémentaire <i>children.size ()&gt; 0</i> sera toujours vraie. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Il existe des sous-expressions identiques 'this.bucketSize' à gauche et à droite de l'opérateur '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Ici, le défaut est que la variable est divisée par elle-même.  Par conséquent, la vérification de la multiplicité sera toujours réussie et en cas d'obtention d'entrées incorrectes ( <i>windowLenMs</i> , <i>numBuckets</i> ), l'exception ne sera jamais levée. <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Deux ou plusieurs branches de cas effectuent les mêmes actions.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  Mêmes fragments de code dans deux branches de <i>cas</i> .  C'est juste partout!  Dans le nombre actuel de cas, il ne s'agit pas d'une véritable erreur, mais simplement d'une raison de penser à une refactorisation du <i>commutateur</i> .  Mais pas pour le cas qui nous occupe.  Des fragments de code répétés définissent la valeur de la variable <i>preemptedVcoreSeconds</i> .  Si vous examinez attentivement les noms de toutes les variables et constantes, vous conclurez probablement que si <i>métric.getId () == APP_MEM_PREEMPT_METRICS,</i> la valeur doit être définie pour la variable <i>preemptedMemorySeconds</i> , et non pour <i>preemptedVcoreSeconds</i> .  À cet égard, après l'opérateur «switch», <i>preemptedMemorySeconds</i> restera toujours 0, tandis que la valeur de <i>preemptedVcoreSeconds</i> peut être incorrecte. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Format incorrect.  Un nombre différent d'éléments de format est attendu.  Arguments non utilisés: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  La variable <i>planQueueName</i> n'est pas utilisée lors de la journalisation.  Dans ce cas, trop est copié ou la chaîne de formatage n'est pas terminée.  Mais je blâme toujours le bon vieux copier-coller, qui dans certains cas est tout simplement génial pour se tirer une balle dans le pied. <br><br><h2>  Code de test </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «allSecretsB» devrait être utilisée à la place de «allSecretsA».  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Et encore le V6072.  Examinez attentivement les variables <i>allSecretsA</i> et <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Envisagez d'inspecter l'opérateur «pour».  Les valeurs initiales et finales de l'itérateur sont identiques.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Un test toujours vert?  =).  Une partie de la boucle, qui fait partie du test lui-même, ne sera jamais exécutée.  Cela est dû au fait que les valeurs de compteur initiales et finales sont égales dans l'instruction <i>for</i> .  En conséquence, la condition <i>i &lt;start</i> deviendra immédiatement fausse, conduisant à un tel comportement.  J'ai parcouru le fichier de test et j'ai sauté à la conclusion qu'en réalité, <i>i &lt;(start + n)</i> devait être écrit dans la condition de boucle. <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'byteAm &lt;0' est toujours fausse.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  La condition <i>byteAm &lt;0</i> est toujours fausse.  Pour le comprendre, donnons le code au-dessus d'un autre coup d'œil.  Si l'exécution du test atteint l'opération <i>byteAm - = headerLen</i> , cela signifie que <i>byteAm&gt; = headerLen.</i>  À partir de là, après soustraction, la <i>valeur</i> octetAm ne sera jamais négative.  C'est ce que nous devions prouver. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «normalFile» devrait être utilisée à la place de «normalDir».  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Croyez-le ou non, c'est encore le V6072!  Suivez simplement les variables <i>normalDir</i> et <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Les variables sont initialisées via l'appel à la même fonction.  Il s'agit probablement d'une erreur ou d'un code non optimisé.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  Dans ce fragment, les variables le plus <i>élevéPriorityLowRedundancyReplicatedBlocksStr</i> et le plus <i>élevéPriorityLowRedundancyECBlocksStr</i> sont initialisés par les mêmes valeurs.  Il devrait souvent en être ainsi, mais ce n'est pas le cas.  Les noms des variables sont longs et similaires, il n'est donc pas surprenant que le fragment copié-collé n'ait été modifié d'aucune façon.  Pour y remédier, lors de l'initialisation de la variable le plus <i>élevéPriorityLowRedundancyECBlocksStr</i> , l'auteur doit utiliser le paramètre d'entrée le plus <i>élevéPriorityLowRedundancyECBlocks</i> .  En outre, très probablement, ils doivent toujours corriger la ligne de format. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  L'analyseur se plaint que le compteur <i>i ++</i> dans la boucle ne peut pas être modifié.  Ce qui signifie que dans la boucle <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> pas plus d'une itération ne s'exécutera.  Voyons pourquoi.  Ainsi, dans la première itération, nous <i>lions</i> le thread avec le fichier qui correspond à <i>slowwriters [0]</i> pour une lecture plus approfondie.  Ensuite, nous lisons le contenu du fichier via la boucle <i>pour (int j = 0, x ;; j ++):</i> <br><br><ul><li>  si nous lisons quelque chose de pertinent, nous comparons l'octet de lecture avec la valeur actuelle du compteur <i>j</i> <i>via assertEquals</i> (si la vérification échoue, nous <i>échouons</i> au test); </li><li>  si le fichier est vérifié avec succès et que nous arrivons à la fin du fichier (nous lisons -1), la méthode se termine. </li></ul><br>  Par conséquent, quoi qu'il arrive lors de la vérification des <i>ralentisseurs [0]</i> , il ne sera pas possible de vérifier les éléments suivants.  Très probablement, la <i>pause</i> doit être utilisée au lieu du <i>retour.</i> <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  Dans cette situation, la méthode <i>Assert.fail</i> interrompra le test et stacktrace ne sera pas imprimé en cas d'exception.  Si le message concernant l'exception interceptée est suffisant ici, il est préférable de supprimer l'impression de stacktrace pour éviter toute confusion.  Si l'impression est nécessaire, il vous suffit de les échanger. <br><br>  De nombreux fragments similaires ont été trouvés: <br><br><ul><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (928) </li><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (737) </li><li>  V6019 Code inaccessible détecté.  Il est possible qu'une erreur soit présente.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «publicCache» devrait être utilisée à la place de «usercache».  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Et enfin, V6072 à nouveau =).  Variables pour afficher le fragment suspect: <i>usercache</i> et <i>publicCache</i> . <br><br><h2>  Conclusion </h2><br>  Des centaines de milliers de lignes de code sont écrites en cours de développement.  Le code de production est généralement conservé à l'abri des bogues, des défauts et des défauts (les développeurs testent leur code, le code est révisé, etc.).  Les tests sont nettement inférieurs à cet égard.  Les défauts dans les tests peuvent facilement se cacher derrière une "coche verte".  Comme vous l'avez probablement compris dans l'examen des avertissements d'aujourd'hui, un test vert n'est pas toujours une vérification réussie. <br><br>  Cette fois, lors de la vérification de la base de code Apache Hadoop, l'analyse statique s'est avérée très nécessaire à la fois dans le code de production et dans les tests qui jouent également un rôle important dans le développement. <br><br>  Donc, si vous vous souciez de votre code et de la qualité des tests, je vous suggère de viser l'analyse statique.  Que <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> soit le premier concurrent de cette entreprise. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480918/">https://habr.com/ru/post/fr480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480904/index.html">PHP Microservice Framework: environnement de développement pour Swoft</a></li>
<li><a href="../fr480906/index.html">Écrire un jeu de python simple</a></li>
<li><a href="../fr480910/index.html">Comment créer une classe de test de base pour les tests Selenium et initialiser via JUnit RuleChain</a></li>
<li><a href="../fr480912/index.html">Dap en action. Écrire TodoMVC. Partie 1</a></li>
<li><a href="../fr480914/index.html">Microservices pour débutants</a></li>
<li><a href="../fr480920/index.html">Test des commutateurs TP-Link avec PoE longue portée. Et un peu sur les mises à niveau des anciens modèles</a></li>
<li><a href="../fr480922/index.html">Evgeny Usvitsky: «Tout le monde dans le monde sait où obtenir les géodonnées librement - uniquement dans OSM»</a></li>
<li><a href="../fr480924/index.html">Comment et pourquoi les créateurs du remake de MediEvil ont repensé le boss culte du jeu</a></li>
<li><a href="../fr480926/index.html">Théorie des probabilités pour un rendu physiquement précis</a></li>
<li><a href="../fr480928/index.html">Apache Hadoop Code Quality: production VS test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>