<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüè´ üèáüèº üñ•Ô∏è Apache Hadoop Code Quality: Production VS Test üôáüèº üìë üôÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour obtenir un code de production de haute qualit√©, il ne suffit pas d'assurer une couverture maximale avec les tests. Aucun doute, de bons r√©sultats...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Hadoop Code Quality: Production VS Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480918/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c48/f76/cf1/c48f76cf15c8138ce1d944918b1dcc07.png" alt="Figure 1"></div><br>  Pour obtenir un code de production de haute qualit√©, il ne suffit pas d'assurer une couverture maximale avec les tests.  Aucun doute, de bons r√©sultats n√©cessitent que le code principal du projet et les tests fonctionnent efficacement ensemble.  Par cons√©quent, les tests doivent recevoir autant d'attention que le code principal.  Un test d√©cent est un facteur cl√© de succ√®s, car il entra√Ænera une r√©gression de la production.  Jetons un coup d'≈ìil aux avertissements de l'analyseur statique PVS-Studio pour voir l'importance du fait que les erreurs dans les tests ne sont pas pires que celles en production.  Objectif d'aujourd'hui: Apache Hadoop. <br><a name="habracut"></a><br><h2>  √Ä propos du projet </h2><br>  Ceux qui √©taient auparavant int√©ress√©s par le Big Data ont probablement entendu parler ou m√™me travaill√© avec le projet <a href="https://hadoop.apache.org/">Apache Hadoop</a> .  En un mot, Hadoop est un framework qui peut √™tre utilis√© comme base pour construire des syst√®mes Big Data et travailler avec eux. <br><br>  Hadoop se compose de quatre modules principaux, chacun d'eux effectue une t√¢che sp√©cifique requise pour un syst√®me d'analyse de Big Data: <br><br><ul><li>  Hadoop commun </li><li>  Mapreduce </li><li>  Syst√®me de fichiers distribu√© Hadoop </li><li>  Fil </li></ul><br>  Quoi qu'il en soit, il existe de nombreux documents √† ce sujet sur Internet. <br><br><h2>  √Ä propos du ch√®que </h2><br>  Comme indiqu√© dans la documentation, PVS-Studio peut √™tre int√©gr√© au projet de diff√©rentes mani√®res: <br><br><ul><li>  Utilisation du plugin maven; </li><li>  Utilisation du plugin gradle; </li><li>  Utilisation du Gradle IntellJ IDEA; </li><li>  Utilisation directe de l'analyseur. </li></ul><br>  Hadoop est bas√© sur le syst√®me de construction maven, par cons√©quent, il n'y avait aucun obstacle avec le ch√®que. <br><br>  Apr√®s avoir int√©gr√© le script de la documentation et √©dit√© l'un des fichiers pom.xml (il y avait des modules dans des d√©pendances qui n'√©taient pas disponibles), l'analyse a commenc√©! <br><br>  Une fois l'analyse termin√©e, j'ai choisi les avertissements les plus int√©ressants et j'ai remarqu√© que j'avais le m√™me nombre d'avertissements dans le code de production et dans les tests.  Normalement, je ne consid√®re pas les avertissements de l'analyseur, donn√©s pour les tests.  Mais quand je les ai divis√©s, je ne pouvais pas laisser les avertissements ¬´tests¬ª sans surveillance.  ¬´Pourquoi ne pas y jeter un coup d'≈ìil?¬ª - pensais-je, car les bogues dans les tests pouvaient √©galement avoir des cons√©quences n√©fastes.  Ils peuvent conduire √† des tests incorrects ou partiels, voire √† des m√©li-m√©lo (ils existent juste pour cocher la case, ils sont toujours verts). <br><br>  Apr√®s avoir s√©lectionn√© les avertissements les plus intrigants, je les ai divis√©s par les groupes suivants: production, test et les quatre principaux modules Hadoop.  Et maintenant, je suis heureux d'offrir √† votre attention l'examen des avertissements de l'analyseur. <br><br><h2>  Code de production </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/en/w/v6033/">V6033</a> Un √©l√©ment avec la m√™me cl√© 'KDC_BIND_ADDRESS' a d√©j√† √©t√© ajout√©.  MiniKdc.java (163), MiniKdc.java (162) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MiniKdc</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Set&lt;String&gt; PROPERTIES = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;String&gt;(); .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { PROPERTIES.add(ORG_NAME); PROPERTIES.add(ORG_DOMAIN); PROPERTIES.add(KDC_BIND_ADDRESS); PROPERTIES.add(KDC_BIND_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">// &lt;= PROPERTIES.add(KDC_PORT); PROPERTIES.add(INSTANCE); .... } .... }</span></span></code> </pre> <br>  La valeur ajout√©e deux fois dans <i>HashSet</i> est un d√©faut tr√®s courant lors de la v√©rification des projets.  Le deuxi√®me ajout sera en fait ignor√©.  J'esp√®re que cette duplication n'est qu'une trag√©die inutile.  Et si une autre valeur devait √™tre ajout√©e? <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont √©t√© trouv√©s.  Il s'agit peut-√™tre d'une faute de frappe et la variable ¬´localFiles¬ª devrait √™tre utilis√©e √† la place de ¬´localArchives¬ª.  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Le diagnostic V6072 donne parfois des r√©sultats int√©ressants.  Le but de ce diagnostic est de d√©tecter les fragments de code de m√™me type r√©sultant du copier-coller et du remplacement de une √† deux variables.  Dans ce cas, certaines variables sont m√™me rest√©es "sous-modifi√©es". <br><br>  Le code ci-dessus le d√©montre.  Dans le premier bloc, la variable <i>localArchives</i> est utilis√©e, dans le deuxi√®me fragment similaire - <i>localFiles</i> .  Si vous √©tudiez ce code avec une diligence raisonnable, plut√¥t que de le parcourir rapidement, comme cela arrive souvent lors de la r√©vision du code, vous remarquerez le fragment, o√π l'auteur a oubli√© de remplacer la variable <i>localArchives</i> . <br><br>  Cette gaffe peut conduire au sc√©nario suivant: <br><br><ul><li>  Supposons que nous ayons <i>localArchives</i> (taille = 4) et <i>localFiles</i> (taille = 2); </li><li>  Lors de la cr√©ation du tableau <i>localFiles.toArray (new String [localArchives.size ()])</i> , les 2 derniers √©l√©ments seront <i>nuls</i> (["pathToFile1", "pathToFile2", null, null]); </li><li>  Ensuite, <i>org.apache.hadoop.util.StringUtils.arrayToString</i> renverra la repr√©sentation sous forme de cha√Æne de notre tableau, dans laquelle les derniers noms de fichiers seront pr√©sent√©s comme "null" ("pathToFile1, pathToFile2, null, null" <i>)</i> ; </li><li>  Tout cela sera pass√© plus loin et Dieu sait seulement quel genre de contr√¥les il y a pour de tels cas =). </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'children.size ()&gt; 0' est toujours vraie.  Queue.java (347) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHierarchySameAs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Queue newState)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || children.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(children.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... }</code> </pre> <br>  √âtant donn√© que le nombre d'√©l√©ments est v√©rifi√© s√©par√©ment pour 0, la v√©rification suppl√©mentaire <i>children.size ()&gt; 0</i> sera toujours vraie. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6001/">V6001</a> Il existe des sous-expressions identiques 'this.bucketSize' √† gauche et √† droite de l'op√©rateur '%'.  RollingWindow.java (79) <br><br><pre> <code class="java hljs"> RollingWindow(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> windowLenMs, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numBuckets) { buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket[numBuckets]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numBuckets; i++) { buckets[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bucket(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.windowLenMs = windowLenMs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize = windowLenMs / numBuckets; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bucketSize % bucketSize != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new IllegalArgumentException( "The bucket size in the rolling window is not integer: windowLenMs= " + windowLenMs + " numBuckets= " + numBuckets); } }</span></span></code> </pre> <br>  Ici, le d√©faut est que la variable est divis√©e par elle-m√™me.  Par cons√©quent, la v√©rification de la multiplicit√© sera toujours r√©ussie et en cas d'obtention d'entr√©es incorrectes ( <i>windowLenMs</i> , <i>numBuckets</i> ), l'exception ne sera jamais lev√©e. <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/en/w/v6067/">V6067</a> Deux ou plusieurs branches de cas effectuent les m√™mes actions.  TimelineEntityV2Converter.java (386), TimelineEntityV2Converter.java (389) <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ApplicationReport </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToApplicationReport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimelineEntity entity)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metrics != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> memorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedVcoreSeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> preemptedMemorySeconds = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TimelineMetric metric : metrics) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric.getId()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_CPU_METRICS: vcoreSeconds = getAverageValue(metric.getValues().values()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_METRICS: memorySeconds = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS: preemptedVcoreSeconds = ....; <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS: preemptedVcoreSeconds = ....; // &lt;= break; default: // Should not happen.. break; } } .... } .... }</span></span></code> </pre> <br>  M√™mes fragments de code dans deux branches de <i>cas</i> .  C'est juste partout!  Dans le nombre actuel de cas, il ne s'agit pas d'une v√©ritable erreur, mais simplement d'une raison de penser √† une refactorisation du <i>commutateur</i> .  Mais pas pour le cas qui nous occupe.  Des fragments de code r√©p√©t√©s d√©finissent la valeur de la variable <i>preemptedVcoreSeconds</i> .  Si vous examinez attentivement les noms de toutes les variables et constantes, vous conclurez probablement que si <i>m√©tric.getId () == APP_MEM_PREEMPT_METRICS,</i> la valeur doit √™tre d√©finie pour la variable <i>preemptedMemorySeconds</i> , et non pour <i>preemptedVcoreSeconds</i> .  √Ä cet √©gard, apr√®s l'op√©rateur ¬´switch¬ª, <i>preemptedMemorySeconds</i> restera toujours 0, tandis que la valeur de <i>preemptedVcoreSeconds</i> peut √™tre incorrecte. <br><br>  <a href="https://www.viva64.com/en/w/v6046/">V6046</a> Format incorrect.  Un nombre diff√©rent d'√©l√©ments de format est attendu.  Arguments non utilis√©s: 2. AbstractSchedulerPlanFollower.java (186) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synchronizePlan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Plan plan, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shouldReplan)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setQueueEntitlement(planQueueName, ....); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (YarnException e) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Exception while trying to size reservation for plan: {}"</span></span>, currResId, planQueueName, e); } .... }</code> </pre> <br>  La variable <i>planQueueName</i> n'est pas utilis√©e lors de la journalisation.  Dans ce cas, trop est copi√© ou la cha√Æne de formatage n'est pas termin√©e.  Mais je bl√¢me toujours le bon vieux copier-coller, qui dans certains cas est tout simplement g√©nial pour se tirer une balle dans le pied. <br><br><h2>  Code de test </h2><br><h3>  Hadoop commun </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont √©t√© trouv√©s.  Il s'agit peut-√™tre d'une faute de frappe et la variable ¬´allSecretsB¬ª devrait √™tre utilis√©e √† la place de ¬´allSecretsA¬ª.  TestZKSignerSecretProvider.java (316), TestZKSignerSecretProvider.java (309), TestZKSignerSecretProvider.java (306), TestZKSignerSecretProvider.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMultiple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... currentSecretA = secretProviderA.getCurrentSecret(); allSecretsA = secretProviderA.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretA); Assert.assertEquals(<span class="hljs-number"><span class="hljs-number">2</span></span>, allSecretsA.length); <span class="hljs-comment"><span class="hljs-comment">// &lt;= Assert.assertArrayEquals(secretA2, allSecretsA[0]); Assert.assertArrayEquals(secretA1, allSecretsA[1]); currentSecretB = secretProviderB.getCurrentSecret(); allSecretsB = secretProviderB.getAllSecrets(); Assert.assertArrayEquals(secretA2, currentSecretB); Assert.assertEquals(2, allSecretsA.length); // &lt;= Assert.assertArrayEquals(secretA2, allSecretsB[0]); Assert.assertArrayEquals(secretA1, allSecretsB[1]); .... }</span></span></code> </pre> <br>  Et encore le V6072.  Examinez attentivement les variables <i>allSecretsA</i> et <i>allSecretsB</i> . <br><br>  <a href="https://www.viva64.com/en/w/v6043/">V6043</a> Envisagez d'inspecter l'op√©rateur ¬´pour¬ª.  Les valeurs initiales et finales de l'it√©rateur sont identiques.  TestTFile.java (235) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrepWithUnknownLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scanner scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = start; i &lt; start; i++) { String key = String.format(localFormatter, i); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] read = readKey(scanner); assertTrue(<span class="hljs-string"><span class="hljs-string">"keys not equal"</span></span>, Arrays.equals(key.getBytes(), read)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read = readValue(scanner); assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ie) { <span class="hljs-comment"><span class="hljs-comment">// should have thrown exception } String value = "value" + key; read = readLongValue(scanner, value.getBytes().length); assertTrue("values nto equal", Arrays.equals(read, value.getBytes())); scanner.advance(); } return (start + n); }</span></span></code> </pre> <br>  Un test toujours vert?  =).  Une partie de la boucle, qui fait partie du test lui-m√™me, ne sera jamais ex√©cut√©e.  Cela est d√ª au fait que les valeurs de compteur initiales et finales sont √©gales dans l'instruction <i>for</i> .  En cons√©quence, la condition <i>i &lt;start</i> deviendra imm√©diatement fausse, conduisant √† un tel comportement.  J'ai parcouru le fichier de test et j'ai saut√© √† la conclusion qu'en r√©alit√©, <i>i &lt;(start + n)</i> devait √™tre √©crit dans la condition de boucle. <br><br><h3>  Mapreduce </h3><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'byteAm &lt;0' est toujours fausse.  DataWriter.java (322) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">GenerateOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeSegment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> byteAm, OutputStream out)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> headerLen = getHeaderLength(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byteAm &lt; headerLen) { <span class="hljs-comment"><span class="hljs-comment">// not enough bytes to write even the header return new GenerateOutput(0, 0); } // adjust for header length byteAm -= headerLen; if (byteAm &lt; 0) { // &lt;= byteAm = 0; } .... }</span></span></code> </pre> <br>  La condition <i>byteAm &lt;0</i> est toujours fausse.  Pour le comprendre, donnons le code au-dessus d'un autre coup d'≈ìil.  Si l'ex√©cution du test atteint l'op√©ration <i>byteAm - = headerLen</i> , cela signifie que <i>byteAm&gt; = headerLen.</i>  √Ä partir de l√†, apr√®s soustraction, la <i>valeur</i> octetAm ne sera jamais n√©gative.  C'est ce que nous devions prouver. <br><br><h3>  HDFS </h3><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont √©t√© trouv√©s.  Il s'agit peut-√™tre d'une faute de frappe et la variable ¬´normalFile¬ª devrait √™tre utilis√©e √† la place de ¬´normalDir¬ª.  TestWebHDFS.java (625), TestWebHDFS.java (615), TestWebHDFS.java (614), TestWebHDFS.java (624) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWebHdfsErasureCodingFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(<span class="hljs-string"><span class="hljs-string">"/dir"</span></span>); dfs.mkdirs(normalDir); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Path normalFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Path(normalDir, <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>); .... <span class="hljs-comment"><span class="hljs-comment">// logic block #1 FileStatus expectedNormalDirStatus = dfs.getFileStatus(normalDir); FileStatus actualNormalDirStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalDirStatus.isErasureCoded(), actualNormalDirStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalDir); assertTrue(normalDir + " should have erasure coding unset in " + ....); // logic block #2 FileStatus expectedNormalFileStatus = dfs.getFileStatus(normalFile); FileStatus actualNormalFileStatus = webHdfs.getFileStatus(normalDir); // &lt;= Assert.assertEquals(expectedNormalFileStatus.isErasureCoded(), actualNormalFileStatus.isErasureCoded()); ContractTestUtils.assertNotErasureCoded(dfs, normalFile); assertTrue( normalFile + " should have erasure coding unset in " + ....); }</span></span></code> </pre> <br>  Croyez-le ou non, c'est encore le V6072!  Suivez simplement les variables <i>normalDir</i> et <i>normalFile.</i> <br><br>  <a href="https://www.viva64.com/en/w/v6027/">V6027</a> Les variables sont initialis√©es via l'appel √† la m√™me fonction.  Il s'agit probablement d'une erreur ou d'un code non optimis√©.  TestDFSAdmin.java (883), TestDFSAdmin.java (879) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyNodesAndCorruptBlocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numLiveDn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numCorruptECBlockGroups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DFSClient client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyReplicatedBlocks, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Long highestPriorityLowRedundancyECBlocks)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init vars */</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String expectedCorruptedECBlockGroupsStr = String.format( <span class="hljs-string"><span class="hljs-string">"Block groups with corrupt internal blocks: %d"</span></span>, numCorruptECBlockGroups); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyReplicatedBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String highestPriorityLowRedundancyECBlocksStr = String.format( <span class="hljs-string"><span class="hljs-string">"\tLow redundancy blocks with highest priority "</span></span> + <span class="hljs-string"><span class="hljs-string">"to recover: %d"</span></span>, highestPriorityLowRedundancyReplicatedBlocks); .... }</code> </pre> <br>  Dans ce fragment, les variables le plus <i>√©lev√©PriorityLowRedundancyReplicatedBlocksStr</i> et le plus <i>√©lev√©PriorityLowRedundancyECBlocksStr</i> sont initialis√©s par les m√™mes valeurs.  Il devrait souvent en √™tre ainsi, mais ce n'est pas le cas.  Les noms des variables sont longs et similaires, il n'est donc pas surprenant que le fragment copi√©-coll√© n'ait √©t√© modifi√© d'aucune fa√ßon.  Pour y rem√©dier, lors de l'initialisation de la variable le plus <i>√©lev√©PriorityLowRedundancyECBlocksStr</i> , l'auteur doit utiliser le param√®tre d'entr√©e le plus <i>√©lev√©PriorityLowRedundancyECBlocks</i> .  En outre, tr√®s probablement, ils doivent toujours corriger la ligne de format. <br><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Code inaccessible d√©tect√©.  Il est possible qu'une erreur soit pr√©sente.  TestReplaceDatanodeFailureReplication.java (222) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verifyFileContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., SlowWriter[] slowwriters)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Verify the file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slowwriters.length; i++) { LOG.info(slowwriters[i].filepath + ....); FSDataInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { in = fs.open(slowwriters[i].filepath); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, x;; j++) { x = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x) != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { Assert.assertEquals(j, x); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { IOUtils.closeStream(in); } } }</code> </pre> <br>  L'analyseur se plaint que le compteur <i>i ++</i> dans la boucle ne peut pas √™tre modifi√©.  Ce qui signifie que dans la boucle <i>for (int i = 0; i &lt;slowwriters.length; i ++) {....}</i> pas plus d'une it√©ration ne s'ex√©cutera.  Voyons pourquoi.  Ainsi, dans la premi√®re it√©ration, nous <i>lions</i> le thread avec le fichier qui correspond √† <i>slowwriters [0]</i> pour une lecture plus approfondie.  Ensuite, nous lisons le contenu du fichier via la boucle <i>pour (int j = 0, x ;; j ++):</i> <br><br><ul><li>  si nous lisons quelque chose de pertinent, nous comparons l'octet de lecture avec la valeur actuelle du compteur <i>j</i> <i>via assertEquals</i> (si la v√©rification √©choue, nous <i>√©chouons</i> au test); </li><li>  si le fichier est v√©rifi√© avec succ√®s et que nous arrivons √† la fin du fichier (nous lisons -1), la m√©thode se termine. </li></ul><br>  Par cons√©quent, quoi qu'il arrive lors de la v√©rification des <i>ralentisseurs [0]</i> , il ne sera pas possible de v√©rifier les √©l√©ments suivants.  Tr√®s probablement, la <i>pause</i> doit √™tre utilis√©e au lieu du <i>retour.</i> <br><br><h3>  Fil </h3><br>  <a href="https://www.viva64.com/en/w/v6019/">V6019</a> Code inaccessible d√©tect√©.  Il est possible qu'une erreur soit pr√©sente.  TestNodeManager.java (176) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCreationOfNodeLabelsProviderService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Assert.fail(<span class="hljs-string"><span class="hljs-string">"Exception caught"</span></span>); e.printStackTrace(); } }</code> </pre> <br>  Dans cette situation, la m√©thode <i>Assert.fail</i> interrompra le test et stacktrace ne sera pas imprim√© en cas d'exception.  Si le message concernant l'exception intercept√©e est suffisant ici, il est pr√©f√©rable de supprimer l'impression de stacktrace pour √©viter toute confusion.  Si l'impression est n√©cessaire, il vous suffit de les √©changer. <br><br>  De nombreux fragments similaires ont √©t√© trouv√©s: <br><br><ul><li>  V6019 Code inaccessible d√©tect√©.  Il est possible qu'une erreur soit pr√©sente.  TestResourceTrackerService.java (928) </li><li>  V6019 Code inaccessible d√©tect√©.  Il est possible qu'une erreur soit pr√©sente.  TestResourceTrackerService.java (737) </li><li>  V6019 Code inaccessible d√©tect√©.  Il est possible qu'une erreur soit pr√©sente.  TestResourceTrackerService.java (685) </li><li>  .... </li></ul><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont √©t√© trouv√©s.  Il s'agit peut-√™tre d'une faute de frappe et la variable ¬´publicCache¬ª devrait √™tre utilis√©e √† la place de ¬´usercache¬ª.  TestResourceLocalizationService.java (315), TestResourceLocalizationService.java (309), TestResourceLocalizationService.java (307), TestResourceLocalizationService.java (313) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDirectoryCleanupOnNewlyCreatedStateStore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, URISyntaxException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// verify directory creation for (Path p : localDirs) { p = new Path((new URI(p.toString())).getPath()); // logic block #1 Path usercache = new Path(p, ContainerLocalizer.USERCACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(usercache), ....); // logic block #2 Path publicCache = new Path(p, ContainerLocalizer.FILECACHE); verify(spylfs).rename(eq(usercache), any(Path.class), any()); // &lt;= verify(spylfs).mkdir(eq(publicCache), ....); .... } .... }</span></span></code> </pre> <br>  Et enfin, V6072 √† nouveau =).  Variables pour afficher le fragment suspect: <i>usercache</i> et <i>publicCache</i> . <br><br><h2>  Conclusion </h2><br>  Des centaines de milliers de lignes de code sont √©crites en cours de d√©veloppement.  Le code de production est g√©n√©ralement conserv√© √† l'abri des bogues, des d√©fauts et des d√©fauts (les d√©veloppeurs testent leur code, le code est r√©vis√©, etc.).  Les tests sont nettement inf√©rieurs √† cet √©gard.  Les d√©fauts dans les tests peuvent facilement se cacher derri√®re une "coche verte".  Comme vous l'avez probablement compris dans l'examen des avertissements d'aujourd'hui, un test vert n'est pas toujours une v√©rification r√©ussie. <br><br>  Cette fois, lors de la v√©rification de la base de code Apache Hadoop, l'analyse statique s'est av√©r√©e tr√®s n√©cessaire √† la fois dans le code de production et dans les tests qui jouent √©galement un r√¥le important dans le d√©veloppement. <br><br>  Donc, si vous vous souciez de votre code et de la qualit√© des tests, je vous sugg√®re de viser l'analyse statique.  Que <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> soit le premier concurrent de cette entreprise. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480918/">https://habr.com/ru/post/fr480918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480904/index.html">PHP Microservice Framework: environnement de d√©veloppement pour Swoft</a></li>
<li><a href="../fr480906/index.html">√âcrire un jeu de python simple</a></li>
<li><a href="../fr480910/index.html">Comment cr√©er une classe de test de base pour les tests Selenium et initialiser via JUnit RuleChain</a></li>
<li><a href="../fr480912/index.html">Dap en action. √âcrire TodoMVC. Partie 1</a></li>
<li><a href="../fr480914/index.html">Microservices pour d√©butants</a></li>
<li><a href="../fr480920/index.html">Test des commutateurs TP-Link avec PoE longue port√©e. Et un peu sur les mises √† niveau des anciens mod√®les</a></li>
<li><a href="../fr480922/index.html">Evgeny Usvitsky: ¬´Tout le monde dans le monde sait o√π obtenir les g√©odonn√©es librement - uniquement dans OSM¬ª</a></li>
<li><a href="../fr480924/index.html">Comment et pourquoi les cr√©ateurs du remake de MediEvil ont repens√© le boss culte du jeu</a></li>
<li><a href="../fr480926/index.html">Th√©orie des probabilit√©s pour un rendu physiquement pr√©cis</a></li>
<li><a href="../fr480928/index.html">Apache Hadoop Code Quality: production VS test</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>