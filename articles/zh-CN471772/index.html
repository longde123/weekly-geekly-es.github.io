<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏽 👮 💍 用于启动和开发Java应用程序，在JVM上进行编译，执行的工具 👂🏽 🙉 👩🏿‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="目前，Java是世界上最受欢迎的编程语言之一已经不是什么秘密了。 Java的正式发布日期是1995年5月23日。 

 本文致力于基础知识的基础知识：它概述了该语言的基础特性，这些语言特性对于初学者“ javists”将派上用场，而经验丰富的Java开发人员将能够刷新他们的知识。 

 *本文是根据...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用于启动和开发Java应用程序，在JVM上进行编译，执行的工具</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471772/"><p> 目前，Java是世界上最受欢迎的编程语言之一已经不是什么秘密了。  Java的正式发布日期是1995年5月23日。 <br><br> 本文致力于基础知识的基础知识：它概述了该语言的基础特性，这些语言特性对于初学者“ javists”将派上用场，而经验丰富的Java开发人员将能够刷新他们的知识。 <br><br>  <i>*本文是根据IntexSoft Java开发人员Eugene Freiman的报告编写的。</i> <i><br></i>  <i>本文包含外部材料的链接</i> 。 <br></p><br><br><img src="https://habrastorage.org/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"><br><a name="habracut"></a><br><h3>  1. JDK，JRE，JVM </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java开发工具包</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java</a>应用程序开发工具包。 它包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java开发工具</a>和Java运行时环境（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JRE</a> ）。 <br><br>  <b>Java开发工具</b>包括大约40种不同的工具：javac（编译器），java（应用程序启动器），javap（java类文件反汇编器），jdb（java调试器）等。 <br><br>  JRE运行时是运行已编译Java程序所需的所有程序的软件包。 包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JVM</a>虚拟机和<b>Java类库</b> 。 <br><br>  <b>JVM</b>是旨在执行字节码的程序。  JVM的第一个优点是<i>“编写一次，随处运行”</i>的原则。 这意味着用Java编写的应用程序在所有平台上都可以相同地工作。 这是JVM和Java本身的一大优势。 <br><br> 在Java之前，许多计算机程序是为特定的计算机系统编写的，并且优先选择手动内存管理，因为这样效率更高且可预测。 自1990年代下半年以来，在Java出现之后，自动内存管理已成为一种普遍的做法。 <br><br> 有许多JVM实现，包括商业和开源。 创建新JVM的目标之一是提高特定平台的性能。 每个JVM都是针对该平台分别编写的，但可以编写它，以便在特定平台上更快地工作。 最常见的JVM实现是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenJDK</a> JVM热点。 也有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IBM J9</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Excelsior JET的实现</a> 。 <br><br><h3>  2. JVM代码执行 </h3><br> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java SE规范</a> ，为了使代码在JVM中运行，您需要完成3个步骤： <br><br><ul><li> 加载字节码并实例化Class类 <br> 粗略地说，为了进入JVM，必须加载该类。 为此，有单独的加载程序类，我们稍后再返回。 </li><li> 链接或链接 <br> 加载类后，链接过程开始，在该链接过程中解析并检查字节码。 链接过程依次分为3个步骤： <br><br>  -校验或字节码校验：指令的正确性，代码这一部分的堆栈溢出的可能性，变量类型的兼容性被检查； 每个班级检查一次； <br>  -准备或准备：在此阶段，根据规范，为静态字段分配内存并进行初始化； <br>  -分辨率或分辨率：符号链接的权限（在字节码中，打开扩展名为.class的文件时，我们看到的是数字值而不是符号链接）。 </li><li> 初始化生成的Class对象 <br> 在最后阶段，我们创建的类被初始化，并且JVM可以开始执行它。 </li></ul><br><h3>  3.类加载器及其层次结构 </h3><br> 回到类加载器，这些是JVM一部分的特殊类。 它们将类加载到内存中，并使它们可用于执行。 加载程序适用于所有类：我们的类以及Java直接需要的类。 <br><br> 想象一下情况：我们编写了应用程序，除了标准类之外，还有我们的类，并且有很多类。  JVM将如何与此一起工作？  Java实现了延迟的类加载，即延迟加载。 这意味着只有在应用程序中没有对类的调用之前，才可以加载类。 <br><br><h4> 类加载器层次结构 </h4><br><br><img src="https://habrastorage.org/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png"><br><br> 第一类加载器是<b>Bootstrap类加载器</b> 。 它是用C ++编写的。 这是从<i>rt.jar</i>存档中加载所有系统类的基础加载器。 同时，从<i>rt.jar</i>加载类和我们的类之间存在细微差别：当JVM从<i>rt.jar</i>加载类时，它不会执行加载任何其他类文件时执行的所有验证步骤，因为  JVM最初知道所有这些类均已验证。 因此，您不应在此存档中包含任何文件。 <br><br> 下一个引导加载程序是<b>Extension类加载程序。</b> 它从<i>jre / lib / ext</i>文件夹加载扩展类。 假设您希望每次Java计算机启动时都加载一个类。 为此，您可以将源类文件复制到此文件夹，它将自动加载。 <br><br> 另一个引导程序是<b>System classloader</b> 。 它从应用程序启动时指定的类路径中加载类。 <br><br> 加载类的过程发生在层次结构中： <br><br><ul><li> 首先，我们请求在系统类加载器缓存中进行搜索（系统加载器缓存包含它已经加载的类）； </li><li> 如果在系统加载器的高速缓存中找不到该类，我们将查看高速缓存扩展类加载器； </li><li> 如果在扩展加载程序缓存中找不到该类，则从Bootstrap加载程序请求该类。 </li></ul><br> 如果在Bootstrap缓存中找不到该类，它将尝试加载该类。 如果Bootstrap无法加载该类，则它将类的加载委托给扩展加载器。 如果此时加载了类，则它将保留在扩展类加载器的缓存中，并且类加载完成。 <br><br><h3>  4.类文件结构和启动过程 </h3><br> 我们直接进入类文件的结构。 <br><br> 用Java编写的一个类被编译为扩展名为.class的单​​个文件。 如果我们的Java文件中有多个类，则可以将一个Java文件编译成扩展名为.class-这些类的字节码文件的多个文件。 <br><br> 所有数字，字符串，指向类，字段和方法的指针都存储在<i>常量池中</i> - <i>元空间</i>存储区。 类描述存储在同一位置，并包含名称，修饰符，超类，超级接口，字段，方法和属性。 属性又可以包含任何其他信息。 <br><br> 因此，在加载类时： <br><br><ul><li> 读取类文件，即格式验证 </li><li> 在常量池（元空间）中创建类表示形式 </li><li> 加载了超类和超级接口； 如果它们没有被加载，那么类本身将不会被加载 </li></ul><br><h3>  5.在JVM上执行字节码 </h3><br> 首先，为了执行字节码，JVM可以对其进行<i>解释</i> 。 解释是一个相当缓慢的过程。 在解释过程中，解释器逐行“遍历”类文件，并将其转换为JVM可以理解的命令。 <br><br> 而且，JVM可以<i>广播它</i> ，即 编译为将直接在CPU上执行的机器代码。 <br><br> 频繁执行的命令将不会被解释，但会立即广播。 <br><br><h3>  6.编译 </h3><br>  <b>编译器</b>是一种程序，可以将用高级编程语言编写的程序的源部分转换为计算机“可以理解”的机器语言程序。 <br><br> 编译器分为： <br><br><ul><li>  <i>没有优化</i> </li><li>  <i>简单优化</i> （Hotspot Client）：工作迅速，但生成非最佳代码 </li><li>  <i>复杂优化</i> （热点服务器）：在生成字节码之前执行复杂的优化转换 </li></ul><br><br> 编译器还可以按编译时间分类： <br><br><ul><li>  <i>动态编译器</i> <br> 它们与程序同时工作，这会影响性能。 这些编译器必须在经常执行的代码上运行，这一点很重要。 在程序执行期间，JVM知道最常执行哪个代码，并且为了不经常解释它，虚拟机立即将其转换为将直接在处理器上执行的命令。 </li><li>  <i>静态编译器</i> <br> 编译时间更长，但会生成最佳代码以供执行。 优点：在程序执行期间它们不需要资源，每种方法都使用优化进行编译。 </li></ul><br><h3>  7. Java的内存组织 </h3><br>  <b>堆栈</b>是Java中根据LIFO方案（“后进<i>先出</i> ”或“后进<i>先出</i> ”）工作的内存区域。 <br><br><img src="https://habrastorage.org/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png"><br><br> 为了存储方法，它是必需的。 只要执行创建变量的方法，堆栈中的变量就存在。 <br><br> 在Java中调用任何方法时，都会在堆栈上创建一个框架或内存区域，并将该方法放在其顶部。 当方法完成执行时，将从内存中删除该方法，从而为以下方法释放内存。 如果堆栈内存已满，则Java将抛出<i>java.lang.StackOverFlowError</i>异常。 例如，如果我们有一个将调用自身的递归函数并且堆栈上没有足够的内存，则会发生这种情况。 <br><br> 堆栈的主要功能： <br><br><ul><li> 随着新方法的调用和完成，将填充并释放堆栈。 </li><li> 对该内存区域的访问比堆快。 </li><li> 堆栈大小由操作系统确定。 </li><li> 它是线程安全的，因为每个堆栈都有自己的单独堆栈。 </li></ul><br>  Java中的另一个内存区域是<b>堆</b>或<b>堆</b> 。 它用于存储对象和类。 新对象总是在堆上创建，对它们的引用存储在堆栈中。 堆上的所有对象都具有全局访问权限，也就是说，可以从应用程序中的任何位置访问它们。 <br><br> 堆分为几个较小的部分，称为几代： <br><br><ul><li>  <i>年轻一代</i> -最近创建的对象所在的区域 </li><li>  <i>旧的（</i>永久的<i>）世代</i> -存储“长寿命”对象的区域 </li><li> 在Java 8之前，存在另一个领域- <i>永久生成</i> -包含有关类，方法和静态变量的元信息。  Java 8出现后，决定将这些信息分别存储在堆外部，即在Meta空间中 </li></ul><br><br><img src="https://habrastorage.org/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png"><br><br> 为什么抛弃永久一代？ 首先，这是由于与该区域溢出相关的错误所致：由于Perm的大小恒定且无法动态扩展，因此内存迟早会耗尽，引发错误，并且应用程序崩溃。 <br><br> 元空间具有动态大小，并且在运行时可以扩展为JVM内存大小。 <br><br> 关键堆功能： <br><br><ul><li> 当此内存区域已满时，Java会引发<i>java.lang.OutOfMemoryError</i> </li><li> 堆访问比栈访问慢 </li><li> 垃圾收集器收集未使用的对象 </li><li> 与堆栈不同，堆不是线程安全的，因为任何线程都可以访问它 </li></ul><br><br> 根据上面的信息，考虑使用一个简单的示例执行内存管理的方法： <br><br><pre><code class="coffeescript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = 23; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jon</span></span></span><span class="hljs-class">"; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class">); } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pid</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructors</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getters</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setters</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><br> 我们有一个App类，其中唯一的<i>主要</i>方法包括： <br><br>  -值为<b>23的</b> <b>int</b>类型的原始<b>id</b>变量 <br>  -具有值<b>Jon的</b> <b>String</b>类型的<b>pName</b>引用变量 <br>  -类型<b>人员的</b>参考变量<b>p</b> <br><br><img src="https://habrastorage.org/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png"><br><br> 如已经提到的，当调用一个方法时，将在堆栈的顶部创建一个存储区，在其中存储要存储该方法所需的数据。 <br> 在我们的例子中，这是对<i>person</i>类的引用：对象本身存储在堆中，链接存储在堆栈中。 字符串的链接也被压入堆栈，字符串本身存储在字符串池的堆中。 原语直接存储在堆栈中。 <br><br> 要从堆栈上的<i>main（）</i>方法使用<i>Person（String）</i>参数调用构造函数，在上一个<i>main（）</i>调用的顶部，将在堆栈上创建一个单独的框架，其中存储以下内容： <br><br>  - <b>此</b> -链接到当前对象 <br>  -原始<b>ID</b>值 <br>  -参考变量<b>personName</b> ，它指向字符串池中的字符串。 <br><br> 调用构造函数后，将调用<i>setPersonName（）</i> ，此后再次在堆栈上创建一个新框架，该框架中存储了相同的数据：对象引用，行引用，变量值。 <br><br> 因此，当执行<i>setter</i>方法时，框架消失，堆栈被清除。 接下来，执行构造函数，清除为该构造函数创建的框架，然后<i>main（）</i>方法完成其工作，并将其从堆栈中删除。 <br><br> 如果调用其他方法，则还将在这些特定方法的上下文中为它们创建新框架。 <br><br><h3>  8.垃圾收集器 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">垃圾收集器</a>正在堆上工作-这是一个在Java虚拟机上运行的程序，它摆脱了无法访问的对象。 <br><br> 不同的JVM可能具有不同的垃圾收集算法；也有不同的垃圾收集器。 <br><br> 我们将讨论最简单的收集器<b>Serial GC</b> 。 我们要求使用<i>System.gc（）进行</i>垃圾收集。 <br><br><img src="https://habrastorage.org/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png"><br><br> 如上所述，堆分为两个区域：新一代和旧一代。 <br><br> 新一代（较年轻的一代）包括3个区域： <i>伊甸园</i> ， <i>幸存者0</i>和<i>幸存者1</i> 。 <br><br> 老一辈包括<i>终身制</i>地区。 <br><br> 当我们用Java创建对象时会发生什么？ <br><br> 首先，物体落入<i>伊甸园</i> 。 如果我们已经创建了许多对象，并且<i>Eden中</i>没有更多空间，则垃圾收集器将触发并释放内存。 这就是所谓的<i>小型垃圾收集</i> -在第一遍中，它将清理<i>Eden</i>区域并将“幸存”对象放入<i>Survivor 0</i>区域。 因此， <i>伊甸园</i>地区被完全释放。 <br><br> 如果碰巧再次填充了<i>Eden</i>区域，则垃圾收集器将开始使用<i>Eden</i>区域和<i>Survivor 0</i> （当前已被占用）工作。 清洗后，幸存的物体将掉入另一个区域- <i>幸存者1</i> ，另外两个将保持干净。 在随后的垃圾收集之后， <i>幸存者0</i>将再次被选择为目标区域。 这就是为什么<i>幸存者</i>区域之一始终为空很重要的原因。 <br><br>  JVM监视不断被复制并从一个区域移动到另一个区域的对象。 并且为了优化此机制，在一定阈值之后，垃圾收集器将此类对象移动到<i>Tenured</i>地区。 <br><br> 当<i>Tenured中</i>没有足够的空间容纳新对象时，将存在一个完整的垃圾收集<b>-Mark-Sweep-Compact</b> 。 <br><br><img src="https://habrastorage.org/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png"><br><br> 在该机制期间，确定不再使用哪些对象，清除这些对象的区域，并对使用<i>期限的</i>存储<i>区进行</i>碎片整理，即 依次填充必要的对象。 <br><br><h4> 结论 </h4><br> 在本文中，我们研究了Java语言的基本工具：JVM，JRE，JDK，JVM代码执行，编译，内存组织的原理和阶段，以及垃圾收集器的原理。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471772/">https://habr.com/ru/post/zh-CN471772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471756/index.html">服务器如何启动</a></li>
<li><a href="../zh-CN471758/index.html">如何将文字翻译成其他语言？</a></li>
<li><a href="../zh-CN471760/index.html">爱德华·斯诺登：战场-加密</a></li>
<li><a href="../zh-CN471766/index.html">Kotlin / Java错误处理：如何正确执行？</a></li>
<li><a href="../zh-CN471770/index.html">认识大数据工具：IntelliJ IDEA中的Spark和Zeppelin笔记本支持</a></li>
<li><a href="../zh-CN471774/index.html">茶壶中的Android Camera2 API，第2部分，编写视频</a></li>
<li><a href="../zh-CN471776/index.html">Laravel：解释基本概念。 第二部分：练习</a></li>
<li><a href="../zh-CN471778/index.html">在HackQuest 2019上打破Micosoft Lunix</a></li>
<li><a href="../zh-CN471792/index.html">巫师从何处来？</a></li>
<li><a href="../zh-CN471794/index.html">平板天花板麦克风的时代</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>