<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏼 👦🏾 👵 OS1: un noyau primitif sur Rust pour x86. Partie 2. VGA, GDT, IDT 👩🏻‍🔬 🕴🏿 🤸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Première partie 


 Le premier article n'a pas encore eu le temps de refroidir, mais j'ai décidé de ne pas vous intriguer et d'écrire une suite. 


 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: un noyau primitif sur Rust pour x86. Partie 2. VGA, GDT, IDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445584/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Première partie</a> </p><br><p>  Le premier article n'a pas encore eu le temps de refroidir, mais j'ai décidé de ne pas vous intriguer et d'écrire une suite. </p><br><p>  Ainsi, dans l'article précédent, nous avons parlé de la liaison, du chargement du fichier noyau et de l'initialisation principale.  J'ai donné quelques liens utiles, expliqué comment le noyau chargé est situé dans la mémoire, comment les adresses virtuelles et physiques sont comparées au démarrage et comment activer la prise en charge du mécanisme de page.  Enfin, le contrôle est passé à la fonction kmain de mon noyau, écrite en Rust.  Il est temps de passer à autre chose et de découvrir la profondeur du terrier du lapin! </p><br><p>  Dans cette partie des notes, je <strong>décrirai brièvement ma configuration Rust, en termes généraux, je parlerai de la sortie des informations en VGA, et en détail de la configuration des segments et des interruptions</strong> .  Je demande à tous les intéressés sous la coupe, et nous commençons. </p><a name="habracut"></a><br><h1 id="nastroyka-rust">  Configuration de la rouille </h1><br><p> En général, il n'y a rien de particulièrement compliqué dans cette procédure, pour plus de détails vous pouvez contacter le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog Philippe</a> .  Cependant, je m'arrêterai à certains moments. </p><br><p>  Stable Rust ne prend toujours pas en charge certaines fonctionnalités nécessaires au développement de bas niveau.Par conséquent, pour désactiver la bibliothèque standard et s'appuyer sur Bare Bones, nous avons besoin de Rust tous les soirs.  Soyez prudent, une fois après la mise à jour vers la dernière version, j'ai obtenu un compilateur complètement inopérant et j'ai dû revenir au stable le plus proche.  Si vous êtes sûr que votre compilateur fonctionnait hier, mais qu'il a été mis à jour et ne fonctionne pas, exécutez la commande en remplaçant la date dont vous avez besoin </p><br><pre><code class="plaintext hljs">rustup override add nightly-YYYY-MM-DD</code> </pre> <br><p>  Pour plus de détails sur le mécanisme, vous pouvez contacter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ensuite, configurez la plate-forme cible pour laquelle nous allons.  J'étais basé sur le blog de Philip Opperman, tant de choses dans cette section lui ont été prises, démontées par des os et adaptées à mes besoins.  Philip développe pour x64 dans son blog, j'ai choisi à l'origine x32, donc mon target.json sera légèrement différent.  Je l'apporte complètement </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"llvm-target"</span></span>: <span class="hljs-string"><span class="hljs-string">"i686-unknown-none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"data-layout"</span></span>: <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-f64:32:64-f80:32-n8:16:32-S128"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"x86"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-endian"</span></span>: <span class="hljs-string"><span class="hljs-string">"little"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-pointer-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-c-int-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"os"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"executables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker-flavor"</span></span>: <span class="hljs-string"><span class="hljs-string">"ld.lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker"</span></span>: <span class="hljs-string"><span class="hljs-string">"rust-lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"panic-strategy"</span></span>: <span class="hljs-string"><span class="hljs-string">"abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"disable-redzone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"features"</span></span>: <span class="hljs-string"><span class="hljs-string">"-mmx,-sse,+soft-float"</span></span> }</code> </pre> <br><p>  La partie la plus difficile ici est le paramètre « <strong>data-layout</strong> ».  La documentation LLVM nous indique qu'il s'agit d'options de disposition de données, séparées par «-».  Le tout premier caractère «e» est responsable de l'indianité - dans notre cas, il est peu endian, comme l'exige la plate-forme.  Le deuxième caractère est m, «distorsion».  Responsable des noms des personnages lors de la mise en page.  Puisque notre format de sortie sera ELF (voir le script de construction), nous sélectionnons «m: e».  Le troisième caractère est la taille du pointeur en bits et ABI (Application binary interface).  Tout est simple ici, nous avons 32 bits, donc nous mettons hardiment «p: 32: 32».  Viennent ensuite les nombres à virgule flottante.  Nous signalons que nous prenons en charge les nombres 64 bits selon ABI 32 avec alignement 64 - "f64: 32: 64", ainsi que les nombres 80 bits avec alignement par défaut - "f80: 32".  L'élément suivant est des entiers.  Nous commençons avec 8 bits et passons à la plate-forme maximum de 32 bits - «n8: 16: 32».  Le dernier est l'alignement de la pile.  J'ai même besoin de nombres entiers de 128 bits, alors que ce soit S128.  Dans tous les cas, LLVM peut ignorer ce paramètre en toute sécurité, c'est notre préférence. </p><br><p>  En ce qui concerne les paramètres restants, vous pouvez jeter un œil à Philip, il explique tout bien. </p><br><p>  Nous avons également besoin de cargo-xbuild - un outil qui vous permet de compiler de manière croisée le noyau de rouille lors de la construction sous une plate-forme cible inconnue. <br>  Installez. </p><br><pre> <code class="bash hljs">cargo install cargo-xbuild</code> </pre> <br><p>  Nous allons le collecter comme ça. </p><br><pre> <code class="bash hljs">cargo xbuild -Z unstable-options --manifest-path=kernel/Cargo.toml --target kernel/targets/$(ARCH).json --out-dir=build/lib</code> </pre> <br><p>  J'avais besoin d'un manifeste pour le bon fonctionnement de Make, car il démarre à partir du répertoire racine et le noyau se trouve dans le répertoire du noyau. </p><br><p>  Parmi les fonctionnalités du manifeste, je ne peux mettre en évidence que <em>crate-type = ["staticlib"]</em> , ce qui donne un fichier <em>pouvant être lié</em> à la sortie.  Nous le nourrirons en LLD. </p><br><h1 id="kmain-i-pervonachalnaya-nastroyka">  kmain et configuration initiale </h1><br><p>  Selon les conventions de Rust, si nous créons une bibliothèque statique (ou un fichier binaire «plat»), la racine de la caisse doit contenir le fichier lib.rs, qui est le point d'entrée.  Dans celui-ci, à l'aide d'attributs, les fonctionnalités linguistiques sont configurées, et le précieux kmain est également localisé. </p><br><p>  Donc, dans la première étape, nous devrons désactiver la bibliothèque std.  Cela se fait avec une macro. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span></code> </pre> <br><p>  Avec une étape aussi simple, nous oublions immédiatement le multithreading, la mémoire dynamique et les autres délices de la bibliothèque standard.  De plus, nous nous privons même de la macro println!, Nous devrons donc l'implémenter nous-mêmes.  Je vais vous dire comment faire la prochaine fois. </p><br><p>  De nombreux tutoriels quelque part dans ce lieu se terminent par la sortie de "Hello World" et sans expliquer comment vivre.  Nous irons dans l'autre sens.  Tout d'abord, nous devons définir le code et les segments de données pour le mode protégé, configurer VGA, configurer les interruptions, ce que nous ferons. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> debug; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arch/i686/mod.rs"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> arch; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_magic: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { arch::arch_init(pd); ...... } <span class="hljs-meta"><span class="hljs-meta">#[panic_handler]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span></span>(_info: &amp;PanicInfo) -&gt; ! { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, _info); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> {} }</code> </pre> <br><p>  Que se passe-t-il ici?  Comme je l'ai dit, nous désactivons la bibliothèque standard.  Nous annoncerons également deux modules très importants - le débogage (dans lequel nous écrirons à l'écran) et arch (dans lequel toute la magie dépendante de la plateforme vivra).  J'utilise la fonction Rust avec des configurations pour déclarer les mêmes interfaces dans différentes implémentations architecturales et les utiliser au maximum.  Ici je m'arrête uniquement sur x86 et ensuite on n'en parle que. </p><br><p>  J'ai déclaré un gestionnaire de panique complètement primitif, ce dont Rust a besoin.  Il sera alors possible de le modifier. </p><br><p>  kmain accepte trois arguments et est également exporté en notation C sans distorsion de nom afin que l'éditeur de liens puisse correctement associer la fonction à l'appel de _loader, que j'ai décrit dans l'article précédent.  Le premier argument est l'adresse de la table de pages PD, le second est l'adresse <strong>physique</strong> de la structure GRUB, d'où nous obtiendrons la carte mémoire, le troisième est le nombre magique.  À l'avenir, je voudrais implémenter à la fois la prise en charge de Multiboot 2 et mon propre chargeur de démarrage.J'utilise donc un nombre magique pour identifier la méthode de démarrage. </p><br><p>  Le premier appel kmain est l'initialisation spécifique à la plate-forme.  On rentre.  La fonction arch_init se trouve dans le fichier arch / i686 / mod.rs, est publique, spécifique à x86 32 bits et ressemble à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arch_init</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { vga::VGA_WRITER.lock().init(); gdt::setup_gdt(); idt::init_idt(); paging::setup_pd(pd); } }</code> </pre> <br><p>  Comme vous pouvez le voir, pour x86, la sortie, la segmentation, les interruptions et la pagination sont initialisées dans l'ordre.  Commençons par VGA. </p><br><h1 id="inicializaciya-vga">  Initialisation VGA </h1><br><p>  Chaque tutoriel considère qu'il est de son devoir d'imprimer Hello World, vous trouverez donc comment travailler avec VGA partout.  Pour cette raison, j'irai le plus brièvement possible, je me concentrerai uniquement sur les puces que j'ai faites moi-même.  Sur l'utilisation de lazy_static je vous enverrai sur le blog de Philippe et ne vous expliquerai pas en détail.  const fn n'est pas encore en version, donc les initialisations magnifiquement statiques ne peuvent pas encore être faites.  Et nous allons ajouter un verrou de rotation pour qu'il ne se révèle pas être un gâchis. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> VGA_WRITER : Mutex&lt;Writer&gt; = Mutex::new(Writer { cursor_position: <span class="hljs-number"><span class="hljs-number">0</span></span>, vga_color: ColorCode::new(Color::LightGray, Color::Black), buffer: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC00B8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer) } }); }</code> </pre> <br><p>  Comme vous le savez, le tampon d'écran est situé à l'adresse physique 0xB8000 et a une taille de 80x25x2 octets (largeur et hauteur de l'écran, octet par caractère et attributs: couleurs, scintillement).  Puisque nous avons déjà activé la mémoire virtuelle, l'accès à cette adresse se bloquera, nous ajoutons donc 3 Go.  Nous déréférençons également un pointeur brut, ce qui n'est pas sûr - mais nous savons ce que nous faisons. <br>  Ce qui est peut-être intéressant dans ce fichier, c'est seulement l'implémentation de la structure Writer, qui permet non seulement d'afficher les caractères dans une rangée, mais aussi de faire défiler, d'aller à n'importe quel endroit de l'écran et d'autres plaisanteries agréables. </p><br><div class="spoiler">  <b class="spoiler_title">Écrivain VGA</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span></span> { cursor_position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, vga_color: ColorCode, buffer: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Writer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vga_color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code: vga_color, } } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor_abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D5</span></span>, (position &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0E</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, ((position &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = position; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(y * VGA_WIDTH + x); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position + offset; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position % VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_y</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position / VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color_code = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ln</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_line = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_y() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_line &gt;= VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, next_line) } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_xy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_pos</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[position] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position &gt;= VGA_WIDTH * VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte_at_pos(byte, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.move_cursor(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.bytes() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> byte { <span class="hljs-number"><span class="hljs-number">0x20</span></span>...<span class="hljs-number"><span class="hljs-number">0xFF</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(byte), <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ln(), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(<span class="hljs-number"><span class="hljs-number">0xfe</span></span>), } } } }</code> </pre> </div></div><br><p>  Lors du rembobinage, il suffit de copier des sections de mémoire de la taille de la largeur de l'écran vers l'arrière, en remplissant avec des blancs une nouvelle ligne (c'est ainsi que je fais le nettoyage).  Les appels sortants sont un peu plus intéressants - en aucun cas autre que de travailler avec des ports d'E / S, il est impossible de déplacer le curseur.  Cependant, nous avons toujours besoin d'entrées / sorties via des ports, ils ont donc été livrés dans un emballage séparé et emballés dans des emballages sécurisés.  Sous le spoiler ci-dessous se trouve le code assembleur.  Pour l'instant, il suffit de savoir que: </p><br><ul><li>  Le décalage absolu du curseur, et non les coordonnées, s'affiche. </li><li>  Vous pouvez émettre vers le contrôleur un octet à la fois </li><li>  La sortie d'un octet se produit en deux commandes - nous écrivons d'abord la commande sur le contrôleur, puis les données. </li><li>  Le port pour les commandes est 0x3D4, le port de données est 0x3D5 </li><li>  Tout d'abord, imprimez l'octet inférieur de la position avec la commande 0x0F, puis le haut avec la commande 0x0E </li></ul><br><div class="spoiler">  <b class="spoiler_title">out.asm</b> <div class="spoiler_text"><p>  Faites attention à travailler avec les variables passées sur la pile.  Étant donné que la pile commence à la fin de l'espace et réduit le pointeur de pile lors de l'appel de la fonction, pour obtenir des paramètres, un point de retour, etc., vous devez ajouter la taille d'argument alignée avec l'alignement de la pile au registre ESP, dans notre cas 4 octets. </p><br><pre> <code class="plaintext hljs">global writeb global writew global writed section .text writeb: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 byte value aligned 4 bytes out dx, al ;write byte by port number an dx - value in al mov esp, ebp pop ebp ret writew: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 word value aligned 4 bytes out dx, ax ;write word by port number an dx - value in ax mov esp, ebp pop ebp ret writed: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 double word value aligned 4 bytes out dx, eax ;write double word by port number an dx - value in eax mov esp, ebp pop ebp ret</code> </pre> </div></div><br><h1 id="nastroyka-segmentov">  Configuration du segment </h1><br><p>  Nous sommes arrivés au sujet le plus déroutant, mais en même temps le plus simple.  Comme je l'ai dit dans un article précédent, l'organisation des pages et des segments de mémoire était mélangée dans ma tête, j'ai chargé l'adresse de la table des pages dans le GDTR et j'ai attrapé ma tête.  Il m'a fallu plusieurs mois pour lire suffisamment le matériel, le digérer et pouvoir le réaliser.  J'ai peut-être été victime de l'assembleur de manuels de Peter Abel.  Le langage et la programmation pour IBM PC »(un excellent livre!), Qui décrit la segmentation pour Intel 8086. Dans ces moments agréables, nous avons chargé les 16 bits supérieurs d'une adresse de vingt bits dans le registre de segment, et c'était l'adresse en mémoire.  Il s'est avéré être une cruelle déception qu'en commençant avec i286 en mode protégé, tout soit complètement faux. </p><br><p>  Ainsi, la simple théorie est que x86 prend en charge un modèle de mémoire segmentée, car les anciens programmes ne pouvaient sortir qu'au-delà de 640 Ko, puis 1 Mo de mémoire. </p><br><p>  Les programmeurs devaient réfléchir à la manière de placer le code exécutable, de placer les données et de maintenir leur sécurité.  L'avènement de l'organisation des pages a rendu l'organisation segmentée inutile, mais elle est restée à des fins de compatibilité et de protection (séparation des privilèges pour l'espace noyau et l'espace utilisateur), donc sans elle, ce n'est nulle part.  Certaines instructions du processeur sont interdites lorsque le niveau de privilège est inférieur à 0 et l'accès entre les segments de programme et de noyau provoquera une erreur de segmentation. </p><br><p>  Faisons-le à nouveau (espérons-le dans le dernier) à propos de la traduction d'adresses <br>  Adresse de ligne [0x08: 0xFFFFFFFF] -&gt; Vérifier les autorisations de segment 0x08 -&gt; Adresse virtuelle [0xFFFFFFFF] -&gt; Tableau de page + TLB -&gt; Adresse physique [0xAAAAFFFF] </p><br><p>  Un segment est utilisé uniquement à l'intérieur du processeur, est stocké dans un registre de segment spécial (CS, SS, DS, ES, FS, GS) et est utilisé exclusivement pour vérifier les droits d'exécution de code et de contrôle de transfert.  C'est pourquoi vous ne pouvez pas simplement prendre et appeler la fonction noyau depuis l'espace utilisateur.  Le segment avec le descripteur 0x18 (j'en ai un, le vôtre est différent) a des droits de niveau 3, et le segment avec le descripteur 0x08 a des droits de niveau 0. Selon la convention x86, pour se protéger contre les accès non autorisés, un segment avec moins de privilèges ne peut pas appeler directement un segment avec grand droits via jmp 0x08: [EAX], mais est obligé d'utiliser d'autres mécanismes, tels que des pièges, des portes, des interruptions. </p><br><p>  Les segments et leurs types (code, données, échelles, portes) doivent être décrits dans le tableau des descripteurs globaux GDT, dont l'adresse <strong>virtuelle</strong> et la taille sont chargés dans le registre GDTR.  Lorsque vous passez d'un segment à l'autre (par souci de simplicité, je suppose qu'une transition directe est possible), vous devez appeler l'instruction jmp 0x08: [EAX], où 0x08 est le <strong>décalage du premier descripteur valide en octets depuis le début du tableau</strong> et EAX est le registre contenant l'adresse de transition.  Le décalage (sélecteur) sera chargé dans le registre CS et le descripteur correspondant sera chargé dans le registre fantôme du processeur.  Chaque descripteur est une structure à 8 octets.  Il est bien documenté et sa description se trouve à la fois sur OSDev et dans la documentation Intel (voir le premier article). </p><br><p>  Je résume.  Lorsque nous initialisons GDT et exécutons la transition jmp 0x08: [EAX], l'état du processeur sera le suivant: </p><br><ul><li>  GDTR contient une adresse GDT <strong>virtuelle</strong> </li><li>  CS contient la valeur 0x08 </li><li>  Un handle vers l'adresse [GDTR + 0x08] a été copié dans le registre fantôme CS à partir de la mémoire </li><li>  Le registre EIP contient l'adresse du registre EAX </li></ul><br><p>  Le descripteur zéro doit toujours être non initialisé et son accès est interdit.  Je m'attarderai sur le descripteur TSS et sa signification plus en détail lorsque nous discuterons du multithreading.  Ma table GDT ressemble maintenant à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_gdt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_gdt</span></span></span></span>() { GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_offset((&amp;super::tss::TSS) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_limit(core::mem::size_of::&lt;super::tss::Tss&gt;() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gdt_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry = GDT.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> limit = (GDT.len() * core::mem::size_of::&lt;GdtEntry&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>; load_gdt(gdt_ptr, limit); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> GDT: [GdtEntry; <span class="hljs-number"><span class="hljs-number">7</span></span>] = [ <span class="hljs-comment"><span class="hljs-comment">//null descriptor - cannot access GdtEntry::new(0, 0, 0, 0), //kernel code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //kernel data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //TSS - for interrupt handling in multithreading GdtEntry::new(0, 0, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_TSS_AVAIL, 0), GdtEntry::new(0, 0, 0, 0), ];</span></span></code> </pre> <br><p>  Et voici l'initialisation, dont j'ai beaucoup parlé plus haut.  Le chargement des adresses et des tailles GDT se fait via une structure distincte, qui ne contient que deux champs.  L'adresse de cette structure est transmise à la commande lgdt.  Dans les registres de segments de données, chargez le descripteur suivant avec un décalage de 0x10. </p><br><pre> <code class="plaintext hljs">global load_gdt section .text gdtr dw 0 ; For limit storage dd 0 ; For base storage load_gdt: mov eax, [esp + 4] mov [gdtr + 2], eax mov ax, [esp + 8] mov [gdtr], ax lgdt [gdtr] jmp 0x08:.reload_CS .reload_CS: mov ax, 0x10 ; 0x10 points at the new data selector mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov ax, 0x28 ltr ax ret</code> </pre> <br><p>  Ensuite, tout sera un peu plus facile, mais non moins intéressant. </p><br><h1 id="preryvaniya">  Interruptions </h1><br><p>  En fait, il est temps de nous donner l'opportunité d'interagir avec notre cœur (au moins pour voir ce que nous appuyons sur le clavier).  Pour ce faire, vous devez initialiser le contrôleur d'interruption. </p><br><p>  Digression lyrique sur le style de code. </p><br><p>  Grâce aux efforts de la communauté et en particulier de Philip Opperman, la convention d'appel x86-interruption a été ajoutée à Rust, ce qui vous permet d'écrire des gestionnaires d'interruption qui exécutent iret.  Cependant, j'ai délibérément décidé de ne pas suivre cette voie, car j'ai décidé de séparer l'assembleur et Rust dans des fichiers différents, et donc des fonctions.  Oui, j'utilise déraisonnablement la mémoire de la pile, j'en suis conscient, mais c'est encore du goût.  Mes gestionnaires d'interruption sont écrits en assembleur et font exactement une chose: ils appellent presque les mêmes gestionnaires d'interruption écrits en Rust.  Veuillez accepter ce fait et soyez indulgents. </p><br><p>  En général, le processus d'initialisation des interruptions est similaire à l'initialisation d'un GDT, mais est plus facile à comprendre.  D'un autre côté, vous avez besoin de beaucoup de code uniforme.  Les développeurs de Redox OS prennent une belle décision, en utilisant tous les plaisirs du langage, mais je suis allé «sur le front» et j'ai décidé d'autoriser la duplication de code. </p><br><p>  Selon la convention x86, nous avons des interruptions, mais il existe des situations exceptionnelles.  Dans ce contexte, les paramètres pour nous sont pratiquement les mêmes.  La seule différence est que lorsqu'une exception est levée, la pile peut contenir des informations supplémentaires.  Par exemple, je l'utilise pour gérer le manque de page lorsque je travaille avec un tas (mais tout a son temps).  Les interruptions et les exceptions sont traitées à partir de la même table, que vous et moi devons remplir.  Il est également nécessaire de programmer le PIC (Programmable Interrupt Controller).  Il y a aussi l'APIC, mais je ne l'ai pas encore compris. </p><br><p>  En travaillant avec PIC, je ne ferai pas beaucoup de commentaires, car il existe de nombreux exemples sur le réseau pour travailler avec lui.  Je vais commencer par les gestionnaires de l'assembleur.  Ils sont tous complètement identiques, donc je vais supprimer le code du spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">IRQ</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global irq0 global irq1 ...... global irq14 global irq15 extern kirq0 extern kirq1 ...... extern kirq14 extern kirq15 section .text irq0: pusha call kirq0 popa iret irq1: pusha call kirq1 popa iret ...... irq14: pusha call kirq14 popa iret irq15: pusha call kirq15 popa iret</code> </pre> </div></div><br><p>  Comme vous pouvez le voir, tous les appels aux fonctions Rust commencent par le préfixe «k» - pour la distinction et la commodité.  La gestion des exceptions est exactement la même.  Pour les fonctions assembleur, le préfixe «e» est sélectionné, pour Rust, «k».  Le gestionnaire de défauts de page est différent, mais à ce sujet - dans les notes sur la gestion de la mémoire. </p><br><div class="spoiler">  <b class="spoiler_title">Exceptions</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global e0_zero_divide global e1_debug ...... global eE_page_fault ...... global e14_virtualization global e1E_security extern k0_zero_divide extern k1_debug ...... extern kE_page_fault ...... extern k14_virtualization extern k1E_security section .text e0_zero_divide: pushad call k0_zero_divide popad iret e1_debug: pushad call k1_debug popad iret ...... eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret ...... e14_virtualization: pushad call k14_virtualization popad iret e1E_security: pushad call k1E_security popad iret</code> </pre> </div></div><br><p>  Nous déclarons les gestionnaires d'assembleurs: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_idt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e0_zero_divide</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1_debug</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e14_virtualization</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1E_security</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq0</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq1</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq14</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq15</span></span></span></span>(); }</code> </pre> <br><p>  Nous définissons les gestionnaires Rust que nous appelons ci-dessus.  Veuillez noter que pour interrompre le clavier, j'affiche simplement le code reçu, que j'obtiens du port 0x60 - c'est ainsi que le clavier fonctionne dans le mode le plus simple.  À l'avenir, cela se transformera en un pilote à part entière, j'espère.  Après chaque interruption, vous devez envoyer au contrôleur le signal de fin de traitement 0x20, c'est important!  Sinon, vous n'obtiendrez pas plus d'interruptions. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kirq0</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// println!("IRQ 0"); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq1() { let ch: char = inb(0x60) as char; crate::arch::vga::VGA_WRITER.force_unlock(); println!("IRQ 1 {}", ch); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq2() { println!("IRQ 2"); outb(0x20, 0x20); } ...</span></span></code> </pre> <br><p>  Initialisation de IDT et PIC.  À propos de PIC et de son remappage, j'ai trouvé un grand nombre de didacticiels de différents degrés de détail, commençant par OSDev et se terminant par des sites amateurs.  Étant donné que la procédure de programmation fonctionne avec une séquence constante d'opérations et de commandes constantes, je donnerai ce code sans autre explication.     ,        0x20-0x2F  ,       0x20  0x28,     16    IDT. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pic</span></span></span></span>(pic1: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, pic2: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start initialization outb(PIC1, 0x11); outb(PIC2, 0x11); // Set offsets outb(PIC1 + 1, pic1); /* remap */ outb(PIC2 + 1, pic2); /* pics */ // Set up cascade outb(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */ outb(PIC2 + 1, 2); // Set up interrupt mode (1 is 8086/88 mode, 2 is auto EOI) outb(PIC1 + 1, 1); outb(PIC2 + 1, 1); // Unmask interrupts outb(PIC1 + 1, 0); outb(PIC2 + 1, 0); // Ack waiting outb(PIC1, 0x20); outb(PIC2, 0x20); } pub unsafe fn init_idt() { IDT[0x0].set_func(e0_zero_divide); IDT[0x1].set_func(e1_debug); ...... IDT[0x14].set_func(e14_virtualization); IDT[0x1E].set_func(e1E_security); IDT[0x20].set_func(irq0); IDT[0x21].set_func(irq1); ...... IDT[0x2E].set_func(irq14); IDT[0x2F].set_func(irq15); setup_pic(0x20, 0x28); let idt_ptr: *const IdtEntry = IDT.as_ptr(); let limit = (IDT.len() * core::mem::size_of::&lt;IdtEntry&gt;() - 1) as u16; load_idt(idt_ptr, limit); }</span></span></code> </pre> <br><p>      IDTR   GDTR —       .  STI        —         —  ,    ,  ASCII-   -. </p><br><pre> <code class="plaintext hljs">global load_idt section .text idtr dw 0 ; For limit storage dd 0 ; For base storage load_idt: mov eax, [esp + 4] mov [idtr + 2], eax mov ax, [esp + 8] mov [idtr], ax lidt [idtr] sti ret</code> </pre> <br><h1 id="posleslovie">  Postface </h1><br><p>  ,     ,            .      setup_pd,           . ,   ,     ,  . </p><br><p>   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitLab</a> . </p><br><p>  Merci de votre attention! </p><br><p> UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445584/">https://habr.com/ru/post/fr445584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445568/index.html">Surveillance et gestion à distance des périphériques Linux / OpenWrt / Lede via le port 80 ...</a></li>
<li><a href="../fr445570/index.html">Le condensé des événements pour les professionnels des RH dans le domaine des TI pour avril 2019</a></li>
<li><a href="../fr445572/index.html">Le gouvernement américain prévoit d'envoyer des gens sur la lune dans 5 ans</a></li>
<li><a href="../fr445580/index.html">Une liste exhaustive des différences entre VB.NET et C #. 2e partie</a></li>
<li><a href="../fr445582/index.html">Systèmes CRM: protection ou menace?</a></li>
<li><a href="../fr445586/index.html">Android Academy à Moscou - parler de comment c'était et partager des supports de cours</a></li>
<li><a href="../fr445588/index.html">Le scan 3D d'une personne en 30 secondes sera montré à l'exposition</a></li>
<li><a href="../fr445590/index.html">Grammaire anglaise. Qui vs Qui - comment comprendre quel mot utiliser</a></li>
<li><a href="../fr445592/index.html">Initialisation paresseuse dans Spring Boot 2.2</a></li>
<li><a href="../fr445594/index.html">Outils pour créer un site réactif sans accès au site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>