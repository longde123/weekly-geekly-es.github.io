<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèº üë¶üèæ üëµ OS1: un noyau primitif sur Rust pour x86. Partie 2. VGA, GDT, IDT üë©üèª‚Äçüî¨ üï¥üèø ü§∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Premi√®re partie 


 Le premier article n'a pas encore eu le temps de refroidir, mais j'ai d√©cid√© de ne pas vous intriguer et d'√©crire une suite. 


 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: un noyau primitif sur Rust pour x86. Partie 2. VGA, GDT, IDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445584/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie</a> </p><br><p>  Le premier article n'a pas encore eu le temps de refroidir, mais j'ai d√©cid√© de ne pas vous intriguer et d'√©crire une suite. </p><br><p>  Ainsi, dans l'article pr√©c√©dent, nous avons parl√© de la liaison, du chargement du fichier noyau et de l'initialisation principale.  J'ai donn√© quelques liens utiles, expliqu√© comment le noyau charg√© est situ√© dans la m√©moire, comment les adresses virtuelles et physiques sont compar√©es au d√©marrage et comment activer la prise en charge du m√©canisme de page.  Enfin, le contr√¥le est pass√© √† la fonction kmain de mon noyau, √©crite en Rust.  Il est temps de passer √† autre chose et de d√©couvrir la profondeur du terrier du lapin! </p><br><p>  Dans cette partie des notes, je <strong>d√©crirai bri√®vement ma configuration Rust, en termes g√©n√©raux, je parlerai de la sortie des informations en VGA, et en d√©tail de la configuration des segments et des interruptions</strong> .  Je demande √† tous les int√©ress√©s sous la coupe, et nous commen√ßons. </p><a name="habracut"></a><br><h1 id="nastroyka-rust">  Configuration de la rouille </h1><br><p> En g√©n√©ral, il n'y a rien de particuli√®rement compliqu√© dans cette proc√©dure, pour plus de d√©tails vous pouvez contacter le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog Philippe</a> .  Cependant, je m'arr√™terai √† certains moments. </p><br><p>  Stable Rust ne prend toujours pas en charge certaines fonctionnalit√©s n√©cessaires au d√©veloppement de bas niveau.Par cons√©quent, pour d√©sactiver la biblioth√®que standard et s'appuyer sur Bare Bones, nous avons besoin de Rust tous les soirs.  Soyez prudent, une fois apr√®s la mise √† jour vers la derni√®re version, j'ai obtenu un compilateur compl√®tement inop√©rant et j'ai d√ª revenir au stable le plus proche.  Si vous √™tes s√ªr que votre compilateur fonctionnait hier, mais qu'il a √©t√© mis √† jour et ne fonctionne pas, ex√©cutez la commande en rempla√ßant la date dont vous avez besoin </p><br><pre><code class="plaintext hljs">rustup override add nightly-YYYY-MM-DD</code> </pre> <br><p>  Pour plus de d√©tails sur le m√©canisme, vous pouvez contacter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Ensuite, configurez la plate-forme cible pour laquelle nous allons.  J'√©tais bas√© sur le blog de Philip Opperman, tant de choses dans cette section lui ont √©t√© prises, d√©mont√©es par des os et adapt√©es √† mes besoins.  Philip d√©veloppe pour x64 dans son blog, j'ai choisi √† l'origine x32, donc mon target.json sera l√©g√®rement diff√©rent.  Je l'apporte compl√®tement </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"llvm-target"</span></span>: <span class="hljs-string"><span class="hljs-string">"i686-unknown-none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"data-layout"</span></span>: <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-f64:32:64-f80:32-n8:16:32-S128"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"x86"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-endian"</span></span>: <span class="hljs-string"><span class="hljs-string">"little"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-pointer-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-c-int-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"os"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"executables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker-flavor"</span></span>: <span class="hljs-string"><span class="hljs-string">"ld.lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker"</span></span>: <span class="hljs-string"><span class="hljs-string">"rust-lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"panic-strategy"</span></span>: <span class="hljs-string"><span class="hljs-string">"abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"disable-redzone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"features"</span></span>: <span class="hljs-string"><span class="hljs-string">"-mmx,-sse,+soft-float"</span></span> }</code> </pre> <br><p>  La partie la plus difficile ici est le param√®tre ¬´ <strong>data-layout</strong> ¬ª.  La documentation LLVM nous indique qu'il s'agit d'options de disposition de donn√©es, s√©par√©es par ¬´-¬ª.  Le tout premier caract√®re ¬´e¬ª est responsable de l'indianit√© - dans notre cas, il est peu endian, comme l'exige la plate-forme.  Le deuxi√®me caract√®re est m, ¬´distorsion¬ª.  Responsable des noms des personnages lors de la mise en page.  Puisque notre format de sortie sera ELF (voir le script de construction), nous s√©lectionnons ¬´m: e¬ª.  Le troisi√®me caract√®re est la taille du pointeur en bits et ABI (Application binary interface).  Tout est simple ici, nous avons 32 bits, donc nous mettons hardiment ¬´p: 32: 32¬ª.  Viennent ensuite les nombres √† virgule flottante.  Nous signalons que nous prenons en charge les nombres 64 bits selon ABI 32 avec alignement 64 - "f64: 32: 64", ainsi que les nombres 80 bits avec alignement par d√©faut - "f80: 32".  L'√©l√©ment suivant est des entiers.  Nous commen√ßons avec 8 bits et passons √† la plate-forme maximum de 32 bits - ¬´n8: 16: 32¬ª.  Le dernier est l'alignement de la pile.  J'ai m√™me besoin de nombres entiers de 128 bits, alors que ce soit S128.  Dans tous les cas, LLVM peut ignorer ce param√®tre en toute s√©curit√©, c'est notre pr√©f√©rence. </p><br><p>  En ce qui concerne les param√®tres restants, vous pouvez jeter un ≈ìil √† Philip, il explique tout bien. </p><br><p>  Nous avons √©galement besoin de cargo-xbuild - un outil qui vous permet de compiler de mani√®re crois√©e le noyau de rouille lors de la construction sous une plate-forme cible inconnue. <br>  Installez. </p><br><pre> <code class="bash hljs">cargo install cargo-xbuild</code> </pre> <br><p>  Nous allons le collecter comme √ßa. </p><br><pre> <code class="bash hljs">cargo xbuild -Z unstable-options --manifest-path=kernel/Cargo.toml --target kernel/targets/$(ARCH).json --out-dir=build/lib</code> </pre> <br><p>  J'avais besoin d'un manifeste pour le bon fonctionnement de Make, car il d√©marre √† partir du r√©pertoire racine et le noyau se trouve dans le r√©pertoire du noyau. </p><br><p>  Parmi les fonctionnalit√©s du manifeste, je ne peux mettre en √©vidence que <em>crate-type = ["staticlib"]</em> , ce qui donne un fichier <em>pouvant √™tre li√©</em> √† la sortie.  Nous le nourrirons en LLD. </p><br><h1 id="kmain-i-pervonachalnaya-nastroyka">  kmain et configuration initiale </h1><br><p>  Selon les conventions de Rust, si nous cr√©ons une biblioth√®que statique (ou un fichier binaire ¬´plat¬ª), la racine de la caisse doit contenir le fichier lib.rs, qui est le point d'entr√©e.  Dans celui-ci, √† l'aide d'attributs, les fonctionnalit√©s linguistiques sont configur√©es, et le pr√©cieux kmain est √©galement localis√©. </p><br><p>  Donc, dans la premi√®re √©tape, nous devrons d√©sactiver la biblioth√®que std.  Cela se fait avec une macro. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span></code> </pre> <br><p>  Avec une √©tape aussi simple, nous oublions imm√©diatement le multithreading, la m√©moire dynamique et les autres d√©lices de la biblioth√®que standard.  De plus, nous nous privons m√™me de la macro println!, Nous devrons donc l'impl√©menter nous-m√™mes.  Je vais vous dire comment faire la prochaine fois. </p><br><p>  De nombreux tutoriels quelque part dans ce lieu se terminent par la sortie de "Hello World" et sans expliquer comment vivre.  Nous irons dans l'autre sens.  Tout d'abord, nous devons d√©finir le code et les segments de donn√©es pour le mode prot√©g√©, configurer VGA, configurer les interruptions, ce que nous ferons. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> debug; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arch/i686/mod.rs"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> arch; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_magic: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { arch::arch_init(pd); ...... } <span class="hljs-meta"><span class="hljs-meta">#[panic_handler]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span></span>(_info: &amp;PanicInfo) -&gt; ! { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, _info); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> {} }</code> </pre> <br><p>  Que se passe-t-il ici?  Comme je l'ai dit, nous d√©sactivons la biblioth√®que standard.  Nous annoncerons √©galement deux modules tr√®s importants - le d√©bogage (dans lequel nous √©crirons √† l'√©cran) et arch (dans lequel toute la magie d√©pendante de la plateforme vivra).  J'utilise la fonction Rust avec des configurations pour d√©clarer les m√™mes interfaces dans diff√©rentes impl√©mentations architecturales et les utiliser au maximum.  Ici je m'arr√™te uniquement sur x86 et ensuite on n'en parle que. </p><br><p>  J'ai d√©clar√© un gestionnaire de panique compl√®tement primitif, ce dont Rust a besoin.  Il sera alors possible de le modifier. </p><br><p>  kmain accepte trois arguments et est √©galement export√© en notation C sans distorsion de nom afin que l'√©diteur de liens puisse correctement associer la fonction √† l'appel de _loader, que j'ai d√©crit dans l'article pr√©c√©dent.  Le premier argument est l'adresse de la table de pages PD, le second est l'adresse <strong>physique</strong> de la structure GRUB, d'o√π nous obtiendrons la carte m√©moire, le troisi√®me est le nombre magique.  √Ä l'avenir, je voudrais impl√©menter √† la fois la prise en charge de Multiboot 2 et mon propre chargeur de d√©marrage.J'utilise donc un nombre magique pour identifier la m√©thode de d√©marrage. </p><br><p>  Le premier appel kmain est l'initialisation sp√©cifique √† la plate-forme.  On rentre.  La fonction arch_init se trouve dans le fichier arch / i686 / mod.rs, est publique, sp√©cifique √† x86 32 bits et ressemble √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arch_init</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { vga::VGA_WRITER.lock().init(); gdt::setup_gdt(); idt::init_idt(); paging::setup_pd(pd); } }</code> </pre> <br><p>  Comme vous pouvez le voir, pour x86, la sortie, la segmentation, les interruptions et la pagination sont initialis√©es dans l'ordre.  Commen√ßons par VGA. </p><br><h1 id="inicializaciya-vga">  Initialisation VGA </h1><br><p>  Chaque tutoriel consid√®re qu'il est de son devoir d'imprimer Hello World, vous trouverez donc comment travailler avec VGA partout.  Pour cette raison, j'irai le plus bri√®vement possible, je me concentrerai uniquement sur les puces que j'ai faites moi-m√™me.  Sur l'utilisation de lazy_static je vous enverrai sur le blog de Philippe et ne vous expliquerai pas en d√©tail.  const fn n'est pas encore en version, donc les initialisations magnifiquement statiques ne peuvent pas encore √™tre faites.  Et nous allons ajouter un verrou de rotation pour qu'il ne se r√©v√®le pas √™tre un g√¢chis. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> VGA_WRITER : Mutex&lt;Writer&gt; = Mutex::new(Writer { cursor_position: <span class="hljs-number"><span class="hljs-number">0</span></span>, vga_color: ColorCode::new(Color::LightGray, Color::Black), buffer: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC00B8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer) } }); }</code> </pre> <br><p>  Comme vous le savez, le tampon d'√©cran est situ√© √† l'adresse physique 0xB8000 et a une taille de 80x25x2 octets (largeur et hauteur de l'√©cran, octet par caract√®re et attributs: couleurs, scintillement).  Puisque nous avons d√©j√† activ√© la m√©moire virtuelle, l'acc√®s √† cette adresse se bloquera, nous ajoutons donc 3 Go.  Nous d√©r√©f√©ren√ßons √©galement un pointeur brut, ce qui n'est pas s√ªr - mais nous savons ce que nous faisons. <br>  Ce qui est peut-√™tre int√©ressant dans ce fichier, c'est seulement l'impl√©mentation de la structure Writer, qui permet non seulement d'afficher les caract√®res dans une rang√©e, mais aussi de faire d√©filer, d'aller √† n'importe quel endroit de l'√©cran et d'autres plaisanteries agr√©ables. </p><br><div class="spoiler">  <b class="spoiler_title">√âcrivain VGA</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span></span> { cursor_position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, vga_color: ColorCode, buffer: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Writer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vga_color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code: vga_color, } } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor_abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D5</span></span>, (position &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0E</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, ((position &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = position; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(y * VGA_WIDTH + x); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position + offset; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position % VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_y</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position / VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color_code = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ln</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_line = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_y() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_line &gt;= VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, next_line) } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_xy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_pos</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[position] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position &gt;= VGA_WIDTH * VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte_at_pos(byte, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.move_cursor(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.bytes() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> byte { <span class="hljs-number"><span class="hljs-number">0x20</span></span>...<span class="hljs-number"><span class="hljs-number">0xFF</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(byte), <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ln(), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(<span class="hljs-number"><span class="hljs-number">0xfe</span></span>), } } } }</code> </pre> </div></div><br><p>  Lors du rembobinage, il suffit de copier des sections de m√©moire de la taille de la largeur de l'√©cran vers l'arri√®re, en remplissant avec des blancs une nouvelle ligne (c'est ainsi que je fais le nettoyage).  Les appels sortants sont un peu plus int√©ressants - en aucun cas autre que de travailler avec des ports d'E / S, il est impossible de d√©placer le curseur.  Cependant, nous avons toujours besoin d'entr√©es / sorties via des ports, ils ont donc √©t√© livr√©s dans un emballage s√©par√© et emball√©s dans des emballages s√©curis√©s.  Sous le spoiler ci-dessous se trouve le code assembleur.  Pour l'instant, il suffit de savoir que: </p><br><ul><li>  Le d√©calage absolu du curseur, et non les coordonn√©es, s'affiche. </li><li>  Vous pouvez √©mettre vers le contr√¥leur un octet √† la fois </li><li>  La sortie d'un octet se produit en deux commandes - nous √©crivons d'abord la commande sur le contr√¥leur, puis les donn√©es. </li><li>  Le port pour les commandes est 0x3D4, le port de donn√©es est 0x3D5 </li><li>  Tout d'abord, imprimez l'octet inf√©rieur de la position avec la commande 0x0F, puis le haut avec la commande 0x0E </li></ul><br><div class="spoiler">  <b class="spoiler_title">out.asm</b> <div class="spoiler_text"><p>  Faites attention √† travailler avec les variables pass√©es sur la pile.  √âtant donn√© que la pile commence √† la fin de l'espace et r√©duit le pointeur de pile lors de l'appel de la fonction, pour obtenir des param√®tres, un point de retour, etc., vous devez ajouter la taille d'argument align√©e avec l'alignement de la pile au registre ESP, dans notre cas 4 octets. </p><br><pre> <code class="plaintext hljs">global writeb global writew global writed section .text writeb: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 byte value aligned 4 bytes out dx, al ;write byte by port number an dx - value in al mov esp, ebp pop ebp ret writew: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 word value aligned 4 bytes out dx, ax ;write word by port number an dx - value in ax mov esp, ebp pop ebp ret writed: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 double word value aligned 4 bytes out dx, eax ;write double word by port number an dx - value in eax mov esp, ebp pop ebp ret</code> </pre> </div></div><br><h1 id="nastroyka-segmentov">  Configuration du segment </h1><br><p>  Nous sommes arriv√©s au sujet le plus d√©routant, mais en m√™me temps le plus simple.  Comme je l'ai dit dans un article pr√©c√©dent, l'organisation des pages et des segments de m√©moire √©tait m√©lang√©e dans ma t√™te, j'ai charg√© l'adresse de la table des pages dans le GDTR et j'ai attrap√© ma t√™te.  Il m'a fallu plusieurs mois pour lire suffisamment le mat√©riel, le dig√©rer et pouvoir le r√©aliser.  J'ai peut-√™tre √©t√© victime de l'assembleur de manuels de Peter Abel.  Le langage et la programmation pour IBM PC ¬ª(un excellent livre!), Qui d√©crit la segmentation pour Intel 8086. Dans ces moments agr√©ables, nous avons charg√© les 16 bits sup√©rieurs d'une adresse de vingt bits dans le registre de segment, et c'√©tait l'adresse en m√©moire.  Il s'est av√©r√© √™tre une cruelle d√©ception qu'en commen√ßant avec i286 en mode prot√©g√©, tout soit compl√®tement faux. </p><br><p>  Ainsi, la simple th√©orie est que x86 prend en charge un mod√®le de m√©moire segment√©e, car les anciens programmes ne pouvaient sortir qu'au-del√† de 640 Ko, puis 1 Mo de m√©moire. </p><br><p>  Les programmeurs devaient r√©fl√©chir √† la mani√®re de placer le code ex√©cutable, de placer les donn√©es et de maintenir leur s√©curit√©.  L'av√®nement de l'organisation des pages a rendu l'organisation segment√©e inutile, mais elle est rest√©e √† des fins de compatibilit√© et de protection (s√©paration des privil√®ges pour l'espace noyau et l'espace utilisateur), donc sans elle, ce n'est nulle part.  Certaines instructions du processeur sont interdites lorsque le niveau de privil√®ge est inf√©rieur √† 0 et l'acc√®s entre les segments de programme et de noyau provoquera une erreur de segmentation. </p><br><p>  Faisons-le √† nouveau (esp√©rons-le dans le dernier) √† propos de la traduction d'adresses <br>  Adresse de ligne [0x08: 0xFFFFFFFF] -&gt; V√©rifier les autorisations de segment 0x08 -&gt; Adresse virtuelle [0xFFFFFFFF] -&gt; Tableau de page + TLB -&gt; Adresse physique [0xAAAAFFFF] </p><br><p>  Un segment est utilis√© uniquement √† l'int√©rieur du processeur, est stock√© dans un registre de segment sp√©cial (CS, SS, DS, ES, FS, GS) et est utilis√© exclusivement pour v√©rifier les droits d'ex√©cution de code et de contr√¥le de transfert.  C'est pourquoi vous ne pouvez pas simplement prendre et appeler la fonction noyau depuis l'espace utilisateur.  Le segment avec le descripteur 0x18 (j'en ai un, le v√¥tre est diff√©rent) a des droits de niveau 3, et le segment avec le descripteur 0x08 a des droits de niveau 0. Selon la convention x86, pour se prot√©ger contre les acc√®s non autoris√©s, un segment avec moins de privil√®ges ne peut pas appeler directement un segment avec grand droits via jmp 0x08: [EAX], mais est oblig√© d'utiliser d'autres m√©canismes, tels que des pi√®ges, des portes, des interruptions. </p><br><p>  Les segments et leurs types (code, donn√©es, √©chelles, portes) doivent √™tre d√©crits dans le tableau des descripteurs globaux GDT, dont l'adresse <strong>virtuelle</strong> et la taille sont charg√©s dans le registre GDTR.  Lorsque vous passez d'un segment √† l'autre (par souci de simplicit√©, je suppose qu'une transition directe est possible), vous devez appeler l'instruction jmp 0x08: [EAX], o√π 0x08 est le <strong>d√©calage du premier descripteur valide en octets depuis le d√©but du tableau</strong> et EAX est le registre contenant l'adresse de transition.  Le d√©calage (s√©lecteur) sera charg√© dans le registre CS et le descripteur correspondant sera charg√© dans le registre fant√¥me du processeur.  Chaque descripteur est une structure √† 8 octets.  Il est bien document√© et sa description se trouve √† la fois sur OSDev et dans la documentation Intel (voir le premier article). </p><br><p>  Je r√©sume.  Lorsque nous initialisons GDT et ex√©cutons la transition jmp 0x08: [EAX], l'√©tat du processeur sera le suivant: </p><br><ul><li>  GDTR contient une adresse GDT <strong>virtuelle</strong> </li><li>  CS contient la valeur 0x08 </li><li>  Un handle vers l'adresse [GDTR + 0x08] a √©t√© copi√© dans le registre fant√¥me CS √† partir de la m√©moire </li><li>  Le registre EIP contient l'adresse du registre EAX </li></ul><br><p>  Le descripteur z√©ro doit toujours √™tre non initialis√© et son acc√®s est interdit.  Je m'attarderai sur le descripteur TSS et sa signification plus en d√©tail lorsque nous discuterons du multithreading.  Ma table GDT ressemble maintenant √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_gdt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_gdt</span></span></span></span>() { GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_offset((&amp;super::tss::TSS) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_limit(core::mem::size_of::&lt;super::tss::Tss&gt;() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gdt_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry = GDT.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> limit = (GDT.len() * core::mem::size_of::&lt;GdtEntry&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>; load_gdt(gdt_ptr, limit); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> GDT: [GdtEntry; <span class="hljs-number"><span class="hljs-number">7</span></span>] = [ <span class="hljs-comment"><span class="hljs-comment">//null descriptor - cannot access GdtEntry::new(0, 0, 0, 0), //kernel code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //kernel data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //TSS - for interrupt handling in multithreading GdtEntry::new(0, 0, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_TSS_AVAIL, 0), GdtEntry::new(0, 0, 0, 0), ];</span></span></code> </pre> <br><p>  Et voici l'initialisation, dont j'ai beaucoup parl√© plus haut.  Le chargement des adresses et des tailles GDT se fait via une structure distincte, qui ne contient que deux champs.  L'adresse de cette structure est transmise √† la commande lgdt.  Dans les registres de segments de donn√©es, chargez le descripteur suivant avec un d√©calage de 0x10. </p><br><pre> <code class="plaintext hljs">global load_gdt section .text gdtr dw 0 ; For limit storage dd 0 ; For base storage load_gdt: mov eax, [esp + 4] mov [gdtr + 2], eax mov ax, [esp + 8] mov [gdtr], ax lgdt [gdtr] jmp 0x08:.reload_CS .reload_CS: mov ax, 0x10 ; 0x10 points at the new data selector mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov ax, 0x28 ltr ax ret</code> </pre> <br><p>  Ensuite, tout sera un peu plus facile, mais non moins int√©ressant. </p><br><h1 id="preryvaniya">  Interruptions </h1><br><p>  En fait, il est temps de nous donner l'opportunit√© d'interagir avec notre c≈ìur (au moins pour voir ce que nous appuyons sur le clavier).  Pour ce faire, vous devez initialiser le contr√¥leur d'interruption. </p><br><p>  Digression lyrique sur le style de code. </p><br><p>  Gr√¢ce aux efforts de la communaut√© et en particulier de Philip Opperman, la convention d'appel x86-interruption a √©t√© ajout√©e √† Rust, ce qui vous permet d'√©crire des gestionnaires d'interruption qui ex√©cutent iret.  Cependant, j'ai d√©lib√©r√©ment d√©cid√© de ne pas suivre cette voie, car j'ai d√©cid√© de s√©parer l'assembleur et Rust dans des fichiers diff√©rents, et donc des fonctions.  Oui, j'utilise d√©raisonnablement la m√©moire de la pile, j'en suis conscient, mais c'est encore du go√ªt.  Mes gestionnaires d'interruption sont √©crits en assembleur et font exactement une chose: ils appellent presque les m√™mes gestionnaires d'interruption √©crits en Rust.  Veuillez accepter ce fait et soyez indulgents. </p><br><p>  En g√©n√©ral, le processus d'initialisation des interruptions est similaire √† l'initialisation d'un GDT, mais est plus facile √† comprendre.  D'un autre c√¥t√©, vous avez besoin de beaucoup de code uniforme.  Les d√©veloppeurs de Redox OS prennent une belle d√©cision, en utilisant tous les plaisirs du langage, mais je suis all√© ¬´sur le front¬ª et j'ai d√©cid√© d'autoriser la duplication de code. </p><br><p>  Selon la convention x86, nous avons des interruptions, mais il existe des situations exceptionnelles.  Dans ce contexte, les param√®tres pour nous sont pratiquement les m√™mes.  La seule diff√©rence est que lorsqu'une exception est lev√©e, la pile peut contenir des informations suppl√©mentaires.  Par exemple, je l'utilise pour g√©rer le manque de page lorsque je travaille avec un tas (mais tout a son temps).  Les interruptions et les exceptions sont trait√©es √† partir de la m√™me table, que vous et moi devons remplir.  Il est √©galement n√©cessaire de programmer le PIC (Programmable Interrupt Controller).  Il y a aussi l'APIC, mais je ne l'ai pas encore compris. </p><br><p>  En travaillant avec PIC, je ne ferai pas beaucoup de commentaires, car il existe de nombreux exemples sur le r√©seau pour travailler avec lui.  Je vais commencer par les gestionnaires de l'assembleur.  Ils sont tous compl√®tement identiques, donc je vais supprimer le code du spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">IRQ</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global irq0 global irq1 ...... global irq14 global irq15 extern kirq0 extern kirq1 ...... extern kirq14 extern kirq15 section .text irq0: pusha call kirq0 popa iret irq1: pusha call kirq1 popa iret ...... irq14: pusha call kirq14 popa iret irq15: pusha call kirq15 popa iret</code> </pre> </div></div><br><p>  Comme vous pouvez le voir, tous les appels aux fonctions Rust commencent par le pr√©fixe ¬´k¬ª - pour la distinction et la commodit√©.  La gestion des exceptions est exactement la m√™me.  Pour les fonctions assembleur, le pr√©fixe ¬´e¬ª est s√©lectionn√©, pour Rust, ¬´k¬ª.  Le gestionnaire de d√©fauts de page est diff√©rent, mais √† ce sujet - dans les notes sur la gestion de la m√©moire. </p><br><div class="spoiler">  <b class="spoiler_title">Exceptions</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global e0_zero_divide global e1_debug ...... global eE_page_fault ...... global e14_virtualization global e1E_security extern k0_zero_divide extern k1_debug ...... extern kE_page_fault ...... extern k14_virtualization extern k1E_security section .text e0_zero_divide: pushad call k0_zero_divide popad iret e1_debug: pushad call k1_debug popad iret ...... eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret ...... e14_virtualization: pushad call k14_virtualization popad iret e1E_security: pushad call k1E_security popad iret</code> </pre> </div></div><br><p>  Nous d√©clarons les gestionnaires d'assembleurs: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_idt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e0_zero_divide</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1_debug</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e14_virtualization</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1E_security</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq0</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq1</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq14</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq15</span></span></span></span>(); }</code> </pre> <br><p>  Nous d√©finissons les gestionnaires Rust que nous appelons ci-dessus.  Veuillez noter que pour interrompre le clavier, j'affiche simplement le code re√ßu, que j'obtiens du port 0x60 - c'est ainsi que le clavier fonctionne dans le mode le plus simple.  √Ä l'avenir, cela se transformera en un pilote √† part enti√®re, j'esp√®re.  Apr√®s chaque interruption, vous devez envoyer au contr√¥leur le signal de fin de traitement 0x20, c'est important!  Sinon, vous n'obtiendrez pas plus d'interruptions. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kirq0</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// println!("IRQ 0"); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq1() { let ch: char = inb(0x60) as char; crate::arch::vga::VGA_WRITER.force_unlock(); println!("IRQ 1 {}", ch); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq2() { println!("IRQ 2"); outb(0x20, 0x20); } ...</span></span></code> </pre> <br><p>  Initialisation de IDT et PIC.  √Ä propos de PIC et de son remappage, j'ai trouv√© un grand nombre de didacticiels de diff√©rents degr√©s de d√©tail, commen√ßant par OSDev et se terminant par des sites amateurs.  √âtant donn√© que la proc√©dure de programmation fonctionne avec une s√©quence constante d'op√©rations et de commandes constantes, je donnerai ce code sans autre explication.     ,        0x20-0x2F  ,       0x20  0x28,     16    IDT. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pic</span></span></span></span>(pic1: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, pic2: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start initialization outb(PIC1, 0x11); outb(PIC2, 0x11); // Set offsets outb(PIC1 + 1, pic1); /* remap */ outb(PIC2 + 1, pic2); /* pics */ // Set up cascade outb(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */ outb(PIC2 + 1, 2); // Set up interrupt mode (1 is 8086/88 mode, 2 is auto EOI) outb(PIC1 + 1, 1); outb(PIC2 + 1, 1); // Unmask interrupts outb(PIC1 + 1, 0); outb(PIC2 + 1, 0); // Ack waiting outb(PIC1, 0x20); outb(PIC2, 0x20); } pub unsafe fn init_idt() { IDT[0x0].set_func(e0_zero_divide); IDT[0x1].set_func(e1_debug); ...... IDT[0x14].set_func(e14_virtualization); IDT[0x1E].set_func(e1E_security); IDT[0x20].set_func(irq0); IDT[0x21].set_func(irq1); ...... IDT[0x2E].set_func(irq14); IDT[0x2F].set_func(irq15); setup_pic(0x20, 0x28); let idt_ptr: *const IdtEntry = IDT.as_ptr(); let limit = (IDT.len() * core::mem::size_of::&lt;IdtEntry&gt;() - 1) as u16; load_idt(idt_ptr, limit); }</span></span></code> </pre> <br><p>      IDTR   GDTR ‚Äî       .  STI        ‚Äî         ‚Äî  ,    ,  ASCII-   -. </p><br><pre> <code class="plaintext hljs">global load_idt section .text idtr dw 0 ; For limit storage dd 0 ; For base storage load_idt: mov eax, [esp + 4] mov [idtr + 2], eax mov ax, [esp + 8] mov [idtr], ax lidt [idtr] sti ret</code> </pre> <br><h1 id="posleslovie">  Postface </h1><br><p>  ,     ,            .      setup_pd,           . ,   ,     ,  . </p><br><p>   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitLab</a> . </p><br><p>  Merci de votre attention! </p><br><p> UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445584/">https://habr.com/ru/post/fr445584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445568/index.html">Surveillance et gestion √† distance des p√©riph√©riques Linux / OpenWrt / Lede via le port 80 ...</a></li>
<li><a href="../fr445570/index.html">Le condens√© des √©v√©nements pour les professionnels des RH dans le domaine des TI pour avril 2019</a></li>
<li><a href="../fr445572/index.html">Le gouvernement am√©ricain pr√©voit d'envoyer des gens sur la lune dans 5 ans</a></li>
<li><a href="../fr445580/index.html">Une liste exhaustive des diff√©rences entre VB.NET et C #. 2e partie</a></li>
<li><a href="../fr445582/index.html">Syst√®mes CRM: protection ou menace?</a></li>
<li><a href="../fr445586/index.html">Android Academy √† Moscou - parler de comment c'√©tait et partager des supports de cours</a></li>
<li><a href="../fr445588/index.html">Le scan 3D d'une personne en 30 secondes sera montr√© √† l'exposition</a></li>
<li><a href="../fr445590/index.html">Grammaire anglaise. Qui vs Qui - comment comprendre quel mot utiliser</a></li>
<li><a href="../fr445592/index.html">Initialisation paresseuse dans Spring Boot 2.2</a></li>
<li><a href="../fr445594/index.html">Outils pour cr√©er un site r√©actif sans acc√®s au site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>