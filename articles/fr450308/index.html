<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≠ üì¥ üëÄ Tra√ßage des rayons GPU dans Unity - Partie 3 ‚óºÔ∏è üëù üëû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Les premi√®re et deuxi√®me parties.] 


 Aujourd'hui, nous allons faire un grand saut. Nous nous √©loignerons des structures exclusivement sph√©riques e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tra√ßage des rayons GPU dans Unity - Partie 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450308/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les premi√®re</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> parties.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9f/a8a/4f2/f9fa8a4f2a79b8c394636de6a128d0d5.png"></div><br>  Aujourd'hui, nous allons faire un grand saut.  Nous nous √©loignerons des structures exclusivement sph√©riques et du plan infini que nous avons trac√© plus t√¥t, et ajouterons des triangles - l'essence m√™me de l'infographie moderne, un √©l√©ment qui consiste en tous les mondes virtuels.  Si vous souhaitez continuer avec ce que nous avons termin√© la derni√®re fois, utilisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code de la partie 2</a> .  Le code final de ce que nous ferons aujourd'hui est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Commen√ßons! <br><br><h2>  Triangles </h2><br>  <em>Un triangle</em> n'est qu'une liste de trois <em>sommets</em> connect√©s, chacun d'entre eux stockant sa propre position, et parfois normal.  L'ordre de travers√©e des sommets de votre point de vue d√©termine ce que nous regardons - le c√¥t√© avant ou arri√®re du triangle.  Traditionnellement, le ¬´front¬ª est consid√©r√© comme l'ordre de contournement dans le sens antihoraire. <br><br>  Tout d'abord, nous devons √™tre en mesure de d√©terminer si le rayon intersecte un triangle, et si oui, √† quel point.  Un algorithme tr√®s populaire (mais certainement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas le seul</a> ) pour d√©terminer l'intersection d'un rayon avec un triangle a √©t√© propos√© en 1997 par les messieurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thomas Akenin-Meller</a> et Ben Trembor.  Vous pouvez en savoir plus √† ce sujet dans leur article ¬´Intersection Ray-Triangle de stockage rapide et minimal¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><a name="habracut"></a><br>  Le code de l'article peut √™tre facilement port√© vers le code de shader HLSL: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> EPSILON = <span class="hljs-number"><span class="hljs-number">1e-8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectTriangle_MT97</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u, inout </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find vectors for two edges sharing vert0 float3 edge1 = vert1 - vert0; float3 edge2 = vert2 - vert0; // begin calculating determinant - also used to calculate U parameter float3 pvec = cross(ray.direction, edge2); // if determinant is near zero, ray lies in plane of triangle float det = dot(edge1, pvec); // use backface culling if (det &lt; EPSILON) return false; float inv_det = 1.0f / det; // calculate distance from vert0 to ray origin float3 tvec = ray.origin - vert0; // calculate U parameter and test bounds u = dot(tvec, pvec) * inv_det; if (u &lt; 0.0 || u &gt; 1.0f) return false; // prepare to test V parameter float3 qvec = cross(tvec, edge1); // calculate V parameter and test bounds v = dot(ray.direction, qvec) * inv_det; if (v &lt; 0.0 || u + v &gt; 1.0f) return false; // calculate t, ray intersects triangle t = dot(edge2, qvec) * inv_det; return true; }</span></span></code> </pre> <br>  Pour utiliser cette fonction, nous avons besoin d'un rayon et de trois sommets d'un triangle.  La valeur de retour nous indique si le triangle s'est intersect√©.  En cas d'intersection, trois valeurs suppl√©mentaires sont calcul√©es: <code>t</code> d√©crit la distance le long du faisceau jusqu'au point d'intersection, et <code>u</code> / <code>v</code> sont deux des trois coordonn√©es barycentriques qui d√©terminent l'emplacement du point d'intersection sur le triangle (la derni√®re coordonn√©e peut √™tre calcul√©e comme <code>w = 1 - u - v</code> ).  Si vous n'√™tes pas encore familier avec les coordonn√©es barycentriques, alors lisez leur excellente explication sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scratchapixel</a> . <br><br>  Sans trop tarder, tra√ßons un triangle avec les sommets indiqu√©s dans le code!  Recherchez la fonction <code>Trace</code> dans le shader et ajoutez-y le fragment de code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace single triangle float3 v0 = float3(-150, 0, -150); float3 v1 = float3(150, 0, -150); float3 v2 = float3(0, 150 * sqrt(2), -150); float t, u, v; if (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = 0.00f; bestHit.specular = 0.65f * float3(1, 0.4f, 0.2f); bestHit.smoothness = 0.9f; bestHit.emission = 0.0f; } }</span></span></code> </pre> <br>  Comme je l'ai dit, <code>t</code> stocke la distance le long du faisceau, et nous pouvons directement utiliser cette valeur pour calculer le point d'intersection.  La normale, qui est importante pour calculer la r√©flexion correcte, peut √™tre calcul√©e en utilisant le produit vectoriel de deux bords quelconques du triangle.  Lancez le mode de jeu et admirez votre premier triangle trac√©: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/65a/a84/b2965aa84ae9d882e6c26f7f44da2af7.png"></div><br>  <strong>Exercice:</strong> Essayez de calculer la position en utilisant les coordonn√©es barycentriques plut√¥t que la distance.  Si vous faites tout correctement, le triangle brillant ressemblera exactement √† ce qu'il √©tait auparavant. <br><br><h2>  Mailles triangulaires </h2><br>  Nous avons surmont√© le premier obstacle, mais tracer des mailles enti√®res √† partir de triangles est une histoire compl√®tement diff√©rente.  Nous devons d'abord apprendre quelques informations de base sur les maillages.  Si vous les connaissez, vous pouvez sauter le paragraphe suivant en toute s√©curit√©. <br><br>  En infographie, le maillage est d√©fini par plusieurs tampons, les plus importants √©tant les tampons de <em>sommet</em> et d' <em>index</em> .  <em>Le tampon de sommet</em> est une liste de vecteurs 3D d√©crivant la position de chaque sommet dans <em>l'espace objet</em> (cela signifie que ces valeurs n'ont pas besoin d'√™tre modifi√©es lors du d√©placement, de la rotation ou de la mise √† l'√©chelle d'un objet - elles sont converties de <em>l'espace objet en espace</em> <em>mondial</em> √† la vol√©e en utilisant la multiplication matricielle) .  <em>Un tampon d'index</em> est une liste de valeurs enti√®res qui sont des <em>index</em> qui pointent vers le tampon de vertex.  Tous les trois index forment un triangle.  Par exemple, si le tampon d'index a la forme [0, 1, 2, 0, 2, 3], alors il a deux triangles: le premier triangle se compose des premier, deuxi√®me et troisi√®me sommets dans le tampon de sommet, et le deuxi√®me triangle se compose du premier, troisi√®me et quatri√®mes pics.  Par cons√©quent, le tampon d'index d√©termine √©galement l'ordre de parcours susmentionn√©.  En plus des tampons et index des sommets, il peut y avoir des tampons suppl√©mentaires qui ajoutent d'autres informations √† chaque sommet.  Les tampons suppl√©mentaires les plus courants stockent les <em>normales</em> , <em>les coordonn√©es de texture</em> (appel√©es <em>texcoords</em> ou simplement <em>UV</em> ), ainsi que les <em>couleurs des sommets</em> . <br><br><h2>  Utilisation de GameObjects </h2><br>  Tout d'abord, nous devons savoir quels GameObjects devraient faire partie du processus de lancer de rayons.  Une solution na√Øve serait d'utiliser simplement <code>FindObjectOfType&lt;MeshRenderer&gt;()</code> , mais de faire quelque chose de plus flexible et plus rapide.  Ajoutons un nouveau composant <code>RayTracingObject</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingObject</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.RegisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingMaster.UnregisterObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br>  Ce composant est ajout√© √† chaque objet que nous voulons utiliser pour le <code>RayTracingMaster</code> de rayons et est engag√© dans leur enregistrement √† l'aide de <code>RayTracingMaster</code> .  Ajoutez les fonctions suivantes √† l'assistant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;RayTracingObject&gt; _rayTracingObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;RayTracingObject&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Add(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnregisterObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RayTracingObject obj</span></span></span><span class="hljs-function">)</span></span> { _rayTracingObjects.Remove(obj); _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Tout se passe bien - nous savons maintenant quels objets doivent √™tre trac√©s.  Mais la partie d√©licate continue: nous allons collecter toutes les donn√©es des maillages Unity (matrice, tampons de sommets et index - vous vous en souvenez?), Les √©crire dans nos propres structures de donn√©es et les charger dans le GPU afin que le shader puisse les utiliser.  Commen√ßons par d√©finir les structures de donn√©es et les tampons c√¥t√© C #, dans l'assistant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MeshObject { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Matrix4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;MeshObject&gt; _meshObjects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MeshObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; _vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _meshObjectBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _vertexBuffer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _indexBuffer;</code> </pre> <br>  ... et maintenant faisons de m√™me dans le shader.  √ätes-vous habitu√©? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MeshObject</span></span></span><span class="hljs-class"> {</span></span> float4x4 localToWorldMatrix; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_offset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indices_count; }; StructuredBuffer&lt;MeshObject&gt; _MeshObjects; StructuredBuffer&lt;float3&gt; _Vertices; StructuredBuffer&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _Indices;</code> </pre> <br>  Les structures de donn√©es sont pr√™tes et nous pouvons les remplir avec de vraies donn√©es.  Nous collectons tous les sommets de toutes les mailles dans une grande <code>List&lt;Vector3&gt;</code> , et tous les index dans une grande <code>List&lt;int&gt;</code> .  Il n'y a pas de probl√®me avec les sommets, mais les indices doivent √™tre modifi√©s afin qu'ils continuent de pointer vers le sommet correct dans notre grand tampon.  Imaginez que nous avons d√©j√† ajout√© des objets √† partir de 1000 sommets, et maintenant nous ajoutons un simple cube maill√©.  Le premier triangle peut √™tre compos√© d'indices [0, 1, 2], mais comme nous avions d√©j√† 1000 sommets dans le tampon, nous devons d√©placer les indices avant d'ajouter des sommets au cube.  Autrement dit, ils se transformeront en [1000, 1001, 1002].  Voici √† quoi cela ressemble dans le code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RebuildMeshObjectBuffers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_meshObjectsNeedRebuilding) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } _meshObjectsNeedRebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Clear all lists _meshObjects.Clear(); _vertices.Clear(); _indices.Clear(); // Loop over all objects and gather their data foreach (RayTracingObject obj in _rayTracingObjects) { Mesh mesh = obj.GetComponent&lt;MeshFilter&gt;().sharedMesh; // Add vertex data int firstVertex = _vertices.Count; _vertices.AddRange(mesh.vertices); // Add index data - if the vertex buffer wasn't empty before, the // indices need to be offset int firstIndex = _indices.Count; var indices = mesh.GetIndices(0); _indices.AddRange(indices.Select(index =&gt; index + firstVertex)); // Add the object itself _meshObjects.Add(new MeshObject() { localToWorldMatrix = obj.transform.localToWorldMatrix, indices_offset = firstIndex, indices_count = indices.Length }); } CreateComputeBuffer(ref _meshObjectBuffer, _meshObjects, 72); CreateComputeBuffer(ref _vertexBuffer, _vertices, 12); CreateComputeBuffer(ref _indexBuffer, _indices, 4); }</span></span></code> </pre> <br>  Nous appelons <code>RebuildMeshObjectBuffers</code> dans la fonction <code>OnRenderImage</code> , et n'oubliez pas de lib√©rer de nouveaux tampons dans <code>OnDisable</code> .  Voici deux fonctions d'assistance que j'ai utilis√©es dans le code ci-dessus pour simplifier un peu la gestion du tampon: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateComputeBuffer&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ComputeBuffer buffer, List&lt;T&gt; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Do we already have a compute buffer? if (buffer != null) { // If no data or buffer doesn't match the given criteria, release it if (data.Count == 0 || buffer.count != data.Count || buffer.stride != stride) { buffer.Release(); buffer = null; } } if (data.Count != 0) { // If the buffer has been released or wasn't there to // begin with, create it if (buffer == null) { buffer = new ComputeBuffer(data.Count, stride); } // Set data on the buffer buffer.SetData(data); } } private void SetComputeBuffer(string name, ComputeBuffer buffer) { if (buffer != null) { RayTracingShader.SetBuffer(0, name, buffer); } }</span></span></code> </pre> <br>  G√©nial, nous avons cr√©√© des tampons et ils sont remplis avec les donn√©es n√©cessaires!  Maintenant, nous devons simplement signaler cela au shader.  Ajoutez le code suivant √† <code>SetShaderParameters</code> (et gr√¢ce aux nouvelles fonctions d'assistance, nous pouvons r√©duire le code du tampon de sph√®re): <br><br><pre> <code class="cs hljs">SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_MeshObjects"</span></span>, _meshObjectBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Vertices"</span></span>, _vertexBuffer); SetComputeBuffer(<span class="hljs-string"><span class="hljs-string">"_Indices"</span></span>, _indexBuffer);</code> </pre> <br>  Donc, le travail est ennuyeux, mais voyons ce que nous venons de faire: nous avons collect√© toutes les donn√©es internes des mailles (matrice, sommets et index), les avons plac√©es dans une structure pratique et simple, puis les avons envoy√©es au GPU, qui attend maintenant avec impatience le moment o√π ils peuvent √™tre utilis√©s. <br><br><h2>  Tra√ßage de maillage </h2><br>  Ne le faisons pas attendre.  Dans le shader, nous avons d√©j√† le code de trace d'un triangle individuel, et le maillage est, en fait, juste un grand nombre de triangles.  Le seul nouvel aspect ici est que nous utilisons la matrice pour transformer les sommets de l'espace objet en espace monde en utilisant la fonction <code>mul</code> int√©gr√©e (abr√©viation de multiplier).  La matrice contient la translation, la rotation et l'√©chelle de l'objet.  Il a une taille de 4 √ó 4, donc pour la multiplication, nous avons besoin d'un vecteur 4d.  Les trois premiers composants (x, y, z) sont extraits du tampon de vertex.  Nous mettons la quatri√®me composante (w) √† 1 car nous avons affaire √† un point.  Si c'√©tait la direction, alors nous √©cririons 0 pour ignorer toutes les traductions et l'√©chelle dans la matrice.  Est-ce d√©routant pour vous?  Lisez ensuite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce tutoriel</a> au moins huit fois.  Voici le code du shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectMeshObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray, inout RayHit bestHit, MeshObject meshObject)</span></span></span><span class="hljs-function"> </span></span>{ uint offset = meshObject.indices_offset; uint count = offset + meshObject.indices_count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = offset; i &lt; count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { float3 v0 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v1 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; float3 v2 = (mul(meshObject.localToWorldMatrix, float4(_Vertices[_Indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]], <span class="hljs-number"><span class="hljs-number">1</span></span>))).xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t, u, v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(cross(v1 - v0, v2 - v0)); bestHit.albedo = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; bestHit.specular = <span class="hljs-number"><span class="hljs-number">0.65f</span></span>; bestHit.smoothness = <span class="hljs-number"><span class="hljs-number">0.99f</span></span>; bestHit.emission = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } } } }</code> </pre> <br>  Nous sommes √† un pas de tout voir en action.  Restructurons un peu la fonction <code>Trace</code> et ajoutons une trace d'objets maill√©s: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ray ray)</span></span></span><span class="hljs-function"> </span></span>{ RayHit bestHit = CreateRayHit(); uint count, stride, i; <span class="hljs-comment"><span class="hljs-comment">// Trace ground plane IntersectGroundPlane(ray, bestHit); // Trace spheres _Spheres.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectSphere(ray, bestHit, _Spheres[i]); } // Trace mesh objects _MeshObjects.GetDimensions(count, stride); for (i = 0; i &lt; count; i++) { IntersectMeshObject(ray, bestHit, _MeshObjects[i]); } return bestHit; }</span></span></code> </pre> <br><h2>  R√©sultats </h2><br>  C'est tout!  Ajoutons quelques maillages simples (les primitives Unity vont bien), donnons-leur le composant <code>RayTracingObject</code> et observons la magie.  <strong>N'utilisez pas</strong> encore de maillages d√©taill√©s (plus de quelques centaines de triangles)!  Notre shader manque d'optimisation, et si vous en faites trop, cela peut prendre des secondes, voire des minutes, pour tracer au moins un √©chantillon par pixel.  Par cons√©quent, le syst√®me arr√™tera le pilote GPU, le moteur Unity peut se bloquer et l'ordinateur devra red√©marrer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/1d4/40e/c801d440e5a0a21f660b5a7e82e1b368.png"></div><br>  Notez que nos mailles n'ont pas d'ombrage lisse mais plat.  Comme nous n'avons pas encore charg√© les normales des sommets dans le tampon, pour obtenir la normale des sommets de chaque triangle, nous devons effectuer un produit vectoriel.  De plus, nous ne pouvons pas interpoler sur l'aire du triangle.  Nous traiterons ce probl√®me dans la prochaine partie du tutoriel. <br><br>  Pour des raisons d'int√©r√™t, j'ai t√©l√©charg√© le Stanford Bunny √† partir des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">archives de Morgan McGwire</a> et en utilisant le modificateur de d√©cimation du package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blender</a> , j'ai r√©duit le nombre de sommets √† 431. Vous pouvez exp√©rimenter avec des param√®tres d'√©clairage et du mat√©riel cod√© en dur dans la fonction de shader <code>IntersectMeshObject</code> .  Voici un lapin di√©lectrique avec de belles ombres douces et un peu d'√©clairage global diffus au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grafitti Shelter</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0da/860/bb4/0da860bb41d9465f2dc21d649a509a66.png"></div><br>  ... et voici un lapin en m√©tal sous la forte lumi√®re directionnelle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cape Hill</a> , jetant des reflets disco sur le sol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/bb1/a64/a76bb1a642d620929ecd250f92e1ef1f.jpg"></div><br>  ... et voici deux petits lapins cach√©s sous la grosse pierre Suzanne sous le ciel bleu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kiara 9 Dusk</a> (j'ai prescrit un mat√©riau alternatif pour le deuxi√®me objet, v√©rifiant si le d√©calage d'index est √©gal √† z√©ro): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ef/196/a4f/7ef196a4f818b366b4838f2b1e4148f5.png"></div><br><h2>  Et ensuite? </h2><br>  C'est g√©nial de voir un vrai maillage dans votre propre traceur pour la premi√®re fois, non?  Aujourd'hui, nous avons trait√© certaines donn√©es, d√©couvert l'intersection √† l'aide de l'algorithme Meller-Trambor et collect√© tout pour que nous puissions imm√©diatement utiliser le moteur GameObjects du moteur Unity.  De plus, nous avons vu l'un des avantages du lancer de rayons: d√®s que vous ajoutez une nouvelle intersection au code, tous les beaux effets (ombres douces, √©clairage global r√©fl√©chi et diffus√©, etc.) commencent imm√©diatement √† fonctionner. <br><br>  Rendre un lapin brillant a pris beaucoup de temps, et j'ai encore d√ª utiliser un peu de filtrage pour me d√©barrasser du bruit le plus √©vident.  Pour r√©soudre ce probl√®me, la sc√®ne est g√©n√©ralement √©crite dans une structure spatiale, par exemple, dans une grille, un arbre dimensionnel K ou une hi√©rarchie de volumes englobants, ce qui augmente consid√©rablement la vitesse de rendu de grandes sc√®nes. <br><br>  Mais nous devons bouger dans l'ordre: nous √©liminerons davantage le probl√®me des normales pour que nos mailles (m√™me celles √† faible poly) soient plus lisses qu'aujourd'hui.  Il serait √©galement int√©ressant de mettre √† jour automatiquement les matrices lors du d√©placement d'objets et de se r√©f√©rer directement aux mat√©riaux Unity, et pas seulement de les √©crire dans le code.  C'est ce que nous ferons dans la prochaine partie de la s√©rie de didacticiels.  Merci d'avoir lu et √† la partie 4! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr450308/">https://habr.com/ru/post/fr450308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr450294/index.html">Les poisons les plus effrayants</a></li>
<li><a href="../fr450298/index.html">Futur quantique (suite)</a></li>
<li><a href="../fr450300/index.html">Arr√™tez de discuter de la programmation fonctionnelle et de la POO</a></li>
<li><a href="../fr450302/index.html">Amateur Radio Technology: fabrication d'un prototype de carte de circuit imprim√© dans une usine chinoise</a></li>
<li><a href="../fr450304/index.html">Carapuzik chevauchant une fourmi: 100 millions d'ann√©es de myrm√©cophilie</a></li>
<li><a href="../fr450310/index.html">Fonctionnement de Philips VideoWRITER. Premi√®res images de fer, puis un peu d'ennui</a></li>
<li><a href="../fr450312/index.html">Docker Compose Starter Guide</a></li>
<li><a href="../fr450314/index.html">TensorFlow pour les d√©butants. Partie 1: informations g√©n√©rales, installation de la biblioth√®que</a></li>
<li><a href="../fr450316/index.html">TDD: une m√©thodologie de d√©veloppement qui a chang√© ma vie</a></li>
<li><a href="../fr450318/index.html">Mod√®les de conception dans le d√©veloppement JavaScript moderne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>