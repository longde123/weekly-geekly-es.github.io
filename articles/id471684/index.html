<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âšœï¸ ğŸ‘©ğŸ» ğŸ¬ Mengapa Anda perlu membuat modul untuk nginx ğŸ¤¡ ğŸ³ ğŸ‘‚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nginx adalah server web yang memecahkan banyak tugas bisnis, dikonfigurasi secara fleksibel, diskalakan dan bekerja pada hampir semua OS dan platform....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa Anda perlu membuat modul untuk nginx</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/471684/">  Nginx adalah server web yang memecahkan banyak tugas bisnis, dikonfigurasi secara fleksibel, diskalakan dan bekerja pada hampir semua OS dan platform.  Daftar fitur, kemampuan, dan masalah yang harus dipecahkan di luar kotak dapat dijelaskan dalam brosur kecil.  Namun terkadang, sejumlah tugas bisnis hanya dapat diselesaikan dengan mengembangkan modul Anda sendiri untuk nginx.  Ini adalah modul yang berorientasi bisnis dan mengandung beberapa logika bisnis, dan bukan hanya solusi sistem umum. <br><br><img src="https://habrastorage.org/webt/_g/qx/cl/_gqxcl-ni0gc2f2rsr7thf4tici.jpeg"><br><br>  Secara umum, semua yang ada di nginx adalah modul yang pernah ditulis oleh seseorang.  Oleh karena itu, menulis modul di bawah nginx tidak hanya mungkin, tetapi juga perlu.  Ketika perlu untuk melakukannya dan mengapa, <strong>Vasily Soshnikov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dedokOne</a> ) akan memberi tahu contoh beberapa kasus. <br><br>  Mari kita bicara tentang alasan yang mendorong penulisan modul dalam C, tentang arsitektur dan inti nginx, anatomi modul HTTP, tentang modul C, NJS, Lua, dan nginx.conf.  Ini penting untuk diketahui tidak hanya bagi mereka yang berkembang di bawah nginx, tetapi juga bagi mereka yang menggunakan nginx-configs, Lua atau bahasa lain di dalam nginx. <br><br>  <em>Catatan: artikel ini didasarkan pada laporan oleh Vasily Soshnikov.</em>  <em>Laporan ini terus diperbarui dan diperbarui.</em>  <em>Informasi dalam materi ini cukup teknis dan untuk mendapatkan hasil maksimal, pembaca perlu memiliki pengalaman bekerja dengan kode nginx pada tingkat rata-rata ke atas.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/82CyWPpjNNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Secara singkat tentang nginx </h2><br>  <strong>Yang Anda gunakan dengan nginx adalah modul</strong> .  Setiap arahan dalam konfigurasi nginx adalah modul terpisah, yang ditulis dengan cermat oleh rekan-rekan dari komunitas nginx. <br><br>  <strong>Arahan di nginx.conf juga merupakan modul</strong> yang memecahkan masalah tertentu.  Oleh karena itu, dalam modul nginx adalah segalanya.  add_header, proxy_pass, arahan apa saja - ini adalah modul atau kombinasi modul yang bekerja sesuai dengan aturan tertentu. <br><br>  <strong>Nginx adalah kerangka kerja</strong> yang memiliki: Network &amp; File I / O, Shared Memory, Configuration &amp; Scripting.  Ini adalah lapisan besar pustaka tingkat rendah, tempat Anda dapat melakukan apa saja untuk bekerja dengan drive jaringan. <br><br>  <strong>Nginx cepat dan stabil, tetapi rumit</strong> .  Anda harus menulis kode tersebut agar tidak kehilangan kualitas nginx ini.  Nginx tidak stabil pada produksi adalah klien yang tidak puas, dan semua yang berikut dari ini. <br><br><h2>  Mengapa membuat modul Anda sendiri </h2><br>  <strong>Konversi protokol HTTP ke protokol lain.</strong>  Inilah alasan utama yang sering memotivasi pembuatan modul tertentu. <br><br>  Sebagai contoh, modul memcached_pass mengkonversi HTTP ke protokol lain, dan Anda dapat bekerja dengan sistem eksternal lainnya.  Modul proxy_pass juga memungkinkan Anda untuk mengkonversi, meskipun dari HTTP (s) ke HTTP (s).  Contoh bagus lainnya adalah fastcgi_pass. <br><br>  Ini semua adalah arahan dari formulir: "pergi ke backend ini dan itu, di mana bukan HTTP (tetapi dalam kasus HTTP proxy_pass)." <br><br>  <strong>Penyisipan konten dinamis: Bypass AdBlock, penyisipan iklan.</strong>  Sebagai contoh, kami memiliki backend dan perlu untuk mengubah konten yang berasal darinya.  Misalnya, AdBlock, yang menganalisis kode penyisipan iklan, dan kami harus menanganinya - untuk menyetelnya dengan satu atau lain cara. <br><br>  Hal lain yang sering harus Anda lakukan untuk menanamkan konten adalah masalah dengan caching HLS.  Ketika parameter di-cache di dalam HLS, maka dua pengguna bisa mendapatkan sesi yang sama atau parameter yang sama.  Dari sana, Anda memotong atau menambahkan beberapa parameter saat Anda perlu melacak sesuatu. <br><br>  <strong>Pengumpulan data Clickstream dari internet / meter seluler.</strong>  Kasus yang populer dalam praktik saya.  Paling sering ini dilakukan pada nginx, tetapi tidak pada access.log, tetapi sedikit lebih cerdas. <br><br>  <strong>Konversi semua jenis konten.</strong>  Misalnya, modul rtmp untuk memungkinkan Anda bekerja tidak hanya dengan rtmp, tetapi juga dengan HLS.  Modul ini dapat melakukan banyak hal dengan konten video. <br><br>  <strong>Titik otorisasi umum: SEP atau Api Gateway.</strong>  Ini adalah kasus ketika nginx berfungsi sebagai bagian dari infrastruktur: mengesahkan, mengumpulkan metrik, mengirim data ke pemantauan dan ClickStream.  Nginx bekerja di sini sebagai hub infrastruktur - titik masuk tunggal untuk backend. <br><br>  <strong>Pengayaan permintaan untuk penelusuran selanjutnya.</strong>  Sistem modern sangat kompleks, dengan beberapa jenis backend yang membuat tim berbeda.  Sebagai aturan, mereka sulit untuk debut, kadang-kadang bahkan sulit untuk memahami dari mana permintaan itu berasal dan ke mana ia pergi.  Untuk menyederhanakan debugging, beberapa perusahaan besar menggunakan teknik yang rumit - mereka menambahkan data tertentu ke permintaan.  Pengguna tidak akan melihatnya, tetapi dari data ini mudah untuk melacak jalur permintaan di dalam sistem.  Ini disebut <strong>jejak</strong> . <br><br>  <strong>S3-proxy.</strong>  Tahun ini, saya sering melihat orang-orang bekerja dengan objek mereka melalui s3.  Tetapi tidak perlu melakukan ini pada modul-C, infrastrukturnya cukup memadai di nginx juga.  Untuk mengatasi beberapa masalah ini, Anda dapat menggunakan Lua, sesuatu sedang dipecahkan di NJS.  Tetapi kadang-kadang perlu untuk menulis modul dalam C. <br><br><h2>  Kapan waktu untuk membuat modul </h2><br>  Ada dua kriteria untuk dipahami bahwa waktunya telah tiba. <br><br>  <strong>Generalisasi fungsionalitas.</strong>  Ketika Anda memahami bahwa orang lain membutuhkan produk Anda, maka Anda berkontribusi ke Open Source, membuat fungsionalitas umum, mempostingnya dan membiarkannya digunakan. <br><br>  <strong>Memecahkan masalah bisnis.</strong>  Ketika sebuah bisnis menetapkan persyaratan seperti itu yang dapat dipenuhi hanya dengan menulis modul sendiri untuk nginx.  Misalnya, penyisipan dinamis / perubahan konten, koleksi ClickStream dapat dilakukan pada Lua, tetapi kemungkinan besar itu tidak akan berfungsi secara normal. <br><br><h2>  Arsitektur nginx </h2><br>  Saya telah menulis kode nginx untuk waktu yang lama.  Sembilan modul saya berputar dalam produksi, salah satunya di Open Source, dan dalam produksi untuk banyak orang.  Karena itu, saya memiliki pengalaman dan pengertian. <br><blockquote>  Nginx adalah boneka bersarang di mana semuanya dibangun di sekitar kernel. </blockquote>  Jadi saya mengerti nginx. <br><blockquote>  Inti adalah pembungkus di atas epoll. </blockquote>  Epoll adalah metode yang memungkinkan Anda untuk bekerja secara tidak sinkron dengan file deskriptor apa pun, bukan hanya soket, karena deskriptor bukan hanya soket. <br><br>  Di atas intinya adalah upstreams, HTTP, dan scripting.  Dengan scripting, maksud saya nginx.conf, bukan NJS.  Di atas upstreams, HTTP, dan scripting, modul HTTP sudah dibangun, yang akan kita bicarakan. <br><br><img src="https://habrastorage.org/webt/d7/b6/ff/d7b6ffhplgm4ddkbvncbfh4umym.jpeg"><br><br>  Contoh klasik upstreams dan HTTP adalah server upstream - arahan di dalam konfigurasi.  Contoh modul untuk HTTP adalah add_header.  Contoh skrip adalah file konfigurasi itu sendiri.  File tersebut berisi modul-modul yang terdiri dari nginx, ditafsirkan dengan cara apa pun dan memungkinkan Anda untuk melakukan sesuatu sebagai administrator atau sebagai pengguna Anda. <br><br>  Kami tidak akan mempertimbangkan inti dan tinggal sebentar di upstream, karena itu adalah alam semesta yang terpisah di dalam nginx.  Kisah tentang mereka layak untuk beberapa artikel. <br><br><h2>  Anatomi Modul HTTP </h2><br>  Bahkan jika Anda tidak menulis kode C di dalam nginx, tetapi menggunakannya, ingat aturan utama. <br><blockquote>  Dalam nginx, semuanya mematuhi Rantai Tanggung Jawab - pola COR. </blockquote>  Saya tidak tahu bagaimana menerjemahkan ini ke dalam bahasa Rusia, tetapi saya akan menjelaskan logikanya.  Permintaan Anda melewati galaksi modul rantai yang dikonfigurasi, mulai dari lokasi.  Masing-masing modul ini mengembalikan hasilnya.  Jika hasilnya buruk, rantai terputus. <br><br><img src="https://habrastorage.org/webt/ky/sf/zj/kysfzj-evntyaf8v8q53ygxgrr4.jpeg"><br><br>  Saat mengembangkan modul atau menggunakan beberapa arahan dalam NJS dan Lua, jangan lupa bahwa kode Anda dapat menyebabkan crash pada eksekusi rantai ini. <br><br>  Analogi terdekat dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chain of Responsibility</a> adalah garis kode Bash: <br><br><pre><code class="bash hljs">grep -RI pool nginx | awk -F<span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> | sort -u | wc -l</code> </pre> <br>  Dalam kode, semuanya cukup sederhana: jika AWK jatuh di tengah baris, maka <code>sort</code> dan perintah berikut tidak akan dieksekusi.  Modul nginx bekerja dengan cara yang sama, tetapi kebenarannya ada di nginx dan Anda bisa menyiasatinya - restart kode.  Tetapi Anda harus siap untuk crash dan menjalankan, sama seperti modul Anda yang Anda gunakan dalam konfigurasi, tetapi bukan fakta bahwa ini benar. <br><br><h3>  Jenis-jenis Modul HTTP </h3><br><blockquote>  HTTP dan nginx adalah sekelompok FASE berbeda. </blockquote><br><ul><li>  <strong>Penanganan Fase - penangan FASE</strong> . </li><li>  <strong>Filter - Filter Badan / Tajuk</strong> .  Penyaringan ini adalah Kepala atau badan permintaan. </li><li>  <strong>Proksi</strong> .  Modul proxy yang umum adalah proxy_pass, fastcgi_pass, memcached_pass. </li><li>  <strong>Modul untuk menyeimbangkan beban tertentu - Load balancers</strong> .  Ini adalah jenis modul yang paling tidak terpilin, mereka tidak banyak dikembangkan.  Contohnya adalah modul Ketama CHash, yang memungkinkan Anda melakukan hashing yang konsisten di dalam nginx untuk mendistribusikan permintaan ke backend. </li></ul><br>  Saya akan menceritakan tentang masing-masing tipe ini dan tujuannya. <br><br><h3>  Penangan fase </h3><br>  Bayangkan kita memiliki beberapa fase, mulai dari fase akses.  Ada beberapa modul di setiap fase.  Misalnya, fase ACCESS dibagi menjadi koneksi, permintaan ke nginx, verifikasi otorisasi pengguna.  Setiap modul adalah sel dalam rantai.  Mungkin ada jumlah modul yang tak terbatas dalam fase. <br><br><img src="https://habrastorage.org/webt/pn/6b/t9/pn6bt9m3khwxmsxgnqjvyzwfcb0.jpeg"><br><br>  Penangan terakhir, terakhir adalah fase KONTEN di mana konten dikirimkan sesuai permintaan. <br><blockquote>  Caranya selalu seperti ini: request - rantai penangan - konten keluaran. </blockquote>  Fase yang tersedia untuk pengembang modul dari <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_">sumber NGINX</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { NGX_HTTP_POST_READ_PHASE = <span class="hljs-number"><span class="hljs-number">0</span></span>, NGX_HTTP_SERVER_REWRITE_PHASE, NGX_HTTP_FIND_CONFIG_PHASE, NGX_HTTP_REWRITE_PHASE, NGX_HTTP_POST_REWRITE_PHASE, NGX_HTTP_PREACCESS_PHASE, NGX_HTTP_ACESS_PHASE, NGX_HTTP_POST_ACESS_PHASE, NGX_HTTP_PRECONTENT_PHASE, NGX_HTTP_CONTENT_PHASE, NGX_HTTP_LOG_PHASE, } ngx_http_phases;</code> </pre> <br>  Fase dapat ditimpa, tambahkan handler Anda sendiri.  Tidak semuanya dibutuhkan dalam kehidupan nyata, jika Anda bukan pengembang nginx core.  Karena itu, saya tidak akan berbicara tentang setiap fase, tetapi hanya tentang yang utama yang saya gunakan. <br><br>  Yang utama adalah <strong>ACCESS_PHASE.</strong>  Sangat berguna untuk menambahkan otorisasi Anda ke nginx - untuk memeriksa eksekusi permintaan dalam hal akses. <br><br>  Fase penting berikutnya yang sering saya manfaatkan adalah fase pra-konten dan konten.  <strong>PRECONTENT_PHASE</strong> memungkinkan <strong>Anda</strong> mengumpulkan metrik tentang konten yang akan dikirim sebagai respons kepada klien.  <strong>CONTENT_PHASE</strong> memungkinkan <strong>Anda</strong> membuat konten unik sendiri berdasarkan sesuatu. <br><br>  Fase terakhir yang sering saya gunakan adalah fase logging <strong>LOG_PHASE.</strong>  Secara kebetulan, arahan ACCESS_LOG berfungsi di dalamnya.  Fase logging memiliki batasan terliar yang membuat saya gila: Anda tidak dapat menggunakan subrequest dan umumnya Anda tidak dapat menggunakan permintaan apa pun.  Anda telah menyerahkan konten kepada pengguna, dan penangan, pengalih pesan dan setiap subrequest tidak akan dieksekusi. <br><br>  Saya akan menjelaskan mengapa itu menjengkelkan.  Katakanlah ketika Anda ingin menyeberang nginx dan Kafka dalam fase logging.  Pada fase ini, semuanya telah selesai: ada ukuran konten, status, semua data yang dihitung, tetapi Anda tidak dapat melakukannya subrequest.  Mereka tidak bekerja di sana.  Anda harus menulis di soket kosong pada fase logging untuk mengirim data ke Kafka. <br><br><h3>  Filter Badan / Tajuk </h3><br>  Ada dua jenis filter: Filter tubuh dan filter Tajuk. <br><br>  Contoh dari <strong>filter Tubuh</strong> adalah modul filter gzip.  Mengapa filter tubuh diperlukan?  Bayangkan Anda memiliki proxy_pass tertentu, dan Anda ingin mengubah konten atau menganalisisnya.  Dalam hal ini, Anda harus menggunakan filter Tubuh. <br><br>  Ini bekerja seperti ini: banyak potongan datang kepada Anda, Anda melakukan sesuatu dengan mereka, lihat isinya, agregat, dll.  Tetapi filter juga memiliki batasan yang signifikan.  Misalnya, jika Anda memutuskan untuk mengubah isi - untuk menyisipkan atau memotong isi tanggapan, ingat bahwa atribut HTTP, misalnya, umpan konten, akan diganti.  Ini dapat menyebabkan efek aneh jika Anda tidak memberikan batasan dan merefleksikan dengan benar dalam kode Anda. <br><br>  Contoh <strong>filter Header</strong> adalah add_header yang digunakan semua orang.  Algoritma bekerja seperti pada filter Tubuh.  Respons disiapkan untuk klien, dan filter add_header memungkinkan Anda melakukan sesuatu di sana: tambahkan tajuk, hapus tajuk, ganti tajuk, kirim subrequest. <br><br>  Ngomong-ngomong, di filter Tubuh dan di subrequest filter Header tersedia, Anda bahkan dapat mengirim identifikasi internal ke lokasi tambahan di sana. <br><br><h3>  Proksi </h3><br>  Ini adalah jenis modul yang paling kompleks dan kontroversial yang memungkinkan Anda untuk mem-proxy permintaan ke sistem eksternal, misalnya, <strong>mengonversi HTTP ke protokol lain</strong> .  Contoh: proxy_pass, redis_pass, tnt_pass. <br><br>  Proxy adalah antarmuka yang diusulkan pengembang nginx core untuk membuat penulisan modul proxy lebih mudah.  Jika ini dilakukan dengan cara klasik, maka untuk proxy penangan PHASES, filter, Balancers akan dieksekusi.  Namun, jika protokol yang ingin Anda konversi HTTP berbeda dari yang klasik, maka masalah besar akan dimulai.  API proxy yang diberikan nginx sama sekali tidak cocok - Anda harus membuat modul proxy ini dari awal. <br><br>  Contoh modul yang bagus adalah postgres_pass.  Memungkinkan nginx untuk berkomunikasi dengan PostgreSQL.  Modul ini tidak menggunakan antarmuka yang dikembangkan di nginx sama sekali - ia memiliki jalurnya sendiri. <br><blockquote>  Ingat proksi, tetapi sebaiknya jangan menulis.  Untuk menulis proxy, Anda harus mempelajari semua nginx dengan hati - itu sangat panjang dan sulit. </blockquote><br><h3>  Muat penyeimbang </h3><br>  Tugas Load balancers sangat sederhana - untuk bekerja dalam mode round-robin.  Bayangkan bahwa Anda memiliki bagian hulu, beberapa server di dalamnya, Anda menentukan bobot dan metode penyeimbangan.  Ini adalah penyeimbang beban tipikal. <br><br>  Mode ini tidak selalu cocok.  Oleh karena itu, modul Ketama CHash dikembangkan, di mana dimungkinkan secara kondisional untuk sampai pada permintaan hash yang konsisten ke beberapa server.  Terkadang itu nyaman.  Nginx Lua menawarkan balancer_by_lua.  Pada Lua, Anda dapat menulis penyeimbang apa pun secara umum. <br><br><h2>  Modul C </h2><br>  Berikutnya akan menjadi pendapat subjektif saya tentang pengembangan C-modules.  Untuk mulai dengan - aturan subjektif saya. <br><br>  <strong>Modul ini dimulai dengan arahan nginx.conf.</strong>  Bahkan jika Anda membuat modul-C yang hanya akan dioperasikan oleh perusahaan Anda, selalu pikirkan arahan.  Mulai merancang modul dengan mereka, karena ini adalah apa yang akan berkomunikasi dengan administrator sistem.  Ini penting - koordinasikan semua nuansa dengan dia atau dengan orang yang akan mengoperasikan modul-C Anda.  NGINX adalah produk yang terkenal, arahannya mematuhi undang-undang tertentu yang diketahui oleh administrator sistem.  Karena itu, selalu memikirkannya. <br><br>  <strong>Gunakan gaya kode nginx.</strong>  Bayangkan bahwa modul Anda akan didukung oleh orang lain.  Jika dia sudah terbiasa dengan nginx dan gaya kodenya, akan lebih mudah baginya untuk membaca dan memahami kode Anda. <br><br>  Baru-baru ini, seorang teman baik dari Jerman meminta saya untuk membantunya menangani bug di dalam kode nginx-nya.  Saya tidak tahu untuk gaya kode apa yang ditulisnya, tetapi saya bahkan tidak bisa membaca kodenya secara normal. <br><br>  <strong>Gunakan kumpulan memori yang benar.</strong>  Ingatlah selalu hal ini, bahkan jika Anda memiliki banyak pengalaman dengan nginx.  Kesalahan umum pengembang modul C pemula untuk nginx adalah mendapatkan kumpulan yang salah. <br><br>  Sedikit latar belakang: nginx umumnya menggunakan ideologi pengalokasi yang lemah.  Anda dapat menggunakan malloc di sana, tetapi tidak disarankan.  Ini memiliki lempengan sendiri, pengalokasi memorinya sendiri;  Oleh karena itu, setiap objek memiliki tautan ke kumpulannya, dan kumpulan ini perlu digunakan.  Kesalahan pemula pada umumnya adalah menggunakan koneksi kumpulan di filter header, bukan permintaan kumpulan.  Ini berarti bahwa jika kita memiliki koneksi tetap-hidup, kolam akan membengkak sampai kehabisan memori atau efek samping lainnya terjadi.  Karena itu, penting. <br><br>  Apalagi kesalahan seperti itu sangat sulit untuk debut.  Valgrind ("syshniks" akan mengerti) tidak bekerja dengan alokasi slab - ini akan menampilkan gambar yang aneh. <br><br>  <strong>Jangan gunakan pemblokiran I / O.</strong>  Kesalahan umum dari mereka yang ingin menerapkan sesuatu eksternal lebih cepat adalah dengan menggunakan memblokir I / O dan memblokir soket.  Anda tidak pernah dapat melakukan ini di nginx - ada banyak proses di dalamnya, tetapi setiap proses menggunakan satu utas. <br><br>  Anda dapat melakukan multi-threading, tetapi, sebagai aturan, ini hanya memperburuknya.  Jika Anda menggunakan pemblokiran I / O dalam arsitektur seperti itu, maka semua orang akan menunggu bagian pemblokiran ini. <br><br>  Saya akan menguraikan apa yang saya katakan di atas. <br><br><h3>  Modul ini dimulai dengan arahan nginx.conf </h3><blockquote>  Tentukan di mana array arahan Anda harus hidup: Utama, Server, HTTP, lokasi, lokasi jika. </blockquote>  Cobalah untuk menghindari lokasi jika - sebagai aturan, ini mengarah ke penggunaan konfigurasi nginx yang sangat aneh. <br><br>  Semua arahan dalam nginx hidup dalam konteks dan lingkup yang berbeda.  Arahan add_header dapat bekerja pada level HTTP, pada level lokasi, pada level lokasi-jika-level.  Ini biasanya dijelaskan dalam dokumentasi. <br><blockquote>  Pahami pada level apa arahan Anda dapat bekerja, di mana arahan dijalankan: PHASE Handler, Filter Header / Badan. </blockquote>  Ini penting karena dalam nginx konfigurasi dibekukan.  Secara konvensi, ketika Anda menulis add_header di suatu tempat di atas, nilai ini dihaluskan di add_header bawah, yang sudah Anda miliki di lokasi.  Dengan demikian, Anda akan menambahkan dua header.  Ini berlaku untuk arahan apa pun. <br><br>  Jika Anda menentukan sesuatu port host, maka sebaliknya - kumpulan soket.  Ini harus ditunjukkan satu kali. <br><br>  Secara umum, saya akan melarang penggabungan - Anda hanya tidak membutuhkannya.  Oleh karena itu, Anda harus selalu menentukan dengan jelas di mana nginx array dari konfigurasi arahan atau set arahan Anda. <br><br>  Contoh yang bagus: <br><br><pre> <code class="cpp hljs">location /my_location/ { add_header â€œMy-Headerâ€ â€œmy valueâ€; }</code> </pre> <br>  Di sini add_header hanya ditambahkan ke lokasi.  Add_header yang sama bisa berada di suatu tempat di atas, dan semuanya akan berubah bentuk.  Ini adalah perilaku yang terdokumentasi dan dapat dimengerti. <br><blockquote>  Pikirkan tentang apa yang mungkin menghambat implementasi arahan. </blockquote>  Bayangkan Anda sedang mengembangkan filter Tubuh.  Seperti yang saya katakan di atas, nginx hanya meletakkan modul Anda di rantai yang sama, dan Anda tidak memiliki jaminan bahwa modul gzip tidak masuk ke rantai di depan filter Tubuh Anda pada waktu kompilasi.  Dalam hal ini, jika seseorang menyalakan modul gzip, data akan dikirim ke modul Anda untuk gzip.  Ini mengancam bahwa Anda tidak dapat melakukan apa pun dengan konten tersebut.  Anda dapat melakukan gzip kembali, misalnya, tetapi ini adalah ejekan dari sudut pandang CPU. <br><br>  Aturan yang sama berlaku untuk semua penangan fase - tidak ada jaminan siapa yang akan dipanggil sebelum dan siapa yang mengejar.  Karena itu, hormati orang yang akan dipanggil, dan ingat bahwa beberapa gzip atau sesuatu yang lain mungkin tiba-tiba terbang ke Anda. <br><br><h3>  Gaya kode nginx </h3><br><blockquote>  Ketika Anda membuat produk, ingatlah bahwa seseorang akan mendukungnya.  Jangan lupa tentang kode gaya nginx. </blockquote>  Sebelum menulis modul nginx Anda, biasakan diri Anda dengan sumber: <a href="">satu</a> dan yang <a href="">kedua</a> . <br><br>  Jika di masa depan Anda mengambil pengembangan modul nginx, maka Anda akan mengetahui sumber-sumber nginx.  Anda akan menyukainya karena tidak <strong>ada dokumentasi</strong> .  Anda akan mempelajari struktur direktori nginx dengan baik, belajar menggunakan Grep, mungkin Sed, ketika Anda perlu mentransfer beberapa bagian dari nginx ke modul Anda. <br><br><h3>  Kolam memori </h3><br>  Kolam harus digunakan dengan benar.  <strong>Misalnya, "r-&gt; connection-&gt; pool! = R-&gt; pool".</strong>  Dalam kasus apa pun Anda tidak dapat menggunakan konfigurasi kumpulan memori saat memproses permintaan, itu akan membengkak sampai nginx restart. <br><br>  Memahami umur objek.  Misalkan permintaan replay memiliki umur pipa yang persis seperti ini.  Di kolam ini Anda bisa meletakkan banyak barang dan membuat ruangan.  Koneksi dapat hidup secara teoritis tanpa batas - lebih baik menempatkan sesuatu yang sangat penting di dalamnya. <br><br>  <strong>Usahakan untuk tidak menggunakan pengalokasi eksternal, misalnya, malloc / gratis</strong> .  Ini memiliki efek buruk pada fragmentasi memori.  Jika Anda beroperasi dengan volume data yang besar dan menggunakan banyak malloc, nginx ini melambat dengan cukup baik. <br><br>  <strong>Untuk penggemar Valgrind ada</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>peretasan</strong></a> yang memungkinkan Anda untuk men-debug nginx-pools menggunakan Valgrind.  Ini penting jika Anda memiliki banyak kode C pada nginx, karena bahkan pengembang yang berpengalaman dalam bekerja dengan memori dapat membuat kesalahan. <br><br><h3>  Memblokir I / O </h3><blockquote>  Semuanya sederhana di sini - jangan gunakan pemblokiran I / O. </blockquote>  Kalau tidak, setidaknya akan ada masalah dengan koneksi tetap hidup, tetapi sebagai maksimum, semuanya akan bekerja untuk waktu yang sangat lama. <br><br>  Saya tahu kasusnya ketika seseorang menggunakan Quora di dalam nginx dalam mode blocking (jangan tanya kenapa).  Ini mengarah pada fakta bahwa koneksi tetap hidup meninggalkan aktivitas mereka dan kehabisan waktu sepanjang waktu.  Lebih baik tidak melakukan ini - semuanya akan bekerja untuk waktu yang lama, tidak efisien dan Anda harus segera memutar sejuta batas waktu, karena nginx akan memulai batas waktu pada banyak hal. <br><br>  Tetapi ada alternatif untuk C-modul - NJS dan Lua. <br><br><h2>  Ketika Anda tidak perlu mengembangkan modul-C </h2><br>  Tahun ini saya memiliki pengalaman pertama saya bekerja di NJS, saya mendapat kesan subjektif, dan saya bahkan menyadari apa yang hilang di sana, sehingga semuanya baik-baik saja.  Saya juga ingin berbicara tentang pengalaman saya bekerja pada Lua di bawah nginx, dan, apalagi, berbagi masalah yang ada di Lua. <br><br><h3>  Lua / LuaJit Essentials </h3><br>  Nginx tidak menggunakan Lua, tetapi LuaJit.  Tapi ini bukan Lua, karena Lua sudah maju dua versi, dan LuaJit terjebak di suatu tempat di masa lalu.  <strong>Penulis praktis tidak mengembangkan LuaJit - ia sering hidup dalam percabangan.</strong>  Garpu terbaru adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuaJit2</a> .  Ini menambah situasi aneh di OpenResty yang sama. <br><br>  <strong>Pengumpul Sampah perlu mendapat perhatian</strong> .  LuaJit tidak dapat mengatasi masalah ini - cukup buat beberapa solusi.  Dengan beban yang besar, ketika banyak Kolektor Sampah yang tetap hidup akan terlihat pada klien dengan kegagalan pada grafik dan 500 kesalahan. Ada banyak cara untuk berurusan dengan Kolektor Sampah di Lua, saya tidak akan fokus pada mereka di sini.  Ada banyak informasi tentang ini di Internet. <br><br>  <strong>Implementasi string mengarah ke masalah kinerja</strong> .  Ini hanya kejahatan LuaJit, dan di Lua itu diperbaiki.  Implementasi string di LuaJit hanya menentang logika apa pun.  Garis melambat dengan cara terliar, yang terkait dengan implementasi internal. <br><br>  <strong>Ketidakmampuan untuk menggunakan banyak perpustakaan yang sudah jadi</strong> .  Lua awalnya memblokir, jadi sebagian besar perpustakaan di Lua dan LuaJit menggunakan pemblokiran I / O.  Karena fakta bahwa nginx tidak memblokir, tidak mungkin untuk menggunakan perpustakaan yang sudah jadi di dalam nginx yang menggunakan I / O pemblokiran apa pun.  Ini akan memperlambat nginx. <br><br>  Alasan menggunakan LuaJit identik dengan alasan menggunakan modul: <br><br><ul><li>  pembuatan prototipe modul yang kompleks; </li><li>  HMAC, perhitungan SHA untuk otorisasi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyeimbang</a> ; </li><li>  aplikasi kecil: penangan header, aturan untuk pengalihan; </li><li>  variabel komputasi untuk nginx.conf. </li></ul><br>  Di mana lebih baik tidak menggunakan LuaJit? <br><blockquote>  Aturan utama: jangan memproses tubuh besar di Lua - ini tidak bekerja. </blockquote>  <strong>Penangan untuk konten di Lua juga tidak berfungsi</strong> .  Cobalah untuk meminimalkan logika hingga beberapa <code>if</code> .  Sebuah penyeimbang sederhana akan bekerja, tetapi bilah sisi pada Lua akan bekerja dengan sangat buruk. <br><br>  <strong>Memori bersama atau Pengumpul Sampah akan datang.</strong>  Jangan gunakan Memori bersama dengan Lua - Pengumpul Sampah akan dengan cepat dan dengan jaminan mengeluarkan seluruh otak untuk diproduksi. <br><br>  <strong>Jangan gunakan coroutine</strong> dengan banyak senyawa yang tetap hidup.  Coroutine menghasilkan lebih banyak sampah di dalam Pengumpul Sampah LuaJit, yang mana ini buruk. <br><br>  Jika Anda sudah menggunakan LuaJit, maka ingat: <br><br><ul><li>  tentang pemantauan memori; </li><li>  tentang pemantauan dan optimalisasi pekerjaan Pengumpul Sampah; </li><li>  tentang cara kerja Pengumpul Sampah, jika Anda memang menulis aplikasi yang rumit untuk LuaJit, karena Anda harus menambahkan sesuatu yang baru. </li></ul><br><h3>  Njs </h3><br>  Ketika saya di NGINX Conf, mereka meyakinkan saya bahwa akan lebih baik untuk tidak menulis kode dalam C. Saya pikir saya harus mencoba, dan itulah yang saya dapatkan. <br><br>  <strong>Otorisasi</strong>  Berhasil, kodenya sederhana, tidak memengaruhi kecepatan - semuanya hebat.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prototipe</a> kecil saya yang saya mulai adalah 10 baris kode.  Tetapi 10 baris ini melakukan otorisasi dengan s3. <br><br>  <strong>Komputasi variabel untuk nginx.conf.</strong>  Banyak variabel dapat dihitung menggunakan NJS.  Di dalam nginx, ini keren.  Ada fitur seperti itu di Lua, tetapi ada seorang Kolektor Sampah, jadi tidak begitu keren. <br><br>  Namun, tidak semuanya baik-baik saja.  Untuk melakukan hal-hal yang sangat keren di NJS, dia kehilangan beberapa hal. <br><br>  <strong>Memori Bersama</strong> .  Saya menambal Memori Bersama, ini adalah garpu saya sendiri, jadi sekarang sudah cukup. <br><br>  <strong>Filter mendukung lebih banyak fase</strong> .  Di NJS, hanya ada fase konten dan variabel, dan filter header sangat kurang.  Anda harus menulis kruk untuk menambahkan banyak tajuk.  Tidak ada cukup filter tubuh untuk logika kompleks atau bekerja dengan konten. <br><br>  <strong>Informasi tentang cara memonitor dan membuat profilnya</strong> .  Saya sekarang tahu caranya, tetapi saya harus mempelajari sumbernya.  Tidak ada informasi atau alat yang cukup tentang profil yang tepat.  Jika ya, itu tersembunyi di tempat yang tidak dapat ditemukan.  Pada saat yang sama, tidak ada cukup informasi tentang di <strong>mana saya bisa menggunakan NJS</strong> dan di mana saya tidak bisa? <br><br>  <strong>Modul-C</strong> .  Saya memiliki keinginan untuk memperluas NJS. <br><br><h2>  Kata penutup </h2><br>  <strong>Mengapa membuat modul Anda sendiri?</strong>  Untuk memecahkan masalah umum dan bisnis. <br><br>  <strong>Kapan saya perlu mengimplementasikan modul dalam C?</strong>  Jika tidak ada pilihan lain.  Misalnya, beban berat, penyisipan konten atau penghematan dasar pada perangkat keras.  Maka ini harus dilakukan dijamin dalam C. Dalam kebanyakan kasus, Lua atau NJS cocok.  Tetapi Anda harus selalu berpikir ke depan. <br><br>  <strong>Dan pada Lua?</strong>  Ketika Anda tidak dapat menulis dalam C. Misalnya, Anda tidak perlu mengonversi badan permintaan dengan RPS yang besar.  Jumlah pelanggan Anda bertambah, pada titik tertentu Anda akan berhenti mengatasinya - pikirkanlah. <br><br>  <strong>NJS?</strong>  Ketika LuaJit benar-benar muak dengan Kolektor Sampah dan senarnya.  Misalnya, otorisasi menghasilkan banyak objek Sampah di Lua, tetapi ini tidak penting.  Namun, ini tercermin dalam pemantauan dan menjengkelkan.  Sekarang sudah tidak lagi muncul dalam pemantauan saya, dan semuanya menjadi baik. <br><br><blockquote>  Di HighLoad ++ 2019, Vasily Soshnikov akan melanjutkan topik modul nginx dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> lebih banyak tentang NJS, tidak melupakan perbandingan dengan LuaJit dan C. <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar</a> lengkap laporan di situs web, dan sampai jumpa pada 7 dan 8 November di konferensi terbesar untuk pengembang sistem yang sangat sarat.  Ikuti ide-ide baru kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471684/">https://habr.com/ru/post/id471684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471666/index.html">Alami pengalaman Pengembang iOS pindah ke Jerman dengan visa kerja</a></li>
<li><a href="../id471668/index.html">Analisis teknis eksploitasi checkm8</a></li>
<li><a href="../id471670/index.html">Mencoba Jetpack Compose dalam pertempuran?</a></li>
<li><a href="../id471676/index.html">Penipu telepon. Tindakan kedua, di mana saya mogok dan lari ke ATM terdekat</a></li>
<li><a href="../id471678/index.html">Beruang layanan sesuai permintaan</a></li>
<li><a href="../id471686/index.html">Bagaimana AWS mengolah layanannya yang tangguh. Penskalaan server dan basis data</a></li>
<li><a href="../id471688/index.html">Bagaimana AWS mengolah layanannya yang tangguh. Penskalaan jaringan</a></li>
<li><a href="../id471700/index.html">Bagaimana saya memilih tumpukan teknologi dengan fondasi untuk masa depan</a></li>
<li><a href="../id471702/index.html">Aplikasi Web yang ditingkatkan oleh Cyber</a></li>
<li><a href="../id471704/index.html">Buku â€œMitokondria egois. Cara menjaga kesehatan dan memindahkan usia lanjut "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>