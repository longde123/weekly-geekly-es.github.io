<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇ ‚ö™Ô∏è üßú Contr√¥le des LED RVB via les microcontr√¥leurs Cypress UDB PSoC ü§≥üèΩ ü§πüèø üàØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 J'ai longtemps voulu apprendre la technique de programmation des blocs UDB dans les contr√¥leurs Cypress PSoC, mais d'une mani√®re ou d'u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contr√¥le des LED RVB via les microcontr√¥leurs Cypress UDB PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429882/"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  Pr√©sentation </h2><br>  J'ai longtemps voulu apprendre la technique de programmation des blocs UDB dans les contr√¥leurs Cypress PSoC, mais d'une mani√®re ou d'une autre, toutes mes mains n'ont pas atteint.  Et donc, un probl√®me s'est pos√© sur lequel cela pourrait √™tre fait.  Comprenant les mat√©riaux du r√©seau, j'ai r√©alis√© que les recommandations pratiques pour travailler avec UDB se limitaient √† diverses variantes de compteurs et de PWM.  Pour une raison quelconque, tous les auteurs font leurs variantes de ces deux exemples canoniques, de sorte que la description d'autre chose pourrait bien √™tre int√©ressante pour les lecteurs. <br><a name="habracut"></a><br>  Alors.  Il y avait un probl√®me pour g√©rer dynamiquement une longue file de LED RVB WS2812B.  Des approches classiques de cette question sont connues.  Vous pouvez prendre l'Arduino trivial, mais l√†, la sortie est programm√©e, donc pendant que les donn√©es sont sorties, tout le reste est inactif, sinon les chronogrammes √©choueront.  Vous pouvez prendre STM32 et sortir des donn√©es soit via DMA vers PWM, soit via DMA vers SPI.  Les techniques sont connues.  J'ai m√™me, √† un moment donn√©, personnellement contr√¥l√© une ligne de seize diodes via SPI.  Mais les frais g√©n√©raux sont excellents.  Un bit de donn√©es dans les LED occupe 8 bits en m√©moire pour le cas de PWM et de 3 √† 4 bits (selon la fra√Æcheur PLL dans le contr√¥leur) pour SPI.  Bien qu'il y ait peu de LED, ce n'est pas effrayant, mais s'il y en a quelques centaines, alors 200 * 24 = 4800 bits = 600 octets de donn√©es utiles doivent √™tre stock√©s physiquement dans un tampon d'une capacit√© de plus de 4 kilo-octets pour l'option PWM ou de plus de 2 kilo-octets pour SPI- les options.  Pour une indication dynamique des tampons, il devrait y en avoir plusieurs, et le STM32F103 a de la RAM pour tout sur tout 20 kilo-octets.  Non pas que nous ayons rencontr√© une t√¢che irr√©alisable, mais une raison de v√©rifier si cela peut √™tre impl√©ment√© sur le PSoC sans avoir besoin de d√©penser de RAM suppl√©mentaire, est assez importante. <br><br><h2>  R√©f√©rences th√©oriques </h2><br>  Tout d'abord, d√©couvrons quel genre de b√™te est un tel UDB et comment ils fonctionnent avec.  De merveilleux films p√©dagogiques du fabricant du contr√¥leur vous y aideront. <br><br>  Vous devriez commencer √† regarder √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> , puis √† la fin de chaque vid√©o, il y aura un lien vers la s√©rie suivante.  √âtape par √©tape, vous acquerrez des connaissances de base et consid√©rerez l'exemple canonique ¬´compteur¬ª.  Eh bien, et un syst√®me de contr√¥le des feux de circulation. <br><br>  √Ä peu pr√®s le m√™me, mais coup√© en petits morceaux, vous pouvez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir ici</a> .  Ma vid√©o n'a pas √©t√© lue, mais elle peut √™tre t√©l√©charg√©e et visionn√©e localement.  Entre autres choses, il existe √©galement un exemple canonique de la mise en ≈ìuvre de PWM. <br><br><h2>  Solutions finies </h2><br>  Afin de ne pas r√©inventer la roue (et vice versa - pour apprendre la m√©thodologie de l'exp√©rience de quelqu'un d'autre), j'ai fouill√© le r√©seau √† la recherche de solutions toutes faites pour contr√¥ler les LED RGB.  La solution la plus populaire est StripLightLib.cylib.  Mais depuis de nombreuses ann√©es, il pr√©voit d'ajouter le support Ajouter un DMA.  Mais je veux essayer une solution qui ne d√©pend pas du processeur central.  Je veux commencer le processus et l'oublier, en me concentrant sur la pr√©paration de la prochaine image. <br><br>  La solution qui correspond √† mes souhaits a √©t√© trouv√©e sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel</a> . <br><br>  Tout y est impl√©ment√© sur UDB (mais les LED ne sont qu'une excuse, le but est d'apprendre UDB).  Il existe un support pour DMA.  Et le projet l√†-bas est clairement magnifiquement organis√©. <br><br><h2>  Probl√®mes de la solution choisie comme base </h2><br>  Comment le "firmware" dans le projet PSoC_DMA_NeoPixel est organis√©, ceux qui le souhaitent peuvent le voir apr√®s avoir lu l'article.  Cela corrigera le mat√©riau.  Pour l'instant, je dirai seulement que j'ai d'abord simplifi√© la logique du firmware d'origine sans r√©duire les ressources consomm√©es (mais c'est devenu plus facile √† comprendre).  Puis il a commenc√© √† exp√©rimenter le remplacement de la logique de l'automate, qui promettait un gain de ressources, mais rencontrait un s√©rieux probl√®me.  Et il a donc d√©cid√© - il n'est pas √©limin√©!  Et de vagues doutes ont commenc√© √† me tourmenter: l'auteur anglais avait-il le m√™me probl√®me?  Sa d√©mo clignote tr√®s joliment avec des LED.  Mais que se passe-t-il si nous rempla√ßons le beau remplissage par ¬´toutes les unit√©s¬ª et contr√¥lons la sortie non pas avec nos yeux, mais avec un oscilloscope? <br>  Donc, aussi grossi√®rement que possible (vous pourriez m√™me dire ¬´brutalement¬ª), nous formons les donn√©es: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  Et ici, nous voyons une telle image sur un oscilloscope: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  Le premier bit a une largeur diff√©rente de celle du reste.  J'ai demand√© d'envoyer toutes les unit√©s, mais pas toutes de partir.  Parmi eux, z√©ro!  Modifiez l'analyse: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  La largeur est diff√©rente pour chaque huiti√®me bit. <br><br>  En g√©n√©ral, cet exemple en tant que solution ind√©pendante ne convient pas, mais en tant que source d'inspiration - tout simplement parfait.  Tout d'abord, son inop√©rabilit√© n'est pas visible √† l'oeil (les LED sont toujours brillantes, l'oeil ne voit pas qu'elles brillent √† moiti√© maximum), mais le code est bien structur√©, c'est agr√©able de le prendre comme base.  Deuxi√®mement, cet exemple fournit un espace pour trouver des moyens de simplifier, et troisi√®mement, il vous fait r√©fl√©chir sur la fa√ßon de corriger le d√©faut.  L'essentiel est de comprendre le mat√©riel!  Donc, encore une fois, apr√®s avoir lu l'article, je recommande d'essayer d'analyser l'exemple d'origine, en r√©alisant comment cela fonctionne. <br><br><h2>  Partie pratique </h2><br>  Maintenant, nous commen√ßons √† pratiquer.  Nous testons les principaux aspects du d√©veloppement de firmware pour UDB.  Consid√©rez la relation et les techniques de base.  Pour ce faire, ouvrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ma version du projet</a> .  Le bloc de gauche stocke des informations sur les fichiers de travail.  Par d√©faut, l'onglet <b>Source</b> est ouvert.  La principale source du projet est le fichier <b>main.c.</b>  En fait, il n'y a aucun autre fichier de travail dans le groupe <b>Fichiers source</b> . <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  Le groupe <b>Source g√©n√©r√©e</b> contient des fonctions de biblioth√®que.  Il vaut mieux ne pas les modifier.  Apr√®s chaque modification du ¬´firmware¬ª de l'UDB, ce groupe sera r√©g√©n√©r√©.  Alors, o√π est la description du code pour UDB dans cette idylle?  Pour le voir, vous devez basculer vers l'onglet <b>Composants</b> : <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  L'auteur du projet original a r√©alis√© un ensemble de composants √† deux niveaux.  Au niveau sup√©rieur se trouve le circuit <b>NeoPixel_v1_2.cysch</b> .  Cela peut √™tre vu √† partir du sch√©ma principal: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  Le composant est le suivant: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  La prise en charge logicielle de ce sch√©ma sera discut√©e ult√©rieurement.  En attendant, d√©couvrez que lui-m√™me est une unit√© DMA r√©guli√®re et un certain symbole <b>NeoPixDrv_v1</b> .  Ce myst√©rieux bloc est d√©crit ci-dessus dans l'arborescence, qui d√©coule de l'infobulle suivante: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  UDB "Firmware" </h2><br>  Ouvrez ce composant (fichier avec l'extension <b>.cyudb</b> ).  Le dessin ouvert est tout simplement √©norme.  Nous commen√ßons √† comprendre ce qui est quoi. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  Contrairement √† l'auteur du projet original, je consid√®re la transmission de chaque bit de donn√©es sous la forme de trois parties √©gales (dans le temps): <br><br><ol><li>  Partie de d√©part (toujours 1) </li><li>  Partie de donn√©es </li><li>  Arr√™ter la partie (toujours 0) </li></ol><br>  Avec cette approche, un grand nombre de compteurs n'est pas n√©cessaire (dans l'original, il y avait jusqu'√† trois pi√®ces, ce qui consommait une grande quantit√© de ressources).  La dur√©e de toutes les parties est la m√™me et peut √™tre r√©gl√©e √† l'aide d'un seul registre.  Ainsi, le graphe de transition du firmware contient les √©tats suivants: <br><br>  √âtat <b>inactif</b> .  La machine y reste jusqu'√† l'arriv√©e de nouvelles donn√©es dans FIFO. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  D'apr√®s les vid√©os de formation, il n'√©tait pas tout √† fait clair pour moi comment l'√©tat de la machine est li√© √† l'ALU.  Les auteurs utilisent la communication comme une √©vidence, mais moi, en tant que d√©butant, je ne pouvais pas la voir imm√©diatement.  Jetons-y un coup d‚Äô≈ìil en d√©tail.  La figure ci-dessus montre que l'√©tat de veille est cod√© avec la valeur 1'b0.  3'b000 sera plus correct, mais l'√©diteur refait tout de m√™me.  Les entr√©es du bloc <b>Datapath sont</b> d√©crites comme <b>suit</b> : <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  Si vous double-cliquez dessus, une version plus d√©taill√©e appara√Ætra: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  Cela signifie que le bit z√©ro de l'adresse de l'instruction ALU correspond au bit z√©ro de la variable qui d√©finit l'√©tat de la machine.  Le premier est le premier, le second est le second.  Si vous le souhaitez, toutes les variables et m√™me les expressions peuvent √™tre mises en correspondance avec les bits d'adresse de l'instruction ALU (dans la version d'origine, le deuxi√®me bit de l'adresse de l'instruction ALU √©tait mis en correspondance par une expression, de plus, il n'est pas utilis√© explicitement dans la version actuelle, mais c'est tr√®s √©vident comme exemple de transport de cerveau, alors vous pouvez jeter un coup d'≈ìil). <br><br>  Alors.  Avec les param√®tres actuels des entr√©es, qui est le code d'√©tat binaire de la machine, une telle instruction ALU est utilis√©e.  Lorsque nous sommes en √©tat <b>inactif</b> avec le code 000, une instruction nulle est utilis√©e.  Le voici: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  Je sais d√©j√† de cette entr√©e que c'est un NOP banal.  Mais vous pouvez double-cliquer dessus et lire la version compl√®te: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  Les NOP sont inscrits partout.  Les registres ne sont remplis de rien. <br><br>  Voyons maintenant quel type de drapeau myst√©rieux <b>! NoData</b> , for√ßant la machine √† quitter l'√©tat <b>inactif</b> .  Il s'agit de la sortie du bloc <b>Datapath</b> .  Au total, jusqu'√† six sorties peuvent √™tre d√©crites.  C'est juste que <b>Datapath</b> peut produire beaucoup plus de drapeaux, mais il n'y a pas suffisamment de ressources de trace pour tout le monde, nous devons donc choisir les six (ou moins) dont nous avons vraiment besoin.  Voici la liste de la figure: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Si vous double-cliquez dessus, les d√©tails seront r√©v√©l√©s: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Voici la liste compl√®te des drapeaux pouvant √™tre affich√©s: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  Apr√®s avoir s√©lectionn√© le drapeau requis, vous devez lui donner un nom.  D√©sormais, le syst√®me a un drapeau.  Comme vous pouvez le voir, l'indicateur <b>NoData</b> est le nom de l' <b>√©tat du bloc F0</b> de la cha√Æne <b>(vide)</b> .  Autrement dit, un signe qu'il n'y a pas de donn√©es dans le tampon d'entr√©e.  Ah <b>! NoData</b> , respectivement, son inversion.  Signe de disponibilit√© des donn√©es.  D√®s que les donn√©es entrent dans le FIFO (par programme ou en utilisant DMA), le drapeau sera effac√© (et son inversion arm√©), et au prochain cycle d'horloge, l'automate quittera l'√©tat inactif et entrera dans l'√©tat <b>GetData</b> . <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  Comme vous pouvez le voir, l'automate sortira inconditionnellement de cet √©tat apr√®s y avoir pass√© exactement un cycle d'horloge.  Aucune action n'est indiqu√©e sur le graphique de transition pour cet √©tat.  Mais vous devriez toujours regarder ce que fera ALU.  Le code de statut est 1'b1, c'est-√†-dire 3'b001.  Nous regardons l'adresse correspondante dans ALU: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  Il y a quelque chose.  N'ayant aucune exp√©rience de la lecture de ce qui est √©crit ici, ouvrez-le en double-cliquant sur la cellule correspondante: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  Il s'ensuit que l'ALU lui-m√™me n'effectue toujours aucune action.  Mais le contenu de FIFO0, c'est-√†-dire les donn√©es provenant du programme ou du bloc DMA, seront plac√©s dans le registre A0.  Pour l'avenir, je dirai que A0 est utilis√© comme registre √† d√©calage, √† partir duquel l'octet sortira sous forme s√©rie.  Le registre A1 place la valeur du registre D1.  En g√©n√©ral, tous les registres D sont g√©n√©ralement remplis par le logiciel avant que le mat√©riel ne soit activ√©.  Ensuite, lors de l'examen de l'API, nous verrons que le nombre de tics d'horloge est mis dans ce registre, qui d√©finit la dur√©e du troisi√®me bit.  Alors.  En A0, la valeur d√©cal√©e a chut√© et en A1, la dur√©e de la partie de d√©but du bit.  Et au prochain temps, la machine entrera certainement dans l'√©tat <b>Constant1</b> . <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  Comme le nom de l'√©tat l'indique, la constante 1 est g√©n√©r√©e ici. Regardons la documentation de la LED.  Voici comment l'unit√© doit √™tre transf√©r√©e: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  Et le voici - z√©ro: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  J'ai ajout√© des lignes rouges.  Si nous supposons que les dur√©es des tiers sont √©gales, alors les exigences pour la dur√©e des impulsions (donn√©es dans la m√™me documentation) sont remplies.  C'est-√†-dire que toute impulsion se compose d'une unit√© de d√©marrage, d'un bit de donn√©es et d'un z√©ro d'arr√™t.  En fait, l'unit√© de d√©marrage est transmise lorsque la machine est en √©tat <b>Constant1</b> . <br><br>  Dans cet √©tat, la machine verrouille l'unit√© dans sa g√¢chette interne.  Le nom du d√©clencheur est <b>CurrentBit</b> .  Dans le projet d'origine, il s'agissait g√©n√©ralement d'un d√©clencheur qui d√©finit l'√©tat de l'automate auxiliaire.  J'ai d√©cid√© que cette machine ne ferait que confondre tout le monde, alors j'ai juste commenc√© un d√©clencheur.  Il n'est d√©crit nulle part.  Mais si vous entrez les propri√©t√©s d'√©tat, l'enregistrement suivant est visible dans le tableau: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  Et sous l'√©tat sur le graphique, il y a un tel texte: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  Ne soyez pas alarm√© par le symbole √©gal.  Ce sont les fonctionnalit√©s de l'√©diteur.  Dans le code Verilog r√©sultant (g√©n√©r√© automatiquement par le m√™me syst√®me), il y aura une fl√®che: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  La valeur verrouill√©e dans ce d√©clencheur est la sortie de l'ensemble de notre bloc: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  Autrement dit, lorsque la machine est entr√©e dans l'√©tat de <b>Constant1</b> , la sortie du bloc que nous d√©veloppons en obtient un.  Voyons maintenant comment l'ALU est programm√© pour l'adresse 3'b010: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  Nous r√©v√©lons cet √©l√©ment: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  L'unit√© 1 est soustraite du registre A1.  La valeur de sortie d'ALU tombe dans le registre A1.  Ci-dessus, nous avons consid√©r√© que A1 est un compteur d'horloge utilis√© pour d√©finir la dur√©e de l'impulsion de sortie.  Permettez-moi de vous rappeler qu'il a d√©marr√© √† partir de D1 √† la derni√®re √©tape. <br>  Quelle est la condition pour sortir d'un √âtat?  <b>CycleTimeOut</b> .  Il est d√©crit parmi les sorties comme suit: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  Donc, nous r√©unissons la logique.  Dans l'√©tat pr√©c√©dent, le contenu du registre D1 pr√©alablement rempli par le programme est tomb√© dans le registre A1.  √Ä cette √©tape, la machine traduit le d√©clencheur <b>CurrentBit</b> en un, et en ALU, le registre A1 diminue √† chaque cycle d'horloge.  Lorsque A1 devient nul, le drapeau est automatiquement lev√©, auquel l'auteur a donn√© le nom <b>CycleTimeout</b> , √† la suite de quoi la machine passe √† l'√©tat <b>Setup1</b> . <br><br>  L'√©tat <b>Setup1</b> pr√©pare les donn√©es pour transmettre l'impulsion utile. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  Nous regardons l'instruction ALU √† 3'b011.  Je vais l'ouvrir tout de suite: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  Il semblerait qu'ALU n'ait aucune action.  Op√©ration NOP.  Et la sortie ALU ne va nulle part.  Mais ce n'est pas le cas.  Une action extr√™mement importante est le transfert de donn√©es dans ALU.  Le fait est que le bit de retenue parmi les sorties est connect√© √† notre cha√Æne <b>ShiftOut</b> : <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  Et √† la suite de cette op√©ration de d√©calage, la valeur d√©cal√©e elle-m√™me n'ira nulle part, mais la cha√Æne <b>ShiftOut</b> prendra la valeur du bit le plus significatif du registre A0.  Autrement dit, les donn√©es qui devraient √™tre transmises.  Sous l'√©tat du graphique, on peut voir que cette valeur, qui a laiss√© l'ALU dans la cha√Æne <b>ShiftOut</b> , sera verrouill√©e dans le d√©clencheur <b>CurrentBit</b> .  Permettez-moi de montrer √† nouveau le dessin afin de ne pas rembobiner l'article: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  La transmission de la deuxi√®me partie du bit commence - la valeur imm√©diate est 0 ou 1. <br><br>  Nous revenons aux instructions pour ALU.  En plus de ce qui a d√©j√† √©t√© dit, il est clair que le contenu du registre D1 sera √† nouveau mis dans le registre A1 afin de mesurer √† nouveau la dur√©e du deuxi√®me tiers de l'impulsion. <br><br>  L'√©tat <b>DataStage</b> est tr√®s similaire √† l'√©tat <b>Constant1</b> .  L'automate soustrait simplement un de A1 et entre dans l'√©tat suivant lorsqu'il atteint z√©ro.  Permettez-moi m√™me de le montrer comme ceci: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  et comme √ßa: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Vient ensuite l'√©tat de <b>Setup2</b> , dont nous connaissons d√©j√† l'essence. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  Dans cet √©tat, le d√©clencheur <b>CurrentBit est</b> remis √† z√©ro (puisque le troisi√®me tiers de l'impulsion sera transmis, la partie stop, et il est toujours nul).  ALU charge le contenu de D1 dans A1.  Vous pouvez m√™me le voir dans une courte note avec votre ≈ìil exerc√©: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  L'√©tat de <b>Constant0 est</b> compl√®tement identique aux √©tats de <b>Constant1</b> et <b>DataStage</b> .  Soustrayez l'unit√© de A1.  Lorsque la valeur atteint z√©ro, quittez √† l'√©tat <b>ShiftData</b> : <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  L'√©tat de <b>ShiftData est</b> plus complexe.  Dans les instructions correspondantes pour ALU, les actions suivantes sont effectu√©es: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  Le registre A0 est d√©cal√© de 1 bit et les r√©sultats sont replac√©s dans A0.  En A1, le contenu de D1 est √† nouveau mis afin de commencer √† mesurer le tiers de d√©part pour le bit de donn√©es suivant. <br><br>  Il vaut mieux consid√©rer les fl√®ches de sortie en tenant compte des priorit√©s, pour lesquelles on double-clique sur l'√©tat <b>ShiftData</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  Si ce n'est pas le dernier bit qui est transmis (sur la fa√ßon dont ce drapeau est form√©, un peu plus bas), alors nous en transf√©rons un pour le bit suivant de l'octet courant. <br><br>  Si le dernier bit est transmis et qu'il n'y a pas de donn√©es dans FIFO, on passe √† l'√©tat inactif. <br><br>  Enfin, si le dernier bit est transmis, mais qu'il y a des donn√©es dans le FIFO, on passe √† la s√©lection et √† la transmission du prochain octet. <br><br>  Maintenant sur le compteur de bits.  Il n'y a que deux batteries en ALU: A0 et A1.  Ils sont d√©j√† occup√©s par le registre √† d√©calage et le compteur de retard, respectivement.  Par cons√©quent, un compteur de bits est utilis√© en externe. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Double-cliquez dessus: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  La valeur au d√©marrage est de six.  Il est charg√© √† l'aide de l'indicateur <b>LoadCounter</b> d√©crit dans la section variable: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  Autrement dit, lorsque le prochain octet de donn√©es est pris, cette constante est charg√©e en cours de route. <br><br>  Lorsque la machine entre dans l'√©tat <b>ShiftData</b> , le compteur diminue la valeur.  Lorsqu'il atteint z√©ro, la sortie <b>TerminalCount</b> est connect√©e, connect√©e au circuit de notre <b>graine FinalBit</b> .  C'est ce circuit qui d√©finit si la machine transf√©rera le bit suivant de l'octet en cours ou transf√©rera un nouvel octet (enfin, ou attendra un nouveau paquet de donn√©es). <br><br>  En fait, tout vient de la logique.  Comment le signal <b>SpaceForData</b> est <b>g√©n√©r√©</b> , qui d√©finit l'√©tat de la sortie <b>Hungry</b> (informant l'unit√© DMA qu'il est possible de transmettre les donn√©es suivantes), les lecteurs sont invit√©s √† suivre ind√©pendamment. <br><br><h2>  Support logiciel </h2><br>  L'auteur du projet d'origine a choisi de prendre en charge le logiciel pour l'ensemble du syst√®me dans le bloc qui d√©crit la solution int√©gr√©e.  Permettez-moi de vous rappeler que nous parlons de ce bloc: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  √Ä partir de ce niveau, il y a un contr√¥le sur l'unit√© de biblioth√®que DMA et sur toutes les parties incluses dans la partie UDB.  Pour impl√©menter l'API, l'auteur de l'original a ajout√© l'en-t√™te et les fichiers programme: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  Le format du corps de ces fichiers vous rend triste.  Tout le bl√¢me est l'amour des d√©veloppeurs PSoC Designer pour les "purs".  D'o√π les macros terribles et les noms de kilom√®tres.  L'organisation des classes en C ++ serait utile ici.  Au moins, nous avons v√©rifi√© cela lors de la mise en ≈ìuvre de notre RTOS MAX: cela s'est av√©r√© magnifique et pratique.  Mais ici, vous pouvez argumenter beaucoup, mais vous devrez utiliser ce que nous avons laiss√© d'en haut.  Je vais seulement montrer bri√®vement √† quoi ressemble la fonction API contenant ces macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  Ces r√®gles du jeu doivent √™tre accept√©es.  Vous savez maintenant d'o√π vous inspirer lors du d√©veloppement de vos fonctions (il est pr√©f√©rable de le faire dans le projet d'origine).  Et je pr√©f√®re parler des d√©tails, en prenant l'option d√©j√† trait√©e par le g√©n√©rateur. <br><br>  Apr√®s avoir g√©n√©r√© le code (d√©crit ci-dessous), ce fichier sera stock√© ici: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  Et la vue sera d√©j√† parfaitement lisible.  Jusqu'√† pr√©sent, il existe deux fonctions.  Le premier initialise le syst√®me, le second d√©marre le transfert des donn√©es du buffer vers la ligne LED. <br><br>  L'initialisation affecte toutes les parties du syst√®me.  Il y a initialisation du compteur √† sept bits, qui fait partie du syst√®me UDB: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  Il y a un calcul constant qui doit √™tre charg√© dans le registre D1 (je rappelle qu'il fixe la dur√©e de chacun des troisi√®mes bits): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  La configuration d'un bloc DMA occupe la majeure partie de cette fonction.  Le tampon est utilis√© comme source et le FIFO0 du bloc UDB est utilis√© comme r√©cepteur (NP_Neo_DPTH_F0_PTR dans l'enregistrement kilom√©trique).  L'auteur avait une partie de ce param√®tre dans la fonction de transfert de donn√©es.  Mais, √† mon avis, faire tous les calculs pour le bien de chaque transmission est trop de gaspillage.  Surtout quand on consid√®re que l'une des actions √† l'int√©rieur de la fonction semble tr√®s, tr√®s volumineuse. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  La deuxi√®me fonction dans le contexte de la premi√®re est le sommet du laconicisme.  C'est juste que le premier est appel√© au stade de l'initialisation, lorsque les exigences de performances sont assez libres.  Pendant le fonctionnement, il vaut mieux ne pas gaspiller les cycles du processeur sur quoi que ce soit de superflu: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Il n'y a clairement pas assez de fonctionnalit√©s pour travailler avec plusieurs tampons (pour fournir une double mise en m√©moire tampon), mais en g√©n√©ral, une discussion sur les fonctionnalit√©s de l'API d√©passe le cadre de l'article.  Maintenant, l'essentiel est de montrer comment ajouter un support logiciel au firmware d√©velopp√©.  Maintenant, nous savons comment le faire. <br><br><h2>  G√©n√©ration de projets </h2><br>  Donc, toute la partie firmware est pr√™te, l'API est ajout√©e, que faire ensuite?  S√©lectionnez l'√©l√©ment de menu <b>Build-&gt; Generate Application</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  Si tout se passe bien, vous pouvez ouvrir l'onglet <b>R√©sultats</b> et voir le fichier avec l'extension <b>rpt</b> . <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  Il montre combien de ressources syst√®me ont √©t√© consacr√©es √† la mise en ≈ìuvre du micrologiciel. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  Quand je compare les r√©sultats avec ceux qui √©taient dans le projet original, mon √¢me se r√©chauffe. <br><br>  Allez maintenant dans l'onglet <b>Source</b> et commencez √† travailler avec la partie logicielle.  Mais cela est d√©j√† trivial et ne n√©cessite aucune explication particuli√®re. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Conclusion </h2><br>  J'esp√®re que gr√¢ce √† cet exemple, les lecteurs ont appris quelque chose de nouveau et d'int√©ressant sur le travail pratique avec les blocs UDB.  J'ai essay√© de me concentrer sur une t√¢che sp√©cifique (contr√¥le LED), ainsi que sur la m√©thodologie de conception, car je devais comprendre certains aspects qui √©taient √©vidents pour les sp√©cialistes.  J'ai essay√© de les marquer pendant que les souvenirs de la qu√™te √©taient frais.  En ce qui concerne le probl√®me r√©solu, les chronogrammes pour moi se sont av√©r√©s ne pas √™tre aussi id√©aux que ceux de l'auteur du d√©veloppement original, mais ils s'int√®grent parfaitement dans les tol√©rances d√©finies dans la documentation pour les LED, et les ressources du syst√®me √©taient nettement inf√©rieures. <br><br>  En fait, ce n'est qu'une partie des informations non standard trouv√©es.  En particulier, de la plupart des mat√©riaux, il peut sembler que l'UDB ne fonctionne bien qu'avec des donn√©es s√©rie, mais ce n'est pas le cas.  Note d'application trouv√©e, qui montre bri√®vement comment vous pouvez conduire des donn√©es et en parall√®le.  Nous pourrions envisager des exemples sp√©cifiques bas√©s sur ces informations (bien qu'il soit impossible de faire de l'ombre au FX2LP, un autre contr√¥leur de Cypress: PSoC a une vitesse de bus USB inf√©rieure). <br><br>  Ma t√™te tourne des id√©es sur la fa√ßon de r√©soudre le probl√®me du ¬´flashage¬ª d'une imprimante 3D, qui me tourmente depuis longtemps.  L√†, les interruptions au service des moteurs pas √† pas ne d√©vorent qu'un pourcentage insens√© du temps CPU.  En g√©n√©ral, j'ai beaucoup parl√© des interruptions et du temps processeur dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article sur le RTOS MAX</a> .  Il est estim√© que pour l'entretien des moteurs pas √† pas, il est possible de prendre toutes les huttes temporaires compl√®tement √† l'UDB, laissant au processeur une t√¢che purement informatique sans craindre qu'il n'aura pas le temps de le faire dans un cr√©neau horaire d√©di√©. <br><br>  Mais ces choses ne peuvent √™tre motiv√©es que si le sujet est int√©ressant. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429882/">https://habr.com/ru/post/fr429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429866/index.html">Comment: termes informatiques en anglais</a></li>
<li><a href="../fr429872/index.html">G√©n√©ration d'un environnement sonore et musical dans Unity3D</a></li>
<li><a href="../fr429876/index.html">Les chercheurs ont surmont√© les bloqueurs de publicit√©s les plus puissants, la guerre des formats approche</a></li>
<li><a href="../fr429878/index.html">Pourquoi avec la croissance de l'entreprise, les d√©veloppeurs qui √©taient √† l'avant-garde sont ¬´par dessus bord¬ª</a></li>
<li><a href="../fr429880/index.html">Pix4D - des photos aux mesures</a></li>
<li><a href="../fr429884/index.html">Conf√©rence PROSTOR 2018: questions et r√©ponses sur l'avenir du stockage</a></li>
<li><a href="../fr429888/index.html">Calculatrice bas√©e sur la pile sur la carte Cyclone IV FPGA</a></li>
<li><a href="../fr429890/index.html">Webinaire ouvert "R√©seaux contradictoires g√©n√©ratifs"</a></li>
<li><a href="../fr429892/index.html">xonsh - python comme remplacement de shell</a></li>
<li><a href="../fr429894/index.html">Utilisation d'un ≈ìil de poisson sur un Raspberry Pi 3 avec ROS - Partie 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>