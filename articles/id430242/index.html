<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõéÔ∏è üîª üöØ OpenSceneGraph: Group Nodes, Transformation Nodes, dan Switch Nodes ‚úíÔ∏è üëáüèº üìö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Ketika suatu titik, garis atau poligon kompleks digambar dalam dunia tiga dimensi, hasil akhirnya pada akhirnya akan ditampilkan pada la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Group Nodes, Transformation Nodes, dan Switch Nodes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430242/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Ketika suatu titik, garis atau poligon kompleks digambar dalam dunia tiga dimensi, hasil akhirnya pada akhirnya akan ditampilkan pada layar dua dimensi yang datar.  Dengan demikian, objek tiga dimensi melalui jalur transformasi tertentu, berubah menjadi sekumpulan piksel yang ditampilkan dalam jendela dua dimensi. <br><br>  Pengembangan perangkat lunak yang menerapkan grafik tiga dimensi telah datang, terlepas dari mana yang Anda pilih, untuk kira-kira konsep yang sama dari deskripsi matematika dan algoritmik dari transformasi di atas.  Secara ideologis, API grafik "bersih" seperti OpenGL, dan mesin permainan keren seperti Unity dan Unreal, menggunakan mekanisme serupa untuk menggambarkan transformasi adegan tiga dimensi.  OpenSceneGraph tidak terkecuali. <br><br>  Pada artikel ini, kami akan meninjau mekanisme untuk mengelompokkan dan mengubah objek tiga dimensi di OSG. <br><a name="habracut"></a><br><h1>  1. Matriks model, matriks tampilan dan matriks proyeksi </h1><br>  Tiga matriks dasar yang terlibat dalam transformasi koordinat terlibat dalam transformasi antara sistem koordinat yang berbeda.  Seringkali, dalam istilah OpenGL, mereka disebut <em>matriks</em> <em>model</em> <em>, matriks tampilan,</em> dan <em>matriks proyeksi</em> . <br><br>  Matriks model digunakan untuk menggambarkan lokasi objek di dunia 3D.  Ini mengubah simpul dari <em>sistem koordinat lokal objek</em> ke <em>sistem koordinat dunia</em> .  Omong-omong, semua sistem koordinat dalam OSG tidak <em>kidal</em> . <br><br>  Langkah selanjutnya adalah transformasi koordinat dunia menjadi ruang tampilan, dilakukan dengan menggunakan matriks tampilan.  Misalkan kita memiliki kamera yang terletak di asal sistem koordinat dunia.  Matriks terbalik dengan matriks transformasi kamera sebenarnya digunakan sebagai matriks tampilan.  Dalam sistem koordinat tangan kanan, OpenGL, secara default, selalu mendefinisikan kamera yang terletak pada titik (0, 0, 0) dari sistem koordinat global dan diarahkan sepanjang arah negatif dari sumbu Z. <br><br>  Saya perhatikan bahwa dalam OpenGL model matrix dan view matrix tidak dipisahkan.  Namun, model-view matrix ditentukan di sana, yang mengubah koordinat lokal objek menjadi koordinat ruang tampilan.  Matriks ini, pada kenyataannya, adalah produk dari matriks model dan matriks bentuk.  Dengan demikian, transformasi vertex V dari koordinat lokal ke ruang bentuk dapat ditulis secara kondisional sebagai produk <br><br><pre><code class="plaintext hljs">Ve = V * modelViewMatrix</code> </pre> <br>  Tugas penting berikutnya adalah menentukan bagaimana objek 3D akan diproyeksikan ke bidang layar dan menghitung apa yang disebut <em>kliping piramida</em> - area ruang yang berisi objek yang akan ditampilkan di layar.  Matriks proyeksi digunakan untuk menentukan piramida kliping yang didefinisikan di ruang dunia oleh enam pesawat: kiri, kanan, bawah, atas, dekat dan jauh.  OpenGL menyediakan fungsi gluPerapective (), yang memungkinkan Anda untuk menentukan piramida kliping dan cara memproyeksikan dunia tiga dimensi ke pesawat. <br><br>  Sistem koordinat yang diperoleh setelah transformasi di atas disebut <em>sistem koordinat dinormalisasi perangkat</em> , memiliki rentang koordinat -1 hingga 1 pada setiap sumbu dan tidak kidal.  Dan, sebagai langkah terakhir, data yang diterima diproyeksikan ke port tampilan (viewport) dari jendela, ditentukan oleh persegi panjang area klien dari jendela.  Setelah itu, dunia 3D muncul di layar 2D kami.  Nilai akhir dari koordinat layar dari simpul Vs dapat dinyatakan dengan transformasi berikut <br><br><pre> <code class="plaintext hljs">Vs = V * modelViewMatrix * projectionMatrix * windowMatrix</code> </pre><br>  atau <br><br><pre> <code class="plaintext hljs">Vs = V * MVPW</code> </pre><br>  di mana MVPW adalah matriks transformasi yang setara dengan produk dari tiga matriks: matriks model-view, matriks proyeksi, dan matriks jendela. <br><br>  Vs dalam situasi ini adalah vektor tiga dimensi yang menentukan posisi piksel 2D dengan nilai kedalaman.  Melawan operasi transformasi koordinat, kami mendapatkan garis dalam ruang tiga dimensi.  Oleh karena itu, titik 2D dapat dianggap sebagai dua titik - satu di dekat (Zs = 0), yang lain di bidang kliping jauh (Zs = 1).  Koordinat titik-titik ini dalam ruang tiga dimensi <br><br><pre> <code class="plaintext hljs">V0 = (Xs, Ys, 0) * invMVPW V1 = (Xs, Ys, 1) * invMVPW</code> </pre><br>  di mana invMVPW adalah kebalikan dari MVPW. <br><br>  Dalam semua contoh yang dibahas sejauh ini, kami menciptakan objek tiga dimensi tunggal dalam adegan.  Dalam contoh ini, koordinat lokal objek selalu bertepatan dengan koordinat global global.  Sekarang saatnya berbicara tentang alat yang memungkinkan Anda untuk menempatkan banyak objek di tempat kejadian dan mengubah posisi mereka di ruang angkasa. <br><br><h1>  2. Node grup </h1><br>  Osg :: Grup kelas adalah yang disebut <em>simpul grup</em> dari grafik adegan di OSG.  Ia dapat memiliki sejumlah node anak, termasuk node daun geometri atau node grup lainnya.  Ini adalah node yang paling umum digunakan dengan fungsi yang luas. <br><br>  Kelas osg :: Grup berasal dari kelas osg :: Node, dan karenanya mewarisi dari kelas osg :: Referenced.  osg :: Grup berisi daftar simpul anak, di mana setiap simpul anak dikontrol oleh penunjuk pintar.  Ini memastikan bahwa tidak ada kebocoran memori ketika mengalirkan cabang pohon adegan.  Kelas ini menyediakan pengembang dengan sejumlah metode publik. <br><ol><li>  addChild () - menambahkan node ke akhir daftar node anak.  Di sisi lain, ada metode insertChild (), yang menempatkan node anak pada posisi tertentu dalam daftar, yang ditentukan oleh indeks integer atau pointer ke node, dilewatkan sebagai parameter. <br></li><li>  removeChild () dan removeChildren () - menghapus satu node atau sekelompok node. <br></li><li>  getChild () - mendapatkan pointer ke node dengan indeksnya dalam daftar <br></li><li>  getNumChildren () - mendapatkan jumlah node anak yang dilampirkan ke grup ini. <br></li></ol><br><h2>  Manajemen Simpul Induk </h2><br>  Seperti yang telah kita ketahui, kelas osg :: group mengelola grup objek anaknya, di antaranya mungkin ada contoh osg :: Geode yang mengontrol geometri objek adegan.  Kedua kelas memiliki antarmuka untuk mengelola node induk. <br><br>  OSG memungkinkan node adegan memiliki beberapa node induk (kami akan membicarakannya nanti).  Sementara itu, kita akan melihat metode yang didefinisikan dalam osg :: Node yang digunakan untuk memanipulasi node induk: <br><ol><li>  getParent () - mengembalikan pointer dari tipe osg :: Grup yang berisi daftar node induk. <br></li><li>  getNumParants () - mengembalikan jumlah node induk. <br></li><li>  getParentalNodePath () - mengembalikan semua jalur yang mungkin ke simpul akar tempat kejadian dari simpul saat ini.  Ini mengembalikan daftar variabel tipe osg :: NodePath. <br></li></ol><br>  osg :: NodePath adalah std :: vektor pointer ke adegan adegan. <br><br><img src="https://habrastorage.org/webt/hx/nb/nk/hxnbnknku1ayvk06j3ank2mug9k.png"><br><br>  Misalnya, untuk adegan yang ditunjukkan pada gambar, kode berikut <br><br><pre> <code class="cpp hljs">osg::NodePath &amp;nodePath = child3-&gt;getParentalNodePaths()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodePath.size(); ++i) { osg::Node *node = nodePath[i]; <span class="hljs-comment"><span class="hljs-comment">// -    }</span></span></code> </pre><br>  akan mengembalikan node Root, Child1, Child2. <br><br>  Anda sebaiknya tidak menggunakan mekanisme manajemen memori untuk referensi node induk.  Ketika node induk dihapus, semua node anak secara otomatis dihapus, yang dapat menyebabkan aplikasi crash. <br><br><h1>  3. Menambahkan beberapa model ke pohon adegan </h1><br>  Kami menggambarkan mekanisme untuk menggunakan grup dengan contoh berikut. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh grup lengkap</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Group&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc, (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cow.osg"); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pada dasarnya, contoh berbeda dari semua yang sebelumnya di mana kami memuat dua model tiga dimensi, dan untuk menambahkannya ke adegan kami membuat simpul akar kelompok dan menambahkan model model kami ke dalamnya sebagai simpul anak <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model1.get()); root-&gt;addChild(model2.get());</code> </pre><br><img src="https://habrastorage.org/webt/gu/yg/gx/guyggxstfydtvlfbosbe-ara3jm.png"><br><br>  Hasilnya, kami mendapatkan pemandangan yang terdiri dari dua model - pesawat terbang dan sapi cermin yang lucu.  Omong-omong, sapi cermin tidak akan menjadi cermin kecuali jika Anda menyalin teksturnya dari OpenSceneGraph-Data / Images / reflect.rgb ke direktori data / Gambar proyek kami. <br><br>  The osg :: Grup kelas dapat menerima semua jenis node sebagai anak-anak, termasuk node jenisnya.  Sebaliknya, kelas osg :: Geode tidak mengandung node anak sama sekali - ini adalah simpul terminal yang berisi geometri objek adegan.  Fakta ini nyaman ketika menanyakan apakah simpul adalah simpul dari tipe osg :: Group atau jenis turunan lain dari osg :: Node.  Mari kita lihat contoh kecil. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osg::Group *&gt;(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>));</code> </pre><br>  Nilai yang dikembalikan oleh fungsi osgDB :: readNodeFile () selalu bertipe osg :: Node *, tetapi dapat dikonversikan ke turunan osg :: turunannya *.  Jika simpul model Cessna adalah simpul grup, maka konversi akan berhasil, jika tidak, konversi akan mengembalikan NULL. <br><br>  Anda juga dapat melakukan trik yang sama yang berfungsi pada kebanyakan kompiler <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      osg::ref_ptr&lt;osg::Group&gt; group = ...; //     osg::Node* node1 = dynamic_cast&lt;osg::Node*&gt;( group.get() ); //      osg::Node* node2 = group.get();</span></span></code> </pre><br>  Di tempat-tempat kode yang kritis terhadap kinerja, lebih baik menggunakan metode konversi khusus <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"cessna.osg"</span></span>); osg::Group* convModel1 = model-&gt;asGroup(); <span class="hljs-comment"><span class="hljs-comment">//   osg::Geode* convModel2 = model-&gt;asGeode(); //  NULL.</span></span></code> </pre><br><h1>  4. Node transformasi </h1><br>  Osg :: Node grup tidak dapat membuat transformasi apa pun kecuali kemampuan untuk pergi ke node anak mereka.  OSG menyediakan osg :: Transform class untuk pergerakan geometri spasial.  Kelas ini merupakan penerus kelas osg :: Group, tetapi juga abstrak - dalam praktiknya, pewarisnya digunakan sebagai gantinya, yang mengimplementasikan berbagai transformasi spasial dari geometri.  Ketika melintasi grafik adegan, osg :: Transform node menambahkan transformasinya ke matriks transformasi OpenGL saat ini.  Ini sama dengan mengalikan matriks transformasi OpenGL dengan perintah glMultMatrix () <br><br><img src="https://habrastorage.org/webt/sj/f7/ql/sjf7qlofwivlimwfljauwnll9nw.png"><br><br>  Contoh grafik adegan ini dapat diterjemahkan ke dalam kode OpenGL berikut <br><br><pre> <code class="cpp hljs">glPushMatrix(); glMultMatrix( matrixOfTransform1 ); renderGeode1(); glPushMatrix(); glMultMatrix( matrixOfTransform2 ); renderGeode2(); glPopMatrix(); glPopMatrix();</code> </pre><br>  Kita dapat mengatakan bahwa posisi Geode1 diatur dalam sistem koordinat Transform1, dan posisi Geode2 diatur dalam sistem koordinat Transform2, diimbangi relatif terhadap Transform1.  Pada saat yang sama, posisi dalam koordinat absolut dapat diaktifkan di OSG, yang akan mengarah pada perilaku objek, setara dengan hasil perintah glGlobalMatrix () OpenGL <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::ABSOLUTE_RF );</code> </pre><br>  Anda dapat beralih kembali ke mode penentuan posisi relatif <br><br><pre> <code class="cpp hljs">transformNode-&gt;setReferenceFrame( osg::Transform::RELATIVE_RF );</code> </pre><br><h1>  5. Konsep matriks transformasi koordinat </h1><br>  Tipe osg :: Matrix adalah tipe OSG dasar yang tidak dikendalikan oleh smart pointer.  Ini menyediakan antarmuka untuk operasi pada matriks 4x4 yang menggambarkan transformasi koordinat, seperti memindahkan, memutar, menskalakan dan menghitung proyeksi.  Matriks dapat ditentukan secara eksplisit. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   44 osg::Matrix mat(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f );</span></span></code> </pre><br>  Kelas osg :: Matrix menyediakan metode publik berikut: <br><br><ol><li>  postMult () dan operator * () - perkalian yang tepat dari matriks saat ini dengan matriks atau vektor dilewatkan sebagai parameter.  Metode preMult () melakukan multiplikasi kiri. <br></li><li>  makeTranslate (), makeRotate () dan makeScale () - mengatur ulang matriks saat ini dan membuat matriks 4x4 yang menggambarkan gerakan, rotasi, dan penskalaan.  versi statisnya menerjemahkan (), memutar () dan skala () dapat digunakan untuk membuat objek matriks dengan parameter tertentu. <br></li><li>  invert () - menghitung kebalikan dari matriks saat ini.  Versi statis dari inverse () mengambil matriks sebagai parameter dan mengembalikan invers matriks baru ke yang diberikan. <br></li></ol><br>  OSG memahami matriks sebagai matriks string, dan vektor sebagai string, oleh karena itu, untuk menerapkan transformasi matriks ke vektor, lakukan ini <br><br><pre> <code class="cpp hljs">osg::Matrix mat = ‚Ä¶; osg::Vec3 vec = ‚Ä¶; osg::Vec3 resultVec = vec * mat;</code> </pre><br>  Urutan operasi matriks mudah dipahami dengan melihat bagaimana matriks dikalikan untuk mendapatkan konversi yang setara <br><br><pre> <code class="cpp hljs">osg::Matrix mat1 = osg::Matrix::scale(sx, sy, sz); osg::Matrix mat2 = osg::Matrix::translate(x, y, z); osg::Matrix resultMat = mat1 * mat2;</code> </pre><br>  Pengembang harus membaca proses transformasi dari kiri ke kanan.  Yaitu, dalam fragmen kode yang dijelaskan, vektor pertama-tama berskala, dan kemudian pergerakannya. <br><br>  osg :: Matrixf mengandung elemen tipe float. <br><br><h1>  6. Menggunakan kelas osg :: MatrixTransform </h1><br>  Kami menerapkan pengetahuan teoritis yang diperoleh dalam praktik dengan memuat dua model pesawat pada titik yang berbeda di tempat kejadian. <br><br><div class="spoiler">  <b class="spoiler_title">Teks lengkap contoh transformasi</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::translate(-25.0, 0.0, 0.0)); transform1-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = new osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(25.0, 0.0, 0.0)); transform2-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Contohnya sebenarnya cukup sepele.  Memuat model pesawat dari file <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Buat simpul transformasi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform;</code> </pre><br>  Kami mengatur model untuk memindahkan model sepanjang sumbu X 25 unit ke kiri sebagai matriks transformasi <br><br><pre> <code class="cpp hljs">transform1-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">-25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>));</code> </pre><br>  Kami menetapkan model kami untuk simpul transformasi sebagai simpul anak <br><br><pre> <code class="cpp hljs">transform1-&gt;addChild(model.get());</code> </pre><br>  Kami melakukan hal yang sama dengan transformasi kedua, tetapi sebagai matriks kami mengatur pergerakan ke kanan sebanyak 25 unit <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform2-&gt;setMatrix(osg::Matrix::translate(<span class="hljs-number"><span class="hljs-number">25.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); transform2-&gt;addChild(model.get());</code> </pre><br>  Kami membuat simpul root dan sebagai node transformasi untuk itu kami menetapkan node transformasi, transform1 dan transform2 <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(transform1.get()); root-&gt;addChild(transform2.get());</code> </pre><br>  Buat pemirsa dan kirimkan simpul root ke sana sebagai data adegan <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get());</code> </pre><br>  Menjalankan program memberikan gambaran seperti itu <br><br><img src="https://habrastorage.org/webt/tb/3q/xn/tb3qxnvgrcobwa0w7sz13k2njq8.png"><br><br>  Struktur grafik adegan dalam contoh ini adalah sebagai berikut. <br><br><img src="https://habrastorage.org/webt/pp/ig/xg/ppigxg36m3wph0idp1bwyln57tq.png"><br><br>  Kita tidak boleh bingung oleh fakta bahwa node transformasi (Anak 1.1 dan Anak 1.2) merujuk pada objek anak yang sama dari model pesawat (Anak 2).  Ini adalah mekanisme OSG biasa, ketika satu simpul anak dari grafik adegan dapat memiliki beberapa simpul induk.  Dengan demikian, kita tidak harus menyimpan dua contoh model dalam ingatan kita untuk mendapatkan dua pesawat identik di tempat kejadian.  Mekanisme ini memungkinkan Anda mengalokasikan memori dengan sangat efisien dalam aplikasi.  Model tidak akan dihapus dari memori sampai disebut sebagai anak, setidaknya satu simpul. <br><br>  Dalam aksinya, kelas osg :: MatrixTransform setara dengan perintah OpenGL glMultMatrix () dan glLoadMatrix (), mengimplementasikan semua jenis transformasi spasial, tetapi sulit digunakan karena kebutuhan untuk menghitung matriks transformasi. <br><br>  Kelas osg :: PositionAttitudeTransform berfungsi seperti fungsi OpenGL glTranslate (), glScale (), glRotate ().  Ini menyediakan metode publik untuk mengkonversi node anak: <br><br><ol><li>  setPosition () - memindahkan node ke titik tertentu dalam ruang yang ditentukan oleh parameter osg :: Vec3 <br></li><li>  setScale () - skala objek di sepanjang sumbu koordinat.  Faktor penskalaan sepanjang sumbu yang sesuai ditetapkan oleh parameter tipe osg :: Vec3 <br></li><li>  setAttitude () - mengatur orientasi spasial objek.  Sebagai parameter, osg :: angka empat transformasi rotasi digunakan, konstruktor yang memiliki beberapa kelebihan yang memungkinkan Anda untuk menentukan angka empat baik secara langsung (komponen) dan, misalnya, melalui sudut Euler osg :: Quat (xAngle, osg :: X_AXIS, yAngle, osg :: Y_AXIS, zAngle, osg :: Z_AXIS) (sudut diberikan dalam radian!) <br></li></ol><br><br><h1>  7. Beralih node </h1><br>  Pertimbangkan kelas lain - osg :: Switch, yang memungkinkan Anda untuk menampilkan atau melewati rendering dari node adegan, tergantung pada beberapa kondisi logis.  Ini adalah turunan dari kelas osg :: Group dan melampirkan beberapa nilai logis untuk masing-masing anak-anaknya.  Ini memiliki beberapa metode publik yang berguna: <br><ol><li>  AddChild (), sebagai parameter kedua, kelebihan mengambil kunci logis yang menunjukkan apakah akan menampilkan node ini atau tidak. <br></li><li>  setValue () - mengatur kunci visibilitas / tembus pandang.  Dibutuhkan indeks simpul anak yang menarik bagi kami dan nilai kunci yang diinginkan.  Dengan demikian, getValue () memungkinkan Anda untuk mendapatkan nilai kunci saat ini dengan indeks dari simpul yang menarik bagi kami. <br></li><li>  setNewChildDefaultValue () - menetapkan nilai default untuk kunci visibilitas semua objek baru yang ditambahkan sebagai anak-anak. <br></li></ol><br>  Pertimbangkan penerapan kelas ini dengan contoh. <br><br><div class="spoiler">  <b class="spoiler_title">Sakelar contoh lengkap</b> <div class="spoiler_text">  <strong>main.h</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br><br>  <strong>main.cpp</strong> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1.get(), false); root-&gt;addChild(model2.get(), true); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Contohnya sepele - kami memuat dua model: cessna konvensional dan cessna dengan efek mesin terbakar <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessnafire.osg"</span></span>);</code> </pre><br>  Namun, kami membuat osg :: Beralih sebagai simpul root, yang memungkinkan kami, ketika menambahkan model sebagai simpul anak, untuk mengatur kunci visibilitas untuk masing-masing <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Switch&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Switch; root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Yaitu, model1 tidak akan dirender, dan model2 akan, yang akan kita amati dengan menjalankan program <br><br><img src="https://habrastorage.org/webt/ne/ql/xu/neqlxu8zkqzvsusyzeoaqow8urg.png"><br><br>  Dengan menukar nilai kunci kita akan melihat gambar yang berlawanan <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/fs/ae/z4/fsaez4jingyv1u3lx9-4ihsr3zq.png"><br><br>  Memiringkan kedua tombol, kita akan melihat dua model sekaligus <br><br><pre> <code class="cpp hljs">root-&gt;addChild(model1.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); root-&gt;addChild(model2.get(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br><img src="https://habrastorage.org/webt/vl/7j/za/vl7jzamish8ype6md3lljfnqsp0.png"><br><br>  Anda dapat mengaktifkan visibilitas dan tembus pandang sebuah simpul, anak dari osg :: Switch, saat bepergian menggunakan metode setValue () <br><br><pre> <code class="cpp hljs">switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><h1>  Kesimpulan </h1><br>  Dalam tutorial ini, kami melihat semua kelas simpul menengah utama yang digunakan dalam OpenSceeneGraph.  Jadi, kami meletakkan batu bata dasar lagi di dasar pengetahuan tentang perangkat mesin grafis yang tidak diragukan lagi menarik ini.  Contoh-contoh yang dibahas dalam artikel, seperti sebelumnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di repositori saya di Github</a> . <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dilanjutkan ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430242/">https://habr.com/ru/post/id430242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430230/index.html">Bagaimana menjaga posisi Anda di startup yang sedang tumbuh</a></li>
<li><a href="../id430232/index.html">Generasi Panggilan Dekat dalam permainan: "Di ambang Kekalahan" atau "Hampir Menang"</a></li>
<li><a href="../id430236/index.html">NASA Mengumumkan Penerbangan Bulan Baru</a></li>
<li><a href="../id430238/index.html">Dsl lain di Kotlin atau bagaimana saya mencetak PDF dari bereaksi</a></li>
<li><a href="../id430240/index.html">Bitcoin Pseudo Random Number Vulnerability</a></li>
<li><a href="../id430244/index.html">SpaceX menerima izin untuk menggunakan jaringan satelit 11943 satelit</a></li>
<li><a href="../id430246/index.html">Relokasi ke Sosialisme Austria</a></li>
<li><a href="../id430252/index.html">Musuh dalam: bagaimana saya masuk ke dalam insider redding</a></li>
<li><a href="../id430256/index.html">Konfigurasi Aplikasi - Metadata Konfigurasi Pegas</a></li>
<li><a href="../id430258/index.html">Tidak ke tempat pembuangan sampah MSW - letakkan peternakan vermicinifer di bawah jendela</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>