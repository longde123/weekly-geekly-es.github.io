<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🏫 🚦 🌗 Entwicklung eines eigenen Kerns zur Einbettung in ein auf FPGA basierendes Prozessorsystem 👃🏿 🌙 ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Artikel des Zyklus wurde daher gesagt, dass es am besten ist, ein Prozessorsystem zur Steuerung unserer Geräte zu verwenden, die mithilfe vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines eigenen Kerns zur Einbettung in ein auf FPGA basierendes Prozessorsystem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454938/"><img src="https://habrastorage.org/webt/ze/eo/9f/zeeo9fw5rmqp8pk7lsmr0cytbve.jpeg"><br><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel des Zyklus</a> wurde daher gesagt, dass es am besten ist, ein Prozessorsystem zur Steuerung unserer Geräte zu verwenden, die mithilfe von FPGAs für den Redd-Komplex implementiert wurden. Anschließend wurde im ersten und zweiten Artikel gezeigt, wie dieses System hergestellt wird.  Nun, es ist geschafft, wir können sogar einige vorgefertigte Kernel aus der Liste auswählen, um sie in die Liste aufzunehmen, aber das ultimative Ziel ist es, unsere eigenen benutzerdefinierten Kernel zu verwalten.  Es ist an der Zeit zu überlegen, wie ein beliebiger Kernel in das Prozessorsystem aufgenommen werden kann. <br><a name="habracut"></a><br>  Alle Artikel des Zyklus: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs und Debugging am Beispiel des Speichertests</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode</a> <br><br>  Um die heutige Theorie zu verstehen, sollten Sie das Dokument mit den <b>Avalon-Schnittstellenspezifikationen</b> finden und herunterladen, da der <b>Avalon-</b> Bus der Basisbus für das NIOS II-System ist.  Ich werde mich bei der Überarbeitung des Dokuments vom 26. September 2018 auf Abschnitte, Tabellen und Abbildungen beziehen. <br><br>  Wir öffnen den Abschnitt 3, der Memory Mapped Interfaces gewidmet ist, oder besser - 3.2.  In Tabelle 9 sind die Bussignale aufgeführt.  Bitte beachten Sie, dass alle diese Signale optional sind.  Ich habe kein einziges Signal mit "Ja" in der Spalte "Erforderlich" gefunden.  Möglicherweise leiten wir dieses oder jenes Signal nicht an unser Gerät weiter.  Daher ist der Bus im einfachsten Fall äußerst einfach zu implementieren.  Der Anfang der Tabelle sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/qj/et/kn/qjetkngv8gubiwwtqtx8atvab7c.png"><br><br>  Wie Sie sehen können, sind alle Signale sehr gut beschrieben (außer dass dies auf Englisch erfolgt).  Unten finden Sie die Zeitdiagramme für verschiedene Fälle.  Der einfachste Fall wirft keine Fragen auf.  Ich werde jetzt das Zeitdiagramm aus dem Dokument entnehmen und einige der Zeilen mit einer durchscheinenden Füllung abdecken (sie sind alle optional, wir haben das Recht, alle Überlegungen auszuschließen). <br><br><img src="https://habrastorage.org/webt/q4/oz/w_/q4ozw_efgf6v6adbdhnkdeacply.png"><br><br>  Beängstigend  Aber alles ist einfach: Wir erhalten die Adresse und den Lesestrob, wir müssen die Daten auf dem Readdata-Bus einstellen.  Und umgekehrt: Wir erhalten die Adresse, die Daten auf dem Writedata-Bus und den Write Strobe, und wir müssen die Daten abfangen.  Es ist überhaupt nicht beängstigend, ein typischer Synchronbus. <br><br>  Verdeckte byteenable Zeilen <b>werden</b> für den Fall benötigt, dass der Speicherzugriff keine 32-Bit-Wörter umfasst.  Dies ist äußerst wichtig, wenn wir universelle Kernel entwerfen.  Aber wenn wir einen eintägigen Kern entwerfen, schreiben wir einfach in das Dokument über diesen Kern (ich bin ein Gegner der Marke in meinem Kopf, aber jemand kann es darauf beschränken), dass wir 32-Bit-Wörter verwenden müssen und das war's.  Nun, und das <b>Antwortsignal</b> ist sehr speziell und interessiert uns im Prinzip nicht. <br><br>  Manchmal ist es wichtig, dass der Betrieb des Busses um mehrere Taktzyklen verzögert werden kann, wenn das Gerät nicht bereit ist.  In diesem Fall sollte das <b>WaitRequest-</b> Signal hinzugefügt werden.  Das Zeitdiagramm ändert sich wie folgt: <br><br><img src="https://habrastorage.org/webt/sy/hr/lf/syhrlf64dvm-zrr262xvveicea4.png"><br><br>  Während <b>WaitRequest</b> gespannt ist, weiß der Assistent, dass unser Gerät ausgelastet ist.  Seien Sie vorsichtig, wenn dieses Signal nicht zurückgesetzt wird. Das gesamte System friert bei der Handhabung ein, sodass es nur durch einen Neustart des FPGA zurückgesetzt werden kann.  JTAG hängt mit dem System.  Das letzte Mal, dass ich dieses Phänomen beobachtete, war in der Vorbereitung dieses Artikels, daher sind die Erinnerungen immer noch lebendig. <br><br>  Weiter im Unternehmensdokument werden produktivere Fälle von Daten-Pipelining und Batch-Transaktionen betrachtet, aber die Aufgabe des Artikels besteht nicht darin, alle möglichen Optionen zu berücksichtigen, sondern dem Leser die Arbeitsweise zu zeigen und zu betonen, dass dies alles überhaupt nicht beängstigend ist. Deshalb beschränken wir uns auf diese beiden einfachen Optionen. <br><br>  Lassen Sie uns ein einfaches Gerät entwerfen, das in regelmäßigen Abständen im Bus nicht mehr verfügbar ist.  Das erste, was mir in den Sinn kommt, ist die serielle Schnittstelle.  Während der Übertragung wird das System warten.  Und im Leben rate ich dringend davon ab: Der Prozessor stoppt bis zum Ende einer geschäftigen Transaktion, aber dies ist ein idealer Fall für einen Artikel, da der Implementierungscode verständlich und nicht sehr umständlich ist.  Im Allgemeinen werden wir einen seriellen Sender herstellen, der Daten und Chipauswahlsignale an zwei Geräte senden kann. <br><br><img src="https://habrastorage.org/webt/fr/uj/_u/fruj_ufw0phhzgbovupezinxo6c.png"><br><br>  Beginnen wir mit der einfachsten Reifenoption.  Machen wir einen parallelen Ausgangsport, der die Signale der Wahl der Kristalle bildet. <br><br><img src="https://habrastorage.org/webt/rc/z6/yg/rcz6ygig6s3yz-bxsjwsbonygp4.png"><br><br>  Dazu werde ich das im vorherigen Artikel erhaltene Projekt übernehmen, aber um Verwirrung zu vermeiden, werde ich es in das Verzeichnis AVALON_DEMO stellen.  Ich werde die Namen anderer Dateien nicht ändern.  Erstellen <b>Sie</b> in diesem Verzeichnis das Verzeichnis <b>my_cores</b> .  Der Verzeichnisname kann beliebig sein.  Wir werden unsere Kerne darin aufbewahren.  Es stimmt, heute wird es einer sein.  Erstellen Sie eine <b>CrazySerial.sv-</b> Datei mit den folgenden Inhalten: <br><pre><code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output reg [1:0] cs ); always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; end else begin if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; default:; endcase end end endmodule</code> </pre> <br>  Lass es uns richtig machen.  Zunächst Schnittstellenleitungen.  <b>clk</b> und <b>reset</b> sind die Takt- und Rücksetzleitungen.  Die Namen der <b>Adressen</b> , <b>Schreib-</b> und <b>Schreibdatenzeilen</b> werden aus der Tabelle mit der Liste der Signale des Dokuments <b>Memory Mapped Interfaces</b> entnommen. <br><br><img src="https://habrastorage.org/webt/lz/q9/rv/lzq9rvmj8mekwwiqqene5mvbu7i.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/a-/pexza-dsswt01-shzs4sy0pkjay.png"><br><br>  Tatsächlich könnte ich beliebige Namen nennen.  Das Verknüpfen logischer mit physischen Zeilen erfolgt später.  Wenn Sie jedoch die Namen wie in der Tabelle angeben, werden sie von der Entwicklungsumgebung selbst verbunden.  Daher ist es besser, die Namen aus der Tabelle zu übernehmen. <br><br>  Nun, <b>cs</b> sind die Kristallauswahllinien, die aus dem Chip kommen. <br><br>  Die Implementierung selbst ist trivial.  Beim Zurücksetzen werden die Ausgänge auf Null gesetzt.  Und so prüfen wir bei jeder Messung, ob ein <b>Schreibsignal</b> vorliegt.  Wenn eine Adresse gleich Null ist, klicken Sie auf die Daten.  Natürlich wäre es möglich, hier einen Decoder hinzuzufügen, der die Auswahl von zwei Geräten gleichzeitig verhindert, aber was im Leben gut ist, wird den Artikel überlasten.  Der Artikel enthält nur die notwendigsten Schritte, es wird jedoch darauf hingewiesen, dass im Leben alles komplizierter gemacht werden kann. <br><br>  Großartig.  Wir sind bereit, diesen Code in das Prozessorsystem einzuführen.  Wir gehen zu <b>Platform Designer</b> und wählen als Eingabedatei das System aus, das wir in früheren Experimenten erstellt haben: <br><br><img src="https://habrastorage.org/webt/vd/a3/mp/vda3mpnhkbmfl9gj037h7kyefs8.png"><br><br>  Wir machen auf das Element <b>Neue Komponente</b> in der oberen linken Ecke aufmerksam: <br><br><img src="https://habrastorage.org/webt/iz/xq/hw/izxqhw8wg6jshahucg0ardu7ukg.png"><br><br>  Klicken Sie auf dieses Element, um Ihre Komponente hinzuzufügen.  Füllen Sie im folgenden Dialogfeld die Felder aus.  Geben Sie für den Artikel nur den Komponentennamen ein: <br><br><img src="https://habrastorage.org/webt/nn/l8/mt/nnl8mtcsdxmqyp6cjnkrcr-qlc0.png"><br><br>  Gehen Sie nun zur Registerkarte <b>Dateien</b> und klicken <b>Sie auf Datei hinzufügen</b> : <br><br><img src="https://habrastorage.org/webt/fo/rw/jx/forwjxin05orcsaaw7uuuiw1mra.png"><br><br>  Fügen Sie die zuvor erstellte Datei hinzu, wählen Sie sie in der Liste aus und klicken Sie auf <b>Synthesedatei analysieren</b> : <br><br><img src="https://habrastorage.org/webt/a_/-i/g0/a_-ig0-b-v--safmwwco-gcblvi.png"><br><br>  Es gibt keine Fehler beim Parsen von <b>SystemVerilog</b> , aber es gibt mehrere konzeptionelle Fehler.  Sie werden durch die Tatsache verursacht, dass einige Leitungen von der Entwicklungsumgebung falsch verbunden wurden.  Wir gehen zur Registerkarte <b>Signale &amp; Schnittstellen</b> und achten hier: <br><br><img src="https://habrastorage.org/webt/be/7s/nb/be7snb0yjnqj8qn-ku_dboeirjs.png"><br><br>  Die <b>cs-</b> Zeilen wurden der Schnittstelle <b>avalon_slave0</b> , dem <b>Readdata-</b> Signal, falsch zugewiesen.  Aber dann wurden alle anderen Zeilen korrekt erkannt, da wir ihnen Namen aus der Dokumententabelle gegeben haben.  Aber was tun mit Problemlinien?  Sie sollten einer Schnittstelle wie einem <b>Conduit</b> zugewiesen werden.  Klicken Sie dazu auf den Punkt „Schnittstelle hinzufügen“. <br><br><img src="https://habrastorage.org/webt/ur/ce/je/urcejebzbrayxcoyvs16vorleik.png"><br><br>  Wählen Sie im Dropdown-Menü die Option <b>Leitung</b> : <br><br><img src="https://habrastorage.org/webt/2-/l-/45/2-l-45h1b_8jnat3uazcscgcpt0.png"><br><br>  Wir bekommen eine neue Schnittstelle: <br><br><img src="https://habrastorage.org/webt/g_/r4/j0/g_r4j0acbfvawp7plewjmsolw1e.png"><br><br>  Falls gewünscht, kann es umbenannt werden.  Dies wird sicherlich notwendig sein, wenn wir mehrere externe Schnittstellen erstellen möchten.  Als Teil des Artikels <b>belassen</b> wir den Namen <b>Conduit_end</b> .  Jetzt haken wir die <b>cs-</b> Linie mit der Maus ein und ziehen sie in diese Oberfläche.  Wir müssen es schaffen, ein Signal unter die Zeile <b>Conduit_end</b> zu werfen, dann dürfen wir dies tun.  An anderen Stellen wird der Cursor als durchgestrichener Kreis angezeigt.  Am Ende sollten wir Folgendes haben: <br><br><img src="https://habrastorage.org/webt/gb/2e/lw/gb2elw6dvx2iw11y28uq0qlye5q.png"><br><br>  Ersetzen Sie den Signaltyp durch <b>Lesedaten</b> , <b>z</b> . B. durch <b>Chipselect</b> .  Endgültiges Bild: <br><br><img src="https://habrastorage.org/webt/6o/ur/gq/6ourgq054tn85rth2nixk33_pvs.png"><br><br>  Aber die Fehler blieben.  Dem <b>Avalon-Bus wird</b> kein Rücksetzsignal zugewiesen.  Wir wählen <b>avalon_slave_0</b> aus der Liste aus und sehen uns seine Eigenschaften an. <br><br><img src="https://habrastorage.org/webt/s6/0i/--/s60i--4ijigk6exutkovd5zlwi0.png"><br><br>  Ersetzen Sie <b>keine</b> durch <b>Zurücksetzen</b> .  Gleichzeitig werden wir andere Schnittstelleneigenschaften untersuchen. <br><br><img src="https://habrastorage.org/webt/xn/4d/kf/xn4dkf5jpxsi-6ujubxeuptddo4.png"><br><br>  Es ist ersichtlich, dass die Adressierung in Worten erfolgt.  Nun, eine Reihe anderer Dinge aus der Dokumentation sind hier konfiguriert.  Welche Zeitdiagramme in diesem Fall erhalten werden, wird ganz unten in den Eigenschaften gezeichnet: <br><br><img src="https://habrastorage.org/webt/xc/nw/xq/xcnwxqjxkz7y4qgxtcmn6ulb5eu.png"><br><br>  Eigentlich gibt es keine Fehler mehr.  Sie können auf <b>Fertig stellen</b> klicken.  Unser erstelltes Modul wurde im Gerätebaum angezeigt: <br><br><img src="https://habrastorage.org/webt/rt/qe/bz/rtqebza22wictmnw0cpgvw_uu3g.png"><br><br>  Fügen Sie es dem Prozessorsystem hinzu, verbinden Sie Taktsignale und setzen Sie es zurück.  Wir verbinden den Datenbus mit dem <b>Data Master-</b> Prozessor.  Doppelklicken Sie auf <b>Conduit_end</b> und geben Sie dem externen Signal einen Namen, z. B. <b>Zeilen</b> .  Es stellt sich irgendwie so heraus: <br><br><img src="https://habrastorage.org/webt/ob/mm/al/obmmalo6x1jytho2mzkvy4emdbu.png"><br><br>  Es ist wichtig, nicht zu vergessen, dass wir, da wir dem System einen Block hinzugefügt haben, sicherstellen müssen, dass er mit niemandem im Adressraum in Konflikt steht.  In diesem speziellen Fall gibt es keine Konflikte in der Abbildung, aber ich werde trotzdem den Menüpunkt <b>System-&gt; Basisadressen zuweisen</b> auswählen. <br><br>  Das ist alles.  Der Block wird erstellt, konfiguriert und dem System hinzugefügt.  Klicken Sie auf die Schaltfläche <b>HDL generieren</b> und dann auf <b>Fertig stellen</b> . <br><br>  Wir machen einen groben Entwurf des Projekts, danach gehen wir zum <b>Pin-Planer</b> und weisen die Beine zu.  Es stellte sich so heraus: <br><br><img src="https://habrastorage.org/webt/mn/fs/39/mnfs39ezihwpwese2tsdto4ialc.png"><br><br>  Dies entspricht den Kontakten B22 und C22 des Schnittstellensteckers. <br><br>  Wir machen die Endmontage, laden das Prozessorsystem in das FPGA.  Jetzt müssen wir den Programmcode verfeinern.  Starten Sie Eclipse. <br><br>  Ich möchte Sie daran erinnern, dass ich derzeit mit einem Projekt arbeite, das sich in einem anderen Verzeichnis befindet als meine letzte Arbeit mit Redd.  Um nicht verwirrt zu werden, werde ich alte Projekte aus dem Baum löschen (aber nur aus dem Baum, ohne die Dateien selbst zu löschen). <br><br><img src="https://habrastorage.org/webt/xm/jv/ch/xmjvchikm8_ukin_evoqdw28op8.png"><br><br>  Als nächstes klicke ich mit der rechten Maustaste auf einen leeren Baum und wähle <b>Importieren</b> aus dem Menü: <br><br><img src="https://habrastorage.org/webt/yp/kt/sf/ypktsfboxaxgfhqcubjnlwogoxq.png"><br><br>  Weiter - <b>Allgemein-&gt; Vorhandenes Projekt in Arbeitsbereich</b> : <br><br><img src="https://habrastorage.org/webt/rb/dw/me/rbdwmebel6yu6hjmvyxn7hik0q8.png"><br><br>  Und wählen Sie einfach das Verzeichnis aus, in dem die Projektdateien gespeichert sind: <br><br><img src="https://habrastorage.org/webt/nd/3t/6h/nd3t6hwmddm9pfrwr4cjd4iw4hy.png"><br><br><img src="https://habrastorage.org/webt/ei/qg/de/eiqgdehf_klzhkyyleod_opnlgq.png"><br><br>  Beide Projekte, die aus früheren Experimenten stammen, werden mit der Entwicklungsumgebung verbunden. <br><br><img src="https://habrastorage.org/webt/qq/vw/jk/qqvwjkfgoli7vu3wedt3qhbnsf0.png"><br><br>  Ich werde den nächsten Punkt in einem Rahmen hervorheben: <br><blockquote>  Wählen Sie jedes Mal nach dem Ändern der Hardwarekonfiguration den Menüpunkt <b>Nios II -&gt; BSP generieren</b> für das BSP-Projekt erneut aus. </blockquote><br><br><img src="https://habrastorage.org/webt/ks/jn/mt/ksjnmtcdfbf2p0vej4qeeltlkxk.png"><br><br>  Nach diesem Vorgang wurde tatsächlich ein neuer Block in der <b>Datei \ AVALON_DEMO \ software \ SDRAMtest_bsp \ system.h angezeigt</b> : <br><pre> <code class="plaintext hljs">/* * CrazySerial_0 configuration * */ #define ALT_MODULE_CLASS_CrazySerial_0 CrazySerial #define CRAZYSERIAL_0_BASE 0x4011020 #define CRAZYSERIAL_0_IRQ -1 #define CRAZYSERIAL_0_IRQ_INTERRUPT_CONTROLLER_ID -1 #define CRAZYSERIAL_0_NAME "/dev/CrazySerial_0" #define CRAZYSERIAL_0_SPAN 16 #define CRAZYSERIAL_0_TYPE "CrazySerial"</code> </pre><br>  Zunächst interessiert uns die Konstante <b>CRAZYSERIAL_0_BASE</b> . <br><br>  Fügen Sie der <b>main () -</b> Funktion den folgenden Code hinzu: <br><pre> <code class="plaintext hljs"> while (true) { IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x03); }</code> </pre><br>  Wir beginnen mit dem Debuggen und betrachten den Inhalt der Zeilen mit einem Oszilloskop.  Es muss inkrementeller Binärcode vorhanden sein.  Er ist da. <br><br><img src="https://habrastorage.org/webt/fm/xp/0z/fmxp0z5mactvzv-vdv2cahbvj1i.png"><br><br>  Darüber hinaus ist die Häufigkeit des Zugangs zu den Häfen einfach wunderbar: <br><br><img src="https://habrastorage.org/webt/cm/rd/of/cmrdofrh6yzmo2xwdkjynz6gwwm.png"><br><br>  Ungefähr 25 MHz sind die Hälfte der Busfrequenz (2 Taktzyklen).  Manchmal beträgt die Zugriffszeit nicht 2 Zyklen, sondern länger.  Dies ist auf die Ausführung von Verzweigungsoperationen im Programm zurückzuführen.  Im Allgemeinen funktioniert der einfachste Zugang zum Bus. <br><br>  Es ist Zeit, zum Beispiel die Funktionalität der seriellen Schnittstelle hinzuzufügen.  <b>Fügen Sie</b> dazu das auf den Bus bezogene <b>Waitrequest-</b> Schnittstellensignal und ein Paar serieller Port-Signale hinzu - <b>sck</b> und <b>sdo</b> .  Insgesamt erhalten wir das folgende Codefragment auf <b>systemverilog</b> : <br><br><img src="https://habrastorage.org/webt/dy/wc/vt/dywcvtwz6_h4ccubotauamcnnju.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo );</code> </pre><br></div></div><br>  Nach den Regeln der guten Form müssen Sie eine einfache Maschine herstellen, die Daten überträgt.  Leider wird die unkomplizierteste Maschine im Artikel sehr schwierig aussehen.  Wenn ich jedoch die Funktionalität der Maschine nicht erhöhe (und als Teil des Artikels werde ich dies nicht tun), hat sie nur zwei Zustände: Die Übertragung wird ausgeführt und die Übertragung wird nicht ausgeführt.  Daher kann ich den Zustand mit einem einzigen Signal codieren: <br>  reg send = 0; <br><br>  Während der Übertragung benötige ich einen Bitzähler, einen Taktteiler (ich mache ein absichtlich langsames Gerät) und ein Schieberegister für die übertragenen Daten.  Fügen Sie die entsprechenden Register hinzu: <br><pre> <code class="plaintext hljs"> reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0;</code> </pre><br>  Ich werde die Frequenz durch 10 teilen (geleitet vom Prinzip "Warum nicht?").  Dementsprechend werde ich im fünften Schritt SCK spannen und im zehnten - diese Zeile fallen lassen, danach - zum nächsten Datenbit gehen.  Erhöhen Sie bei allen anderen Maßnahmen einfach den Teilerzähler.  Es ist wichtig, nicht zu vergessen, dass Sie beim vierten Takt auch den Zähler erhöhen müssen und beim neunten - Null.  Wenn wir den Übergang zum nächsten Bit weglassen, sieht die angegebene Logik folgendermaßen aus: <br><pre> <code class="plaintext hljs"> if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin sck &lt;= 0; clk_div &lt;= 0; // &lt;   &gt; end default: clk_div &lt;= clk_div + 1; endcase end else</code> </pre><br>  Zum nächsten Stück zu gehen ist einfach.  Sie haben das Schieberegister verschoben, und wenn das aktuelle Bit das siebte ist, haben sie aufgehört zu arbeiten, indem sie den Zustand der Maschine geändert haben, andernfalls haben sie den Bitzähler erhöht. <br><pre> <code class="plaintext hljs"> shifter &lt;= {shifter[6:0],1'b0}; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end</code> </pre><br>  Eigentlich ist das alles.  Das Ausgangsbit wird immer aus dem hohen Bit des Schieberegisters entnommen: <br><pre> <code class="plaintext hljs"> assign sdo = shifter [7];</code> </pre><br>  Und die wichtigste Zeile für die aktuelle Revision.  Das <b>Warteanforderungssignal wird</b> immer dann auf Eins gespannt, wenn serielle Daten übertragen werden.  Das heißt, es ist eine Kopie des Sendesignals, die den Status der Maschine festlegt: <br><pre> <code class="plaintext hljs"> assign waitrequest = sending;</code> </pre><br>  Nun, und wenn wir an Adresse 1 schreiben (ich erinnere mich, hier haben wir die Adressierung in 32-Bit-Wörtern), fangen wir die Daten in das Schieberegister ein, setzen die Zähler auf Null und starten den Übertragungsprozess: <br><pre> <code class="plaintext hljs"> if (write) //... 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Jetzt werde ich alle Fragmente als einen einzigen Text beschreiben:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo ); reg sending = 0; reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0; always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; sck &lt;= 0; sending &lt;= 0; end else begin if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin clk_div &lt;= 0; shifter &lt;= {shifter[6:0],1'b0}; sck &lt;= 0; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end end default: clk_div &lt;= clk_div + 1; endcase end else if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end end assign sdo = shifter [7]; assign waitrequest = sending; endmodule</code> </pre><br></div></div><br>  Wir beginnen, neuen Code in das System einzuführen.  Eigentlich ist der Pfad der gleiche wie beim Erstellen der Komponente, aber einige der Schritte können bereits weggelassen werden.  Jetzt werden wir uns nur noch mit dem Verfeinerungsprozess vertraut machen.  Gehen Sie zu <b>Platform Designer</b> .  Wenn wir nur den Verilog-Code ändern würden, wäre es recht einfach, die Operation <b>HDL generieren</b> für das fertige System auszuführen.  Da das Modul jedoch neue Zeilen hat (dh die Schnittstelle hat sich geändert), muss es erneuert werden.  Wählen Sie dazu im Baum aus, drücken Sie die rechte Maustaste und wählen Sie <b>Bearbeiten</b> . <br><br><img src="https://habrastorage.org/webt/sg/el/hx/sgelhxlzgzwjz81z6q7xhkhbxzs.png"><br><br>  Wir bearbeiten ein bestehendes System.  Gehen Sie einfach zur Registerkarte " <b>Dateien"</b> und klicken Sie auf " <b>Sinthesis-Dateien analysieren"</b> : <br><br><img src="https://habrastorage.org/webt/qy/nw/0q/qynw0q5tul7k26yaygdyzsigouu.png"><br><br>  Vorhersehbar sind Fehler aufgetreten.  Aber wir wissen bereits, dass die falschen Zeilen schuld sind.  Daher gehen wir zur Registerkarte <b>Signale &amp; Schnittstellen</b> und ziehen <b>sck</b> und <b>sdo</b> entlang derselben Linie von der Schnittstelle <b>avalon_slave_0 zur</b> Schnittstelle <b>Conduit_end</b> : <br><br><img src="https://habrastorage.org/webt/z_/rz/jj/z_rzjjaaiaqzey6gczf6ptt0vfa.png"><br><br>  Benennen Sie auch die Felder für den <b>Signaltyp</b> für sie um.  Das Ergebnis sollte wie folgt sein: <br><br><img src="https://habrastorage.org/webt/ng/3_/t_/ng3_t_kiebqf_jw3wwljh0aqsig.png"><br><br>  Eigentlich ist das alles.  Klicken Sie auf <b>Fertig stellen</b> , rufen <b>Sie HDL-Datei</b> für das Prozessorsystem <b>generieren</b> auf, entwerfen Sie das Projekt in Quartus und weisen Sie neue Abschnitte zu: <br><br><img src="https://habrastorage.org/webt/ul/hg/rh/ulhgrhytzp1y9149j8x11apyvcy.png"><br><br>  Dies sind die Kontakte A21 und A22 des Schnittstellenanschlusses, wir machen die Endmontage, füllen die "Firmware" im FPGA aus. <br><br>  Eisen aktualisiert.  Nun das Programm.  Lass uns zu Eclipse gehen.  Woran erinnern wir uns dort zu tun?  Vergessen Sie nicht, <b>BSP generieren</b> zu wählen. <br><br>  Eigentlich ist das alles.  Es bleibt noch, dem Programm Funktionen hinzuzufügen.  Lassen Sie uns ein Paar Bytes an die serielle Schnittstelle übertragen, aber wir senden das erste Byte an das Gerät, das durch die Zeile <b>cs [0]</b> und das zweite Byte - <b>cs [1] ausgewählt wurde</b> . <br><pre> <code class="plaintext hljs"> IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x12); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x34); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00);</code> </pre><br>  Bitte beachten Sie, dass dort keine Verfügbarkeitsprüfungen stattfinden.  Pakete gehen nacheinander.  Trotzdem stellte sich auf dem Oszilloskop alles als ziemlich konsequent heraus <br><br><img src="https://habrastorage.org/webt/vh/qm/ig/vhqmigcblrnmmcizbs11jwdgsig.png"><br><br>  Der gelbe Strahl ist <b>cs [0]</b> , der grüne <b>Strahl</b> ist <b>sdo</b> , der violette <b>Strahl</b> ist <b>sck</b> und der blaue <b>Strahl</b> ist <b>cs [1]</b> .  Es ist ersichtlich, dass der 0x12-Code an das erste Gerät ging, 0x34 an das zweite. <br><br>  Das Lesen erfolgt ähnlich, aber ich kann mir kein schönes Beispiel einfallen lassen, außer dem banalen Lesen des Inhalts des Anschlussfußes.  Aber dieses Beispiel ist so entartet, dass es nicht einmal interessant ist, es zu tun.  Hier ist jedoch zu beachten, dass beim Lesen dieser Buseinstellung äußerst wichtig sein kann: <br><br><img src="https://habrastorage.org/webt/m4/7g/i6/m47gi6xbkat-jct5iuuffqmyya8.png"><br><br>  Wenn eine <b>Lesezeile vorhanden</b> ist, wird im Einstellungsdialog ein Lesezeitdiagramm angezeigt.  Und es wird den Einfluss dieses Parameters zeigen.  Wenn Sie die Beine des Anschlusses lesen, fällt dies immer noch nicht auf, aber wenn Sie aus demselben FIFO oder RAM lesen - vollständig.  Der Arbeitsspeicher kann so konfiguriert werden, dass Daten unmittelbar nach der Übermittlung der Adresse ausgegeben werden, oder er kann synchron ausgegeben werden.  Im zweiten Fall wird die Latenz hinzugefügt.  Immerhin hat der Bus die Adresse eingestellt, den Blitz eingestellt ... Aber es gibt keine Daten zur nächsten Flanke des Taktsignals.  Sie werden nach dieser Front angezeigt ... Das heißt, das System hat eine Latenz von einer Latenz.  Und es muss nur durch Einstellen dieses Parameters berücksichtigt werden.  Kurz gesagt, wenn Sie nicht lesen, was erwartet wurde, prüfen Sie zunächst, ob Sie die Latenz konfigurieren müssen.  Das restliche Lesen unterscheidet sich nicht vom Schreiben. <br><br>  Nun, ich möchte Sie noch einmal daran erinnern, dass es besser ist, die Busbereitschaft für den Langzeitbetrieb nicht zu entfernen, da es sonst durchaus möglich ist, die Systemleistung drastisch zu reduzieren.  Das Bereitschaftssignal ist gut, um die Transaktion für ein paar Taktzyklen zu halten, und nicht für bis zu 80 Taktzyklen, wie in meinem Beispiel.  Aber erstens wäre jedes andere Beispiel für den Artikel unpraktisch, und zweitens ist dies für eintägige Kernel durchaus akzeptabel.  Sie sind sich Ihrer Handlungen voll bewusst und vermeiden Situationen, in denen der Bus blockiert ist.  Wenn der Kern die ihm zugewiesene Zeit überlebt, kann eine solche Annahme das Leben in der Zukunft verderben, wenn jeder sie vergisst und alles verlangsamt.  Aber es wird später sein. <br><br>  Trotzdem haben wir gelernt, dass der Prozessorkern unsere Kerne steuert.  Mit der adressierbaren Welt ist alles klar, jetzt ist es Zeit, sich mit der Streaming-Welt zu befassen.  Aber wir werden dies im nächsten Artikel und möglicherweise sogar in mehreren Artikeln tun. <br><br><h3>  Fazit </h3><br>  Der Artikel zeigt, wie ein beliebiger Verilog-Kernel zur Steuerung des Nios II-Prozessorsystems angeschlossen werden kann.  Die Optionen für die einfachste Verbindung zum Avalon-Bus sowie die Verbindung, in der sich der Bus in einem besetzten Zustand befinden kann, werden angezeigt.  Es werden Links zu Literatur gegeben, aus der andere Avalon-Bus-Betriebsmodi im Memory Mapped-Modus zu finden sind. <br><br>  Das resultierende Projekt kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454938/">https://habr.com/ru/post/de454938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454924/index.html">Authentifizierungseinstellungen in Veeam Backup für Microsoft Office 365 v3</a></li>
<li><a href="../de454926/index.html">Alles, was Sie über word2vec wussten, ist nicht wahr</a></li>
<li><a href="../de454928/index.html">Möglichkeit, den Windows-Sperrbildschirm in RDP-Sitzungen zu umgehen</a></li>
<li><a href="../de454932/index.html">Investitionen und Software: 5 Handelsterminals für den Handel an der Börse</a></li>
<li><a href="../de454936/index.html">Vivaldi: Das Blockieren von Anzeigen sollte die Wahl des Nutzers sein</a></li>
<li><a href="../de454940/index.html">Reisekrankenversicherung: detaillierte Anweisungen</a></li>
<li><a href="../de454944/index.html">So funktioniert das JPEG-Format</a></li>
<li><a href="../de454946/index.html">Globale Staaten: warum und wie man sie vermeidet</a></li>
<li><a href="../de454958/index.html">Ein Einblick: Graduiertenschule an der EPFL. Teil 4.1: Alltag</a></li>
<li><a href="../de454960/index.html">Microbiota. Wie Medikamente Darmbakterien beeinflussen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>