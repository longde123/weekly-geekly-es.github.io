<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🥃 🧙 Python-Buggy-Code: 10 häufigste Fehler, die Entwickler machen 🔜 🧑🏾‍🤝‍🧑🏻 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Über Python 
 Python ist eine interpretierte, objektorientierte Programmiersprache auf hoher Ebene mit dynamischer Semantik. Integrierte Datenstruktur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Buggy-Code: 10 häufigste Fehler, die Entwickler machen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  Über Python </h3><br>  Python ist eine interpretierte, objektorientierte Programmiersprache auf hoher Ebene mit dynamischer Semantik.  Integrierte Datenstrukturen auf hoher Ebene in Kombination mit dynamischer Typisierung und dynamischer Bindung machen es für BRPS (schnelle Entwicklung von Anwendungstools) sowie für die Verwendung als Skript- und Verbindungssprache zum Verbinden vorhandener Komponenten oder Dienste sehr attraktiv.  Python unterstützt Module und Pakete und fördert so die Programmmodularität und die Wiederverwendung von Code. <br><br><h3>  Über diesen Artikel </h3><br>  Die Einfachheit und Leichtigkeit, diese Sprache zu beherrschen, kann für Entwickler verwirrend sein (insbesondere für diejenigen, die gerade erst anfangen, Python zu lernen), sodass Sie einige wichtige Feinheiten aus den Augen verlieren und die Leistungsfähigkeit der Vielzahl möglicher Lösungen mit Python unterschätzen können. <br><br>  In diesem Sinne werden in diesem Artikel die „Top 10“ subtiler, schwer zu findender Fehler vorgestellt, die selbst fortgeschrittene Python-Entwickler machen können. <br><a name="habracut"></a><br>
<h3>  Fehler Nr. 1: Missbrauch von Ausdrücken als Standardwerte für Funktionsargumente </h3><br>  Mit Python können Sie angeben, dass eine Funktion optionale Argumente haben kann, indem Sie einen Standardwert für diese festlegen.  Dies ist natürlich ein sehr praktisches Merkmal der Sprache, kann jedoch zu unangenehmen Konsequenzen führen, wenn der Typ dieses Werts veränderlich ist.  Betrachten Sie beispielsweise die folgende Funktionsdefinition: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Ein häufiger Fehler in diesem Fall ist die Annahme, dass der Wert eines optionalen Arguments bei jedem Aufruf einer Funktion ohne Wert für dieses Argument auf den Standardwert gesetzt wird.  Im obigen Code können wir beispielsweise davon ausgehen, dass durch wiederholtes Aufrufen der Funktion foo () (dh ohne Angabe eines Werts für das Balkenargument) immer "baz" zurückgegeben wird, da davon ausgegangen wird, dass jedes Mal, wenn foo () aufgerufen wird (ohne) unter Angabe der Argumentleiste) wird die Leiste auf [] gesetzt (d. h. eine neue leere Liste). <br><br>  Aber mal sehen, was tatsächlich passieren wird: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Huh?  Warum fügt die Funktion der vorhandenen Liste bei jedem Aufruf von foo () weiterhin den Standardwert "baz" hinzu, anstatt jedes Mal eine neue Liste zu erstellen? <br><br>  Die Antwort auf diese Frage wird ein tieferes Verständnis dafür sein, was mit Python „unter der Haube“ vor sich geht.  Nämlich: Der Standardwert für die Funktion wird während der Definition der Funktion nur einmal initialisiert.  Daher wird das Balkenargument standardmäßig nur dann initialisiert (d. H. Eine leere Liste), wenn foo () zum ersten Mal definiert wird, aber nachfolgende Aufrufe von foo () (d. H. Ohne Angabe des Balkenarguments) verwenden weiterhin dieselbe Liste wie zuvor Erstellt für die Argumentleiste zum Zeitpunkt der ersten Funktionsdefinition. <br><br>  Als Referenz ist die folgende Definition eine häufige „Problemumgehung“ für diesen Fehler: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Fehler Nr. 2: Missbrauch von Klassenvariablen </h3><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Alles scheint in Ordnung zu sein. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ja, alles war wie erwartet. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Was zur Hölle ?!  Wir haben gerade Axe geändert. Warum hat sich Cx auch geändert? <br><br>  In Python werden Klassenvariablen wie Wörterbücher behandelt und folgen der sogenannten Method Resolution Order (MRO).  Da das Attribut x im obigen Code nicht in Klasse C gefunden wird, wird es daher in seinen Basisklassen gefunden (im obigen Beispiel nur A, obwohl Python Mehrfachvererbung unterstützt).  Mit anderen Worten, C hat keine eigene Eigenschaft x unabhängig von A. Somit sind Verweise auf Cx tatsächlich Verweise auf Ax. Dies führt zu Problemen, wenn diese Fälle nicht richtig behandelt werden.  Achten Sie beim Erlernen von Python besonders auf Klassenattribute und arbeiten Sie mit ihnen. <br><br><h3>  Fehler Nr. 3: Falsche Parameter für den Ausnahmeblock </h3><br>  Angenommen, Sie haben den folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Das Problem hierbei ist, dass der Ausnahmeausdruck die auf diese Weise angegebene Liste von Ausnahmen nicht akzeptiert.  Vielmehr wird in Python 2.x der Ausdruck "außer Ausnahme, e" verwendet, um die Ausnahme an einen optionalen zweiten gegebenen zweiten Parameter (in diesem Fall e) zu binden, um sie für die weitere Überprüfung verfügbar zu machen.  Infolgedessen wird im obigen Code eine IndexError-Ausnahme nicht von der Ausnahme-Anweisung abgefangen.  Stattdessen endet die Ausnahme mit der Bindung an einen Parameter namens IndexError. <br><br>  Der richtige Weg, um mehrere Ausnahmen mit dem Ausnahmeausdruck abzufangen, besteht darin, den ersten Parameter als Tupel anzugeben, das alle Ausnahmen enthält, die Sie abfangen möchten.  Verwenden Sie für maximale Kompatibilität auch das Schlüsselwort as, da diese Syntax sowohl in Python 2 als auch in Python 3 unterstützt wird: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Fehler Nr. 4: Missverständnis der Python-Bereichsregeln </h3><br>  Der Gültigkeitsbereich in Python basiert auf der sogenannten LEGB-Regel, bei der es sich um eine Abkürzung für Local (Namen, die in einer Funktion in irgendeiner Weise zugewiesen wurden (def oder lambda) und in dieser Funktion nicht als global deklariert sind), Enclosing (Name im lokalen Gültigkeitsbereich statisch einschließender Funktionen () handelt. def oder lambda), von intern nach extern), Global (Namen, die auf der obersten Ebene der Moduldatei zugewiesen wurden, oder durch Ausführen der globalen Anweisungen in def in der Datei), Integriert (Namen, die zuvor im Modul für integrierte Namen zugewiesen wurden: offen, Bereich, SyntaxError, ...).  Es scheint einfach genug, oder?  Nun, tatsächlich gibt es einige Feinheiten, wie dies in Python funktioniert, was uns zu dem allgemein komplexeren Python-Programmierproblem unten führt.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Was ist das Problem? <br><br>  Der obige Fehler tritt auf, weil Python beim Zuweisen einer Variablen im Bereich diese automatisch als lokal für diesen Bereich betrachtet und jede Variable mit demselben Namen in einem übergeordneten Bereich ausblendet. <br><br>  Daher sind viele überrascht, wenn sie UnboundLocalError in zuvor ausgeführtem Code erhalten, wenn dieser durch Hinzufügen eines Zuweisungsoperators irgendwo im Funktionskörper geändert wird. <br><br>  Diese Funktion ist für Entwickler bei der Verwendung von Listen besonders verwirrend.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Huh?  Warum stürzt foo2 ab, während foo1 einwandfrei funktioniert? <br><br>  Die Antwort ist die gleiche wie im vorherigen Beispiel, aber nach allgemeiner Meinung ist die Situation hier subtiler.  foo1 wendet den Zuweisungsoperator nicht auf lst an, foo2 nicht.  Wenn man bedenkt, dass lst + = [5] eigentlich nur eine Abkürzung für lst = lst + [5] ist, sehen wir, dass wir versuchen, den Wert lst zuzuweisen (Python geht also davon aus, dass er im lokalen Bereich liegt).  Der Wert, den wir lst zuweisen möchten, basiert jedoch auf lst selbst (es wird nun wieder angenommen, dass er sich im lokalen Bereich befindet), der noch nicht bestimmt wurde.  Und wir bekommen einen Fehler. <br><br><h3>  Fehler Nr. 5: Ändern einer Liste während der Iteration darüber </h3><br>  Das Problem im folgenden Code sollte ziemlich offensichtlich sein: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Das Entfernen eines Elements aus einer Liste oder einem Array während der Iteration ist ein Python-Problem, das jedem erfahrenen Softwareentwickler bekannt ist.  Obwohl das obige Beispiel ziemlich offensichtlich sein mag, können selbst erfahrene Entwickler diesen Rechen mit viel komplexerem Code beginnen. <br><br>  Glücklicherweise enthält Python eine Reihe eleganter Programmierparadigmen, die bei richtiger Verwendung zu einer erheblichen Vereinfachung und Optimierung des Codes führen können.  Eine weitere erfreuliche Folge davon ist, dass in einfacherem Code die Wahrscheinlichkeit, in den Fehler zu geraten, ein Listenelement während der Iteration versehentlich zu löschen, viel geringer ist.  Ein solches Paradigma sind Listengeneratoren.  Darüber hinaus ist das Verständnis der Funktionsweise von Listengeneratoren besonders hilfreich, um dieses spezielle Problem zu vermeiden, wie in dieser alternativen Implementierung des obigen Codes gezeigt, die einwandfrei funktioniert: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Fehler Nr. 6: Missverständnis, wie Python Variablen in Abschlüssen bindet </h3><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Sie können die folgende Ausgabe erwarten: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Aber eigentlich bekommst du das: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Überraschung! <br><br>  Dies ist auf die späte Bindung in Python zurückzuführen. Dies bedeutet, dass die Werte der in Closures verwendeten Variablen während des Aufrufs der internen Funktion nachgeschlagen werden.  Daher wird im obigen Code bei jedem Aufruf einer der zurückgegebenen Funktionen der Wert i während des Aufrufs im umgebenden Bereich gesucht (und zu diesem Zeitpunkt war der Zyklus bereits abgeschlossen, sodass mir bereits das Endergebnis zugewiesen wurde - Wert 4). . <br><br>  Die Lösung für dieses häufig auftretende Python-Problem wäre: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Wir verwenden hier die Standardargumente, um anonyme Funktionen zu generieren, um das gewünschte Verhalten zu erzielen.  Einige würden diese Lösung als elegant bezeichnen.  Einige sind <br>  dünn.  Einige Leute hassen diese Dinge.  Aber wenn Sie ein Python-Entwickler sind, ist es trotzdem wichtig zu verstehen. <br><br><h3>  Fehler Nr. 7: Erstellen zyklischer Modulabhängigkeiten </h3><br>  Angenommen, Sie haben zwei Dateien, a.py und b.py, von denen jede die andere wie folgt importiert: <br><br>  In a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  In b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Versuchen Sie zunächst, a.py zu importieren: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Es hat gut funktioniert.  Das kann Sie überraschen.  Schließlich importieren sich Module zyklisch und das sollte wahrscheinlich ein Problem sein, oder? <br><br>  Die Antwort ist, dass der einfache zyklische Import von Modulen an sich kein Problem in Python ist.  Wenn das Modul bereits importiert wurde, ist Python intelligent genug, um nicht zu versuchen, es erneut zu importieren.  Abhängig von dem Punkt, an dem jedes Modul versucht, auf Funktionen oder Variablen zuzugreifen, die in einem anderen Modul definiert sind, können jedoch tatsächlich Probleme auftreten. <br><br>  Zurück zu unserem Beispiel: Beim Importieren von a.py gab es keine Probleme beim Importieren von b.py, da b.py nicht erfordert, dass a.py während des Imports definiert wird.  Der einzige Verweis in b.py auf a ist ein Aufruf von af ().  Aber dieser Aufruf in g () und nichts in a.py oder b.py ruft g () nicht auf.  Also funktioniert alles gut. <br><br>  Aber was passiert, wenn wir versuchen, b.py zu importieren (ohne zuerst a.py zu importieren): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh, oh.  Das ist nicht gut!  Das Problem hierbei ist, dass während des Importvorgangs von b.py versucht wird, a.py zu importieren, was wiederum f () aufruft, das versucht, auf bx zuzugreifen. Bx wurde jedoch noch nicht definiert.  Daher die AttributeError-Ausnahme. <br><br>  Mindestens eine Lösung für dieses Problem ist ziemlich trivial.  Ändern Sie einfach b.py, um a.py in g () zu importieren: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Wenn wir es jetzt importieren, ist alles in Ordnung: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Fehler Nr. 8: Überschneiden von Namen mit Modulnamen in der Python-Standardbibliothek </h3><br>  Einer der Reize von Python sind die vielen Module, die sofort einsatzbereit sind.  Wenn Sie dies jedoch nicht bewusst befolgen, stellen Sie möglicherweise fest, dass der Name Ihres Moduls mit dem Namen des Moduls in der mit Python gelieferten Standardbibliothek identisch ist (z. B. enthält Ihr Code möglicherweise ein Modul mit dem Namen email.py, die mit dem gleichnamigen Standardbibliotheksmodul in Konflikt steht). <br><br>  Dies kann zu ernsthaften Problemen führen.  Wenn beispielsweise eines der Module versucht, die Version des Moduls aus der Python-Standardbibliothek zu importieren, und Sie im Projekt ein Modul mit demselben Namen haben, das versehentlich anstelle des Moduls aus der Standardbibliothek importiert wird. <br><br>  Daher sollte darauf geachtet werden, nicht dieselben Namen wie in den Modulen der Python-Standardbibliothek zu verwenden.  Es ist viel einfacher, den Namen des Moduls in Ihrem Projekt zu ändern, als eine Anfrage zu senden, um den Namen des Moduls in der Standardbibliothek zu ändern und die Genehmigung dafür zu erhalten. <br><br><h3>  Fehler Nr. 9: Die Unterschiede zwischen Python 2 und Python 3 wurden nicht berücksichtigt </h3><br>  Betrachten Sie die folgende foo.py-Datei: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  Unter Python 2 funktioniert es einwandfrei: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Aber jetzt wollen wir sehen, wie es in Python 3 funktioniert: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  Was ist gerade hier passiert?  Das "Problem" ist, dass in Python 3 ein Objekt in einem Ausnahmeblock außerhalb nicht verfügbar ist.  (Der Grund dafür ist, dass ansonsten die Objekte in diesem Block im Speicher gespeichert werden, bis der Garbage Collector startet und Verweise auf sie von dort entfernt.) <br><br>  Eine Möglichkeit, dieses Problem zu vermeiden, besteht darin, den Verweis auf das Ausnahmeblockobjekt außerhalb dieses Blocks zu belassen, damit es verfügbar bleibt.  Hier ist die Version des vorherigen Beispiels, in der diese Technik verwendet wird, um Code zu erhalten, der sowohl für Python 2 als auch für Python 3 geeignet ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  Führen Sie es in Python 3 aus: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Hurra! <br><br><h3>  Fehler Nr. 10: Unsachgemäße Verwendung der Methode __del__ </h3><br>  Angenommen, Sie haben eine mod.py-Datei wie diese: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  Und Sie versuchen dies von einer anderen another_mod.py aus zu tun: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  Und bekomme einen schrecklichen AttributeError. <br><br>  Warum?  Denn wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> berichtet, haben alle globalen Variablen des Moduls beim Herunterfahren des Interpreters den Wert None.  Infolgedessen wurde im obigen Beispiel beim Aufrufen von __del__ der Name foo bereits auf None gesetzt. <br><br>  Die Lösung für diese "Aufgabe mit einem Sternchen" besteht in der Verwendung von atexit.register ().  Wenn Ihr Programm die Ausführung abgeschlossen hat (dh wenn es normal beendet wird), werden Ihre Handles gelöscht, bevor der Interpreter seine Arbeit beendet. <br><br>  In diesem Sinne könnte das Update für den obigen mod.py-Code ungefähr so ​​aussehen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Eine solche Implementierung bietet eine einfache und zuverlässige Möglichkeit, die erforderliche Bereinigung nach einer normalen Programmbeendigung aufzurufen.  Natürlich bleibt die Entscheidung, wie mit dem Objekt umgegangen werden soll, das mit dem Namen self.myhandle verknüpft ist, foo.cleanup überlassen, aber ich denke, Sie verstehen die Idee. <br><br><h3>  Fazit </h3><br>  Python ist eine leistungsstarke und flexible Sprache mit vielen Mechanismen und Paradigmen, die die Leistung erheblich verbessern können.  Wie bei jedem Software-Tool oder jeder Software können jedoch bei einem eingeschränkten Verständnis oder einer eingeschränkten Bewertung ihrer Funktionen unvorhergesehene Probleme während der Entwicklung auftreten. <br><br>  Eine Einführung in die in diesem Artikel behandelten Python-Nuancen hilft Ihnen dabei, die Verwendung der Sprache zu optimieren und einige häufige Fehler zu vermeiden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466441/">https://habr.com/ru/post/de466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466431/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 40. 802.1X Standard- und AAA-Protokollfamilie</a></li>
<li><a href="../de466433/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 41. DHCP-Snooping und nicht standardmäßiges natives VLAN</a></li>
<li><a href="../de466435/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 42. Inter-VLAN-Routing und SVI</a></li>
<li><a href="../de466437/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 43. Routing-Protokolle Distanzvektor und Verbindungsstatus</a></li>
<li><a href="../de466439/index.html">Überprüfen Sie selbst: Wie viele Fragen können Sie ChGK beantworten?</a></li>
<li><a href="../de466443/index.html">ShIoTiny und die Welt: Analoge Sensoren oder ADCs für die Kleinsten</a></li>
<li><a href="../de466445/index.html">Angriffe zwischen Vertrauensstellungen zwischen Domänen</a></li>
<li><a href="../de466447/index.html">Wofür sollen wir ein CDN bauen?</a></li>
<li><a href="../de466449/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 44. Einführung in OSPF</a></li>
<li><a href="../de466451/index.html">Read_You kann nicht werfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>