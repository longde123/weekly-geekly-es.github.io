<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¶ ü•É üßô Python-Buggy-Code: 10 h√§ufigste Fehler, die Entwickler machen üîú üßëüèæ‚Äçü§ù‚Äçüßëüèª üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√úber Python 
 Python ist eine interpretierte, objektorientierte Programmiersprache auf hoher Ebene mit dynamischer Semantik. Integrierte Datenstruktur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Buggy-Code: 10 h√§ufigste Fehler, die Entwickler machen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466441/"><h3>  √úber Python </h3><br>  Python ist eine interpretierte, objektorientierte Programmiersprache auf hoher Ebene mit dynamischer Semantik.  Integrierte Datenstrukturen auf hoher Ebene in Kombination mit dynamischer Typisierung und dynamischer Bindung machen es f√ºr BRPS (schnelle Entwicklung von Anwendungstools) sowie f√ºr die Verwendung als Skript- und Verbindungssprache zum Verbinden vorhandener Komponenten oder Dienste sehr attraktiv.  Python unterst√ºtzt Module und Pakete und f√∂rdert so die Programmmodularit√§t und die Wiederverwendung von Code. <br><br><h3>  √úber diesen Artikel </h3><br>  Die Einfachheit und Leichtigkeit, diese Sprache zu beherrschen, kann f√ºr Entwickler verwirrend sein (insbesondere f√ºr diejenigen, die gerade erst anfangen, Python zu lernen), sodass Sie einige wichtige Feinheiten aus den Augen verlieren und die Leistungsf√§higkeit der Vielzahl m√∂glicher L√∂sungen mit Python untersch√§tzen k√∂nnen. <br><br>  In diesem Sinne werden in diesem Artikel die ‚ÄûTop 10‚Äú subtiler, schwer zu findender Fehler vorgestellt, die selbst fortgeschrittene Python-Entwickler machen k√∂nnen. <br><a name="habracut"></a><br>
<h3>  Fehler Nr. 1: Missbrauch von Ausdr√ºcken als Standardwerte f√ºr Funktionsargumente </h3><br>  Mit Python k√∂nnen Sie angeben, dass eine Funktion optionale Argumente haben kann, indem Sie einen Standardwert f√ºr diese festlegen.  Dies ist nat√ºrlich ein sehr praktisches Merkmal der Sprache, kann jedoch zu unangenehmen Konsequenzen f√ºhren, wenn der Typ dieses Werts ver√§nderlich ist.  Betrachten Sie beispielsweise die folgende Funktionsdefinition: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># bar -    #      . ... bar.append("baz") #     ... ... return bar</span></span></code> </pre> <br>  Ein h√§ufiger Fehler in diesem Fall ist die Annahme, dass der Wert eines optionalen Arguments bei jedem Aufruf einer Funktion ohne Wert f√ºr dieses Argument auf den Standardwert gesetzt wird.  Im obigen Code k√∂nnen wir beispielsweise davon ausgehen, dass durch wiederholtes Aufrufen der Funktion foo () (dh ohne Angabe eines Werts f√ºr das Balkenargument) immer "baz" zur√ºckgegeben wird, da davon ausgegangen wird, dass jedes Mal, wenn foo () aufgerufen wird (ohne) unter Angabe der Argumentleiste) wird die Leiste auf [] gesetzt (d. h. eine neue leere Liste). <br><br>  Aber mal sehen, was tats√§chlich passieren wird: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>] &gt;&gt;&gt; foo() [<span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>, <span class="hljs-string"><span class="hljs-string">"baz"</span></span>]</code> </pre> <br>  Huh?  Warum f√ºgt die Funktion der vorhandenen Liste bei jedem Aufruf von foo () weiterhin den Standardwert "baz" hinzu, anstatt jedes Mal eine neue Liste zu erstellen? <br><br>  Die Antwort auf diese Frage wird ein tieferes Verst√§ndnis daf√ºr sein, was mit Python ‚Äûunter der Haube‚Äú vor sich geht.  N√§mlich: Der Standardwert f√ºr die Funktion wird w√§hrend der Definition der Funktion nur einmal initialisiert.  Daher wird das Balkenargument standardm√§√üig nur dann initialisiert (d. H. Eine leere Liste), wenn foo () zum ersten Mal definiert wird, aber nachfolgende Aufrufe von foo () (d. H. Ohne Angabe des Balkenarguments) verwenden weiterhin dieselbe Liste wie zuvor Erstellt f√ºr die Argumentleiste zum Zeitpunkt der ersten Funktionsdefinition. <br><br>  Als Referenz ist die folgende Definition eine h√§ufige ‚ÄûProblemumgehung‚Äú f√ºr diesen Fehler: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar=None)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-comment"><span class="hljs-comment"># or if not bar: ... bar = [] ... bar.append("baz") ... return bar ... &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"] &gt;&gt;&gt; foo() ["baz"]</span></span></code> </pre> <br><h3>  Fehler Nr. 2: Missbrauch von Klassenvariablen </h3><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... x = <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(A)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Alles scheint in Ordnung zu sein. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Bx = <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Ja, alles war wie erwartet. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Ax = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Ax, Bx, Cx <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Was zur H√∂lle ?!  Wir haben gerade Axe ge√§ndert. Warum hat sich Cx auch ge√§ndert? <br><br>  In Python werden Klassenvariablen wie W√∂rterb√ºcher behandelt und folgen der sogenannten Method Resolution Order (MRO).  Da das Attribut x im obigen Code nicht in Klasse C gefunden wird, wird es daher in seinen Basisklassen gefunden (im obigen Beispiel nur A, obwohl Python Mehrfachvererbung unterst√ºtzt).  Mit anderen Worten, C hat keine eigene Eigenschaft x unabh√§ngig von A. Somit sind Verweise auf Cx tats√§chlich Verweise auf Ax. Dies f√ºhrt zu Problemen, wenn diese F√§lle nicht richtig behandelt werden.  Achten Sie beim Erlernen von Python besonders auf Klassenattribute und arbeiten Sie mit ihnen. <br><br><h3>  Fehler Nr. 3: Falsche Parameter f√ºr den Ausnahmeblock </h3><br>  Angenommen, Sie haben den folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError, IndexError: <span class="hljs-comment"><span class="hljs-comment"># To catch both exceptions, right? ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 3, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Das Problem hierbei ist, dass der Ausnahmeausdruck die auf diese Weise angegebene Liste von Ausnahmen nicht akzeptiert.  Vielmehr wird in Python 2.x der Ausdruck "au√üer Ausnahme, e" verwendet, um die Ausnahme an einen optionalen zweiten gegebenen zweiten Parameter (in diesem Fall e) zu binden, um sie f√ºr die weitere √úberpr√ºfung verf√ºgbar zu machen.  Infolgedessen wird im obigen Code eine IndexError-Ausnahme nicht von der Ausnahme-Anweisung abgefangen.  Stattdessen endet die Ausnahme mit der Bindung an einen Parameter namens IndexError. <br><br>  Der richtige Weg, um mehrere Ausnahmen mit dem Ausnahmeausdruck abzufangen, besteht darin, den ersten Parameter als Tupel anzugeben, das alle Ausnahmen enth√§lt, die Sie abfangen m√∂chten.  Verwenden Sie f√ºr maximale Kompatibilit√§t auch das Schl√ºsselwort as, da diese Syntax sowohl in Python 2 als auch in Python 3 unterst√ºtzt wird: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ... l = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] ... int(l[<span class="hljs-number"><span class="hljs-number">2</span></span>]) ... <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> (ValueError, IndexError) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt;</code> </pre> <br><h3>  Fehler Nr. 4: Missverst√§ndnis der Python-Bereichsregeln </h3><br>  Der G√ºltigkeitsbereich in Python basiert auf der sogenannten LEGB-Regel, bei der es sich um eine Abk√ºrzung f√ºr Local (Namen, die in einer Funktion in irgendeiner Weise zugewiesen wurden (def oder lambda) und in dieser Funktion nicht als global deklariert sind), Enclosing (Name im lokalen G√ºltigkeitsbereich statisch einschlie√üender Funktionen () handelt. def oder lambda), von intern nach extern), Global (Namen, die auf der obersten Ebene der Moduldatei zugewiesen wurden, oder durch Ausf√ºhren der globalen Anweisungen in def in der Datei), Integriert (Namen, die zuvor im Modul f√ºr integrierte Namen zugewiesen wurden: offen, Bereich, SyntaxError, ...).  Es scheint einfach genug, oder?  Nun, tats√§chlich gibt es einige Feinheiten, wie dies in Python funktioniert, was uns zu dem allgemein komplexeren Python-Programmierproblem unten f√ºhrt.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... x += <span class="hljs-number"><span class="hljs-number">1</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x ... &gt;&gt;&gt; foo() Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> foo UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'x'</span></span> referenced before assignment</code> </pre> <br>  Was ist das Problem? <br><br>  Der obige Fehler tritt auf, weil Python beim Zuweisen einer Variablen im Bereich diese automatisch als lokal f√ºr diesen Bereich betrachtet und jede Variable mit demselben Namen in einem √ºbergeordneten Bereich ausblendet. <br><br>  Daher sind viele √ºberrascht, wenn sie UnboundLocalError in zuvor ausgef√ºhrtem Code erhalten, wenn dieser durch Hinzuf√ºgen eines Zuweisungsoperators irgendwo im Funktionsk√∂rper ge√§ndert wird. <br><br>  Diese Funktion ist f√ºr Entwickler bei der Verwendung von Listen besonders verwirrend.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... lst.append(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   ... ... &gt;&gt;&gt; foo1() &gt;&gt;&gt; lst [1, 2, 3, 5] &gt;&gt;&gt; lst = [1, 2, 3] &gt;&gt;&gt; def foo2(): ... lst += [5] # ...    ! ... &gt;&gt;&gt; foo2() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in foo UnboundLocalError: local variable 'lst' referenced before assignment</span></span></code> </pre> <br>  Huh?  Warum st√ºrzt foo2 ab, w√§hrend foo1 einwandfrei funktioniert? <br><br>  Die Antwort ist die gleiche wie im vorherigen Beispiel, aber nach allgemeiner Meinung ist die Situation hier subtiler.  foo1 wendet den Zuweisungsoperator nicht auf lst an, foo2 nicht.  Wenn man bedenkt, dass lst + = [5] eigentlich nur eine Abk√ºrzung f√ºr lst = lst + [5] ist, sehen wir, dass wir versuchen, den Wert lst zuzuweisen (Python geht also davon aus, dass er im lokalen Bereich liegt).  Der Wert, den wir lst zuweisen m√∂chten, basiert jedoch auf lst selbst (es wird nun wieder angenommen, dass er sich im lokalen Bereich befindet), der noch nicht bestimmt wurde.  Und wir bekommen einen Fehler. <br><br><h3>  Fehler Nr. 5: √Ñndern einer Liste w√§hrend der Iteration dar√ºber </h3><br>  Das Problem im folgenden Code sollte ziemlich offensichtlich sein: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(numbers)): ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> odd(numbers[i]): ... <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> numbers[i] <span class="hljs-comment"><span class="hljs-comment"># BAD: Deleting item from a list while iterating over it ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; IndexError: list index out of range</span></span></code> </pre> <br>  Das Entfernen eines Elements aus einer Liste oder einem Array w√§hrend der Iteration ist ein Python-Problem, das jedem erfahrenen Softwareentwickler bekannt ist.  Obwohl das obige Beispiel ziemlich offensichtlich sein mag, k√∂nnen selbst erfahrene Entwickler diesen Rechen mit viel komplexerem Code beginnen. <br><br>  Gl√ºcklicherweise enth√§lt Python eine Reihe eleganter Programmierparadigmen, die bei richtiger Verwendung zu einer erheblichen Vereinfachung und Optimierung des Codes f√ºhren k√∂nnen.  Eine weitere erfreuliche Folge davon ist, dass in einfacherem Code die Wahrscheinlichkeit, in den Fehler zu geraten, ein Listenelement w√§hrend der Iteration versehentlich zu l√∂schen, viel geringer ist.  Ein solches Paradigma sind Listengeneratoren.  Dar√ºber hinaus ist das Verst√§ndnis der Funktionsweise von Listengeneratoren besonders hilfreich, um dieses spezielle Problem zu vermeiden, wie in dieser alternativen Implementierung des obigen Codes gezeigt, die einwandfrei funktioniert: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>odd = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : bool(x % <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;&gt;&gt; numbers = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>)] &gt;&gt;&gt; numbers[:] = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> odd(n)] <span class="hljs-comment"><span class="hljs-comment"># ahh, the beauty of it all &gt;&gt;&gt; numbers [0, 2, 4, 6, 8]</span></span></code> </pre> <br><h3>  Fehler Nr. 6: Missverst√§ndnis, wie Python Variablen in Abschl√ºssen bindet </h3><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ...</code> </pre> <br>  Sie k√∂nnen die folgende Ausgabe erwarten: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Aber eigentlich bekommst du das: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  √úberraschung! <br><br>  Dies ist auf die sp√§te Bindung in Python zur√ºckzuf√ºhren. Dies bedeutet, dass die Werte der in Closures verwendeten Variablen w√§hrend des Aufrufs der internen Funktion nachgeschlagen werden.  Daher wird im obigen Code bei jedem Aufruf einer der zur√ºckgegebenen Funktionen der Wert i w√§hrend des Aufrufs im umgebenden Bereich gesucht (und zu diesem Zeitpunkt war der Zyklus bereits abgeschlossen, sodass mir bereits das Endergebnis zugewiesen wurde - Wert 4). . <br><br>  Die L√∂sung f√ºr dieses h√§ufig auftretende Python-Problem w√§re: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_multipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, i=i : i * x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>)] ... &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> multiplier <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> create_multipliers(): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>) ... <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Voila!  Wir verwenden hier die Standardargumente, um anonyme Funktionen zu generieren, um das gew√ºnschte Verhalten zu erzielen.  Einige w√ºrden diese L√∂sung als elegant bezeichnen.  Einige sind <br>  d√ºnn.  Einige Leute hassen diese Dinge.  Aber wenn Sie ein Python-Entwickler sind, ist es trotzdem wichtig zu verstehen. <br><br><h3>  Fehler Nr. 7: Erstellen zyklischer Modulabh√§ngigkeiten </h3><br>  Angenommen, Sie haben zwei Dateien, a.py und b.py, von denen jede die andere wie folgt importiert: <br><br>  In a.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f()</code> </pre> <br>  In b.py: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> af()</code> </pre> <br>  Versuchen Sie zun√§chst, a.py zu importieren: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Es hat gut funktioniert.  Das kann Sie √ºberraschen.  Schlie√ülich importieren sich Module zyklisch und das sollte wahrscheinlich ein Problem sein, oder? <br><br>  Die Antwort ist, dass der einfache zyklische Import von Modulen an sich kein Problem in Python ist.  Wenn das Modul bereits importiert wurde, ist Python intelligent genug, um nicht zu versuchen, es erneut zu importieren.  Abh√§ngig von dem Punkt, an dem jedes Modul versucht, auf Funktionen oder Variablen zuzugreifen, die in einem anderen Modul definiert sind, k√∂nnen jedoch tats√§chlich Probleme auftreten. <br><br>  Zur√ºck zu unserem Beispiel: Beim Importieren von a.py gab es keine Probleme beim Importieren von b.py, da b.py nicht erfordert, dass a.py w√§hrend des Imports definiert wird.  Der einzige Verweis in b.py auf a ist ein Aufruf von af ().  Aber dieser Aufruf in g () und nichts in a.py oder b.py ruft g () nicht auf.  Also funktioniert alles gut. <br><br>  Aber was passiert, wenn wir versuchen, b.py zu importieren (ohne zuerst a.py zu importieren): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"b.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> f() File <span class="hljs-string"><span class="hljs-string">"a.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bx AttributeError: <span class="hljs-string"><span class="hljs-string">'module'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'x'</span></span></code> </pre> <br>  Oh, oh.  Das ist nicht gut!  Das Problem hierbei ist, dass w√§hrend des Importvorgangs von b.py versucht wird, a.py zu importieren, was wiederum f () aufruft, das versucht, auf bx zuzugreifen. Bx wurde jedoch noch nicht definiert.  Daher die AttributeError-Ausnahme. <br><br>  Mindestens eine L√∂sung f√ºr dieses Problem ist ziemlich trivial.  √Ñndern Sie einfach b.py, um a.py in g () zu importieren: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-comment"><span class="hljs-comment"># This will be evaluated only when g() is called print af()</span></span></code> </pre> <br>  Wenn wir es jetzt importieren, ist alles in Ordnung: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b &gt;&gt;&gt; bg() <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># Printed a first time since module 'a' calls 'print f()' at the end 1 # Printed a second time, this one is our call to 'g'</span></span></code> </pre><br><h3>  Fehler Nr. 8: √úberschneiden von Namen mit Modulnamen in der Python-Standardbibliothek </h3><br>  Einer der Reize von Python sind die vielen Module, die sofort einsatzbereit sind.  Wenn Sie dies jedoch nicht bewusst befolgen, stellen Sie m√∂glicherweise fest, dass der Name Ihres Moduls mit dem Namen des Moduls in der mit Python gelieferten Standardbibliothek identisch ist (z. B. enth√§lt Ihr Code m√∂glicherweise ein Modul mit dem Namen email.py, die mit dem gleichnamigen Standardbibliotheksmodul in Konflikt steht). <br><br>  Dies kann zu ernsthaften Problemen f√ºhren.  Wenn beispielsweise eines der Module versucht, die Version des Moduls aus der Python-Standardbibliothek zu importieren, und Sie im Projekt ein Modul mit demselben Namen haben, das versehentlich anstelle des Moduls aus der Standardbibliothek importiert wird. <br><br>  Daher sollte darauf geachtet werden, nicht dieselben Namen wie in den Modulen der Python-Standardbibliothek zu verwenden.  Es ist viel einfacher, den Namen des Moduls in Ihrem Projekt zu √§ndern, als eine Anfrage zu senden, um den Namen des Moduls in der Standardbibliothek zu √§ndern und die Genehmigung daf√ºr zu erhalten. <br><br><h3>  Fehler Nr. 9: Die Unterschiede zwischen Python 2 und Python 3 wurden nicht ber√ºcksichtigt </h3><br>  Betrachten Sie die folgende foo.py-Datei: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(e) bad()</code> </pre> <br>  Unter Python 2 funktioniert es einwandfrei: <br><br><pre> <code class="python hljs">$ python foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Aber jetzt wollen wir sehen, wie es in Python 3 funktioniert: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; bad() File <span class="hljs-string"><span class="hljs-string">"foo.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> bad print(e) UnboundLocalError: local variable <span class="hljs-string"><span class="hljs-string">'e'</span></span> referenced before assignment</code> </pre> <br>  Was ist gerade hier passiert?  Das "Problem" ist, dass in Python 3 ein Objekt in einem Ausnahmeblock au√üerhalb nicht verf√ºgbar ist.  (Der Grund daf√ºr ist, dass ansonsten die Objekte in diesem Block im Speicher gespeichert werden, bis der Garbage Collector startet und Verweise auf sie von dort entfernt.) <br><br>  Eine M√∂glichkeit, dieses Problem zu vermeiden, besteht darin, den Verweis auf das Ausnahmeblockobjekt au√üerhalb dieses Blocks zu belassen, damit es verf√ºgbar bleibt.  Hier ist die Version des vorherigen Beispiels, in der diese Technik verwendet wird, um Code zu erhalten, der sowohl f√ºr Python 2 als auch f√ºr Python 3 geeignet ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyError(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> exception = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: bar(int(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'key error'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: exception = e print(<span class="hljs-string"><span class="hljs-string">'value error'</span></span>) print(exception) good()</code> </pre> <br>  F√ºhren Sie es in Python 3 aus: <br><br><pre> <code class="python hljs">$ python3 foo.py <span class="hljs-number"><span class="hljs-number">1</span></span> key error <span class="hljs-number"><span class="hljs-number">1</span></span> $ python3 foo.py <span class="hljs-number"><span class="hljs-number">2</span></span> value error <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Hurra! <br><br><h3>  Fehler Nr. 10: Unsachgem√§√üe Verwendung der Methode __del__ </h3><br>  Angenommen, Sie haben eine mod.py-Datei wie diese: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__del__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(self.myhandle)</code> </pre> <br>  Und Sie versuchen dies von einer anderen another_mod.py aus zu tun: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mod mybar = mod.Bar()</code> </pre> <br>  Und bekomme einen schrecklichen AttributeError. <br><br>  Warum?  Denn wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> berichtet, haben alle globalen Variablen des Moduls beim Herunterfahren des Interpreters den Wert None.  Infolgedessen wurde im obigen Beispiel beim Aufrufen von __del__ der Name foo bereits auf None gesetzt. <br><br>  Die L√∂sung f√ºr diese "Aufgabe mit einem Sternchen" besteht in der Verwendung von atexit.register ().  Wenn Ihr Programm die Ausf√ºhrung abgeschlossen hat (dh wenn es normal beendet wird), werden Ihre Handles gel√∂scht, bevor der Interpreter seine Arbeit beendet. <br><br>  In diesem Sinne k√∂nnte das Update f√ºr den obigen mod.py-Code ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> atexit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cleanup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handle)</span></span></span><span class="hljs-function">:</span></span> foo.cleanup(handle) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... atexit.register(cleanup, self.myhandle)</code> </pre> <br>  Eine solche Implementierung bietet eine einfache und zuverl√§ssige M√∂glichkeit, die erforderliche Bereinigung nach einer normalen Programmbeendigung aufzurufen.  Nat√ºrlich bleibt die Entscheidung, wie mit dem Objekt umgegangen werden soll, das mit dem Namen self.myhandle verkn√ºpft ist, foo.cleanup √ºberlassen, aber ich denke, Sie verstehen die Idee. <br><br><h3>  Fazit </h3><br>  Python ist eine leistungsstarke und flexible Sprache mit vielen Mechanismen und Paradigmen, die die Leistung erheblich verbessern k√∂nnen.  Wie bei jedem Software-Tool oder jeder Software k√∂nnen jedoch bei einem eingeschr√§nkten Verst√§ndnis oder einer eingeschr√§nkten Bewertung ihrer Funktionen unvorhergesehene Probleme w√§hrend der Entwicklung auftreten. <br><br>  Eine Einf√ºhrung in die in diesem Artikel behandelten Python-Nuancen hilft Ihnen dabei, die Verwendung der Sprache zu optimieren und einige h√§ufige Fehler zu vermeiden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466441/">https://habr.com/ru/post/de466441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466431/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 40. 802.1X Standard- und AAA-Protokollfamilie</a></li>
<li><a href="../de466433/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 41. DHCP-Snooping und nicht standardm√§√üiges natives VLAN</a></li>
<li><a href="../de466435/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 42. Inter-VLAN-Routing und SVI</a></li>
<li><a href="../de466437/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 43. Routing-Protokolle Distanzvektor und Verbindungsstatus</a></li>
<li><a href="../de466439/index.html">√úberpr√ºfen Sie selbst: Wie viele Fragen k√∂nnen Sie ChGK beantworten?</a></li>
<li><a href="../de466443/index.html">ShIoTiny und die Welt: Analoge Sensoren oder ADCs f√ºr die Kleinsten</a></li>
<li><a href="../de466445/index.html">Angriffe zwischen Vertrauensstellungen zwischen Dom√§nen</a></li>
<li><a href="../de466447/index.html">Wof√ºr sollen wir ein CDN bauen?</a></li>
<li><a href="../de466449/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 44. Einf√ºhrung in OSPF</a></li>
<li><a href="../de466451/index.html">Read_You kann nicht werfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>