<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçß üöò üé¢ M√©todo de miner√≠a probabil√≠stico de Bitcoin üë®üèæ‚Äçüåæ üç§ üê´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Creo que un poco de tonter√≠as el martes no perjudicar√° la semana laboral. Tengo un pasatiempo, en mi tiempo libre trato de descubrir c√≥mo hackear el a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todo de miner√≠a probabil√≠stico de Bitcoin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420131/"><img src="https://habrastorage.org/webt/oi/lh/dt/oilhdtkhhgrgz2gpjy00mjrxhaq.jpeg"><br><br>  Creo que un poco de tonter√≠as el martes no perjudicar√° la semana laboral.  Tengo un pasatiempo, en mi tiempo libre trato de descubrir c√≥mo hackear el algoritmo de miner√≠a de bitcoin, evitar b√∫squedas est√∫pidas sin sentido y encontrar una soluci√≥n al problema de coincidencia de hash con un consumo m√≠nimo de energ√≠a.  Debo decir de inmediato el resultado, por supuesto, a√∫n no lo he logrado, pero sin embargo, ¬øpor qu√© no exponer por escrito las ideas que nacen en la cabeza?  En alg√∫n lugar necesitan ser puestos ... <br><br>  A pesar del delirio de las ideas a continuaci√≥n, creo que este art√≠culo puede ser √∫til para alguien que est√° estudiando <br><br><ol><li>  Lenguaje C ++ y sus plantillas </li><li>  algunos circuitos digitales </li><li>  un poco de teor√≠a de probabilidad y aritm√©tica probabil√≠stica </li><li>  algoritmo de hash de bitcoin en detalle </li></ol><a name="habracut"></a><br>  Por donde empezamos <br><br>  ¬øQuiz√°s del √∫ltimo y m√°s aburrido elemento de esta lista?  Paciencia, entonces ser√° m√°s divertido. <br>  Consideremos en detalle el algoritmo para calcular la funci√≥n hash de bitcoin.  Es simple F (x) = sha256 (sha256 (x)), donde x es la entrada de 80 bytes, el encabezado del bloque junto con el n√∫mero de versi√≥n del bloque, hash del bloque anterior, ra√≠z de merkle, marca de tiempo, bits y nonce.  Aqu√≠ hay ejemplos de encabezados de bloque bastante recientes que se pasan a la funci√≥n hash: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//blk=533522 0x00,0x00,0x00,0x20, 0x6d,0xa5,0xdd,0xb5,0x78,0x04,0x08,0x80,0xae,0x3d,0xed,0xc5,0x8e,0xe9,0x74,0x93,0x93,0x6d,0x6a,0xf4,0x0e,0x80,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xdf,0x3e,0xb0,0xf4,0x92,0xbf,0xe9,0xb8,0xc8,0x12,0x1f,0x84,0xdd,0x35,0xe1,0x38,0x09,0xcc,0x28,0xc2,0x33,0x53,0x90,0x4e,0x15,0x49,0x5e,0xc7,0xb0,0x78,0x35,0x91, 0x82,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xAA,0x02,0x44,0x22, //blk=533523 0x00,0x00,0x00,0x20, 0x6a,0x27,0x37,0xc3,0x1f,0x68,0xf8,0xe3,0x03,0xa3,0x5d,0xff,0x2d,0x97,0x39,0xaf,0x81,0xa2,0xf5,0xf0,0x7c,0xdb,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0xa1,0xb8,0x4f,0x75,0x66,0xf3,0xf3,0x8e,0x78,0xf7,0xa2,0xa2,0xa2,0x19,0xa1,0x18,0x45,0xfa,0x58,0x53,0xe4,0x05,0x50,0x12,0x57,0xa1,0xab,0x2c,0x39,0xe6,0x1f,0x63, 0xA0,0xDB,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0x84,0x7B,0x86,0xE7, //blk=533524 0x00,0x00,0x00,0x20, 0xb3,0xc7,0xaa,0x07,0x26,0xdb,0xe8,0x58,0x19,0xa8,0xb9,0x53,0x08,0x62,0x8b,0xca,0x58,0x00,0x69,0x64,0x58,0x69,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x4e,0xfc,0xf4,0x5c,0xad,0x31,0x44,0x5b,0xb1,0x13,0x80,0x03,0xe0,0xfd,0x04,0x24,0x86,0xcc,0x7a,0x8c,0xa7,0x7c,0x30,0x60,0x05,0x6f,0x43,0xcf,0x25,0x45,0x8f,0xd8, 0x80,0xDE,0x57,0x5B, 0x17,0x5A,0x36,0x17, 0xF7,0x2B,0x3B,0x42,</span></span></code> </pre> <br>  Este conjunto de bytes es un material bastante valioso, ya que a menudo no es f√°cil para los mineros averiguar en qu√© orden deben seguir los bytes al formar el encabezado, a menudo invirtiendo los lugares de los bytes bajos y altos (endianos). <br><br>  Entonces, desde el encabezado del bloque, 80 bytes se consideran el hash sha256 y luego del resultado otro sha256. <br>  El algoritmo sha256 en s√≠ mismo, si observa diferentes fuentes, generalmente consta de cuatro funciones: <br><br><ol><li>  nulo sha256_init (SHA256_CTX * ctx); </li><li>  vac√≠o sha256_transform (SHA256_CTX * ctx, datos BYTE constantes []); </li><li>  vac√≠o sha256_update (SHA256_CTX * ctx, const BYTE data [], size_t len); </li><li>  nulo sha256_final (SHA256_CTX * ctx, BYTE hash []); </li></ol><br>  La primera funci√≥n que se llama al calcular el hash es sha256_init (), que restaura la estructura SHA256_CTX.  No hay nada especial all√≠ excepto ocho palabras de estado de 32 bits, que inicialmente se llenan con palabras especiales: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;bitlen = <span class="hljs-number"><span class="hljs-number">0</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x6a09e667</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbb67ae85</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x3c6ef372</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0xa54ff53a</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">0x510e527f</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-number"><span class="hljs-number">0x9b05688c</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0x1f83d9ab</span></span>; ctx-&gt;state[<span class="hljs-number"><span class="hljs-number">7</span></span>] = <span class="hljs-number"><span class="hljs-number">0x5be0cd19</span></span>; }</code> </pre><br>  Supongamos que tenemos un archivo cuyo hash necesita ser calculado.  Leemos el archivo con bloques de tama√±o arbitrario y llamamos a la funci√≥n sha256_update () donde pasamos el puntero a los datos del bloque y la longitud del bloque.  La funci√≥n acumula el hash en la estructura SHA256_CTX en la matriz de estado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha256_update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SHA256_CTX *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE data[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; ++i) { ctx-&gt;data[ctx-&gt;datalen] = data[i]; ctx-&gt;datalen++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx-&gt;datalen == <span class="hljs-number"><span class="hljs-number">64</span></span>) { sha256_transform(ctx, ctx-&gt;data); ctx-&gt;bitlen += <span class="hljs-number"><span class="hljs-number">512</span></span>; ctx-&gt;datalen = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Por s√≠ solo, sha256_update () llama a la funci√≥n de caballo de batalla sha256_transform (), que ya acepta bloques de solo una longitud fija de 64 bytes: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/****************************** MACROS ******************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ROTLEFT(a,b) (((a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; (b)) | ((a) &gt;&gt; (32-(b)))) #define ROTRIGHT(a,b) (((a) &gt;&gt; (b)) | ((a) &lt;&lt; (32-(b)))) #define CH(x,y,z) (((x) &amp; (y)) ^ (~(x) &amp; (z))) #define MAJ(x,y,z) (((x) &amp; (y)) ^ ((x) &amp; (z)) ^ ((y) &amp; (z))) #define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22)) #define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25)) #define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) &gt;&gt; 3)) #define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) &gt;&gt; 10)) /**************************** VARIABLES *****************************/ static const uint32_t k[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; /*********************** FUNCTION DEFINITIONS ***********************/ void sha256_transform(SHA256_CTX *ctx, const BYTE data[]) { uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64]; for (i = 0, j = 0; i &lt; 16; ++i, j += 4) m[i] = (data[j] &lt;&lt; 24) | (data[j + 1] &lt;&lt; 16) | (data[j + 2] &lt;&lt; 8) | (data[j + 3]); for (; i &lt; 64; ++i) m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16]; a = ctx-&gt;state[0]; b = ctx-&gt;state[1]; c = ctx-&gt;state[2]; d = ctx-&gt;state[3]; e = ctx-&gt;state[4]; f = ctx-&gt;state[5]; g = ctx-&gt;state[6]; h = ctx-&gt;state[7]; for (i = 0; i &lt; 64; ++i) { t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i]; t2 = EP0(a) + MAJ(a, b, c); h = g; g = f; f = e; e = d + t1; d = c; c = b; b = a; a = t1 + t2; } ctx-&gt;state[0] += a; ctx-&gt;state[1] += b; ctx-&gt;state[2] += c; ctx-&gt;state[3] += d; ctx-&gt;state[4] += e; ctx-&gt;state[5] += f; ctx-&gt;state[6] += g; ctx-&gt;state[7] += h; }</span></span></span></span></code> </pre><br>  Cuando se haya le√≠do todo el archivo hash y ya se haya transferido a la funci√≥n sha256_update (), todo lo que queda es llamar a la funci√≥n sha256_final () final, que si el tama√±o del archivo no era un m√∫ltiplo de 64 bytes, agregar√° bytes de relleno adicionales, escribir√° la longitud total de datos al final del √∫ltimo bloque de datos y har√° el sha256_transform final (). <br>  El resultado hash permanece en la matriz de estado. <br><br>  Este es el "alto nivel", por as√≠ decirlo. <br><br>  En relaci√≥n con el minero de Bitcoin, por supuesto, los desarrolladores piensan c√≥mo considerarlos m√°s peque√±os y m√°s eficientes. <br><br>  Es simple: el encabezado contiene solo 80 bytes, que no es un m√∫ltiplo de 64 bytes.  Por lo tanto, ser√≠a necesario que el primer sha256 hiciera dos sha256_transform () ya.  Sin embargo, afortunadamente para los mineros, el nonce del bloque est√° al final del encabezado, por lo que el primer sha256_transform () solo se puede ejecutar una vez; este ser√° el llamado estado intermedio.  A continuaci√≥n, el minero pasa por todas las opciones sin sentido, que son 4 mil millones, 2 ^ 32 y las sustituye en el campo correspondiente por el segundo sha256_transform ().  Esta transformaci√≥n completa la primera funci√≥n sha256.  Su resultado son ocho palabras de 32 bits, es decir, 32 bytes.  Es f√°cil encontrar sha256 de ellos: se llama al sha256_transform () final y todo est√° listo.  Tenga en cuenta que los datos de entrada son 32 bytes m√°s peque√±os que los 64 bytes necesarios para sha256_transform ().  Entonces, nuevamente, el bloque se rellenar√° con ceros y la longitud del bloque se ingresar√° al final. <br><br>  En total, solo hay tres llamadas a sha256_transform () de las cuales la primera debe leerse solo una vez para calcular el estado medio. <br><br>  Trat√© de expandir todas las manipulaciones de datos que ocurren al calcular el hash del encabezado de un bloque de bitcoin en una sola funci√≥n, para que quede claro c√≥mo ocurre todo el c√°lculo espec√≠ficamente para bitcoin y esto es lo que sucedi√≥: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//get bitcoin header via ptr to 80 bytes and calc hash template &lt;typename T&gt; void full_btc_hash(const uint8_t* ptr80, T nonce, T* presult) { //-1------------------------------------------ //init sha256 state s[7:0] T s[16]; for (int i = 0; i &lt; 8; i++) { s[i] = sha256_init_state[i]; presult[i] = sha256_init_state[i]; } uint8_t tail2[] = { 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00, }; uint32_t* p = (uint32_t*)tail2; for (int i = 0; i &lt; 8; i++) { s[i + 8] = ntohl(p[i]); } //get first block for sha256 uint8_t tail[] = { /* 2nd sha256 block padding */ 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x80 }; T blk1[32]; p = (uint32_t*)ptr80; for (int i = 0; i &lt; 19; i++) { blk1[i] = ntohl(p[i]); } //put nonce here blk1[19] = nonce; p = (uint32_t*)tail; for (int i = 0; i &lt; 12; i++) { blk1[i + 20] = ntohl(p[i]); } sha256_transform(s, &amp;blk1[0]); //warning! this can be called only once and produce MIDSTATE sha256_transform(s, &amp;blk1[16]); sha256_transform(presult, s); }</span></span></code> </pre><br>  Implement√© esta funci√≥n como una plantilla de c ++, puede operar no solo con palabras de 32 bits, digamos uint32_t, sino tambi√©n con palabras de un tipo diferente "T" de la misma manera.  Tengo aqu√≠ y el estado sha256 se almacena como una matriz de tipo "T" y sha256_transform () se llama con un puntero de par√°metro a una matriz de tipo "T" y el resultado se devuelve igual.  La funci√≥n de transformaci√≥n ahora tambi√©n tiene la forma de una plantilla de c ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ror32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T word, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shift)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (word &gt;&gt; shift) | (word &lt;&lt; (<span class="hljs-number"><span class="hljs-number">32</span></span> - shift)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z ^ (x &amp; (y ^ z)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Maj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x, T y, T z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &amp; y) | (z &amp; (x | y)); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e0(x) (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> e1(x) (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s0(x) (ror32(x, 7) ^ ror32(x,18) ^ (x &gt;&gt; 3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s1(x) (ror32(x,17) ^ ror32(x,19) ^ (x &gt;&gt; 10)) unsigned int ntohl(unsigned int in) { return ((in &amp; 0xff) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24) | ((in &amp; 0xff00) &lt;&lt; 8) | ((in &amp; 0xff0000) &gt;&gt; 8) | ((in &amp; 0xff000000) &gt;&gt; 24); } template &lt;typename T&gt; void LOAD_OP(int I, T *W, const u8 *input) { //W[I] = /*ntohl*/ (((u32*)(input))[I]); W[I] = ntohl(((u32*)(input))[I]); //W[I] = (input[3] &lt;&lt; 24) | (input[2] &lt;&lt; 16) | (input[1] &lt;&lt; 8) | (input[0]); } template &lt;typename T&gt; void BLEND_OP(int I, T *W) { W[I] = s1(W[I - 2]) + W[I - 7] + s0(W[I - 15]) + W[I - 16]; } template &lt;typename T&gt; void sha256_transform(T *state, const T *input) { T a, b, c, d, e, f, g, h, t1, t2; TW[64]; int i; /* load the input */ for (i = 0; i &lt; 16; i++) // MJ input is cast to u32* so this processes 16 DWORDS = 64 bytes W[i] = input[i]; /* now blend */ for (i = 16; i &lt; 64; i++) BLEND_OP(i, W); /* load the state into our registers */ a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; // t1 = h + e1(e) + Ch(e, f, g) + 0x428a2f98 + W[0]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x71374491 + W[1]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb5c0fbcf + W[2]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xe9b5dba5 + W[3]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x3956c25b + W[4]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x59f111f1 + W[5]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x923f82a4 + W[6]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xab1c5ed5 + W[7]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xd807aa98 + W[8]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x12835b01 + W[9]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x243185be + W[10]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x550c7dc3 + W[11]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x72be5d74 + W[12]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x80deb1fe + W[13]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x9bdc06a7 + W[14]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc19bf174 + W[15]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xe49b69c1 + W[16]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xefbe4786 + W[17]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x0fc19dc6 + W[18]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x240ca1cc + W[19]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x2de92c6f + W[20]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4a7484aa + W[21]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5cb0a9dc + W[22]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x76f988da + W[23]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x983e5152 + W[24]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa831c66d + W[25]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xb00327c8 + W[26]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xbf597fc7 + W[27]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xc6e00bf3 + W[28]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd5a79147 + W[29]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x06ca6351 + W[30]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x14292967 + W[31]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x27b70a85 + W[32]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x2e1b2138 + W[33]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x4d2c6dfc + W[34]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x53380d13 + W[35]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x650a7354 + W[36]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x766a0abb + W[37]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x81c2c92e + W[38]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x92722c85 + W[39]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0xa2bfe8a1 + W[40]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0xa81a664b + W[41]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0xc24b8b70 + W[42]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0xc76c51a3 + W[43]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0xd192e819 + W[44]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xd6990624 + W[45]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xf40e3585 + W[46]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x106aa070 + W[47]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x19a4c116 + W[48]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x1e376c08 + W[49]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x2748774c + W[50]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x34b0bcb5 + W[51]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x391c0cb3 + W[52]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0x4ed8aa4a + W[53]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0x5b9cca4f + W[54]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0x682e6ff3 + W[55]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; t1 = h + e1(e) + Ch(e, f, g) + 0x748f82ee + W[56]; t2 = e0(a) + Maj(a, b, c); d += t1; h = t1 + t2; t1 = g + e1(d) + Ch(d, e, f) + 0x78a5636f + W[57]; t2 = e0(h) + Maj(h, a, b); c += t1; g = t1 + t2; t1 = f + e1(c) + Ch(c, d, e) + 0x84c87814 + W[58]; t2 = e0(g) + Maj(g, h, a); b += t1; f = t1 + t2; t1 = e + e1(b) + Ch(b, c, d) + 0x8cc70208 + W[59]; t2 = e0(f) + Maj(f, g, h); a += t1; e = t1 + t2; t1 = d + e1(a) + Ch(a, b, c) + 0x90befffa + W[60]; t2 = e0(e) + Maj(e, f, g); h += t1; d = t1 + t2; t1 = c + e1(h) + Ch(h, a, b) + 0xa4506ceb + W[61]; t2 = e0(d) + Maj(d, e, f); g += t1; c = t1 + t2; t1 = b + e1(g) + Ch(g, h, a) + 0xbef9a3f7 + W[62]; t2 = e0(c) + Maj(c, d, e); f += t1; b = t1 + t2; t1 = a + e1(f) + Ch(f, g, h) + 0xc67178f2 + W[63]; t2 = e0(b) + Maj(b, c, d); e += t1; a = t1 + t2; state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; }</span></span></span></span></code> </pre><br>  Usar las funciones de plantilla C ++ es conveniente porque puedo calcular el hash que necesito a partir de datos regulares y obtener el resultado habitual: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> header[] = { <span class="hljs-number"><span class="hljs-number">0x02</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x5b</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0xc1</span></span>,<span class="hljs-number"><span class="hljs-number">0x8e</span></span>,<span class="hljs-number"><span class="hljs-number">0xd1</span></span>,<span class="hljs-number"><span class="hljs-number">0xf7</span></span>, <span class="hljs-number"><span class="hljs-number">0xe2</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>,<span class="hljs-number"><span class="hljs-number">0xad</span></span>,<span class="hljs-number"><span class="hljs-number">0xf2</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x59</span></span>,<span class="hljs-number"><span class="hljs-number">0x9b</span></span>,<span class="hljs-number"><span class="hljs-number">0x55</span></span>, <span class="hljs-number"><span class="hljs-number">0x33</span></span>,<span class="hljs-number"><span class="hljs-number">0x0e</span></span>,<span class="hljs-number"><span class="hljs-number">0xda</span></span>,<span class="hljs-number"><span class="hljs-number">0xb8</span></span>,<span class="hljs-number"><span class="hljs-number">0x78</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x8a</span></span>,<span class="hljs-number"><span class="hljs-number">0x97</span></span>,<span class="hljs-number"><span class="hljs-number">0x29</span></span>,<span class="hljs-number"><span class="hljs-number">0x5a</span></span>,<span class="hljs-number"><span class="hljs-number">0x27</span></span>,<span class="hljs-number"><span class="hljs-number">0x47</span></span>,<span class="hljs-number"><span class="hljs-number">0xb4</span></span>,<span class="hljs-number"><span class="hljs-number">0xf1</span></span>, <span class="hljs-number"><span class="hljs-number">0xa0</span></span>,<span class="hljs-number"><span class="hljs-number">0xb3</span></span>,<span class="hljs-number"><span class="hljs-number">0x94</span></span>,<span class="hljs-number"><span class="hljs-number">0x8d</span></span>,<span class="hljs-number"><span class="hljs-number">0xf3</span></span>,<span class="hljs-number"><span class="hljs-number">0x99</span></span>,<span class="hljs-number"><span class="hljs-number">0x03</span></span>,<span class="hljs-number"><span class="hljs-number">0x44</span></span>, <span class="hljs-number"><span class="hljs-number">0xc0</span></span>,<span class="hljs-number"><span class="hljs-number">0xe1</span></span>,<span class="hljs-number"><span class="hljs-number">0x9f</span></span>,<span class="hljs-number"><span class="hljs-number">0xa6</span></span>,<span class="hljs-number"><span class="hljs-number">0xb2</span></span>,<span class="hljs-number"><span class="hljs-number">0xb9</span></span>,<span class="hljs-number"><span class="hljs-number">0x2b</span></span>,<span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">0x19</span></span>,<span class="hljs-number"><span class="hljs-number">0xc8</span></span>,<span class="hljs-number"><span class="hljs-number">0xe6</span></span>,<span class="hljs-number"><span class="hljs-number">0xba</span></span>, <span class="hljs-number"><span class="hljs-number">0xdc</span></span>,<span class="hljs-number"><span class="hljs-number">0x14</span></span>,<span class="hljs-number"><span class="hljs-number">0x17</span></span>,<span class="hljs-number"><span class="hljs-number">0x87</span></span>, <span class="hljs-number"><span class="hljs-number">0x35</span></span>,<span class="hljs-number"><span class="hljs-number">0x8b</span></span>,<span class="hljs-number"><span class="hljs-number">0x05</span></span>,<span class="hljs-number"><span class="hljs-number">0x53</span></span>, <span class="hljs-number"><span class="hljs-number">0x53</span></span>,<span class="hljs-number"><span class="hljs-number">0x5f</span></span>,<span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x19</span></span>, <span class="hljs-number"><span class="hljs-number">0x48</span></span>,<span class="hljs-number"><span class="hljs-number">0x75</span></span>,<span class="hljs-number"><span class="hljs-number">0x08</span></span>,<span class="hljs-number"><span class="hljs-number">0x33</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> test_nonce = <span class="hljs-number"><span class="hljs-number">0x48750833</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> result[<span class="hljs-number"><span class="hljs-number">8</span></span>]; full_btc_hash(header, test_nonce, result); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>* presult = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * )result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%02X "</span></span>, presult[i]);</code> </pre><br>  Resulta que: <br><br>  92 98 2A 50 91 FA BD 42 97 8A A5 2D CD C9 36 28 02 4A DD FE E0 67 A4 78 00 00 00 00 00 00 00 00 00 <br><br>  Al final del hash hay muchos ceros, un hermoso hash, bingo, etc. <br><br>  Y ahora, adem√°s, puedo pasar no datos ordinarios de uint32_t a esta funci√≥n hash, sino mi clase especial de C ++, que redefinir√° toda la aritm√©tica. <br><br>  Si si.  Voy a aplicar las matem√°ticas probabil√≠sticas "alternativas". <br>  Lo invent√© yo mismo, me di cuenta, lo experiment√© yo mismo.  No parece funcionar muy bien.  Un chiste  Deber√≠a funcionar  Tal vez no soy el primero que estoy tratando de arrancar. <br><br>  Ahora pasamos a lo m√°s interesante. <br>  Toda la aritm√©tica en electr√≥nica digital se realiza como operaciones en bits, y est√° estrictamente definida por las operaciones AND, OR, NOT, EXCLUSIVE OR.  Bueno, todos sabemos qu√© tablas de verdad hay en √°lgebra booleana. <br><br>  Sugiero agregar un poco de incertidumbre a los c√°lculos, haci√©ndolos probabil√≠sticos. <br>  ¬°Deje que cada bit de la palabra tenga no solo los valores CERO y UNO posibles, sino tambi√©n todos los valores intermedios!  Propongo considerar el valor de un bit como la probabilidad de un evento que puede ocurrir o no.  Si todos los datos iniciales se conocen de manera confiable, entonces el resultado es confiable.  Y si faltan algunos datos, entonces el resultado resultar√° con cierta probabilidad. <br><br>  De hecho, suponga que hay dos eventos independientes ‚Äúa‚Äù y ‚Äúb‚Äù, cuya probabilidad de ocurrencia es naturalmente de cero a uno, respectivamente, Pa y Pb.  ¬øCu√°l es la probabilidad de que los eventos sucedan simult√°neamente?  ¬°Estoy seguro de que cada uno de nosotros no dudar√° en responder P = Pa * Pb y esta es la respuesta correcta! <br><br>  El gr√°fico 3D de dicha funci√≥n se ver√° as√≠ (desde dos puntos de vista diferentes): <br><br><img src="https://habrastorage.org/webt/-e/ll/pw/-ellpwuzq9bxl8fi_b3l1drhutc.png"><br><br>  ¬øY cu√°l es la probabilidad de que ocurra el evento Pa o el evento Pb? <br>  Probabilidad P = Pa + Pb-Pa * Pb.  El gr√°fico de funciones es as√≠: <br><br><img src="https://habrastorage.org/webt/vs/sd/wk/vssdwknevb1dijfbqcy3lsnib0w.png"><br><br>  Y si conocemos la probabilidad de que ocurra el evento Pa, ¬øcu√°l es la probabilidad de que el evento no ocurra? <br>  P = 1 - Pa. <br><br>  Ahora hagamos una suposici√≥n.  Imagine que tenemos elementos l√≥gicos que calculan la probabilidad de un evento de salida, conociendo la probabilidad de eventos de entrada: <br><br><img src="https://habrastorage.org/webt/tn/qk/-v/tnqk-v5-dce15dkr0-zsb1wmiww.gif"><br><br>  Tener tales elementos l√≥gicos puede hacerlos m√°s complejos, por ejemplo, exclusivos o XOR: <br><br><img src="https://habrastorage.org/webt/l0/e8/ju/l0e8judlmw-uh6plwsuj5sjnutq.png"><br><br>  Ahora, mirando el diagrama de este elemento l√≥gico XOR, podemos entender cu√°l ser√° la probabilidad del evento a la salida del XOR probabil√≠stico: <br><br><img src="https://habrastorage.org/webt/oj/xy/re/ojxyrexx8xkmcrmoyfohfl6bqyw.png"><br><br>  Pero eso no es todo.  Conocemos la l√≥gica t√≠pica de un sumador completo y descubrimos c√≥mo se hace un sumador de varios bits a partir de un sumador completo: <br><br><img src="https://habrastorage.org/webt/_s/fh/qs/_sfhqsmrhygqasjfv6inengna38.png"><br><br>  Entonces, de acuerdo con su esquema, ahora podemos calcular las probabilidades de las se√±ales en su salida, con probabilidades conocidas de las se√±ales en la entrada. <br><br>  Por lo tanto, puedo implementar en c ++ mi propia clase de "32 bits" (la llamar√© x32) con aritm√©tica probabil√≠stica, anular esta clase para todas las operaciones sha256 como AND, OR, XOR, ADD y turnos.  La clase almacenar√° 32 bits en su interior, pero cada bit es un n√∫mero de coma flotante.  Cada operaci√≥n l√≥gica o aritm√©tica en dicho n√∫mero de 32 bits calcular√° la probabilidad del valor de cada bit con par√°metros de entrada conocidos o poco conocidos de una operaci√≥n l√≥gica o aritm√©tica. <br><br>  Considere un ejemplo muy simple que usa mis matem√°ticas probabil√≠sticas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); x32 a = <span class="hljs-number"><span class="hljs-number">0xaabbccdd</span></span>; x32 b = <span class="hljs-number"><span class="hljs-number">0x12345678</span></span>; &lt;b&gt;<span class="hljs-comment"><span class="hljs-comment">//b.setBit( 4, 0.75 );&lt;/b&gt; x32 c = a + b; cout &lt;&lt; std::hex &lt;&lt; "result = 0x" &lt;&lt; c.get32() &lt;&lt; "\n" &lt;&lt; std::dec; for (int i = 0; i &lt; 32; i++) cout &lt;&lt; "bit" &lt;&lt; i &lt;&lt; " = " &lt;&lt; c.get_bvi(i) &lt;&lt; "\n"; cout &lt;&lt; "ok\n"; }</span></span></code> </pre><br>  En este ejemplo, se agregan dos n√∫meros de 32 bits. <br>  Mientras que la cadena es b.setBit (4, 0.75);  El resultado de la adici√≥n se comenta de manera exactamente predecible y predeterminada, porque se conocen todos los datos de entrada para la adici√≥n.  El programa imprime esto en la consola: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">result</span></span> = 0xbcf02355 bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Si descomento la l√≠nea b.setBit (4, 0.75); al hacer esto le dir√≠a al programa: "agr√©game estos dos n√∫meros, pero no s√© realmente el valor del bit 4 del segundo argumento, creo que es uno con una probabilidad de 0,75". <br><br>  Luego, la adici√≥n se produce, como deber√≠a ser, con un c√°lculo completo de las probabilidades de las se√±ales de salida, es decir, bits: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stable</span></span> result = <span class="hljs-number"><span class="hljs-number">0xbcf02305</span></span> bit0 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit1 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit2 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit3 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit4 = <span class="hljs-number"><span class="hljs-number">0.75</span></span> bit5 = <span class="hljs-number"><span class="hljs-number">0.1875</span></span> bit6 = <span class="hljs-number"><span class="hljs-number">0.8125</span></span> bit7 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit8 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit9 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit10 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit11 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit12 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit13 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit14 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit15 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit16 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit17 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit18 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit19 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit20 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit21 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit22 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit23 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit24 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit25 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit26 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit27 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit28 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit29 = <span class="hljs-number"><span class="hljs-number">1</span></span> bit30 = <span class="hljs-number"><span class="hljs-number">0</span></span> bit31 = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Debido al hecho de que los datos de entrada no eran muy conocidos, el resultado no es muy conocido.  Adem√°s, lo que se puede calcular de manera confiable se considera confiable.  Lo que no se puede contar se considera con probabilidad. <br><br>  Ahora que tengo una clase c ++ de 32 bits tan maravillosa para la aritm√©tica difusa, puedo pasar matrices de variables del tipo x32 a la funci√≥n full_btc_hash () en la plantilla y obtener un resultado hash estimado probabil√≠stico. <br><br><div class="spoiler">  <b class="spoiler_title">Algunas de las implementaciones de la clase x32 son:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;list&gt; #include &lt;iostream&gt; #include &lt;utility&gt; #include &lt;stdint.h&gt; #include &lt;vector&gt; #include &lt;limits&gt; using namespace std; #include &lt;boost/math/constants/constants.hpp&gt; #include &lt;boost/multiprecision/cpp_dec_float.hpp&gt; using boost::multiprecision::cpp_dec_float_50; //typedef double MY_FP; typedef cpp_dec_float_50 MY_FP; class x32 { public: x32(); x32(uint32_t n); void init(MY_FP val); void init(double* pval); void setBit(int i, MY_FP val) { bvi[i] = val; }; ~x32() {}; x32 operator|(const x32&amp; right); x32 operator&amp;(const x32&amp; right); x32 operator^(const x32&amp; right); x32 operator+(const x32&amp; right); x32&amp; x32::operator+=(const x32&amp; right); x32 operator~(); x32 operator&lt;&lt;(const unsigned int&amp; right); x32 operator&gt;&gt;(const unsigned int&amp; right); void print(); uint32_t get32(); MY_FP get_bvi(uint32_t idx) { return bvi[idx]; }; private: MY_FP not(MY_FP a); MY_FP and(MY_FP a, MY_FP b); MY_FP or (MY_FP a, MY_FP b); MY_FP xor(MY_FP a, MY_FP b); MY_FP bvi[32]; //bit values }; #include "stdafx.h" #include "x32.h" x32::x32() { for (int i = 0; i &lt; 32; i++) { bvi[i] = 0.0; } } x32::x32(uint32_t n) { for (int i = 0; i &lt; 32; i++) { bvi[i] = (n&amp;(1 &lt;&lt; i)) ? 1.0 : 0.0; } } void x32::init(MY_FP val) { for (int i = 0; i &lt; 32; i++) { bvi[i] = val; } } void x32::init(double* pval) { for (int i = 0; i &lt; 32; i++) { bvi[i] = pval[i]; } } x32 x32::operator&lt;&lt;(const unsigned int&amp; right) { x32 t; for (int i = 31; i &gt;= 0; i--) { if (i &lt; right) { t.bvi[i] = 0.0; } else { t.bvi[i] = bvi[i - right]; } } return t; } x32 x32::operator&gt;&gt;(const unsigned int&amp; right) { x32 t; for (unsigned int i = 0; i &lt; 32; i++) { if (i &gt;= (32 - right)) { t.bvi[i] = 0; } else { t.bvi[i] = bvi[i + right]; } } return t; } MY_FP x32::not(MY_FP a) { return 1.0 - a; } MY_FP x32::and(MY_FP a, MY_FP b) { return a * b; } MY_FP x32::or(MY_FP a, MY_FP b) { return a + b - a * b; } MY_FP x32::xor (MY_FP a, MY_FP b) { //(~(A &amp; B)) &amp; (A | B) return and( not( and(a,b) ) , or(a,b) ); } x32 x32::operator|(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = or ( bvi[i], right.bvi[i] ); } return t; } x32 x32::operator&amp;(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = and (bvi[i], right.bvi[i]); } return t; } x32 x32::operator~() { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = not(bvi[i]); } return t; } x32 x32::operator^(const x32&amp; right) { x32 t; for (int i = 0; i &lt; 32; i++) { t.bvi[i] = xor (bvi[i], right.bvi[i]); } return t; } x32 x32::operator+(const x32&amp; right) { x32 r; r.bvi[0] = xor (bvi[0], right.bvi[0]); MY_FP cout = and (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); r.bvi[i] = xor( xor_a_b, cout ); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); cout = or (and1,and2); } return r; } x32&amp; x32::operator+=(const x32&amp; right) { MY_FP cout = and (bvi[0], right.bvi[0]); bvi[0] = xor (bvi[0], right.bvi[0]); for (unsigned int i = 1; i &lt; 32; i++) { MY_FP xor_a_b = xor (bvi[i], right.bvi[i]); MY_FP and1 = and (bvi[i], right.bvi[i]); MY_FP and2 = and (xor_a_b, cout); bvi[i] = xor (xor_a_b, cout); cout = or (and1, and2); } return *this; } void x32::print() { for (int i = 0; i &lt; 32; i++) { cout &lt;&lt; bvi[i] &lt;&lt; "\n"; } } uint32_t x32::get32() { uint32_t r = 0; for (int i = 0; i &lt; 32; i++) { if (bvi[i] == 1.0) r = r | (1 &lt;&lt; i); else if (bvi[i] == 0.0) { //ok } else { //oops.. cout &lt;&lt; "bit not stable\n"; } } return r; }</span></span></span></span></code> </pre><br></div></div><br>  ¬øPara qu√© es todo esto? <br><br>  El minero de Bitcoin no sabe de antemano qu√© valor seleccionar 32x nonce.  El minero se ve obligado a iterar sobre los 4 mil millones de ellos para contar el hash hasta que se vuelva "hermoso", hasta que el valor del hash sea menor que el objetivo. <br><br>  La aritm√©tica probabil√≠stica difusa te√≥ricamente te permite deshacerte de la b√∫squeda exhaustiva. <br><br>  S√≠, inicialmente no s√© el significado de todos los bits sin sentido requeridos.  Si no los conozco, que no haya mierda, la probabilidad inicial de no bits es 0.5.  Incluso en este escenario, puedo calcular la probabilidad de bits hash de salida.  En alg√∫n lugar, tambi√©n resultan alrededor de 0,5 m√°s o menos medio centavo. <br><br> ,          0.5  0.9   0.1   1.0  ,            .       .                       . <br><br> ,  ,         ,       0.5   ,  ,    nonce[0] = 0.9: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &gt; dbl; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>.precision(dbl::max_digits10); <span class="hljs-comment"><span class="hljs-comment">//--------------------------------- //hash: 502A989242BDFA912DA58A972836C9CDFEDD4A0278A467E00000000000000000 const u8 strxx[] = { 0x02,0x00,0x00,0x00, 0x17,0x97,0x5b,0x97,0xc1,0x8e,0xd1,0xf7, 0xe2,0x55,0xad,0xf2,0x97,0x59,0x9b,0x55, 0x33,0x0e,0xda,0xb8,0x78,0x03,0xc8,0x17, 0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 0x8a,0x97,0x29,0x5a,0x27,0x47,0xb4,0xf1, 0xa0,0xb3,0x94,0x8d,0xf3,0x99,0x03,0x44, 0xc0,0xe1,0x9f,0xa6,0xb2,0xb9,0x2b,0x3a, 0x19,0xc8,0xe6,0xba, 0xdc,0x14,0x17,0x87, 0x35,0x8b,0x05,0x53, 0x53,0x5f,0x01,0x19, 0x48,0x75,0x08,0x33 }; double nonce_bits[32]; for (int i = 0; i &lt; 32; i++) nonce_bits[i] = 0.5; x32 nonce_x32_a; x32 nonce_x32_b; nonce_x32_a.init(nonce_bits); nonce_bits[0] = 0.9; nonce_x32_b.init(nonce_bits); x32 result_x32_a[8]; x32 result_x32_b[8]; full_btc_hash(strxx, nonce_x32_a, result_x32_a); full_btc_hash(strxx, nonce_x32_b, result_x32_b); for (int i = 0; i &lt; 32; i++) cout &lt;&lt; result_x32_a[7].get_bvi(i) &lt;&lt; " " &lt;&lt; result_x32_b[7].get_bvi(i) &lt;&lt; "\n";</span></span></code> </pre><br>   x32::get_bvi()      . <br>   ,      nonce[0]  0.5  0.9,        ,     : <br><br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540883948</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.44525679540840074</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.55268174813167364</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5526817481315932</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725359399</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57758654725360606</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978928474</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.49595026978930477</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561406703</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57118578561407746</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53237003739057907</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5323700373905661</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138096</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57269859374138162</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57631236396381141</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5763123639638157</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960149</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.47943176373960219</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54955992675177704</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5495599267517755</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879686</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53321116270879733</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744952</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57294025883744984</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387693</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53131857821387655</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899101</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57253530821899102</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287194</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.50661432403287198</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354913</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57149419848354916</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366491</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53220327148366487</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57268927270412251</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913003</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57632130426913005</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776142</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57233970084776143</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552812</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56824728628552813</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889921</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.45247155441889922</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.56875940568326509</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57524323439326321</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57587726902392535</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57597043124557292</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52847748894672118</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54512141953055808</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.57362254577539695</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53082194129771177</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54404489702929382</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.54065386336136847</span></span></code> </pre><br>   ,        10   .    ‚Ä¶      - .  , ? <br><br> ,       ,   ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nonce_bits[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; i++) nonce_bits[i] = (real_nonce32&amp;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; x32 nonce_x32; nonce_x32.init(nonce_bits); full_btc_hash(strxx, nonce_x32, result_x32);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luego, al calcular el hash probabil√≠stico, obtenemos el resultado l√≥gico correcto: un hash "hermoso" en la salida, bingo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, con las matem√°ticas, todo est√° aqu√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por aprender c√≥mo analizar el aliento de la brisa ... y el hash est√° roto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece una tonter√≠a, pero esto es una tonter√≠a, y advert√≠ desde el principio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros materiales √∫tiles:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minim Bitcoin con papel y bol√≠grafo.</font></font></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øEs posible calcular bitcoins m√°s r√°pido, m√°s f√°cil o m√°s f√°cil?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øC√≥mo hice blakecoin miner hacer</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGA Bitcoin miner en Mars rover board 3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPGA Miner con Algoritmo Blake</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420131/">https://habr.com/ru/post/es420131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420119/index.html">10 marcos web de Python con los que vale la pena trabajar en 2018</a></li>
<li><a href="../es420121/index.html">Prueba de resistencia: Termite LT450, LXI</a></li>
<li><a href="../es420123/index.html">¬øQu√© es realmente Node.js?</a></li>
<li><a href="../es420125/index.html">Automatizaci√≥n en finanzas: los empleados del banco pueden quedar sin trabajo debido a los robots</a></li>
<li><a href="../es420129/index.html">Patrones de rutina de Asyncio: afuera aguardan</a></li>
<li><a href="../es420133/index.html">Modelado de sistemas din√°micos: ¬øc√≥mo se mueve la luna?</a></li>
<li><a href="../es420135/index.html">Esto tambi√©n es Toshiba: productos inesperados de la corporaci√≥n japonesa</a></li>
<li><a href="../es420139/index.html">Libro "Ingenier√≠a de confiabilidad del sitio. Fiabilidad y fiabilidad como en Google ¬ª</a></li>
<li><a href="../es420141/index.html">Desde el MPP DBMS cargado - Data Lake lleno de vida con herramientas anal√≠ticas: comparta los detalles de la creaci√≥n</a></li>
<li><a href="../es420143/index.html">Rendimiento de Kotlin en Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>