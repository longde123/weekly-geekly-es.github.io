<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖼️ ☠️ 🃏 什么时候代码令人钦佩？ 🏇 🔄 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="理想的代码主题经常在经验丰富的程序员中引起争议。 得到Parallels RAS开发总监Igor Marnat的意见更加有趣。 根据削减，他的作者对宣布的话题的看法。 好好享受 



 作为引言，我想讨论为什么我决定写这篇简短的文章。 在编写它之前，我从标题向几个开发人员提出了一个问题。 我与大多...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>什么时候代码令人钦佩？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/parallels/blog/426679/"><img src="https://habrastorage.org/webt/ra/0s/yx/ra0syx2ovvhaqig6cdsntx297cw.png"><br><br> 理想的代码主题经常在经验丰富的程序员中引起争议。 得到Parallels RAS开发总监Igor Marnat的意见更加有趣。 根据削减，他的作者对宣布的话题的看法。 好好享受 <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/iy/ky/zg/iykyzgb9kkv_lvpvfplcfbbfqmm.png"><br><br> 作为引言，我想讨论为什么我决定写这篇简短的文章。 在编写它之前，我从标题向几个开发人员提出了一个问题。 我与大多数人一起工作了五年多，但与之合作的时间却有所减少，但我无条件地相信他们的专业知识和经验。 所有的工业发展经验都超过十年，每个人都在俄罗斯和国际公司，软件制造商工作。 <br><br> 一些同事发现很难回答（有些人仍然认为），另一些同事立刻举了一两个例子。 对于那些提供示例的人，我问了一个澄清的问题：“实际上是什么引起了这种钦佩？” 答案与我的小研究的下一阶段的结果一致。 我在网上搜索了该问题的答案，并采用了与文章标题相似的不同表述。 所有文章的回答方式与我的同志回答的方式大致相同。 <br><br> 开发人员的答案以及所发现文章的措辞与代码的可读性和结构，逻辑结构的优美性，现代编程语言的所有功能的使用以及遵循某种设计风格有关。 <br><br> 当我为自己问有关“神典”的问题时，答案立即从潜意识浮出水面。 我立即想到了已经使用了很长时间（十多年前）的两个代码示例，但是我仍然感到钦佩和崇敬。 考虑了每个人钦佩的原因后，我制定了几个标准，下面将进行讨论。 我将继续讲讲第一个例子，但我想更详细地分析第二个例子。 顺便说一句，在所有开发人员的史蒂夫·麦康奈尔（Steve McConnell）的手册“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Perfect Code</a> ”中，都在不同程度上考虑了所有这些条件，但是本文明显简短。 <br><br><h3>  <font color="#cc0000">90年代的例子</font> </h3><br> 我将提到的第一个示例与v42bis调制解调器协议的实现有关。 该协议开发于80年代末-90年代初。 该协议的开发者所体现的一个有趣的想法是在不稳定的（电话）通信线路上传输期间实现信息流的压缩。 流压缩和文件压缩之间的区别是根本的。 压缩文件时，存档器可以完全分析数据集，确定压缩和编码数据的最佳方法，并将整个数据写入文件，而不必担心可能的数据和元数据丢失。 反过来，解压缩时，数据集又可以完全访问，因此校验和可确保完整性。 使用在线压缩时，存档器只能访问一个小的数据窗口，不能保证不会丢失任何数据，需要重新安装连接并初始化压缩过程很常见。 <br><br> 该算法的作者找到了一个优雅的解决方案，其描述实际上需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几页</a> 。 已经过去了很多年，但是算法开发人员提出的方法的优美和优雅让我印象深刻。 <br><br> 这个示例仍然没有引用这样的代码，而是引用了算法，因此我们将不对其进行详细介绍。 <br><br><h3>  <font color="#cc0000">Linux是一切的负责人！</font> </h3><br> 我想更详细地分析第二个完美代码示例。 这是Linux内核代码。 在编写本文时，该代码控制着<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前500</a>名超级计算机中的500台超级计算机的运行，该代码在世界上每秒钟一部电话上运行，并且控制Internet上的大多数服务器。 <br><br> 例如，考虑<a href="">Linux内核中</a>的memory.c文件， <a href="">该</a>文件属于内存管理子系统。 <br><br>  <b>1.资料易于阅读。</b> 它们以非常简单的风格编写，易于遵循且难以混淆。 大写字符仅用于预处理器指令和宏，其他所有内容均以小写字母书写，名称中的单词用下划线分隔。 除了根本没有样式外，这可能是最简单的编码样式。 同时，该代码是完全可读的。 缩进和注释方法可以从任何内核文件的任何部分看到，例如： <br><br><pre><code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> tlb_remove_table_one(<span class="hljs-type"><span class="hljs-type">void</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) {     <span class="hljs-comment"><span class="hljs-comment">/*      * This isn't an RCU grace period and hence the page-tables cannot be      * assumed to be actually RCU-freed.      *      * It is however sufficient for software page-table walkers that rely on      * IRQ disabling. See the comment near struct mmu_table_batch.      */</span></span>     smp_call_function(tlb_remove_table_smp_sync, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);     __tlb_remove_table(<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>); }</code> </pre> <br><br>  <b>2.代码中没有太多注释，但是这些注释通常很有用。</b> 通常，它们描述的不是代码中已经显而易见的动作（无用注释的经典示例是“ cnt ++; //增量计数器”），而是该动作的上下文-为什么在此处执行，为什么在执行，为什么在这里，使用什么假设，将其连接在代码的其他位置。 例如： <br><br><pre> <code class="hljs java"><span class="hljs-comment"><span class="hljs-comment">/** * tlb_gather_mmu - initialize an mmu_gather structure for page-table tear-down * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@tlb</span></span></span><span class="hljs-comment">: the mmu_gather structure to initialize * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@mm</span></span></span><span class="hljs-comment">: the mm_struct of the target address space * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@start</span></span></span><span class="hljs-comment">: start of the region that will be removed from the page-table * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@end</span></span></span><span class="hljs-comment">: end of the region that will be removed from the page-table * * Called to initialize an (on-stack) mmu_gather structure for page-table * tear-down from </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@mm</span></span></span><span class="hljs-comment">. The </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@start</span></span></span><span class="hljs-comment"> and </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@end</span></span></span><span class="hljs-comment"> are set to 0 and -1 * respectively when </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@mm</span></span></span><span class="hljs-comment"> is without users and we're going to destroy * the full address space (exit/execve). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tlb_gather_mmu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mmu_gather *tlb, struct mm_struct *mm,            unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span></span></code> </pre><br><br> 内核中注释的另一种用法是描述更改的历史记录，通常是在文件的开头。 内核的历史已经有将近30年了，阅读一些地方很有趣，您会觉得自己是故事的一部分： <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* * demand-loading started 01.12.91 - seems it is high on the list of * things wanted, and it should be easy to implement. - Linus */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* * Ok, demand-loading was easy, shared pages a little bit tricker. Shared * pages started 02.12.91, seems to work. - Linus. * * Tested sharing by executing about 30 /bin/sh: under the old kernel it * would have taken more than the 6M I have free, but it worked well as * far as I could see. * * Also corrected some "invalidate()"s - I wasn't doing enough of them. */</span></span></code> </pre><br><br>  <b>3.内核代码使用特殊的宏来验证数据。</b> 它们还用于检查代码工作的上下文。 这些宏的功能类似于标准断言，不同之处在于，如果条件为真，则开发人员可以覆盖执行的操作。 内核中数据处理的一种通用方法-检查来自用户空间的所有内容，如果数据错误，则返回相应的值。 在这种情况下，可以使用WARN_ON向内核日志发出记录。 在调试新代码并在新体系结构上启动内核时，BUG_ON通常非常有用。 <br><br>  BUG_ON宏通常会导致寄存器和堆栈的内容被打印，并在发生相应调用的上下文中停止整个系统或进程。 如果条件为真，则WARN_ON宏仅向内核日志发出一条消息。 还有宏WARN_ON_ONCE和其他一些宏，它们的功能从名称中就很明显。 <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> unmap_page_range(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mmu_gather *tlb, ….     <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> next;    BUG_ON(addr &gt;= end);    tlb_start_vma(tlb, vma); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> apply_to_page_range(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> mm_struct *mm, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> addr, …    <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = addr + size;    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WARN_ON(addr &gt;= end))        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL;</code> </pre><br><br> 在使用前检查从不可靠来源获得的数据的方法，可以预见和确定系统对“不可能”情况的响应，这大大简化了系统的调试和操作。 您可以将这种方法视为“尽早失败”原则的一种实现。 <br><br>  <b>4.内核的所有主要组件都通过简单的界面（虚拟文件系统/ proc /）为用户提供有关其状态的信息。</b> <br><br> 例如，内存状态信息在/ proc / meminfo文件中可用 <br><br><pre> <code class="hljs mel">user@parallels-vm:/home/user$ cat /<span class="hljs-keyword"><span class="hljs-keyword">proc</span></span>/meminfo MemTotal:    <span class="hljs-number"><span class="hljs-number">2041480</span></span> kB MemFree:      <span class="hljs-number"><span class="hljs-number">65508</span></span> kB MemAvailable:   <span class="hljs-number"><span class="hljs-number">187600</span></span> kB Buffers:      <span class="hljs-number"><span class="hljs-number">14040</span></span> kB Cached:      <span class="hljs-number"><span class="hljs-number">246260</span></span> kB SwapCached:    <span class="hljs-number"><span class="hljs-number">19688</span></span> kB Active:     <span class="hljs-number"><span class="hljs-number">1348656</span></span> kB Inactive:     <span class="hljs-number"><span class="hljs-number">477244</span></span> kB Active(anon):  <span class="hljs-number"><span class="hljs-number">1201124</span></span> kB Inactive(anon):  <span class="hljs-number"><span class="hljs-number">387600</span></span> kB Active(<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>):   <span class="hljs-number"><span class="hljs-number">147532</span></span> kB Inactive(<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>):  <span class="hljs-number"><span class="hljs-number">89644</span></span> kB ….</code> </pre><br><br> 以上信息在内存管理子系统的几个源文件中收集和处理。 因此，第一个MemTotal字段是sysinfo结构的totalram字段的值，该字段由<a href="">page_alloc.c文件</a>的<a href="">si_meminfo</a>函数填充。 <br><br> 显然，组织收集，存储并为用户提供对此类信息的访问需要开发人员的努力和系统的一些开销。 同时，在开发过程和代码操作中，方便，轻松地访问此类数据的好处是无价的。 <br><br> 几乎所有系统的开发都应从收集和提供有关代码和数据内部状态信息的系统开始。 这将大大有助于开发和测试过程以及以后的运行。 <br><br> 正如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Linus所说</a> ：“糟糕的程序员担心代码。 好的程序员担心数据结构及其关系。“ <br><br>  <b>5.在提交之前，所有开发人员都会阅读和讨论所有代码。</b> 记录并更改了源代码的历史记录。 对任何行的更改都可以追溯到它的发生-更改的内容，更改的对象，时间，原因，开发人员讨论了哪些问题。 例如，代码memory.c中https://github.com/torvalds/linux/commit/1b2de5d039c883c9d44ae5b2b6eca4ff9bd82dac#diff-983ac52fa16631c1e1dfa28fc593d2ef中的更改是受https://bugzsh_b.bg?bg_b。对代码进行了小幅优化（如果内存已被写保护，则不会进行启用内存写保护的调用）。 <br><br> 对于使用代码的开发人员来说，了解此代码的上下文，创建代码的假设，更改的时间和时间始终很重要，以便了解哪些情况可能受到他将要进行的更改影响。 <br><br>  <b>6.记录和访问了内核代码生命周期的所有重要元素</b> ，从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编码风格</a>开始<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以发行稳定内核版本</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容和时间表</a>结束。 每个想要以一种或多种身份使用内核代码的开发人员和用户都具有与此相关的所有必要信息。 <br><br> 这些时刻对我来说似乎很重要，基本上，它们决定了我对核心代码的热情。 显然，该列表很短，可以扩展。 但是我认为，从开发人员的角度来看，以上列出的几点与任何源代码生命周期的关键方面有关。 <br><br> 最后我想说的是。 核心开发人员很聪明，经验丰富，他们成功了。 经过数十亿Linux设备的验证 <br><br> 作为内核开发人员，使用最佳实践并阅读Code Complete！ <br><br>  <b>Z.Y.</b> 顺便说一句，您个人对理想代码的标准是什么？ 在评论中分享您的想法。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426679/">https://habr.com/ru/post/zh-CN426679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426665/index.html">保罗·格雷厄姆汇报：Viaweb，1998年6月</a></li>
<li><a href="../zh-CN426667/index.html">Seymour Papert：“将计算机当作避孕套”</a></li>
<li><a href="../zh-CN426671/index.html">Google负责人评论了在中国推出具有审查制度的搜索引擎</a></li>
<li><a href="../zh-CN426675/index.html">基于OpenCV的行</a></li>
<li><a href="../zh-CN426677/index.html">YouTube服务的工作将近两个小时，现在该服务已开始运作</a></li>
<li><a href="../zh-CN426681/index.html">GitHub宣布了自己的CI / CD，并开始分发邀请</a></li>
<li><a href="../zh-CN426685/index.html">我们通过智能手机的语音和文本控制数百种不同的智能家居设备。 信使中的Alexa Echo</a></li>
<li><a href="../zh-CN426687/index.html">用有限的预算制作机器人机壳。 真空成型</a></li>
<li><a href="../zh-CN426689/index.html">我们对别人的市场负责：社交网络对CRM的评价</a></li>
<li><a href="../zh-CN426691/index.html">程序员请病假</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>