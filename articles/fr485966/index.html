<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞ ü•£ üßëüèø‚Äçü§ù‚Äçüßëüèø Adaptateur USB-SATA invers√© (historique d'un stagiaire) üòú üåè üèÇüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contexte 


 Le stage est le processus d'acquisition de connaissances et d'exp√©rience. Notre √©quipe Raccoon Security estime qu'il est impossible d'am√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Adaptateur USB-SATA invers√© (historique d'un stagiaire)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Contexte </h1><br><p>  Le stage est le processus d'acquisition de connaissances et d'exp√©rience.  Notre √©quipe Raccoon Security estime qu'il est impossible d'am√©liorer la s√©curit√© des informations des appareils et des logiciels qui nous entourent sans transmettre ces connaissances et cette exp√©rience aux g√©n√©rations futures de sp√©cialistes.  C'est pourquoi nous organisons des stages individuels pour des √©tudiants et dipl√¥m√©s talentueux depuis de nombreuses ann√©es. </p><br><p>  La recherche sur la s√©curit√© est une comp√©tence qui n'est pas enseign√©e √† l'universit√©.  Vous pouvez l'apprendre √† partir d'exemples concrets et sous la direction de mentors exp√©riment√©s.  Chaque ann√©e, nos stagiaires r√©solvent des probl√®mes techniques complexes, atteignent leurs objectifs et progressent, √©largissant leurs horizons professionnels et rendant le monde un peu plus s√ªr.  Chacun d'eux a sa propre histoire de devenir un sp√©cialiste, et sous la coupe - le d√©but de l'un d'eux. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  Pr√©sentation </h1><br><p>  En octobre de l'ann√©e derni√®re, je suis venu pour un stage technique au sein de la soci√©t√© NTC Vulkan.  Mon int√©r√™t √©tait dirig√© vers le domaine de la r√©tro-ing√©nierie.  Je savais ce que c'√©tait, j'avais d√©j√† essay√© de rechercher ind√©pendamment crackme sous x86, mais j'ai compris que la chose la plus int√©ressante se situe pr√©cis√©ment √† la jonction du logiciel et du mat√©riel.  Je n'avais pas d'exp√©rience dans ce domaine, mais j'avais envie de m'essayer. </p><br><p> Je n'avais aucune attente particuli√®re de cet √©v√©nement - des amis et des connaissances parlent souvent de stages techniques dans diverses entreprises bien connues.  Et quand on m'a propos√© de m'essayer √† la recherche d'un adaptateur USB-SATA, j'√©tais simplement heureux de la nouvelle opportunit√© d'apprendre quelque chose.  L'exp√©rience acquise et le r√©sultat que j'ai obtenu ont permis de v√©rifier l'exactitude du choix du lieu de stage et du futur m√©tier. </p><br><p>  Et l'√©tude a commenc√© avec la disponibilit√© d'un adaptateur USB-SATA standard.  Voici ce que j'ai fait ensuite. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  Analyse visuelle des circuits </h1><br><p>  Vous devez d'abord inspecter la carte adaptateur et d√©terminer les √©l√©ments de base de l'appareil.  Dans les figures ci-dessous, les principaux blocs de composants importants pour le fonctionnement de l'appareil sont marqu√©s.  Photos prises apr√®s la recherche: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>Adaptateur USB vers SATA.</em>  <em>Vue de dessus</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>Adaptateur USB vers SATA.</em>  <em>Vue de dessous</em> </p><br><p>  Apr√®s avoir pass√© un peu de temps sur Google, j'ai d√©couvert qu'il y avait deux convertisseurs de tension sur la carte: l'un √† 3,3 V, l'autre √† 1,2 V.Il est √©galement tr√®s facile de d√©terminer la m√©moire flash install√©e sur la carte.  La ROM fonctionne sur l'interface SPI et la capacit√© de m√©moire est de 512 Kbps. </p><br><p>  Il semblerait que l'√©tape de reconnaissance des circuits soit presque termin√©e, mais une recherche rapide sur Internet n'a donn√© aucun r√©sultat pour la requ√™te ¬´ASM1051¬ª.  Aucun document n'a √©t√© trouv√© pour la puce install√©e sur la carte.  Certes, toujours r√©ussi √† trouver un logiciel qui vous permet de le mettre √† jour.  En outre, il existe une petite <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">fiche technique</a> pour l'ancien mod√®le <strong>ASM1053</strong> . </p><br><h1 id="usb">  USB </h1><br><p>  Lorsqu'il est connect√© √† un ordinateur, l'adaptateur appara√Æt comme un p√©riph√©rique de stockage USB.  J'ai d√©cid√© qu'une connaissance plus approfondie de l' <a href="https://ru.wikipedia.org/wiki/USB">USB</a> serait probablement utile pour mes recherches, donc les deux prochaines heures que j'ai pass√©es √† √©tudier l'interface. <br>  En g√©n√©ral, les p√©riph√©riques USB peuvent √™tre de diff√©rentes classes, selon leur fonctionnalit√©.  Par exemple, les lecteurs flash sont le p√©riph√©rique de stockage de masse, et les claviers et les souris sont le <a href="https://ru.wikipedia.org/wiki/USB_HID">p√©riph√©rique d'interface humaine (HID)</a> .  Et puisque mon adaptateur est visible dans le gestionnaire de p√©riph√©riques en tant que p√©riph√©rique de stockage, cela signifie qu'il est d√©fini en tant que stockage de masse et devrait fonctionner avec les commandes SCSI. </p><br><div class="spoiler">  <b class="spoiler_title">Documentation USB de base utile</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB en bref</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Classe de stockage de masse de bus s√©rie universel</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">Classe de stockage de masse USB sur un p√©riph√©rique int√©gr√©</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manuel de r√©f√©rence des commandes SCSI</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Lire la m√©moire de la ROM </h1><br><p>  Comme on ne sait rien de l'ASM1051 install√© sur la carte, la m√©moire de la ROM a √©t√© consid√©r√©e comme l'action la plus √©vidente.  J'ai d√©m√©nag√© au laboratoire.  Il a s√©par√© la puce de m√©moire flash avec un s√®che-cheveux √† souder et l'a connect√©e au programmateur ChipProg-48 USB.  Il n'y a eu aucun probl√®me de lecture et j'avais un fichier binaire sur les mains.  √Ä ce moment-l√†, je ne pouvais pas dire ce qui √©tait sur le lecteur flash et j'ai commenc√© √† analyser les donn√©es. </p><br><h1 id="analiz-binarnogo-fayla">  Analyse de fichiers binaires </h1><br><p>  Tout d'abord, j'ai ouvert un vidage de m√©moire √† partir de la ROM √† l'aide de WinHex, mais vous pouvez utiliser n'importe quel √©diteur HEX.  A commenc√© √† regarder les octets: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>D√©but d'un vidage de m√©moire lu √† partir de la ROM</em> </p><br><p> La capture d'√©cran ci-dessus est une capture d'√©cran de l'√©diteur.  La ligne <code>ASMT1051</code> , qui commence par l'adresse 0x44, est imm√©diatement √©vidente.  Vous pouvez √©galement voir la ligne <code>asmedia</code> partir de l'adresse 0x18.  Pour l'analyse initiale des donn√©es, j'ai utilis√© l'outil d'analyse de fr√©quence, qui est disponible dans WinHex. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histogramme d'analyse de fr√©quence de la m√©moire ROM</em> </p><br><p>  L'histogramme montre les octets les plus pr√©sents dans le fichier.  En plus du tas 0x00 et 0xFF (les colonnes extr√™mes de l'histogramme), les octets suivants se trouvent souvent en m√©moire: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Il serait possible de confirmer mon hypoth√®se qu'il existe un firmware dans la ROM.  Un moyen facile de le faire est d'essayer de comparer les <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">opcodes de</a> diff√©rentes architectures adapt√©es aux microcontr√¥leurs (ci-apr√®s - MC) avec des octets qui se trouvent souvent en m√©moire. </p><br><p>  Si grossi√®rement estim√©, alors tr√®s souvent dans n'importe quel code de l'assembleur devrait r√©pondre des commandes telles que: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  appeler; </li><li>  ret. </li></ul><br><p>  Bien s√ªr, dans diff√©rentes architectures, ces commandes peuvent avoir diff√©rentes variations, mais il y a un bon sens. </p><br><p>  J'ai d√ª passer par plusieurs ensembles d'instructions pour diff√©rents noyaux avant de trouver les bons.  La comparaison avec l'architecture d' <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051 a</a> donn√© un r√©sultat tr√®s plausible.  Les opcodes de certaines <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">commandes</a> co√Øncident avec les octets populaires d'un fichier, par exemple: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - MOV DPTR, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Il semble vraiment qu'il existe un firmware pour MK dans la ROM.  On pouvait imm√©diatement charger le binaire dans le <a href="https://www.hex-rays.com/products/ida/index.shtml">d√©monteur IDA Pro</a> , mais au d√©jeuner, l'un des coll√®gues a demand√©: </p><br><blockquote>  <em>"√ätes-vous s√ªr que le code en m√©moire commence exactement √† partir de l'adresse z√©ro?"</em> </blockquote><p>  Et vraiment, vous devez tenir compte du fait que certaines ¬´ordures¬ª ou donn√©es de l'adresse 0x00 peuvent √™tre en m√©moire. </p><br><p>  En g√©n√©ral, j'ai √©t√© confront√© √† la t√¢che de d√©terminer l'adresse de d√©part du code.  Pour atteindre cet objectif, il √©tait pr√©f√©rable d'utiliser l'√©mulateur <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI.  L'√©mulateur remplace la puce de m√©moire sur la carte, avec elle il n'est pas n√©cessaire de souder la ROM √† chaque fois avec le firmware, en plus, l'EM100 peut enregistrer un journal d'acc√®s √† la m√©moire.  √âtant donn√© que le firmware de la ROM a d√©j√† √©t√© lu, vous pouvez maintenant le t√©l√©charger sur l'√©mulateur SPI.  Ensuite, vous devez souder l'√©mulateur sur la carte adaptateur et enregistrer un journal lors de la connexion de l'adaptateur via USB √† un PC. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>L'√©mulateur SPI est soud√© √† la carte adaptateur USB-SATA</em> </p><br><p>  J'ai soud√© le c√¢blage de l'√©mulateur aux pads de la m√©moire flash et flash√© l'√©mulateur avec quelques firmware.  Il reste maintenant √† voir si MK adresse la m√©moire, et si oui, √† quelles adresses. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM d'acc√®s √† la m√©moire ROM (obtenue √† l'aide du logiciel d'√©mulation SPI)</em> </p><br><p>  La figure ci-dessus montre que lorsque l'alimentation est connect√©e √† l'adaptateur, le contr√¥leur ASM1051 install√© sur la carte envoie plusieurs commandes 0x03 (lecture des donn√©es). </p><br><p>  Tout d'abord, l'ASM1051 lit 0x80 octets, en commen√ßant √† 0x0000.  Voici deux octets, en commen√ßant √† l'adresse 0x0080, puis deux autres octets √† partir de l'adresse 0x8082.  Il lit ensuite la majeure partie de la m√©moire de la ROM, √† partir de l'adresse 0x0082. </p><br><p>  Nous pouvons supposer qu'un grand nombre d'octets lus dans la ROM en dernier, en commen√ßant par l'adresse 0x0082, est probablement le code.  Quoi et pourquoi est demand√© avant cela n'est pas encore clair.  On sait seulement qu'en r√©ponse √† la premi√®re demande, l'ASM1051 recevra des lignes de la m√©moire flash qui sont marqu√©es dans la figure ci-dessus.  Ils √©taient juste situ√©s dans les premiers octets 0x80. </p><br><p>  Il est temps de v√©rifier que la m√©moire externe de la carte contient le firmware pour MK avec le noyau 8051, et le code lui-m√™me se trouve √† partir de l'adresse 0x0082.  Ouvrez le vidage de m√©moire dans IDA Pro, sp√©cifiez le type de processeur Intel 8051 et le d√©calage pour le code 0x0082. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>Fichier binaire ouvert dans IDA Pro avec d√©calage 0x82</em> </p><br><p>  Il n'y a eu aucun probl√®me d'ouverture du binaire dans le d√©sassembleur. </p><br><p>  <strong><em>Conclusions:</em></strong> </p><br><ol><li>  MK ASM1051 a une architecture 8051. </li><li>  Dans la ROM, il existe un code qui commence par l'adresse 0x82.  Il y a autre chose que le code. </li><li>  Les premiers 0x80 octets attirent l'attention. </li></ol><br><h1 id="analiz-koda">  Analyse de code </h1><br><p>  Maintenant que je me suis assur√© que le code dans l'IDA est correctement charg√©, vous pouvez commencer √† l'analyser et √† le commenter en parall√®le. </p><br><p>  Au cours de l'√©tude du code, des fonctions simples ont √©t√© trouv√©es, telles que la soustraction de nombres 32 bits, divers gestionnaires, similaires √† <code>switch ()</code> dans S.Melkali, et des fonctions tr√®s simples, telles que le stockage de la valeur du registre R7 en m√©moire √† une certaine adresse.  Les d√©couvertes les plus importantes que je d√©crirai ci-dessous. </p><br><h2 id="nahodka--1">  Trouver n ¬∞ 1 </h2><br><p>  Fait int√©ressant, en r√©ponse √† ma demande de RENSEIGNEMENT ( <a href="https://en.wikipedia.org/wiki/SCSI_command">commande SCSI</a> ), j'ai re√ßu une r√©ponse contenant deux lignes que nous avons vues au d√©but de la m√©moire ROM.  Bien s√ªr, j'ai imm√©diatement chang√© ces lignes dans la m√©moire de l'√©mulateur, en attendant une demande d'ENQU√äTE pour voir ce que j'ai √©crit.  Un tel r√™ve na√Øf s'est rapidement effondr√©.  Maintenant, en r√©ponse √† la commande, j'ai vu une autre ligne, l'ASM1051 n'a pas demand√© la majeure partie de la m√©moire de la ROM.  MK ne lit que les premiers 0x80 octets et tout.  Dans l'architecture du 8051, le firmware du masque (mat√©riel) peut √™tre utilis√©, apparemment, l'ASM1051 a commenc√© √† d√©marrer √† partir de celui-ci. </p><br><p>  Il est donc devenu clair que les premiers octets 0x80 sont vraiment importants, et les modifier ne fonctionnera tout simplement pas.  J'ai d√©cid√© d'√©tudier plus en d√©tail les requ√™tes que MK fait sur SPI avant de t√©l√©charger le code. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>Demande de donn√©es SPI dans la ROM</em> </p><br><p>  Deux requ√™tes de deux octets semblaient int√©ressantes.  La recherche dans IDA 0x00, 0x80 et 0xEB a donn√© un grand nombre de r√©sultats que je n'ai pas analys√©s, mais l'octet 0x5A est apparu moins souvent. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Comparaison avec l'octet 0x5A.</em>  <em>Comptage de la somme de contr√¥le-8</em> </p><br><p>  Litt√©ralement, le sixi√®me clic m'a conduit √† la section de code illustr√©e dans la figure ci-dessus.  On peut voir que la valeur du registre avec l'adresse 0x80 <strong>7E est</strong> compar√©e √† 0x5A.  Ensuite, la somme de contr√¥le-8 est lue pour les valeurs situ√©es de l'adresse 0x80 <strong>04</strong> √† 0x80 <strong>7E</strong> .  Ensuite, la valeur √† 0x80 <strong>7F est</strong> compar√©e au montant re√ßu pr√©c√©demment. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>Le d√©but de la m√©moire dans la ROM</em> </p><br><p>  Ces d√©calages ressemblaient au d√©but d'un vidage de m√©moire √† partir de la ROM.  La figure ci-dessus montre que l'adresse 0x7E contient l'octet 0x5A.  Et si vous comptez la somme de contr√¥le-8 pour les octets de la position 0x04 √† 0x7E, alors nous obtenons 0xA7, et cette valeur se trouve simplement √† l'adresse 0x7F. </p><br><p>  De mani√®re similaire, nous avons r√©ussi √† trouver le calcul de la somme de contr√¥le des octets de l'adresse 0x0082 √† 0x807F (apparemment, c'est le code entier), qui est v√©rifi√©e avec l'octet √† l'adresse 0x8083.  Et √† 0x8082 se trouve √† nouveau la valeur 0x5A. </p><br><p>  Oui, c'est un peu plus compliqu√© que de simplement changer les lignes en m√©moire.  Je les ai √©galement modifi√©s, mais j'ai √©galement calcul√© et not√© les sommes de contr√¥le pour le nouveau fichier aux bons endroits.  Apr√®s cela, en r√©ponse √† la commande SCSI INQUIRY, j'ai vu mes lignes. </p><br><p>  <strong><em>Conclusions:</em></strong> </p><br><ol><li>  Lors du d√©marrage, l'ASM1051 tente de t√©l√©charger le code √† partir de la ROM. </li><li>  Tout d'abord, l'ASM1051 compare l'octet de somme de contr√¥le 8 de l'adresse 0x04 √† 0x7E avec la valeur √† 0x7F. </li><li>  Si la comparaison de la somme de contr√¥le du pr√©ambule est r√©ussie, alors nous pouvons le consid√©rer pour le "code" (adresses de 0x0082 √† 0x807F).  L'ASM1051 compare ce montant √† la valeur √† l'adresse 0x8083 et v√©rifie que l'octet 0x5A se trouve √† l'adresse 0x8082. </li><li>  Si toutes les v√©rifications sont correctes, l'ASM1051 est charg√© √† partir de la ROM, sinon il utilise le firmware du masque. </li></ol><br><h2 id="nahodka--2">  Trouver le num√©ro 2 </h2><br><p>  En examinant et en commentant les fonctions, j'ai trouv√© que tr√®s souvent la fonction PRINTF est utilis√©e dans le code (je l'ai appel√© ainsi).  La chose int√©ressante √† ce sujet est qu'avant son appel, un caract√®re <strong>imprim√©</strong> est √©crit dans le registre R7. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>Fonction PRINTF dans IDA Pro</em> </p><br><p>  La fonction elle-m√™me a √©t√© pr√©sent√©e dans la figure ci-dessus.  Traitons-la.  Tout d'abord, vous devez d√©placer la valeur du registre avec l'adresse 0x7F6 vers la batterie.  S'il y a z√©ro, quittez la fonction.  La chose la plus int√©ressante se produit s'il n'y a pas z√©ro.  Ensuite, la valeur du registre R7 est d√©plac√©e vers le registre avec l'adresse 0xC001, et, comme nous le rappelons, avant d'appeler cette fonction, un caract√®re imprim√© est √©crit dans R7.  Ensuite, v√©rifiez si la valeur de R7 est √©gale au code de caract√®re "." Ou "-", sinon, quittez la fonction.  Mais si la comparaison s'est av√©r√©e r√©ussie, la fonction prend la valeur du registre avec l'adresse 0x16A et la d√©place vers 0xC001, mais la rend d√©licate.  Par exemple, au lieu de l'octet <strong>0x41</strong> (caract√®re "A" en ASCII), la fonction passera √† 0xC001 octet 0x34 (caract√®re <strong>"4"</strong> en ASCII), puis 0x31 (caract√®re <strong>"1"</strong> en ASCII).  Quittez √† nouveau la fonction. </p><br><p>  J'ai d√©couvert que la v√©rification au d√©but de la fonction ne peut pas √™tre pass√©e, car le registre avec l'adresse 0x7F6 est initialis√© √† z√©ro, alors il ne change pas dans le code.  Autrement dit, cette fonction est d√©sactiv√©e par le programmeur, bien qu'elle reste compil√©e.  Le fait que les octets ne soient √©crits que dans le registre 0xC001 (et parfois deux de suite), sugg√®re qu'il s'agit tr√®s probablement d'un registre mat√©riel. </p><br><p>  Tout cela ressemble √† UART.  Pour savoir si tel est le cas, vous devez proc√©der comme suit: </p><br><ol><li>  Identifiez les jambes sur l'ASM1051 o√π l'UART est sorti. </li><li>  D√©finissez les param√®tres UART (vitesse, parit√©, nombre de bits d'arr√™t). </li><li>  Ce serait bien d'activer UART dans le code (apparemment, il est d√©sactiv√©). </li></ol><br><p>  Tout semble assez simple: vous pouvez √† tour de r√¥le toucher les jambes avec un analyseur logique et rechercher celui sur lequel le moment de l'envoi de l'UART sera visible.  En pr√©sence d'un signal, la vitesse peut √™tre d√©termin√©e par le temps des impulsions.  Avec le reste des param√®tres, tout est √©galement clair, il suffit de voir le moment de l'envoi d'un octet sur l'analyseur. </p><br><p>  Pour "activer" cette fonction, vous pouvez √©crire des z√©ros au lieu des trois premi√®res lignes, o√π la valeur est v√©rifi√©e dans le registre avec l'adresse 0x7F6.  Pour ce faire, j'ouvre √† nouveau le firmware dans WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Six octets √† r√©initialiser sont allou√©s.</em> </p><br><p>  Dans l'√©diteur, je change les six octets souhait√©s en z√©ros.  Le firmware est maintenant pr√™t et peut √™tre t√©l√©charg√© sur l'√©mulateur ROM.  Si nous supposons que la fonction de sortie d'octets dans UART est activ√©e et que son appel se trouve tr√®s souvent dans le code, nous pouvons nous attendre √† ce que les octets "volent" de l'UART lorsque l'adaptateur est en cours d'ex√©cution.  J'esp√®re voir un traceur qui signale en octets dans l'UART combien de code est ex√©cut√©. </p><br><p>  Comme je l'ai √©crit ci-dessus, afin de trouver les jambes Rx et Tx n√©cessaires, vous pouvez regarder l'analyseur logique un par un.  Cependant, j'ai suppos√© que le Rx et le Tx sur l'ASM1051 sont au m√™me endroit que l'ASM1053 - les jambes 40 et 41, respectivement.  Je mets la sonde de l'analyseur sur la broche 41 (suppos√© Tx) et je vois quelque chose de similaire au signal souhait√©: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Diagramme de synchronisation avec la jambe 41 - Tx</em> </p><br><p>  Afin de connecter le convertisseur USB-UART et d'observer les caract√®res imprim√©s entrants dans le terminal, j'ai d√ª souder deux c√¢bles fins directement sur la carte adaptateur et le fixer avec de la colle chaude. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Deux c√¢bles soud√©s √† RX et TX</em> </p><br><p>  J'ai √©tudi√© un peu le diagramme de la figure ¬´Diagramme temporel de l'√©tape 41 - Tx¬ª: le temps d'une impulsion, apparemment, est de 1 Œºs, et pour six bits, il est de 6,3 Œºs.  Apr√®s avoir recalcul√© la valeur en bauds, j'ai re√ßu environ 950 000 bauds, la vitesse UART standard la plus proche √©tant de 921600 bauds.  Je pense que cet √©cart est obtenu en raison de l'erreur de mesure de l'analyseur logique, je n'ai pas pris l'appareil le plus digne, mais le ¬´b√©b√©¬ª chinois.  Apr√®s avoir r√©gl√© les param√®tres dans la fen√™tre du programme Terminal 1.9b, j'ai pu observer les octets entrants de l'ASM1051 MK pendant son fonctionnement. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Fen√™tre de programme du terminal 1.9b pendant le fonctionnement de l'adaptateur</em> </p><br><p>  <strong><em>Conclusion:</em></strong> </p><br><p>  L'ASM1051 MK poss√®de un module mat√©riel UART.  Le registre d'envoi de donn√©es a l'adresse 0xC001.  Le d√©bit de donn√©es est de 921600 bauds.  Il y a un bit d'arr√™t.  La jambe 41 est Tx et la jambe 40 est Rx (bien que ce ne soit pas exact). </p><br><h2 id="nahodka--3">  Trouver le num√©ro 3 </h2><br><p>  En faisant d√©filer le code dans le d√©sassembleur, en ajoutant des commentaires, vous pouvez trouver des constructions plus difficiles que d'√©crire un nombre dans un registre.  Je suis donc tomb√© sur un gestionnaire int√©ressant, dont une partie en C, ressemblait √† <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>Le gestionnaire de commandes du registre avec l'adresse 0x800F</em> </p><br><p>  Comprenant que quelque part quelque part les <a href="https://en.wikipedia.org/wiki/SCSI_command">commandes SCSI</a> doivent √™tre trait√©es, j'ai commenc√© √† chercher parmi eux des octets avec lesquels le contenu du registre avec l'adresse 0x800F est compar√© dans la figure ci-dessus.  Il s'est av√©r√© que les quatre premi√®res branches v√©rifient les commandes Read (10), Write (10), Read (16), Write (16).  Il ne fait aucun doute qu'il s'agit d'un gestionnaire de commandes SCSI.  Ensuite, j'ai regard√© une fonction qui est appel√©e si la commande qui est entr√©e n'est pas en lecture / √©criture (u_Switch).  Il, en fonction de l'octet dans le registre avec l'adresse 0x16A (la valeur est tir√©e de 0x800F), lit l'adresse √† laquelle nous obtiendrons lorsqu'ils quitteront cette fonction.  Ceci est similaire √† <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>Commuter les commandes SCSI</em> </p><br><p>  Comme j'ai d√©j√† d√©termin√© l'octet avec lequel je compare la commande SCSI qui est entr√©e dans l'adaptateur, j'ai rapidement arrang√© la correspondance des adresses par commandes.  Ainsi, par exemple, dans la figure ci-dessus, on voit que si l'octet 0x1A √©tait dans le registre avec l'adresse 0x16A, alors apr√®s avoir quitt√© la fonction u_Switch, nous irions √† l'adresse 0x1B85.  Fait int√©ressant, tous les octets par rapport √† u_Switch ne sont pas d√©finis dans la norme SCSI.  Autrement dit, l'adaptateur peut traiter les octets 0xE6 ou 0xDF, mais ils ne sont pas fix√©s par la norme. </p><br><p>  Comme vous pouvez le voir, l'adaptateur peut ex√©cuter des commandes personnalis√©es et il existe des fonctions de gestionnaire pour elles. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>Page 13 de la <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">classe Universal Serial Bus Mass Storage</a></em> </p><br><p>  Faites attention au d√©calage <strong>0x0F par</strong> rapport √† l'adresse 0x8000.  Avant le processeur, c'est √† partir du registre avec l'adresse 0x800F que la commande SCSI est lue.  Si vous lisez attentivement le tableau de la figure ci-dessus, vous pouvez voir que dans le wrapper de bloc de commande (CBW), le champ CBWCB a √©galement un d√©calage de <strong>0x0F</strong> .  Il s'av√®re que les adresses de la m√©moire RAM ASM1051, en commen√ßant par 0x8000, peuvent √™tre un tampon USB, comme indiqu√© dans le tableau ci-dessous. </p><br><div class="scrollable-table"><table><thead><tr><th>  Adresse m√©moire </th><th>  La description </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - en cas de r√©ception d'un paquet) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCBLength </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB - Commande SCSI et ses param√®tres </td></tr></tbody></table></div><br><p>  La figure ci-dessous montre la section de code o√π la comparaison avec la cha√Æne USBC se produit (telle devrait √™tre la signature dCBWSignature) et la signature propos√©e se trouve √† partir de l'adresse 0x8000.  Je pense que cela suffit pour vous assurer que le tampon USB est situ√© dans la m√©moire RAM √† partir de 0x8000. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>V√©rifiez le champ dCBWSignature pour une correspondance avec la cha√Æne USBC</em> </p><br><p>  <strong><em>Conclusions:</em></strong> </p><br><ol><li>  MK ASM1051 peut g√©rer non seulement les commandes SCSI, qui sont d√©crites dans la norme. </li><li>  L'adresse de d√©part du tampon USB est 0x8000.  La commande SCSI se trouve dans le registre avec l'adresse 0x800F, ce qui signifie qu'il y aura d'autres donn√©es / arguments des commandes. </li></ol><br><h2 id="nahodka--4">  Trouver le num√©ro 4 </h2><br><p>  Sachant que MK peut traiter des √©quipes non standard, je voulais savoir ce qu'elles faisaient.  La plupart d'entre eux m'ont rapidement ob√©i.  Je ne citerai pas l'√©tude du code de ces commandes, car cela peut prendre beaucoup de temps et peut √™tre important pour un article s√©par√© intitul√© ¬´L'assembleur est simple¬ª, je d√©crirai les r√©sultats dans le tableau ci-dessous. </p><br><div class="scrollable-table"><table><thead><tr><th>  Commande SCSI </th><th>  Description de l'√©quipe </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Vous permet de lire les premiers octets 0x80 de la ROM.  √Ä l'avenir, j'appellerai cette partie de la m√©moire le <em>pr√©ambule</em> (oui, ces m√™mes 0x80 octets dans lesquels il y a des lignes <code>asmedia</code> et <code>ASM1051</code> ) </td></tr><tr><td>  0xE1 </td><td>  √âcrit les premiers 0x80 octets dans la ROM </td></tr><tr><td>  0xE3 </td><td>  Les √©critures dans la m√©moire ROM √† partir de 0x80 adressent n'importe quel nombre d'octets.  L'argument (comme il s'est av√©r√©) est la taille du paquet </td></tr><tr><td>  0xE4 </td><td>  Lit le bloc d'octets de la RAM ASM1051.  Comme argument, prend l'adresse de d√©part et le nombre d'octets que nous lisons </td></tr><tr><td>  0xE5 </td><td>  √âcrit un octet dans la RAM √† </td></tr><tr><td>  0xE7 </td><td>  Lit le dernier paquet re√ßu dans le tampon ATA. </td></tr><tr><td>  0xE8 </td><td>  Red√©marre l'appareil </td></tr></tbody></table></div><br><p>  J'avoue que je n'ai pas compris toutes les commandes en lisant les fonctions dans l'IDA.  Ayant heurt√© le mur pendant la recherche, je me suis souvenu avoir vu des <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">logiciels et de nombreux micrologiciels</a> pour l'ASM1051 lorsque je cherchais de la documentation dessus.  √Ä l'aide du logiciel trouv√©, vous pouvez mettre √† jour le micrologiciel et red√©marrer l'appareil.  Par cons√©quent, j'ai d√©cid√© qu'il √©tait temps d'utiliser <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio</a> et de voir ce qui envoie le PC √† l'adaptateur pendant la mise √† jour. </p><br><p>  Ainsi, il a √©t√© possible de comprendre comment se d√©roule le processus de mise √† jour du firmware: d'abord le pr√©ambule est envoy√© (avec la commande 0xE1), puis le code est √©crit avec la commande 0xE3, puis tout ceci est poli par red√©marrage (la commande 0xE8).  Pour une mise √† jour rapide et pratique, j'ai √©crit un script Python qui ins√®re les lignes n√©cessaires dans le pr√©ambule, puis lit les sommes de contr√¥le et met √† jour l'appareil.  Maintenant, je n'ai plus besoin d'un √©mulateur, j'ai eu la possibilit√© de t√©l√©charger le firmware sur l'ASM1051 via USB, vous pouvez renvoyer la ROM native sur la carte. </p><br><p>  <strong><em>Conclusions</em></strong> </p><br><p>  Pour mettre √† jour le firmware, trois commandes SCSI doivent √™tre ex√©cut√©es s√©quentiellement: 0xE1, 0xE3 et 0xE8. </p><br><h2 id="nahodka--5">  Trouver le num√©ro 5 </h2><br><p>  En plus des commandes non document√©es, il √©tait int√©ressant de regarder les gestionnaires de commandes standard. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>D√©placement du troisi√®me bit du registre 0xC884 vers le septi√®me bit du registre 0x8002</em> </p><br><p>  Il existe un test int√©ressant dans le gestionnaire de la commande MODE SENSE (10) SCSI.  La figure ci-dessus montre une partie du code de fonction.  On peut voir que le troisi√®me bit est lu dans le registre <strong>0xC884</strong> .  Ensuite, la valeur de ce bit est d√©finie dans le registre √† 0x8002. </p><br><p>  Ce qui est int√©ressant ici, c'est que le registre <strong>0xC884</strong> n'est initialis√© nulle part dans le code, ce qui signifie qu'il s'agit probablement du mat√©riel. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tableau 362 du <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">manuel de r√©f√©rence des commandes SCSI</a></em> </p><br><p>  En outre, si vous consultez la documentation de <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">la commande</a> 0x5A <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI</a> (MODE SENSE), il devient clair que l'adaptateur USB-SATA doit r√©pondre √† la demande MODE SENSE.  Le troisi√®me octet de la r√©ponse contient le septi√®me bit de WP (Write Protect - protection en √©criture).  Soit dit en passant, j'ai d√©j√† vu le <strong>septi√®me</strong> bit dans 0x8002, et le <strong>d√©calage par</strong> rapport au d√©but du tampon USB (0x8000) est exactement de <strong>3 ici</strong> . </p><br><p>  <strong><em>Conclusion:</em></strong> </p><br><p>  L'adaptateur USB-SATA test√© lit le troisi√®me bit du registre mat√©riel √† <strong>0xC884</strong> et l'envoie √† l'h√¥te USB en tant que bit WP. </p><br><h2 id="nahodka--6">  Trouver le num√©ro 6 </h2><br><p>  Le registre mat√©riel trouv√© lors de l'enqu√™te sur le gestionnaire de commandes MODE SENSE SCSI est tr√®s similaire au GPIO.  Pour confirmer cela, j'ai d√©cid√© de toucher les jambes de l'ASM1051 avec une r√©sistance sous tension et de lire la valeur du registre (commande SCSI 0xE4) avec l'adresse <strong>0xC884</strong> .  Pour ce faire, j'ai √©crit un script Python √† l'aide de commandes SCSI personnalis√©es qui surveille la valeur dans le registre <strong>0xC884</strong> et l'affiche sur le PC. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bits 0xC884 </th><th>  7 </th><th>  6 </th><th>  5 </th><th>  4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 </th></tr></thead><tbody><tr><td>  Leg ASM1051 </td><td>  - </td><td>  - </td><td>  37 </td><td>  - </td><td>  9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Apr√®s avoir men√© une telle exp√©rience, j'ai compil√© un tableau dans lequel j'ai affich√© quels bits du registre <strong>0xC884 ont</strong> chang√© lorsque la r√©sistance ASM1051 a touch√© les jambes.  Il s'av√®re que le registre √† l'√©tude est √©troitement li√© au GPIO, mais la tentative d'√©criture sur celui-ci (avec la commande SCSI 0xE5) a √©chou√© - la valeur n'a pas chang√©. </p><br><p>  J'ai alors d√©cid√© que ce registre √©tait soit en lecture seule, soit qu'il √©tait interdit d'y √©crire quelque part au niveau mat√©riel.  Si, par exemple, les segments MK √©taient initialement configur√©s pour la lecture uniquement, alors, probablement, l'√©criture dans le registre <strong>0xC884</strong> pourrait √™tre indisponible. </p><br><p>  En g√©n√©ral, afin de trouver les registres associ√©s au GPIO, j'ai parcouru le code d'initialisation MK.  J'ai not√© tous les registres dont les adresses sont proches de <strong>0xC884</strong> .  J'en ai eu environ 10. Je vous rappelle que la dixi√®me branche du MK est reli√©e √† la LED de la carte, elle correspond au deuxi√®me bit du registre <strong>0xC884</strong> .          ‚Äì <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  ‚Ññ 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p> <strong><em></em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    ‚Äì  ASM1051  ,         HDD. ,   ,     (¬´     ¬ª),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>       ,       . </p><br><p>           -,    ,   .         ¬´ ¬´¬ª,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security ‚Äì     ¬´¬ª     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485966/">https://habr.com/ru/post/fr485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485950/index.html">√âpid√©mie et censure: les autorit√©s chinoises tentent-elles de restreindre la diffusion d'informations sur les coronavirus?</a></li>
<li><a href="../fr485952/index.html">Interface CLI pour Laravel Artisan</a></li>
<li><a href="../fr485954/index.html">Digeste Java du 28 janvier</a></li>
<li><a href="../fr485958/index.html">[R√©sum√© administrateur] Et si le programme veut des droits d'administrateur et que vous ne le faites pas</a></li>
<li><a href="../fr485962/index.html">Recherche personnelle sur 2019-nCoV</a></li>
<li><a href="../fr485968/index.html">Et encore une fois contourner les verrous. RouterOS + BGP + OSPF</a></li>
<li><a href="../fr485970/index.html">Trente meilleures interviews r√©cemment: d√©veloppement, design, sciencepop et style de vie</a></li>
<li><a href="../fr485972/index.html">M√©thodes d'analyse de r√©gression en science des donn√©es</a></li>
<li><a href="../fr485974/index.html">Modem Hasp Raspberry Pi et SIM7600E 4G</a></li>
<li><a href="../fr485986/index.html">Top 5 des tendances de localisation en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>