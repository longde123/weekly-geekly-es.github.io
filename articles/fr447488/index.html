<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèª ü§ß üëàüèΩ Briser une fissure simple avec Ghidra - Partie 2 üë©üèæ‚Äçüíª üéë üïù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la premi√®re partie de l' article, en utilisant Ghidra, nous avons automatiquement analys√© un programme de crack simple (que nous avons t√©l√©charg√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Briser une fissure simple avec Ghidra - Partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447488/">  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie de l'</a> article, en utilisant Ghidra, nous avons automatiquement analys√© un programme de crack simple (que nous avons t√©l√©charg√© depuis crackmes.one).  Nous avons compris comment renommer les fonctions "incompr√©hensibles" directement dans la liste des d√©compilateurs, et avons √©galement compris l'algorithme du programme "de haut niveau", c'est-√†-dire  ce qui est fait par <b>main ()</b> . <br><br>  Dans cette partie, comme je l'ai promis, nous allons reprendre l'analyse de la fonction <strong>_construct_key ()</strong> , qui, comme nous l'avons d√©couvert, est responsable de la lecture du fichier binaire transf√©r√© au programme et de la v√©rification des donn√©es lues. <br><a name="habracut"></a><br><h2>  √âtape 5 - Pr√©sentation de la fonction _construct_key () </h2><br>  Regardons tout de suite la liste compl√®te de cette fonction: <br><br><div class="spoiler">  <b class="spoiler_title">Liste _construct_key ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** __cdecl _construct_key(FILE *param_1) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar1; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar2; uint uVar3; uint local_3c; byte local_36; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_35; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_34; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_30 [<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_20; undefined4 local_19; undefined local_15; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **local_14; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_10; local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_14 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { local_19 = <span class="hljs-number"><span class="hljs-number">0</span></span>; local_15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_19,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); iVar1 = _text((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;local_19,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *local_14; local_30[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; local_20 = *local_14 + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; local_10 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_10 &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { local_35 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_35,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*local_30[local_10] != local_35) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_36 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_36,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_36 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)local_36; _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); sVar2 = _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sVar2 != *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>)) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_3c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_3c,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); local_3c = local_3c + <span class="hljs-number"><span class="hljs-number">7</span></span>; uVar3 = _text(param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_3c &lt; uVar3) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x108</span></span>) = local_3c; _text(param_1,local_3c,<span class="hljs-number"><span class="hljs-number">0</span></span>); local_10 = local_10 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } local_34 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_34,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(*local_14 + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) == local_34) { _text(<span class="hljs-string"><span class="hljs-string">"Markers seem to still exist"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_14; }</code> </pre> <br></div></div><br>  Avec cette fonction, nous ferons la m√™me chose qu'avant avec <strong>main ()</strong> - pour commencer, nous passerons en revue les appels de fonction ¬´voil√©s¬ª.  Comme pr√©vu, toutes ces fonctions proviennent des biblioth√®ques standard C. Je ne d√©crirai pas la proc√©dure pour renommer des fonctions √† nouveau - revenez √† la premi√®re partie de l'article, si n√©cessaire.  √Ä la suite du changement de nom, les fonctions standard suivantes ont √©t√© ¬´trouv√©es¬ª: <br><br><ul><li>  fread () </li><li>  strncmp () </li><li>  strlen () </li><li>  ftell () </li><li>  fseek () </li><li>  met () </li></ul><br>  Nous avons renomm√© les fonctions d'encapsulation correspondantes dans notre code (celles que le d√©compilateur a effront√©ment cach√©es derri√®re le mot <strong>_text</strong> ) en ajoutant l'index 2 (afin qu'il n'y ait pas de confusion avec les fonctions C d'origine).  Presque toutes ces fonctions permettent de travailler avec des flux de fichiers.  Il n'est pas surprenant - un rapide coup d'≈ìil au code suffit pour comprendre qu'il lit s√©quentiellement les donn√©es d'un fichier (dont le descripteur est transmis √† la fonction en tant que param√®tre unique) et compare les donn√©es lues avec un certain tableau bidimensionnel de <strong>local_14</strong> octets. <br><br>  Supposons que ce tableau contient des donn√©es pour la v√©rification des cl√©s.  Appelez-le, dites <strong>key_array</strong> .  √âtant donn√© qu'Hydra vous permet de renommer non seulement des fonctions, mais √©galement des variables, nous l'utiliserons et renommerons le <strong>local_14</strong> incompr√©hensible en un <strong>tableau de cl√©s</strong> plus compr√©hensible.  Cela se fait de la m√™me mani√®re que pour les fonctions: via le menu du bouton droit de la souris ( <strong>Renommer local</strong> ) ou par la touche <strong>L</strong> du clavier. <br><br>  Ainsi, imm√©diatement apr√®s la d√©claration des variables locales, une certaine fonction <strong>_prepare_key ()</strong> est <strong>appel√©e</strong> : <br><br><pre> <code class="cpp hljs">key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; }</code> </pre><br>  Nous reviendrons sur <strong>_prepare_key ()</strong> , c'est le 3√®me niveau d'imbrication dans notre hi√©rarchie d'appels: <strong>main () -&gt; _construct_key () -&gt; _prepare_key ()</strong> .  En attendant, nous acceptons qu'il cr√©e et initialise en quelque sorte ce tableau bidimensionnel ¬´test¬ª.  Et seulement si ce tableau n'est pas vide, la fonction continue son travail, comme en t√©moigne le bloc <b>else</b> imm√©diatement apr√®s la condition. <br><br>  Ensuite, le programme lit les 4 premiers octets du fichier et compare avec la section correspondante du tableau <b>key_array</b> .  (Le code ci-dessous est apr√®s avoir renomm√©, y compris la variable <b>local_19,</b> j'ai renomm√© <b>first_4bytes</b> .) <br><br><pre> <code class="cpp hljs">first_4bytes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   4    */</span></span> fread2(&amp;first_4bytes,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); <span class="hljs-comment"><span class="hljs-comment">/*   key_array[1][0...3] */</span></span> iVar1 = strncmp2((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;first_4bytes,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre><br>  Ainsi, une ex√©cution ult√©rieure ne se produit que si les 4 premiers octets co√Øncident (rappelez-vous ceci).  Ensuite, nous lisons 2 blocs de 2 octets du fichier (et le m√™me <b>key_array</b> est utilis√© comme tampon pour l'√©criture des donn√©es): <br><br><pre> <code class="cpp hljs">fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1);</code> </pre><br>  Et encore - en outre, la fonction ne fonctionne que si la condition suivante est vraie: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//   ... }</span></span></code> </pre><br>  Il est facile de voir que le premier des blocs de 2 octets lu ci-dessus doit √™tre le num√©ro 5, et le second doit √™tre le num√©ro 4 (le type de donn√©es <b>court</b> occupe seulement 2 octets sur les plates-formes 32 bits). <br><br>  Le suivant est le suivant: <br><br><pre> <code class="cpp hljs">local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; <span class="hljs-comment"><span class="hljs-comment">// .. key_array[0] local_30[1] = *key_array + 0x10c; local_30[2] = *key_array + 0x218; local_30[3] = *key_array + 0x324; local_20 = *key_array + 0x430;</span></span></code> </pre><br>  Nous voyons ici que le tableau <b>local_30</b> (d√©clar√© comme char * local_30 [4]) contient les d√©calages du pointeur <b>key_array</b> .  Autrement dit, <b>local_30</b> est un tableau de lignes de marqueur dans lequel les donn√©es du fichier seront probablement lues.  Dans cette hypoth√®se, j'ai renomm√© <b>local_30</b> en <b>marqueurs</b> .  Dans cette section de code, seule la derni√®re ligne semble un peu suspecte, o√π l'affectation du dernier d√©calage (√† l'index 0x430, c'est-√†-dire 1072) est effectu√©e non par l'√©l√©ment de <b>marqueurs</b> suivant, mais par une variable <b>locale_20</b> distincte ( <b>char *</b> ).  Mais nous allons le d√©couvrir encore, mais pour l'instant - passons √† autre chose! <br><br>  Ensuite, nous attendons un cycle: <br><br><pre> <code class="cpp hljs"> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// local_10   i while (i &lt; 5) { // ... i = i + 1; }</span></span></code> </pre><br>  C'est-√†-dire  Seulement 5 it√©rations de 0 √† 4 inclus.  Dans la boucle, la lecture du fichier et la v√©rification de la conformit√© avec notre tableau de <b>marqueurs</b> commencent imm√©diatement: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c_marker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_35 /*  .    */ fread2(&amp;c_marker, 1, 1, param_1); if (*markers[i] != c_marker) { /*    -      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  C'est-√†-dire que l'octet suivant du fichier est lu dans la variable <b>c_marker</b> (dans le code d√©compil√© d'origine - <b>local_35</b> ) et v√©rifi√© la conformit√© avec le premier caract√®re du i√®me √©l√©ment <b>marqueurs</b> .  En cas de non-concordance, le tableau <b>key_array</b> est annul√© et un double pointeur vide est renvoy√©.  Plus loin dans le code, nous voyons que cela se fait chaque fois que les donn√©es lues ne correspondent pas aux donn√©es de v√©rification. <br><br>  Mais ici, comme on dit, "le chien est enterr√©".  Examinons de plus pr√®s ce cycle.  Il a 5 it√©rations, comme nous l'avons d√©couvert.  Vous pouvez v√©rifier cela si vous le souhaitez en consultant le code assembleur: <br><br><img src="https://habrastorage.org/webt/si/b4/q8/sib4q8jsxe2zyxpxi2gcwy0vfba.png"><br><br><img src="https://habrastorage.org/webt/tr/8q/oh/tr8qoh9ayg-7v9t6rv1vwtsuy_c.png"><br><br>  En effet, la commande CMP compare la valeur de la variable <b>local_10</b> (nous avons d√©j√† <b>i</b> ) avec le nombre 4 et si la valeur est <i>inf√©rieure ou √©gale √†</i> 4 (la commande JLE), la transition vers le label <b>LAB_004017eb est effectu√©e</b> , c'est-√†-dire  d√©but du corps du cycle.  C'est-√†-dire  la condition sera remplie pour <b>i</b> = 0, 1, 2, 3 et 4 - seulement 5 it√©rations!  Tout irait bien, mais les <b>marqueurs sont</b> √©galement index√©s par cette variable dans une boucle, et apr√®s tout, ce tableau est d√©clar√© avec seulement 4 √©l√©ments: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *markers [<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  Donc, quelqu'un essaie clairement de tromper quelqu'un :) Rappelez-vous, j'ai dit que cette ligne est douteuse? <br><br><pre> <code class="cpp hljs">local_20 = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>;</code> </pre><br>  Comme √ßa!  Regardez simplement la liste compl√®te de la fonction et essayez de trouver au moins une r√©f√©rence suppl√©mentaire √† la variable <b>local_20</b> .  Elle n'est pas l√†!  Nous concluons de ceci: ce d√©calage devrait √©galement √™tre stock√© dans le tableau des <b>marqueurs</b> , et le tableau lui-m√™me devrait contenir 5 √©l√©ments.  Corrigeons-le.  Acc√©dez √† la d√©claration de variable, <b>appuyez sur Ctrl + L</b> (Retaper la variable) et changez audacieusement la taille du tableau en 5: <br><br><img src="https://habrastorage.org/webt/t0/sq/xw/t0sqxw-hbw5dqo9mca3m43r5cei.png"><br><br>  C'est fait.  Faites d√©filer jusqu'au code pour attribuer des d√©calages de pointeur aux <b>marqueurs</b> , et - et voil√†!  - une variable suppl√©mentaire incompr√©hensible dispara√Æt et tout se met en place: <br><br><pre> <code class="cpp hljs">markers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; markers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; markers[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; markers[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; markers[<span class="hljs-number"><span class="hljs-number">4</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ...   !</span></span></code> </pre><br>  Nous revenons √† notre <b>boucle while</b> (dans le code source, ce sera tr√®s probablement <b>pour</b> , mais peu nous importe).  Ensuite, l'octet du fichier est relu et sa valeur est v√©rifi√©e: <br><br><pre> <code class="cpp hljs">byte n_strlen1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_36 /*  .    */ fread2(&amp;n_strlen1,1,1,param_1); if (n_strlen1 == 0) { /*      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  OK, ce <b>n_strlen1</b> doit √™tre diff√©rent de z√©ro.  Pourquoi?  Vous verrez maintenant, mais en m√™me temps, vous comprendrez pourquoi j'ai donn√© √† cette variable le nom suivant: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   n_strlen1)  (markers[i] + 0x104) */</span></span> *(uint *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)n_strlen1; <span class="hljs-comment"><span class="hljs-comment">/*    (n_strlen1)  (--&gt;  ?) */</span></span> fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   sVar2 if (n_strlen2 != *(size_t *)(markers[i] + 0x104)) { /*    (n_strlen2)  == n_strlen1 */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  J'ai ajout√© des commentaires sur lesquels tout devrait √™tre clair.  <b>N_strlen1</b> octets sont lus √† partir du fichier et enregistr√©s sous forme de s√©quence de caract√®res (c'est-√†-dire une cha√Æne) dans le tableau des <b>marqueurs [i]</b> - c'est-√†-dire apr√®s le ¬´stop-symbol¬ª correspondant, qui y sont d√©j√† √©crits √† partir de <b>key_array</b> .  L'enregistrement de la valeur <b>n_strlen1</b> dans les <b>marqueurs [i]</b> √† l'offset 0x104 (260) ne joue aucun r√¥le ici (voir la premi√®re ligne du code ci-dessus).  En fait, ce code peut √™tre optimis√© comme suit (et c'est certainement le cas dans le code source): <br><br><pre> <code class="cpp hljs">fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1, param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_strlen2 != (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1) { ... }</code> </pre><br>  Il v√©rifie √©galement que la longueur de la ligne de lecture est <b>n_strlen1</b> .  Cela peut sembler inutile, √©tant donn√© que ce param√®tre a √©t√© transmis √† la fonction <b>fread</b> , mais <b>fread</b> <i>ne</i> lit <i>pas plus de</i> tant d'octets sp√©cifi√©s et peut lire moins que ce qui est indiqu√©, par exemple, dans le cas de la r√©union du marqueur de fin de fichier (EOF).  Autrement dit, tout est strict: la longueur de la ligne (en octets) est indiqu√©e dans le fichier, puis la ligne elle-m√™me va - et exactement 5 fois.  Mais nous prenons de l'avance sur nous-m√™mes. <br><br>  Arrose encore ce code (que j'ai aussi imm√©diatement comment√©): <br><br><pre> <code class="cpp hljs">uint n_pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_3c /*  .    */ fread2(&amp;n_pos,1,1,param_1); /*   7 */ n_pos = n_pos + 7; /*     */ uint n_filepos = ftell2(param_1); //   uVar3 if (n_pos &lt; n_filepos) { /* n_pos   &gt;= n_filepos */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  C'est encore plus simple ici: nous prenons l'octet suivant du fichier, ajoutons 7 et comparons la valeur r√©sultante avec la position actuelle du curseur dans le flux de fichier obtenu par la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ftell ()</a> .  La valeur de <b>n_pos ne</b> doit pas √™tre inf√©rieure √† la position du curseur (c'est-√†-dire d√©calage en octets depuis le d√©but du fichier). <br><br>  La derni√®re ligne de la boucle: <br><br><pre> <code class="cpp hljs">fseek2(param_1,n_pos,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  C'est-√†-dire  r√©organiser le curseur de fichier (depuis le d√©but) √† la position indiqu√©e par <b>n_pos</b> par la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fseek ()</a> .  OK, nous effectuons toutes ces op√©rations dans la boucle 5 fois.  La fonction <b>_construct_key () se termine par le</b> code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_lastmarker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_34 /*   4    (int32) */ fread2(&amp;i_lastmarker,4,1,param_1); if (*(int *)(*key_array + 0x53c) == i_lastmarker) { /*    == key_array[0][1340] ...   :) */ puts2("Markers seem to still exist"); } else { _free_key(key_array); key_array = (char **)0x0; }</span></span></code> </pre><br>  Ainsi, le dernier bloc de donn√©es dans le fichier doit √™tre une valeur enti√®re de 4 octets et il doit √™tre √©gal √† la valeur dans <b>key_array [0] [1340]</b> .  Dans ce cas, nous recevrons un message de f√©licitations dans la console.  Sinon, le tableau vide revient toujours sans √©loge :) <br><br><h2>  √âtape 6 - Pr√©sentation de la fonction __prepare_key () </h2><br>  Il ne nous reste qu'une fonction non assembl√©e - <b>__prepare_key ()</b> .  Nous avons d√©j√† devin√© que c'est en elle que les donn√©es de v√©rification sont g√©n√©r√©es sous la forme du tableau <b>key_array</b> , qui est ensuite utilis√© dans la fonction <b>_construct_key ()</b> pour v√©rifier les donn√©es du fichier.  Reste √† savoir quel genre de donn√©es l√†-bas! <br><br>  Je n'analyserai pas cette fonction en d√©tail et donnerai imm√©diatement une liste compl√®te avec des commentaires apr√®s tout le renommage n√©cessaire des variables: <br><br><div class="spoiler">  <b class="spoiler_title">Liste des fonctions de __Prepare_key ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ** __prepare_key(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **key_array; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* key_array = new char*[2]; // 2 4-  (char*) */</span></span> key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0x540</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[0] = new char[1340] */</span></span> *key_array = pvVar1; pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[1] = new char[8] */</span></span> key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* "VOID" */</span></span> *(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 5  4 (2- ) */</span></span> *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">5</span></span>; *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* key_array[0][0] = 'b' */</span></span> *(undefined *)*key_array = <span class="hljs-number"><span class="hljs-number">0x62</span></span>; *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'W' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>) = <span class="hljs-number"><span class="hljs-number">0x57</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'p' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>) = <span class="hljs-number"><span class="hljs-number">0x70</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'l' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x6c</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 152 ( ASCII) */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>) = <span class="hljs-number"><span class="hljs-number">0x98</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   = 1122 (int32) */</span></span> *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x462</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_array; }</code> </pre><br></div></div><br>  Le seul endroit √† consid√©rer est cette ligne: <br><br><pre> <code class="cpp hljs">*(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>;</code> </pre><br>  Comment puis-je comprendre que se trouve ici la ligne "VOID"?  Le fait est que 0x404024 est l'adresse dans l'espace d'adressage du programme menant √† la section <b>.rdata</b> .  Un double-clic sur cette valeur nous permet de voir clairement ce qui s'y trouve: <br><br><img src="https://habrastorage.org/webt/8a/eu/0j/8aeu0jkpr-ea7euhrlcgvm0rxq8.png"><br><br>  Par ailleurs, la m√™me chose peut √™tre comprise √† partir du code assembleur de cette ligne: <br><br> <code>004015da c7 00 24 MOV dword ptr [EAX], .rdata = 56h V <br> 40 40 00 <br></code> <br>  Les donn√©es correspondant √† la ligne VOID se <b>trouvent</b> au tout d√©but de la section <b>.rdata</b> (√† d√©calage z√©ro par rapport √† l'adresse correspondante). <br><br>  Ainsi, √† la sortie de cette fonction, un tableau √† deux dimensions doit √™tre form√© avec les donn√©es suivantes: <br><br> <code>[0] [0]:'b' [268]:'l' [536]:'W' [804]:'p' [1072]:152 [1340]:1122 <br> [1] [0-3]:"VOID" [4-5]:5 [6-7]:4 <br></code> <br><h2>  √âtape 7 - Pr√©parez le binaire pour la fissure </h2><br>  Nous pouvons maintenant commencer la synth√®se du fichier binaire.  Toutes les donn√©es initiales entre nos mains: <br>  1) les donn√©es de v√©rification (¬´symboles d'arr√™t¬ª) et leurs positions dans le tableau de v√©rification; <br>  2) la s√©quence de donn√©es dans le fichier <br><br>  <b>Restaurons</b> la structure du fichier recherch√© selon l'algorithme de la fonction <b>_construct_key ()</b> .  Ainsi, la s√©quence de donn√©es dans le fichier sera la suivante: <br><br><div class="spoiler">  <b class="spoiler_title">Structure des fichiers</b> <div class="spoiler_text"><ol><li>  4 octets == key_array [1] [0 ... 3] == "VOID" </li><li>  2 octets == key_array [1] [4] == 5 </li><li>  2 octets == key_array [1] [6] == 4 </li><li>  1 octet == key_array [0] [0] == 'b' (jeton) </li><li>  1 octet == (longueur de ligne suivante) == n_strlen1 </li><li>  n_strlen1 octets == (n'importe quelle cha√Æne) == n_strlen1 </li><li>  1 octet == (+7 == jeton suivant) == n_pos </li><li>  1 octet == key_array [0] [0] == 'l' (jeton) </li><li>  1 octet == (longueur de ligne suivante) == n_strlen1 </li><li>  n_strlen1 octets == (n'importe quelle cha√Æne) == n_strlen1 </li><li>  1 octet == (+7 == jeton suivant) == n_pos </li><li>  1 octet == key_array [0] [0] == 'W' (jeton) </li><li>  1 octet == (longueur de ligne suivante) == n_strlen1 </li><li>  n_strlen1 octets == (n'importe quelle cha√Æne) == n_strlen1 </li><li>  1 octet == (+7 == jeton suivant) == n_pos </li><li>  1 octet == key_array [0] [0] == 'p' (jeton) </li><li>  1 octet == (longueur de ligne suivante) == n_strlen1 </li><li>  n_strlen1 octets == (n'importe quelle cha√Æne) == n_strlen1 </li><li>  1 octet == (+7 == jeton suivant) == n_pos </li><li>  1 octet == tableau_cl√© [0] [0] == 152 (jeton) </li><li>  1 octet == (longueur de ligne suivante) == n_strlen1 </li><li>  n_strlen1 octets == (n'importe quelle cha√Æne) == n_strlen1 </li><li>  1 octet == (+7 == jeton suivant) == n_pos </li><li>  4 octets == (tableau_cl√© [1340]) == 1122 </li></ol><br></div></div><br>  Pour plus de clart√©, j'ai r√©alis√© dans Excel une telle tablette avec les donn√©es du fichier souhait√©: <br><br><img src="https://habrastorage.org/webt/kr/i-/7a/kri-7arjlro0ye_los64uhakbfq.png"><br><br>  Ici, √† la 7e ligne - les donn√©es elles-m√™mes sous forme de caract√®res et de chiffres, √† la 6e ligne - leurs repr√©sentations hexad√©cimales, √† la 8e ligne - la taille de chaque √©l√©ment (en octets), √† la 9e ligne - le d√©calage par rapport au d√©but du fichier.  Cette vue est tr√®s pratique car  vous permet d'entrer toutes les lignes dans le futur fichier (marqu√©es d'un remplissage jaune), tandis que les valeurs des longueurs de ces lignes, ainsi que les d√©calages de position du prochain symbole d'arr√™t sont calcul√©s automatiquement par des formules, comme l'algorithme du programme l'exige.  Ci-dessus (aux lignes 1 √† 4), la structure du tableau de contr√¥le <b>key_array</b> est <b>affich√©e</b> . <br><br>  L'excel lui-m√™me ainsi que d'autres sources de l'article peuvent √™tre t√©l√©charg√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  G√©n√©ration et validation de fichiers binaires </h3><br>  Il ne reste plus qu'√† g√©n√©rer le fichier souhait√© au format binaire et √† le nourrir avec notre crack.  Pour g√©n√©rer le fichier, j'ai √©crit un simple script Python: <br><br><div class="spoiler">  <b class="spoiler_title">Script pour g√©n√©rer le fichier</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys, os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess out_str = [<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">' solved'</span></span>, <span class="hljs-string"><span class="hljs-string">' this'</span></span>, <span class="hljs-string"><span class="hljs-string">' crackme!'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_path, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> outfile: outfile.write(<span class="hljs-string"><span class="hljs-string">'VOID'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'b'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos = <span class="hljs-number"><span class="hljs-number">10</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'l'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'W'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'p'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">152</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-number"><span class="hljs-number">1122</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) != <span class="hljs-number"><span class="hljs-number">2</span></span>: print(<span class="hljs-string"><span class="hljs-string">'USAGE: {this_script.py} path_to_crackme[.exe]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.isfile(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]): print(<span class="hljs-string"><span class="hljs-string">'File "{}" unavailable!'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file_path = os.path.splitext(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'.dat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: write_file(file_path) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: outputstr = subprocess.check_output(<span class="hljs-string"><span class="hljs-string">'"{}" -f "{}"'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], file_path), stderr=subprocess.STDOUT) print(outputstr.decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br>  Le script prend le chemin d'acc√®s aux fissures en tant que param√®tre unique, puis g√©n√®re un fichier binaire avec la cl√© dans le m√™me r√©pertoire et appelle les fissures avec le param√®tre correspondant, traduisant la sortie du programme vers la console. <br><br>  Pour convertir des donn√©es texte en binaire, utilisez le package <b>struct</b> .  La m√©thode <b>pack ()</b> vous permet d'√©crire des donn√©es binaires dans un format dans lequel le type de donn√©es est indiqu√© ("B" = "byte", "i" = int, etc.), et vous pouvez √©galement sp√©cifier la s√©quence ("&gt;" = "Big -endian "," &lt;"=" Little-endian ").  L'ordre par d√©faut est Little-endian.  Parce que  nous avons d√©j√† d√©termin√© dans le premier article que c'est exactement notre cas, nous n'indiquons alors que le type. <br><br>  Tout le code dans son ensemble reproduit l'algorithme de programme que nous avons trouv√©.  En tant que ligne √† imprimer en cas de succ√®s, j'ai sp√©cifi√© "J'ai r√©solu ce crackme!"  (vous pouvez modifier ce script pour qu'il soit possible de sp√©cifier n'importe quelle ligne). <br><br>  V√©rifiez la sortie: <br><br><img src="https://habrastorage.org/webt/th/mx/pz/thmxpzy22t8leydwou56w3emrze.png"><br><br>  Hourra, tout fonctionne!  Ainsi, apr√®s avoir transpir√© un peu et tri√© quelques fonctions, nous avons pu restaurer compl√®tement l'algorithme du programme et le ¬´casser¬ª.  Bien s√ªr, ce n'est qu'un simple crack, un programme de test, et m√™me celui du 2√®me niveau de difficult√© (sur 5 propos√©s sur ce site).  En r√©alit√©, nous traiterons une hi√©rarchie complexe d'appels et de dizaines - des centaines de fonctions, et dans certains cas - des sections chiffr√©es de donn√©es, du code poubelle et d'autres techniques d'obscurcissement, jusqu'√† l'utilisation de machines virtuelles internes et de code P ... Mais cela, comme on dit, est d√©j√† une histoire compl√®tement diff√©rente. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mat√©riaux pour l'article.</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447488/">https://habr.com/ru/post/fr447488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447474/index.html">Un analogue de d√©catron fonctionnel miniature pour la r√©plique de l'ordinateur Harwell Dekatron et pas seulement</a></li>
<li><a href="../fr447476/index.html">D√©finition de LaTeX dans un texte sublime</a></li>
<li><a href="../fr447478/index.html">L'illusion d'immuabilit√© et de confiance comme base du d√©veloppement d'√©quipe</a></li>
<li><a href="../fr447480/index.html">Journ√©e de la cosmonautique 2019: √©v√©nements par ville</a></li>
<li><a href="../fr447482/index.html">Cyber ‚Äã‚ÄãLaw School. 5 jours intensifs en droit num√©rique</a></li>
<li><a href="../fr447490/index.html">Comment am√©liorer votre style d'√©criture en anglais: 5 conseils</a></li>
<li><a href="../fr447494/index.html">D√©veloppement durable GAN Learning (Creuser plus profond√©ment)</a></li>
<li><a href="../fr447496/index.html">G√©rer Raspberry via des websockets</a></li>
<li><a href="../fr447498/index.html">Reportage photo de JPoint 2019 + annonce du Joker 2019 √† Saint-P√©tersbourg</a></li>
<li><a href="../fr447500/index.html">Pourquoi les op√©rateurs ont peur de l'eSIM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>