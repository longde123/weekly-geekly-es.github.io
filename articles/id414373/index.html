<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèø üÜí üë©üèº‚Äçüé§ Desain async / menunggu JavaScript: kekuatan, jebakan, dan pola penggunaan ‚ûñ üçª üî∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konstruksi async / menunggu muncul dalam standar ES7. Ini dapat dianggap sebagai peningkatan luar biasa dalam bidang pemrograman asinkron dalam JavaSc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desain async / menunggu JavaScript: kekuatan, jebakan, dan pola penggunaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414373/">  Konstruksi async / menunggu muncul dalam standar ES7.  Ini dapat dianggap sebagai peningkatan luar biasa dalam bidang pemrograman asinkron dalam JavaScript.  Ini memungkinkan Anda untuk menulis kode yang terlihat seperti sinkron, tetapi digunakan untuk menyelesaikan tugas-tugas yang tidak sinkron dan tidak memblokir utas utama.  Terlepas dari kenyataan bahwa async / menunggu adalah fitur baru yang hebat dari bahasa, menggunakannya dengan benar tidak begitu sederhana.  Bahan, terjemahan yang kami terbitkan hari ini, dikhususkan untuk studi komprehensif async / menunggu dan cerita tentang bagaimana menggunakan mekanisme ini dengan benar dan efektif. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/ea6/61a/e97/ea661ae979bc9999209bca9db6744dc5.png" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Kekuatan async / menunggu</font> </h2><br>  Manfaat paling penting yang didapat oleh seorang programmer yang menggunakan konstruk async / await adalah bahwa hal itu memungkinkan untuk menulis kode asinkron dengan gaya yang spesifik untuk kode sinkron.  Bandingkan kode yang ditulis menggunakan async / tunggu dengan kode berdasarkan janji. <br><br><pre><code class="hljs pgsql">// async/await async getBooksByAuthorWithAwait(authorId) {  const books = await bookModel.fetchAll();  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId); } //  getBooksByAuthorWithPromise(authorId) {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(books =&gt; books.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(b =&gt; b.authorId === authorId)); }</code> </pre> <br>  Mudah untuk memperhatikan bahwa versi async / await dari contoh lebih mudah dipahami daripada versinya, di mana janji digunakan.  Jika Anda tidak memperhatikan kata kunci yang <code>await</code> , kode ini akan terlihat seperti serangkaian instruksi reguler yang dijalankan secara serempak - seperti dalam JavaScript yang akrab atau dalam bahasa sinkron lain seperti Python. <br><br>  Daya tarik async / menunggu tidak hanya karena peningkatan pembacaan kode.  Mekanisme ini, di samping itu, menikmati dukungan browser yang sangat baik, yang tidak memerlukan solusi apa pun.  Jadi, fungsi asinkron hari ini sepenuhnya mendukung semua browser utama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/324/a94/b98324a94798cf96620a3ed89c88204d.png"></div><br>  <i><font color="#999999">Semua browser utama mendukung fungsi asinkron ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">caniuse.com</a> )</font></i> <br><br>  Tingkat dukungan ini berarti, misalnya, kode yang menggunakan async / menunggu tidak perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditransformasikan</a> .  Selain itu, ini memfasilitasi debugging, yang mungkin bahkan lebih penting daripada kurangnya kebutuhan untuk transpilasi. <br><br>  Gambar berikut ini menunjukkan proses debug dari fungsi asinkron.  Di sini, ketika mengatur breakpoint pada instruksi pertama fungsi dan ketika menjalankan perintah Step Over, ketika debugger mencapai garis di mana kata kunci <code>await</code> digunakan, Anda dapat melihat bagaimana debugger berhenti sementara waktu, menunggu fungsi <code>bookModel.fetchAll()</code> , dan kemudian melompat ke baris di mana perintah <code>.filter()</code> !  Proses debugging seperti itu terlihat jauh lebih sederhana daripada janji-janji debugging.  Di sini, ketika men-debug kode yang sama, Anda harus mengatur breakpoint lain di baris <code>.filter()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/bdb/4e0/23dbdb4e062eb7523a1d677e6255e880.gif"><br>  <i><font color="#999999">Debugging fungsi asinkron.</font></i>  <i><font color="#999999">Debugger akan menunggu baris menunggu untuk menyelesaikan dan pergi ke baris berikutnya setelah operasi selesai</font></i> <br><br>  Kekuatan lain dari mekanisme yang dipertimbangkan, yang kurang jelas dari apa yang telah kita bahas, adalah keberadaan kata kunci <code>async</code> sini.  Dalam kasus kami, penggunaannya memastikan bahwa nilai yang dikembalikan oleh <code>getBooksByAuthorWithAwait()</code> adalah sebuah janji.  Akibatnya, Anda dapat menggunakan <code>getBooksByAuthorWithAwait().then(...)</code> dengan aman <code>getBooksByAuthorWithAwait().then(...)</code> atau <code>await getBooksByAuthorWithAwait()</code> membuat kode yang memanggil fungsi ini.  Pertimbangkan contoh berikut (perhatikan bahwa ini tidak disarankan): <br><br><pre> <code class="hljs javascript">getBooksByAuthorWithPromise(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!authorId) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookModel.fetchAll()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books</span></span></span><span class="hljs-function"> =&gt;</span></span> books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> b.authorId === authorId)); } }</code> </pre> <br>  Di sini fungsi <code>getBooksByAuthorWithPromise()</code> dapat, jika semuanya baik-baik saja, mengembalikan janji, atau, jika terjadi kesalahan - <code>null</code> .  Akibatnya, jika terjadi kesalahan, Anda tidak dapat memanggil <code>.then()</code> .  Saat mendeklarasikan fungsi menggunakan <code>async</code> kesalahan semacam ini tidak mungkin. <br><br><h2>  <font color="#3AC1EF">Tentang kesalahan persepsi tentang async / menunggu</font> </h2><br>  Dalam beberapa publikasi, konstruksi async / await dibandingkan dengan janji-janji dan dikatakan mewakili generasi berikutnya dari evolusi pemrograman JavaScript asinkron.  Dengan ini, dengan segala hormat kepada penulis publikasi seperti itu, saya membiarkan diri saya tidak setuju.  Async / menunggu adalah perbaikan, tetapi tidak lebih dari "gula sintaksis", penampilan yang tidak mengarah pada perubahan lengkap dalam gaya pemrograman. <br><br>  Intinya, fungsi asinkron adalah janji.  Sebelum seorang programmer dapat menggunakan async / wait construct dengan benar, ia harus mempelajari janji dengan baik.  Selain itu, dalam kebanyakan kasus, bekerja dengan fungsi asinkron, Anda perlu menggunakan janji. <br><br>  Lihatlah fungsi <code>getBooksByAuthorWithAwait()</code> dan <code>getBooksByAuthorWithPromises()</code> dari contoh di atas.  Harap dicatat bahwa keduanya identik tidak hanya dalam hal fungsionalitas.  Mereka juga memiliki antarmuka yang persis sama. <br><br>  Semua ini berarti bahwa jika Anda secara langsung memanggil fungsi <code>getBooksByAuthorWithAwait()</code> , itu akan mengembalikan janji. <br><br>  Bahkan, inti dari masalah yang kita bicarakan di sini adalah persepsi yang salah dari desain baru, ketika itu menciptakan perasaan menyesatkan bahwa fungsi sinkron dapat dikonversi menjadi asinkron karena penggunaan sederhana <code>async</code> dan <code>await</code> kata kunci dan tidak memikirkan hal lain. <br><br><h2>  <font color="#3AC1EF">Jebakan async / menunggu</font> </h2><br>  Mari kita bicara tentang kesalahan paling umum yang bisa dibuat menggunakan async / menunggu.  Secara khusus, tentang penggunaan irasional panggilan berturut-turut dari fungsi asinkron. <br><br>  Meskipun kata kunci yang <code>await</code> dapat membuat kode terlihat seperti sinkron, menggunakannya, perlu diingat bahwa kode tersebut asinkron, yang berarti Anda harus sangat berhati-hati tentang panggilan berurutan dari fungsi-fungsi asinkron. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Kode ini, dalam hal logika, tampaknya benar.  Namun, ada masalah serius.  Beginilah cara kerjanya. <br><br><ol><li>  Panggilan sistem <code>await bookModel.fetchAll()</code> dan tunggu perintah <code>.fetchAll()</code> selesai. </li><li>  Setelah menerima hasil dari <code>bookModel.fetchAll()</code> <code>await authorModel.fetch(authorId)</code> akan dipanggil. </li></ol><br>  Perhatikan bahwa panggilan ke <code>authorModel.fetch(authorId)</code> tidak tergantung pada hasil panggilan ke <code>bookModel.fetchAll()</code> , dan, pada kenyataannya, kedua perintah ini dapat dieksekusi secara paralel.  Namun, menggunakan <code>await</code> hasil dalam dua panggilan ini dieksekusi secara berurutan.  Total waktu eksekusi berurutan dari kedua perintah ini akan lebih lama dari waktu eksekusi paralelnya. <br><br>  Berikut adalah pendekatan yang benar untuk menulis kode seperti itu: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getBooksAndAuthor(authorId) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bookPromise = bookModel.fetchAll(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authorPromise = authorModel.fetch(authorId); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookPromise; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> authorPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   author,   <span class="hljs-attr"><span class="hljs-attr">books</span></span>: books.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.authorId === authorId), }; }</code> </pre> <br>  Perhatikan contoh lain penyalahgunaan fungsi asinkron.  Ini masih lebih buruk daripada pada contoh sebelumnya.  Seperti yang Anda lihat, untuk memuat daftar elemen tertentu secara tidak sinkron, kita perlu mengandalkan kemungkinan janji. <br><br><pre> <code class="hljs ruby">async getAuthors(authorIds) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     /<span class="hljs-regexp"><span class="hljs-regexp">/ const authors = _.map( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   authorIds, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   id =&gt; await authorModel.fetch(id)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   const promises = _.map(authorIds, id =&gt; authorModel.fetch(id)); const authors = await Promise.all(promises); }</span></span></code> </pre> <br>  Singkatnya, maka, untuk menggunakan fungsi asinkron dengan benar, Anda perlu, karena pada saat ini tidak mungkin, pertama-tama pikirkan operasi asinkron, dan kemudian tulis kode menggunakan <code>await</code> .  Dalam kasus yang kompleks, mungkin akan lebih mudah menggunakan janji secara langsung. <br><br><h2>  <font color="#3AC1EF">Menangani kesalahan</font> </h2><br>  Saat menggunakan janji, eksekusi kode asinkron dapat berakhir seperti yang diharapkan - kemudian mereka mengatakan bahwa janji tersebut berhasil diselesaikan, atau dengan kesalahan - kemudian mereka mengatakan bahwa janji tersebut ditolak.  Ini memungkinkan kita untuk menggunakan masing-masing. <code>.then()</code> dan <code>.catch()</code> .  Namun, penanganan kesalahan menggunakan mekanisme async / await bisa rumit. <br><br><h3>  <font color="#3AC1EF">‚ñç coba / tangkap konstruk</font> </h3><br>  Cara standar untuk menangani kesalahan saat menggunakan async / await adalah dengan konstruk try / catch.  Saya merekomendasikan menggunakan pendekatan ini.  Saat melakukan panggilan tunggu, nilai yang dikembalikan saat janji ditolak disajikan sebagai pengecualian.  Berikut ini sebuah contoh: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span><span class="hljs-class"> </span></span>{ fetchAll() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject({<span class="hljs-string"><span class="hljs-string">'error'</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>}) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);   }); } } <span class="hljs-comment"><span class="hljs-comment">// async/await async getBooksByAuthorWithAwait(authorId) { try { const books = await bookModel.fetchAll(); } catch (error) { console.log(error);    // { "error": 400 } }</span></span></code> </pre> <br>  Kesalahan yang ditangkap di <code>catch</code> adalah persis nilai yang diperoleh saat janji ditolak.  Setelah menangkap pengecualian, kami dapat menerapkan beberapa pendekatan untuk bekerja dengannya: <br><br><ul><li>  Anda dapat menangani pengecualian dan mengembalikan nilai normal.  Jika Anda tidak menggunakan ekspresi <code>return</code> di <code>catch</code> untuk mengembalikan apa yang diharapkan setelah fungsi asinkron dijalankan, ini akan setara dengan menggunakan perintah <code>return undefined</code> ;. </li><li>  Anda bisa meneruskan kesalahan ke tempat kode yang gagal dipanggil dan membiarkannya diproses di sana.  Anda dapat melempar kesalahan secara langsung dengan menggunakan perintah seperti <code>throw error;</code>  , yang memungkinkan Anda untuk menggunakan fungsi <code>async getBooksByAuthorWithAwait()</code> dalam rantai janji.  Artinya, dapat dipanggil menggunakan <code>getBooksByAuthorWithAwait().then(...).catch(error =&gt; ...)</code> membangun.  Selain itu, Anda dapat membungkus kesalahan dalam objek <code>Error</code> , yang mungkin terlihat seperti <code>throw new Error(error)</code> .  Ini akan memungkinkan, misalnya, ketika mengeluarkan informasi kesalahan ke konsol, melihat tumpukan panggilan penuh. </li><li>  Kesalahan dapat direpresentasikan sebagai janji yang ditolak, sepertinya <code>return Promise.reject(error)</code> .  Dalam hal ini, ini sama dengan perintah <code>throw error</code> , karena itu tidak disarankan. </li></ul><br>  Berikut adalah manfaat menggunakan konstruk coba / tangkap: <br><br><ul><li>  Alat penanganan kesalahan seperti itu telah ada dalam pemrograman untuk waktu yang sangat lama, mereka sederhana dan dapat dimengerti.  Katakanlah, jika Anda memiliki pengalaman pemrograman dalam bahasa lain, seperti C ++ atau Java, maka Anda akan dengan mudah memahami perangkat try / catch dalam JavaScript. </li><li>  Anda dapat menempatkan beberapa panggilan tunggu dalam satu blok coba / tangkap, yang memungkinkan Anda untuk menangani semua kesalahan di satu tempat jika Anda tidak perlu secara terpisah menangani kesalahan pada setiap langkah dari eksekusi kode. </li></ul><br>  Perlu dicatat bahwa ada satu kelemahan dalam mekanisme coba / tangkap.  Karena try / catch menangkap setiap pengecualian yang terjadi di blok <code>try</code> , pengecualian tersebut yang tidak terkait dengan janji juga akan masuk ke <code>catch</code> handler.  Lihatlah contoh ini. <br><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookModel</span></span></span></span> { fetchAll() {   cb();    //    ,   `cb`  ,       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/books'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { bookModel.fetchAll(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(error) { console.log(error);  //       <span class="hljs-string"><span class="hljs-string">"cb is not defined"</span></span> }</code> </pre> <br>  Jika Anda menjalankan kode ini, Anda akan melihat <code>ReferenceError: cb is not defined</code> pesan kesalahan di konsol.  Pesan ini dihasilkan oleh perintah <code>console.log()</code> dari <code>catch</code> , dan bukan oleh JavaScript itu sendiri.  Dalam beberapa kasus, kesalahan seperti itu menyebabkan konsekuensi yang serius.  Misalnya, jika memanggil <code>bookModel.fetchAll();</code>  tersembunyi jauh di dalam serangkaian panggilan fungsi dan salah satu panggilan akan "menelan" kesalahan, itu akan sangat sulit untuk mendeteksi kesalahan seperti itu. <br><br><h3>  <font color="#3AC1EF">‚ñç Fungsi mengembalikan dua nilai</font> </h3><br>  Inspirasi untuk cara selanjutnya menangani kesalahan dalam kode asinkron adalah Go.  Ini memungkinkan fungsi asinkron untuk mengembalikan kesalahan dan hasilnya.  Baca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Singkatnya, maka fungsi asinkron, dengan pendekatan ini, dapat digunakan seperti ini: <br><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">err</span></span>, <span class="hljs-type"><span class="hljs-type">user</span></span>] = await to(UserModel.findById(<span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br>  Secara pribadi, saya tidak suka ini, karena metode penanganan kesalahan ini memperkenalkan gaya pemrograman Go ke dalam JavaScript, yang terlihat tidak wajar, meskipun, dalam beberapa kasus, ini bisa sangat berguna. <br><br><h3>  <font color="#3AC1EF">‚ñçGunakan dari .catch</font> </h3><br>  Cara terakhir untuk menangani kesalahan, yang akan kita bicarakan, adalah dengan menggunakan <code>.catch()</code> . <br><br>  Pikirkan bagaimana cara <code>await</code> bekerja.  Yaitu, penggunaan kata kunci ini menyebabkan sistem menunggu sampai janji itu selesai.  Juga, ingatlah bahwa perintah dari form berjanji.catch <code>promise.catch()</code> juga mengembalikan janji.  Semua ini menunjukkan bahwa kesalahan fungsi asinkron dapat ditangani seperti ini: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> books   <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>     let books = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookModel.fetchAll() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); });</code> </pre> <br>  Dua masalah kecil adalah karakteristik dari pendekatan ini: <br><br><ul><li>  Ini adalah campuran dari fungsi janji dan asinkron.  Untuk menggunakan ini, perlu, seperti dalam kasus serupa lainnya, untuk memahami fitur-fitur dari pekerjaan yang dijanjikan. </li><li>  Pendekatan ini tidak intuitif, karena penanganan kesalahan dilakukan di tempat yang tidak biasa. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Konstruksi async / wait, yang diperkenalkan pada ES7, jelas merupakan peningkatan pada mekanisme pemrograman asinkron JavaScript.  Ini dapat membuat membaca dan men-debug kode lebih mudah.  Namun, untuk menggunakan async / menunggu dengan benar, diperlukan pemahaman yang mendalam tentang janji, karena async / menunggu hanyalah "gula sintaksis" berdasarkan janji. <br><br>  Kami berharap materi ini memungkinkan Anda untuk menjadi lebih akrab dengan async / menunggu, dan apa yang Anda pelajari di sini akan menyelamatkan Anda dari beberapa kesalahan umum yang muncul saat menggunakan konstruksi ini. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan konstruk async / menunggu dalam JavaScript?  Jika demikian, beri tahu kami bagaimana Anda menangani kesalahan dalam kode asinkron. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414373/">https://habr.com/ru/post/id414373/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414361/index.html">Unity3D: Arsitektur Game, ScriptableObjects, Singletones</a></li>
<li><a href="../id414363/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 319 (11-17 Juni 2018)</a></li>
<li><a href="../id414367/index.html">Berderap dalam tiga tahun: apa yang menarik untuk dibaca kembali di blog HashFlare</a></li>
<li><a href="../id414369/index.html">Print Server Windows yang toleran</a></li>
<li><a href="../id414371/index.html">Kelas sekolah dan sketsa kecil rekayasa sosial</a></li>
<li><a href="../id414375/index.html">Perintah untuk bekerja dengan konsol JavaScript di browser dan meningkatkan produktivitas programmer</a></li>
<li><a href="../id414377/index.html">Inovasi literal objek dalam JavaScript ES6</a></li>
<li><a href="../id414379/index.html">"Mereka yang bersedia bertukar kebebasan untuk keamanan tidak layak dengan kebebasan atau keamanan" (sumber asli)</a></li>
<li><a href="../id414381/index.html">Airwheel R8 E-bike: under-rider atau re-bike</a></li>
<li><a href="../id414383/index.html">Kabel bawah laut serat optik juga dapat berfungsi sebagai seismograf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>