<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîô üë©üèæ‚Äçü§ù‚Äçüë®üèª ü§∞üèº Compatibilidad binaria: ahora o nunca üòü üé∑ üèÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traducci√≥n de la publicaci√≥n de Titus Winters en el Grupo de trabajo 21 (WG21) - Comit√© de normalizaci√≥n del lenguaje C ++. El autor analiza un tema i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compatibilidad binaria: ahora o nunca</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474294/"><p>  <i>Traducci√≥n de la publicaci√≥n de Titus Winters en el Grupo de trabajo 21 (WG21) - Comit√© de normalizaci√≥n del lenguaje C ++.</i>  <i>El autor analiza un tema importante: soporte para compatibilidad binaria hacia atr√°s o ABI (interfaz binaria de aplicaci√≥n).</i> <br><br></p><p>  En los √∫ltimos a√±os en WG21, he promovido activamente que el progreso es m√°s importante que la compatibilidad con versiones anteriores.  Pero yo mismo ya no creo en esto, especialmente con respecto al mantenimiento de la compatibilidad binaria (ABI). <a name="habracut"></a>  En las √∫ltimas tres versiones (C ++ 14, C ++ 17 y C ++ 20) ABI fue tan estable como pudimos.  Incluso si WG21 decide romper la compatibilidad con versiones anteriores de ABI en C ++ 23, hemos estado proporcionando compatibilidad binaria en muchas plataformas durante m√°s de 10 a√±os.  En mi opini√≥n, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ley de Hyrum</a> domina en las alteraciones a gran escala de los sistemas de software.  Ahora no puede decir cu√°ntos usuarios tienen la suposici√≥n de la estabilidad de la biblioteca est√°ndar ABI (no importa cu√°n sabio o cu√°n expl√≠cito o impl√≠cito) est√© firmemente "cosido en la subcorteza", tal vez la mitad de los desarrolladores de C ++ en el mundo. </p><br><p> Mantengo una lista de lo que WG21 podr√≠a arreglar en el idioma si decidimos "romper" el ABI.  Y no puedo decir con confianza que el costo total del retrabajo, que implicar√° la implementaci√≥n de solo esta lista, es comparable al costo de violar ABI en todo el ecosistema.  Vimos muchas peque√±as mejoras en la consistencia de la API, la calidad del c√≥digo est√°ndar de la biblioteca, etc., pero sin duda no hay un solo cambio "innovador" que justifique este costo para el desarrollador promedio.  Quiz√°s obtendr√≠amos mejores implementaciones del est√°ndar, dar√≠amos la oportunidad de resolver problemas para implementaciones que no cumplen con las especificaciones est√°ndar de hoy.  Pero ninguna mejora en mi lista claramente vale la pena. </p><br><p>  M√°s importante a√∫n, debido a las limitaciones de ABI, no podemos eliminar p√©rdidas significativas de rendimiento.  No podemos deshacernos del costo significativo de transmitir unique_ptr por valor [el rendimiento de Chandler en CppCon 2019, que se publicar√° m√°s adelante], no podemos cambiar std :: hash o la ubicaci√≥n de la clase en la memoria para unorped_map sin obligar a todos a recopilar todo en todas partes.  El rendimiento de los hash se ha estudiado ampliamente a lo largo de los a√±os y, teniendo en cuenta la optimizaci√≥n de las b√∫squedas en la tabla y el hash adecuado, estamos seguros de que podemos proporcionar una implementaci√≥n desordenada_map / std :: hash que es compatible con API y proporciona un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aumento del rendimiento del</a> 200-300%.  Pero las restricciones ABI no permiten esto.  Estudios adicionales sobre la optimizaci√≥n y el ajuste de SSO para std :: string sugieren un aumento no trivial en el rendimiento (1% en microbenchmarks y escalado): la API no se ve afectada, pero las restricciones ABI no lo permiten. <br><br>  La p√©rdida total de productividad bloqueada exclusivamente por ABI alcanza varios puntos porcentuales, posiblemente hasta un 5-10%.  Esto no es algo de lo que el ecosistema en su conjunto no pueda prescindir, pero puede que no sea aceptable para algunas organizaciones (Google entre ellas).  Esto, por supuesto, es una gran p√©rdida de rendimiento que es aceptable para C ++: recuerde que este es un lenguaje que afirma que no deja espacio para un competidor m√°s productivo.  La mayor√≠a de los usuarios no parecen preocupados por esta degradaci√≥n del rendimiento: hay otras implementaciones de tablas hash para aquellos preocupados por el rendimiento absoluto.  La ineficiencia general asociada con el paso de unique_ptr en valor y otros problemas del lenguaje ABI se destacan en un n√∫mero muy peque√±o de tareas.  Las organizaciones que necesitan la m√°xima productividad pueden seguir su propio camino (y hacerlo), utilizando bibliotecas no est√°ndar y herramientas de configuraci√≥n no est√°ndar.  Esto es natural y debe entenderse claramente. </p><br><br>  Un cambio en ABI afectar√° a un n√∫mero relativamente mayor de usuarios.  Sospecho que una proporci√≥n significativa de estos usuarios no sospecha cu√°n fuerte es su dependencia de ABI.  En el ecosistema de los servidores de Google, casi todo se recopila de la fuente, hay pocas dependencias externas y hay una oportunidad mejor que el promedio para realizar una refactorizaci√≥n a gran escala.  Pero incluso para nosotros, los cambios recientes que rompieron ABI en la biblioteca est√°ndar costaron 5-10 a√±os de ingenier√≠a. <br><p>  El costo total de romper la compatibilidad con versiones anteriores de ABI para todo el ecosistema C ++ puede estimarse de manera conservadora en el " <b>Ingeniero del Milenio</b> ": coordinar la reconstrucci√≥n de cada proveedor de complementos, .so o dll en el mundo requerir√° enormes recursos humanos.  Junto con la separaci√≥n del ecosistema debido a los m√≥dulos C ++ 20, cambiar el ABI en el cronograma de desarrollo e implementaci√≥n de C ++ 23 puede conducir a una separaci√≥n dura del ecosistema. </p><br><br><p>  Hay muchas preguntas que no se pueden responder con esta discusi√≥n.  ¬øCu√°nto tiempo podemos continuar hasta el punto en que cambiar la ABI de solo √∫til se convierta en una necesidad cr√≠tica?  Si elegimos expl√≠citamente el soporte de estabilidad ABI, ¬øqu√© tan costoso ser√° el cambio cuando y cuando surja una necesidad tan cr√≠tica?  Si los problemas de seguridad como Spectre y Meltdown requieren un cambio en la convenci√≥n de llamadas, ¬øcu√°nto costar√° C ++ para superar este hito?  ¬øQu√© proporci√≥n de desarrolladores usan C ++ porque pretendemos poner el rendimiento por encima de todo lo dem√°s?  Peor a√∫n: ¬øcu√°nto tiempo puede C ++ pretender ser el lenguaje m√°s r√°pido y no tener que hacer tales optimizaciones? </p><br><p>  Si conscientemente no podemos permitir o no queremos cambiar el ABI, entonces esta decisi√≥n debe expresarse en voz alta.  Debemos decir claramente que este es un lenguaje que coloca la estabilidad de ABI por encima del √∫ltimo porcentaje de productividad.  Estoy dispuesto a argumentar que en la pr√°ctica este ha sido el caso en los √∫ltimos a√±os.  Necesitamos que los usuarios sepan qu√© esperar de nosotros y que las bibliotecas como Boost, Folly o Absail hagan la elecci√≥n correcta si se necesita rendimiento.  Pero esto no ayuda en absoluto con las restricciones relacionadas con ABI en el lenguaje en s√≠, como el costo de transmitir unique_ptr.  La biblioteca est√°ndar conserva su importancia en este modelo de desarrollo: la biblioteca est√°ndar es lo que usamos para compatibilidad y estabilidad.  Esto puede requerir un cambio en el enfoque y la direcci√≥n del desarrollo: es posible que deseemos dise√±ar para una mayor flexibilidad en condiciones cambiantes, y no para un rendimiento "limpio". </p><br><p>  Si argumentamos que la productividad es m√°s importante que la estabilidad ABI, debemos decidir de inmediato cu√°ndo exactamente "romperemos" la compatibilidad con versiones anteriores y haremos todo lo posible para que el ecosistema acepte dichos cambios.  Y declara clara y en voz alta que vamos por este camino.  Debe comprender que cuanto m√°s tiempo pase entre dichos cambios, m√°s caros se volver√°n, porque con el tiempo habr√° una dependencia cada vez mayor de ABI.  Nuestros "implementadores" dejaron muy claro que los cambios de C ++ 11 que rompen la compatibilidad fueron dolorosos y costosos.  El deseo de evitar la repetici√≥n de dichos costos es natural, pero debe elegir: o no los repetimos, porque no cambiamos el ABI o reducimos los costos. </p><br><p>  En esencia, hay tres posibilidades para WG21: <br><br></p><ol><li>  Decidir en qu√© versi√≥n se cambiar√° la ABI no importa en C ++ 23 o C ++ 26.  Advierta a las personas e inmediatamente desarrolle herramientas y diagn√≥sticos para ayudar a identificar los lugares que se romper√°n.  Se enfoca en pr√°cticas y herramientas m√°s consistentes para soportar futuros cambios de ABI.  A un implementador en particular no le interesa exponer a sus usuarios a las consecuencias de cambiar el ABI; si otras implementaciones no lo hacen, cambiar el ABI deber√≠a ser una actividad coordinada para el beneficio de los futuros usuarios.  Idealmente, debe romper todo, para dejar en claro que el c√≥digo compilado en modo C ++ 23 es incompatible con el c√≥digo compilado en modos anteriores.  Si alguien puede prescindir de la reconstrucci√≥n, y otros tendr√°n errores en el dise√±o o en el tiempo de ejecuci√≥n, esto solo aumentar√° los malentendidos y la decepci√≥n. </li><li>  Decida que nos esforzamos por lograr la estabilidad de ABI formalizando la pr√°ctica de hoy.  Este ha sido el caso durante muchos a√±os cuando los implementadores est√°ndar ten√≠an derecho a vetar los cambios abi de ABI: ya establecimos la compatibilidad con ABI por encima de la pureza y el rendimiento del dise√±o.  Si reconocemos esto y les decimos claramente a los usuarios, el ecosistema ser√° mejor.  El valor de las bibliotecas adicionales crecer√° para aquellos que necesitan exprimir las √∫ltimas ca√≠das de rendimiento, pero no requieren la estabilidad proporcionada por el est√°ndar.  Otros lenguajes orientados al rendimiento pueden desafiar nuestra posici√≥n en el futuro. </li><li>  No poder elegir una direcci√≥n y guardar el status quo.  Este es el peor de los casos para m√≠: seguimos prestando m√°s atenci√≥n a la compatibilidad con ABI.  Decimos "rendimiento" y votamos "compatibilidad binaria".  Tal disonancia da√±a el ecosistema e implica una falta de acuerdo sobre las prioridades del lenguaje.  Espero sinceramente que a trav√©s de los esfuerzos de los implementadores y la DG, lleguemos al consenso necesario. </li></ol><br><p>  Creo que la opci√≥n No. 1 es m√°s adecuada para los usuarios que necesitan el m√°ximo rendimiento, pero tiene un costo incre√≠ble para el ecosistema y puede conducir a la fragmentaci√≥n del lenguaje en el futuro.  La opci√≥n n√∫mero 2 es una opci√≥n aburrida, responsable y digna: es triste admitir que nos pintamos en la esquina de la habitaci√≥n e intentamos minimizar las p√©rdidas asociadas con esto.  Elegir la opci√≥n # 3 significa no administrar, y rezo para que esto se evite: cualquier elecci√≥n expl√≠cita es mejor que la disonancia actual y la incapacidad de llegar a un acuerdo sobre la elecci√≥n de objetivos a largo plazo. <br><br>  Entiendo que hemos alcanzado nuestra posici√≥n actual a trav√©s de muchos peque√±os actos de inacci√≥n aparentemente razonable.  En los √∫ltimos 10 a√±os, no se ha realizado un solo cambio que pueda justificar una violaci√≥n de la compatibilidad binaria, pero la pol√≠tica impl√≠cita de mantener la compatibilidad con versiones anteriores se ha vuelto destructiva para el ecosistema.  Sin embargo, al adoptar expl√≠citamente una pol√≠tica de este tipo, abriremos otra posibilidad para que C ++ salga gradualmente del escenario: no puede ser un lenguaje orientado al sistema y orientado al rendimiento, dejando mucho espacio para un lenguaje m√°s productivo.  En teor√≠a, cada proveedor puede decidir "romper" ABI en cualquier versi√≥n futura, pero la direcci√≥n general del pensamiento parece diferente.  Estoy seguro de que se requiere discusi√≥n y consenso entre los implementadores de la norma y el WG21: ¬øqu√© prioridades debo elegir? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474294/">https://habr.com/ru/post/474294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474286/index.html">An√°lisis detallado del m√©todo simplex</a></li>
<li><a href="../474292/index.html">Tutorial JavaFX: Primeros pasos</a></li>
<li><a href="../474298/index.html">Implementaci√≥n de una puerta de enlace P2P Operaciones de transferencia de tarjeta a tarjeta</a></li>
<li><a href="../474300/index.html">Respaldo confiable, seguro y vers√°til para U2F</a></li>
<li><a href="../474302/index.html">C√≥mo escribir un script de prueba de usabilidad de aplicaci√≥n efectiva</a></li>
<li><a href="../474306/index.html">Haga que los estilos de apuntar, enfocar y estado activo sean diferentes.</a></li>
<li><a href="../474308/index.html">Tipos de API HTTP escritas en Python: experiencia de Instagram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>