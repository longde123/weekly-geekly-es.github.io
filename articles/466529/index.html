<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£ üëÉ üëäüèΩ Tipos de compilaci√≥n en la JVM: Exposici√≥n de la sesi√≥n de magia negra ü§µüèª üöµüèª üë©‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Hoy, su atenci√≥n est√° invitada a una traducci√≥n del art√≠culo, que muestra ejemplos de opciones de compilaci√≥n en la JVM. Se presta es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de compilaci√≥n en la JVM: Exposici√≥n de la sesi√≥n de magia negra</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/">  Hola a todos! <br><br>  Hoy, su atenci√≥n est√° invitada a una traducci√≥n del art√≠culo, que muestra ejemplos de opciones de compilaci√≥n en la JVM.  Se presta especial atenci√≥n a la compilaci√≥n AOT compatible con Java 9 y superior. <br><br>  Que tengas una buena lectura! <br><a name="habracut"></a><br>  Supongo que cualquiera que haya programado en Java ha o√≠do hablar de la compilaci√≥n instant√°nea (JIT), y posiblemente de la compilaci√≥n antes de la ejecuci√≥n (AOT).  Adem√°s, no es necesario explicar qu√© son los idiomas "interpretados".  Este art√≠culo explicar√° c√≥mo se implementan todas estas caracter√≠sticas en la m√°quina virtual Java, JVM. <br><br>  Probablemente sepa que al programar en Java, necesita ejecutar un compilador (usando el programa "javac") que recopila el c√≥digo fuente de Java (archivos .java) en el c√≥digo de bytes de Java (archivos .class).  Java bytecode es un lenguaje intermedio.  Se llama "intermedio" porque no es entendido por un dispositivo inform√°tico real (CPU) y no puede ser ejecutado por una computadora y, por lo tanto, representa una forma de transici√≥n entre el c√≥digo fuente y el c√≥digo m√°quina "nativo" ejecutado en el procesador. <br><br>  Para que el bytecode de Java haga un trabajo espec√≠fico, hay 3 formas de hacerlo: <br><br><ol><li>  Ejecute directamente el c√≥digo intermedio.  Es mejor y m√°s correcto decir que necesita ser "interpretado".  La JVM tiene un int√©rprete de Java.  Como sabe, para que la JVM funcione, debe ejecutar el programa "java". </li><li>  Justo antes de ejecutar el c√≥digo intermedio, comp√≠lelo en c√≥digo nativo y fuerce a la CPU a ejecutar este c√≥digo nativo reci√©n horneado.  Por lo tanto, la compilaci√≥n se lleva a cabo justo antes de la ejecuci√≥n (Just in Time) y se llama "din√°mica". </li><li>  3Lo primero, incluso antes de que se inicie el programa, el c√≥digo intermedio se traduce al nativo y lo ejecuta a trav√©s de la CPU de principio a fin.  Esta compilaci√≥n se realiza antes de la ejecuci√≥n y se llama AoT (Ahead of Time). </li></ol><br>  Entonces, (1) es el trabajo del int√©rprete, (2) es el resultado de la compilaci√≥n JIT y (3) es el resultado de la compilaci√≥n AOT. <br><br>  En aras de la exhaustividad, mencionar√© que hay un cuarto enfoque: interpretar directamente el c√≥digo fuente, pero en Java esto no se acepta.  Esto se hace, por ejemplo, en Python. <br>  Ahora veamos c√≥mo funciona "java" como (1) el int√©rprete de (2) el compilador JIT y / o (3) el compilador AOT, y cu√°ndo. <br><br>  En resumen, como regla, "java" hace tanto (1) como (2).  A partir de Java 9, tambi√©n es posible una tercera opci√≥n. <br><br>  Aqu√≠ est√° nuestra clase de <code>Test</code> , que se utilizar√° en futuros ejemplos. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  Como puede ver, hay un m√©todo <code>main</code> que crea instancias del objeto <code>Test</code> y llama c√≠clicamente a la funci√≥n <code>f</code> 10 veces seguidas.  La funci√≥n <code>f</code> no hace casi nada. <br><br>  Entonces, si compila y ejecuta el c√≥digo anterior, la salida ser√° bastante esperada (por supuesto, los valores del tiempo transcurrido ser√°n diferentes para usted): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  Y ahora la pregunta es: ¬øes esta conclusi√≥n el resultado del trabajo de "java" como int√©rprete, es decir, la opci√≥n (1), "java" como un compilador JIT, es decir, la opci√≥n (2) o est√° relacionado de alguna manera con la compilaci√≥n AOT , es decir, la opci√≥n (3)?  En este art√≠culo voy a encontrar las respuestas correctas a todas estas preguntas. <br><br>  La primera respuesta que quiero dar es muy probable que solo (1) tenga lugar aqu√≠.  Digo "muy probablemente", porque no s√© si alguna variable de entorno est√° configurada aqu√≠ que cambiar√≠a las opciones predeterminadas de JVM.  Si no se instala nada superfluo, y as√≠ es como funciona "java" por defecto, entonces aqu√≠ estamos observando al 100% solo la opci√≥n (1), es decir, el c√≥digo se interpreta completamente.  Estoy seguro de esto, ya que: <br><br><ul><li>  De acuerdo con la documentaci√≥n de Java, la <code>-XX:CompileThreshold=invocations</code> se inicia con las <code>invocations=1500</code> predeterminadas <code>invocations=1500</code> en la JVM del cliente (a continuaci√≥n se describe m√°s sobre la JVM del cliente).  Como lo ejecuto solo 10 veces y 10 &lt;1500, no estamos hablando de compilaci√≥n din√°mica aqu√≠.  Por lo general, esta opci√≥n de l√≠nea de comando especifica cu√°ntas veces (m√°ximo) debe interpretarse la funci√≥n antes de que comience el paso de compilaci√≥n din√°mica.  Me detendr√© en esto a continuaci√≥n. </li><li>  De hecho, ejecut√© este c√≥digo con marcas de diagn√≥stico, as√≠ que s√© si se compil√≥ din√°micamente.  Tambi√©n explicar√© este punto a continuaci√≥n. </li></ul><br>  Tenga en cuenta: JVM puede funcionar en modo cliente o servidor, y las opciones establecidas de forma predeterminada en el primer y segundo caso ser√°n diferentes.  Como regla general, la decisi√≥n sobre el modo de inicio se toma autom√°ticamente, dependiendo del entorno o la computadora donde se lanz√≥ la JVM.  En lo sucesivo, especificar√© la opci√≥n <code>‚Äìclient</code> durante todos los inicios, para no dudar de que el programa se est√° ejecutando en modo cliente.  Esta opci√≥n no afectar√° los aspectos que quiero demostrar en esta publicaci√≥n. <br><br>  Si ejecuta "java" con la <code>-XX:PrintCompilation</code> , el programa imprimir√° una l√≠nea cuando la funci√≥n se compila din√°micamente.  No olvide que la compilaci√≥n JIT se realiza para cada funci√≥n por separado, algunas funciones de la clase pueden permanecer en bytecode (es decir, no compiladas), mientras que otras pueden haber pasado la compilaci√≥n JIT, es decir, listas para la ejecuci√≥n directa en el procesador . <br><br>  A continuaci√≥n tambi√©n agrego la opci√≥n <code>-Xbatch</code> .  La opci√≥n <code>-Xbatch</code> solo <code>-Xbatch</code> necesaria para que la salida se vea m√°s presentable;  de lo contrario, la compilaci√≥n JIT procede de manera competitiva (junto con la interpretaci√≥n), y el resultado despu√©s de la compilaci√≥n a veces puede parecer extra√±o en tiempo de ejecuci√≥n (debido a <code>-XX:PrintCompilation</code> ).  Sin embargo, la opci√≥n <code>‚ÄìXbatch</code> deshabilita la compilaci√≥n en segundo plano, por lo tanto, antes de ejecutar la compilaci√≥n JIT, la ejecuci√≥n de nuestro programa se detendr√°. <br><br>  (En aras de la legibilidad, escribir√© cada opci√≥n desde una nueva l√≠nea) <br><br><pre> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  No insertar√© la salida de este comando aqu√≠, porque de forma predeterminada, la JVM compila muchas funciones internas (relacionadas, por ejemplo, con los paquetes java, sun, jdk), por lo que la salida ser√° muy larga, por lo que, en mi pantalla, hay 274 l√≠neas en las funciones internas , y algunos m√°s hasta la conclusi√≥n del programa en s√≠).  Para facilitar esta investigaci√≥n, cancelar√© la compilaci√≥n JIT para clases internas o la habilitar√© selectivamente solo para mi m√©todo ( <code>Test.f</code> ).  Para hacer esto, especifique una opci√≥n m√°s, <code>-XX:CompileCommand</code> .  Puede especificar muchos comandos (compilaci√≥n), por lo que ser√≠a m√°s f√°cil colocarlos en un archivo separado.  Afortunadamente, tenemos la opci√≥n <code>-XX:CompileCommandFile</code> .  Entonces, pasa a crear el archivo.  Lo llamar√© <code>hotspot_compiler</code> por una raz√≥n que explicar√© en breve y escribir√© lo siguiente: <br><br><pre> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  En este caso, debe quedar completamente claro que excluimos todas las funciones (la √∫ltima *) en todas las clases de todos los paquetes que comienzan con java, jdk y sun (los nombres de los paquetes est√°n separados por /, y puede usar *).  El comando <code>quiet</code> le dice a la JVM que no escriba nada sobre las clases excluidas, por lo que solo las que se compilan ahora se enviar√°n a la consola.  Entonces, corro: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  Antes de informarle sobre la salida de este comando, le recuerdo que llam√© a este archivo <code>hotspot_compiler</code> , porque parece (no verifiqu√©) que en Oracle JDK el nombre <code>.hotspot_compiler</code> est√° configurado de manera predeterminada para el archivo con los comandos del compilador. <br><br>  Entonces la conclusi√≥n es: <br><br><pre> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  Primero, no s√© por qu√© algunos m√©todos <code>java.lang.invoke.MethodHandler.</code> todav√≠a se est√°n compilando <code>java.lang.invoke.MethodHandler.</code>  Probablemente, algunas cosas simplemente no se pueden apagar.  Como entiendo cu√°l es el problema, actualizar√© esta publicaci√≥n.  Sin embargo, como puede ver, todos los dem√°s pasos de compilaci√≥n (anteriormente hab√≠a 274 l√≠neas) ahora han desaparecido.  En otros ejemplos, tambi√©n eliminar√© <code>java.lang.invoke.MethodHandler</code> de la salida del registro de compilaci√≥n. <br><br>  Veamos a qu√© hemos llegado.  Ahora tenemos un c√≥digo simple donde ejecutamos nuestra funci√≥n 10 veces.  Mencion√© anteriormente que esta funci√≥n se interpreta, no se compila, como se indica en la documentaci√≥n, y ahora la vemos en los registros (al mismo tiempo, no la vemos en los registros de compilaci√≥n, y esto significa que no est√° sujeta a la compilaci√≥n JIT).  Bueno, acabas de ver la herramienta "java" en acci√≥n, interpretando y solo interpretando nuestra funci√≥n en el 100% de los casos.  Entonces, podemos marcar la casilla que descubri√≥ con la opci√≥n (1).  Pasamos a (2), compilaci√≥n din√°mica. <br><br>  De acuerdo con la documentaci√≥n, puede ejecutar la funci√≥n 1.500 veces y asegurarse de que la compilaci√≥n JIT realmente est√© sucediendo.  Sin embargo, tambi√©n puede usar la <code>-XX:CompileThreshold=invocations</code> llamada <code>-XX:CompileThreshold=invocations</code> , estableciendo el valor deseado en lugar de 1500.  Se√±alemos aqu√≠ 5. Esto significa que esperamos lo siguiente: despu√©s de 5 "interpretaciones" de nuestra funci√≥n f, la JVM debe compilar el m√©todo y luego ejecutar la versi√≥n compilada. <br>  java -client -Xbatch <br><br><pre> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  Si ejecut√≥ este comando, es posible que haya notado que nada ha cambiado en comparaci√≥n con el ejemplo anterior.  Es decir, la compilaci√≥n a√∫n no ocurre.  Resulta que, de acuerdo con la documentaci√≥n, <code>-XX:CompileThreshold</code> solo funciona cuando <code>TieredCompilation</code> deshabilitado, que es el valor predeterminado.  Se <code>-XX:-TieredCompilation</code> as√≠: <code>-XX:-TieredCompilation</code> .  La compilaci√≥n escalonada es una caracter√≠stica introducida en Java 7 para mejorar tanto el lanzamiento como la velocidad de crucero de la JVM.  En el contexto de esta publicaci√≥n, no es importante, as√≠ que si√©ntete libre de deshabilitarla.  Ahora ejecutemos este comando nuevamente: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  Aqu√≠ est√° la salida (recuerdo, he perdido las l√≠neas con respecto a <code>java.lang.invoke.MethodHandle</code> ): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  Damos la bienvenida (¬°hola!) A la funci√≥n compilada din√°micamente Test.f o <code>Test::&lt;init&gt;</code> inmediatamente despu√©s de llamar al n√∫mero 5, porque configur√© CompileThreshold en 5. La JVM interpreta la funci√≥n 5 veces, luego la compila y finalmente ejecuta la versi√≥n compilada.  Como la funci√≥n est√° compilada, deber√≠a ejecutarse m√°s r√°pido, pero no podemos verificar esto aqu√≠, ya que esta funci√≥n no hace nada.  Creo que este es un buen tema para una publicaci√≥n separada. <br><br>  Como probablemente ya haya adivinado, aqu√≠ se compila otra funci√≥n, a saber, <code>Test::&lt;init&gt;</code> , que es un constructor de la clase <code>Test</code> .  Como el c√≥digo llama al constructor (nueva <code>Test()</code> ), cada vez que <code>f</code> llama <code>f</code> , se compila simult√°neamente con la funci√≥n <code>f</code> , exactamente despu√©s de 5 llamadas. <br><br>  En principio, esto puede terminar la discusi√≥n de la opci√≥n (2), compilaci√≥n JIT.  Como puede ver, en este caso, la funci√≥n es interpretada primero por la JVM, luego compilada din√°micamente despu√©s de una interpretaci√≥n qu√≠ntuple.  Me gustar√≠a agregar el √∫ltimo detalle con respecto a la compilaci√≥n JIT, es decir, mencionar la opci√≥n <code>-XX:+PrintAssembly</code> .  Como su nombre lo indica, env√≠a a la consola una versi√≥n compilada de la funci√≥n (versi√≥n compilada = c√≥digo m√°quina nativo = c√≥digo ensamblador).  Sin embargo, esto solo funcionar√° si hay un desensamblador en la ruta de la biblioteca.  Supongo que el desensamblador puede diferir en diferentes JVM, pero en este caso estamos tratando con hsdis, un desensamblador para openjdk.  El c√≥digo fuente de la biblioteca hsdis o su archivo binario se puede tomar en diferentes lugares.  En este caso, compil√© este archivo y puse <code>hsdis-amd64.so</code> en <code>JAVA_HOME/lib/server</code> . <br><br>  Entonces ahora podemos ejecutar este comando.  Pero primero debo agregar eso para ejecutar <code>-XX:+PrintAssembly</code> tambi√©n debe agregar la <code>-XX:+UnlockDiagnosticVMOptions</code> , y debe seguir antes de la opci√≥n <code>PrintAssembly</code> .  Si esto no se hace, la JVM le dar√° una advertencia sobre el uso incorrecto de la opci√≥n <code>PrintAssembly</code> .  Ejecutemos este c√≥digo: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  La salida ser√° larga y habr√° l√≠neas como: <br><br><pre> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  Como puede ver, las funciones correspondientes se compilan en c√≥digo m√°quina nativo. <br><br>  Finalmente, discuta la opci√≥n 3, AOT.  La compilaci√≥n antes de la ejecuci√≥n, AOT, no estaba disponible en Java antes de la versi√≥n 9. <br><br>  Ha aparecido una nueva herramienta en JDK 9, jaotc, como su nombre lo indica, es un compilador AOT para Java.  La idea es esta: ejecute el compilador Java "javac", luego el compilador AOT para Java "jaotc", y luego ejecute el JVM "java" como de costumbre.  La JVM normalmente realiza interpretaci√≥n y compilaci√≥n JIT.  Sin embargo, si la funci√≥n tiene c√≥digo compilado AOT, lo usa directamente y no recurre a la interpretaci√≥n o la compilaci√≥n JIT.  D√©jame explicarte: no tienes que ejecutar el compilador AOT, es opcional, y si lo usas, solo puedes compilar las clases que deseas antes de que se ejecute. <br><br>  Construyamos una biblioteca que consista en una versi√≥n compilada AOT de <code>Test::f</code> .  No olvide: para hacerlo usted mismo, necesitar√° JDK 9 en la compilaci√≥n 150+. <br><br><pre> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  Como resultado, <code>libTest.so</code> genera <code>libTest.so</code> , una biblioteca que contiene un c√≥digo nativo de funciones compilado por AOT incluido en la clase <code>Test</code> .  Puede ver los caracteres definidos en esta biblioteca: <br><br><pre> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  En nuestra conclusi√≥n, entre otras cosas, habr√°: <br><br><pre> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  Entonces, todas nuestras funciones, constructor, <code>f</code> , m√©todo est√°tico <code>main</code> est√°n presentes en la biblioteca <code>libTest.so</code> . <br><br>  Como en el caso de la opci√≥n "java" correspondiente, en este caso la opci√≥n puede ir acompa√±ada de un archivo, para esto est√° la opci√≥n ‚Äìcompile-command de jaotc.  JEP 295 proporciona ejemplos relevantes que no mostrar√© aqu√≠. <br><br>  Ejecutemos ahora "java" y veamos si se utilizan m√©todos compilados por AOT.  Si ejecuta "java" como antes, entonces la biblioteca AOT no se usar√°, y esto no es sorprendente.  Para usar esta nueva funci√≥n, se proporciona la opci√≥n <code>-XX:AOTLibrary</code> , que debe especificar: <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  Puede especificar varias bibliotecas AOT, separadas por comas. <br><br>  El resultado de este comando es exactamente el mismo que cuando se inicia "java" sin <code>AOTLibrary</code> , ya que el comportamiento del programa Test no ha cambiado en absoluto.  Para verificar si se utilizan funciones compiladas por AOT, puede agregar otra nueva opci√≥n, <code>-XX:+PrintAOT</code> . <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Antes de la salida del programa de <code>Test</code> , este comando muestra lo siguiente: <br><br><pre> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  Seg√∫n lo planeado, se carga la biblioteca AOT y se utilizan funciones compiladas por AOT. <br><br>  Si est√° interesado, puede ejecutar el siguiente comando y verificar si est√° ocurriendo la compilaci√≥n JIT. <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Como se esperaba, la compilaci√≥n JIT no ocurre, ya que los m√©todos en la clase Test se compilan antes de la ejecuci√≥n y se proporcionan como una biblioteca. <br><br>  Una posible pregunta es: si proporcionamos un c√≥digo de funci√≥n nativo, entonces, ¬øc√≥mo determina la JVM si el c√≥digo nativo es obsoleto / obsoleto?  Como √∫ltimo ejemplo, modifiquemos la funci√≥n <code>f</code> y establezcamos a a 6. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  Hice esto solo para modificar el archivo de clase.  Ahora hacemos compilaci√≥n de javac y ejecutamos el mismo comando que el anterior. <br><br><pre> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Como puede ver, no ejecut√© "jaotc" despu√©s de "javac", por lo que el c√≥digo de la biblioteca AOT ahora es antiguo e incorrecto, y la funci√≥n <code>f</code> tiene a = 5. <br><br>  La salida del comando "java" anterior demuestra: <br><br><pre> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  Esto significa que las funciones en este caso se compilaron din√°micamente, por lo que no se utiliz√≥ el c√≥digo resultante de la compilaci√≥n AOT.  Entonces, se ha detectado un cambio en el archivo de clase.  Cuando la compilaci√≥n se realiza usando javac, su huella digital se ingresa en la clase, y la huella digital de la clase tambi√©n se almacena en la biblioteca AOT.  Dado que la nueva huella digital de la clase difiere de la almacenada en la biblioteca AOT, no se utiliz√≥ el c√≥digo nativo compilado por adelantado (AOT).  Eso es todo lo que quer√≠a decirte sobre la √∫ltima opci√≥n de compilaci√≥n, antes de la ejecuci√≥n. <br><br>  En este art√≠culo intent√© explicar e ilustrar con ejemplos realistas simples c√≥mo JVM ejecuta c√≥digo Java: interpret√°ndolo, compilando din√°micamente (JIT) o por adelantado (AOT); adem√°s, la √∫ltima oportunidad apareci√≥ solo en JDK 9. Espero que hayas descubierto algo nuevo </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466529/">https://habr.com/ru/post/466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466517/index.html">Entrenamiento de localizaci√≥n de la Universidad de Washington</a></li>
<li><a href="../466519/index.html">An√°lisis detallado de AWS Lambda</a></li>
<li><a href="../466521/index.html">C for Metal: metal precioso para la inform√°tica en tarjetas gr√°ficas Intel</a></li>
<li><a href="../466525/index.html">¬øQu√© es un dise√±o de iPhone PSD y c√≥mo usarlo?</a></li>
<li><a href="../466527/index.html">Probar la funcionalidad del usuario del sitio web con los objetos de p√°gina de Capybara</a></li>
<li><a href="../466533/index.html">Pastilda: resultados</a></li>
<li><a href="../466535/index.html">Repensar deepClone</a></li>
<li><a href="../466537/index.html">Uso de m√≥dulos JavaScript en producci√≥n: estado actual de las cosas. Parte 1</a></li>
<li><a href="../466539/index.html">Uso de m√≥dulos JavaScript en producci√≥n: estado actual de las cosas. Parte 2</a></li>
<li><a href="../466541/index.html">Uso de DbTool para sembrar bases de datos en aplicaciones .NET (Core)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>