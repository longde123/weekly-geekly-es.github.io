<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏿 🥊 🤾 Organisasi interaksi microservices yang efektif 🤜🏽 🙆🏾 🔕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, arsitektur microservice telah menikmati popularitas. Kinerja dan skalabilitas solusi berdasarkan solusi tersebut dapat bergantung pada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Organisasi interaksi microservices yang efektif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/421579/">  Baru-baru ini, arsitektur microservice telah menikmati popularitas.  Kinerja dan skalabilitas solusi berdasarkan solusi tersebut dapat bergantung pada bagaimana interaksi layanan mikro.  Interaksi ini mungkin sinkron atau asinkron.  Materi, terjemahan yang kami sajikan untuk perhatian Anda hari ini, membahas metode sinkron untuk interaksi layanan mikro.  Yaitu, kami akan fokus pada studi dua teknologi: HTTP / 1.1 dan gRPC.  Teknologi pertama diwakili oleh panggilan HTTP standar.  Yang kedua didasarkan pada penggunaan kerangka kerja RPC berkinerja tinggi Google.  Penulis artikel menyarankan untuk melihat kode yang diperlukan untuk mengimplementasikan interaksi layanan microser menggunakan HTTP / 1.1 dan gRPC, mengambil pengukuran kinerja, dan memilih teknologi yang memungkinkan mengatur pertukaran data antara layanan microser dengan cara terbaik. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/8f/rs/wi/8frswixgdwda7hy0qyauot2ze0c.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Aplikasi normal</font> </h2><br>  Mari kita mulai dari yang kecil dan membuat sistem dua layanan microser yang dapat saling berinteraksi.  Harap dicatat bahwa mode klaster tidak digunakan di sini.  Berikut adalah diagram aplikasi kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e7/4d1/da1/5e74d1da16523f9fbd60e31e08db4fe4.png"></div><br>  <i><font color="#999999">Arsitektur Aplikasi Khas</font></i> <br><br>  Aplikasi terdiri dari komponen-komponen berikut: <br><br><ul><li>  Alat Pengujian Sistem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jMeter</a> . </li><li>  Layanan A: Layanan mikro yang mengeksekusi permintaan untuk layanan B dan mengembalikan respons yang diterima darinya. </li><li>  Layanan B (Layanan B): layanan mikro yang mengirimkan data JSON statis sebagai tanggapan atas permintaan setelah penundaan 10 milidetik yang digunakan untuk semua API. </li><li>  Mesin virtual (VM 1 dan VM 2): Amazon EC2 t2.xlarge instance. </li></ul><br><h3>  <font color="#3AC1EF">▍HTTP / 1.1</font> </h3><br>  HTTP / 1.1 adalah teknologi standar untuk mengatur interaksi layanan microser, yang digunakan saat menggunakan perpustakaan HTTP seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aksioma</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">superagent</a> . <br><br>  Berikut adalah kode layanan B yang mengimplementasikan API sistem kami: <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">server</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.route</span></span>({  <span class="hljs-attribute"><span class="hljs-attribute">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>,  path: <span class="hljs-string"><span class="hljs-string">'/'</span></span>,  handler: async (request, h) =&gt; {    const response = await new <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>((resolve) =&gt; {      <span class="hljs-built_in"><span class="hljs-built_in">setTimeout</span></span>(() =&gt; {        <span class="hljs-built_in"><span class="hljs-built_in">resolve</span></span>({          id: 1,          name: <span class="hljs-string"><span class="hljs-string">'Abhinav Dhasmana'</span></span>,          enjoys_coding: true,        });      }, 10);    });    <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.response</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span>);  }, });</code> </pre> <br>  Berikut adalah kode untuk layanan A yang mengakses layanan B menggunakan HTTP / 1.1: <br><br><pre> <code class="hljs cs">server.route({ method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, handler: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (request, h) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Axios({ url: <span class="hljs-string"><span class="hljs-string">'http://localhost:8001/'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h.response(response.data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Boom.clientTimeout(err); } }, });</code> </pre> <br>  Dengan menjalankan layanan microser ini, kita dapat memanfaatkan jMeter untuk menjalankan tes kinerja.  Kami akan mencari tahu bagaimana sistem berperilaku ketika bekerja dengan 50 pengguna, yang masing-masing melakukan 2000 permintaan.  Seperti yang dapat dilihat pada gambar berikut, median hasil pengukuran adalah 37 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/d94/aea/2ebd94aea7752eb87d25f2c4cbdfdd1a.png"></div><br>  <i><font color="#999999">Hasil Penelitian dari Sistem Mode Normal Menggunakan HTTP / 1.1 Menggunakan jMeter</font></i> <br><br><h3>  <font color="#3AC1EF">▍gRPC</font> </h3><br>  gRPC menggunakan teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Protokol Buffer</a> secara default.  Oleh karena itu, menggunakan gRPC, selain kode dua layanan, kita perlu menulis kode proto-file, yang menggambarkan antarmuka antar modul sistem. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> SampleDataService { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GetSampleData (Empty) returns (SampleData) {} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> SampleData { <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">bool</span></span> enjoys_coding = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Empty {}</code> </pre> <br>  Sekarang, karena sekarang kami berencana untuk menggunakan gRPC, kami perlu menulis ulang kode layanan B: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> grpc = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'grpc'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proto = grpc.load(<span class="hljs-string"><span class="hljs-string">'serviceB.proto'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> grpc.Server(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetSampleData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">call, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {     <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Abhinav Dhasmana'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">enjoys_coding</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span>); }; server.addService(proto.SampleDataService.service, { GetSampleData, }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = process.env.PORT; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'port'</span></span>, port); server.bind(<span class="hljs-string"><span class="hljs-string">`0.0.0.0:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, grpc.ServerCredentials.createInsecure()); server.start(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'grpc server is running'</span></span>);</code> </pre> <br>  Perhatikan beberapa fitur kode ini: <br><br><ul><li>  Perintah <code>const server = new grpc.Server();</code>  kami membuat server grpc. </li><li>  <code>server.addService(proto...</code> perintah <code>server.addService(proto...</code> kami menambahkan layanan ke server. </li><li>  Perintah <code>server.bind(`0.0.0.0:${port}...</code> digunakan untuk mengikat port dan kredensial. </li></ul><br>  Sekarang tulis ulang layanan A menggunakan gRPC: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> protoPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/../serviceB/serviceB.proto`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proto = grpc.load(protoPath); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> proto.SampleDataService(<span class="hljs-string"><span class="hljs-string">'localhost:8001'</span></span>, grpc.credentials.createInsecure()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getDataViagRPC = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { client.GetSampleData({}, (err, response) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.err) {     resolve(response);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     reject(err);   } }); }); server.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (request, h) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allResults = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getDataViagRPC();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h.response(allResults); }, });</code> </pre> <br>  Di antara fitur-fitur kode ini adalah sebagai berikut: <br><br><ul><li>  <code>const client = new proto.SampleDataService...</code> perintah <code>const client = new proto.SampleDataService...</code> kami membuat klien grpc. </li><li>  Panggilan jarak jauh dilakukan menggunakan perintah <code>client.GetSampleData({}...</code> </li></ul><br>  Sekarang mari kita menguji apa yang kita dapatkan dengan jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/48d/3c3/d1148d3c34e8b4b5fbdd62fbf546863c.png"></div><br>  <i><font color="#999999">Hasil Penelitian dari Sistem Mode Normal Menggunakan gRPC Menggunakan jMeter</font></i> <br><br>  Setelah perhitungan sederhana, Anda dapat mengetahui bahwa solusi menggunakan gRPC adalah 27% lebih cepat daripada solusi menggunakan HTTP / 1.1. <br><br><h2>  <font color="#3AC1EF">Aplikasi cluster</font> </h2><br>  Berikut adalah diagram aplikasi yang mirip dengan yang baru saja kami teliti tetapi bekerja dalam mode klaster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/2d0/d0b/72e2d0d0bd3566507d10a35e9b63f518.png"></div><br>  <i><font color="#999999">Arsitektur Aplikasi Mode Cluster</font></i> <br><br>  Jika Anda membandingkan arsitektur ini dengan yang sebelumnya dipertimbangkan, perubahan berikut dapat dicatat: <br><br><ul><li>  Ada load balancer (Load Balancer), yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NGINX</a> . </li><li>  Layanan B sekarang hadir dalam tiga contoh yang mendengarkan pada port yang berbeda. </li></ul><br>  Arsitektur serupa adalah tipikal untuk proyek nyata. <br><br>  Menjelajahi HTTP / 1.1 dan gRPC di lingkungan baru. <br><br><h3>  <font color="#3AC1EF">▍HTTP / 1.1</font> </h3><br>  Saat menggunakan layanan microser yang menggunakan HTTP / 1.1 di lingkungan yang berkerumun, kode mereka tidak harus diubah.  Anda hanya perlu mengkonfigurasi nginx untuk mengatur keseimbangan lalu lintas layanan B. Dalam kasus kami, untuk melakukan ini, Anda perlu membawa file <code>/etc/nginx/sites-available/default</code> ke form ini: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> httpservers {  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8001</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8002</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8003</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> {  <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / {     <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://httpservers;  } }</code> </pre> <br>  Sekarang mari kita jalankan apa yang kita miliki dan lihat hasil pengujian sistem menggunakan jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/fe5/3b6/113fe53b66aab039270b109b9f570e6b.png"></div><br>  <i><font color="#999999">Hasil penelitian untuk sistem berbasis cluster menggunakan HTTP / 1.1 menggunakan jMeter</font></i> <br><br>  Median dalam hal ini adalah 41 ms. <br><br><h3>  <font color="#3AC1EF">▍gRPC</font> </h3><br>  Dukungan GRPC muncul di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nginx 1.13.10</a> .  Oleh karena itu, kita memerlukan versi nginx terbaru, untuk instalasi yang perintah <code>sudo apt-get install nginx</code> tidak cocok. <br><br>  Juga di sini kita tidak menggunakan Node.js dalam mode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster</a> , karena gRPC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak didukung</a> dalam mode ini. <br><br>  Untuk menginstal versi nginx terbaru, gunakan urutan perintah berikut: <br><br><pre> <code class="hljs powershell">sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install <span class="hljs-literal"><span class="hljs-literal">-y</span></span> software<span class="hljs-literal"><span class="hljs-literal">-properties</span></span><span class="hljs-literal"><span class="hljs-literal">-common</span></span> sudo <span class="hljs-built_in"><span class="hljs-built_in">add-apt</span></span><span class="hljs-literal"><span class="hljs-literal">-repository</span></span> ppa:nginx/stable sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> update sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install nginx</code> </pre> <br>  Selain itu, kami akan memerlukan sertifikat SSL.  Sertifikat yang ditandatangani sendiri dapat dibuat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openSSL</a> : <br><br><pre> <code class="hljs powershell">openssl req <span class="hljs-literal"><span class="hljs-literal">-x509</span></span> <span class="hljs-literal"><span class="hljs-literal">-newkey</span></span> rsa:<span class="hljs-number"><span class="hljs-number">2048</span></span> <span class="hljs-literal"><span class="hljs-literal">-nodes</span></span> <span class="hljs-literal"><span class="hljs-literal">-sha256</span></span> <span class="hljs-literal"><span class="hljs-literal">-subj</span></span> <span class="hljs-string"><span class="hljs-string">'/CN=localhost'</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-keyout</span></span> localhost<span class="hljs-literal"><span class="hljs-literal">-privatekey</span></span>.pem <span class="hljs-literal"><span class="hljs-literal">-out</span></span> localhost<span class="hljs-literal"><span class="hljs-literal">-certificate</span></span>.pem</code> </pre> <br>  Untuk menggunakan gRPC, Anda perlu mengedit file / <code>etc/nginx/sites-available/default</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> httpservers {  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8001</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8002</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8003</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> {  <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / {     <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://httpservers;  } }</code> </pre> <br>  Sekarang semuanya siap untuk menguji solusi cluster gRPC menggunakan jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/618/666/8d2618666f9a8593328d15850271803e.png"></div><br>  <i><font color="#999999">Hasil dari sistem mode kluster menggunakan gRPC menggunakan jMeter</font></i> <br><br>  Dalam hal ini, median adalah 28 ms, yang 31% lebih cepat dibandingkan dengan indikator yang sama yang diperoleh ketika memeriksa solusi HTTP / 1.1 berkerumun. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hasil penelitian menunjukkan bahwa aplikasi berbasis microservice yang menggunakan gRPC adalah sekitar 30% lebih produktif daripada aplikasi serupa yang menggunakan HTTP / 1.1 untuk bertukar data antara layanan microser.  Kode sumber untuk proyek yang dibahas dalam artikel ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda mengembangkan layanan microser, silakan bicarakan bagaimana Anda mengatur pertukaran data di antara mereka. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421579/">https://habr.com/ru/post/id421579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421569/index.html">Yang paling penting dengan Gamescom 2018 - Nvidia RTX, Cyberpunk 2077, Metro Exodus</a></li>
<li><a href="../id421571/index.html">Kivy. Xamarin Bereaksi Asli. Tiga kerangka kerja - satu percobaan (bagian 3)</a></li>
<li><a href="../id421573/index.html">Intisari Desain Makanan Agustus 2018</a></li>
<li><a href="../id421575/index.html">Konfrontasi antara Yandex dan Roskomnadzor sedang terjadi, dalam sehari mesin pencari mungkin akan diblokir sebagian</a></li>
<li><a href="../id421577/index.html">Eksploit untuk kerentanan tidak tertutup dalam Penjadwal Tugas Windows diterbitkan (terjemahan)</a></li>
<li><a href="../id421583/index.html">Ke mana harus kuliah untuk belajar spesialis IT? + survei</a></li>
<li><a href="../id421585/index.html">Bagaimana kontes retro Cossack memutuskan</a></li>
<li><a href="../id421587/index.html">[Yekaterinburg, pengumuman] Java Mitap - JUG.EKB</a></li>
<li><a href="../id421589/index.html">Metamorfosis: pemrograman molekul bentuk</a></li>
<li><a href="../id421591/index.html">Sistem anggaran untuk pengawasan video nirkabel (Wi-Fi) otonom (dari baterai)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>