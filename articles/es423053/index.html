<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßö üöø üàπ Estructura y solo lectura: c√≥mo evitar la degradaci√≥n del rendimiento ü•§ üßëüèø‚Äçü§ù‚Äçüßëüèº „Ä∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usar el tipo Struct y el modificador de solo lectura a veces puede causar una degradaci√≥n del rendimiento. Hoy hablaremos sobre c√≥mo evitar esto usand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estructura y solo lectura: c√≥mo evitar la degradaci√≥n del rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423053/">  Usar el tipo Struct y el modificador de solo lectura a veces puede causar una degradaci√≥n del rendimiento.  Hoy hablaremos sobre c√≥mo evitar esto usando un analizador de c√≥digo de c√≥digo abierto: ErrorProne.NET. <br><br><img src="https://habrastorage.org/webt/wc/aa/xn/wcaaxny16t6cvqvl2euetypst3o.jpeg"><a name="habracut"></a><br><br>  Como probablemente sepa por mis publicaciones anteriores, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El modificador 'in' y las estructuras de solo lectura en C #</a> " ("El modificador en y las estructuras de solo lectura en C #") y " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trampas de rendimiento de locales de referencia y devoluciones de referencia en C #</a> " (" Las trampas de rendimiento cuando se usan variables locales y valores de retorno con el modificador de referencia)), trabajar con estructuras es m√°s dif√≠cil de lo que parece.  Dejando de lado el tema de la mutabilidad, observo que el comportamiento de las estructuras con modificador de solo lectura (solo lectura) y sin √©l en contextos de solo lectura var√≠a mucho. <br><br>  Se supone que las estructuras se utilizan en scripts de programaci√≥n que requieren un alto rendimiento, y para trabajar de manera efectiva con ellas, debe saber algo sobre las diversas operaciones ocultas generadas por el compilador para garantizar que la estructura permanezca sin cambios. <br><br>  Aqu√≠ hay una breve lista de precauciones que debe recordar: <br><br><ul><li>  El uso de grandes estructuras que se pasan o devuelven por valor puede causar problemas de rendimiento en las rutas cr√≠ticas de ejecuci√≥n del programa. </li><li> <code>xY</code> hace que se <code>xY</code> una copia protectora de x si: <br><ul><li>  <code>x</code> es un campo de solo lectura; </li><li>  tipo <code>x</code> es una estructura sin modificador de solo lectura; </li><li>  <code>Y</code> no es un campo. </li></ul></li></ul><br>  Las mismas reglas funcionan si x es un par√°metro con el modificador in, una variable local con el modificador de solo lectura de referencia o el resultado de llamar a un m√©todo que devuelve un valor a trav√©s de una referencia de solo lectura. <br><br>  Aqu√≠ hay algunas reglas a tener en cuenta.  Y, lo m√°s importante, el c√≥digo que se basa en estas reglas es muy fr√°gil (es decir, los cambios realizados en el c√≥digo producen inmediatamente cambios significativos en otras partes del c√≥digo o la documentaci√≥n, aprox. Transl.).  ¬øCu√°ntas personas notar√°n que reemplazando <code>public readonly int X</code> ;  en <code>public int X { get; }</code>  <code>public int X { get; }</code> en una estructura de uso frecuente sin un modificador de solo lectura que afecta significativamente el rendimiento?  ¬øO qu√© tan f√°cil es ver que pasar un par√°metro usando el modificador in en lugar de pasar por valor puede disminuir el rendimiento?  Esto es realmente posible cuando se usa la propiedad in de un par√°metro en un bucle, cuando se crea una copia protectora en cada iteraci√≥n. <br><br>  Tales propiedades de las estructuras literalmente apelan al desarrollo de analizadores.  Y se escuch√≥ la llamada.  Conozca <a href="">ErrorProne.NET</a> : un conjunto de analizadores que le informa sobre la posibilidad de cambiar el c√≥digo del programa para mejorar su dise√±o y rendimiento al trabajar con estructuras. <br><br><h2>  An√°lisis de c√≥digo con salida de mensaje "Haga que la estructura X sea de solo lectura" </h2><br>  La mejor manera de evitar errores sutiles e impactos negativos en el rendimiento al usar estructuras es hacer que sean de solo lectura siempre que sea posible.  El modificador de solo lectura en la declaraci√≥n de estructura expresa claramente la intenci√≥n del desarrollador (enfatizando que la estructura es inmutable) y ayuda al compilador a evitar generar copias de seguridad en muchos de los contextos mencionados anteriormente. <br><br><img src="https://habrastorage.org/webt/tx/fp/5v/txfp5vx1h-8wtkuv_9epx4ulsqe.png"><br><br>  Declarar una estructura de solo lectura no viola la integridad del c√≥digo.  Puede ejecutar de manera segura el fijador (el proceso de arreglar el c√≥digo) en modo por lotes y declarar todas las estructuras de toda la soluci√≥n de software de solo lectura. <br><br><h2>  Amabilidad para el modificador de solo lectura de referencia </h2><br>  El siguiente paso es evaluar la seguridad del uso de nuevas caracter√≠sticas (en modificador, variables de lectura local, variables de referencia, etc.).  Esto significa que el compilador no crear√° copias protectoras ocultas que puedan reducir el rendimiento. <br><br>  Se pueden considerar tres tipos de tipos: <br><br><ul><li>  ref estructuras de solo lectura cuyo uso nunca conduce a la creaci√≥n de copias protectoras; </li><li>  estructuras que no son amigables para la lectura solo de referencia, cuyo uso en el contexto de solo lectura siempre conduce a la creaci√≥n de copias protectoras; </li><li>  estructuras neutrales: estructuras cuyo uso puede dar lugar a copias protectoras dependiendo del miembro utilizado en el contexto de solo lectura. </li></ul><br>  La primera categor√≠a incluye estructuras de solo lectura y estructuras POCO.  El compilador nunca generar√° una copia protectora si la estructura es de solo lectura.  Tambi√©n es seguro usar estructuras POCO en el contexto de solo lectura: el acceso a los campos se considera seguro y no se crean copias de protecci√≥n. <br><br>  La segunda categor√≠a son estructuras sin modificador de solo lectura que no contienen campos abiertos.  En este caso, cualquier acceso al miembro p√∫blico en el contexto de solo lectura provocar√° la creaci√≥n de una copia protectora. <br><br>  La √∫ltima categor√≠a es estructuras con campos p√∫blicos o internos y propiedades o m√©todos p√∫blicos o internos.  En este caso, el compilador crea copias de protecci√≥n seg√∫n el miembro utilizado. <br><br>  Esta separaci√≥n ayuda a generar advertencias instant√°neamente si la estructura "hostil" se pasa con el modificador in, se almacena en la variable local ref readonly, etc. <br><br><img src="https://habrastorage.org/webt/nc/5a/0p/nc5a0pkfa3xsvrzqxznstyxn5yc.png"><br><br>  El analizador no muestra una advertencia si la estructura "hostil" se utiliza como un campo de solo lectura, ya que no hay alternativa en este caso.  Los modificadores de solo lectura y referencia est√°n dise√±ados para ser optimizados espec√≠ficamente para evitar la creaci√≥n de copias redundantes.  Si la estructura es "hostil" con respecto a estos modificadores, tiene otras opciones: pasar un argumento por valor o guardar una copia en una variable local.  En este sentido, los campos de solo lectura se comportan de manera diferente: si desea que el tipo sea inmutable, debe usar estos campos.  Recuerde: el c√≥digo debe ser claro y elegante, y solo secundariamente r√°pido. <br><br><h2>  An√°lisis de CCO </h2><br>  El compilador realiza muchas acciones ocultas para el usuario.  Como se muestra en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n</a> anterior, es bastante dif√≠cil ver cu√°ndo se est√° creando una copia protectora. <br><br>  El analizador detecta las siguientes copias ocultas: <br><br><ol><li>  Cco del campo de solo lectura. </li><li>  Bcc de en. </li><li>  CCO de la variable local de solo lectura de referencia. </li><li>  Bcc return ref readonly. </li><li>  Bcc cuando se llama a un m√©todo de extensi√≥n que toma un par√°metro con este modificador por valor para una instancia de la estructura. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> NonReadOnlyStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublicMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NonReadOnlyStruct _ros; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Samples</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NonReadOnlyStruct nrs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok. Public field access causes no hidden copies var x = nrs.PublicField; // Ok. No hidden copies. x = _ros.PublicField; // Hidden copy: Property access on 'in'-parameter x = nrs.PublicProperty; // Hidden copy: Method call on readonly field _ros.PublicMethod(); ref readonly var local = ref nrs; // Hidden copy: method call on ref readonly local local.PublicMethod(); // Hidden copy: method call on ref readonly return Local().PublicMethod(); ref readonly NonReadOnlyStruct Local() =&gt; ref _ros; } }</span></span></code> </pre> <br>  Tenga en cuenta que los analizadores muestran mensajes de diagn√≥stico solo si el tama√±o de la estructura es ‚â•16 bytes. <br><br><h2>  Uso de analizadores en proyectos reales. </h2><br>  La transferencia de grandes estructuras por valor y, como resultado, la creaci√≥n de copias de protecci√≥n por parte del compilador afectan significativamente el rendimiento.  Al menos esto se muestra en los resultados de las pruebas de rendimiento.  Pero, ¬øc√≥mo afectar√°n estos fen√≥menos a las aplicaciones reales en t√©rminos de tiempo de extremo a extremo? <br><br>  Para probar los analizadores con c√≥digo real, los utilic√© para dos proyectos: el proyecto Roslyn y el proyecto interno en el que estoy trabajando actualmente en Microsoft (el proyecto es una aplicaci√≥n inform√°tica independiente con estrictos requisitos de rendimiento);  vamos a llamarlo "Proyecto D" para mayor claridad. <br><br>  Aqu√≠ est√°n los resultados: <br><br><ol><li>  Los proyectos con requisitos de alto rendimiento generalmente contienen muchas estructuras, y la mayor√≠a de ellas pueden ser de solo lectura.  Por ejemplo, en el proyecto Roslyn, el analizador encontr√≥ unas 400 estructuras que pueden ser de solo lectura, y en el proyecto D, unas 300. </li><li>  En proyectos con requisitos de alto rendimiento, las copias ocultas solo deben crearse en situaciones excepcionales.  Encontr√© solo unos pocos casos en el proyecto Roslyn, ya que la mayor√≠a de las estructuras tienen campos p√∫blicos en lugar de propiedades p√∫blicas.  Esto evita la creaci√≥n de copias de protecci√≥n en situaciones donde las estructuras se almacenan en campos de solo lectura.  Hubo m√°s copias ocultas en el Proyecto D, porque al menos la mitad de ellas ten√≠an propiedades de solo obtenci√≥n (acceso de solo lectura). </li><li>  Es probable que la transferencia de estructuras incluso bastante grandes que usan el modificador in tenga un efecto muy peque√±o (casi imperceptible) en el tiempo completo del programa. </li></ol><br>  Cambi√© las 300 estructuras en el proyecto D, haci√©ndolas de solo lectura, y luego correg√≠ cientos de casos de su uso, lo que indica que se pasan con el modificador in.  Luego med√≠ el tiempo de tr√°nsito de extremo a extremo para varios escenarios de rendimiento.  Las diferencias fueron estad√≠sticamente insignificantes. <br><br>  ¬øSignifica esto que las caracter√≠sticas descritas anteriormente son in√∫tiles?  En absoluto <br><br>  Trabajar en un proyecto con requisitos de alto rendimiento (por ejemplo, en Roslyn o "Proyecto D") implica que una gran cantidad de personas dedican mucho tiempo a varios tipos de optimizaci√≥n.  De hecho, en algunos casos, las estructuras en nuestro c√≥digo se pasaron con el modificador de referencia, y algunos campos se declararon sin el modificador de solo lectura para excluir la generaci√≥n de copias protectoras.  La falta de crecimiento de la productividad durante la transferencia de estructuras con el modificador in puede significar que el c√≥digo estaba bien optimizado y que no hay copia excesiva de estructuras en los caminos cr√≠ticos de su paso. <br><br><h2>  ¬øQu√© debo hacer con estas caracter√≠sticas? </h2><br>  Creo que la cuesti√≥n del uso del modificador de solo lectura para estructuras no requiere mucha reflexi√≥n.  Si la estructura es inmutable, entonces el modificador de solo lectura simplemente obliga expl√≠citamente al compilador a tal decisi√≥n de dise√±o.  Y la falta de copias protectoras para tales estructuras es solo una ventaja. <br><br>  Hoy mis recomendaciones son las siguientes: si la estructura puede ser de solo lectura, entonces h√°ganlo as√≠. <br><br>  Usar las otras opciones consideradas tiene matices. <br><br><h2>  ¬øOptimizaci√≥n previa versus pesimizaci√≥n previa? </h2><br>  Herb Sutter presenta el concepto de "pesimismo preliminar" en su sorprendente libro, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ Coding Standards: 101 Rule, Recommended, and Best Practices</a> . <br><br>  ‚ÄúCeteris paribus, complejidad de c√≥digo y legibilidad, algunos patrones de dise√±o efectivos y expresiones idiom√°ticas de codificaci√≥n naturalmente deber√≠an drenarse de la punta de tus dedos.  Tal c√≥digo no es m√°s dif√≠cil de escribir que sus alternativas pesimistas.  No se realiza una optimizaci√≥n preliminar, sino que se evita la pesimismo voluntaria ". <br><br>  Desde mi punto de vista, un par√°metro con el modificador in es el caso.  Si sabe que la estructura es relativamente grande (40 bytes o m√°s), siempre puede pasarla con el modificador in.  El costo de usar el modificador in es relativamente bajo, ya que no es necesario ajustar las llamadas, y los beneficios pueden ser reales. <br><br>  Por el contrario, para variables locales y valores de retorno con el modificador de referencia de solo lectura, este no es el caso.  Dir√≠a que estas caracter√≠sticas deber√≠an usarse al codificar bibliotecas, y es mejor rechazarlas en el c√≥digo de la aplicaci√≥n (solo si la creaci√≥n de perfiles del c√≥digo no revela que la operaci√≥n de copia es realmente un problema).  El uso de estas caracter√≠sticas requiere un esfuerzo adicional, y se vuelve m√°s dif√≠cil para el lector de c√≥digos entenderlo. <br><br><h2>  Conclusi√≥n </h2><br><ol><li>  Utilice el modificador de solo lectura para estructuras donde sea posible. </li><li>  Considere usar el modificador in para estructuras grandes. </li><li>  Considere el uso de variables locales y valores de retorno con el modificador de solo lectura de referencia para codificar bibliotecas o en los casos en que los resultados del perfil de c√≥digo indiquen que esto puede ser √∫til. </li><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ErrorProne.NET</a> para detectar problemas de c√≥digo y compartir los resultados. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423053/">https://habr.com/ru/post/es423053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423043/index.html">Debido a una vulnerabilidad en el sistema de protecci√≥n del veh√≠culo el√©ctrico Tesla, un autom√≥vil puede ser robado en unos segundos</a></li>
<li><a href="../es423045/index.html">¬øQu√© impresora 3D elegir? Revisi√≥n de video de 3Dtool</a></li>
<li><a href="../es423047/index.html">Reservamos sistemas inform√°ticos por dinero razonable</a></li>
<li><a href="../es423049/index.html">Procesos de aprendizaje en Linux</a></li>
<li><a href="../es423051/index.html">La lucha por los recursos, Parte 1: Los fundamentos de los grupos C</a></li>
<li><a href="../es423055/index.html">Analistas de Wall Street: "Apple nos hizo comer nuestros sombreros"</a></li>
<li><a href="../es423057/index.html">Python tambi√©n rechaza parcialmente los t√©rminos maestro / esclavo</a></li>
<li><a href="../es423059/index.html">Mejor de lo que dicen: tres elementos esenciales para que el pr√≥ximo MacBook sea una de las mejores computadoras port√°tiles de Apple</a></li>
<li><a href="../es423061/index.html">ref locales y devoluciones de ref en C #: dificultades de rendimiento</a></li>
<li><a href="../es423063/index.html">Epson WorkForce Pro: Cr√≥nicas de c√≥mo una impresi√≥n de oficina de inyecci√≥n de tinta "sac√≥ una manta" de un l√°ser y lo que sucedi√≥ hoy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>