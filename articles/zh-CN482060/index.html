<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 🥣 🈲 访问控制授权模型（MAC）：概述和应用程序应用 🎍 ☑️ 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="强制访问控制（MAC）模型-一种具有一组固定权限的访问控制方法。 通常，此MAC用于具有高安全性要求的系统中，并为与国家或官方机密相关的各种执法机构和组织提供服务。 

 MAC模型 
 尽管包含在许多文章和材料中，但MAC经常被随意提及，并且以辣酱的形式被提及，例如在SELinux中对MLS的简短...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>访问控制授权模型（MAC）：概述和应用程序应用</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avanpost/blog/482060/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/yo/zn/9uyoznyeiuxtftmzte_bwep82tw.jpeg" alt="图片"></div><br> 强制访问控制（MAC）模型-一种具有一组固定权限的访问控制方法。 通常，此MAC用于具有高安全性要求的系统中，并为与国家或官方机密相关的各种执法机构和组织提供服务。 <br><a name="habracut"></a><br><h2>  MAC模型 </h2><br> 尽管包含在许多文章和材料中，但MAC经常被随意提及，并且以辣酱的形式被提及，例如在SELinux中对MLS的简短提及。 由于许多人使用“ <a href="https://stopdisablingselinux.com/">如何禁用SELinux</a> ”配方<a href="https://stopdisablingselinux.com/">来</a>限制他们与SELinux的友谊，因此MAC通常也很荣幸。 因此，首先简要介绍一下MAC。 <br><br> 如果您熟悉该模型，则可以直接跳到下一部分。 <br><br><h4> 主要思想 </h4><br> 经典MAC中实现的抽象安全模型（如执法人员所知）如下（说明<a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%2591%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25B0_%25E2%2580%2594_%25D0%259B%25D0%25B0%25D0%25BF%25D0%25B0%25D0%25B4%25D1%2583%25D0%25BB%25D1%258B">Bell-Lapadula模型的</a>经典图片）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a4/5w/j-/a45wj-wbygb8biqticjy8bxcdyg.png" alt="图片"></div><br>  MAC模型本质上是书面“秘密”工作流程的“电子”实现。  MAC具有以下“参与者”： <br><br><ul><li> 在系统中处理<b>的访问级别的层次结构</b> （通常在OS中注册）。 为了方便起见，通常以无符号数字的形式指定（从0到实现所限制的值）。 在这种情况下，为了比较访问级别（较高/较低/相等），使用了最简单的算术运算（相等，较少，较多）。 </li><li> <b>具有保密级别的对象。</b> 数据库系统中的任何文件，文件系统中的目录，单元或记录，数据库中的表，数据库本身，网络数据包等。 从访问级别的层次结构中为对象分配任何值。 对于该对象，允许增加保密级别（更改为比当前级别更高的级别值）。 绝对不允许降低保密级别（尽管在某些技巧的帮助下完全可行）。 </li><li>  <b>具有访问级别的主题。</b> 应用程序或用户会话的过程（本质上也是应用程序过程）。 该主题创建的所有对象都从该主题继承访问级别标签。 </li></ul><br>  <i>主题的访问级别</i>或<i>对象的安全级别的值</i>通常称为“强制级别”，“强制标签”或简称为“标签”（在<a href="https://csrc.nist.gov/csrc/media/publications/white-paper/1985/12/26/dod-rainbow-series/final/documents/std001.txt">STCSEC中，</a>此术语称为“层次分类级别”）。 简单，宽敞且<i>几乎</i>毫不含糊。 <br><br> 对对象访问受MAC保护的对象的每个事实都进行授权检查。 在这种情况下，凭据访问控制模型通常与其他访问控制机制结合使用，例如DAC（UNIX模型和POSIX ACL）。 在这种情况下，最后检查MAC。 首先，访问由DAC（最不安全）检查，然后由MAC检查。 <br><br> 在根据强制模型检查对象访问对象的资格时，可以使用以下组合： <br><br><ol><li>  <i>主题的凭证标签等于对象的凭证标签。</i> 在这种情况下，允许对象阅读和修改对象。 </li><li>  <i>主题的凭据标签高于对象的凭据标签。</i> 主题仅允许阅读该对象：他看到了该对象，但是不能更改它。 </li><li>  <i>主题的凭证标签低于对象的凭证标签。</i> 正式允许对象创建具有较高凭据标记的对象（所谓的“增加对象的保密级别”）。 在实践中，对象没有执行此操作的技术能力（他只是“看不到”变量对象，例如文件或包含文件的目录）。 </li></ol><br> 在MAC中也有一个“类别”（在<a href="https://csrc.nist.gov/csrc/media/publications/white-paper/1985/12/26/dod-rainbow-series/final/documents/std001.txt">STCSEC</a>术语中，这个术语称为“非分层类别”）。  MAC中的类别是可选的。 实际上，MAC类别的实现用于组织不同部门之间的“水平”访问控制。 在这种情况下，尽管有一个强制级别，员工也只能根据其标签访问他们有权访问的那些对象类别。 <br><br><h4> 局限性和漏洞 </h4><br>  MAC具有其局限性和功能： <br><br><ol><li> 系统用户无法独立确定主题对对象的访问。 在MAC中的整个对象访问控制库中，只有与该对象相关联的凭据标签和凭据类别。 主题对对象的访问权限的管理仅由管理员执行。 </li><li> 如果用户想要更改其作者的对象的凭据标签，则他需要进入目标标签会话。 这是由于用户不能随意指定标签，而只能“通过继承”将标签传递给对象。 同时，用户只能在一个凭证标签的会话中工作。 </li><li> 由于MAC与其他访问控制模型结合使用，因此会产生冲突：有时很难找出拒绝访问安全系统的哪个“层”。 需要对所有保护层进行细微的“调整”。 </li><li> 除了通过MAC工具包进行的访问设置外，还需要安全策略。 它应描述凭证的特定值的含义（这在MAC之外），受保护的对象，受权的对象。 没有达成一致的规定，仅MAC不能提供安全性增强。 </li><li> 在分布式网络基础结构中使用MAC。 配置MAC的传统方法是在本地管理员的帮助下，按照说明进行手动操作。 有一些解决方案可让您实施集中管理的MAC存储（例如ALD），但是它们有各自的特点和构造困难。 </li></ol><br><h2> 设计MAC应用程序 </h2><br> 尽管存在该模型的所有局限性，但对于那些与公共部门（尤其是与执法机构合作）的人来说，在构建具有强制访问控制模型支持的应用程序方面比以往任何时候都更加重要。 突然，明天您将不得不在产品中支持MAC？ <br><br> 乍一看，该模型似乎是原始的，其实现仅需5美分，但有一个警告：对使用凭证模型提出要求的客户首先要考虑一个经过认证的信息安全工具。 真正的机密信息（包括国家机密信息）将在这样的IP中进行处理，并且很难将自己的开发认证到所需的级别。 解决这种情况的方法是使用支持MAC的认证基础架构。 <br><br> 所以我们拥有的是： <br><div class="scrollable-table"><table><tbody><tr><th> 系统软件 <br></th><th> 内容描述 <br></th></tr><tr><td>  OS Astra Linux特别版/ SELinux <br></td><td> 具有MAC支持的操作系统。 提供与操作系统用户存储库关联的用户凭证信息存储库。 它提供了用于控制对受MAC保护的对象（文件系统对象，以凭据标签模式启动应用程序等）的访问的机制。 <br></td></tr><tr><td>  PostgreSQL DBMS（PostgresPro） <br></td><td> 它与操作系统的帐户和凭据存储集成在一起。  DBMS提供了将强制性标签分配给诸如群集，数据库，表，列和记录之类的对象的功能。 <br></td></tr><tr><td>  MAC服务器（Apache Http服务器） <br></td><td> 它通过MAC支持从客户端请求中继证书标签，并使用相同标签启动应用程序处理程序（脚本/服务），并传输用户身份验证数据。 <br></td></tr><tr><td>  MAC浏览器（Mozilla Firefox） <br></td><td> 读取用户会话的凭据标签（用户的图形外壳），并将其添加到对Web应用程序的请求中。 <br></td></tr></tbody></table></div><br> 现在，让我们看看在开发应用程序以在基础结构级别保留访问控制功能时如何使用该基础结构。 <br><br> 为了使应用程序能够利用操作系统的强制性标签机制，必须满足以下条件： <br><br><ul><li> 应用程序的用户必须在操作系统用户的存储库中注册。 至少必须有一些标识符，允许您将应用程序用户唯一地映射到操作系统的用户（通常是登录名）。 </li><li> 必须为操作系统的MAC机制级别的应用程序用户配置特定证书（证书范围）的证书权限。 </li></ul><br> 从桌面应用程序的角度来看，用户场景如下： <br><br><ol><li> 用户以他需要的标签模式在他的个人超声下进入OS。 启动应用程序。 应用程序进程将继承凭证标签。 </li><li> 该应用程序与PostgreSQL上的数据库进行交互，例如，仅显示具有当前凭据标签的数据库表的记录。 </li></ol><br> 从提供Web服务的服务器应用程序的角度来看，用户场景在概念上是接近的，尽管看起来有些复杂： <br><br><ol><li> 用户以他需要的标签模式在他的个人超声下进入OS。 它会启动一个支持MAC的浏览器，在我们的示例中为Mozilla Firefox（“正常”浏览器无法用于这些目的）。 浏览器进程将继承证书。 </li><li> 用户请求具有凭据支持的应用程序的资源地址。 浏览器通过向其添加证书标记来形成请求。 </li><li> 该请求由支持凭据的Web服务器处理，在我们的示例中为Apache Http Server。  Web服务器（其过程以最低凭据模式运行）读取请求的凭据标签，找到处理程序应用程序，并通过传递的凭据标签开始其过程。 </li><li> 该应用程序与PostgreSQL数据库进行交互，从而中继查询中的凭据标签。 </li></ol><br>  MAC在操作系统中的存在对应用程序体系结构施加了相当严格的限制。 在没有证书访问控制模型的OS中，对于具有MAC的OS来说似乎微不足道，这一事实可能会给整个开发团队带来很多惊喜。 特别是对项目经理。 因此，必须在开始开发之前就构建具有MAC功能的应用程序的体系结构。 具有MAC的项目经理应坚持在进行任何实施之前，由架构团队完成设计。 <br><br> 当然，对于开发简单的应用程序（实用程序或应用程序，由于它们对MAC不具有特殊性），许多技巧根本没有用。 如果该应用程序比读取文件并将其工作结果写入文件的单用户本地应用程序更复杂，则建议您清楚地了解“陷阱”。 <br><br> 我们根据自己的经验编制了用于设计具有MAC支持的应用程序的配方。 在它们的背后是不眠之夜，一连串来自测试的票据，数千小时的调试应用程序，这些应用程序从所有常识上都可以正常运行，但是由于某种原因却无法正常运行。 食谱以对技术和工具最简单，最中立的方式进行描述，并在可能的情况下配备可提高认知度的计划。 走吧 <br><br><h4> 当无法避免时如何避免MAC </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rv/od/sf/rvodsfy279palaopincmwnjz3pa.jpeg" alt="图片"></div><br> 使用MAC设计应用程序时，可以使用一种非常简单的体系结构解决方案，最终可以节省很多时间和精力。 应在应用程序配置中添加一个参数，该参数告诉应用程序是否启用了此安装的凭据访问控制模型。 在与MAC基础结构进行交互的应用程序的所有地方，或应用程序的业务功能需要标签验证的地方，您应首先检查此参数的值。 如果根据它禁用了MAC，则应用程序将忽略所有旨在测试MAC兼容功能的业务逻辑规则。 <br><br> 在人工成本方面，您将不得不花费额外的时间在MAC支持下实现应用程序的每个功能。 您将需要在没有证书标签的模式下调试和测试相同的功能，因此测试成本将增加。 <br><br> 通过此解决方案，可以为被迫在MAC环境中运行的应用程序（和整个开发团队）提供以下优势： <br><br><ul><li> 跨平台应用程序（仅受编程语言功能的限制）及其与运行时的独立性。 </li><li> 使用现代虚拟化工具（例如Docker）进行自动化的能力。 </li><li> 轻松进行与MAC不直接相关的测试和调试功能。 </li></ul><br><p>  <strong>建议</strong> ： </p><p> 添加选项以启用/禁用对应用程序中凭据的支持。 </p><p> 在所有需要与MAC交互的地方，首先，检查参数值。 </p><p> 在调试和测试时，有必要对应用程序的两种模式进行调试（在开发团队方面）和测试（在测试团队方面）。 </p><br><h4> 分而治之 </h4><br> 在开发开始之前必须完成的另一个重要设计步骤是将需要MAC支持的模块与不需要此访问控制机制的模块分开。 使用凭证访问控制模型几乎总是会使应用程序的业务逻辑复杂化。 <br><br> 这是相同的基础结构，要对其进行抽象非常困难，有时甚至是不可能的。 因此，应将应用程序划分为模块，并针对每个模块分析对MAC支持的需求。 也许在您的情况下，仅在一个模块中支持MAC就足够了，并且由于这个模块使整个应用程序复杂化而没有意义吗？ <br><div class="scrollable-table"><table><tbody><tr><td><p>  <strong>建议：</strong>应将应用程序分为模块，并根据凭据的处理方式进行分类。 </p></td></tr></tbody></table></div> 如果我们正在考虑某个抽象模块（或者整个应用程序，如果不需要将应用程序划分为模块），则可能有以下范例： <br><br><ul><li>  <i>最小标签。</i> 模块以最小强制标签模式（OS进程在其中运行的最小标签，例如0个强制标签）或没有强制标签的方式处理数据。 </li><li>  <i>一个标签。</i> 该模块仅使用最低强制性标签（除操作系统进程所使用的标签以外的任何标签）上方的一个强制性标签的数据。 </li><li>  <i>几个标签。</i> 该模块可同时处理多个强制性标签（OS进程在其中运行的标签以及OS进程标签以外的其他标签）的数据。 </li></ul><br> 具有不同凭据处理范式的应用程序模块之间不应了解太多。 否则，它充满了关于对各种对象等的访问冲突的大而无法预测的问题的出现。 最小连接模块的想法是显而易见的。 在使用MAC的情况下，您应该格外警惕并监视模块的所有“连接”。 <br><div class="scrollable-table"><table><tbody><tr><td><p>  <strong>建议：</strong>设计时，应确保在不同的凭证处理范式中工作<a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">的</a>模块具有最小的<a href="https://en.wikipedia.org/wiki/Cohesion_(computer_science)">内聚性</a> 。 </p></td></tr></tbody></table></div> 接下来，我们将更详细地考虑具有三种用于处理凭据的范式的设计功能。 为此，我们概述了从简单到复杂的分类。 此分类纯粹是实用的并且可以应用。 它源于各个模块开发中直观上明显的差异，并在实践中显示了其有效性。 <br><br><h2> 通过MAC处理模式对模块进行分类 </h2><br><img src="https://habrastorage.org/webt/-f/yi/g7/-fyig7orpxezbkioclske9kgaj0.jpeg" alt="图片"><br><br><h4>  “ BRING IT ON”：模块在最低凭证模式下运行 </h4><br><img src="https://habrastorage.org/webt/gx/m_/mc/gxm_mc75kv2-vhaptuvuuu7hjxw.png" alt="图片"><br><br> 在模块中实现此机制的动机： <br><br><ul><li> 该模块处理的信息原则上不能在系统中使用其他凭据进行处理，并且不需要特殊的读/写特权。 </li><li> 该模块与OS基础架构紧密相连，这限制了它在强制标签模式下的功能，该模式不同于最低要求。 </li></ul><br> 在此模式下运行的模块应检查过程凭证。 如果运行此模块的进程的标签不同于最小值（例如，它不等于0强制标签），则应在应用程序的业务逻辑级别禁止执行所有操作（查看除外）。 也就是说，如果用户在非零的凭证标签会话中来找我们，我们可能根本不允许用户使用此模块。 <br><br> 适合使用最小强制性标签模式的实际示例： <br><br><ul><li>  <b>管理应用程序商店中的用户帐户。</b> 例如，如果应用程序在文件或数据库中维护自己的超声记录。 与应用程序的安全性和访问控制有关的所有数据都必须存储在最小凭据模式下，否则当应用程序以凭据标记模式运行时，应用程序安全模型将简单地“崩溃”。 因此，所有系统应用程序都严格按照最低凭据运行。 </li><li>  <b>访问权限管理。</b> 例如，如果应用程序在业务逻辑级别实现其自己的访问控制模型。 </li><li>  <b>管理</b>应在所有凭据下可用的<b>应用程序配置设置</b> 。 </li><li>  <b>操作系统中的帐户管理。</b> 如果应用程序需要管理OS中KM的任何属性，则必须严格在最小凭据标记下执行所有操作。 </li></ul><br><h4>  “ HURT ME PLENTY”：模块以单证书模式运行 </h4><br><img src="https://habrastorage.org/webt/ya/hp/e8/yahpe8ehumoaewc1jd1yubiwbbm.png" alt="图片"><br><br> 这种情况稍微复杂一点，但在许多方面与具有最小凭据标记的情况相似。 从用户的角度来看，使用该应用程序不会有太大变化：记录，卡片和操作的所有相同的熟悉列表，包括“查看”，“编辑”和“保存”。 唯一的区别是，在此模式下，用户仅看到与他当前会话的凭据标记相对应的那些记录。 <br><br> 还可以开发一个有限的选项：该模块捕获“默认证书标签”参数的值。 在这种情况下，只有使用指定的凭证标签才能对模块进行操作，但是此选项更易于实现。 <br><br> 在以下情况下，这种情况可能有用： <br><br><ul><li> 设计模块时，体系结构存在错误（未列出MAC中处理记录的功能），并且没有时间或资源来重写所有内容。 </li><li> 对凭据访问控制模型的支持已引入到已经运行的应用程序中，并且根据要求，有必要确保使用高于OS最小值的标签进行工作。 是的，就是这样的情况，当团长来找您，并高兴地告诉您我们赢得了比赛，并将以<i>“秘密部门的名称”</i>执行我们的决定时！ </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有理由为同时处理多个凭证的记录提供全面支持。</font><font style="vertical-align: inherit;">无需一次同时处理多个凭证的记录。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该应用程序以单用户模式运行。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 从实现的角度来看，这种情况不是很简单，因为我们需要： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 仅选择与当前强制性标签相对应的那些记录，因为根据Bell-Lapadula模型，用户将看到当前强制性标签的记录以及位于层次结构中较低位置的所有强制性标签。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在执行任何修改记录的操作之前，请检查凭据标记。</font><font style="vertical-align: inherit;">如果您尝试更改具有与会话的凭据标签不同的凭据标签的条目，则必须中止该操作。</font></font></li></ul><div class="scrollable-table"><table><tbody><tr><td><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建议：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在仅以单一强制性标签模式工作的模块（不同于最小OS强制性标签）中，添加一个参数，用于存储该模块的有效强制性标签模式。</font><font style="vertical-align: inherit;">应用程序必须拒绝在指定列表之外以凭据标记模式执行操作的尝试。</font></font></p></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在模块中执行操作时，建议使用默认凭据标签检查当前应用程序进程的凭据标签。</font><font style="vertical-align: inherit;">如果模块的凭据标签与会话的凭据标签不匹配，则不应允许用户执行该操作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适合使用单证书标签模式的实际示例：</font></font><br><br><ul><li> <b>.</b> ,        ( ,   ..).            ,               .            . </li><li> <b>.</b> ,      ,     ( )     .   «»    ,       « »,  «»    . </li></ul><br><h4> «NIGHTMARE!»:        </h4><br><img src="https://habrastorage.org/webt/87/la/4x/87la4xq3rsiipsjmr5hmirp0fxm.png" alt="图片"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当在与模块的一个会话中我们需要显示位于层次结构中当前会话的凭据下方的所有凭据的信息时，此操作模式才有用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在设计时，有必要描述模块的功能需求，并在每个功能需求的细节中，以强制性模型指示交互列表（可能的选项在下面的``应用程序与环境之间的交互''部分中讨论）。这将突出显示与基础架构交互的一些有关强制性标签的一般概念。同样，此信息对于评估开发的复杂性和进一步测试将非常有用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在用户界面实现方面，通常使用以下模式：</font></font><br><br><ul><li>  (, )         ( ).      ,         . </li><li> /  /   ,      . </li><li>   /     (      ). </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一组业务流程取决于模块业务逻辑的复杂性和数据处理的细节。</font><font style="vertical-align: inherit;">例如，您可以按凭据标签过滤记录的集合。</font><font style="vertical-align: inherit;">您可以在界面中显示凭证记录标签。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组合的范围是巨大的，错误的出现空间也是如此。</font><font style="vertical-align: inherit;">因此，不建议在存在任何业务逻辑的情况下，在同一用例中处理具有不同凭证标签的记录。</font><font style="vertical-align: inherit;">进行记录收集的任何操作都应在整个收集所共有的凭证的显式指示下进行。</font><font style="vertical-align: inherit;">处理第三个标记，然后处理第二个，依此类推。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要实施这种制度，有必要承担以下职能：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 该函数获取当前应用程序进程（用户会话）的证书标签。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 获得记录（如果是使用数据库中的记录的问题）或文件（如果是处理文件的问题）的凭证标记的功能。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接收集合中数据库记录/文件的凭证标签的功能。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 适用于多凭证模式的实际情况示例： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告中 </font><font style="vertical-align: inherit;">要实现这种情况，我们需要在系统上累积最多的信息，该信息可用于具有当前强制性标签的会话。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该杂志。</font><font style="vertical-align: inherit;">在这种情况下，将开发一个用于查看所有可用于查看操作且具有过滤功能（包括凭据标签）的界面。</font></font></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 环境互动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAC环境中的应用程序与围绕它的组件的特定列表进行交互。</font><font style="vertical-align: inherit;">根据交互作用的示意图，可以将它们分类如下：</font></font><br><br><img src="https://habrastorage.org/webt/js/mk/jj/jsmkjjau7takqryy7zi2jdvf9gy.png" alt="图片"><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 作业系统： </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 凭证模型的参数： </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 强制标签OS的层次结构； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 强制权限（特定用户可以使用的标签范围）OS用户。 </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户凭证存储 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 操作系统中的身份验证（包括考虑凭据）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他访问控制机制（可选的POSIX ACL，UNIX等）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与FS合作； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流程管理； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与网络合作； </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不支持MAC的第三方软件； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有MAC支持的第三方软件： </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DBMS（例如PostgreSQL）： </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数据库对象（单元，行，列，模式，表，数据库，集群，序列，函数等）。 </font></font></li></ul></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用户名 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将分别考虑与每个组件进行交互的细微差别。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MAC兼容应用程序与操作系统的交互 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/ww/ky/nswwkyiglwv0uvp7s98vq6qpv8g.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MAC对其在文件系统中设置访问规则的困难感到非常“满意”。例如，MAC应用程序中的大部分错误都与以下事实有关：该应用程序在当前凭据标记模式下看不到文件，但在另一种凭据标记模式下（一个级别）存在该文件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从MAC方面，我们对操作系统有什么期望？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们的应用程序在多用户模式下工作，则可能需要请求有关其处理数据的用户帐户的信息。</font><font style="vertical-align: inherit;">这对于支持用户访问控制是必需的。</font><font style="vertical-align: inherit;">因此，应用程序将需要从OS请求有关用户凭据的信息。</font><font style="vertical-align: inherit;">如果操作系统中用户的KM由我们的应用程序控制，那么我们不仅需要读取有关KM的信息，还需要管理KM的属性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下图显示了OS与应用程序之间最可能的交互流：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z_/cd/s0/z_cds0kasvdqkfqxsoapzm8-gns.png" alt="图片"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MAC兼容应用程序与不支持MAC的第三方软件的交互 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在具有MAC的OS中使用的大多数应用程序都不知道如何处理MAC。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在组织这种交互时，在将数据或请求传输到这种应用程序的过程中，需要模拟凭证标签。这是通过将数据流“分层”到单独的通道中来实现的，每个通道在逻辑上针对具有特定强制性标签的数据而设计。严格禁止混合此类数据；它们必须经过单独的队列，通道，并且几乎要通过分开</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的双绞线连接到</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络接口。 MAC进行数据分离的“逻辑”实现的有效性也是一个有争议的问题，因此，大多数情况下取决于客户和应用程序开发人员的良心。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在MAC模式下运行的应用程序使用不带MAC的应用程序的能力取决于所选的交互方法，其详细信息以及在应用程序中处理传入数据的实现功能。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MAC兼容应用程序与具有MAC支持的第三方软件的交互 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在与具有MAC支持的软件进行交互的情况下，我们的应用程序必须清楚地能够读取发出请求的进程的标签，并根据强制访问控制模型执行操作。</font><font style="vertical-align: inherit;">与此类软件进行交互的应用程序仅需要从具有正确凭据标记的过程中满足对第三方应用程序/过程的请求。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全支持强制标签的流行应用程序示例是PostgresSQL。</font><font style="vertical-align: inherit;">在此DBMS交付的某些变体中，对某些具有MAC机制的OS实现了对MAC的完全支持，例如：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Astra Linux：PostgreSQL，随附SE的发行套件版本。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SELinux：sepgsql扩展。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PostgreSQL允许您在以下级别按凭证标签（仍然支持凭证类别，但我们对标签感兴趣）分隔数据： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群级别。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群数据库级别。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群数据库的架构级别。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群数据库架构的表级别。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群的数据库模式表的列级别。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在集群的数据库模式表的记录级别。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，在MAC的实现中，我们得到了这样一个“嵌套娃娃”：每个“父”级别对所有“子”级别都施加了自己的限制。</font><font style="vertical-align: inherit;">因此，当在完全支持MAC的情况下实现与每个相似应用程序的交互时，有必要考虑其工作细节。</font><font style="vertical-align: inherit;">没有通用的食谱。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MAC兼容应用程序的用户互操作性 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i2/nh/6g/i2nh6g0gp3x8cnvqns4ojkyd_f0.jpeg" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与先前所考虑的相比，无论交互的外观如何奇怪，都不可能不去讨论。</font><font style="vertical-align: inherit;">毕竟，对于用户而言，最常构建具有MAC支持的应用程序，对吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有模式下，除了具有多个凭据的同时工作模式之外，具有MAC支持的应用程序与没有MAC的应用程序在用户界面上几乎没有什么不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在当今常见的Web应用程序示例中，最常发现以下情况：</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 案例 </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 需要什么 </font></font><br></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 身份验证和用户使用会话 </font></font><br></td><td>       ,       .              ,       . <br><br>         . <br></td></tr><tr><td>    ( )           <br></td><td>    - . 细微差别： <br><br><ul><li>     ,       . </li><li>           . </li><li>        ,         (,     ),     (,  ). ,   ,    ,  -    (,  backend       ,        frontend). </li><li>             ,     . </li></ul><br></td></tr><tr><td>  ,       (  /    ..) <br></td><td>      . ,       (),         .   ,   -     (              ),   —  . <br><br>    : <br><br><ol><li>         ,      .    ,     ,  ,     . </li><li>    ,         «» . </li></ol><br></td></tr><tr><td>       (, ) <br></td><td> ,          ,      . ,        (,  backend ),              (        ).                . <br></td></tr></tbody></table></div><br><h4> 结论 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们研究了开发具有MAC支持的应用程序的几个方面。</font><font style="vertical-align: inherit;">当然，很难预见所有情况。</font><font style="vertical-align: inherit;">凭证模型的大多数功能取决于所选OS中可用的实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对MAC应用程序的支持不是该应用程序的附加“功能”。</font><font style="vertical-align: inherit;">这是一个严重的体系结构解决方案，需要规划和设计。</font><font style="vertical-align: inherit;">对于MAC兼容应用程序的设计者来说，最大的“痛苦”是：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与OS基础架构的交互（文件系统，网络交互，使用所需凭据标签启动进程，以防在服务器上执行应用程序的情况）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与具有内置MAC支持的应用软件进行交互（例如，DBMS）； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与MAC兼容操作的正确处理有关的用户交互。 </font></font></li></ul><br><img src="https://habrastorage.org/webt/kw/yg/ij/kwygijxsx7fub4w4dj7mctcqdac.png" alt="图片"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到此为止！</font><font style="vertical-align: inherit;">欢迎对本文进行补充，个人经验和评论！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482060/">https://habr.com/ru/post/zh-CN482060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482044/index.html">保护Docker映像的10个最佳实践。 第二部分</a></li>
<li><a href="../zh-CN482050/index.html">绝地卷积网络约简技术-修剪</a></li>
<li><a href="../zh-CN482052/index.html">新年数据集2019：俄语开放色调词典</a></li>
<li><a href="../zh-CN482054/index.html">3.弹性堆栈：安全日志分析。 仪表板</a></li>
<li><a href="../zh-CN482058/index.html">捕食者还是猎物？ 谁来保护证书颁发机构</a></li>
<li><a href="../zh-CN482064/index.html">轻松在CMS Umbraco 8上开发多语言站点</a></li>
<li><a href="../zh-CN482066/index.html">用工作故事替换用户故事</a></li>
<li><a href="../zh-CN482068/index.html">我是否需要从SSD创建RAID阵列以及为此需要哪些控制器</a></li>
<li><a href="../zh-CN482070/index.html">五个有助于维持大脑表现的习惯</a></li>
<li><a href="../zh-CN482076/index.html">客户，信任asoshnikov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>