<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèΩ üßë‚Äçü§ù‚Äçüßë üôåüèº Comandos r√°pidos do Siri üö™ üè≥Ô∏è‚Äçüåà üë©‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um dos recursos √∫teis (na minha opini√£o) do iOS 12 introduzidos na WWDC 2018 √© o Siri Shortcuts . 


 Atalho ( atalho ) - um comando r√°pido, uma manei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comandos r√°pidos do Siri</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/414677/"><p><img src="https://habrastorage.org/webt/ge/mr/un/gemrunsbwx7gf07v5htwy9lytpu.png"></p><br><p>  Um dos recursos √∫teis (na minha opini√£o) do iOS 12 introduzidos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://">WWDC 2018</a> √© o <strong>Siri Shortcuts</strong> . </p><br><p>  Atalho ( <em>atalho</em> ) - um comando r√°pido, uma maneira curta de executar qualquer a√ß√£o ignorando o script padr√£o. </p><br><p>  Nos seus aplicativos, voc√™ pode ajustar atalhos para algumas a√ß√µes.  Aprendendo como e quando o usu√°rio os executa, o Siri come√ßa de maneira inteligente, no momento e no local certos, para oferecer a ele esses atalhos e, o melhor de tudo, o usu√°rio poder√° cham√°-los com frases que ser√£o anexadas a eles!  Sob o gato mais. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Como isso funciona </h2><br><p>  Utilizamos aplicativos que, com determinadas a√ß√µes, criam e entregam atalhos para o sistema. </p><br><p>  Voc√™ pode visualizar esses atalhos em <strong>Configura√ß√µes ‚Üí Siri e Pesquisa</strong> . <br><img src="https://habrastorage.org/webt/vp/z2/fd/vpz2fdo_rakpjpl-imiuvzkbyly.png"><br>  A captura de tela acima mostra os tr√™s √∫ltimos atalhos que o sistema capturou de diferentes aplicativos.  Se clicarmos no bot√£o "Mais atalhos", veremos todos os atalhos entregues ao sistema por cada aplicativo. </p><br><p>  Com certas configura√ß√µes no c√≥digo de cria√ß√£o de atalhos, a Siri oferecer√° esses atalhos ao usu√°rio em uma tela bloqueada, na central de notifica√ß√µes e na pesquisa, focando na frequ√™ncia com que usamos essas a√ß√µes, a que horas, em quais dias da semana, onde e por outros fatores. </p><br><p>  Por exemplo, se na sexta √† noite voc√™ costuma procurar caixas eletr√¥nicos, depois de treinar, a Siri oferecer√° um atalho com essa a√ß√£o nas noites de sexta-feira. </p><br><p><img src="https://habrastorage.org/webt/ef/my/gu/efmyguxaczsetehquug_nyp7vnc.png"></p><br><p>  Podemos adicionar nosso comando de voz a cada atalho se clicarmos no √≠cone " <strong>+</strong> ". </p><br><p>  Dizemos um comando de voz, pressione "Conclu√≠do" e agora podemos executar a a√ß√£o por tr√°s do atalho usando a voz da Siri.  <em>Acontece que o usu√°rio poder√° executar a funcionalidade do seu aplicativo atrav√©s do Siri sem abrir o pr√≥prio aplicativo.</em>  O atalho com a frase √© preservado em "Meus atalhos". </p><br><h2 id="sozdanie-shortkatov">  Criando atalhos </h2><br><p> Para o desenvolvimento, precisaremos do Xcode 10 e do iOS 12. No momento da reda√ß√£o, os dois est√£o na fase <strong>Beta</strong> . </p><br><p> Um atalho pode ser criado pelo <code>NSUserActivity</code> ou pelo <code>Intent</code> . </p><br><p>  O primeiro caso: </p><br><p>  O usu√°rio clica no atalho, que passa o comando com par√¢metros ( <code>NSUserActivity</code> ) para o nosso aplicativo, e decide como esse comando deve ser processado (abra a janela da taxa atual de USD ou a janela de pedidos da nossa pizza favorita).  Este √© o bom e antigo atalho do Spotlight que todos conhecemos, mas oferecido de forma inteligente pela Siri. </p><br><p>  Segundo caso: </p><br><p>  Os atalhos criados por meio do <code>Intent</code> mais interessantes - eles permitem que voc√™ execute um comando imediatamente na interface Siri sem iniciar o aplicativo.  Anteriormente, o conjunto de <code>Intent</code> era dif√≠cil para a Apple: transferir dinheiro, enviar mensagens e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outros</a> .  Agora, n√≥s desenvolvedores temos a oportunidade de criar nossas <code>Intent</code> ! </p><br><p>  Independentemente de como o atalho foi criado, ele passa por tr√™s est√°gios do ciclo de vida: </p><br><ol><li>  An√∫ncio ( <strong><em>Definir</em></strong> ) </li><li>  Entrega no sistema ( <strong><em>Doa√ß√£o</em></strong> ) </li><li>  Processando por aplicativo ( <strong><em>Handle</em></strong> ) </li></ol><br><p><img src="https://habrastorage.org/webt/ie/7b/6z/ie7b6zoy5fd9mkx5ivjddp0agxc.png"></p><br><p>  Minha pesquisa mostrou que um aplicativo pode fornecer no m√°ximo 20 atalhos para o sistema. </p><br><p>  Al√©m disso, consideraremos como dar ao nosso aplicativo a capacidade de criar atalhos e como trabalhar com eles dentro dele. </p><br><h2 id="sozdanie-shortkatov-cherez-nsuseractivity">  Criando atalhos por meio do <code>NSUserActivity</code> </h2><br><p>  Vamos analisar o primeiro tipo simples de atalhos que s√£o abertos por meio do <code>NSUserActivity</code> . </p><br><p>  Por exemplo, no aplicativo de banco m√≥vel, temos uma tela de pesquisa em caixas eletr√¥nicos e geralmente os procuro.  Para acessar a tela com um cart√£o ATM, eu tenho que iniciar o aplicativo, v√° para a aba ‚ÄúMais‚Äù na aba, selecione a se√ß√£o ‚ÄúInfo‚Äù e clique no bot√£o ‚ÄúATMs‚Äù. <br>  Se criarmos um atalho que leva imediatamente a essa tela, o usu√°rio poder√° acess√°-lo com um toque quando a Siri oferecer a ele, por exemplo, em uma tela bloqueada. </p><br><h3 id="obyavlyaem-shortkat-declare">  Declarar atalho </h3><br><p>  O primeiro passo √© declarar um tipo como o <code>NSUserActivity</code> (podemos dizer que esse √© o seu identificador) em <em>info.playlist</em> : </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSUserActivityTypes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff.demo.show-cashMachine<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Anunciado. </p><br><h3 id="dostavlyaem-shortkat-v-sistemu-donate">  Entregue o atalho para o sistema (Doa√ß√£o) </h3><br><p>  Ap√≥s a declara√ß√£o, podemos criar <code>NSUserActivity</code> no c√≥digo do nosso aplicativo com o tipo que definimos acima em <strong>info.playlist</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> activity = NSUserActivity(activityType: <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span>)</code> </pre> <br><p>  Para que a atividade entre na lista de atalhos do sistema, ela deve ser configurada como <code>title</code> e definir a propriedade <code>isEligibleForSearch</code> como <code>true</code> .  Outras propriedades n√£o s√£o necess√°rias para adicionar atalhos, mas sua presen√ßa torna o atalho mais leg√≠vel e f√°cil de usar. </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (     ,   ) activity.title = " " if #available(iOS 12.0, *) { // ,             activity.suggestedInvocationPhrase = "  " //           activity.isEligibleForPrediction = true // (     ,   ) activity.isEligibleForSearch = true } //       let attributes = CSSearchableItemAttributeSet(itemContentType: "NSUserActivity.searchableItemContentType") ///    if let image = UIImage(named: "siriAtmIcon") { attributes.thumbnailData = UIImagePNGRepresentation(image) } ///   attributes.contentDescription = "     " ///     activity.contentAttributeSet = attributes</span></span></code> </pre> <br><p>  Fogo!  <code>NSUserActivity</code> √©, para entreg√°-lo ao sistema, resta dar o √∫ltimo passo. </p><br><p>  <code>ViewConroller</code> possui uma propriedade <code>userActivity</code> , √† qual precisamos atribuir a <code>activity</code> criada acima: </p><br><pre> <code class="javascript hljs">self.userActivity = activity</code> </pre> <br><p>  Assim que essa linha for executada, um atalho ser√° criado a partir dessa atividade.  Ele ser√° entregue ao sistema e exibido nas configura√ß√µes da Siri ( <strong>Configura√ß√µes ‚Üí Siri e Pesquisa</strong> ).  Em seguida, a Siri poder√° oferecer ao usu√°rio, e o usu√°rio poder√° atribuir a ele seu comando de voz. </p><br><p>  <em><strong>Nota</strong> : A documenta√ß√£o da Apple diz que, em vez de atribuir atividade ao controlador de exibi√ß√£o, basta chamar o m√©todo <code>becomeCurrent()</code> na <code>becomeCurrent()</code> .</em>  <em>No entanto, esta a√ß√£o n√£o entregou atividade ao meu sistema e o atalho n√£o apareceu na lista</em> </p><br><blockquote>  Em seguida, chame o m√©todo <code>becomeCurrent()</code> no objeto de atividade do usu√°rio para marc√°-lo como atual, o que doa a atividade √† Siri.  Como alternativa, voc√™ pode anexar o objeto a um objeto UIViewController ou UIResponder, que tamb√©m marca a atividade como atual. </blockquote><p>  Para verificar se tudo funcionou, abra <strong>Configura√ß√µes&gt; Siri e pesquise</strong> - o atalho com base em nossa atividade deve estar na lista. </p><br><h3 id="obrabotka-shortkata-prilozheniem-handle">  Processando atalhos por aplicativo (identificador) </h3><br><p>  Quando um usu√°rio navega pelo atalho a partir do centro de notifica√ß√£o ou o ativa por voz, o aplicativo √© iniciado e precisamos processar esse atalho. </p><br><p>  <code>activity</code> lan√ßada para n√≥s no <code>AppDelegate</code> ', um m√©todo: </p><br><pre> <code class="javascript hljs">func application(_ application: UIApplication, <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> userActivity: NSUserActivity, <span class="hljs-attr"><span class="hljs-attr">restorationHandler</span></span>: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> userActivity.activityType == <span class="hljs-string"><span class="hljs-string">"ru.tinkoff.demo.show-cashMachine"</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     handleShowCashMachineActivity() return true } return false }</span></span></code> </pre> <br><h3 id="itogo">  Total </h3><br><p>  Um <code>NSUserActivity</code> NSUserActivity √© criado da seguinte maneira: </p><br><ol><li>  Declare o tipo (identificador) de <code>NSUserActivity</code> em <code>NSUserActivity</code> . </li><li>  Criamos <code>NSUserActivity</code> no c√≥digo e configuramos </li><li>  <code>viewController'</code> . </li></ol><br><h2 id="sozdanie-golosovyh-komand-iz-prilozheniya">  Criando comandos de voz a partir de um aplicativo </h2><br><p>  Portanto, se o usu√°rio abrir <strong>Configura√ß√µes&gt; Siri e pesquisar</strong> , ele ver√° uma lista de seus atalhos, criados por v√°rios aplicativos, incluindo o nosso.  Ao clicar no " <strong>+</strong> ", o usu√°rio pode criar qualquer comando de voz e associ√°-lo ao atalho selecionado.  No entanto, cada vez que entrar nas configura√ß√µes √© inconveniente para o usu√°rio, muitos nem percebem essa possibilidade. </p><br><p>  √â legal poder anexar um comando de voz a uma a√ß√£o espec√≠fica diretamente dentro do aplicativo. </p><br><p>  Suponha que um usu√°rio execute alguma a√ß√£o, seja entregue ao sistema, ele queira salv√°-lo.  Podemos adicionar o bot√£o " <em>adicionar a√ß√£o ao Siri</em> " (voc√™ pode nomear e desenhar o bot√£o como desejar) na tela do nosso aplicativo, para que o usu√°rio, ao clicar nele, possa associar esta a√ß√£o a um comando de voz dentro do aplicativo sem acessar as configura√ß√µes. </p><br><p>  Ao clicar no bot√£o, voc√™ deve abrir modalmente a tela para adicionar um comando de voz a um atalho no Siri <code>INUIAddVoiceShortcutViewController</code> , ou a tela para editar um comando de voz <code>INUIEditVoiceShortcutViewController</code> , se j√° tiver sido criado.  A <code>action</code> n√£o reagida desse bot√£o ser√° aproximadamente a seguinte: </p><br><pre> <code class="hljs julia"> <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> func addToSiriAction() { // <span class="hljs-number"><span class="hljs-number">1.</span></span>   ,       INVoiceShortcutCenter.shared.getAllVoiceShortcuts { (shortcuts, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> guard error == nil, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcuts = shortcuts <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // TODO: Handle error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2.</span></span>     ,      <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> donatedShortcut: INVoiceShortcut? = shortcuts.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (shorcut) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shorcut.__shortcut.userActivity?.activityType == <span class="hljs-string"><span class="hljs-string">"com.ba"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = donatedShortcut { // <span class="hljs-number"><span class="hljs-number">3.</span></span>     -     . //         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> editVoiceShortcutViewController = INUIEditVoiceShortcutViewController(voiceShortcut: shortcut) editVoiceShortcutViewController.delegate = self self.present(editVoiceShortcutViewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // <span class="hljs-number"><span class="hljs-number">4.</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shortcut = INShortcut(userActivity: self.userActivity!) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> addVoiceShortcutViewController = INUIAddVoiceShortcutViewController(shortcut: shortcut) addVoiceShortcutViewController.delegate = self } } }</code> </pre> <br><p>  Portanto, as telas para adicionar e editar um comando de voz para o atalho Siri s√£o exibidas: </p><br><p><img src="https://habrastorage.org/webt/ez/lk/ai/ezlkaihh3q9gvj4syqkizbwqy4c.png"></p><br><p>  Tamb√©m devemos implementar os m√©todos delegados desses viewControllers, nos quais eles precisam ocultar <code>dismiss(animated: true, completion: nil)</code> e, se necess√°rio, atualizar a tela atual.  Por exemplo, se houve um bot√£o "adicionar comando de voz" na tela anteriormente, depois de adicionar um comando de voz, esse bot√£o deve desaparecer ou mudar para "editar comando de voz". </p><br><h2 id="shortkaty-sozdannye-pri-pomoschi-intent">  Atalhos de inten√ß√£o </h2><br><p>  At√© o momento, falamos apenas sobre atalhos que abrem um aplicativo e transmitem <code>NSUserActivity</code> dados para o <code>NSUserActivity</code> . </p><br><p>  Mas voltemos aos atalhos criados pelo <code>Intent</code> , que permitem executar algumas a√ß√µes sem abrir o aplicativo.  Aqui a divers√£o come√ßa. </p><br><p>  Imagine que um usu√°rio pe√ßa sua pizza favorita.  Ele far√° o pedido v√°rias vezes sempre que quiser, e at√© adicionou um comando de voz ao atalho dessa pizza - e isso simplifica sua vida.  Mas podemos fazer mais por ele - podemos garantir que, dando o comando de voz Siri, o sistema n√£o o jogue no aplicativo, mas exiba informa√ß√µes sobre pedidos e solicite pizza imediatamente na interface Siri!  Este √© apenas o caso em que o usu√°rio n√£o precisa abrir o aplicativo em si para executar alguma a√ß√£o. </p><br><p>  Primeiro, v√° para as configura√ß√µes do projeto, selecione o destino principal, a guia <code>Capabilities</code> e habilite o acesso ao Siri. </p><br><p>  Nosso aplicativo pode interagir com o Siri, mas isso n√£o acontece no c√≥digo principal do aplicativo, mas em uma extens√£o de destino separada. </p><br><p>  Para come√ßar, esse destino deve ser criado: <strong>Arquivo ‚Üí Novo ‚Üí Destino</strong> , selecione <strong>Extens√µes de Inten√ß√£o</strong> .  O Xcode oferecer√° a cria√ß√£o de outra extens√£o de destino para a janela que exibe suas a√ß√µes no Siri. Se houver necessidade, concordamos. </p><br><p><img src="https://habrastorage.org/webt/ia/o_/pp/iao_pphchyfpr33hj6jluyy-ozc.jpeg"></p><br><h3 id="obyavlyaem-shortkat-declare-1">  Declarar atalho </h3><br><p>  A principal inova√ß√£o do SiriKit no iOS 12 √© a capacidade de criar seus <code>Inetnts</code> , para aqueles que eram anteriores. </p><br><p><img src="https://habrastorage.org/webt/5a/66/6m/5a666mqkcm0li-cujpl7yexzrgm.png"></p><br><p>  Para fazer isso, crie um novo arquivo: <strong>Arquivo ‚Üí Novo ‚Üí Arquivo</strong> , selecionando <strong>Arquivo de defini√ß√£o de inten√ß√£o do SiriKit</strong> na se√ß√£o <strong>Recurso</strong> . </p><br><p><img src="https://habrastorage.org/webt/qz/8l/lx/qz8llxznc1o05palhxxxcskrcbq.png"></p><br><p>  Como resultado, um arquivo com a extens√£o <em>.intentdefinition √© exibido</em> , no qual voc√™ pode criar seus pr√≥prios <code>Intents</code> .  Abrimos o arquivo e, onde est√° escrito " <strong>Sem Inten√ß√£o</strong> ", na parte inferior, h√° um √≠cone " <strong>+</strong> " - clique nele.  " <strong>Nova inten√ß√£o</strong> ".  Uma inten√ß√£o aparecer√° na lista √† qual voc√™ pode adicionar par√¢metros.  No caso de um pedido de pizza, voc√™ pode adicionar o n√∫mero de pizzas e o tipo de pizza a serem pedidos como par√¢metros.  Para a quantidade, escolhemos o tipo <code>Integer</code> , e para o tipo de pizza, selecionamos o tipo <code>Custom</code> , que no c√≥digo ser√° representado pela classe <code>INObject</code> . </p><br><p>  Agora, algumas linhas de frustra√ß√£o: </p><br><p>  <strong>O usu√°rio n√£o poder√° transmitir par√¢metros diferentes para o mesmo comando de voz salvo.</strong>  <strong>Ai!</strong> </p><br><p><img src="https://habrastorage.org/webt/kn/z4/y-/knz4y-oo1kns8ehvzoojslxqycq.jpeg"></p><br><p>  Quais s√£o os par√¢metros para: </p><br><p>  Suponha que voc√™ crie uma entidade "Mostrar taxa <code>%currency</code> ", em que <code>currency</code> √© um par√¢metro da entidade.  Isso n√£o significa que o usu√°rio possa dizer as frases "Mostrar a taxa de c√¢mbio do d√≥lar", "Mostrar a taxa de c√¢mbio do Bitcoin" etc.  Fora da caixa, isso n√£o funcionar√° assim.  Mas isso significa que, se o usu√°rio analisou a taxa de c√¢mbio do d√≥lar, o atalho "Mostrar taxa do USD" foi criado e, quando analisou a taxa de c√¢mbio do Bitcoin, o atalho "Mostrar taxa do BTC" foi criado, etc.  Em outras palavras, ele pode ter v√°rias shorkatas baseadas na mesma inten√ß√£o, mas com par√¢metros diferentes.  Cada um dos atalhos, o usu√°rio poder√° solicitar seu comando de voz. </p><br><p>  Bem, ao criar uma inten√ß√£o no arquivo <em>.intentdefinition</em> , o <em>Xcode</em> gerar√° automaticamente uma classe para essa inten√ß√£o (nota: n√£o aparecer√° nos arquivos do projeto, mas estar√° dispon√≠vel para uso). Esse arquivo gerado automaticamente estar√° apenas nos destinos que possuem o arquivo <em>.intentdefinition</em> . </p><br><p>  Depois de criar a inten√ß√£o no arquivo .intentdefinition <em>,</em> podemos criar nossas inten√ß√µes no c√≥digo. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intent = <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span>()</code> </pre> <br><h3 id="dostavlyaem-shortkat-v-sistemu-donate-1">  Entregue o atalho para o sistema (Doa√ß√£o) </h3><br><p>  Para que essa entidade seja inclu√≠da na lista de atalhos, √© necess√°rio incorpor√°-la.  Para fazer isso, um objeto <code>INInteraction</code> √© criado com uma inst√¢ncia de sua inten√ß√£o e o m√©todo .donate √© chamado nessa <code>.donate</code> </p><br><pre> <code class="hljs lua">let intent = OrderPizzaIntentf() // ...   let interaction = INInteraction(intent: intent, response: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) interaction.donate { (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> // ...   /  }</code> </pre> <br><p>  Ap√≥s a execu√ß√£o desse c√≥digo, o atalho baseado em inten√ß√£o ser√° entregue ao sistema e exibido nas Configura√ß√µes da Siri. </p><br><h3 id="obrabatyvaem-shortkat-prilozheniem-handle">  Processamos o aplicativo de atalho (Handle) </h3><br><p>  O pr√≥ximo passo √© processar a inten√ß√£o quando o usu√°rio clicar nela no Sirjest da Siri ou a chamar com um comando de voz. </p><br><p>  J√° criamos uma extens√£o de destino para a Siri e ela possui uma classe IntentHandler pr√©-criada, que possui um √∫nico m√©todo - `` handle (for intent) '' </p><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> intent: INIntent)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> intent <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unhandled intent type: \(intent)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">OrderPizzaIntentHandler</span></span>() } }</code> </pre> <br><blockquote>  Nota: Se o compilador n√£o <em>vir</em> a classe de sua inten√ß√£o, voc√™ n√£o adicionou o arquivo de extens√£o de destino <em>.intentdefinition</em> para o Siri. </blockquote><p>  Nesse m√©todo, determinamos o tipo de inten√ß√£o recebida e, para cada tipo, criamos um objeto manipulador que processar√° essa inten√ß√£o.  Crie um manipulador para o nosso <code>OrderPizzaIntent</code> e implemente o protocolo <code>OrderPizzaIntentHandling</code> nele, que j√° √© gerado automaticamente ap√≥s a cria√ß√£o do Intent na <em>defini√ß√£o .intent</em> . </p><br><p>  O protocolo cont√©m dois m√©todos de <code>confirm</code> e <code>handle</code> .  Primeiro, <code>confirm</code> √© chamado onde todos os dados s√£o verificados e a disponibilidade da a√ß√£o √© verificada.  Em seguida, o <code>handle</code> funcionar√° em uma a√ß√£o curta a ser executada. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandler</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderPizzaIntentHandling</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(intent: OrderPizzaIntent, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(OrderPizzaIntentResponse)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.ready, userActivity: nil)) } public func handle(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { //     // ... completion(OrderPizzaIntentResponse(code: OrderPizzaIntentResponseCode.success, userActivity: nil)) } }</span></span></code> </pre> <br><p>  Ambos os m√©todos devem definitivamente chamar a <code>completion</code> com a resposta <code>OrderPizzaIntentResponse</code> (tamb√©m √© gerada automaticamente), caso contr√°rio, a Siri ir√° esperar um longo tempo e, em seguida, cometer um erro. </p><br><h3 id="bolee-podrobnye-otvety-ot-siri">  Respostas mais detalhadas da Siri </h3><br><p>  Existe um conjunto padr√£o de c√≥digos de resposta gerados automaticamente - <code>enum OrderPizzaIntentResponseCode</code> , mas eles podem n√£o ser suficientes para uma interface amig√°vel.  Por exemplo, no est√°gio de <code>confirm</code> , v√°rios erros diferentes podem ocorrer - a pizza acabou, a pizzaria n√£o est√° funcionando no momento, etc.  e o usu√°rio deve aprender sobre esses fatos, em vez da mensagem padr√£o "Erro de aplicativo".  Lembre-se de que criamos <code>Intent</code> no arquivo <em>.intentdefinition</em> ?  Juntamente com a inten√ß√£o em si, sua <code>Response</code> na qual voc√™ pode adicionar suas pr√≥prias op√ß√µes para erros e respostas bem-sucedidas e configur√°-las com os par√¢metros: </p><br><p><img src="https://habrastorage.org/webt/xz/zg/fa/xzzgfawljagfnruxp_zjjdeug2m.png"></p><br><p>  Agora podemos dizer ao usu√°rio erros e respostas mais informativos: </p><br><pre> <code class="hljs lua">public func confirm(intent: OrderPizzaIntent, completion: @escaping (OrderPizzaIntentResponse) -&gt; Void) { guard let pizzaKindId = intent.kind?.identifier <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         -     completion(OrderPizzaIntentResponse(code: .failure, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.isPizzeriaClosed == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { ///     -     completion(OrderPizzaIntentResponse(code: .failurePizzeriaClosed, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pizzeriaManager.menu.isPizzaUnavailable(identifier: pizzaKindId) { ///      -     completion(OrderPizzaIntentResponse(code: .failurePizzaUnavailable(kind: intent.kind), userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } //     -    completion(OrderPizzaIntentResponse(code: .ready, userActivity: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> <br><h3 id="otrisovka-intenta">  Renderiza√ß√£o <code>Intent</code> </h3><br><p>  Se criamos uma <strong>extens√£o de</strong> destino da <strong>interface do usu√°rio de Intent Extension</strong> , podemos desenhar uma Siri na Siri para as inten√ß√µes de que precisamos.  Temos <code>MainInterface.storyboard</code> e <code>IntentViewController</code> nos quais podemos esbo√ßar seu design.  Este controlador de visualiza√ß√£o implementa o protocolo INUIHostedViewControlling e a visualiza√ß√£o √© <code>configureView</code> no m√©todo <code>configureView</code> </p><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Prepare</span></span> your <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the interaction <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> handle. func configureView(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> interaction: INInteraction, interactiveBehavior: INUIInteractiveBehavior, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: INUIHostedViewContext, completion: @escaping (<span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;INParameter&gt;, CGSize) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> configuration here, <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> preparing views <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> calculating a desired <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> presentation. completion(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameters</span></span>, self.desiredSize) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desiredSize: CGSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.extensionContext!.hostedViewMaximumAllowedSize }</code> </pre> <br><p>  Para que esse m√©todo seja chamado, voc√™ precisa adicionar o nome de nossa inten√ß√£o √† matriz <code>NSExtension</code> -&gt; <code>NSExtensionAttributes</code> -&gt; <code>IntentsSupported</code> , que se refere √† interface de destino Intents UI </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtension<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSExtensionAttributes<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>IntentsSupported<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>OrderPizzaIntent<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">array</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Dependendo do design da sua exibi√ß√£o no Siri e da <code>interaction.intent</code> que entrou no m√©todo, voc√™ pode desenhar essa exibi√ß√£o da maneira que desejar.  Abaixo est√£o as capturas de tela de como √© nossa inten√ß√£o no Siri, na pesquisa e em uma tela bloqueada. </p><br><p><img src="https://habrastorage.org/webt/wr/gh/sa/wrghsafmpp3qz3fiih1afdkrrou.png"></p><br><p>  Vale a pena considerar que o usu√°rio n√£o poder√° interagir com bot√µes, rolagem e outros controles na sua exibi√ß√£o, pois o m√©todo √© chamado com o par√¢metro <code>interactiveBehavior = .none</code> , isso certamente imp√µe uma s√©rie de limita√ß√µes. </p><br><h3 id="itogo-1">  Total </h3><br><p>  Um atalho baseado em <code>Intent</code> pode ser renderizado na interface siri ou no centro de notifica√ß√£o e executar uma a√ß√£o sem abrir o aplicativo.  Para cri√°-lo, voc√™ precisa: </p><br><ol><li>  Habilitar <strong>recursos</strong> para usar o Siri </li><li>  Criar <strong>Intents Extensions</strong> e <strong>Intents Extensions UI</strong> </li><li>  Criar <strong>arquivo de defini√ß√£o de inten√ß√£o SiriKit</strong> </li><li>  Criamos nossa <code>Intent</code> nesse arquivo e atribu√≠mos par√¢metros a ele. </li><li>  Crie um <code>IntentHandler</code> no qual implementamos os <code>hanlde</code> <code>confirm</code> e <code>hanlde</code> </li></ol><br><h2 id="rekomendacii">  Recomenda√ß√µes </h2><br><h3 id="obschiy-kod-v-targete-rasshirenii-siri-i-v-osnovnom-prilozhenii">  C√≥digo gen√©rico no destino da extens√£o Siri e no aplicativo principal </h3><br><p>  Se voc√™ tiver um c√≥digo usado no destino da Siri e no destino do projeto principal - existem duas maneiras de resolver esse problema: </p><br><ol><li>  Destaque as classes comuns e adicione-as aos dois destinos.  ( <strong>Exibir ‚Üí Utilit√°rios ‚Üí Mostrar inspetor de arquivos</strong> 'e, na se√ß√£o <strong>Associa√ß√£o</strong> ao <strong>destino</strong> , adicione marcas de sele√ß√£o aos destinos que precisam acessar o arquivo selecionado) </li><li>  Crie uma ou mais estruturas de destino e leve o c√≥digo geral para l√°. </li></ol><br><p>  O √∫ltimo m√©todo √© prefer√≠vel, porque voc√™ pode usar essas estruturas em outras extens√µes e projetos.  Tamb√©m √© importante notar que, para essas estruturas, √© aconselh√°vel definir o sinalizador <code>Allow app extension API only</code> e, ao desenvolver a estrutura, o compilador jurar√° se voc√™ tentar usar uma API ilegal no desenvolvimento de extens√µes (por exemplo, <code>UIApplication</code> ). </p><br><p>  Recursos compartilhados podem ser vasculhados entre destinos por meio de <strong>Grupos de aplicativos</strong> </p><br><h3 id="otladka">  Depura√ß√£o </h3><br><p>  Testar atalhos ajudar√° a ajudar: </p><br><ol><li>  <strong>Configura√ß√µes do</strong> telefone <strong>Configura√ß√µes ‚Üí Desenvolvedor</strong> : <strong>exibir atalhos recentes</strong> e <strong>exibir doa√ß√µes nas</strong> op√ß√µes da <strong>tela de bloqueio</strong> : </li></ol><br><p><img src="https://habrastorage.org/webt/lv/0s/v8/lv0sv8rxfrdw7tgeqaql7p9yyhy.png"></p><br><ol><li>  Para testar o Intens, voc√™ pode iniciar imediatamente a extens√£o de destino especificando no Xcode a frase que a Siri abre.  Para fazer isso, selecione o esquema para a extens√£o de destino Siri </li></ol><br><p><img src="https://habrastorage.org/webt/lc/lf/vj/lclfvj0e18-jx73zrxkf0tasnyq.png"></p><br><p>  Clique neste destino, clique em <strong>Editar esquema ...</strong> </p><br><p><img src="https://habrastorage.org/webt/de/fq/8n/defq8nu0ptzrcaib4bcbwrpfa0k.png"></p><br><p>  No campo <strong>Consulta de inten√ß√£o</strong> da <strong>Siri</strong> , insira uma frase com a qual a Siri j√° iniciar√°, como se voc√™ j√° tivesse dito. </p><br><h2 id="itogo-2">  Total </h2><br><p>  Proponho parar e resumir o que fizemos: </p><br><ol><li>  Os atalhos podem ser criados atrav√©s do <code>NSUserActivity</code> ou atrav√©s do <code>INIntent</code> </li><li>  Os atalhos precisam ser declarados (declarar), relatados ao sistema (doar) e processados ‚Äã‚Äã(manipular). </li><li>  Voc√™ pode adicionar o bot√£o " <em>Adicionar √† Siri</em> " ao aplicativo, clicando no qual o usu√°rio pode adicionar uma frase para a a√ß√£o e, posteriormente, cham√°-la com sua voz. </li><li>  Voc√™ pode criar suas pr√≥prias <code>Intents</code> , al√©m do incorporado. </li><li>  Atrav√©s dos <code>Intents</code> baseados no <code>Intents</code> voc√™ pode criar a√ß√µes que ser√£o executadas atrav√©s da interface Siri (em uma tela bloqueada ou em pesquisa) sem a necessidade de abrir o pr√≥prio aplicativo. </li></ol><br><p>  Na documenta√ß√£o da Apple, h√° um link para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto Demo</a> , que √© √∫til para baixar e focar nele durante o desenvolvimento. </p><br><p>  Gostaria de enfatizar que, no momento da reda√ß√£o deste artigo, h√° uma API na fase <code>beta</code> .  E eu sempre pego problemas e bugs.  Durante o trabalho, periodicamente me deparei com o seguinte: </p><br><ul><li>  ,  Intent  Siri,  . </li><li>   Siri     . </li><li>        Siri. </li></ul><br><h2 id="ssylki">  Refer√™ncias </h2><br><ol><li> WWDC 2018, session 211: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introduction to Siri Shortcuts</a> </li><li> WWDC 2018, session 214: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Building for Voice with Siri Shortcuts</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SiriKit</a> </li><li> Apple Developer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">INUIHostedViewControlling</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Demo  <strong><em>Soup Chef</em></strong>  Apple</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414677/">https://habr.com/ru/post/pt414677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414663/index.html">Burnout profissional: uma palavra para especialistas</a></li>
<li><a href="../pt414667/index.html">[Tema de mini-f√£] Tabela do campeonato da FIFA no terminal</a></li>
<li><a href="../pt414669/index.html">Desenvolvimento de um novo analisador est√°tico: PVS-Studio Java</a></li>
<li><a href="../pt414673/index.html">N√£o √© mais Abibas: o milagre tecnol√≥gico da China</a></li>
<li><a href="../pt414675/index.html">Carreira de gerente de TI: da linha de comando ao trabalho em equipe</a></li>
<li><a href="../pt414679/index.html">Box-shadows.css</a></li>
<li><a href="../pt414683/index.html">A hist√≥ria da cria√ß√£o de um aplicativo m√≥vel para crian√ßas que permite que voc√™ ganhe dinheiro com sua mente. Continua√ß√£o</a></li>
<li><a href="../pt414687/index.html">Como gerenciar uma equipe e voc√™: 15 livros para um gerente de projetos</a></li>
<li><a href="../pt414689/index.html">Li√ß√£o aberta "Aplicativos da Web e microsservi√ßos no Spring Boot 2.0"</a></li>
<li><a href="../pt414691/index.html">Background. YouTube Music e YouTube Premium: o que √© e como eles diferem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>