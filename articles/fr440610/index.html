<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèΩ üìò ü§≥üèø Introduisez l'analyse statique dans le processus, ne vous contentez pas de rechercher des bogues üóæ ‚öîÔ∏è üòπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est une traduction autoris√©e de l'article d'origine . La traduction a √©t√© r√©alis√©e avec l'aimable aide des gars de PVS-Studio. Merci les g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduisez l'analyse statique dans le processus, ne vous contentez pas de rechercher des bogues</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440610/"> <i>Cet article est une traduction autoris√©e de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article d'origine</a> .</i>  <i>La traduction a √©t√© r√©alis√©e avec l'aimable aide des gars de PVS-Studio.</i>  <i>Merci les gars!</i> <br><br>  Ce qui m'a encourag√© √† √©crire cet article, c'est une quantit√© importante de documents sur l'analyse statique, qui est de plus en plus r√©cente.  Tout d'abord, il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog de PVS-Studio</a> , qui se promeut activement sur Habr en publiant des critiques d'erreurs, trouv√©es par leur outil dans des projets open source.  PVS-Studio a r√©cemment impl√©ment√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">support Java</a> et, bien s√ªr, les d√©veloppeurs d'IntelliJ IDEA, dont l'analyseur int√©gr√© est probablement le plus avanc√© pour Java aujourd'hui, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne pouvaient pas rester √† l'√©cart</a> . <br><br>  En lisant ces critiques, j'ai l'impression que nous parlons d'un √©lixir magique: cliquez sur le bouton, et le voici - la liste des d√©fauts juste devant vos yeux.  Il semble qu'√† mesure que les analyseurs deviennent plus avanc√©s, de plus en plus de bugs seront d√©tect√©s, et les produits, scann√©s par ces robots, deviendront de mieux en mieux sans aucun effort de notre part. <br><br>  Eh bien, mais il n'y a pas d'√©lixirs magiques.  Je voudrais parler de ce qui n'est g√©n√©ralement pas parl√© dans des articles comme "voici des choses que notre robot peut trouver": ce que les analyseurs ne sont pas en mesure de faire, quelle est leur v√©ritable partie et place dans le processus de livraison de logiciels, et comment mettre en ≈ìuvre l'analyse correctement. <br><br><img src="https://habrastorage.org/webt/ey/2o/ta/ey2otantl8aitotp4_lojjuscn4.png" width="500"><br>  <i>Ratchet (source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> ).</i> <br><a name="habracut"></a><br><h2>  Ce que les analyseurs statiques ne pourront jamais faire </h2><br>  Quelle est l'analyse du code source du point de vue pratique?  Nous prenons les fichiers source et obtenons quelques informations sur la qualit√© du syst√®me en peu de temps (beaucoup plus court qu'une ex√©cution de tests).  La limitation principale et math√©matiquement insurmontable est que de cette fa√ßon, nous ne pouvons r√©pondre qu'√† un sous-ensemble tr√®s limit√© de questions sur le syst√®me analys√©. <br><br>  L'exemple le plus c√©l√®bre d'une t√¢che, non r√©soluble en utilisant l'analyse statique est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me d'arr√™t</a> : c'est un th√©or√®me, qui prouve qu'on ne peut pas travailler sur un algorithme g√©n√©ral, qui d√©finirait si un programme avec un code source donn√© boucl√© pour toujours ou termin√© pour la derni√®re fois.  L'extension de ce th√©or√®me est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">th√©or√®me de Rice</a> , affirmant que pour toute propri√©t√© non triviale de fonctions calculables, la question de d√©terminer si un programme donn√© calcule une fonction avec cette propri√©t√© est une t√¢che algorithmiquement insoluble.  Par exemple, vous ne pouvez pas √©crire un analyseur, qui d√©termine en fonction du code source si le programme analys√© est une impl√©mentation d'un algorithme sp√©cifique, disons, celui qui calcule la mise au carr√© d'un nombre entier. <br><br>  Ainsi, la fonctionnalit√© des analyseurs statiques a des limites insurmontables.  L'analyseur statique ne pourra jamais d√©tecter tous les cas, par exemple, de bogue "d'exception de pointeur nul" dans les langues sans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©curit√© void</a> .  Ou d√©tectez toutes les occurrences de "attribut introuvable" dans les langues typ√©es dynamiquement.  Tout ce que l'analyseur statique le plus parfait peut faire est de d√©tecter des cas particuliers.  Le nombre d'entre eux parmi tous les probl√®mes possibles avec votre code source, sans exag√©ration, est une goutte dans l'oc√©an. <br><br><h2>  L'analyse statique n'est pas une recherche de bogues </h2><br>  Voici une conclusion qui d√©coule de ce qui pr√©c√®de: l'analyse statique n'est pas le moyen de diminuer le nombre de d√©fauts dans un programme.  Je me risquerais √† affirmer ce qui suit: √©tant appliqu√© pour la premi√®re fois √† votre projet, il trouvera des endroits "amusants" dans le code, mais ne trouvera probablement aucun d√©faut affectant la qualit√© de votre programme. <br><br>  Les exemples de d√©fauts d√©tect√©s automatiquement par les analyseurs sont impressionnants, mais il ne faut pas oublier que ces exemples ont √©t√© trouv√©s en scannant un √©norme ensemble de bases de code par rapport √† un ensemble de r√®gles relativement simples.  De la m√™me mani√®re, les pirates, ayant la possibilit√© d'essayer plusieurs mots de passe simples sur un grand nombre de comptes, finissent par trouver les comptes avec un mot de passe simple. <br><br>  Est-ce √† dire qu'il n'est pas n√©cessaire d'appliquer une analyse statique?  Bien s√ªr que non!  Il doit √™tre appliqu√© pour la m√™me raison que vous souhaiterez peut-√™tre v√©rifier chaque nouveau mot de passe dans la liste d'arr√™t des mots de passe non s√©curis√©s. <br><br><h2>  L'analyse statique est plus que la recherche de bogues </h2><br>  En fait, les t√¢ches qui peuvent √™tre r√©solues par l'analyse dans la pratique sont beaucoup plus larges.  Parce que d'une mani√®re g√©n√©rale, l'analyse statique repr√©sente toute v√©rification du code source, effectu√©e avant de l'ex√©cuter.  Voici certaines choses que vous pouvez faire: <br><br><ul><li> Une v√©rification du style de codage au sens large de ce mot.  Il comprend √† la fois une v√©rification de la mise en forme et une recherche d'utilisation des parenth√®ses vides / inutiles, la d√©finition de valeurs de seuil pour les m√©triques telles qu'un certain nombre de lignes / la complexit√© cyclomatique d'une m√©thode, etc. - tout cela complique la lisibilit√© et la maintenabilit√© du code.  En Java, Checkstyle repr√©sente un outil avec une telle fonctionnalit√©, en Python - <code>flake8</code> .  Ces programmes sont g√©n√©ralement appel√©s "linters". </li><li>  Non seulement le code ex√©cutable peut √™tre analys√©.  La validit√© des ressources telles que les fichiers JSON, YAML, XML et <code>.properties</code> peut (et doit!) √ätre v√©rifi√©e automatiquement.  La raison en est qu'il est pr√©f√©rable de d√©couvrir que, disons, la structure JSON est rompue en raison des citations non appari√©es au d√©but de la v√©rification automatis√©e d'une demande d'extraction plut√¥t que pendant l'ex√©cution des tests ou au moment de l'ex√©cution, n'est pas √ßa?  Il existe des outils pertinents, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YAMLlint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSONLint</a> et <code>xmllint</code> . </li><li>  La compilation (ou l'analyse pour les langages de programmation dynamiques) est √©galement une sorte d'analyse statique.  Habituellement, les compilateurs peuvent √©mettre des avertissements qui signalent des probl√®mes de qualit√© du code source, et ils ne doivent pas √™tre ignor√©s. </li><li>  Parfois, la compilation est appliqu√©e non seulement au code ex√©cutable.  Par exemple, si vous avez de la documentation au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AsciiDoctor</a> , puis en train de la compiler en HTML / PDF, AsciiDoctor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin Maven</a> ) peut √©mettre des avertissements, par exemple, sur des liens internes rompus.  Il s'agit d'une raison importante de ne pas accepter une demande d'extraction avec des modifications de la documentation. </li><li>  La v√©rification orthographique est √©galement une sorte d'analyse statique.  L'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aspell</a> est capable de v√©rifier l'orthographe non seulement dans la documentation, mais aussi dans le code source des programmes (commentaires et litt√©raux) dans divers langages de programmation, notamment C / C ++, Java et Python.  Une faute d'orthographe dans l'interface utilisateur ou la documentation est √©galement un d√©faut! </li><li>  Les tests de configuration repr√©sentent en fait une forme d'analyse statique, car ils n'ex√©cutent pas le code source pendant le processus de leur ex√©cution, m√™me si les tests de configuration sont ex√©cut√©s comme des <code>pytest</code> unitaires <code>pytest</code> . </li></ul><br>  Comme nous pouvons le voir, la recherche de bogues a le r√¥le le moins important dans cette liste et tout le reste est disponible lors de l'utilisation d'outils open source gratuits. <br><br>  Lequel de ces types d'analyse statique doit √™tre utilis√© dans votre projet?  Bien s√ªr, plus c'est mieux!  Ce qui est important ici, c'est une bonne mise en ≈ìuvre, qui sera discut√©e plus loin. <br><br><h2>  Un pipeline de livraison comme filtre √† plusieurs √©tages et l'analyse statique comme sa premi√®re √©tape </h2><br>  Un pipeline avec un flux de changements (depuis les changements du code source jusqu'√† la livraison en production) est une m√©taphore classique de l'int√©gration continue.  La s√©quence standard des √©tapes de ce pipeline se pr√©sente comme suit: <br><br><ol><li>  analyse statique </li><li>  compilation </li><li>  tests unitaires </li><li>  tests d'int√©gration </li><li>  Tests d'interface utilisateur </li><li>  v√©rification manuelle </li></ol><br>  Les modifications rejet√©es √† la N-√®me √©tape du pipeline ne sont pas transmises √† l'√©tape N + 1. <br><br>  Pourquoi et non autrement?  Dans la partie du pipeline, qui traite des tests, les testeurs reconnaissent la pyramide des tests bien connue: <br><br><img src="https://habrastorage.org/webt/hr/41/ut/hr41utwuuzfwoe_3pkr6xm7rcwo.png" width="400"><br>  <i>Pyramide de test.</i>  <i>Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article</a> de Martin Fowler.</i> <br><br>  Au bas de cette pyramide, il y a des tests plus faciles √† √©crire, qui sont ex√©cut√©s plus rapidement et n'ont pas tendance √† produire de faux positifs.  Par cons√©quent, il devrait y en avoir plus, ils devraient couvrir la majeure partie du code et devraient √™tre ex√©cut√©s en premier.  Au sommet de la pyramide, la situation est tout √† fait oppos√©e, de sorte que le nombre de tests d'int√©gration et d'interface utilisateur devrait √™tre r√©duit au minimum n√©cessaire.  Les membres de cette cha√Æne sont la ressource la plus ch√®re, la plus lente et la moins fiable, ils sont donc situ√©s √† la fin et ne font le travail que si les √©tapes pr√©c√©dentes n'ont d√©tect√© aucun d√©faut.  Dans les parties non li√©es aux tests, le pipeline est construit selon les m√™mes principes! <br><br>  Je voudrais sugg√©rer l'analogie sous la forme d'un syst√®me de filtration de l'eau √† plusieurs niveaux.  L'eau sale (change avec des d√©fauts) est fournie dans l'entr√©e, et en tant que sortie, nous devons obtenir de l'eau propre, qui ne contiendra pas toutes les contaminations ind√©sirables. <br><br><img src="https://habrastorage.org/webt/nf/2n/gi/nf2ngidmm_2_aaiye4c52ol0fr0.jpeg" width="400"><br>  <i>Filtre √† plusieurs √©tages.</i>  <i>Source: <a href="">Wikimedia Commons</a></i> <br><br>  Comme vous le savez peut-√™tre, les filtres de purification sont con√ßus pour que chaque √©tape suivante soit capable d'√©liminer les particules contaminantes de plus petite taille.  Les √©tapes d'entr√©e de purification grossi√®re ont un d√©bit plus √©lev√© et un co√ªt inf√©rieur.  Dans notre analogie, cela signifie que les portes de qualit√© d'entr√©e ont de meilleures performances, n√©cessitent moins d'efforts pour √™tre lanc√©es et ont moins de co√ªts d'exploitation.  Le r√¥le de l'analyse statique, qui (comme nous le comprenons maintenant) ne peut √©liminer que les d√©fauts les plus graves est le r√¥le du filtre de puisard en tant que premier √©tage des purificateurs √† plusieurs √©tages. <br><br>  L'analyse statique n'am√©liore pas la qualit√© du produit final par elle-m√™me, tout comme le ¬´puisard¬ª ne rend pas l'eau potable.  Pourtant, en conjonction avec d'autres √©l√©ments du pipeline, son importance est √©vidente.  M√™me si dans un filtre √† plusieurs √©tages, les √©tages de sortie peuvent potentiellement supprimer tout ce que les entr√©es peuvent faire - nous sommes conscients des cons√©quences qui suivront lorsque vous tenterez de vous en sortir uniquement avec des √©tapes de purification fine, sans √©tapes d'entr√©e. <br><br>  Le ¬´puisard¬ª a pour but de d√©charger les √©tapes suivantes de la capture des d√©fauts tr√®s grossiers.  Par exemple, une personne effectuant une r√©vision de code ne doit pas √™tre distraite par du code mal format√© et une violation des normes de code (comme des parenth√®ses redondantes ou des branchements imbriqu√©s trop profond√©ment).  Les bogues comme NPE devraient √™tre d√©tect√©s par les tests unitaires, mais si auparavant, l'analyseur indique qu'un bogue doit appara√Ætre in√©vitablement - cela acc√©l√©rera consid√©rablement sa correction. <br><br>  Je suppose qu'il est maintenant clair pourquoi l'analyse statique n'am√©liore pas la qualit√© du produit lorsqu'elle est appliqu√©e occasionnellement, et doit √™tre appliqu√©e en continu pour filtrer les modifications pr√©sentant de graves d√©fauts.  La question de savoir si l'application d'un analyseur statique am√©liore la qualit√© de votre produit est √† peu pr√®s √©quivalente √† la question "si nous prenons de l'eau d'√©tangs sales, sa qualit√© de boisson sera-t-elle am√©lior√©e lorsque nous la passerons dans une passoire?" <br><br><h2>  Introduction dans un projet h√©rit√© </h2><br>  Un enjeu pratique important: comment mettre en ≈ìuvre l'analyse statique dans le processus d'int√©gration continue, en tant que ¬´porte qualit√©¬ª?  En cas de tests automatis√©s, tout est clair: il existe un ensemble de tests, l'√©chec de l'un d'entre eux est une raison suffisante pour croire qu'une build n'a pas pass√© une porte de qualit√©.  Une tentative de d√©finir la porte de la m√™me mani√®re par les r√©sultats de l'analyse statique √©choue: il y a trop d'avertissements d'analyse sur le code h√©rit√©, vous ne voulez pas tous les ignorer, d'autre part, il est impossible d'arr√™ter la livraison du produit simplement parce que il contient des avertissements de l'analyseur. <br><br>  Pour tout projet, l'analyseur √©met un grand nombre d'avertissements appliqu√©s la premi√®re fois.  La majorit√© des avertissements n'ont rien √† voir avec le bon fonctionnement du produit.  Il sera impossible de les r√©parer tous et beaucoup d'entre eux n'ont pas du tout besoin d'√™tre r√©par√©s.  Au final, nous savons que notre produit fonctionne r√©ellement avant m√™me l'introduction de l'analyse statique! <br><br>  En cons√©quence, de nombreux d√©veloppeurs se cantonnent √† une utilisation occasionnelle de l'analyse statique ou ne l'utilisent qu'en mode informatif, ce qui implique d'obtenir un rapport d'analyseur lors de la construction d'un projet.  Cela √©quivaut √† l'absence d'analyse, car si nous avons d√©j√† de nombreux avertissements, l'√©mergence d'un autre (m√™me grave) reste inaper√ßu lors du changement de code. <br><br>  Voici les moyens connus d'introduction de portes de qualit√©: <br><br><ul><li>  D√©finition de la limite du nombre total d'avertissements ou du nombre d'avertissements, divis√© par le nombre de lignes de code.  Cela fonctionne mal, car une telle porte laisse passer les changements avec de nouveaux d√©fauts jusqu'√† ce que leur limite soit d√©pass√©e. </li><li>  Marquage de tous les anciens avertissements du code comme ignor√©s √† un certain moment et √©chec de la g√©n√©ration lorsque de nouveaux avertissements apparaissent.  Une telle fonctionnalit√© peut √™tre fournie par PVS-Studio et certains autres outils, par exemple, Codacy.  Je n'ai pas eu l'occasion de travailler avec PVS-Studio.  Quant √† mon exp√©rience avec Codacy, leur principal probl√®me est que la distinction entre une ancienne et une nouvelle erreur est un algorithme compliqu√© et pas toujours fonctionnel, surtout si les fichiers changent de mani√®re significative ou sont renomm√©s.  √Ä ma connaissance, Codacy pourrait ignorer de nouveaux avertissements dans une demande d'extraction et en m√™me temps entraver une demande d'extraction en raison d'avertissements, non li√©s √† des modifications du code de ce PR. </li><li>  √Ä mon avis, la solution la plus efficace est la m√©thode du ¬´cliquet¬ª d√©crite dans le livre ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuous Delivery</a> ¬ª.  L'id√©e de base est que le nombre d'avertissements d'analyse statique est une propri√©t√© de chaque version et seules ces modifications sont autoris√©es, ce qui n'augmente pas le nombre total d'avertissements. </li></ul><br><h2>  Cliquet </h2><br>  Cela fonctionne de la mani√®re suivante: <br><br><ol><li>  Dans la phase initiale, une entr√©e sur un certain nombre d'avertissements trouv√©s par les analyseurs de code est ajout√©e dans les m√©tadonn√©es de publication.  Ainsi, lors de la construction de la branche principale, non seulement la ¬´version 7.0.2¬ª est √©crite dans votre gestionnaire de r√©f√©rentiel, mais la ¬´version 7.0.2, contenant 100500 Checkstyle-warnings¬ª.  Si vous utilisez un gestionnaire de r√©f√©rentiels avanc√© (comme Artifactory), il est facile de conserver ces m√©tadonn√©es sur votre version. </li><li>  Lors de la cr√©ation, chaque demande d'extraction compare le nombre d'avertissements r√©sultants avec leur nombre dans une version actuelle.  Si un PR conduit √† une croissance de ce nombre, le code ne passe pas la porte de qualit√© sur l'analyse statique.  Si le nombre d'avertissements est r√©duit ou ne change pas - alors il passe. </li><li>  Lors de la prochaine version, le num√©ro recalcul√© sera √† nouveau √©crit dans les m√©tadonn√©es. </li></ol><br>  Ainsi lentement mais s√ªrement, le nombre d'avertissements convergera vers z√©ro.  Bien s√ªr, le syst√®me peut √™tre tromp√© en introduisant un nouvel avertissement et en corrigeant celui de quelqu'un d'autre.  C'est normal, car √† long terme, cela donne le r√©sultat: les avertissements sont r√©solus, g√©n√©ralement pas un par un, mais par des groupes d'un certain type, et tous les avertissements facilement r√©solus sont r√©solus assez rapidement. <br><br>  Ce graphique montre le nombre total d'avertissements Checkstyle pendant six mois d'un tel "cliquet" sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un de nos projets OpenSource</a> .  Le nombre d'avertissements a √©t√© consid√©rablement r√©duit, et cela s'est produit naturellement, en parall√®le avec le d√©veloppement du produit! <br><br><img src="https://habrastorage.org/webt/ye/wa/u5/yewau5w494aa0vpkaevdydizoqm.png" width="500"><br><br>  J'applique la version modifi√©e de cette m√©thode.  Je compte les avertissements s√©par√©ment pour diff√©rents modules de projet et outils d'analyse.  Le fichier YAML avec des m√©tadonn√©es sur la construction, qui est form√© en proc√©dant ainsi, se pr√©sente comme suit: <br><br><pre> <code class="plaintext hljs">celesta-sql: checkstyle: 434 spotbugs: 45 celesta-core: checkstyle: 206 spotbugs: 13 celesta-maven-plugin: checkstyle: 19 spotbugs: 0 celesta-unit: checkstyle: 0 spotbugs: 0</code> </pre><br>  Dans tout syst√®me CI avanc√©, un "cliquet" peut √™tre impl√©ment√© pour tous les outils d'analyse statique, sans s'appuyer sur des plugins et des outils tiers.  Chacun des analyseurs publie son rapport dans un format texte ou XML simple, qui sera facilement analys√©.  La seule chose √† faire apr√®s, est d'√©crire la logique n√©cessaire dans un script CI.  Vous pouvez jeter un ≈ìil et voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> comment il est impl√©ment√© dans nos projets sources bas√©s sur Jenkins et Artifactory.  Les deux exemples d√©pendent de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ratchetlib</a> : la m√©thode <code>countWarnings()</code> de la mani√®re habituelle compte les balises xml dans les fichiers g√©n√©r√©s par Checkstyle et Spotbugs, et <code>compareWarningMaps()</code> impl√©mente ce m√™me cliquet, lan√ßant une erreur dans le cas, si le nombre d'avertissements dans l'un des les cat√©gories augmentent. <br><br>  Une mani√®re int√©ressante d'impl√©mentation "√† cliquet" est possible pour analyser l'orthographe des commentaires, des litt√©raux de texte et de la documentation en utilisant aspell.  Comme vous le savez peut-√™tre, lors de la v√©rification de l'orthographe, tous les mots inconnus du dictionnaire standard ne sont pas incorrects, ils peuvent √™tre ajout√©s au dictionnaire personnalis√©.  Si vous int√©grez un dictionnaire personnalis√© au projet de code source, le portail de qualit√© pour l'orthographe peut √™tre formul√© comme suit: l'ex√©cution d'aspell avec un dictionnaire standard et personnalis√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne doit pas</a> trouver d'erreurs d'orthographe. <br><br><h2>  L'importance de corriger la version de l'analyseur </h2><br>  En conclusion, il est n√©cessaire de noter ce qui suit: quelle que soit la fa√ßon dont vous choisissez d'introduire l'analyse dans votre pipeline de livraison, la version de l'analyseur doit √™tre fixe.  Si vous laissez l'analyseur se mettre √† jour spontan√©ment, lors de la g√©n√©ration d'une autre demande d'extraction, de nouveaux d√©fauts peuvent appara√Ætre, qui ne sont pas li√©s au code modifi√©, mais au fait que le nouvel analyseur est simplement capable de d√©tecter plus de d√©fauts.  Cela interrompra votre processus de v√©rification de la demande d'extraction.  La mise √† niveau de l'analyseur doit √™tre une action consciente.  Quoi qu'il en soit, la fixation rigide de la version de chaque composant de construction est une exigence g√©n√©rale et un sujet pour un autre sujet. <br><br><h2>  Conclusions </h2><br><ul><li>  L'analyse statique ne trouvera pas de bogues et n'am√©liorera pas la qualit√© de votre produit √† la suite d'une seule ex√©cution.  Seul son fonctionnement continu dans le processus de livraison produira un effet positif. </li><li>  La chasse aux insectes n'est pas du tout l'objectif principal de l'analyse.  La grande majorit√© des fonctionnalit√©s utiles sont disponibles dans les outils open source. </li><li>  Introduire des portes de qualit√© par les r√©sultats de l'analyse statique sur la premi√®re √©tape du pipeline de livraison, en utilisant le ¬´cliquet¬ª pour le code h√©rit√©. </li></ul><br><h2>  Les r√©f√©rences </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livraison continue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexey Kudryavtsev: Analyse de programme: √™tes-vous un bon d√©veloppeur?</a>  Rapport sur diff√©rentes m√©thodes d'analyse de code, pas seulement statique! </li></ol><br><br><hr><br><h2>  Extraits de la discussion de l'article original </h2><br><br>  <b>Evgeniy Ryzhkov</b> <br><br>  Ivan, merci pour l'article et pour nous avoir aid√©s √† faire notre travail, qui est de vulgariser la technologie de l'analyse de code statique.  Vous avez tout √† fait raison de dire que les articles du blog PVS-Studio, au cas o√π les esprits seraient immatures, pourraient les affecter et conduire √† des conclusions telles que "Je vais v√©rifier le code une seule fois, corriger les erreurs et cela suffira."  C'est ma douleur personnelle, que je ne sais pas surmonter depuis d√©j√† plusieurs ann√©es.  Le fait est que les articles sur les contr√¥les de projets: <br><br><ol><li>  Provoque un effet wow chez les gens.  Les gens aiment lire comment les d√©veloppeurs de soci√©t√©s telles que Google, Epic Games, Microsoft et d'autres soci√©t√©s √©chouent parfois.  Les gens aiment penser que n'importe qui peut se tromper, m√™me les leaders de l'industrie font des erreurs.  Les gens aiment lire ces articles. </li><li>  De plus, les auteurs peuvent √©crire des articles sur le flux, sans avoir √† r√©fl√©chir s√©rieusement.  Bien s√ªr, je ne veux pas offenser nos gars qui √©crivent ces articles.  Mais trouver un nouvel article √† chaque fois est beaucoup plus difficile que d'√©crire un article sur une v√©rification de projet (une douzaine de bugs, quelques blagues, m√©langez-le avec des images de licornes). </li></ol><br>  Vous avez √©crit un tr√®s bon article.  J'ai √©galement quelques articles sur ce sujet.  Les autres coll√®gues aussi.  De plus, je visite diff√©rentes entreprises avec un rapport sur le th√®me "Philosophie de l'analyse de code statique", dans lequel je parle du processus lui-m√™me, mais pas de bugs sp√©cifiques. <br><br>  Mais il n'est pas possible d'√©crire 10 articles sur le processus.  Eh bien, pour promouvoir notre produit, nous devons √©crire r√©guli√®rement.  Je voudrais commenter quelques points suppl√©mentaires de l'article avec un commentaire s√©par√© pour amener la discussion plus facilement. <br><br>  Ce court <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> traite de la ¬´Philosophie de l'analyse de code statique¬ª, qui est mon sujet lorsque je visite diff√©rentes entreprises. <br><br>  <b>Ivan Ponomarev</b> <br>  Evgeniy, merci beaucoup pour la revue informative de l'article!  Oui, vous avez eu ma pr√©occupation dans le post sur l'impact sur les "esprits immatures" tout √† fait correctement! <br><br>  Il n'y a personne √† bl√¢mer ici, car les auteurs des articles / rapports sur les <i>analyseurs</i> ne visent pas √† faire des articles / rapports sur l' <i>analyse</i> .  Mais apr√®s quelques articles r√©cents d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Andrey2008</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">lany</a> , j'ai d√©cid√© que je ne pouvais plus me taire. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ivan, comme √©crit ci-dessus, je commenterai trois points de l'article.  Cela signifie que je suis d'accord avec ceux-l√†, que je ne commente pas. <br><br>  1. <i>La s√©quence standard des √©tapes de ce pipeline se pr√©sente comme suit ...</i> <br><br>  Je ne suis pas d'accord pour dire que la premi√®re √©tape est l'analyse statique et que la deuxi√®me est la compilation.  Je pense qu'en moyenne, la v√©rification de la compilation est plus rapide et plus logique qu'une ex√©cution imm√©diate d'une analyse statique "plus lourde".  Nous pouvons discuter si vous pensez le contraire. <br><br>  2. <i>Je n'ai pas travaill√© avec PVS-Studio.</i>  <i>Quant √† mon exp√©rience avec Codacy, leur principal probl√®me est que la distinction entre une ancienne et une nouvelle erreur est un algorithme compliqu√© et pas toujours fonctionnel, surtout si les fichiers changent de mani√®re significative ou sont renomm√©s.</i> <br><br>  Dans PVS-Studio, cela est extr√™mement pratique.  C'est l'une des principales caract√©ristiques du produit, qui, malheureusement, est difficile √† d√©crire dans les articles, c'est pourquoi les gens ne le connaissent pas tr√®s bien.  Nous recueillons des informations sur les erreurs existantes dans une base.  Et pas seulement ¬´le nom du fichier et la ligne¬ª, mais aussi des informations suppl√©mentaires (marque de hachage de trois lignes - actuelle, pr√©c√©dente, suivante), de sorte qu'en cas de d√©calage du fragment de code, nous pourrions toujours le trouver.  Par cons√©quent, lorsque des modifications mineures sont apport√©es, nous comprenons toujours qu'il s'agit d'une ancienne erreur.  Et l'analyseur ne s'en plaint pas.  Maintenant, quelqu'un peut dire: "Eh bien, si le code a beaucoup chang√©, cela ne fonctionnerait pas, et vous vous en plaignez comme s'il √©tait le nouveau?"  Oui  Nous nous plaignons.  Mais en fait, c'est un nouveau code.  Si le code a beaucoup chang√©, c'est maintenant un nouveau code, plut√¥t que l'ancien. <br><br>  Gr√¢ce √† cette fonctionnalit√©, nous avons personnellement particip√© √† la mise en ≈ìuvre du projet avec 10 millions de lignes de code C ++, qui est chaque jour ¬´touch√©¬ª par un tas de d√©veloppeurs.  Tout s'est d√©roul√© sans aucun probl√®me.  Nous recommandons donc d'utiliser cette fonctionnalit√© de PVS-Studio √† toute personne qui introduit l'analyse statique dans son processus.  L'option de fixation du nombre d'avertissements en fonction d'une version me semble moins sympathique. <br><br>  3. <i>Quelle que soit la fa√ßon dont vous choisissez d'introduire votre analyse du pipeline de livraison, la version de l'analyseur doit √™tre fixe</i> <br><br>  Je ne suis pas d'accord avec √ßa.  Un adversaire certain d'une telle approche.  Je recommande de mettre √† jour l'analyseur en mode automatique.  Au fur et √† mesure que nous ajoutons de nouveaux diagnostics et am√©liorons les anciens.  Pourquoi?  Tout d'abord, vous recevrez des avertissements pour de nouvelles erreurs r√©elles.  Deuxi√®mement, certains vieux faux positifs pourraient dispara√Ætre si nous les surmontions. <br><br>  Ne pas mettre √† jour l'analyseur revient √† ne pas mettre √† jour les bases de donn√©es antivirus (¬´et si elles commencent √† notifier les virus¬ª).  Nous ne discuterons pas ici de la v√©ritable utilit√© du logiciel antivirus dans son ensemble. <br><br>  Si, apr√®s la mise √† niveau de la version de l'analyseur, vous avez de nombreux nouveaux avertissements, supprimez-les, comme je l'ai √©crit ci-dessus, via cette fonction.  Mais pas pour mettre √† jour la version ... En r√®gle g√©n√©rale, de tels clients (bien s√ªr, il y en a) ne mettent pas √† jour la version de l'analyseur pendant des ann√©es.  Pas le temps pour √ßa.  Ils PAYENT pour le renouvellement de la licence, mais n'utilisent pas les nouvelles versions.  Pourquoi?  Parce qu'une fois, ils ont d√©cid√© de fixer une version.  Le produit aujourd'hui et il y a trois ans est jour et nuit.  Il s'av√®re que ¬´je vais acheter le billet, mais ne viendra pas¬ª. <br><br>  <b>Ivan Ponomarev</b> <br><br>  1. Ici, vous avez raison.  Je suis pr√™t √† √™tre d'accord avec un compilateur / analyseur au d√©but et cela devrait m√™me √™tre chang√© dans l'article!  Par exemple, les fameux <code>spotbugs</code> ne peuvent pas du tout agir diff√©remment, car ils analysent le bytecode compil√©.  Il y a des cas exotiques, par exemple, dans le pipeline des playbooks Ansible, il est pr√©f√©rable de d√©finir l'analyse statique avant l'analyse car elle est plus l√©g√®re.  Mais c'est l'exotique lui-m√™me) <br><br>  2. <i>L'option de fixation du nombre d'avertissements en fonction d'une release me semble moins sympathique ...</i> - ben oui, c'est moins sympathique, moins technique mais tr√®s pratique :-) L'essentiel c'est que c'est un m√©thode g√©n√©rale, par laquelle je peux impl√©menter efficacement l'analyse statique n'importe o√π, m√™me dans le projet le plus effrayant, ayant n'importe quelle base de code et n'importe quel analyseur (pas n√©cessairement le v√¥tre), en utilisant des scripts Groovy ou bash sur CI.  Soit dit en passant, nous comptons maintenant les avertissements s√©par√©ment pour diff√©rents modules et outils de projet, mais si nous les divisons de mani√®re plus granuleuse (pour les fichiers), cela sera beaucoup plus proche de la m√©thode de comparaison des nouveaux / anciens.  Mais nous avons ressenti cela et j'ai aim√© ce cliquet car il stimule les d√©veloppeurs √† surveiller le nombre total d'avertissements et √† diminuer lentement ce nombre.  Si nous avions la m√©thode des anciens / nouveaux, cela motiverait-il les d√©veloppeurs √† surveiller la courbe du nombre d'avertissements?  - probablement, oui, peut-√™tre, non. <br><br>  Quant au point 3, voici un vrai exemple de mon exp√©rience.  Regardez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce commit</a> .  D'o√π cela vient-il?  Nous pla√ßons des linters dans le script TravisCI.  Ils y travaillaient comme des portes de qualit√©.  Mais tout √† coup, lorsqu'une nouvelle version d'Ansible-lint qui trouvait plus d'avertissements, certaines versions de demandes de tir ont commenc√© √† √©chouer en raison d'avertissements dans le code, qu'ils n'avaient pas modifi√©s !!!  Au final, le processus a √©t√© interrompu et les demandes de retrait urgentes ont √©t√© fusionn√©es sans passer par des barri√®res de qualit√©. <br><br>  Personne ne dit qu'il n'est pas n√©cessaire de mettre √† jour les analyseurs.  Bien s√ªr que √ßa l'est!  Comme tous les autres composants de build.  Mais ce doit √™tre un processus conscient, refl√©t√© dans le code source.  Et chaque fois que les actions d√©pendront des circonstances (que nous r√©parions les avertissements d√©tect√©s √† nouveau ou que nous r√©initialisions simplement le "cliquet") <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Quand on me demande: ¬´Y a-t-il une possibilit√© de v√©rifier chaque commit dans PVS-Studio?¬ª, Je r√©ponds que oui, il y en a.  Et puis ajoutez: "Juste pour l'amour de Dieu, ne manquez pas la construction si PVS-Studio trouve quelque chose!"  Parce que sinon, t√¥t ou tard, PVS-Studio sera per√ßu comme une chose perturbatrice.  Et il y a des situations o√π IL EST N√âCESSAIRE de s'engager rapidement, plut√¥t que de se battre avec les outils, qui ne laissent pas passer le commit. <br><br>  Mon avis qu'il est mauvais d'√©chouer la construction dans ce cas.  Il est bon d'envoyer des messages aux auteurs du code probl√©matique. <br><br>  <b>Ivan Ponomarev</b> <br>  √Ä mon avis, il n'existe pas de ¬´nous devons nous engager rapidement¬ª.  Tout cela n'est qu'un mauvais processus.  Un bon processus g√©n√®re de la vitesse non pas parce que nous cassons un processus / des portes de qualit√©, quand nous devons ¬´le faire rapidement¬ª. <br><br>  Cela ne contredit pas le fait que nous pouvons faire sans manquer une construction sur certaines classes de r√©sultats d'analyse statique.  Cela signifie simplement que la porte est configur√©e de mani√®re √† ignorer certains types de r√©sultats et pour d'autres r√©sultats, nous avons une tol√©rance z√©ro. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mon commitstrip pr√©f√©r√© sur le sujet "rapidement".</a> <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Je suis un adversaire certain de l'approche consistant √† utiliser l'ancienne version de l'analyseur.  Et si un utilisateur d√©couvrait un bogue dans cette version?  Il √©crit √† un d√©veloppeur d'outils et un d√©veloppeur d'outils le corrigera m√™me.  Mais dans la nouvelle version.  Personne ne prendra en charge l'ancienne version pour certains clients.  Si nous ne parlons pas de contrats valant des millions de dollars. <br><br>  <b>Ivan Ponomarev</b> <br>  Evidemment, nous n'en parlons pas du tout.  Personne ne dit que nous devons les garder vieux.  Il s'agit de corriger les versions des d√©pendances des composants de construction pour leur mise √† jour contr√¥l√©e - c'est une discipline courante, elle s'applique √† tout, y compris les biblioth√®ques et les outils. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Je comprends comment "cela devrait √™tre fait en th√©orie".  Mais je ne vois que deux choix faits par les clients.  Soit s'en tenir √† la nouvelle ou √† l'ancienne.  Nous n'avons donc PRESQUE PAS de telles situations quand ¬´nous avons de la discipline et nous sommes en retard par rapport √† la version actuelle sur deux versions¬ª.  Ce n'est pas important pour moi de dire maintenant que c'est bon ou mauvais.  Je dis juste ce que je vois. <br><br>  <b>Ivan Ponomarev</b> <br>  J'ai compris.  Quoi qu'il en soit, tout d√©pend fortement des outils / processus dont disposent vos clients et de la fa√ßon dont ils les utilisent.  Par exemple, je ne sais pas comment tout cela fonctionne dans le monde C ++. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440610/">https://habr.com/ru/post/fr440610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440600/index.html">Combien de noms de domaine .com ne sont pas utilis√©s?</a></li>
<li><a href="../fr440602/index.html">Relier avec Kruger, Socrate et les cercles de la connaissance</a></li>
<li><a href="../fr440604/index.html">Machines comptables, IBM 1403, et pourquoi 132 colonnes sont la norme pour les imprimantes</a></li>
<li><a href="../fr440606/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 286 (du 11 au 17 f√©vrier)</a></li>
<li><a href="../fr440608/index.html">La t√¢che de classer √† travers les yeux d'un √©colier: d√©terminer la pr√©sence d'une voiture dans le parking √† l'aide de cadres provenant d'une cam√©ra de surveillance</a></li>
<li><a href="../fr440612/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 5. Connexion des appareils CISCO et des modes IOS</a></li>
<li><a href="../fr440614/index.html">Probl√®mes de s√©curit√© routi√®re, tri√©s par points</a></li>
<li><a href="../fr440616/index.html">La NASA ach√®te deux si√®ges suppl√©mentaires sur Soyouz, teste le RS-25 et n'abandonne pas la station proche de la Terre</a></li>
<li><a href="../fr440618/index.html">Julia et l'optimisation</a></li>
<li><a href="../fr440620/index.html">Dotfile Madness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>