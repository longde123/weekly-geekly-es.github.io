<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üö¥üèæ üòø Ein anderes Partikelsystem. Post mortem ‚è≥ üí´ üëàüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im September dieses Jahres sollte das Titan World-Handyspiel von Unstoppable, dem Minsker B√ºro von Glu Mobile, ver√∂ffentlicht werden. Das Projekt wurd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein anderes Partikelsystem. Post mortem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424995/"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="Bild"><br><br>  <b>Im September dieses Jahres sollte das Titan World-Handyspiel von Unstoppable, dem Minsker B√ºro von Glu Mobile, ver√∂ffentlicht werden.</b>  <b>Das Projekt wurde kurz vor der Weltver√∂ffentlichung abgesagt.</b>  <b>Aber die Erfolge blieben und die interessantesten von ihnen, mit freundlicher Genehmigung der Leiter des Studios Dennis Zdonov und Alex Paley, m√∂chte ich mit der √ñffentlichkeit teilen.</b> <br><a name="habracut"></a><br>  Im M√§rz 2018 hielten der Teamleiter und ich ein Treffen ab, bei dem wir besprachen, was als n√§chstes zu tun ist: Der Rendercode wurde fertiggestellt, und die Pl√§ne enthielten keine neuen Funktionen und Spezialeffekte.  Es schien eine logische Entscheidung zu sein, das Partikelsystem von Grund auf neu zu schreiben - nach allen Tests f√ºhrte es zu den gr√∂√üten Produktivit√§tseinbu√üen und machte die Designer mit seiner Benutzeroberfl√§che (Textkonfigurationsdatei) und den √§u√üerst mageren Funktionen verr√ºckt. <br><br>  Es sollte beachtet werden, dass das Team die meiste Zeit im "Morgen Release" -Modus an dem Spiel gearbeitet hat, also habe ich alle Subsysteme geschrieben, erstens, um nicht zu brechen, was bereits funktioniert, und zweitens mit einem kurzen Entwicklungszyklus.  Insbesondere wurden die meisten Effekte, zu denen das regul√§re System nicht in der Lage war, im Fragment-Shader ausgef√ºhrt, ohne den Hauptcode zu beeinflussen. <br><br>  Die Beschr√§nkung der Anzahl der Partikel (Transformationsmatrizen f√ºr jedes Partikel wurden auf CPU gebildet, die Schlussfolgerung wurde durch den Installateur des gl-erweiterbaren ios gezogen), zum Beispiel war es notwendig, einen Shader zu schreiben, der eine gro√üe Anzahl von Partikeln basierend auf der analytischen Darstellung der Form von Objekten "emuliert" und mit dem Raum zusammengesetzt gef√§lschte Daten in den Tiefenpuffer legen. <br><br>  Die z-Koordinate des Fragments wurde f√ºr ein ebenes Teilchen berechnet, als ob wir eine Kugel zeichnen w√ºrden, und der Radius dieser Kugel wurde durch den Sinus des Perlin-Rauschens unter Ber√ºcksichtigung der Zeit moduliert: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  Eine vollst√§ndige Beschreibung der Rekonstruktion der Tiefe der Kugel finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ç√±igo Qu√≠lez</a> , aber ich habe einen vereinfachten, schnelleren Code verwendet.  Nat√ºrlich war er eine grobe Ann√§herung, aber bei komplexen geometrischen Formen (Rauch, Explosionen) gab er ein ziemlich anst√§ndiges Bild. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="Bild"><br>  <i>Gameplay-Screenshot.</i>  <i>Der Rauchrock wurde in einem kleinen Teil hergestellt, mehrere weitere blieben am Hauptteil der Explosion zur√ºck.</i>  <i>Nat√ºrlich sah es ‚Äûvom Boden aus‚Äú am spektakul√§rsten aus, als Geb√§ude und Einheiten von Rauch sanft umh√ºllt wurden. Vorschl√§ge, die Position der Kamera w√§hrend der Explosion zu √§ndern, wurden jedoch nicht produziert.</i> <br><br><h4>  Erkl√§rung des Problems </h4><br>  Was wolltest du auf dem Weg nach drau√üen machen?  Wir gingen vielmehr von den Einschr√§nkungen aus, mit denen wir beim vorherigen Partikelsystem gequ√§lt wurden.  Die Situation wurde durch die Tatsache verschlechtert, dass das Frame-Budget fast ersch√∂pft war und auf schwachen Ger√§ten (wie iPad Air) sowohl Pixel- als auch Vertex-Pipelines voll geladen waren.  Daher wollte ich als Ergebnis das produktivste System erhalten, auch wenn ich die Funktionalit√§t etwas einschr√§nkte. <br><br>  Designer haben eine Liste von Funktionen zusammengestellt und eine Skizze der Benutzeroberfl√§che erstellt, die auf ihren eigenen Erfahrungen und Praktiken mit Einheit, Unwirklichkeit und Nachwirkungen basiert. <br><br><h4>  Verf√ºgbare Technologie </h4><br>  Aufgrund des Erbes und der Einschr√§nkungen, die von der Zentrale auferlegt wurden, waren wir auf OpenGlES 2 beschr√§nkt. Daher waren Technologien wie das in modernen Partikelsystemen verwendete Transformationsfeedback nicht verf√ºgbar. <br><br>  Was war noch √ºbrig?  Verwenden Sie das Abrufen und Speichern von Vertex-Texturen in Texturen?  Eine funktionierende Option, aber der Speicher ist auch fast vorbei, die Leistung einer solchen L√∂sung ist nicht die optimalste und das Ergebnis unterscheidet sich nicht in der architektonischen Sch√∂nheit. <br><br>  Zu diesem Zeitpunkt hatte ich viele Artikel √ºber die Implementierung von Partikelsystemen auf GPU gelesen.  Die √ºberwiegende Mehrheit enthielt einen hellen Titel ("Millionen von Partikeln auf mobiler GPU, mit Vorlieben und Dichtern"). Die Implementierung bestand jedoch aus Beispielen f√ºr einfache, wenn auch am√ºsant aussehende Emitter / Attraktoren und war im Allgemeinen f√ºr den realen Einsatz im Spiel fast nutzlos. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel</a> brachte maximalen Nutzen: Der Autor l√∂ste das eigentliche Problem und machte keine ‚Äûkugelf√∂rmigen Partikel im Vakuum‚Äú.  Die Benchmark-Zahlen aus diesem Artikel und die Profilerstellungsergebnisse haben in der Entwurfsphase viel Zeit gespart. <br><br><h4>  Suche nach Ans√§tzen </h4><br>  Ich begann damit, die vom Partikelsystem gel√∂sten Probleme zu klassifizieren und nach bestimmten F√§llen zu suchen.  Es stellte sich ungef√§hr Folgendes heraus (ein Teil der tats√§chlichen Docks des Konzepts aus der Korrespondenz mit dem Teamleiter): <br><blockquote>  ‚Äú- Partikel / Mesh-Arrays mit zyklischer Bewegung.  Keine Verarbeitungsposition, alles durch die Bewegungsgleichung.  Anwendungen - Rauch aus Rohren, Dampf √ºber Wasser, Schnee / Regen, volumetrischer Nebel, schwankende B√§ume, teilweise Verwendung bei nichtzyklischen Auswirkungen von Explosionen. <br><br>  - B√§nder.  Bildung von vb durch Ereignis, Verarbeitung nur auf der GPU (Aufnahmen durch Strahlen, Fl√ºge entlang einer festen (?) Flugbahn mit einer Spur).  Vielleicht hebt die Variante mit der √úbertragung der Start-Ziel-Koordinaten auf die Uniformen und der Konstruktion des Bandes durch vertexID ab.  mit t.z.  Kreuz mit Fresnel wie bei Direktlichtern + UVScroll rendern. <br><br>  - Partikelerzeugung und Geschwindigkeitsverarbeitung.  Die vielseitigste und schwierigste / langsamste Option finden Sie unter Tech Motion Processing. ‚Äú </blockquote><br>  Kurz gesagt: Es gibt verschiedene Partikeleffekte, von denen einige einfacher als andere implementiert werden k√∂nnen. <br><br>  Wir haben beschlossen, die Aufgabe in mehrere Iterationen aufzuteilen - von einfach bis komplex.  Das Prototyping wurde auf meiner Engine / meinem Editor unter Windows / DirectX11 durchgef√ºhrt, da die Geschwindigkeit einer solchen Entwicklung um mehrere Gr√∂√üenordnungen h√∂her war.  Das Projekt wurde in wenigen Sekunden kompiliert, und die Shader wurden im laufenden Betrieb bearbeitet und im Hintergrund kompiliert. Das Ergebnis wurde in Echtzeit angezeigt, ohne dass zus√§tzliche Gesten wie das Dr√ºcken von Tasten erforderlich waren.  Jeder, der gro√üe Projekte mit einer Menge MacBook / Xcode erstellt hat, wird die Gr√ºnde f√ºr diese Entscheidung verstehen. <br><br>  Alle Codebeispiele stammen aus dem Windows-Prototyp. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="Bild"><br>  <i>Entwicklungsumgebung f√ºr Windows.</i> <br><br><h4>  Implementierung </h4><br>  Die erste Stufe ist die statische Ausgabe einer Anordnung von Partikeln.  Nichts kompliziertes: Starten Sie den Vertex-Bufffer, f√ºllen Sie ihn mit Quads (schreiben Sie die richtige UV f√ºr jedes Quad) und n√§hen Sie die Vertex-ID in die "zus√§tzliche" UV.  Danach bilden wir im Shader anhand der Scheitelpunkt-ID basierend auf den Emittereinstellungen die Positionen der Partikel und stellen mithilfe von UV die Bildschirmkoordinaten wieder her. <br><br>  Wenn vertex_id nativ verf√ºgbar ist, k√∂nnen Sie vollst√§ndig auf einen Puffer und ohne UV verzichten, um die Bildschirmkoordinaten wiederherzustellen (was in der Windows-Version der Fall war). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { ‚Ä¶ uint v_id:SV_VertexID; ‚Ä¶ } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  Danach k√∂nnen Sie einfache Szenarien mit sehr wenig Code implementieren. Beispielsweise ist eine zyklische Bewegung mit kleinen Abweichungen f√ºr den Schneeeffekt geeignet.  Unser Ziel war es jedoch, den K√ºnstlern die Kontrolle √ºber das Verhalten der Partikel zu geben, und sie wissen, wie Sie wissen, selten, wie man Shader erstellt.  Die Option mit Verhaltensvoreinstellungen und Bearbeitungsparametern √ºber die Schieberegler war ebenfalls nicht attraktiv - Shader wechseln oder nach innen verzweigen, voreingestellte Optionen multiplizieren, mangelnde vollst√§ndige Kontrolle. <br><br>  Die n√§chste Aufgabe bestand darin, das Ein- und Ausblenden f√ºr ein solches System zu implementieren.  Partikel sollten nicht aus dem Nichts erscheinen und im Nirgendwo verschwinden.  Bei der klassischen Implementierung eines Partikelsystems verarbeiten wir den Puffer programmgesteuert mit CPU, erstellen neue Partikel und entfernen alte.  Um eine gute Leistung zu erzielen, m√ºssen Sie einen intelligenten Speichermanager schreiben.  Aber was passiert, wenn Sie die "toten" Partikel nicht zeichnen? <br><br>  Angenommen, (f√ºr den Anfang) das Zeitintervall der Partikelemission und die Lebensdauer eines Partikels ist eine Konstante innerhalb eines einzelnen Emitters. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="Bild"><br>  Dann k√∂nnen wir unseren Puffer (der nur die Scheitelpunkt-ID enth√§lt) spekulativ als kreisf√∂rmig darstellen und seine maximale Gr√∂√üe wie folgt bestimmen: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  Berechnen Sie im Shader die Zeit basierend auf Index und Zeit (seit dem Beginn des Effekts verstrichene Zeit). <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  Befindet sich der Emitter in einer zyklischen Phase (alle Partikel werden emittiert und sterben jetzt ab und werden synchron geboren), machen wir aus der Zeit des Partikels Frac und erhalten so eine Schleife. <br><br>  Wir m√ºssen keine Partikel mit einer pTime von weniger als Null zeichnen - sie sind noch nicht geboren.  Gleiches gilt f√ºr Partikel, bei denen die Summe aus Lebensdauer und Stromzeit die Emissionsendezeit √ºberschreitet.  In beiden F√§llen zeichnen wir nichts, indem wir die Partikelgr√∂√üe aufheben und / oder hinter den Bildschirm fallen lassen.  Dieser Ansatz f√ºhrt zu einem geringen Overhead in den Fadein / Fadeout-Phasen, w√§hrend die maximale Leistung in der Sustain-Phase beibehalten wird. <br><br>  Der Algorithmus kann leicht verbessert werden, indem nur der Teil des Scheitelpunktpuffers gesendet wird, der lebende Partikel zum Rendern enth√§lt.  Aufgrund der Tatsache, dass die Emission nacheinander auftritt, werden lebende Partikel h√∂chstens einmal segmentiert, d.h.  Es sind zwei Drawcalls erforderlich. <br><br>  Wenn Sie nun die aktuelle Zeit jedes Partikels kennen, k√∂nnen Sie die Geschwindigkeit, Beschleunigung (und im Allgemeinen alle anderen Parameter) einstellen, um die Bewegungsgleichung zu schreiben, die zu den Koordinaten im Weltraum f√ºhrt. <br><br>  Wenn Sie restauriert von vertex_id uv verwenden, erhalten Sie bereits vier Punkte (genauer gesagt, wir verschieben jeden der Quad-Punkte in die gew√ºnschte Richtung), auf denen der Vertex-Shader nach Abschluss der Projektion seine Arbeit abschlie√üt. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  Mit dem kostenlosen Bonus hatten wir die M√∂glichkeit, nicht nur den Emitter anzuhalten, sondern auch die Zeit mit der Genauigkeit des Rahmens zur√ºckzuspulen.  Diese Funktion hat sich bei der Gestaltung komplexer Effekte als sehr n√ºtzlich erwiesen. <br><br><h4>  Wir erh√∂hen die Funktionalit√§t </h4><br>  Die n√§chste Iteration in der Entwicklung war die L√∂sung des Problems eines sich bewegenden Emitters.  Unser spezielles System wusste nichts √ºber seine Position, und als sich der Emitter bewegte, bewegte sich der gesamte Effekt synchron dahinter.  F√ºr Rauch aus dem Auspuffrohr und √§hnliche Effekte sah es mehr als seltsam aus. <br><br>  Die Idee war, die Emitterposition in einem Scheitelpunktpuffer aufzuzeichnen, wenn ein neues Teilchen geboren wurde.  Da die Anzahl solcher Partikel gering ist, sollte der Overhead minimal sein. <br><br>  Ein Kollege schlug vor, dass er bei der Entwicklung seiner eigenen Benutzeroberfl√§che nur einen Teil des Scheitelpunktpuffers zuordnen / nicht zuordnen und mit der Leistung dieser L√∂sung sehr zufrieden war.  Ich habe Tests durchgef√ºhrt und es stellte sich heraus, dass dieser Ansatz sowohl auf Desktop- als auch auf mobilen Plattformen wirklich gut funktioniert. <br><br>  Die Schwierigkeit trat bei der Synchronisation der Zeit auf CPU und GPU auf.  Es musste sichergestellt werden, dass die Pufferaktualisierung genau dann durchgef√ºhrt wurde, wenn sich das ‚Äûneue‚Äú, geschlungene Partikel in seiner Startposition befand.  Das hei√üt, in Bezug auf den Ringpuffer ist es notwendig, die Grenzen des Aktualisierungsbereichs mit der Betriebszeit des Emitters zu synchronisieren. <br><br>  Ich habe den hlsl-Code nach C ++ √ºbertragen, f√ºr den Test habe ich den Emitter geschrieben, der sich in Lissajous bewegt, und das alles hat pl√∂tzlich funktioniert.  Von Zeit zu Zeit ‚Äûspuckte‚Äú das System jedoch auf ein oder mehrere Partikel, feuerte sie in eine beliebige Richtung, entfernte sie nicht rechtzeitig oder erzeugte neue an beliebigen Orten. <br><br>  Das Problem wurde gel√∂st, indem die Genauigkeit der Berechnung der Zeit im Motor √ºberpr√ºft und gleichzeitig das Zeitdelta bei der Aufzeichnung der neuen Emitterposition √ºberpr√ºft wurde, sodass der gesamte Pufferabschnitt, der von der vorherigen Iteration nicht betroffen war, aktualisiert wurde.  Es war auch notwendig, dass das System unter den Bedingungen einer erzwungenen Desynchronisation arbeitete - ein pl√∂tzlicher R√ºckgang der fps sollte den Effekt nicht beeintr√§chtigen, zumal unser Spiel f√ºr verschiedene Ger√§te je nach Leistung unterschiedliche fps aufzeichnete - 60/30/20. <br><br>  Der Methodencode ist ziemlich gewachsen (der Ringpuffer ist schwer elegant zu verarbeiten), aber unter Ber√ºcksichtigung aller Bedingungen funktionierte das System korrekt und stabil. <br><br>  Um diese Zeit hatte der Partner bereits den ‚ÄûFisch‚Äú des Editors erstellt, der zum Testen des Systems ausreichte, und die / api-Vorlagen f√ºr die Integration des Systems in unsere Engine geschrieben. <br><br>  Ich habe den gesamten Code auf ios / opengl portiert, integriert und schlie√ülich echte Effekttests auf einem echten Ger√§t durchgef√ºhrt.  Es wurde deutlich, dass das System nicht nur funktioniert, sondern auch f√ºr die Produktion geeignet ist.  Es blieb noch Zeit, den UI-Editor fertigzustellen und den Code auf den Status "Es ist nicht be√§ngstigend, ihn morgen zu ver√∂ffentlichen" zu bringen. <br><br>  Wir haben uns sogar schon darauf vorbereitet, einen Speichermanager zu schreiben, um keinen Puffer (der schlie√ülich vertex_id, uv, position und den anf√§nglichen Partikelvektor speicherte) f√ºr jeden neuen Effekt mit einem dynamischen Emitter zuzuweisen / zu zerst√∂ren, als mir eine andere Idee einfiel. <br><br>  Die Tatsache, dass der Scheitelpunktpuffer in diesem System vorhanden ist, hat mich verfolgt.  Er sah deutlich in ihrem Archaismus, "dem Erbe des dunklen Zeitalters des festen F√∂rderers".  Bei Testeffekten an einem Windows-Prototyp dachte ich, dass die Bewegung des Emitters immer glatt und immer viel langsamer ist als die Bewegung des Partikels.  Dar√ºber hinaus f√ºhrt die Aktualisierung der Position bei einer gro√üen Anzahl von Partikeln dazu, dass Hunderte von Partikeln dieselben Daten aufzeichnen.  Die L√∂sung erwies sich als einfach: Wir f√ºhren ein festes Array ein, in das die durch die Lebensdauer des Partikels normalisierte ‚ÄûHistorie‚Äú der Position des Emitters f√§llt.  Und auf GPU werden wir die Daten interpolieren.  Danach verschwand der Bedarf an dynamischen Puffern in der Version ios / gles2 (nur die allgemeine Statik blieb f√ºr die Implementierung von vertex_id √ºbrig), und in Windows / dx11-Versionen verschwanden die Puffer aufgrund der nativen vertex_id und der F√§higkeit von d3d api, null zu akzeptieren, anstatt mit dem Vertex-Puffer zu verkn√ºpfen. <br><br>  Daher verbraucht die Win-Version des Systems nach modernen Ma√üst√§ben √ºberhaupt keinen Speicher, egal wie viele Partikel wir anzeigen m√∂chten.  Nur ein kleiner konstanter Puffer mit Parametern, ein Puffer von Positionen / Basen (60 Vektorpaare erwiesen sich als ausreichend, mit einem Rand f√ºr jeden Fall) und, falls erforderlich, Textur.  Leistungsmessungen zeigen eine Geschwindigkeit nahe an synthetischen Tests. <br><br>  Dar√ºber hinaus sah der ‚ÄûSchwanz‚Äú in Effekten wie Funken viel nat√ºrlicher aus, da durch Interpolation die Abtastung durch Frames entfernt werden konnte und der Emitter seine Position reibungslos √§nderte, als ob Zeichnungsaufrufe mit einer Frequenz von Hunderten von Hertz ausgef√ºhrt w√ºrden. <br><br><h4>  Eigenschaften </h4><br>  Zus√§tzlich zur Grundfunktionalit√§t des Partikelfluges (Geschwindigkeit, Beschleunigung, Schwerkraft, Widerstand des Mediums) ben√∂tigten wir eine bestimmte Menge an funktionellem ‚ÄûFett‚Äú. <br>  Infolgedessen wurden Bewegungsunsch√§rfe (Partikel, die sich entlang eines Bewegungsvektors dehnen), Partikelorientierung √ºber den Bewegungsvektor (dies erm√∂glicht beispielsweise das Erstellen einer Partikelkugel), die √Ñnderung der Partikelgr√∂√üe entsprechend der aktuellen Lebenszeit und Dutzende anderer kleiner Dinge implementiert. <br><br>  Komplexit√§t entstand mit Vektorfeldern: Da das System seinen Zustand (Position, Beschleunigung usw.) nicht f√ºr jedes Teilchen speichert, sondern jedes Mal durch die Bewegungsgleichung berechnet, waren eine Reihe von Effekten (wie die Bewegung des Schaums beim R√ºhren von Kaffee) im Prinzip unm√∂glich.  Eine einfache Modulation von Geschwindigkeit und Beschleunigung durch das Ger√§usch von Perlin ergab jedoch Ergebnisse, die recht modern aussehen.  Die Echtzeit-Rauschberechnung f√ºr so viele Partikel erwies sich als zu teuer (selbst bei einer Begrenzung auf f√ºnf Oktaven), sodass eine Textur generiert wurde, aus der der Vertex-Shader dann eine Stichprobe erstellen w√ºrde.  Um den Effekt eines gef√§lschten Vektorfeldes zu verst√§rken, wurde eine kleine Verschiebung der Abtastkoordinaten in Abh√§ngigkeit von der aktuellen Zeit des Emitters hinzugef√ºgt. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="Bild"><br>  <i>Der Zigarettenrauchtest verteilt die Anfangsgeschwindigkeit und die Beschleunigung auf das Perlinger√§usch.</i> <br><br><h4>  Pixelf√∂rderer </h4><br>  Zun√§chst wollten wir nur die Farbe / Transparenz des Partikels je nach Zeit √§ndern.  Ich habe dem Pixel-Shader mehrere Algorithmen hinzugef√ºgt. <br><br>  Textur Farbrotation - vereinfacht, S√ºnde (Farbe + Zeit).  Erm√∂glicht bis zu einem gewissen Grad die Nachahmung des Permutationseffekts von AfterEffects. <br><br>  Gef√§lschte Beleuchtung - Modulation der Farbe eines Partikels durch einen Gradienten in Weltkoordinaten, unabh√§ngig vom Drehwinkel des Partikels. <br><br>  Grenzentwicklung - Wenn sich ein Partikel im Raum bewegt, werden seine Grenzen (Alpha-Kanal) durch eine Kombination aus Scheinwerfer- und Perlin-Rauschen moduliert, wodurch sich eine Str√∂mungsdynamik ergibt, die Wolken, Rauch und anderen Fl√ºssigkeitseffekten sehr √§hnlich ist. <br><br>  Shader Pseudo Code: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//‚Äù‚Äù,  </span></span></code> </pre> <br>  In einer etwas komplizierten Version konnte dieser Shader Grenzen mit beliebiger Weichheit und mit einem Konturhighlight zeichnen, was dem Realismus ‚Äûexplosive‚Äú Effekte hinzuf√ºgte. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="Bild"><br>  <i>Die ersten Experimente mit der Entwicklung von Grenzen.</i> <br><br><h4>  Was weiter? </h4><br>  Obwohl der Editor bereits einsatzbereit und in die Engine integriert war, hatten die Designer keine Zeit, einen einzigen Effekt darauf zu erzielen - das Projekt wurde geschlossen.  Es gibt jedoch keine Hindernisse f√ºr die anderweitige Verwendung dieser Praktiken - beispielsweise f√ºr die Arbeit an der Demo-Revision. <br><br>  Aus technologischer Sicht gibt es auch Bewegungsspielraum - jetzt sind beispielsweise mehrere Auswirkungen der Zerst√∂rung von Drahtgitterobjekten in Betrieb: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="Bild"><br><br>  Die Frage nach dem Sortieren von Partikeln f√ºr das Alpha-Blending bleibt bislang offen: Da im Shader alles analytisch betrachtet wird, gibt es tats√§chlich keine Eingabedaten zum Sortieren.  Aber es gibt ein gro√ües Feld zum Experimentieren! <br><br>  W√§hrend der Entwicklung von Titan World wurden im grafischen Teil des Spiels viele Tricks angewendet, aber beim n√§chsten Mal mehr dar√ºber. <br><br>  PS Hier k√∂nnen Sie in die Quell-Alpha-Engine <a href="">eintauchen</a> .  Beispiele befinden sich im Ordner release / samples, die Hauptsteuertasten sind Leerzeichen, Alt | Strg + Maus.  Shader liegen direkt in FXP-Dateien, ihr Code ist √ºber das Editorfenster verf√ºgbar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424995/">https://habr.com/ru/post/de424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424985/index.html">In einem wichtigen Pr√§zedenzfall konnten US-Geheimdienste Anrufe im Messenger nicht abh√∂ren</a></li>
<li><a href="../de424987/index.html">Stellen Sie mit dem Wiener Filter unscharfe und defokussierte Bilder wieder her. Implementierung in C ++ OpenCV</a></li>
<li><a href="../de424989/index.html">Designprozess: 7 Schritte zum perfekten Projekt</a></li>
<li><a href="../de424991/index.html">Wenn alte Methoden nicht funktionieren: Vasily Mazin - √ºber einen hybriden Ansatz zur KI-Entwicklung</a></li>
<li><a href="../de424993/index.html">Produktmarketing-Praktiken auf der Epic Growth Conference</a></li>
<li><a href="../de424997/index.html">"VKontakte iOS-Anwendung hat eine hohe Einstiegsschwelle": Interview mit Alexei Savin</a></li>
<li><a href="../de425001/index.html">Validierung generischer Parameter in Federreglern</a></li>
<li><a href="../de425003/index.html">Vergleichen Sie TCO-Hardwarek√§ufe und Cloud-Anmietungen</a></li>
<li><a href="../de425005/index.html">Rust News # 1 (September 2018)</a></li>
<li><a href="../de425007/index.html">Iridium und Jeff Bezos AWS haben sich zusammengetan, um ein globales Satelliten-Internetprojekt f√ºr IoT zu entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>