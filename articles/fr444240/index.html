<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 ⏲️ 🥖 Spring Data JPA: Bringing Files ↖️ 🛣️ 🛷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salutations, c'est le deuxième article sur Spring Data JPA. La première partie a été entièrement consacrée aux râteaux sous-marins, ainsi qu'aux astuc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: Bringing Files</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444240/"><p> Salutations, c'est le deuxième article sur Spring Data JPA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La première partie a</a> été entièrement consacrée aux râteaux sous-marins, ainsi qu'aux astuces expérimentées.  Dans cette partie, nous expliquerons comment affiner le cadre selon vos besoins.  Tous les exemples décrits sont disponibles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><a name="habracut"></a><br><h4 id="grafy">  Comtes </h4><br><p>  Commençons peut-être par une tâche simple et en même temps courante: lors du chargement d'une entité, il est nécessaire de télécharger sélectivement sa «fille».  Prenons un exemple simple: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p>  L'entité enfant dans notre exemple est paresseuse: nous ne voulons pas charger de données inutiles (et joindre une autre table dans la requête SQL) lors de la réception de <code>Child</code> .  Mais dans certains cas, dans notre demande, nous savons avec certitude que nous aurons besoin à la fois de l'enfant et de ses parents.  Si vous quittez l'entité paresseux, nous recevons 2 demandes distinctes.  Si vous appliquez un chargement rapide en supprimant <code>FetchType.LAZY</code> , les deux entités seront toujours chargées à la première demande (et nous ne le voulons pas). </p><br><p>  JPQL fournit une bonne solution prête à l'emploi - c'est le mot clé <code>fetch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p>  Cette demande est simple et claire, mais elle présente des inconvénients: </p><br><ul><li>  nous avons en fait dupliqué la logique de <code>JpaRepository::findById</code> ajoutant un chargement explicite </li><li>  chaque requête décrite à l'aide de <code>@Query</code> vérifiée au démarrage de l'application, ce qui nécessite l'analyse de la requête, la vérification des arguments, etc. (voir <a href="">org.springframework.data.jpa.repository.query.SimpleJpaQuery :: validateQuery</a> ).  Tout cela est un travail qui prend du temps et de la mémoire. </li><li>  l'utilisation d'une telle approche dans un grand projet avec des dizaines de référentiels et d'entités entrelacées (parfois avec une douzaine de «filles») conduira à une explosion combinatoire. </li></ul><br><p>  Les comptes viennent à notre aide: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>(value = { <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>( name = Child.PARENT, attributeNodes = <span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) ) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PARENT = <span class="hljs-string"><span class="hljs-string">"Child[parent]"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; }</code> </pre> <br><p>  Le graphique lui-même est facile à décrire; les difficultés commencent lors de son utilisation.  Spring Data JPA sur sa page suggère de le faire de cette façon (selon notre cas): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupInfo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EntityGraph</span></span>(value = Child.PARENT) <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p>  Ici, nous voyons tous les mêmes problèmes (sauf que la demande écrite est devenue un peu plus facile).  Vous pouvez les terminer d'un seul coup à l'aide d'un réglage fin.  Créez votre propre interface, que nous utiliserons pour créer des référentiels au lieu du <code>JpaRepository</code> encadré: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NoRepositoryBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span></span>; }</code> </pre> <br><p>  Maintenant implémentation: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JpaEntityInformation&lt;T, ?&gt; entityInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EntityManager entityManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JpaEntityInformation&lt;T, ?&gt; ei, EntityManager em)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ei, em); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityInfo = ei; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityManager = em; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(id, <span class="hljs-string"><span class="hljs-string">"The given id must not be null!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  EntityGraph&lt;?&gt; graph = entityManager.getEntityGraph(graphName); Map&lt;String, Object&gt; hints = singletonMap(QueryHints.HINT_LOADGRAPH, graph); return entityManager.find(getDomainClass(), id, hints); }</span></span></code> </pre> <br><p>  <code>BaseJpaRepositoryImpl</code> maintenant Spring à utiliser <code>BaseJpaRepositoryImpl</code> comme base pour tous les référentiels de notre application: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(repositoryBaseClass = BaseJpaRepositoryImpl.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Maintenant, notre méthode sera disponible à partir de tous les référentiels hérités de notre <code>BaseJpaRepository</code> . </p><br><p>  Cette approche présente un inconvénient qui peut mettre un porc très gras. </p><br><div class="spoiler">  <b class="spoiler_title">Essayez de penser par vous-même</b> <div class="spoiler_text"><p>  Le problème est que Hibernate (au moins au moment de la rédaction) ne correspond pas aux noms des graphiques et aux graphiques eux-mêmes.  Pour cette raison, il peut y avoir une erreur d'exécution lorsque nous exécutons quelque chose comme </p><br><pre> <code class="java hljs">Optional&lt;MyEntity&gt; entity = repository.findById(id, NON_EXISTING_GRAPH);</code> </pre> </div></div><br><p>  Vous pouvez vérifier l'intégrité de la solution à l'aide du test: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Sql</span></span>(<span class="hljs-string"><span class="hljs-string">"/ChildRepositoryGraphTest.sql"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryGraphTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long childId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository.findOne(childId, Child.PARENT); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertTrue(initialized); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldNotInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository .findById(childId) .orElseThrow(NullPointerException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertFalse(initialized); } }</code> </pre> <br><h4 id="kogda-derevya-byli-bolshimi">  Quand les arbres étaient gros </h4><br><p>  Et nous étions petits et inexpérimentés, nous devions souvent voir ce code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"from Record "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &gt;="</span></span>).append(format(from)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { query.append(<span class="hljs-string"><span class="hljs-string">" and date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query.toString(), DailyRecord.class).getResultList(); }</code> </pre> <br><p>  Ce code collecte la demande pièce par pièce.  Les inconvénients de cette approche sont évidents: </p><br><ul><li>  vous devez faire beaucoup avec vos mains </li><li>  là où il y a du travail manuel - il y a des erreurs </li><li>  pas de coloration syntaxique (des fautes de frappe apparaissent lors de l'exécution) </li><li>  il est très difficile d'étendre et de maintenir le code </li></ul><br><p>  Un peu plus tard, l'API Criteria est apparue, ce qui nous a permis de presser un peu le code ci-dessus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ Criteria criteria = em .unwrap(Session.class) .createCriteria(DailyRecord.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.ge(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, from)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.le(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, to)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> criteria.list(); }</code> </pre> <br><p>  L'utilisation de critères présente plusieurs avantages: </p><br><ul><li>  la possibilité d'utiliser un métamodèle au lieu de valeurs "câblées" comme "date" </li><li>  certaines erreurs dans la construction de la requête s'avèrent être des erreurs de compilation, c'est-à-dire qu'elles sont déjà détectées lors de l'écriture </li><li>  le code est plus court et plus intelligible qu'avec des chaînes de collage stupides </li></ul><br><p>  Il existe également des inconvénients: </p><br><ul><li>  le code est assez compliqué pour comprendre </li><li>  pour apprendre à écrire de telles requêtes, vous devez remplir votre main (je me souviens de la douleur la plus folle lorsque j'ai dû faire face à la correction d'erreurs dans de telles requêtes, consistant parfois en 100-150 lignes, avec branchement, etc.) </li><li>  une requête complexe est plutôt lourde (50 lignes sont loin de la limite) </li></ul><br><p>  Je veux le développer facilement et avec plaisir, donc je n'aime pas ces deux méthodes. </p><br><p>  Tournons-nous vers l'entité que nous avons déjà examinée: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; <span class="hljs-comment"><span class="hljs-comment">//... @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL) @LazyCollection(value = LazyCollectionOption.EXTRA) private List&lt;Toy&gt; toys = new ArrayList&lt;&gt;(); }</span></span></code> </pre> <br><p>  J'aimerais pouvoir charger une entité dans différents modes (et leurs combinaisons): </p><br><ul><li>  charger (ou non) le parent </li><li>  charger (ou non) des jouets </li><li>  trier les enfants par âge </li></ul><br><p>  Si vous résolvez ce problème de front, c'est-à-dire en écrivant un grand nombre de requêtes qui correspondent au mode de chargement sélectionné, cela entraînera très rapidement une explosion combinatoire: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.toys order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithToysOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent join fetch c.toys"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentAndToys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre> <br><p>  Il existe un moyen simple et élégant de résoudre ce problème: une combinaison de moteurs SQL / HQL et de modèles.  «Freemarker» a été utilisé sur mes projets, bien que d'autres solutions puissent être utilisées («Timlif», «Mustash», etc.). </p><br><p>  Commençons à créer.  Tout d'abord, nous devons décrire la requête dans un fichier qui reçoit l' <code>*.hql.ftl</code> ou <code>*.sql.ftl</code> (si vous utilisez du SQL "pur"): </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#* @vtlvariable name="fetchParent" type="java.lang.Boolean" *# #* @vtlvariable name="fetchToys" type="java.lang.Boolean" *# #* @vtlvariable name="orderByAge" type="java.lang.Boolean" *# select child from Child child #if($fetchParent) left join fetch child.parent #end #if($fetchToys) left join fetch child.toys #end #if($orderByAge) order by child.age #end</span></span></code> </pre> <br><p>  Vous avez maintenant besoin d'un gestionnaire: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Configuration configuration; <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String templateName, Map&lt;String, Object&gt; params)</span></span></span></span>{ Template template = configuration.getTemplate(templateName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FreeMarkerTemplateUtils.processTemplateIntoString(template, params); } }</code> </pre> <br><p>  Rien de compliqué.  Accès au référentiel.  Évidemment, l'interface héritant de <code>JpaRepository</code> ne nous convient pas.  Au lieu de cela, nous profiterons de l'occasion pour créer nos propres référentiels: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDao</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TemplateParser templateParser; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"fetchParent"</span></span>, fetchParent); params.put(<span class="hljs-string"><span class="hljs-string">"fetchToys"</span></span>, fetchToys); params.put(<span class="hljs-string"><span class="hljs-string">"orderByAge"</span></span>, orderByAge); String query = templateParser.prepareQuery(BASE_CHILD_TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepositoryTemplates { BASE_CHILD_TEMPLATE(<span class="hljs-string"><span class="hljs-string">"BaseChildTemplate.hql.ftl"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; } }</code> </pre> <br><p>  Pour rendre la méthode <code>findUsingTemplate</code> accessible à partir de <code>ChildRepository</code> vous devez procéder comme <code>findUsingTemplate</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Une caractéristique importante associée au nom</b> <div class="spoiler_text"><p>  Spring ne liera notre classe et nos interfaces qu'avec le nom correct: </p><br><ul><li>  Childrepository </li><li>  ChildRepository <strong>Custom</strong> </li><li>  ChildRepository Impl </li></ul><br><p>  N'oubliez pas ceci, car en cas d'erreur dans le nom, une exception inintelligible sera levée, d'où il est impossible de comprendre la cause de l'erreur. </p></div></div><br><p>  Maintenant, en utilisant cette approche, vous pouvez résoudre des problèmes plus complexes.  Supposons que nous devions effectuer une sélection en fonction des caractéristiques sélectionnées par l'utilisateur.  En d'autres termes, si l'utilisateur n'a pas spécifié les dates "de" et "à", il n'y aura pas de filtrage temporel.  Si seule la date "de" ou uniquement la date "à" est spécifiée, le filtrage sera à sens unique.  Si les deux dates sont spécifiées, seuls les enregistrements entre les dates spécifiées entrent dans la sélection: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestDto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate from; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate to; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChildRequest request)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = singletonMap(<span class="hljs-string"><span class="hljs-string">"request"</span></span>, request); String query = templateParser.prepareQuery(TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); }</code> </pre> <br><p>  Maintenant, le modèle: </p><br><pre> <code class="sql hljs">&lt;<span class="hljs-comment"><span class="hljs-comment">#-- @ftlvariable name="request" type="...RequestDto" --&gt; select child from Child child &lt;#if request.hasDateFrom() &amp;&amp; request.hasDateTo()&gt; where child.birthDate &gt;= :dateFrom and child.birthDate &lt;= :dateTo &lt;#elseif request.hasDateFrom()&gt; where child.birthDate &gt;= :dateFrom &lt;#elseif request.hasDateTo()&gt; where child.birthDate &lt;= :dateTo &lt;/#if&gt;</span></span></code> </pre> <br><h4 id="orakl-i-nvl">  Oracle et nvl </h4><br><p>  Considérez l'essence: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DailyRecord</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String currency; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"record_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal rate; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"fixed_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal fxRate; <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span>(value = AccessLevel.PRIVATE) <span class="hljs-meta"><span class="hljs-meta">@Formula</span></span>(<span class="hljs-string"><span class="hljs-string">"select avg(r.record_rate) from daily_record r where r.currency = currency"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal avgRate; }</code> </pre> <br><p>  Cette entité est utilisée dans la requête (SGBD, rappelons-le, nous avons Oracle): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select nvl(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p>  Il s'agit d'une demande valide et fonctionnelle.  Mais il y a un petit problème, que les experts SQL remarqueront probablement.  Le fait est que <code>nvl</code> dans Oracle n'est pas paresseux.  En d'autres termes, lorsque nous appelons la méthode <code>findRateByCurrency</code> , le journal des <code>findRateByCurrency</code> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl( dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p>  Même si la valeur <code>dr.fixed_rate</code> présente, le SGBD calcule toujours la valeur renvoyée par la deuxième expression dans <code>nvl</code> , qui dans notre cas </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency)</code> </pre> <br><p>  Le lecteur sait probablement déjà comment esquiver le poids inutile de la demande: bien sûr, c'est le mot-clé <code>coalesce</code> , qui se compare favorablement à <code>nvl</code> sa paresse, ainsi que la possibilité d'accepter plus de 2 expressions.  Corrigeons notre demande: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select coalesce(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p>  Et puis, comme on dit, tout d'un coup: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p>  La demande est restée la même.  C'est parce que le dialecte oracle de la boîte transforme la <code>coalesce</code> en une chaîne <code>nvl</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Remarque</b> <div class="spoiler_text"><p>  Si vous souhaitez reproduire ce problème, supprimez la deuxième ligne du constructeur de la classe <a href="">CustomOracleDialect</a> et exécutez le <code>DailyRecordRepositoryTest::findRateByCurrency</code> </p></div></div><br><p>  Pour esquiver cela, vous devez créer votre propre dialecte et l'utiliser dans l'application: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); } }</code> </pre> <br><p>  Oui, c'est tellement simple.  Maintenant, nous lions le dialecte créé à l'application: </p><br><pre> <code class="plaintext hljs">spring: jpa: database-platform: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Une autre façon (obsolète):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate.dialect: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> </div></div><br><p>  L'exécution répétée de la demande donne au koalesk convoité: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><h4 id="orakl-i-postranichnye-zaprosy">  Oracle et demandes de page </h4><br><p>  En général, l'achèvement d'un dialecte offre de riches opportunités pour la manipulation de requêtes.  Souvent, lors du développement d'une application et d'une face Web, la tâche de paginer les données est rencontrée.  En d'autres termes, nous avons plusieurs centaines de milliers d'enregistrements dans la base de données, mais ils sont affichés en paquets de 10/50/100 enregistrements par page.  La date de printemps prête à l'emploi offre au développeur des fonctionnalités similaires: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select new com.luxoft.logeek.data.BriefChildData("</span></span> + <span class="hljs-string"><span class="hljs-string">"c.id, "</span></span> + <span class="hljs-string"><span class="hljs-string">"c.age "</span></span> + <span class="hljs-string"><span class="hljs-string">") from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">" join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>) <span class="hljs-function"><span class="hljs-function">Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span></span>;</code> </pre> <br><p>  Cette approche présente un inconvénient important, à savoir l'exécution de deux requêtes, dont la première obtient les données, et la seconde détermine leur nombre total dans la base de données (cela est nécessaire pour afficher la quantité totale de données dans l'objet <code>Page</code> ).  Dans notre cas, un appel à cette méthode donne les requêtes suivantes (journalisation à l'aide de p6spy): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br><p>  Si la requête est lourde (de nombreuses tables sont jointes par une colonne non indexable, juste beaucoup de jointures, une condition de sélection difficile, etc.), cela peut devenir un problème.  Mais puisque nous avons Oracle, alors en utilisant la pseudo-colonne rownum, vous pouvez vous en tirer avec une seule demande. </p><br><p>  Pour ce faire, nous devons terminer notre dialecte et décrire la fonction utilisée pour compter tous les enregistrements: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); registerFunction(<span class="hljs-string"><span class="hljs-string">"total_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalCountFunc()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TotalCountFunc</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SQLFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasParenthesesIfNoArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, Mapping mapping)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StandardBasicTypes.LONG; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, List arguments, SessionFactoryImplementor factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arguments.size() != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Only 1 argument acceptable"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" count("</span></span> + arguments.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-string"><span class="hljs-string">") over () "</span></span>; } }</code> </pre> <br><p>  Maintenant, écrivez une nouvelle requête (dans la classe <code>ChildRepositoryImpl</code> ): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browseWithTotalCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select "</span></span> + <span class="hljs-string"><span class="hljs-string">" c.id as id,"</span></span> + <span class="hljs-string"><span class="hljs-string">" c.age as age, "</span></span> + <span class="hljs-string"><span class="hljs-string">" total_count(c.id) as totalCount"</span></span> + <span class="hljs-string"><span class="hljs-string">" from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">"join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>; List&lt;BriefChildData&gt; list = em.unwrap(Session.class) .createQuery(query) .setFirstResult((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) pageable.getOffset()) .setMaxResults(pageable.getPageSize()) .setResultTransformer(Transformers.aliasToBean(BriefChildData.class)) .getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl(Collections.emptyList()); } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> totalCount = list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getTotalCount(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl&lt;&gt;(list, pageable, totalCount); }</code> </pre> <br><p>  Lors de l'appel de ce code, une requête sera exécutée </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- &lt;----- from child c inner join parent p on c.parent_id = p.id where p.name = '') where rownum &lt;= 3</span></span></code> </pre> <br><p>  En utilisant l'expression <code>count(c.id) over ()</code> vous pouvez obtenir la quantité totale de données et l'obtenir de la classe de données pour la passer au constructeur <code>PageImpl</code> .  Il existe un moyen de le faire plus élégamment, sans ajouter un autre champ à la classe de données, considérez-le comme un devoir :) Vous pouvez tester la solution en utilisant le test <a href="">ProjectionVsDataTest</a> . </p><br><h4 id="podvodnye-kamni-kastomizacii">  Pièges de la personnalisation </h4><br><p>  Nous avons un projet sympa avec Oracle et Spring Date.  Notre tâche est d'améliorer les performances d'un tel code: </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); ids.stream() .map(repository::findById) .filter(Optional::isPresent) .map(Optional::get) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p>  L'inconvénient réside à première vue: le nombre de requêtes de base de données est égal au nombre de clés uniques.  Il existe une méthode connue pour surmonter cette difficulté: </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); repository .findAllById(ids) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p>  L'avantage de l'échantillonnage multiple est évident: si auparavant, nous avions de nombreuses requêtes similaires du formulaire </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  alors maintenant ils se sont effondrés en un seul </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, ... )</code> </pre> <br><p>  Cela semble être plus facile et est devenu bon.  Le projet grandit, se développe, les données se multiplient et une fois que l'inévitable arrive: </p><br><div class="spoiler">  <b class="spoiler_title">Aki tonnerre dans le ciel clair</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">ERROR - ORA-01795: maximum number of expressions in a list is 1000</code> </pre> </div></div><br><p>  Nous devons à nouveau chercher une issue (ne pas revenir à l'ancienne version).  Étant donné qu'Oracle ne lui permet pas d'alimenter plus de 1 000 clés, vous pouvez diviser l'ensemble de données entier en parts égales ne dépassant pas 1 000 et exécuter un nombre multiple de requêtes: </p><br><pre> <code class="java hljs">List&lt;List&lt;Long&gt;&gt; idChunks = cgccLists.partition(ids, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//* idChunks.forEach(idChunk -&gt; repository.findAllById(idChunk).forEach(this::sendToSchool) ); //* cgccLists = com.google.common.collect.Lists</span></span></code> </pre> <br><p>  Cette méthode fonctionne, mais elle sent légèrement (n'est-ce pas?): Si vous rencontrez de telles difficultés dans d'autres endroits, vous devez clôturer le même jardin.  Essayons de résoudre le problème de manière plus élégante, notamment en <code>BaseJpaRepositoryImpl</code> .  La façon la plus simple de le faire est de transférer la logique ci-dessus vers l'intérieur, en la cachant à l'utilisateur: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); Set&lt;ID&gt; idsCopy = Sets.newHashSet(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; idChunks = Lists.partition(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(ids), <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idChunks .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::findAllById) .flatMap(List::stream) .collect(Collectors.toList()); }</code> </pre> <br><p>  Cela s'est amélioré: d'une part, nous avons nettoyé le code de travail des couches d'infrastructure, et d'autre part, nous avons étendu la portée de notre solution à tous les référentiels de projet qui étendent <code>BaseJpaRepository</code> .  Il y a aussi des inconvénients.  La principale est plusieurs demandes au lieu d'une, et aussi (découle de la principale) - la nécessité de filtrer les clés, car si cela n'est pas fait, alors la même clé peut apparaître dans différents <code>idChunks</code> .  Cela, à son tour, signifie que la même entité sera incluse dans la liste deux fois et, par conséquent, sera traitée deux fois.  Nous n'en avons pas besoin, voici donc une autre solution plus sophistiquée: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); ArrayList&lt;ID&gt; idsCopy = Lists.newArrayList(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;T&gt; query = cb.createQuery(getDomainClass()); Root&lt;T&gt; from = query.from(getDomainClass()); Predicate predicate = toPredicate(cb, ids, from); query = query.select(from).where(predicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityManager.createQuery(query).getResultList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Predicate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toPredicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CriteriaBuilder cb, ArrayList&lt;ID&gt; ids, Root&lt;T&gt; root)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; chunks = Lists.partition(ids, OracleConstants.MAX_IN_COUNT); SingularAttribute&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, ?&gt; id = entityInfo.getIdAttribute(); Predicate[] predicates = chunks.stream() .map(chunk -&gt; root.get(id).in(chunk)) .toArray(Predicate[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb.or(predicates); }</code> </pre> <br><p>  Il utilise l'API Criteria, qui permet de construire une dernière requête du formulaire </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ... , <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">2000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">2001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">3000</span></span>)</code> </pre> <br><p>  Il y a une subtilité: une requête similaire peut être exécutée plus longtemps que d'habitude en raison des conditions encombrantes, donc la première méthode peut (parfois) être préférable. </p><br><p>  C'est tout, j'espère que les exemples vous ont été utiles et utiles dans le développement quotidien.  Les commentaires et ajouts sont les bienvenus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444240/">https://habr.com/ru/post/fr444240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444226/index.html">@Pythonetc compilation février 2019</a></li>
<li><a href="../fr444228/index.html">Trucs et astuces de ma chaîne Telegram @pythonetc, février 2019</a></li>
<li><a href="../fr444230/index.html">Internet d'État: histoire du VPN à distance en Chine</a></li>
<li><a href="../fr444234/index.html">DeepMind et Google: la bataille pour le contrôle d'une IA forte</a></li>
<li><a href="../fr444238/index.html">Refuser en un clic, ou comment un designer pour obtenir un emploi de rêve</a></li>
<li><a href="../fr444242/index.html">Vérification de FreeRDP avec l'analyseur PVS-Studio</a></li>
<li><a href="../fr444244/index.html">Se déplacer dans l'espace et le temps</a></li>
<li><a href="../fr444246/index.html">Vérification de FreeRDP avec PVS-Studio</a></li>
<li><a href="../fr444248/index.html">Test sans tête dans un navigateur. Avantages et inconvénients</a></li>
<li><a href="../fr444250/index.html">Les gens ne sont-ils pas prêts pour le bitcoin ou le bitcoin pour une adoption massive?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>