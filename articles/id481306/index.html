<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐷 ➖ 😆 Memperkenalkan werf 1.0 stable: apa yang harus dilakukan GitOps dengan status, dan rencana 🐓 👩🏼‍🏫 📳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="werf adalah utilitas open source GitOps CLI untuk membangun dan mengirimkan aplikasi ke Kubernetes. werf mendukung merakit gambar aplikasi menggunakan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan werf 1.0 stable: apa yang harus dilakukan GitOps dengan status, dan rencana</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481306/"><img src="https://habrastorage.org/webt/3x/gd/dm/3xgddmaqs9o_1evxjgalmlsczzo.png"><br><br>  <a href="https://werf.io/">werf</a> adalah utilitas <a href="https://github.com/flant/werf">open source</a> GitOps CLI untuk membangun dan mengirimkan aplikasi ke Kubernetes.  werf mendukung merakit gambar aplikasi menggunakan Dockerfile atau kolektor bawaannya sendiri (berdasarkan sintaks YAML, dengan dukungan yang mungkin dan pembangunan kembali secara bertahap berdasarkan Git).  Format konfigurasi yang kompatibel dengan helm digunakan untuk mengirimkan aplikasi.  Kode aplikasi, konfigurasi gambar yang dikumpulkan, dan konfigurasi peluncuran aplikasi disimpan dalam satu repositori Git. <br><br>  <a href="">Rilis stabil yang</a> ditunggu-tunggu <a href="">1.0</a> adalah versi dasar dari utilitas yang dilengkapi fungsi <i>(nomor versi persis dari rilis stabil pertama adalah 1.0.6)</i> .  Dalam versi dasar, werf mendukung siklus penuh pengiriman dan pemeliharaan aplikasi.  Ini termasuk merakit gambar aplikasi, menyebarkan ke Kubernetes, dan membersihkan gambar yang tidak digunakan. <a name="habracut"></a><br><br>  Penting bahwa dalam versi 1.0, semua operasi pada satu proyek ( <code>build</code> , <code>deploy</code> , <code>cleanup</code> ) harus dilakukan dari satu host.  Ini berarti bahwa pekerja tetap harus digunakan dalam sistem CI.  Pada saat yang sama, tidak ada batasan pada paralelisme tugas: tidak sepenuhnya menyelesaikan masalah ini.  Anda juga dapat mendistribusikan berbagai proyek di antara pekerja yang berbeda. <br><br>  Dalam artikel yang didedikasikan untuk rilis ini, kami akan melihat lebih dekat apa yang disediakan dan tidak disediakan versi ini, serta rencana kami untuk versi yang akan datang.  Tetapi kita akan mulai dengan memahami pengertian istilah “GitOps” dan peran werf dalam proses integrasi berkelanjutan dan pengiriman aplikasi (CI / CD). <br><br><h2>  Mengapa werf adalah GitOps </h2><br>  Jadi apa yang kita maksud dengan GitOps dan area apa yang tidak tercakup? <br><br>  Istilah "GitOps" diciptakan oleh Weaveworks sekitar 2,5 tahun yang lalu, dan kami baru-baru ini <a href="https://habr.com/ru/company/flant/blog/458878/">menerjemahkan</a> sebuah artikel dari penulisnya yang mengungkapkan inti dari fenomena baru ini untuk blog.  Dalam pemahaman kami, ide utama dan makna utama GitOps adalah bahwa <b>Git adalah "sumber tunggal kebenaran"</b> .  Toko Git: <br><br><ul><li>  kode aplikasi </li><li>  semua dependensi; </li><li>  informasi tentang cara mengumpulkan kontainer; </li><li>  informasi tentang cara menyebar ke Kubernetes; </li><li>  dan lainnya </li></ul><br>  Dan kemudian ada "sesuatu" yang membuat <b>kenyataan berubah sejalan dengan perubahan Git</b> .  Pendekatan ini dapat diimplementasikan tidak hanya dengan menginstal beberapa operator di Kubernetes yang memonitor Git, tetapi juga menggunakan utilitas konsol yang dapat dipanggil dari sistem CI apa pun.  Selain itu, dari sudut pandang kami, pendekatan dengan utilitas CLI tidak memaksakan pembatasan yang tidak perlu: kita dapat melakukan CI dengan alat apa pun dan dengan sejumlah nuansa, memanggil utilitas CLI yang menyinkronkan "kenyataan" (yaitu Kubernetes) dengan keadaan Git . <br><br>  werf menyediakan antarmuka CLI tingkat tinggi dengan perintah-perintah dasar untuk membangun dan menerbitkan gambar, mengirimkan aplikasi dan membersihkan gambar: <code>werf build-and-publish</code> , <code>werf deploy</code> , <code>werf dismiss</code> , <code>werf cleanup</code> .  Diasumsikan bahwa perintah yang sangat mendasar ini tertanam dalam sistem CI tertentu dan menyediakan sinkronisasi yang diperlukan dengan kenyataan.  Selain itu, werf juga menyediakan antarmuka CLI tingkat rendah untuk mengelola berbagai subsistem - lihat <a href="https://ru.werf.io/documentation/cli/management/stages/build.html">perintah manajemen tingkat rendah</a> dalam dokumentasi. <br><br>  Tidak masalah apakah CI / CD <b>bawaan</b> akan bekerja sesuai dengan model dorong atau tarik <i>(baca lebih lanjut tentang mereka di <a href="https://habr.com/ru/company/flant/blog/456754/">sini</a> )</i> , karena <b>werf dapat dimasukkan ke dalam model apa pun</b> .  Pada saat yang sama, werf menutup masalah seperti bekerja dengan utilitas tingkat rendah yang terpisah seperti <code>git</code> , <code>docker</code> dan kubernetes api-server, menjadi "bagian yang hilang" untuk mengkonfigurasi aplikasi CI / CD terpadu. <br><br><h2>  Apa itu werf 1.0 stable </h2><br><h3>  1. Perakitan, publikasi, dan pembersihan gambar </h3><br>  Jika aplikasi Anda membutuhkan pembuatan gambar Docker, maka menggunakan werf 1.0 Anda dapat: <br><br><ul><li>  jelaskan aturan untuk merakit gambar (Anda dapat memiliki beberapa) dalam satu konfigurasi <code>werf.yaml</code> ; </li><li>  Kumpulkan gambar dan terbitkan ke Docker Registry </li><li>  Bersihkan Docker Registry secara berkala untuk kebijakan khusus. </li></ul><br>  werf mendukung <b>dua cara untuk menggambarkan perakitan</b> : menghubungkan <code>werf.yaml</code> <b>Dockerfiles yang ada</b> dan instruksi untuk <b>kolektor Stapel</b> .  Membangun dengan Stapel memiliki kelebihan: membangun kembali secara bertahap lebih cepat saat mengubah kode aplikasi di Git, menggunakan sintaks yang mungkin untuk perakitan, dan lainnya.  Anda dapat <a href="https://ru.werf.io/documentation/reference/build_process.html">mempelajari</a> lebih lanjut tentang kolektor dan sintaks ini <a href="https://ru.werf.io/documentation/reference/build_process.html">dalam dokumentasi</a> , dan contoh penggunaannya disajikan dalam <a href="https://ru.werf.io/documentation/guides/advanced_build/first_application.html">manual</a> . <br><br>  Skema yang berbeda untuk penandaan / pembuatan versi gambar yang dikumpulkan tersedia dengan mengacu pada komitmen Git, cabang dan tag. <br><br>  Merakit gambar adalah tahap opsional penyebaran aplikasi dan dapat dilewati jika tidak ada gambar rakitan Anda sendiri. <br><br><h3>  2. Penyimpanan panggung hanya pada satu host </h3><br>  werf memperkenalkan konsep penyimpanan tahap.  Perintah werf utama menggunakan penyimpanan panggung sebagai berikut: <br><br><ul><li>  Simpan hasil perakitan - Gambar Docker di toko panggung </li><li>  menggunakan gambar dari toko panggung sebagai cache untuk membangun kembali dan untuk mengumpulkan gambar baru; </li><li>  menggunakan repositori untuk mendapatkan informasi tentang gambar yang dikumpulkan untuk digunakan lebih lanjut (misalnya, ketika mengirimkan aplikasi ke Kubernetes). </li></ul><br>  Saat menggunakan satu aplikasi, penyimpanan satu tahap harus digunakan untuk semua tim (perakitan, publikasi, pembersihan gambar, penerapan aplikasi). <br><br>  Dalam versi 1.0, hanya penyimpanan host lokal yang dapat bertindak sebagai penyimpanan stage (parameter yang sesuai untuk perintah adalah: <code>--stages-storage=:local</code> ).  Saat menggunakan <code>:local</code> tahapan <code>:local</code> disimpan pada disk.  Konsekuensi dari ini: <b>werf 1.0</b> hanya dapat digunakan <b>pada satu host untuk</b> mengatur penyebaran <b>aplikasi tunggal</b> .  Tuan rumah ini harus menyimpan data antara peluncuran perintah agar werf berfungsi dengan benar. <br><br>  Dalam versi 1.0, tidak ada dukungan untuk menyimpan tahapan dalam penyimpanan eksternal, yang dengannya Anda dapat mengatur unit terdistribusi.  Namun, fungsi seperti itu akan muncul di versi werf yang akan datang <i>(lihat di bawah untuk lebih jelasnya)</i> . <br><br><h3>  3. Luncurkan aplikasi dan periksa ketersediaan </h3><br>  Untuk menjalankan aplikasi, pengguna menjelaskan bagan dalam format yang kompatibel dengan Helm: seperangkat manifes Kubernet dan parameter templat. <br><br>  werf meluncurkan aplikasi di Kubernetes dan memberikan jaminan bahwa itu dimulai dan berfungsi sebelum menyelesaikan proses peluncuran aplikasi.  Ini termasuk output dari log komponen dan respons instan terhadap kesalahan peluncuran ketika terjadi kesalahan - perintah peluncuran akan turun dengan kode yang tidak nol.  Jadi, ketika menggunakan werf rollout di CI / CD, <b>kami mendapatkan umpan balik yang memadai dari perangkat lunak</b> : aplikasi diunduh atau tidak, dan ada cukup informasi untuk debug dan memperbaiki masalah (tanpa harus menjalankan utilitas lain untuk menemukan masalah seperti <code>kubectl</code> ). <br><br>  werf sepenuhnya kompatibel dengan instalasi Helm 2 yang ada, tetapi werf memiliki beberapa keunggulan di atasnya.  Misalnya, sebagai mekanisme untuk memperbarui sumber daya, Kubernetes menggunakan tambalan <a href="https://ru.werf.io/documentation/reference/deploy_process/resources_update_methods_and_adoption.html">3-way-merge</a> , dan ada juga kemungkinan menerima umpan balik ketika aplikasi dikirim ke cluster.  Daftar lengkap perbedaan dijelaskan di <a href="https://ru.werf.io/documentation/reference/deploy_process/differences_with_helm.html">halaman ini</a> . <br><br><h3>  4. Hubungan gambar yang dikumpulkan dengan proses pengiriman aplikasi </h3><br>  werf mengintegrasikan gambar yang dikumpulkan ke dalam sistem tunggal, proses penandaan dan versi mereka dengan proses pengiriman aplikasi ke Kubernetes.  Gambar yang dikumpulkan oleh werf dapat digunakan dalam templat deskripsi sumber daya Kubernetes. <br><br>  Karena fungsi-fungsi ini kita dapat mengatakan bahwa <b>werf menyediakan antarmuka tingkat yang lebih tinggi</b> daripada Helm, Docker dan pembangun dan utilitas lain untuk digunakan secara terpisah.  Antarmuka ini memungkinkan Anda untuk hanya mengintegrasikan werf ke sistem CI / CD yang ada dan tidak memecahkan masalah menggabungkan semua komponen yang digunakan - ia menangani tugas ini. <br><br><h3>  5. Integrasi dengan sistem CI / CD yang ada </h3><br>  Dalam versi 1.0, integrasi otomatis hanya tersedia dengan <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">sistem GitLab CI</a> .  Untuk melakukan ini, perintah <code>werf ci-env</code> disediakan.  Ini menerima informasi yang diperlukan dari sistem CI / CD dan secara otomatis mengkonfigurasi werf untuk bekerja dengan benar di lingkungan CI. <br><br>  Anda dapat membaca lebih lanjut tentang cara integrasi dengan sistem CI / CD apa saja bekerja dalam manual ( <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/overview.html">tinjau</a> , <a href="https://ru.werf.io/documentation/reference/plugging_into_cicd/gitlab_ci.html">spesifik GitLab CI</a> , <a href="https://ru.werf.io/documentation/guides/unsupported_ci_cd_integration.html">integrasi dengan sistem lain</a> ). <br><br><h3>  6. Pengembangan lintas platform untuk Linux, Windows dan macOS </h3><br>  werf 1.0 adalah file biner yang terhubung secara statis yang bekerja secara independen dengan rilis Docker dan Helm.  Ketergantungan eksternal pada sistem host: <br><br><ul><li>  Daemon Docker Lokal </li><li>  utilitas git. </li></ul><br>  werf dapat berjalan di salah satu sistem operasi dan lingkungan GNU / Linux, Windows, atau macOS.  Selain itu, hasil perakitan akan sama terlepas dari sistem yang digunakan: tanda tangan yang sama dari tahap cache, pengisian tahap yang sama, terlepas dari sistem tempat tahap ini dikumpulkan.  Perubahan dalam konfigurasi untuk bekerja di sistem yang berbeda juga tidak diperlukan. <br><br>  Jadi, werf 1.0 menyediakan alat lintas platform untuk membangun dan mengirimkan aplikasi ke Kubernetes. <br><br>  Perlu juga dicatat di sini bahwa werf mengumpulkan gambar Docker standar untuk bekerja di lingkungan Linux, tetapi <a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/about/">wadah Windows</a> tidak didukung dalam versi 1.0. <br><br><h3>  7. Meliputi fungsionalitas dengan tes </h3><br>  Saat ini 60% kode werf dicakup oleh tes integrasi e2e dan tes unit. <br><br>  werf diuji pada semua OS yang didukung (Linux, Windows dan macOS) menggunakan GitHub Actions untuk mengatur peluncuran mereka.  Beberapa detail pengujian juga tersedia pada <a href="https://codeclimate.com/github/flant/werf">Kode Iklim</a> . <br><br><h3>  8. Versi werf </h3><br>  Saat ini, dengan rilis versi 1.0, <a href="https://github.com/flant/werf/releases">sekitar 700 rilis</a> telah dibuat dalam proyek ini. <br><br>  werf menggunakan sistem rilis canggih dengan saluran stabilitas: <i>alpha</i> , <i>beta</i> , <i>ea (akses awal)</i> , <i>stabil</i> dan <i>rock-solid</i> .  Posting ini waktunya bertepatan dengan rilis versi pertama 1.0 di saluran <i>stabil</i> .  Perubahan tidak stabil pada versi pertama kali melalui rantai saluran dan akhirnya berakhir di <i>rock-solid</i> .  Rilis sering dilakukan (kadang-kadang beberapa kali sehari) dan perubahan disampaikan terus menerus dalam "porsi kecil." <br><br>  Saluran stabilitas dan banyak rilis sering memungkinkan Anda untuk mendapatkan umpan balik terus menerus tentang perubahan baru, kemampuan untuk dengan cepat mengembalikannya dan secara umum memastikan stabilitas tinggi dari perangkat lunak dan pada saat yang sama kecepatan pengembangan yang dapat diterima. <br><br>  Poin penting adalah bahwa ketika beralih di antara versi 1.0-&gt; 1.1, 1.1-&gt; 1.2, perubahan werf dimungkinkan yang memerlukan intervensi manual oleh pengguna (ini bisa berupa skrip migrasi atau hanya instruksi untuk eksekusi manual yang dijelaskan dalam rilis).  Memperbarui versi di dalam 1.0 (1.0.1, 1.0.2, ... 1.0.6-alpha.1, 1.0.6-beta.2, dll.) Memastikan bahwa perubahan manual tersebut tidak diperlukan. <br><br>  Anda dapat membaca lebih lanjut tentang janji kompatibilitas ke belakang di <a href="https://github.com/flant/werf">sini</a> . <br><br><h2>  Rencana selanjutnya </h2><br>  Berikut tampilan bidang kerja utama untuk versi yang akan datang dan perkiraan persyaratan untuk penerapannya: <br><br><h3>  1. Pengembangan dan penyebaran aplikasi lokal dengan werf </h3><br>  Tujuan utamanya adalah untuk mencapai konfigurasi tunggal terpadu untuk menyebarkan aplikasi baik secara lokal maupun dalam produksi, tanpa tindakan yang rumit, di luar kebiasaan. <br><br>  Werf juga memerlukan mode operasi di mana akan lebih mudah untuk mengedit kode aplikasi dan langsung menerima umpan balik dari aplikasi yang berfungsi untuk debugging. <br><br>  <i>Versi 1.1, Januari-Februari 2020</i> <br><br><h3>  2. Penandaan berbasis konten </h3><br>  Memberi tag pada gambar saat dipublikasikan, hanya berdasarkan pada konten gambar ini.  Tidak seperti mode dengan pengikatan pada komitmen Git, mode ini akan sepenuhnya menyingkirkan pembangunan kembali yang tidak perlu.  Git-commit-id bukan pengidentifikasi universal untuk konten worktree (meskipun tergantung pada itu). <br><br>  Dalam kasus di mana kode aplikasi tidak berubah, tetapi komit baru telah dibuat, mode penandaan saat ini untuk Git akan membuat gambar dengan nama baru ketika diterbitkan.  Ini juga akan memerlukan pengembalian sumber daya menggunakan gambar ini di Kubernetes.  Pada saat yang sama, isi gambar itu sendiri tidak berubah. <br><br>  Untuk mengatasi masalah ini, werf akan memperkenalkan jenis penandaan baru berdasarkan perhitungan checksum <b>konten</b> aplikasi - <b>penandaan berbasis konten</b> . <br><br>  <i>Versi 1.1, Februari-Maret 2020</i> <br><br><h3>  3. Transisi ke Helm 3 </h3><br>  Ini termasuk transisi ke basis kode <a href="https://habr.com/ru/company/flant/news/t/475722/">Helm 3 yang</a> baru dan cara yang terbukti dan nyaman untuk memigrasi instalasi yang ada. <br><br>  <i>Versi 1.1, Februari-Maret 2020</i> <br><br><h3>  4. Perakitan gambar paralel </h3><br>  Saat ini, werf 1.0 mengumpulkan semua tahapan gambar dan artefak yang dideklarasikan dalam <code>werf.yaml</code> secara berurutan.  Membutuhkan kemampuan untuk memparalelkan proses perakitan tahap. <br><br>  <i>Versi: 1.1, Januari-Februari 2020</i> <br><br><h3>  5. Perakitan gambar yang didistribusikan </h3><br>  Saat ini, werf 1.0 hanya dapat digunakan pada satu host khusus <i>(lihat poin di atas tentang penyimpanan stage hanya pada satu host)</i> . <br><br>  Untuk membuka kemungkinan rakitan terdistribusi, ketika rakitan diluncurkan pada beberapa host dan host ini tidak mempertahankan statusnya di antara rakitan (pelari sementara), werf diminta untuk mengimplementasikan kemungkinan menggunakan Docker Registry sebagai repositori panggung. <br><br>  Sebelumnya, ketika proyek werf juga disebut dapp, ia memiliki kesempatan seperti itu.  Namun, kami menemukan sejumlah masalah yang harus dipertimbangkan ketika mengimplementasikan fungsi ini di werf. <br><br>  <i>Versi 1.2: Maret-April 2020</i> <br><br><h3>  6. Jsonnet untuk menggambarkan konfigurasi Kubernetes </h3><br>  werf akan mendukung deskripsi konfigurasi untuk Kubernetes dalam format <a href="https://jsonnet.org/">Jsonnet</a> .  Pada saat yang sama, werf akan tetap kompatibel dengan Helm dan dimungkinkan untuk memilih format deskripsi. <br><br>  Alasannya adalah fakta bahwa templat bahasa Go, menurut banyak orang, memiliki ambang masuk yang besar, dan kejelasan kode templat ini juga menderita. <br><br>  Opsi lain untuk menerapkan sistem deskripsi konfigurasi Kubernetes (seperti Kustomize) juga dipertimbangkan. <br><br>  <i>Versi 1.1: Januari-Februari 2020</i> <br><br><h3>  7. Bekerja di dalam Kubernetes </h3><br>  Tujuan: Untuk memastikan perakitan gambar dan pengiriman aplikasi menggunakan pelari di Kubernetes.  Yaitu  kumpulan gambar baru, publikasi mereka, pembersihan dan penyebaran dapat terjadi langsung dari pod Kubernetes. <br><br>  Untuk mewujudkan fitur ini, pertama-tama Anda perlu kemampuan untuk mendistribusikan gambar secara terdistribusi <i>(lihat paragraf di atas)</i> . <br><br>  Ini juga memerlukan dukungan untuk mode operasi build tanpa daemon Docker (mis., Build seperti Kaniko atau <i>build in userspace</i> ). <br><br>  werf akan mendukung build Kubernet tidak hanya dengan Dockerfile, tetapi juga dengan builder Stapel-nya dengan pembangunan kembali bertahap. <br><br>  <i>Versi 1.2: April-Mei 2020</i> <br><br><h3>  8. Lainnya </h3><br>  Juga direncanakan: <br><br><ul><li>  Peningkatan versi yang dimungkinkan dan kemampuan untuk menggunakan berbagai versi Ansible; </li><li>  mendukung peran yang memungkinkan; </li><li>  dukungan untuk tahapan perakitan acak di Stapel (saat ini tidak mendukung serangkaian statis tahapan: <code>beforeInstall</code> <code>install</code> , <code>install</code> , <code>beforeSetup</code> , <code>setup</code> ); </li><li>  sintaks <code>werf.yaml</code> ditingkatkan, beralih ke <code>configVersion: 2</code> (terkait, antara lain, dengan dua poin sebelumnya), dukungan untuk spesifikasi OpenAPI; </li><li>  Dukungan Git LFS di Stapel untuk menyimpan file besar di Git; </li><li>  peningkatan mekanisme pembersihan gambar (cacat non-kritis dalam versi saat ini dikaitkan dengan gambar yang tidak dideklarasikan dalam konfigurasi <code>werf.yaml</code> di cabang utama utama - gambar ini akan dihapus dengan pembersihan berkala); </li><li>  pekerjaan yang lebih benar dengan ruang nama Kubernet bersama, ketika beberapa aplikasi dikerahkan dalam satu ruang nama; </li><li>  rollback otomatis aplikasi ke versi kerja terbaru jika penyebaran tidak berhasil. </li></ul><br><h2>  Total </h2><br>  Saya akan singkat dalam meringkas.  Kami adalah: <br><br><ul><li>  berjalan jauh ke munculnya versi 1.0; </li><li>  memperhitungkan banyak pengalaman nyata; </li><li>  Kami hadir untuk menggunakan utilitas yang terbukti dengan fungsi yang stabil, diverifikasi oleh puluhan ribu peluncuran. </li></ul><br>  Rilis versi 1.0 menandai dimulainya fase pengembangan baru werf, di mana fitur fundamental baru akan ditambahkan.  Ikuti beritanya!  Dan juga bergabung <a href="https://t.me/werf_ru">dengan saluran terg wer__ru</a> , di mana kehidupan baik pengembang langsung werf, dan insinyur kami, dan pengguna utilitas di luar perusahaan Flant berpartisipasi. <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/news/t/478716/">Werf memiliki dokumentasi dalam bahasa Rusia</a> "; </li><li>  Serangkaian catatan tentang inovasi di werf: <br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/476646/">3-arah bergabung di werf: penyebaran di Kubernetes dengan Helm" on steroids "</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/468049/">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/465131/">Dukungan untuk monorepo dan multirepo di werf dan apa hubungannya dengan Docker Registry dengan itu</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/463613/">Sekarang Anda dapat merakit gambar Docker di werf menggunakan Dockerfile yang biasa</a> "; </li></ul></li><li>  “ <a href="https://habr.com/ru/company/flant/blog/460351/">Werf adalah alat CI / CD kami di Kubernetes (review dan laporan video)</a> ”; </li><li>  “ <a href="https://habr.com/ru/company/flant/blog/458878/">Apa itu GitOps?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481306/">https://habr.com/ru/post/id481306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481290/index.html">Pengaturan CARA-ke / Jaringan dan VLAN pada server Hetzner dan Mikrotik khusus</a></li>
<li><a href="../id481294/index.html">10 alat otomatisasi pengujian perangkat lunak terbaik</a></li>
<li><a href="../id481296/index.html">Cara menulis kode yang akan digunakan kembali</a></li>
<li><a href="../id481302/index.html">"Tentang, ya, bukan cluster" atau karena kami mengimpor DBMS</a></li>
<li><a href="../id481304/index.html">Sortir Bendera Amerika</a></li>
<li><a href="../id481312/index.html">Santa's Lost Gifts: Pengumuman Quest TI untuk 6 Januari</a></li>
<li><a href="../id481314/index.html">Platform DIY Crawler untuk robot dan hiburan</a></li>
<li><a href="../id481316/index.html">Menulis Blog Microservice - Bagian 4 Layanan Pos</a></li>
<li><a href="../id481318/index.html">Meretas dengan Unicode (pada contoh GitHub)</a></li>
<li><a href="../id481320/index.html">Empat Inovasi Teknologi Membentuk Kembali Layanan Kesehatan Saat Ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>