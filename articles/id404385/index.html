<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†– ğŸ˜” ğŸ Stasiun untuk mengukur kecepatan dan arah angin ğŸ¤¹ğŸ½ ğŸ˜š ğŸ˜­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rumah tangga biasa bermerek atau stasiun cuaca buatan sendiri mengukur dua suhu-kelembaban (dalam ruangan dan di jalan), tekanan atmosfer dan juga mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Stasiun untuk mengukur kecepatan dan arah angin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/404385/">  Rumah tangga biasa bermerek atau stasiun cuaca buatan sendiri mengukur dua suhu-kelembaban (dalam ruangan dan di jalan), tekanan atmosfer dan juga memiliki jam dengan kalender.  Namun, stasiun cuaca nyata memiliki lebih banyak lagi - sensor radiasi matahari, meteran curah hujan dan semua itu, yang, secara umum, hanya diperlukan untuk kebutuhan profesional, dengan satu pengecualian.  Alat pengukur parameter angin (kecepatan, dan, yang paling penting, arah) adalah tambahan yang sangat berguna untuk rumah pedesaan.  Selain itu, sensor angin bermerek cukup mahal bahkan pada Ali Baba, dan masuk akal untuk melihat solusi buatan sendiri. <br><a name="habracut"></a><br>  Saya harus segera mengatakan bahwa jika saya tahu sebelumnya berapa banyak pekerjaan manual dan uang yang dihabiskan untuk eksperimen akan mencurahkan ide saya, mungkin saya tidak akan memulai.  Tapi rasa ingin tahu melebihi, dan pembaca artikel ini memiliki kesempatan untuk menghindari perangkap yang saya harus tersandung. <br><br>  Untuk <b>mengukur kecepatan angin</b> (anemometri), ada ratusan metode, yang utamanya adalah: <br><br>  - kawat panas, <br>  - mekanis - dengan baling-baling (lebih tepatnya, baling-baling) atau baling-baling horisontal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anemometer gelas</a> klasik) Pengukuran kecepatan dalam kasus ini setara dengan mengukur kecepatan sumbu di mana baling-baling atau baling baling dipasang. <br>  - Serta USG, menggabungkan pengukuran kecepatan dan arah. <br>  Untuk <b>mengukur arah</b> metode lebih sedikit: <br>  - USG yang disebutkan; <br>  - Baling-baling cuaca mekanis dengan penghapusan sudut rotasi secara elektronik.  Ada juga berbagai cara untuk mengukur sudut rotasi: optik, resistif, magnetik, induktif, mekanis.  Ngomong-ngomong, mungkin saja untuk hanya menempelkan kompas elektronik ke poros baling-baling cuaca - ini hanya metode yang andal dan sederhana (untuk pengulangan "setinggi lutut") untuk mentransmisikan bacaan dari poros yang berputar secara acak.  Oleh karena itu, kami selanjutnya memilih metode optik tradisional. <br><br>  Jika Anda secara mandiri mengulangi salah satu dari metode ini, Anda harus mengingat persyaratan konsumsi energi minimum dan sepanjang waktu (dan mungkin sepanjang tahun?) Paparan terhadap matahari dan hujan.  Sensor angin tidak dapat ditempatkan di bawah atap di tempat teduh - sebaliknya, sensor angin harus berada sejauh mungkin dari semua faktor yang mengganggu dan "terbuka untuk semua angin".  Penempatan yang ideal adalah punggungan atap rumah atau, paling buruk, gudang atau gazebo, jauh dari bangunan dan pohon lainnya.  Persyaratan tersebut membutuhkan daya otonom dan, tentu saja, saluran data nirkabel.  Persyaratan ini bertanggung jawab atas beberapa "lonceng dan peluit" dari desain, yang dijelaskan di bawah ini. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang konsumsi daya minimum</b> <div class="spoiler_text">  Omong-omong, berapa konsumsi daya minimum?  Berdasarkan baterai rumah tangga tipe AA biasa, konsumsi sirkuit rata-rata idealnya tidak lebih dari 1-2 mA.  Hitung sendiri: kapasitas elemen alkali yang layak ukuran AA adalah sekitar 2,5-3 Ah, yaitu, rangkaian dengan konsumsi yang ditunjukkan akan bekerja darinya selama sekitar 1500-2500 jam, atau 2-3 bulan.  Pada prinsipnya, ini juga sedikit, tetapi relatif dapat diterima - Anda tidak dapat melakukan apapun yang kurang: bangkrut atau menggunakan baterai yang perlu diisi lebih sering daripada mengganti baterai.  Untuk alasan ini, ketika menyusun skema seperti itu, kami berkewajiban untuk menangkap remah-remah: mode hemat energi wajib, sirkuit sirkuit yang dipikirkan dengan cermat, dan urutan tindakan dalam program.  Lebih jauh kita akan melihat bahwa dalam desain akhir saya masih belum memenuhi persyaratan yang diperlukan dan harus menggunakan daya baterai. <br><br></div></div><br>  Sebuah cerita kognitif tentang bagaimana saya mencoba mereproduksi metode yang paling modern dan canggih - USG, dan gagal, saya akan menceritakannya lain waktu.  Semua metode lain melibatkan pengukuran kecepatan dan arah yang terpisah, jadi saya harus memagari dua sensor.  Setelah mempelajari anemometer hot-wire secara teoritis, saya menyadari bahwa kami tidak akan bisa mendapatkan elemen sensitif siap pakai dari tingkat amatir (mereka tersedia di pasar Barat!), Tetapi untuk menciptakannya sendiri - untuk terlibat dalam R&amp;D reguler - untuk terlibat dalam R&amp;D reguler dengan pemborosan waktu dan uang yang sesuai.  Oleh karena itu, setelah beberapa pemikiran, saya memutuskan untuk membuat desain terpadu untuk kedua sensor: anemometer gelas dengan pengukuran optik kecepatan putaran dan baling-baling cuaca dengan pengukuran sudut rotasi elektronik berdasarkan pada disk pengkodean (encoder). <br><br><h2>  Desain Sensor </h2><br>  Keuntungan dari sensor mekanik adalah bahwa tidak ada R&amp;D yang diperlukan di sana, prinsipnya sederhana dan jelas, dan kualitas hasilnya hanya bergantung pada keakuratan pelaksanaan desain yang dipikirkan dengan cermat. <br><br>  Jadi sepertinya secara teori, dalam praktiknya, ini menghasilkan banyak pekerjaan mekanik, beberapa di antaranya harus dipesan di samping, karena kurangnya mesin berputar dan penggilingan yang ada.  Saya harus segera mengatakan bahwa saya tidak pernah menyesal bahwa saya telah mengandalkan pendekatan modal sejak awal, dan tidak mulai membuat konstruksi dari bahan improvisasi. <br><br>  Untuk baling-baling cuaca dan anemometer, bagian-bagian berikut diperlukan, yang harus dipesan dari turner dan operator mesin penggilingan (jumlah dan bahan diindikasikan segera untuk kedua sensor): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/abe/8c9/b4c/abe8c9b4c68f9b7a5593d81e5f729cf0.png" width="1000" alt="gambar"><br>  Kami perhatikan, kapak dihidupkan pada mesin bubut: praktis tidak mungkin membuat sumbu dengan titik tepat di tengah lutut.  Dan penempatan ujung persis di sepanjang sumbu rotasi di sini adalah faktor penentu keberhasilan.  Selain itu, poros harus benar-benar lurus, tidak ada penyimpangan yang diizinkan. <br><br><h3>  Sensor arah angin mekanik - baling-baling cuaca elektronik </h3><br>  Dasar dari baling-baling cuaca (serta sensor kecepatan di bawah) adalah braket berbentuk-U yang terbuat dari D-16 duralumin, ditunjukkan pada gambar di kiri atas.  Sepotong fluoroplastik ditekan ke dalam reses yang lebih rendah, di mana reses bertingkat dibuat secara berurutan dengan bor 2 dan 3 mm.  Sumbu dimasukkan ke dalam ceruk ini dengan ujung yang tajam (untuk baling-baling cuaca - dari kuningan).  Dari atas, secara bebas melewati lubang 8 mm.  Di atas lubang ini, sekrup M2 menempel pada braket sepotong persegi panjang dengan fluoroplastik yang sama setebal 4 mm sehingga tumpang tindih lubang.  Sebuah lubang dibuat di fluoroplastik persis di sepanjang diameter sumbu 6 mm (terletak persis di sepanjang sumbu umum lubang - lihat gambar perakitan di bawah).  Ftoroplast di atas dan di bawah memainkan peran bantalan geser. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/f85/413/03a/f8541303a5e102a6255d611e8190686a.png" width="600" alt="gambar"><br>  Sumbu di tempat gesekan terhadap photoplastic dapat dipoles, dan daerah gesekan dapat dikurangi dengan melawan lubang di fluoroplastic.  ( <b>Lihat topik ini di bawah UPD dari 09/13/18 dan 06/05/19</b> ).  Untuk baling-baling cuaca, ini tidak memainkan peran khusus - beberapa "penghambatan" bahkan berguna baginya, dan untuk anemometer, Anda harus mencoba meminimalkan gesekan dan kelembaman. <br><br>  Sekarang tentang penghapusan sudut rotasi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Encoder Grey</a> klasik dengan 16 posisi dalam case kami terlihat seperti yang ditunjukkan pada gambar: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/4ec/2ee/310/4ec2ee310a65fbc1d80e85c834c65963.png" width="500" alt="gambar"><br>  Ukuran disk dipilih berdasarkan isolasi optik yang dapat diandalkan dari pasangan emitor-penerima dari satu sama lain.  Dengan konfigurasi ini, slot selebar 5 mm juga berjarak 5 mm, dan pasangan optik berjarak tepat 10 mm.  Dimensi braket tempat baling-baling cuaca terpasang dihitung dengan tepat berdasarkan diameter disk 120 mm.  Semua ini, tentu saja, dapat dikurangi (terutama jika Anda memilih LED dan photodetektor dengan diameter sekecil mungkin), tetapi kompleksitas pembuatan encoder diperhitungkan: ternyata mesin-mesin penggilingan tidak mengambil pekerjaan rumit seperti itu, sehingga harus dipotong secara manual dengan sebuah file.  Dan semakin besar dimensinya, semakin dapat diandalkan hasilnya dan lebih mudah. <br><br>  Gambar rakitan di atas menunjukkan pemasangan disk ke sumbu.  Disk yang dipusatkan dengan hati-hati diikat dengan sekrup M2 ke hub caprolon.  Selongsong ditempatkan pada sumbu sehingga jarak bebas di atas minimal (1-2 mm) - sehingga sumbu pada posisi normal berputar bebas, dan selama revolusi ujung tidak jatuh dari soket di bawah.  Blok photodetektor dan pemancar melekat pada braket di atas dan bawah disk, lebih khusus tentang desain mereka lebih lanjut. <br><br>  Seluruh struktur ditempatkan dalam wadah plastik (ABS atau polikarbonat) 150 Ã— 150 Ã— 90 mm.  Dirakit (tanpa penutup dan baling-baling cuaca), sensor arah adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/c34/85b/a61/c3485ba615b14aa3728b9e624c5f3b50.jpg" width="500" alt="gambar"><br><br>  Perhatikan bahwa arah yang dipilih ke utara ditandai dengan panah, itu perlu diperhatikan saat memasang sensor di tempat. <br><br>  Di bagian atas sumbu, baling-baling cuaca yang sebenarnya terpasang.  Itu dibuat atas dasar sumbu kuningan yang sama, ke dalam potongan di sisi tumpul di mana betis kuningan disolder.  Pada ujung yang tajam, benang M6 dipotong hingga panjang tertentu, dan beban penyeimbang bundar, dilemparkan dari timbal, dipasang di atasnya dengan bantuan mur: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/84c/f58/ebb/84cf58ebbc6312411db92a32a51b46d4.jpg" width="500" alt="gambar"><br><br>  Beban dirancang sedemikian rupa sehingga pusat gravitasi jatuh tepat di tempat pengikat (memindahkannya di sepanjang benang, Anda dapat mencapai keseimbangan sempurna).  Baling-baling dipasang ke sumbu menggunakan sekrup baja stainless M3, yang melewati lubang di poros baling-baling dan disekrup ke dalam ulir yang dipotong menjadi sumbu rotasi (sekrup pengunci terlihat pada foto di atas).  Untuk orientasi yang akurat, bagian atas sumbu rotasi memiliki reses setengah lingkaran di mana terletak sumbu baling-baling cuaca. <br><br><h3>  Sensor Kecepatan Angin DIY - Anemometer Piala DIY </h3><br>  Seperti yang sudah Anda pahami, dasar untuk sensor kecepatan untuk tujuan unifikasi dipilih sama seperti untuk baling-baling cuaca.  Tetapi persyaratan desain di sini agak berbeda: untuk mengurangi ambang awal, anemometer harus seringan mungkin.  Oleh karena itu, khususnya, sumbu untuk itu terbuat dari duralumin, piringan dengan lubang (untuk mengukur kecepatan) dikurangi diameternya: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f79/4eb/e72/f794ebe7245a7132970c1a27c04b5d0a.jpg" width="500" alt="gambar"><br><br>  Jika empat optocoupler diperlukan untuk enkoder Grey empat bit, maka hanya ada satu untuk sensor kecepatan.  16 lubang dibor di sekeliling lingkar cakram pada jarak yang sama, sehingga satu putaran cakram per detik setara dengan 16 hertz frekuensi yang berasal dari optocoupler (lebih banyak lubang yang mungkin, lebih sedikit yang mungkin - satu-satunya pertanyaan adalah skala konversi energi dan penghematan energi untuk penghasil emisi). <br><br>  Sensor buatan sendiri masih akan berubah menjadi agak kasar (ambang untuk memulai tidak kurang dari setengah meter per detik), tetapi hanya dapat dikurangi jika desainnya diubah secara radikal: misalnya, alih-alih cangkir putar, taruh baling-baling.  Dalam pemintal cangkir, perbedaan dalam kekuatan hambatan untuk mengalir, yang menentukan torsi, relatif kecil - itu dicapai semata-mata karena bentuk permukaan yang berbeda memenuhi aliran udara yang masuk (oleh karena itu, bentuk cangkir harus sedamping mungkin - idealnya ini adalah setengah telur atau bola).  Baling-baling memiliki torsi lebih besar, bobotnya bisa dibuat jauh lebih kecil, dan, akhirnya, pembuatannya sendiri lebih sederhana.  Tetapi baling-baling harus dipasang ke arah aliran udara - misalnya, dengan menempatkannya di <a href="">ujung baling-baling cuaca yang sama</a> . <br><br>  Pertanyaannya adalah: bagaimana cara mengirimkan bacaan dari sensor yang berputar secara acak di sekitar sumbu vertikal?  Saya tidak bisa menyelesaikannya, dan menilai dari fakta bahwa konstruksi piala profesional masih tersebar luas, itu sama sekali tidak diputuskan dari setengah tendangan (kami tidak memperhitungkan anemometer manual - mereka berorientasi sesuai dengan aliran udara secara manual). <br><br>  Versi anemometer gelas saya dibuat berdasarkan cakram laser.  Tampilan atas dan bawah ditunjukkan pada foto: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/86b/dfe/b7d/86bdfeb7d725ad1cacc76c48c7e99739.jpg" width="400" alt="gambar"><br><img src="https://habrastorage.org/getpro/geektimes/post_images/400/944/bf9/400944bf9dc46d666f49949f37fcf845.jpg" width="400" alt="gambar"><br><br>  Gelas terbuat dari dasar dari botol dari bawah air bayi Agusha.  Bagian bawahnya terpotong dengan hati-hati, dan ketiganya - pada jarak yang sama, sehingga mereka memiliki berat yang sama, secara lokal menghangat di bagian tengah (jangan memanaskan semuanya - itu akan melengkung tak tertahankan!) Dan bagian belakang gagang kayu membungkuk ke arah luar agar lebih ramping.  Anda akan mengulangi - persediaan pada botol yang lebih besar berisi lima atau enam potong, Anda mungkin dapat membuat tiga gelas lebih banyak atau kurang dari cangkir yang sama.  Dalam cangkir yang dibuat, potongan dibuat di samping dan mereka dipasang di sepanjang piringan pada 120 Â° sehubungan satu sama lain dengan bantuan seal-lem tahan air.  Disk secara ketat berpusat di sekitar sumbu (saya melakukan ini dengan bantuan mesin cuci logam bersarang) dan dipasang pada hub caprolon dengan sekrup M2. <br><br><h3>  Desain umum dan pemasangan sensor </h3><br>  Kedua sensor, sebagaimana telah disebutkan, ditempatkan dalam wadah plastik 150 Ã— 150 Ã— 90 mm.  Pilihan bahan kasing harus didekati dengan hati-hati: ABS atau polikarbonat memiliki ketahanan cuaca yang memadai, tetapi polistirena, plexiglass dan terutama polietilen tidak akan cocok di sini (dan akan sulit untuk mengecatnya agar terlindung dari matahari).  Jika tidak mungkin membeli kotak perusahaan, lebih baik menyolder kasing dari fiberglass foil dan kemudian cat untuk melindunginya dari korosi dan memberikan tampilan estetika. <br><br>  Lubang 8-10 mm dibuat di tutup tepat di titik keluar sumbu, ke mana kerucut plastik dipotong dari nosel dari kaleng semprotan dengan sealant konstruksi atau lem dilem dengan sealant perekat yang sama: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/a0d/b61/78c/a0db6178c5977c8a8a9081daa31c4753.jpg" width="400" alt="gambar"><br><br>  Untuk memusatkan kerucut di sepanjang sumbu, gunakan penjepit untuk memperbaiki sepotong kayu di bagian bawah penutup, tandai pusat tepat di atasnya dan pergi sedikit lebih dalam dengan bor bulu 12 mm, membuat reses annular di sekitar lubang.  Kerucut harus masuk ke sana persis, setelah itu dapat dilapisi dengan lem.  Selain itu dapat diperbaiki dalam posisi vertikal selama periode pemadatan dengan sekrup dan mur M6. <br><br>  Sensor kecepatan itu sendiri menutupi sumbu dengan kerucut ini, seperti payung, mencegah air memasuki tubuh.  Untuk baling-baling cuaca, perlu juga menempatkan selongsong di atas kerucut, yang akan menutup celah antara sumbu dan kerucut dari aliran air langsung (lihat foto pandangan umum sensor di bawah). <br><br>  Kabel dari optocoupler diarahkan ke konektor tipe D-SUB yang terpisah (lihat foto sensor arah di atas).  Rekan dengan kabel dimasukkan melalui lubang persegi panjang di dasar rumah.  Lubang kemudian ditutup oleh penutup dengan slot untuk kabel, yang membuat konektor tidak terjatuh.  Kurung duralumin dikencangkan ke dasar rumahan agar terpasang dengan benar.  Konfigurasi mereka tergantung pada lokasi sensor. <br><br>  Saat dipasang, kedua sensor terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/ac0/2ee/d02/ac02eed02599b4f62d7a959ecef6a136.jpg" width="500" alt="gambar"><br><br>  Di sini mereka ditampilkan sudah terpasang di tempat - di punggung gazebo.  Harap dicatat bahwa ceruk untuk sekrup yang menahan penutup terlindung dari air oleh sumbat karet mentah.  Sensor-sensor dipasang secara ketat di tingkat horizontal, di mana saya harus menggunakan lapisan dari potongan linoleum. <br><br><h2>  Bagian elektronik </h2><br>  Stasiun cuaca secara keseluruhan terdiri dari dua modul: unit jarak jauh (yang melayani kedua sensor angin, dan juga mengambil bacaan dari sensor suhu-kelembaban eksternal), dan modul utama dengan display.  Unit jarak jauh dilengkapi dengan pemancar nirkabel untuk mengirim data yang terpasang di dalamnya (antena menonjol keluar dari samping).  Modul utama menerima data dari unit jarak jauh (penerima, untuk kenyamanan orientasinya, ditempatkan pada kabel di unit terpisah), dan juga mengambil bacaan dari sensor suhu-kelembaban internal dan menampilkan semua ini pada monitor.  Komponen terpisah dari unit utama adalah jam dengan kalender, yang, untuk kenyamanan pengaturan umum stasiun, dilayani oleh pengontrol Arduino Mini yang terpisah dan memiliki display sendiri. <br><br><h3>  Modul jarak jauh dan sirkuit pengukur sensor angin </h3><br>  Sebagai pemancar foto, IR-LED AL-107B dipilih.  LED vintage ini, tentu saja, bukan yang terbaik di kelasnya, tetapi mereka memiliki casing mini dengan diameter 2,4 mm dan mampu mentransmisikan arus hingga 600 mA per pulsa.  Ngomong-ngomong, selama pengujian ternyata sampel LED ini sekitar tahun 1980 (dalam kasus merah) memiliki efisiensi kira-kira dua kali lipat (dinyatakan dalam kisaran operasi fotodetektor yang andal) daripada salinan modern yang dibeli di Chip-Dip (mereka memiliki transparan tubuh hijau kekuningan).  Tidak mungkin pada tahun 1980 kristal lebih baik dari sekarang, meskipun apa yang tidak bercanda?  Namun, ada kemungkinan bahwa masalahnya terletak pada sudut hamburan yang berbeda dalam satu dan desain lainnya. <br><br>  Arus konstan sekitar 20 mA (resistor 150 Ohm dengan catu daya 5 volt) dilewatkan melalui LED pada sensor kecepatan, dan arus berdenyut (berliku dengan siklus 2) arus sekitar 65 mA (150 Ohm yang sama dengan catu daya 12 volt) dilewatkan pada sensor arah.  Arus rata-rata melalui satu LED dari sensor arah dalam kasus ini adalah sekitar 33 mA, hanya dalam empat saluran - sekitar 130 mA. <br><br>  Sebagai fotodetektor, dipilih fototransistor L-32P3C dalam kasus dengan diameter 3 mm.  Sinyal diambil dari kolektor yang dimuat pada resistor 1,5 atau 2 kOhm dari suplai 5 V. Parameter ini dipilih sehingga pada jarak ~ 20 mm antara pemancar foto dan penerima, sinyal logika ukuran penuh pada level 5-volt segera tiba di input tanpa amplifikasi tambahan .  Arus yang muncul di sini mungkin tampak sangat besar bagi Anda, berdasarkan pada kebutuhan konsumsi energi minimum yang disebutkan di atas, tetapi seperti yang akan Anda lihat, mereka muncul dalam setiap siklus pengukuran selama maksimum beberapa milidetik sehingga total konsumsi tetap kecil. <br><br>  Dasar untuk memasang penerima dan penghasil emisi adalah segmen saluran kabel (terlihat pada foto sensor di atas), dipotong sehingga membentuk "telinga" untuk pemasangan pada braket di pangkalan.  Untuk masing-masing memo ini, piring plastik dilem pada tutup pengunci dari dalam, dengan lebar yang sama dengan lebar saluran.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED dan fototransistor diperbaiki pada jarak yang diperlukan dalam lubang yang dibor di pelat ini sehingga timah berada di dalam saluran, dan hanya tonjolan di ujung badan yang menonjol keluar. Kesimpulan disolder sesuai dengan diagram (lihat di bawah), kesimpulan eksternal dibuat oleh memo dari kawat multi-warna yang fleksibel. Resistor untuk pemancar sensor arah juga terletak di dalam saluran, satu kesimpulan umum dibuat dari mereka. Setelah pematrian, tutupnya terkunci pada tempatnya, semua slot disegel dengan plastisin dan pita perekat tambahan, yang juga menutup lubang di sisi yang berlawanan dengan terminal, dan seluruh struktur diisi dengan epoksi. Kesimpulan eksternal, seperti dapat dilihat pada foto sensor, ditampilkan pada blok terminal yang dipasang di bagian belakang braket. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagram sirkuit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit untuk memproses sensor angin terlihat seperti ini: </font></font><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/3ed/42e/3b7/3ed42e3b7ef2fee830c17786e991db52.png" width="1000" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang dari mana daya 12-14 volt berasal, lihat di bawah. Selain komponen yang ditunjukkan dalam diagram, unit jarak jauh berisi sensor suhu-kelembaban, yang tidak ditampilkan dalam diagram. Pembagi tegangan yang terhubung ke terminal A0 dari pengontrol dirancang untuk mengontrol tegangan catu daya untuk penggantian tepat waktu. LED yang terhubung ke terminal 13 tradisional (terminal 19 dari rumah DIP) super terang, karena cahaya normal dan tidak menyilaukan, cukup arus dalam sepersekian miliampere sudah cukup, yang disediakan oleh peringkat resistor tinggi 33 kOhm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema ini menggunakan Atmega328 controller "telanjang" dalam paket DIP, diprogram melalui Uno dan dipasang pada soket. Pengontrol seperti itu dengan loader Arduino yang sudah direkam, dijual, misalnya, dalam Chip-Dip (atau Anda dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merekam</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loader itu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">sendiri</font></a><font style="vertical-align: inherit;"> ). Pengontrol seperti itu mudah diprogram dalam lingkungan yang akrab, tetapi, tanpa komponen di papan, itu, pertama, lebih ekonomis, dan kedua, ini membutuhkan lebih sedikit ruang. Mode hemat energi penuh dapat diperoleh dengan menyingkirkan bootloader juga (dan umumnya mengecat semua kode di assembler :), tetapi di sini tidak terlalu relevan, dan pemrograman tidak perlu rumit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam diagram, persegi panjang abu-abu dilingkari di sekitar komponen yang terkait secara terpisah dengan saluran kecepatan dan arah. Pertimbangkan operasi sirkuit secara keseluruhan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengoperasian pengontrol secara keseluruhan dikendalikan oleh timer pengawas WDT, yang dihidupkan dalam mode panggilan interupsi. WDT membangunkan pengontrol dari mode tidur pada interval yang ditentukan. Jika timer mulai lagi di interupsi yang disebut, itu tidak memulai kembali dari awal, semua variabel global tetap pada nilainya. Ini memungkinkan Anda untuk mengakumulasikan data dari kebangkitan ke kebangkitan dan pada titik tertentu untuk memprosesnya - misalnya, rata-rata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awal program, deklarasi perpustakaan dan variabel global berikut dibuat (agar tidak mengacaukan teks dari contoh-contoh yang sudah luas, semua yang berhubungan dengan sensor suhu-kelembaban dirilis di sini):</font></font><br><br><pre><code class="plaintext hljs">#include &lt;VirtualWire.h&gt; #include &lt;avr/wdt.h&gt; #include &lt;avr/sleep.h&gt; . . . . . #define ledPin 13 //  (PB5  19 ATmega) #define IR_Pin 10 //  IRLU (PB2  16 Atmega) #define in_3p 9 //   3 #define in_2p 8 //   2 #define in_1p 7 //   1 #define in_0p 6 //   0 #define IR_PINF 5 //(PD5,11)   -  #define IN_PINF 4 //(PD4,6)    volatile unsigned long ttime = 0; //   float ff[4]; //      char msg[25]; //  byte count=0;// int batt[4]; //   byte wDir[4]; //   byte wind_Gray=0; //   </code> </pre> <br>  Prosedur berikut digunakan untuk memulai mode tidur dan WDT (bangun setiap 4 detik): <br><br><pre> <code class="plaintext hljs">//      void system_sleep() { ADCSRA &amp;= ~(1 &lt;&lt; ADEN); //. cbi(ADCSRA,ADEN);   set_sleep_mode(SLEEP_MODE_PWR_DOWN); //   sleep_mode(); //   sleep_disable(); //      watchdog ADCSRA |= (1 &lt;&lt; ADEN); /. sbi(ADCSRA,ADEN);   } //**************************************************************** // ii: 0=16ms, 1=32ms,2=64ms,3=128ms,4=250ms,5=500ms // 6=1 sec,7=2 sec, 8=4 sec, 9= 8sec void setup_watchdog(int ii) { byte bb; if (ii &gt; 9 ) ii=9; bb=ii &amp; 7; if (ii &gt; 7) bb|= (1&lt;&lt;5); // bb -   bb|= (1&lt;&lt;WDCE); MCUSR &amp;= ~(1&lt;&lt;WDRF); //   WDTCSR |= (1&lt;&lt;WDCE) | (1&lt;&lt;WDE); //      WDTCSR = bb; WDTCSR |= (1&lt;&lt;WDIE); // WDT } //**************************************************************** //     ISR(WDT_vect) { wdt_reset(); }</code> </pre><br>  Sensor kecepatan memberikan frekuensi gangguan pada saluran optik, urutan besarnya beberapa puluh hertz.  Mengukur nilai ini lebih ekonomis dan lebih cepat setelah periode (ini adalah subjek publikasi penulis " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penilaian metode untuk mengukur frekuensi rendah pada Arduino</a> ").  Di sini, metode ini dipilih melalui fungsi pulseInLong () yang dimodifikasi, yang tidak mengikat pengukuran ke output controller spesifik (teks dari fungsi periodInLong () dapat ditemukan dalam publikasi). <br><br>  Dalam fungsi setup (), arah output dideklarasikan, perpustakaan 433 MHz transmitter dan pengawas waktu diinisialisasi (garis untuk IN_PINF pada dasarnya berlebihan, dan dimasukkan untuk memori): <br><br><pre> <code class="plaintext hljs">void setup() { pinMode(IR_PINF, OUTPUT); //  pinMode(IN_PINF, INPUT); //     pinMode(13, OUTPUT); // vw_setup(1200); //   VirtualWire vw_set_tx_pin(2); //D2, PD2(4)   VirtualWire // Serial.begin(9600); // Serial-     setup_watchdog(8); //WDT  4 c wdt_reset(); }</code> </pre><br>  Akhirnya, dalam siklus utama program, kami pertama kali setiap kali kami bangun (setiap 4 detik) kami membaca voltase dan menghitung frekuensi sensor kecepatan angin: <br><br><pre> <code class="plaintext hljs">void loop() { wdt_reset(); //  digitalWrite(ledPin, HIGH); //    batt[count]=analogRead(0); //      /*===  ==== */ digitalWrite(IR_PINF, HIGH); // -   float f=0; //   ttime=periodInLong(IN_PINF, LOW, 250000); // 0,25  // Serial.println(ttime); //    if (ttime!=0) {//    f = 1000000/float(ttime);} //      digitalWrite(IR_PINF, LOW); // - ff[count]=f; //     . . . . .</code> </pre><br>  Waktu pembakaran LED IR (memakan, saya ingat, 20 mA) di sini, seperti yang Anda lihat, akan maksimum tanpa adanya rotasi disk sensor dan dalam kondisi ini akan menjadi sekitar 0,25 detik.  Frekuensi minimum yang diukur, dengan demikian, akan menjadi 4 Hz (seperempat revolusi disk per detik dengan 16 lubang).  Ternyata selama kalibrasi sensor (lihat di bawah), ini sesuai dengan sekitar 0,2 m / s kecepatan angin. Kami menekankan bahwa ini adalah nilai terkecil dari kecepatan angin, tetapi bukan resolusi dan bukan ambang batas untuk memulai (yang akan berubah menjadi jauh lebih tinggi).  Jika ada frekuensi (yaitu, ketika sensor berputar), waktu pengukuran (dan, karenanya, waktu pembakaran LED, yaitu konsumsi saat ini) akan dikurangi secara proporsional, dan resolusi akan meningkat. <br><br>  Berikut ini adalah prosedur yang dilakukan setiap kebangkitan keempat (mis. Setiap 16 detik).  Nilai frekuensi sensor kecepatan dari akumulasi empat nilai yang kami kirimkan bukan rata-rata, tetapi maksimum - seperti yang ditunjukkan oleh pengalaman, ini adalah nilai yang lebih informatif.  Untuk kenyamanan dan keseragaman, masing-masing nilai, terlepas dari jenisnya, dikonversi sebelum transmisi ke bilangan bulat positif dari 4 tempat desimal.  Variabel jumlah dimonitor oleh variabel jumlah: <br><br><pre> <code class="plaintext hljs">// 16        //  4- : if (count==3){ f=0; //  for (byte i=0; i&lt;4; i++) if (f&lt;ff[i]) f=ff[i]; //    int fi=(int(f*10)+1000); //  4 .    int volt=0; //  for (byte i=0; i&lt;4; i++) volt=volt+batt[i]; volt=volt/4+100; //   100  = 3 . volt=volt*10; // 4 .  . . . . .</code> </pre><br>  Berikutnya adalah definisi arah kode Gray.  Di sini, untuk mengurangi konsumsi, alih-alih terus-menerus pada LED IR, frekuensi 5 kHz dipasok ke keempat saluran secara bersamaan melalui transistor efek medan kunci menggunakan fungsi nada ().  Kehadiran frekuensi di masing-masing debit (in_0p - in_3p output) dideteksi menggunakan metode yang mirip dengan anti-bouncing ketika membaca pembacaan tombol yang ditekan.  Pertama, dalam siklus kita menunggu untuk melihat apakah ada tingkat tinggi pada output, dan kemudian memeriksanya setelah 100 Î¼s.  100 Î¼s adalah setengah periode frekuensi 5 kHz, yaitu, jika ada frekuensi dari setidaknya yang kedua kalinya, kita akan kembali jatuh ke level tinggi (untuk berjaga-jaga, ulangi empat kali) dan ini berarti sudah pasti ada.  Kami ulangi prosedur ini untuk masing-masing dari empat bit kode: <br><br><pre> <code class="plaintext hljs">/* ===== Wind Gray ==== */ //: tone(IR_Pin,5000);// 5    boolean yes = false; byte i=0; while(!yes){ // 3 i++; boolean state1 = (digitalRead(in_3p)&amp;HIGH); delayMicroseconds(100); //   100  yes=(state1 &amp; !digitalRead(in_3p)); if (i&gt;4) break; //   } if (yes) wDir[3]=1; else wDir[3]=0; yes = false; i=0; while(!yes){ // 2 i++; boolean state1 = (digitalRead(in_2p)&amp;HIGH); delayMicroseconds(100); //   100  yes=(state1 &amp; !digitalRead(in_2p)); if (i&gt;4) break; //   } if (yes) wDir[2]=1; else wDir[2]=0; yes = false; i=0; while(!yes){ // 1 i++; boolean state1 = (digitalRead(in_1p)&amp;HIGH); delayMicroseconds(100); //   100  yes=(state1 &amp; !digitalRead(in_1p)); if (i&gt;4) break; //   } if (yes) wDir[1]=1; else wDir[1]=0; yes = false; i=0; while(!yes){ // 0 i++; boolean state1 = (digitalRead(in_0p)&amp;HIGH); delayMicroseconds(100); //   100  yes=(state1 &amp; !digitalRead(in_0p)); if (i&gt;4) break; //   } if (yes) wDir[0]=1; else wDir[0]=0; noTone(IR_Pin); //  //     : wind_Gray=wDir[0]+wDir[1]*2+wDir[2]*4+wDir[3]*8; //   .  int wind_G=wind_Gray*10+1000; //  4- .  . . . . .</code> </pre><br>  Durasi maksimum dari satu prosedur adalah tidak adanya frekuensi pada penerima dan sama dengan 4 Ã— 100 = 400 mikrodetik.  Waktu pembakaran maksimum 4 arah LED adalah ketika tidak ada penerima yang menyala, mis. 4 Ã— 400 = 1,6 milidetik.  Algoritme, omong-omong, akan bekerja dengan cara yang persis sama, jika alih-alih frekuensi yang periodenya kelipatan 100 Î¼s, mudah untuk menerapkan level tinggi yang konstan ke LED.  Jika ada berliku-liku bukannya tingkat konstan, kita cukup menghemat makanan hingga setengahnya.  Kita masih dapat menyimpan jika kita memulai setiap IR LED melalui jalur yang terpisah (masing-masing, melalui output terpisah dari pengontrol dengan transistor kunci sendiri), tetapi pada saat yang sama sirkuit, kabel dan kontrol rumit, dan arusnya 130 mA selama 2 ms setiap 16 detik - ini, Anda tahu, sedikit. <br><br>  Akhirnya, <b>transfer data nirkabel</b> .  Untuk mentransfer data dari situs pemasangan sensor ke papan skor stasiun cuaca, dipilih metode yang paling sederhana, termurah, dan paling andal: <a href="">pasangan pemancar / penerima pada frekuensi 433 MHz</a> .  Saya setuju bahwa metode ini bukan yang paling nyaman (karena fakta bahwa perangkat dirancang untuk mentransmisikan urutan bit, bukan keseluruhan byte, Anda harus memperbaiki pikiran Anda tentang mengonversi data antara format yang diperlukan), dan saya yakin bahwa banyak orang akan ingin berdebat dengan saya dalam hal keandalannya.  Jawaban atas keberatan terakhir sederhana: "Anda tidak tahu cara memasaknya!" <br><br>  Rahasianya adalah bahwa ia biasanya tetap di belakang layar dari berbagai deskripsi pertukaran data pada saluran 433 MHz: karena perangkat ini murni analog, catu daya ke penerima harus dibersihkan dengan sangat baik dari setiap denyut asing.  Dalam hal apa pun Anda tidak perlu menyalakan receiver dari stabilisator Arduino 5 volt internal!  Memasang stabilizer berdaya rendah terpisah untuk penerima (LM2931, LM2950 atau serupa) langsung di sekitar terminalnya, dengan sirkuit penyaringan yang benar pada input dan output, secara radikal meningkatkan jangkauan dan keandalan transmisi. <br><br>  Dalam hal ini, pemancar bekerja langsung dari tegangan baterai 12 V, penerima dan pemancar dilengkapi dengan antena standar buatan rumah dalam bentuk sepotong kawat sepanjang 17 cm. (Saya ingat bahwa kabel untuk antena hanya cocok untuk satu-inti, dan perlu menempatkan antena di ruang yang sejajar satu sama lain.) Paket informasi 24-byte (memperhitungkan kelembaban dan suhu) tanpa masalah apa pun dengan percaya diri ditransmisikan pada kecepatan 1200 bit / s secara diagonal melalui plot kebun seluas 15 hektar (sekitar 40-50 meter), dan kemudian melalui tiga log  dinding di dalam ruangan (di mana, misalnya, sinyal seluler diterima dengan sangat sulit dan tidak di mana-mana).  Kondisi yang secara praktis tidak dapat dicapai untuk metode 2.4 GHz standar apa pun (seperti Bluetooth, Zig-Bee, dan bahkan amatir Wi-Fi), meskipun faktanya konsumsi pemancar di sini adalah 8 mA yang menyedihkan dan hanya pada saat transmisi aktual, sisa waktu pemancar yang dikonsumsi uang receh.  Pemancar ditempatkan secara struktural di dalam unit jarak jauh, antena menjulur keluar secara horizontal dari samping. <br><br>  Kami menggabungkan semua data dalam satu paket (di stasiun nyata, suhu dan kelembaban akan ditambahkan ke dalamnya), yang terdiri dari bagian 4-byte yang seragam dan didahului oleh tanda "DAT", mengirimkannya ke pemancar dan menyelesaikan semua siklus: <br><br><pre> <code class="plaintext hljs">/*=====Transmitter=====*/ String strMsg="DAT"; // -  strMsg+=volt; //  4  strMsg+=wind_G; // wind 4  strMsg+=fi; //  4  strMsg.toCharArray(msg,16); //    // Serial.println(msg); //  vw_send((uint8_t *)msg, strlen(msg)); //   vw_wait_tx(); //    - ! delay(50); //+      count=0; //  }//end count==3 else count++; digitalWrite(ledPin, LOW); //   system_sleep(); // â€”   } //end loop</code> </pre><br>  Ukuran paket dapat dikurangi jika Anda menolak persyaratan untuk menyajikan masing-masing nilai dari berbagai jenis dalam bentuk kode 4-byte yang seragam (misalnya, untuk kode Gray, tentu saja, satu byte sudah cukup).  Tetapi demi universalisasi, saya meninggalkan semuanya apa adanya. <br><br>  <b>Fitur nutrisi dan desain unit jarak jauh</b> .  Konsumsi unit jarak jauh dihitung dengan cara ini: <br><br>  - 20 mA (emitor) + ~ 20 mA (pengontrol dengan sirkuit bantu) selama kurang lebih 0,25 detik setiap empat detik - rata-rata 40/16 = 2,5 mA; <br>  - 130 mA (emitor) + ~ 20 mA (pengontrol dengan sirkuit bantu) selama sekitar 2 ms setiap 16 detik - rata-rata 150/16/50 â‰ˆ 0,2 mA; <br><br>  Setelah melakukan perhitungan ini, konsumsi pengontrol saat mengambil data dari sensor suhu-kelembaban dan ketika pemancar bekerja, kita dapat dengan aman membawa konsumsi rata-rata menjadi 4 mA (di puncak sekitar 150 mA, ingat!).  Baterai (yang, secara kebetulan, akan membutuhkan sebanyak 8 buah untuk menyediakan pemancar dengan tegangan maksimum!) Harus sering diganti, jadi idenya adalah memberi daya unit jarak jauh dari baterai 12 volt untuk obeng - Saya hanya punya dua yang ekstra.  Kapasitasnya bahkan lebih sedikit dari jumlah baterai AA yang sesuai - hanya 1,3 jam, tetapi tidak ada yang mau mengubahnya kapan saja, tetap siap dengan baterai kedua.  Dengan konsumsi yang ditunjukkan 4 mA, kapasitas 1300 mA â€¢ jam sudah cukup untuk sekitar dua minggu, yang tidak terlalu merepotkan. <br><br>  Perhatikan bahwa tegangan baterai yang baru diisi bisa mencapai 14 volt.  Penstabil input 12 volt dipasang dalam kasus ini - untuk mencegah tegangan lebih dari catu daya pemancar dan tidak membebani penstabil lima volt utama. <br><br>  Unit portabel dalam wadah plastik yang sesuai terletak di bawah atap, kabel daya dari baterai dan koneksi ke sensor angin terhubung ke sana pada konektor.  Kesulitan utama adalah bahwa rangkaian itu ternyata sangat sensitif terhadap kelembaban udara: dalam cuaca hujan, setelah beberapa jam pemancar mulai gagal, pengukuran frekuensi menunjukkan kekacauan total, dan pengukuran tegangan baterai menunjukkan "cuaca di Mars". <br><br>  Karena itu, setelah men-debug algoritma dan memeriksa semua koneksi, kasing harus disegel dengan hati-hati.  Semua konektor di pintu masuk rumah disegel dengan sealant, hal yang sama berlaku untuk semua kepala sekrup mencuat, output antena dan kabel daya.  Sendi tubuh diolesi dengan plastisin (dengan mempertimbangkan bahwa mereka harus dipisahkan), dan tambahan dilem di atas dengan strip plumbing tape.  Sangat menyenangkan juga memperkuat konektor yang digunakan di dalam dengan epoksi: misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DB-15 yang</a> ditunjukkan pada diagram modul jarak jauh tidak kencang, dan udara lembab perlahan-lahan akan bocor di antara kerangka logam dan dasar plastik. <br><br>  Tetapi semua langkah ini dalam dirinya sendiri hanya akan memberikan efek jangka pendek - bahkan jika tidak ada hisapan udara lembab dingin, maka udara kering dari ruangan dengan mudah berubah menjadi udara lembab ketika suhu di luar perumahan turun (ingat fenomena yang disebut "titik embun"). <br><br>  Untuk menghindari hal ini, Anda perlu meninggalkan kartrij atau tas dengan desiccant - silica gel di dalam case (kantong yang terkadang dimasukkan ke dalam kotak dengan sepatu atau dalam beberapa paket dengan perangkat elektronik).  Jika silika gel asal tidak diketahui telah disimpan untuk waktu yang lama, harus dikalsinasi sebelum digunakan dalam oven listrik pada 140-150 derajat selama beberapa jam.  Jika kasing disegel dengan benar, maka desikan harus diganti tidak lebih sering daripada pada awal setiap musim panas. <br><br><h3>  Modul utama </h3><br>  Dalam modul utama, semua nilai diterima, didekripsi, jika perlu, dikonversi sesuai dengan persamaan kalibrasi dan ditampilkan. <br><br>  Penerima ditempatkan di luar modul utama stasiun dan ditempatkan di sebuah kotak kecil dengan telinga untuk pemasangan.  Antena dibawa keluar melalui lubang di sampul, semua lubang di rumah ditutup dengan karet mentah.  Kontak penerima terhubung ke konektor domestik tipe RS-4 yang sangat andal, di sisi penerima terhubung melalui sepotong kabel AV berpelindung ganda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/ffc/abe/5daffcabee184faa792d98fffea4abb7.jpg" width="500" alt="gambar"><br><br>  Sebuah sinyal diambil di sepanjang salah satu inti kabel, dan di sisi lain, daya disuplai dalam bentuk mentah 9 volt dari adaptor daya modul.  Stabilizer tipe LM-2950-5.0 bersama-sama dengan kapasitor penyaringan dipasang dalam sebuah kotak dengan penerima pada syal terpisah. <br><br>  Eksperimen dilakukan untuk menambah panjang kabel (untuk berjaga-jaga, tiba-tiba, itu tidak akan bekerja melalui dinding?), Di mana ternyata tidak ada yang berubah dalam panjang hingga 6 meter. <br><br>  Hanya ada empat tampilan OLED: dua data cuaca servis kuning, dua jam hijau, dan kalender.  Penempatan mereka ditampilkan di foto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccb/ff2/095/ccbff20958163b5865beb85f9a2bcf0f.jpg" width="500" alt="gambar"><br><br>  Harap dicatat bahwa di setiap grup salah satu tampilan adalah teks, yang kedua adalah grafik, dengan font yang dibuat secara artifisial dalam bentuk gambar mesin terbang.  Di sini kita tidak akan membahas masalah menampilkan informasi pada tampilan agar tidak mengembang teks artikel dan contoh-contoh yang sudah luas: karena adanya gambar mesin terbang yang harus ditampilkan secara individual (seringkali dengan hanya daftar opsi menggunakan operator kasus), program output mungkin sangat besar.  Untuk informasi tentang cara menangani tampilan seperti itu, lihat publikasi penulis, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mode Grafik dan Teks Menampilkan Winstar,</a> " yang mencakup contoh tampilan untuk menghasilkan data angin. <br><br>  <b>Diagram sirkuit.</b>  Jam dan tampilannya diservis oleh pengontrol Arduino Mini terpisah untuk kemudahan pengaturan dan kami tidak akan membongkar lagi di sini.  Diagram koneksi komponen ke Arduino Nano, yang mengontrol penerimaan dan keluaran data cuaca, adalah sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c6/0c2/49d/6c60c249dfa514a332194b8c5cc10e95.png" width="1000" alt="gambar"><br><br>  Di sini, tidak seperti modul jarak jauh, koneksi sensor cuaca - barometer dan sensor suhu-kelembaban internal ditampilkan.  Perhatikan kabel daya - display didukung oleh 5 V stabilizer tipe LM1085 yang terpisah.  Itu wajar untuk menyalakan jam menampilkan dari itu, namun, dalam hal ini, pengontrol jam juga harus didukung oleh tegangan yang sama, dan melalui output 5 V, bukan Vin (untuk Mini Pro yang terakhir disebut RAW).  Jika Anda menyalakan pengontrol arloji dengan cara yang sama seperti Nano - 9 volt melalui pin RAW, maka penstabil internal akan bertentangan dengan 5 volt eksternal dan, tentu saja, yang terkuat akan menang dalam pertarungan ini, yaitu, LM1085, dan Mini akan dibiarkan sepenuhnya tanpa daya.  Juga, untuk menghindari segala macam masalah, sebelum memprogram Nano dan terutama Mini (yaitu, sebelum menghubungkan kabel USB), adaptor eksternal harus diputuskan. <br><br>  Pada stabilizer LM1085, ketika keempat monitor terhubung, daya akan dialokasikan sekitar satu watt, oleh karena itu harus dipasang pada radiator kecil sekitar 5-10 cm2 dari sudut aluminium atau tembaga. <br><br>  Penerimaan dan pemrosesan data.  Di sini saya mereproduksi dan mengomentari hanya fragmen program yang terkait dengan data angin, beberapa kata tentang sensor lain di bawah ini. <br><br>  Untuk menerima pesan pada saluran 433 MHz, metode standar yang dijelaskan dalam banyak sumber berlaku.  Kami menghubungkan perpustakaan dan mendeklarasikan variabel: <br><br><pre> <code class="plaintext hljs">#include &lt;VirtualWire.h&gt; . . . . . int volt; //      float batt; //  â€”   byte wDir; //    uint16_t t_time = 0; //   char str[5]; //   uint8_t buf[VW_MAX_MESSAGE_LEN]; //    uint8_t buflen = VW_MAX_MESSAGE_LEN; // max    . . . . .</code> </pre><br>  Satu kekhasan terkait dengan ukuran buffer buflen: menyatakan nilainya (VW_MAX_MESSAGE_LEN) satu kali pada awal program tidak cukup.  Karena variabel ini muncul dengan referensi dalam fungsi terima (lihat di bawah), ukuran pesan default harus diperbarui setiap siklus.  Jika tidak, karena penerimaan pesan yang rusak, nilai buflen akan dipersingkat setiap kali sampai Anda mulai mendapatkan semua jenis omong kosong alih-alih data.  Dalam contoh-contoh, kedua variabel ini biasanya dideklarasikan secara lokal dalam siklus loop (), karena ukuran buffer diperbarui secara otomatis, dan di sini kita hanya akan mengulangi penetapan nilai yang diinginkan pada awal setiap siklus. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam prosedur pengaturan, buat pengaturan berikut: </font></font><br><br><pre> <code class="plaintext hljs">void setup() { delay (500); //    pinMode(16,INPUT_PULLUP); //   vw_setup(1200); //   VirtualWire vw_set_rx_pin(17); //A3   VirtualWire . . . . .</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum mengambil apa pun, interval waktu t_time berlalu dari penerimaan terakhir diperiksa. </font><font style="vertical-align: inherit;">Jika telah melampaui batas wajar (misalnya, 48 detik - tiga kali waktu coba lagi pesan dari unit eksternal), maka ini dianggap sebagai kehilangan sensor dan entah bagaimana ditampilkan pada layar:</font></font><br><br><pre> <code class="plaintext hljs">void loop() { vw_rx_start(); //   buflen = VW_MAX_MESSAGE_LEN; //     if ((int(millis()) - t_time) &gt; 48000) // t_time    48  { &lt;   &gt; }//end    if (vw_have_message()) { //  if (vw_get_message(buf, &amp;buflen)) //    { vw_rx_stop(); //    t_time = millis(); // t_time for (byte i=0;i&lt;3;i++) //     str[i]= buf[i]; str[3]='\0'; if((str[0]=='D')&amp;&amp;(str[1]=='A')&amp;&amp;(str[2]=='T')) { //  // : for (byte i=3;i&lt;7;i++) //     str[i-11]= buf[i]; //     volt=atoi(str); //    volt=(volt/10)-100; //   4-  batt=float(volt)/55.5; //       //      for (byte i=7;i&lt;11;i++) //     str[i-15]= buf[i]; //     int w_Dir=atoi(str); //    w_Dir=(w_Dir-1000)/10; //    wDir=lowByte(w_Dir); //  -   &lt;      case&gt; . . . . .</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koefisien 55,5 - konversi nilai kode ADC menjadi tegangan nyata, nilainya tergantung pada tegangan referensi dan nilai resistor pembagi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, kode Gray memiliki satu fitur: urutan bit tidak penting di dalamnya, kode menyimpan semua propertinya ketika disusun ulang. Dan karena ketika mendekripsi, kami masih mempertimbangkan setiap kasus secara terpisah, bit dapat dilihat dalam urutan apa pun dan bahkan bingung ketika terhubung. Ini masalah lain jika Anda ingin menyelesaikan masalah ini entah bagaimana - misalnya, buat array nilai arah ("s", "ssz", "sz", "ssz", "z", dll.), Dan bukannya pertimbangan individu setiap opsi untuk mengekstraksi penunjukan dengan angka dalam array ini. Maka akan diperlukan untuk mengubah kode Gray menjadi biner terurut, dan urutan bit akan memainkan peran penting.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan akhirnya, kami mengekstrak nilai kecepatan dan menutup semua operator: </font></font><br><br><pre> <code class="plaintext hljs">. . . . . for (byte i=19;i&lt;23;i++) //     str[i-19]= buf[i]; //     int wFrq=atoi(str); //    wFrq = (wFrq-1000)/10; //   4-  wFrq=10+0.5*wFrq;//      &lt;    &gt; }//end if str=DAT }//end vw_get_message } //end vw_have_message(); . . . . .</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini 10 + 0,5 * wFrq adalah persamaan ukur. </font><font style="vertical-align: inherit;">10 dm / s (yaitu, 1,0 meter per detik) adalah ambang untuk memulai, dan 0,5 adalah koefisien untuk mengubah frekuensi menjadi kecepatan (dalam dm / s). </font><font style="vertical-align: inherit;">Dengan nilai nol dari frekuensi input, persamaan ini memberikan 10 dm / s, oleh karena itu perawatan harus dilakukan secara terpisah sehingga tidak 1 m / s, tetapi nilai nol. </font><font style="vertical-align: inherit;">Anda dapat mengkalibrasi sensor kecepatan menggunakan anemometer genggam dan kipas desktop termurah. </font><font style="vertical-align: inherit;">Jangan mencoba menentukan ambang awal secara eksperimental - itu akan jauh lebih akurat jika dua atau tiga titik nilai kalibrasi langsung dari kecepatan V versus frekuensi F dicatat: V = V + K Ã— F pada laju aliran yang berbeda, maka ambang awal ditentukan secara otomatis sebagai nilai V (titik ordinat) persimpangan garis ini dengan sumbu kecepatan).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum Anda menutup loop utama, Anda perlu melakukan satu hal lagi. Kami memiliki tegangan baterai, tetapi Anda tidak perlu menampilkannya sepanjang waktu - cukup gunakan ruang. Untuk melakukan ini, kita memerlukan tombol Kn1 - dengan mengkliknya, kita sementara (sampai pembaruan data berikutnya) mengganti garis suhu-kelembaban eksternal dengan nilai tegangan:</font></font><br><br><pre> <code class="plaintext hljs">. . . . . if (digitalRead(16)==LOW){ //  &lt;   ,   -&gt; }//  delay(500); }// loop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memiliki tombol, seperti dapat dilihat dari rangkaian, dengan kontak penggantian, tetapi tidak ada yang mencegah memasang yang biasa dengan kontak penutup, menghubungkannya ke catu daya melalui resistor. Anda juga dapat menambahkan ini simbol berkedip pada tampilan jika tegangan baterai turun di bawah, misalnya, 10 volt, sebagai tanda bahwa sudah waktunya untuk mengubahnya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulannya tentang sensor cuaca. </font></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHT-75 digunakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai sensor eksternal </font><font style="vertical-align: inherit;">- satu-satunya sensor amatir yang saya temukan yang tidak memerlukan kalibrasi dan menunjukkan nilai nyata baik suhu dan kelembaban langsung "di luar kotak" (karenanya harganya tinggi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perpustakaan untuk menghubungkannya dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHT-75 dirancang agak bodoh: substrat logam papan melakukan panas dengan sangat baik, oleh karena itu harus sepenuhnya dilepas di luar kasing. Jika tidak, keberadaan hanya satu pengontrol tipe ATmega328 dengan pengatur daya dalam wadah tertutup sudah cukup untuk memanaskan sensor melalui substrat dengan beberapa derajat bahkan jika kepalanya dikeluarkan. Skema saya dengan sensor angin, dengan arus 20-130 mA (bahkan arus milidetik yang tidak signifikan) memanaskan SHT-75 derajat dengan lima, sehingga dibawa keluar dan dipasang secara terpisah di piring plastik yang menonjol dari kasing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data dari SHT-75 diambil oleh pengontrol yang sama dengan data dari sensor angin dan dikirim dari modul jarak jauh dalam satu paket melalui saluran nirkabel 433 MHz. Untuk transmisi, mereka juga awalnya dikonversi ke format string 4-byte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengukur suhu dan kelembaban di dalam ruangan, dangkal DHT-22 dipilih - karena jangkauannya kecil dibandingkan dengan jalan, tidak ada perbedaan sensor yang digunakan (kecuali, tentu saja, DHT-11, yang tidak boleh digunakan sama sekali dalam situasi apa pun, di ini sama sekali tidak berfungsi). Suhu DHT-22 dikoreksi dengan pengukuran dengan termometer air raksa (mereka benar-benar bertepatan dengan SHT-75!), Dan kelembabannya sedikit diratakan dibandingkan dengan SHT-75. Koreksi dimasukkan segera sebelum tampilan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, DHT-22 juga perlu diambil dari kasing dengan pajangan - jika tidak maka akan memanas dan berbohong. Saya memperbaikinya pada dudukan plastik di bagian bawah kasing, pada jarak sepuluh milimeter dari itu. Omong-omong, keadaan ini, seperti yang saya duga, adalah salah satu alasan (kecuali karena kurangnya kalibrasi individu) bahwa semua stasiun cuaca bermerek bermerek RST dan Oregon tanpa malu-malu terbaring dalam kesaksian, bahkan memiliki penyebaran diri sendiri (sensor internal dengan sensor eksternal) dua hingga tiga derajat. dan kelembaban hingga sepuluh persen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barometer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini tidak menimbulkan masalah, karena hampir semua produk yang tersedia secara komersial dibuat atas dasar yang sama - chip microelectromechanical (MEMS) BMP180 atau modifikasinya. Pengalaman pribadi saya mencoba menggunakan varian yang lebih jarang berdasarkan LPS331AP adalah negatif: lebih sulit untuk menemukan perpustakaan untuk itu, dan to top it off, konflik ditemukan dengan perangkat lain di bus I2C. Pembacaan barometer mungkin perlu disesuaikan di lokasi pemasangan - setiap 10-12 meter di atas permukaan laut mengurangi tekanan sebesar 1 mm Hg. Seni Oleh karena itu, nilai tertentu harus dikurangi (atau ditambahkan) dari pembacaan sehingga tekanan sesuai dengan pembacaan stasiun cuaca resmi di daerah tersebut.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak membawa semua program stasiun cuaca sepenuhnya - mereka agak besar, dan Anda masih tidak akan dapat mengulangi konstruksi satu-ke-satu. </font><font style="vertical-align: inherit;">Jika ada, ketuk PM. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD dari 06/30/17. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daya terpasang dari panel surya. </font><font style="vertical-align: inherit;">Kit dari sini: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">pengontrol </font></a></font><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panel surya</font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baterai</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya + pengiriman di Moskow dalam 2,5 tyr. </font><font style="vertical-align: inherit;">Ini bekerja dengan sempurna. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknik yang menarik untuk menghitung kekuatan baterai surya dan baterai, yang ditawarkan oleh konsultan dari situs ini. </font><font style="vertical-align: inherit;">Contoh perhitungan konsumsi daya 3 W (saya punya lebih sedikit), saya kutip: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"3W dikalikan 24jam dan dibagi 6 = 12Ah ini adalah kapasitas baterai minimum </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3W dikalikan 24jam dan dibagi 3j = 24W ini adalah daya minimum baterai surya"</font></font><br>  Tidak ada komentar <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus saya, daya yang dihasilkan dari pembangkit listrik tenaga surya sepuluh kali lebih tinggi dari yang diperlukan dalam kondisi cuaca terburuk. Oleh karena itu, dalam pengontrol sensor, Anda tidak dapat terlalu khawatir tentang penghematan energi, dan menerapkan frekuensi yang diperlukan untuk mengambil bacaan dan nilai rata-rata. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD dari 09/13/18.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selama hampir dua musim operasi, kekuatan dan kelemahan stasiun terungkap. Lemah - pertama-tama, siklus pembaruan pembacaan 16 detik (dari empat seri pengukuran), seperti yang awalnya, terlalu lama. Memasang baterai surya dengan baterai penyangga memungkinkan kami untuk tidak memikirkan penghematan energi dan bermain dengan waktu siklus. Akibatnya, siklus diatur ke 8 detik (empat pengukuran dalam dua detik).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari peningkatan mekanis, bantalan dorong yang kuat diperkenalkan di bawah ujung sensor kecepatan (ya, saya telah diperingatkan tentang perlunya saat itu, tetapi saya tidak tahu bagaimana membuatnya saat itu). Setelah beberapa waktu, sumbu sensor sepenuhnya memotong dukungan fluoroplastik dan ambang awal meningkat tajam (omong-omong, ini tidak mempengaruhi sensitivitas baling-baling cuaca). Oleh karena itu, dukungan digantikan oleh bantalan dorong stainless steel, di mana reses kecil dibuat dengan bor tipis. Saya memperkirakan bahwa kemudian saya harus datang dengan sesuatu yang lain dengan titik, yang, seperti seluruh sumbu, terbuat dari duralumin. Tapi saya menunda sampai sensor masih harus diperbaiki: disk laser, yang diambil sebagai dasar desain, menjadi keruh dari matahari selama dua musim dan mulai retak. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD dari 06/05/19.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang perubahan sensor (baling-baling cuaca kiri yang sama). Sensor kecepatan harus diperbaiki baik karena sumbu usang dan karena disk laser yang tidak dapat digunakan. Basis desain dibiarkan sama, tetapi disc laser baru dicat dengan cat semprot emas. Solusi untuk ujung sumbu ditemukan dalam bentuk berikut. Sebuah reses dibor tepat di sumbu dural tepat di tengah, dan trim bagian atas keran Cina sebesar 3 mm dimasukkan pada lem kedua di sana. Ujung keran adalah kerucut berpusat baik dengan sudut sekitar 70-80 derajat. Selain itu dipoles dengan kulit nol dan kemudian pasta GOI. Sebagai dasarnya, saya menggunakan kepala sekrup M3 stainless dengan slot gergaji, di mana reses tengah kecil ditandai dengan bor konvensional D = 2 mm. Sekrup ini disekrup langsung ke ceruk di dalam fluoroplastik,digergaji dengan sumbu lebih awal dari perataan disediakan.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ujung sumbu dilumasi dengan minyak grafit untuk melindunginya dari korosi (karena sifat stainless dari keran tidak diketahui oleh saya). </font><font style="vertical-align: inherit;">Setelah beberapa penggilingan, ambang awal menurun sangat banyak sehingga menjadi tidak mungkin untuk diukur dengan anemometer bermerek, di mana ambangnya sekitar 0,3-0,5 cm / s. </font><font style="vertical-align: inherit;">Menurut data tidak langsung (dengan membangun garis lurus pada dua titik), ambang 0,3 m / s diadopsi secara sukarela, meskipun kemungkinan akan sedikit kurang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan utama dalam algoritma perhitungan juga menyangkut sensor angin, dan saya merasa berguna untuk menempatkan ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel terpisah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id404385/">https://habr.com/ru/post/id404385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id404375/index.html">Berita kuantum dari IBM: dua prosesor kuat dari tipe baru diluncurkan</a></li>
<li><a href="../id404377/index.html">Dunia "Internet of Russia" Rusia: T-band, Element, X-turion, FlipFlic dan banyak lagi</a></li>
<li><a href="../id404379/index.html">Kami mencari pembicara di DIY-mitap 1 Juli</a></li>
<li><a href="../id404381/index.html">Video 3D DIY</a></li>
<li><a href="../id404383/index.html">Formlabs memperkenalkan Fuse 1, Top 3D Shop menemukan pemenang</a></li>
<li><a href="../id404387/index.html">Dia mengambil wawancara video dari Wakil Presiden Arduino dan berdiskusi dengan dia mengajar anak sekolah FPGA / FPGA dan Verilog</a></li>
<li><a href="../id404389/index.html">Atmotube Atmosphere Tube - Sensor Kualitas Udara Portabel</a></li>
<li><a href="../id404391/index.html">Printer level 80. Epson WorkForce Enterprise</a></li>
<li><a href="../id404393/index.html">Bobby Compact - ransel anti-pencurian generasi baru</a></li>
<li><a href="../id404395/index.html">Kisah-kisah seputar mesin SCUMM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>