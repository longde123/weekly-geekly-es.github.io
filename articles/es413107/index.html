<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≠ üçñ ü•ã Traducci√≥n del wiki del proyecto Svelto.ECS. Marco ECS para Unity3D ‚õΩÔ∏è üë©‚Äçüë©‚Äçüëß ‚òùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tabla de contenidos  CONTENIDO 


1. Introduccion 
2. Ra√≠z de composici√≥n y ra√≠z de motores 
3. Entidades 
4. Motores 
5. Representaciones de entidade...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traducci√≥n del wiki del proyecto Svelto.ECS. Marco ECS para Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413107/"><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><h2>  CONTENIDO </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ra√≠z de composici√≥n y ra√≠z de motores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entidades</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Motores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Representaciones de entidades</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Componentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descriptores de entidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Imitadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n de entidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comunicaci√≥n en Svelto.ECS</a> </li></ol><br></div></div><br>  Hola Habr!  Os presento la traducci√≥n de la wiki del proyecto <a href="">Svelto.ECS</a> escrita por Sebastiano Mandal√†. <br><br>  Svelto.ECS es el resultado de muchos a√±os de investigaci√≥n y aplicaci√≥n de principios SOLIDOS en el desarrollo de juegos en Unity.  Esta es una de las muchas implementaciones del patr√≥n ECS disponible para C # con varias caracter√≠sticas √∫nicas introducidas para abordar las deficiencias del patr√≥n en s√≠. <a name="habracut"></a><br><br><h2>  Primer vistazo </h2><br>  La forma m√°s f√°cil de ver las caracter√≠sticas b√°sicas de Svelto.ECS es descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vanilla Example</a> .  Si desea asegurarse de que sea f√°cil de usar, le mostrar√© un ejemplo: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  void ApplicationCompositionRoot() { var simpleSubmissionEntityViewScheduler = new SimpleSubmissionEntityViewScheduler(); _enginesRoot = new EnginesRoot(simpleSubmissionEntityViewScheduler); var entityFactory = _enginesRoot.GenerateEntityFactory(); var entityFunctions = _enginesRoot.GenerateEntityFunctions(); _enginesRoot.AddEngine(new BehaviourForSimpleEntityEngine(entityFunctions)); entityFactory.BuildEntity&lt;SimpleEntityDescriptor&gt;(new EGID(1), new[] { new SimpleImplementor() });` } //  class SimpleEntityDescriptor : GenericEntityDescriptor&lt;BehaviourEntityViewForSimpleEntity&gt; { } public class BehaviourEntityViewForSimpleEntity : EntityView { public ISimpleComponent simpleComponent; } public interface ISimpleComponent { public int counter {get; set;} } class SimpleImplementor : ISimpleComponent { public int counter { get; set; } } //  ()    public class BehaviourForSimpleEntityAsStructEngine : IQueryingEntityViewEngine { public IEntityViewsDB entityViewsDB { private get; set; } public void Ready() { Update().Run(); } //   . //    N ,  N    0  1. IEnumerator Update() { Console.Log("Task Waiting"); while (true) { var entityViews = entityViewsDB .QueryGroupedEntityViews&lt;BehaviourEntityViewForSimpleEntity&gt;(0); if (entityViews.Length&gt; 0) { for (var i = 0; i &lt; entityViews.Length; i++) AddOne(entityViews[i].counter); Console.Log("Task Done"); yield break; } yield return null; } } static void AddOne(int counter) { counter += 1; } }</span></span></code> </pre> <br>  Desafortunadamente, no es posible comprender r√°pidamente la teor√≠a detr√°s de este c√≥digo, que puede parecer simple pero confuso al mismo tiempo.  Para comprender esto, debe dedicar tiempo a leer el "muro de texto" y probar los ejemplos anteriores. <br><a name="Introduction"></a><br><h2>  Introduccion </h2><br>  Recientemente, he estado discutiendo <b>mucho</b> sobre <b>Svelto.ECS</b> con varios programadores m√°s o menos experimentados.  Recopil√© muchos comentarios e hice muchas notas que usar√© como punto de partida para mis pr√≥ximos art√≠culos, donde hablar√© m√°s sobre teor√≠a y buenas pr√°cticas.  Un peque√±o spoiler: me di cuenta de que cuando comienzas a usar Svelto.ECS, el mayor obst√°culo es <b>cambiar el paradigma de programaci√≥n</b> .  Es sorprendente cu√°nto tengo que escribir para explicar los nuevos conceptos introducidos por Svelto.ECS, en comparaci√≥n con la peque√±a cantidad de c√≥digo escrito para desarrollar el marco.  De hecho, si bien el marco en s√≠ es muy simple y liviano, la transici√≥n de OOP con el uso activo de la herencia o los componentes habituales de Unity al "nuevo" dise√±o modular y de acoplamiento flexible que Svelto.ECS ofrece para usar evita que las personas se adapten al marco. <br><br>  Svelto.ECS se utiliza activamente en <b>Freejam</b> (nota del traductor: el autor es el director t√©cnico de esta empresa).  Como siempre puedo explicar a mis colegas los conceptos b√°sicos del marco, les lleva menos tiempo entender c√≥mo trabajar con √©l.  Aunque Svelto.ECS es lo m√°s duro posible, los malos h√°bitos son dif√≠ciles de superar, por lo que los usuarios tienden a abusar de cierta flexibilidad que les permite adaptar el marco a los paradigmas "antiguos" con los que se sienten c√≥modos.  Esto puede conducir al desastre debido a malentendidos o distorsiones de los conceptos que subyacen a la l√≥gica del marco.  Es por eso que tengo la intenci√≥n de escribir tantos art√≠culos como sea posible, especialmente porque estoy seguro de que el paradigma ECS es la mejor soluci√≥n en este momento para escribir c√≥digo efectivo y mantenible para grandes proyectos que cambian y vuelven a funcionar muchas veces durante varios a√±os.  <b>Robocraft</b> y <b>Cardlife</b> son prueba de esto. <br><br>  No voy a hablar mucho sobre las teor√≠as que subyacen a este art√≠culo.  Solo le recordar√© por qu√© me negu√© a usar el <b>contenedor IoC</b> y comenc√© a usar exclusivamente el marco ECS: el contenedor IoC es una herramienta muy peligrosa si se usa sin comprender la esencia misma de la inversi√≥n de control.  Como puede ver en mis art√≠culos anteriores, distingo entre la inversi√≥n del control de creaci√≥n (Inversi√≥n del control de creaci√≥n) y la inversi√≥n del control de flujo (Inversi√≥n del control de flujo).  Invertir el control de flujo es como el principio de Hollywood: "No nos llame, lo llamaremos".  Esto significa que las dependencias inyectadas nunca deben usarse directamente a trav√©s de m√©todos p√∫blicos, ya que al hacerlo simplemente usa el contenedor IoC como sustituto de cualquier otra forma de inyecci√≥n global, como singleton.  Sin embargo, si el contenedor de IoC se usa sobre la base de la Inversi√≥n de la Administraci√≥n (IoC), b√°sicamente todo se reduce a reutilizar el patr√≥n "M√©todo de plantilla" para implementar gerentes que se usan solo para registrar los objetos que administran.  En el contexto real de las inversiones de control de flujo, los gerentes siempre son responsables de administrar las entidades.  ¬øEsto parece un patr√≥n de ECS?  Por supuesto  Basado en este razonamiento, tom√© el patr√≥n ECS y desarroll√© un marco r√≠gido basado en √©l, y su uso equivale a aplicar el nuevo paradigma de programaci√≥n. <br><a name="Composition_Root"></a><br><h2>  Composici√≥n Ra√≠z y Motores Ra√≠z </h2><br>  La clase principal es la ra√≠z de composici√≥n de la aplicaci√≥n.  La ra√≠z de la composici√≥n es el lugar donde se crean e implementan las dependencias (habl√© mucho sobre esto en mis art√≠culos).  Una ra√≠z de composici√≥n pertenece a un contexto, pero un contexto puede tener m√°s de una ra√≠z de composici√≥n.  Por ejemplo, la F√°brica es la ra√≠z de la composici√≥n.  Una aplicaci√≥n puede tener m√°s de un contexto, pero este es un escenario avanzado, y en este ejemplo no lo consideraremos. <br><br>  Antes de sumergirnos en el c√≥digo, conozcamos las primeras reglas del lenguaje Svelto.ECS.  ECS es la abreviatura Entity Component System.  La infraestructura de ECS ha sido bien analizada en art√≠culos por muchos autores, pero si bien los conceptos b√°sicos son comunes, las implementaciones var√≠an ampliamente.  En primer lugar, no existe una forma est√°ndar de resolver algunos problemas que surgen cuando se utiliza c√≥digo orientado a ECS.  Es con respecto a este tema que hago la mayor parte de mis esfuerzos, pero hablar√© sobre esto m√°s adelante o en los siguientes art√≠culos.  La teor√≠a se basa en los conceptos de Esencia, Componentes (entidades) y Sistemas.  Aunque entiendo por qu√© la palabra Sistema se us√≥ hist√≥ricamente, desde el principio no lo consider√© lo suficientemente intuitivo para este prop√≥sito, por lo que utilic√© el Motor como sin√≥nimo del Sistema y usted, seg√∫n sus preferencias, puede usar uno de estos t√©rminos. <br><br>  La clase EnginesRoot es el n√∫cleo de Svelto.ECS.  Con su ayuda, puedes registrar motores y dise√±ar toda la esencia del juego.  Crear motores din√°micamente no tiene mucho sentido, por lo que todos deben agregarse a la instancia de EnginesRoot desde la misma ra√≠z de la composici√≥n donde se cre√≥.  Por razones similares, una instancia de EnginesRoot nunca se debe implementar, y los motores no se deben eliminar despu√©s de que se hayan agregado. <br><br>  Para crear e implementar dependencias, necesitamos al menos una ra√≠z de la composici√≥n.  S√≠, en una aplicaci√≥n puede existir m√°s de un EnginesRoot, pero no trataremos esto en el art√≠culo actual, que trato de simplificar lo m√°s posible.  As√≠ es como se ve la ra√≠z de la composici√≥n con la creaci√≥n del motor y la inyecci√≥n de dependencia: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupEnginesAndEntities</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Engines Root   Svelto.ECS.      EngineRoot // ,  Composition Root     ,   //   . //UnitySumbmissionEntityViewScheduler -  ,   //EnginesRoot,     EntityViews. //    ,   , //         Unity. _enginesRoot = new EnginesRoot(new UnitySumbmissionEntityViewScheduler()); //Engines root      ,   , //   . //   EntityFactory  EntityFunctions. //EntityFactory      //(    ), //   . _entityFactory = _enginesRoot.GenerateEntityFactory(); // EntityFunctions     //   , //  .        var entityFunctions = _enginesRoot.GenerateEntityFunctions(); //GameObjectFactory   Unity GameObject //   // GameObject.Instantiate.      // ,    ,   //       //(  ,   //         //      -  ) GameObjectFactory factory = new GameObjectFactory(); //    3     Svelto.ECS. //        //  . //         //     . var enemyKilledObservable = new EnemyKilledObservable(); var scoreOnEnemyKilledObserver = new ScoreOnEnemyKilledObserver(enemyKilledObservable); //ISequencer   3     Svelto.ECS // .       : //1)       //(   //,   ,     //  ). //2)   ,     // . ISequencer      //  Sequencer playerDamageSequence = new Sequencer(); Sequencer enemyDamageSequence = new Sequencer(); //    Unity. //     . IRayCaster rayCaster = new RayCaster(); ITime time = new Others.Time(); // .         //  . var playerHealthEngine = new HealthEngine(entityFunctions, playerDamageSequence); var playerShootingEngine = new PlayerGunShootingEngine(enemyKilledObservable, enemyDamageSequence, rayCaster, time); var playerMovementEngine = new PlayerMovementEngine(rayCaster, time); var playerAnimationEngine = new PlayerAnimationEngine(); //  var enemyAnimationEngine = new EnemyAnimationEngine(); var enemyHealthEngine = new HealthEngine(entityFunctions, enemyDamageSequence); var enemyAttackEngine = new EnemyAttackEngine(playerDamageSequence, time); var enemyMovementEngine = new EnemyMovementEngine(); var enemySpawnerEngine = new EnemySpawnerEngine(factory, _entityFactory); //    var hudEngine = new HUDEngine(time); var damageSoundEngine = new DamageSoundEngine(); // Sequencer  ,    // ,     . playerDamageSequence.SetSequence( new Steps // ,  ! { { //  //      Next   enemyAttackEngine, new To //        { //      //   Next playerHealthEngine, } }, { //  playerHealthEngine, //      Next   new To //       { //      Next     //DamageCondition.damage { DamageCondition.damage, new IStep[] { hudEngine, damageSoundEngine } }, //      Next     //DamageCondition.dead { DamageCondition.dead, new IStep[] { hudEngine, damageSoundEngine, playerMovementEngine, playerAnimationEngine, enemyAnimationEngine } }, } } }); enemyDamageSequence.SetSequence( new Steps { { playerShootingEngine, new To { enemyHealthEngine, } }, { enemyHealthEngine, new To { { DamageCondition.damage, new IStep[] { enemyAnimationEngine, damageSoundEngine } }, { DamageCondition.dead, new IStep[] { enemyMovementEngine, enemyAnimationEngine, playerShootingEngine, enemySpawnerEngine, damageSoundEngine } }, } } }); // ,     //  _enginesRoot.AddEngine(playerMovementEngine); _enginesRoot.AddEngine(playerAnimationEngine); _enginesRoot.AddEngine(playerShootingEngine); _enginesRoot.AddEngine(playerHealthEngine); _enginesRoot.AddEngine(new PlayerInputEngine()); _enginesRoot.AddEngine(new PlayerGunShootingFXsEngine()); //  _enginesRoot.AddEngine(enemySpawnerEngine); _enginesRoot.AddEngine(enemyAttackEngine); _enginesRoot.AddEngine(enemyMovementEngine); _enginesRoot.AddEngine(enemyAnimationEngine); _enginesRoot.AddEngine(enemyHealthEngine); //  _enginesRoot.AddEngine(new CameraFollowTargetEngine(time)); _enginesRoot.AddEngine(damageSoundEngine); _enginesRoot.AddEngine(hudEngine); _enginesRoot.AddEngine(new ScoreEngine(scoreOnEnemyKilledObserver));</span></span></code> </pre><br>  Este c√≥digo es del ejemplo Survival, que ahora se comenta y cumple con casi todas las reglas de buenas pr√°cticas que propongo aplicar, incluido el uso de l√≥gica de motor probada e independiente de la plataforma.  Los comentarios lo ayudar√°n a comprender la mayor√≠a de ellos, pero un proyecto de este tama√±o puede ser dif√≠cil de entender si es nuevo en Svelto. <br><a name="Entities"></a><br><h2>  Entidades </h2><br>  El primer paso despu√©s de crear la ra√≠z vac√≠a de la composici√≥n y una instancia de la clase EnginesRoot es identificar primero los objetos con los que desea trabajar.  Es l√≥gico comenzar con Entity Player.  La esencia de Svelto.ECS no debe confundirse con el Unity Game Object (GameObject).  Si lee otros art√≠culos relacionados con ECS, podr√≠a ver que en muchos de ellos, las entidades a menudo se describen como √≠ndices.  Esta es probablemente la peor forma de introducir el concepto de ECS.  Aunque es cierto para Svelto.ECS, est√° oculto en √©l.  Quiero que el usuario de Svelto.ECS represente, describa e identifique cada entidad en t√©rminos del lenguaje del Dominio del dise√±o del juego.  La entidad en el c√≥digo debe ser el objeto descrito en el documento de dise√±o del juego.  Cualquier otra forma de definici√≥n de entidad conducir√° a una forma descabellada de adaptar sus puntos de vista antiguos a los principios de Svelto.ECS.  Sigue esta regla fundamental y no te equivocar√°s.  La clase de entidad en s√≠ no existe en el c√≥digo, pero a√∫n no debe definirla de manera abstracta. <br><a name="Engines"></a><br><h2>  Motores </h2><br>  El siguiente paso es pensar en qu√© comportamiento preguntar a las Entidades.  Cada comportamiento siempre se modela dentro del motor; no puede agregar l√≥gica a ninguna otra clase dentro de la aplicaci√≥n Svelto.ECS.  Podemos comenzar moviendo el personaje del jugador y definir la clase <b>PlayerMovementEngine</b> .  El nombre del motor debe estar muy enfocado, porque cuanto m√°s espec√≠fico sea, m√°s probable es que el motor siga la Regla de responsabilidad √∫nica.  El nombre apropiado de la clase en Svelto.ECS es fundamental.  Y el objetivo no es solo mostrar claramente sus intenciones, sino tambi√©n ayudarlo a "verlas" usted mismo. <br><br>  Por la misma raz√≥n, es importante que su motor se encuentre en un espacio de nombres muy especializado.  Si define espacios de nombres de acuerdo con la estructura de carpetas, ad√°ptese a los conceptos de Svelto.ECS.  El uso de espacios de nombres espec√≠ficos ayuda a detectar errores de dise√±o cuando las entidades se usan dentro de espacios de nombres incompatibles.  Por ejemplo, no se supone que se usar√° ning√∫n objeto enemigo dentro del espacio de nombres del jugador, a menos que el objetivo sea romper las reglas asociadas con la modularidad y el acoplamiento d√©bil de los objetos.  La idea es que los objetos de un espacio de nombres en particular solo se pueden usar dentro de √©l o en el espacio de nombres padre.  Usar Svelto.ECS es mucho m√°s dif√≠cil de convertir su c√≥digo en espagueti, donde las dependencias se inyectan de derecha a izquierda, y esta regla lo ayudar√° a elevar el nivel de calidad del c√≥digo a√∫n m√°s cuando las dependencias se abstraen correctamente entre clases. <br><br>  En Svelto.ECS, la abstracci√≥n avanza unas pocas l√≠neas, pero ECS esencialmente ayuda a extraer datos de la l√≥gica que deber√≠a procesar los datos.  Las entidades est√°n determinadas por sus datos, no por su comportamiento.  En este caso, los motores es un lugar donde puede colocar el comportamiento conjunto de entidades id√©nticas para que los motores siempre puedan trabajar con un conjunto de entidades. <br><br>  Svelto.ECS y el paradigma ECS permiten que el codificador logre uno de los santos griales de la programaci√≥n pura, que es la encapsulaci√≥n ideal de la l√≥gica.  Los motores no deben tener funciones p√∫blicas.  Las √∫nicas funciones p√∫blicas que deben existir son aquellas que son necesarias para implementar las interfaces del marco.  Esto lleva a olvidar la inyecci√≥n de dependencia y ayuda a evitar el c√≥digo incorrecto que ocurre cuando se usa la inyecci√≥n de dependencia sin inversi√≥n de control.  Los motores NUNCA deben estar integrados en ning√∫n otro motor o cualquier otro tipo de clase.  Si cree que desea implementar el motor, simplemente comete un error fundamental en el dise√±o del c√≥digo. <br><br>  En comparaci√≥n con Unity MonoBehaviours, los motores ya muestran la primera gran ventaja, que es la capacidad de acceder a todos los estados de entidades de este tipo desde la misma √°rea de c√≥digo.  Esto significa que el c√≥digo puede usar f√°cilmente el estado de todos los objetos directamente desde el mismo lugar donde se ejecutar√° la l√≥gica del objeto com√∫n.  Adem√°s, los motores individuales pueden procesar los mismos objetos para que el motor pueda cambiar el estado del objeto, mientras que el otro motor puede leerlo, utilizando efectivamente dos motores para la comunicaci√≥n a trav√©s de los mismos datos de entidad.  Se puede ver un ejemplo mirando los <b>motores</b> <b>PlayerGunShootingEngine</b> y <b>PlayerGunShootingFxsEngine</b> .  En este caso, dos motores est√°n en el mismo espacio de nombres, por lo que pueden compartir los mismos datos de entidad.  <b>PlayerGunShootingEngine</b> determina si un jugador (enemigo) ha sido da√±ado y escribe el valor <b>lastTargetPosition del</b> componente <b>IGunAttributesComponent</b> (que es un componente <b>PlayerGunEntity</b> ).  <b>PlayerGunShootFxsEngine</b> procesa los efectos gr√°ficos del arma y lee la posici√≥n del objetivo seleccionado por el jugador.  Este es un ejemplo de interacci√≥n entre motores a trav√©s del sondeo de datos.  M√°s adelante en este art√≠culo, mostrar√© c√≥mo permitir que un mecanismo se comunique entre ellos <i>empujando datos (empuje de datos)</i> o <i>enlace de datos (enlace de datos)</i> .  L√≥gicamente, los motores nunca deber√≠an almacenar estado. <br><br>  Los motores no necesitan saber c√≥mo interactuar con otros motores.  La comunicaci√≥n externa se produce a trav√©s de la abstracci√≥n, y Svelto.ECS resuelve la conexi√≥n entre los motores de tres formas oficiales diferentes, pero hablar√© de esto m√°s adelante.  Los mejores motores son aquellos que no requieren comunicaciones externas.  Estos motores reflejan un comportamiento bien encapsulado y generalmente funcionan a trav√©s de un bucle l√≥gico.  Los bucles siempre se modelan utilizando tareas Svelto.Task dentro de las aplicaciones Svelto.ECS.  Dado que el movimiento del jugador debe actualizarse en cada tic f√≠sico, ser√≠a natural crear una tarea para realizar en cada tic f√≠sico.  Svelto.Tasks le permite ejecutar cada tipo de <b>IEnumerator</b> en varios tipos de planificadores.  En este caso, decidimos crear una tarea en <b>PhysicScheduler</b> , que le permite actualizar la posici√≥n del jugador: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayerMovementEngine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IRayCaster raycaster, ITime time</span></span></span><span class="hljs-function">)</span></span> { _rayCaster = raycaster; _time = time; _taskRoutine = TaskRunner.Instance.AllocateNewTaskRoutine() .SetEnumerator(PhysicsTick()).SetScheduler(StandardSchedulers.physicScheduler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Stop(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,      //  EnginesRoot    . // ,         . var _playerEntityViews = entityViewsDB.QueryEntityViews&lt;PlayerEntityView&gt;(); var playerEntityView = _playerEntityViews[0]; while (true) { Movement(playerEntityView); Turning(playerEntityView); //   yield,     ! yield return null; } }</span></span></code> </pre><br>  Las tareas de Svelto.Tasks se pueden realizar directamente o mediante objetos <b>ITaskRoutine</b> .  No hablar√© mucho sobre Svelto. Tareas aqu√≠, ya que escrib√≠ otros art√≠culos para ello.  La raz√≥n por la que decid√≠ usar la rutina de tareas en lugar de iniciar la implementaci√≥n de IEnumerator directamente es bastante discrecional.  Quer√≠a mostrar que puedes iniciar un ciclo cuando el objeto de un jugador se agrega al motor y detenerlo cuando se elimina.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, para esto necesita saber cu√°ndo se agrega y elimina un objeto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Svelto.ECS introduce </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quitar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devoluciones </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">llamada </font><font style="vertical-align: inherit;">para saber cu√°ndo se agregan o eliminan ciertas entidades. Esto es algo √∫nico en Svelto.ECS, pero este enfoque debe usarse con prudencia. A menudo vi que estas devoluciones de llamada est√°n siendo abusadas, ya que en muchos casos son suficientes para consultar entidades. Incluso tener una referencia de entidad como un campo de motor debe considerarse m√°s como una excepci√≥n que como una regla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo cuando se utilicen estas devoluciones de llamada, el motor debe heredarse de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingleEntityViewEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiEntitiesViewEngine &lt;EntityView1, ..., EntityViewN&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Una vez m√°s, el uso de estos datos deber√≠a ser raro, y de ninguna manera tienen la intenci√≥n de informar qu√© objetos procesar√° el motor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los motores a menudo implementan la interfaz </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryingEntityViewEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto le permite acceder y extraer datos de una base de datos de entidades. Recuerde que siempre puede solicitar un objeto desde el interior del motor, pero en el momento en que solicita una entidad que es incompatible con el espacio de nombres donde se encuentra el motor, debe comprender que ya est√° haciendo algo mal. Los motores nunca deber√≠an suponer que las entidades son accesibles, y deber√≠an funcionar en un conjunto de objetos. No debe suponerse que siempre habr√° un solo jugador en el juego, como hago en el ejemplo del c√≥digo. En </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnemyMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hay un enfoque muy general sobre c√≥mo solicitar objetos: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ready</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Tick().Run(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemyTargetEntityViews = entityViewsDB.QueryEntityViews&lt;EnemyTargetEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyTargetEntityViews.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetEntityView = enemyTargetEntityViews[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemies = entityViewsDB.QueryEntityViews&lt;EnemyEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = enemies[i].movementComponent; component.navMeshDestination = targetEntityView.targetPositionComponent.position; } } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, el ciclo del motor principal comienza directamente en el planificador predefinido. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marque (). Ejecutar ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muestra la forma m√°s corta de iniciar IEnumerator con Svelto.Tasks. IEnumerator continuar√° cediendo al siguiente cuadro hasta que se encuentre al menos un objetivo enemigo. Como sabemos que siempre habr√° un solo objetivo (otra mala suposici√≥n), elijo el primero disponible. Si bien el objetivo de Enemy Target puede ser solo uno (¬°aunque podr√≠a haber m√°s!), Hay muchos enemigos y, sin embargo, el motor se encarga de la l√≥gica del movimiento para todos. En este caso, hice trampa, ya que en realidad uso el Sistema de malla Unity Nav, as√≠ que todo lo que tengo que hacer es configurar el destino en NavMesh. Honestamente, nunca us√© el c√≥digo Unity NavMesh, por lo que ni siquiera estoy seguro de c√≥mo funciona, este c√≥digo solo se hereda de la demostraci√≥n original de Survival.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que un componente nunca proporciona directamente una dependencia de Navmesh Unity. </font><font style="vertical-align: inherit;">El componente Entidad, como lo analizar√© m√°s adelante, siempre debe exponer los tipos de valor. </font><font style="vertical-align: inherit;">En este caso, esta regla tambi√©n le permite mantener el c√≥digo bajo control, ya que el tipo de valor del campo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navMeshDestination</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede implementarse m√°s tarde sin usar Unity Nav Mesh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para completar el p√°rrafo sobre motores, tenga en cuenta que no existe un motor demasiado peque√±o. </font><font style="vertical-align: inherit;">Por lo tanto, no tenga miedo de escribir un motor que contenga varias l√≠neas de c√≥digo, porque no puede escribir l√≥gica en otro lugar y necesita que sus motores sigan la regla de responsabilidad uniforme.</font></font><br><a name="Entity_Views"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Representaciones de entidades </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de eso, introdujimos el concepto del Motor y la definici√≥n abstracta de la Esencia, ahora definamos qu√© es la Representaci√≥n de la esencia. Debo admitir que de los 5 conceptos en los que se basa Svelto.ECS, las Vistas de entidad son probablemente las m√°s confusas. Anteriormente llamado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nodo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (un nombre tomado del </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marco ECS Ash</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), me di cuenta de que el nombre "Nodo" no significaba nada. EntityView tambi√©n puede ser enga√±oso porque los programadores t√≠picamente asociados con la representaci√≥n concepto que emana de la plantilla de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">controlador de vista modelo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Model View Controller), sin embargo, Svelto.ECS usa View, porque EntityView es como el motor ve a Entity. Me gusta describirlo as√≠ porque parece lo m√°s natural, pero tambi√©n podr√≠a llamarlo EntityMap, porque EntityView muestra los componentes de la entidad a los que debe acceder el motor. Este esquema de conceptos Svelto.ECS deber√≠a ayudar un poco: </font></font><br><br><img src="https://habrastorage.org/webt/b4/ph/ui/b4phuignfk8myvfpojldjsyxlkq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sugiero comenzar con el motor, y ahora estamos en el lado derecho de este esquema. Cada motor tiene su propio conjunto de EntityViews. El motor puede reutilizar EntityViews compatibles con el espacio de nombres, pero la mayor√≠a de las veces el Motor define sus EntityViews. Al motor no le importa si la entidad Player est√° realmente definida, indica el hecho de que necesita </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el trabajo </font><font style="vertical-align: inherit;">Escribir el c√≥digo depende de las necesidades del motor, no debe crear una entidad y su campo antes de comprender c√≥mo usarlos. </font><font style="vertical-align: inherit;">En un escenario m√°s complejo, el nombre EntityView podr√≠a ser a√∫n m√°s espec√≠fico. </font><font style="vertical-align: inherit;">Por ejemplo, si tuvi√©ramos que escribir motores complejos para manejar la l√≥gica del jugador y representar gr√°ficos del jugador (o animaciones, etc.), podr√≠amos tener </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se pueden usar nombres m√°s espec√≠ficos, como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicJumpEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (etc.) </font></font><br><a name="Components"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Componentes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos dimos cuenta de que los motores modelan el comportamiento de un conjunto de datos de entidad, y entendemos que los motores no usan entidades directamente, sino que usan componentes de entidad a trav√©s de representaciones de entidades. Nos dimos cuenta de que EntityView es una clase que puede contener SOLAMENTE componentes p√∫blicos de entidades. Tambi√©n suger√≠ que los componentes de la entidad siempre son interfaces, as√≠ que d√©mos una mejor definici√≥n: las </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entidades son una colecci√≥n de datos, y los componentes de la entidad son una forma de acceder a esos datos. Si a√∫n no lo ha notado, definir los componentes de la entidad como interfaces es otra caracter√≠stica bastante √∫nica de Svelto.ECS. Por lo general, los componentes en otros marcos son objetos. El uso de interfaces en su lugar puede reducir significativamente el c√≥digo. Si sigues el principio</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Principio de segregaci√≥n de interfaz", habiendo escrito peque√±as interfaces de componentes, incluso con una propiedad cada una, notar√° que ha comenzado a reutilizar interfaces de componentes dentro de diferentes entidades. En nuestro ejemplo, ITransformComponent se reutiliza en muchas representaciones de entidades. El uso de componentes como interfaces tambi√©n les permite implementar los mismos objetos, lo que en muchos casos simplifica la relaci√≥n entre entidades que ven la misma entidad usando diferentes representaciones de las entidades (o lo mismo, si es posible). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, en Svelto.ECS, el componente de entidad es siempre una interfaz, y esta interfaz se usa solo a trav√©s del campo EntityView dentro del motor. La interfaz del componente de entidad es implementada por el llamado</font></font><b>¬´¬ª.      ,       .</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los componentes siempre deben almacenar tipos significativos, y los campos son siempre propiedades. Solo se pueden hacer excepciones para escribir setters y getters como m√©todos para usar la palabra clave ref cuando se necesita optimizaci√≥n. Esto no significa que el c√≥digo est√© orientado a datos, pero le permitir√° crear c√≥digo para pruebas, ya que la l√≥gica del motor no debe procesar enlaces a dependencias externas. Adem√°s, esto evita que los codificadores hagan trampa en el marco y usen funciones p√∫blicas (¬°que pueden incluir l√≥gica!) De objetos aleatorios. La √∫nica raz√≥n por la que pod√≠a sentir la necesidad de usar enlaces dentro de las interfaces de los componentes de la entidad era para tratar con dependencias de terceros, como los objetos de Unity. Sin embargo, el ejemplo de supervivencia muestra c√≥mo manejar esto,dejando el c√≥digo de prueba del motor sin tener que preocuparse por las dependencias de Unity.</font></font><br><a name="Entity_Descriptors"></a><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ es donde Entity Descriptors viene al rescate para armar todo. Sabemos que los motores pueden acceder a los datos de la entidad a trav√©s de componentes que se almacenan en las vistas de la entidad. Sabemos que los motores son clases, EntityView son clases que contienen solo entidades componentes y que los componentes son interfaces. Aunque di una definici√≥n abstracta de la Esencia, no hemos visto una sola clase que realmente represente la Esencia. Esto corresponde al concepto de objetos que son identificadores dentro del sistema ECS moderno. Sin embargo, sin la definici√≥n correcta de Entidades, esto obligar√° a los codificadores a identificar Entidades con Representaciones de entidades, lo que ser√≠a catastr√≥ficamente incorrecto. Las representaciones de entidades es la forma en que varios motores pueden ver la misma entidad,pero no son entidades. La Entidad misma siempre debe considerarse como un conjunto de datos definidos a trav√©s de los Componentes de la entidad, pero incluso esta es una definici√≥n d√©bil. Una instancia de EntityDescriptor permite que el codificador determine correctamente sus Entidades, independientemente de los motores que las procesen. Por lo tanto, en el caso de Entity Player, necesitamos</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta clase se usar√° para crear Entidades, y aunque lo que realmente hace es algo completamente diferente, el hecho de que el usuario pueda escribir </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity &lt;PlayerEntityDescriptor&gt; ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ayuda a visualizar Entidades muy f√°cilmente para construir y comunicar intenciones a otros. codificadores </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, lo que EntityDescriptor realmente hace es crear una lista de EntityViews. En las primeras etapas de desarrollo del marco, permit√≠ a los codificadores crear esta lista de EntityViews manualmente, lo que condujo a un c√≥digo muy feo porque ya no pod√≠a visualizar lo que realmente estaba sucediendo. </font><b><font style="vertical-align: inherit;">As√≠</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como se</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ve </font><b><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></b><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Camera; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.HUD; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Enemies; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Sound; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Svelto.ECS.Example.Survive.Player</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerEntityDescriptor</span></span> : <span class="hljs-title"><span class="hljs-title">GenericEntityDescriptor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">HUDDamageEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">PlayerEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">EnemyTargetEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">DamageSoundEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">HealthEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">CameraTargetEntityView</span></span>&gt; { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los descriptores de entidad (y los implementadores) son las √∫nicas clases que pueden usar identificadores de m√∫ltiples espacios de nombres. </font><font style="vertical-align: inherit;">En este caso, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> define una lista de EntityViews para instanciar e inyectar en el motor al crear PlayerEntity.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EntityDescriptorHolder </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntityDescriptorHolder es una extensi√≥n para Unity y solo debe usarse en ciertos casos. Lo m√°s com√∫n es la creaci√≥n de un tipo de polimorfismo que almacena informaci√≥n sobre entidades para construir un GameObject de Unity. Por lo tanto, se puede usar el mismo c√≥digo para crear varios tipos de entidades. Por ejemplo, en Robocraft, utilizamos una √∫nica f√°brica de cubos que construye todos los cubos que componen las m√°quinas. El tipo de cubo para ensamblar se almacena en la prefabricada del propio cubo. Esto es bueno siempre que los implementadores sean iguales entre los cubos o se encuentren en GameObject como MonoBehaviour's. Es preferible crear Entidades directamente, as√≠ que use EntityDescriptorHolders solo cuando comprenda correctamente los principios de Svelto.ECS, de lo contrario, existe el riesgo de abuso. Esta funci√≥n del ejemplo muestra c√≥mo usar la clase:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildEntitiesFromScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnityContext contextHolder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//EntityDescriptorHolder -    Svelto.ECS , //       . //         . //      , //    //     IEntityDescriptorHolder[] entities = contextHolder.GetComponentsInChildren&lt;IEntityDescriptorHolder&gt;(); //     Svelto.ECS, ,   //      . //        . //    EntityDescriptorHolder, //    for (int i = 0; i &lt; entities.Length; i++) { var entityDescriptorHolder = entities[i]; var entityDescriptor = entityDescriptorHolder.RetrieveDescriptor(); _entityFactory.BuildEntity (((MonoBehaviour) entityDescriptorHolder).gameObject.GetInstanceID(), entityDescriptor, (entityDescriptorHolder as MonoBehaviour).GetComponentsInChildren&lt;IImplementor&gt;()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que en este ejemplo estoy usando una funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no gen√©rica menos preferida </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Explicar√© esto. </font><font style="vertical-align: inherit;">En este caso, los implementadores son las clases MonoBehaviour adjuntas al GameObject. </font><font style="vertical-align: inherit;">Esta no es una buena pr√°ctica. </font><font style="vertical-align: inherit;">Deber√≠a haber eliminado este c√≥digo del ejemplo, pero dejado para mostrarle este caso especial. </font><font style="vertical-align: inherit;">Los implementadores, como veremos m√°s adelante, ¬°deber√≠an ser clases MonoBehaviours solo cuando sea necesario!</font></font><br><a name="Implementors"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Imitadores </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de crear nuestra esencia, definamos el √∫ltimo concepto en Svelto.ECS, que es el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empalador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como sabemos, los componentes de la entidad son siempre interfaces, y las interfaces C # deben implementarse. </font><font style="vertical-align: inherit;">Un objeto que implementa estas interfaces se denomina "implementador". </font><font style="vertical-align: inherit;">Los implementadores tienen varias caracter√≠sticas importantes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de desatar el n√∫mero de objetos a ensamblar del n√∫mero de componentes de entidad necesarios para determinar los datos de la entidad. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La capacidad de intercambiar datos entre diferentes Componentes, dado que los Componentes proporcionan datos a trav√©s de propiedades, las diferentes propiedades de un Componente pueden devolver el mismo campo de implementaci√≥n. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capacidad para crear un stub de componente de interfaz para un componente de entidad. </font><font style="vertical-align: inherit;">Esto es importante para dejar el c√≥digo del motor probado.</font></font><br></li><li>      Svelto.ECS   (third party) .     .    Unity,    ,       ,      <b>Monobehaviour</b> .  ,        Unity,   <b>OnTriggerEnter</b> / <b>OnTriggerExit</b> ,         Unity.        ,      .  : <br></li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyTriggerImplementor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IImplementor</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTriggerComponent</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTargetComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; entityInRange; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTriggerComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _targetInRange = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTargetComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _targetInRange; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerExit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _targetInRange; }</code> </pre><br> <i>,    ,        .    ,     .</i> <br><a name="Build_Entity"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creaci√≥n de entidad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos que creamos nuestros </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motores</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los agregamos a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnginesRoot</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , creamos sus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vistas de entidad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que necesitan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como interfaces que se implementar√°n dentro de los </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementadores</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es hora de crear nuestra primera Esencia. </font><font style="vertical-align: inherit;">Una entidad siempre se crea a trav√©s de una instancia </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Factory creada por EnginesRoot a trav√©s de la funci√≥n </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GenerateEntityFactory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A diferencia de una instancia de EnginesRoot, una instancia de IEntityFactory se puede implementar y transferir. </font><font style="vertical-align: inherit;">Los objetos se pueden construir dentro de la ra√≠z de la composici√≥n o din√°micamente dentro de las f√°bricas, por lo que para este √∫ltimo caso, debe pasar un IEntityFactory a trav√©s de un par√°metro.</font></font><br><br> <b>IEntityFactory</b>     .         <b>PreallocateEntitySlots</b>  <b>BuildMetaEntity</b> ,        <b>BuildEntity</b>  <b>BuildEntityInGroup</b> . <br><br>    <b>BuildEntityInGroup</b> ,    Survival   ,   ,   <b>BuildEntity</b>   : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntervaledTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  :       //MonoBehaviour    . //       //   . // ,     , //         . //        ,     . //  ,        //   , //  .      , // ,   ,   . var enemiestoSpawn = ReadEnemySpawningDataServiceRequest(); while (true) { //Svelto.Tasks    yield  Unity, //    . //       . // ,  , //    . yield return _waitForSecondsEnumerator; if (enemiestoSpawn != null) { for (int i = enemiestoSpawn.Length - 1; i &gt;= 0 &amp;&amp; _numberOfEnemyToSpawn &gt; 0; --i) { var spawnData = enemiestoSpawn[i]; if (spawnData.timeLeft &lt;= 0.0f) { //          int spawnPointIndex = Random.Range(0, spawnData.spawnPoints.Length); //       . var go = _gameobjectFactory.Build(spawnData.enemyPrefab); //        MonoBehaviour. //      . var data = go.GetComponent&lt;EnemyAttackDataHolder&gt;(); //     MonoBehaviour   // : List&lt;IImplementor&gt; implementors = new List&lt;IImplementor&gt;(); go.GetComponentsInChildren(implementors); implementors.Add(new EnemyAttackImplementor(data.timeBetweenAttacks, data.attackDamage)); //         EntityViews, //     EntityDescriptor. //,       EntityView //  ,     ,  EntityDescriptorHolder //       , //    . _entityFactory.BuildEntity&lt;EnemyEntityDescriptor&gt;( go.GetInstanceID(), implementors.ToArray()); var transform = go.transform; var spawnInfo = spawnData.spawnPoints[spawnPointIndex]; transform.position = spawnInfo.position; transform.rotation = spawnInfo.rotation; spawnData.timeLeft = spawnData.spawnTime; numberOfEnemyToSpawn--; } spawnData.timeLeft -= 1.0f; } } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuerde leer todos los comentarios en este ejemplo, lo ayudar√°n a comprender mejor los conceptos de Svelto.ECS. Debido a la simplicidad del ejemplo, no utilizo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se usa en proyectos m√°s complejos. En Robocraft, cada motor que procesa la l√≥gica de los cubos funcionales procesa la l√≥gica de TODOS los cubos funcionales de este tipo en particular en el juego. Sin embargo, a menudo es necesario saber a qu√© veh√≠culo pertenecen los cubos, por lo que usar un grupo para cada m√°quina ayudar√° a dividir los cubos del mismo tipo en m√°quinas, donde la ID de la m√°quina es la ID del grupo. Esto nos permite implementar cosas interesantes, como ejecutar una tarea Svelto.Tasks en una m√°quina dentro del mismo motor, que puede funcionar en paralelo usando subprocesos m√∫ltiples.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo muestra un problema importante que puedo cubrir con m√°s detalle en los siguientes art√≠culos ... del comentario (si no lo ha le√≠do): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca cree Impulsores MonoBehaviour solo para el almacenamiento de datos. Los datos siempre deben recuperarse a trav√©s de la capa de servicio, independientemente de la fuente de datos. Los beneficios son numerosos, incluido el hecho de que para cambiar la fuente de datos solo necesita cambiar el c√≥digo de servicio. En este simple ejemplo, no uso la capa de Servicio, pero en general la idea es clara. Tambi√©n tenga en cuenta que solo subo datos una vez para cada inicio de aplicaci√≥n, fuera del bucle principal. Siempre puedes usar este truco si los datos que necesitas nunca cambian.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, le√≠a datos directamente de MonoBehaviour, como har√≠a un buen codificador perezoso. </font><font style="vertical-align: inherit;">Esto me hizo crear un implementador de serializador de solo lectura MonoBehaviore. </font><font style="vertical-align: inherit;">Esto es aceptable si no queremos abstraer la fuente de datos, pero es mucho mejor serializar la informaci√≥n en un archivo json y leerla a pedido del servicio que leer esta informaci√≥n del Componente de la entidad.</font></font><br><a name="Communication"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comunicaci√≥n en Svelto.ECS </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un problema cuya soluci√≥n nunca ha sido estandarizada por ninguna implementaci√≥n de ECS es la comunicaci√≥n entre sistemas. </font><font style="vertical-align: inherit;">Este es otro lugar donde pens√© mucho, y Svelto.ECS lo resuelve de dos maneras nuevas. </font><font style="vertical-align: inherit;">La tercera forma es utilizar el patr√≥n Observador / Observado est√°ndar, aceptable en casos muy espec√≠ficos y espec√≠ficos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DispatchOnSet / DispatchOnChange </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente vimos c√≥mo permitir que los motores intercambien datos a trav√©s de componentes de la entidad mediante el sondeo de datos. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son las √∫nicas referencias (tipos no significativos) que pueden ser devueltas por las propiedades de los componentes de la entidad, pero el tipo del par√°metro gen√©rico T debe ser un tipo significativo. Los nombres de las funciones suenan como un despachador de eventos, pero en su lugar deben considerarse como m√©todos para enviar los datos, en lugar de encuestas de datos, que es un poco como el enlace de datos. Eso es todo, a veces los datos de sondeo son inconvenientes, no queremos sondear una variable en cada cuadro cuando sabemos que los datos rara vez cambian. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se puede iniciar sin cambiar los datos, esto nos permite considerarlos como un mecanismo de enlace de datos en lugar de un evento regular. </font><font style="vertical-align: inherit;">Tampoco hay una funci√≥n de inicio para llamar; en cambio, el valor de los datos en poder de estas clases debe establecerse o cambiarse. </font><font style="vertical-align: inherit;">No hay grandes ejemplos en el c√≥digo de supervivencia, pero puede ver c√≥mo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo booleano </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">targetHit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><font style="vertical-align: inherit;">IGunHitTargetComponent</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La diferencia entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es que este √∫ltimo activa el evento solo cuando los datos realmente cambian, y el primero siempre.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secuenciador </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los motores ideales est√°n completamente encapsulados, y puede escribir la l√≥gica de este motor como una secuencia de instrucciones utilizando Svelto.Tasks e IEnumerators. Sin embargo, esto no siempre es posible, ya que en algunos casos los motores deben enviar eventos a otros motores. Esto generalmente se hace a trav√©s de los datos de la entidad, especialmente usando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin embargo, como en el caso de las Entidades "da√±adas" en el ejemplo, una serie de Motores independientes y no relacionados act√∫an sobre √©l. </font><font style="vertical-align: inherit;">En otros casos, desea que la secuencia sea estricta en el orden en que se llamaron los motores, como en el ejemplo en el que quiero que siempre ocurra la muerte para este √∫ltimo. </font><font style="vertical-align: inherit;">En este caso, la secuencia no solo es muy f√°cil de usar, ¬°sino que tambi√©n es muy conveniente! </font><font style="vertical-align: inherit;">La refactorizaci√≥n de secuencias es muy simple. </font><font style="vertical-align: inherit;">Por lo tanto, utilice Tareas Ivelumerator Svelto para motores "verticales" y secuencias para l√≥gica "horizontal" entre motores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Observador / Observado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dej√© la oportunidad de usar este patr√≥n espec√≠ficamente para casos en los que el c√≥digo heredado o el c√≥digo que no usa Svelto.ECS deber√≠a interactuar con los motores Svelto.ECS. </font><font style="vertical-align: inherit;">Para otros casos, debe usarse con extrema precauci√≥n, ya que existe la posibilidad de abuso del patr√≥n, ya que es familiar para la mayor√≠a de los codificadores nuevos en Svelto.ECS, y los secuenciadores son generalmente la mejor opci√≥n.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413107/">https://habr.com/ru/post/es413107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413097/index.html">Basado en software de nivel empresarial, probado millones de veces: se lanz√≥ openSUSE Leap 15</a></li>
<li><a href="../es413099/index.html">Descarga de ram en macbook</a></li>
<li><a href="../es413101/index.html">Placa de depuraci√≥n STM32F4 en factor de forma Raspberry Pi</a></li>
<li><a href="../es413103/index.html">3CX v15.5 Actualizaci√≥n 5 Beta e integraci√≥n REST con AmoCRM lanzado</a></li>
<li><a href="../es413105/index.html">Notas del proveedor de IoT. Activaci√≥n y seguridad en LoraWAN</a></li>
<li><a href="../es413109/index.html">C√≥mo construir una plataforma de integraci√≥n de productos SaaS: experiencia de pago de Cloud Poster</a></li>
<li><a href="../es413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../es413113/index.html">Soporte de serializaci√≥n JavaScript JavaScript de clase</a></li>
<li><a href="../es413117/index.html">C√≥mo programar de forma segura en bash</a></li>
<li><a href="../es413119/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 317 (28 de mayo - 3 de junio de 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>