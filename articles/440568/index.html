<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèæ ‚úä üôÄ Estamos escribiendo una aplicaci√≥n de aprendizaje en Go y Javascript para evaluar el rendimiento real de las acciones. Parte 2 - Prueba del backend üé¶ üö∫ ‚è≠Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la primera parte del art√≠culo, escribimos un peque√±o servidor web, que es el back-end de nuestro sistema de informaci√≥n. Esa parte no fue particula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos escribiendo una aplicaci√≥n de aprendizaje en Go y Javascript para evaluar el rendimiento real de las acciones. Parte 2 - Prueba del backend</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440568/">  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del</a> art√≠culo, escribimos un peque√±o servidor web, que es el back-end de nuestro sistema de informaci√≥n.  Esa parte no fue particularmente interesante, aunque demostr√≥ el uso de la interfaz y uno de los m√©todos para trabajar con gorutinas.  Tanto eso como otro pueden ser interesantes para los desarrolladores principiantes. <br><br>  La segunda parte es mucho m√°s interesante y √∫til, porque en ella escribiremos pruebas unitarias tanto para el servidor como para el paquete de la biblioteca que implementa el almac√©n de datos.  Empecemos <br><br><img src="https://habrastorage.org/webt/wt/j2/bu/wtj2bu3mbxf_4pj0a_7lypsprcm.jpeg"><br>  <i>foto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aqui</a></i> <br><a name="habracut"></a><br>  Entonces, perm√≠tame recordarle que nuestra aplicaci√≥n consta de un m√≥dulo ejecutable (servidor web, API), m√≥dulo de almacenamiento (estructuras de datos de entidad, interfaz de contrato para proveedores de almacenamiento) y m√≥dulos de proveedor de almacenamiento (en nuestro ejemplo, solo hay un m√≥dulo que ejecuta la interfaz de almacenamiento datos en memoria). <br><br>  Probaremos el m√≥dulo ejecutable y la implementaci√≥n de almacenamiento.  El m√≥dulo de contrato no contiene c√≥digo que pueda ser probado.  Solo hay declaraciones de tipo. <br>  Para las pruebas, utilizaremos solo las capacidades de la biblioteca est√°ndar: paquetes de prueba y httptest.  En mi opini√≥n, son suficientes, aunque hay muchos marcos de prueba diferentes.  M√≠ralos, tal vez te gusten.  Desde mi punto de vista, los programas en Go realmente no necesitan esos marcos (de varios tipos) que existen actualmente.  Este no es Javascript para usted, que se discutir√° en la tercera parte del art√≠culo. <br><br>  Primero, algunas palabras sobre la metodolog√≠a de prueba que uso para los programas Go. <br><br>  <b>En primer lugar</b> , debo decir que realmente me gusta Go solo porque no lleva al programador a un marco r√≠gido.  Aunque a algunos desarrolladores, para ser justos, les encanta conducirse al marco tra√≠do del PL anterior.  Digamos, el mismo Rob Pike, dijo que no ve√≠a ning√∫n problema en copiar el c√≥digo, si eso era m√°s f√°cil.  Tal copiar y pegar est√° incluso en la biblioteca est√°ndar.  En lugar de importar el paquete, uno de los autores del lenguaje simplemente copi√≥ el texto de una funci√≥n (verificaci√≥n Unicode).  En esta prueba, el paquete Unicode se importa, por lo que todo est√° bien. <br><br>  Por cierto, en este sentido (en el sentido de la flexibilidad del lenguaje), se puede utilizar una t√©cnica interesante al escribir pruebas.  La conclusi√≥n es esta: sabemos que los contratos de interfaz en Go se ejecutan impl√≠citamente.  Es decir, podemos declarar un tipo, escribir m√©todos para √©l y ejecutar alg√∫n tipo de contrato.  Quiz√°s incluso sin saberlo.  Esto es conocido y entendido.  Sin embargo, esto tambi√©n funciona en la direcci√≥n opuesta.  Si el autor de alg√∫n m√≥dulo no escribi√≥ una interfaz que nos ayudar√≠a a crear un c√≥digo auxiliar para probar nuestro paquete, entonces podemos declarar la interfaz en nuestra prueba, que se ejecutar√° en un paquete de terceros.  Una idea fruct√≠fera, aunque no es √∫til en nuestra aplicaci√≥n de capacitaci√≥n. <br><br>  <b>En segundo lugar</b> , algunas palabras sobre el momento de escribir las pruebas.  Como todos saben, hay diferentes opiniones sobre cu√°ndo escribir pruebas unitarias.  Las ideas principales son las siguientes: <br><br><ul><li>  Escribimos pruebas antes de escribir el c√≥digo (TDD).  Por lo tanto, entendemos mejor la tarea y establecemos criterios de calidad. </li><li>  Escribimos pruebas mientras escribimos c√≥digo, o incluso un poco m√°s tarde (consideraremos este prototipo incremental). </li><li>  Escribiremos pruebas en alg√∫n momento posterior, si hay tiempo.  Y esto no es una broma.  A veces las condiciones son tales que f√≠sicamente no hay tiempo. </li></ul><br>  No creo que haya la √∫nica opini√≥n correcta sobre este tema.  Compartir√© el m√≠o y pedir√© a los lectores que comenten en los comentarios.  Mi opini√≥n es esta: <br><br><ul><li>  Desarrollar paquetes independientes en TDD, realmente simplifica el asunto, especialmente cuando el lanzamiento de la aplicaci√≥n para verificaci√≥n es un proceso que requiere muchos recursos.  Por ejemplo, recientemente desarroll√© un sistema de monitoreo de veh√≠culos GPS / GLONASS.  Los paquetes de controladores para protocolos solo se pueden desarrollar a trav√©s de pruebas, ya que el lanzamiento y la verificaci√≥n manual de una aplicaci√≥n requieren la espera de datos de los rastreadores, lo cual es extremadamente inconveniente.  Para las pruebas, tom√© muestras de paquetes de datos, las grab√© en pruebas de tabla y no inici√© el servidor hasta que los controladores estuvieron listos. </li><li>  Si la estructura del c√≥digo no est√° clara, entonces primero intento hacer un prototipo funcional m√≠nimo.  Luego escribo pruebas, o incluso primero pulido el c√≥digo un poco y luego solo las pruebas. </li><li>  Para los m√≥dulos ejecutables, primero escribo un prototipo.  Pruebas posteriores.  No pruebo el c√≥digo ejecutable obvio en absoluto (puede escribir el inicio del servidor http desde main en una funci√≥n separada y llamarlo en la prueba, pero ¬øpor qu√© probar la biblioteca est√°ndar?) </li></ul><br>  En base a esto, en nuestra aplicaci√≥n de capacitaci√≥n, el proveedor de almacenamiento RAM fue escrito a trav√©s de pruebas.  El ejecutable del servidor se cre√≥ a trav√©s de un prototipo. <br><br>  Comencemos con las pruebas para implementar el repositorio. <br><br>  En el repositorio, tenemos el m√©todo de f√°brica New (), que devuelve un puntero a una instancia del tipo de almacenamiento.  Tambi√©n hay m√©todos para obtener cotizaciones de Valores (), agregar papel a la lista Agregar () e inicializar el almacenamiento con datos del servidor Mosbirzh InitData (). <br><br>  Prueba del constructor (los t√©rminos OOP se usan libremente, de manera informal. De acuerdo con la posici√≥n de OOP en Go). <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestNew(t *testing.T) { //   - memoryStorage := New() //     var s *Storage //         .   if reflect.TypeOf(memoryStorage) != reflect.TypeOf(s) { t.Errorf(" :  %v,   %v", reflect.TypeOf(memoryStorage), reflect.TypeOf(s)) } //     t.Logf("\n%+v\n\n", memoryStorage) }</span></span></code> </pre> <br>  En esta prueba, sin una necesidad especial, se demostr√≥ que la √∫nica forma en Go de verificar el tipo de una variable es la reflexi√≥n (reflect.TypeOf (memoryStorage)).  No se recomienda el uso excesivo de este m√≥dulo.  Los desaf√≠os son pesados ‚Äã‚Äãy no valen la pena.  Por otro lado, ¬øqu√© m√°s verificar en esta prueba adem√°s de la ausencia de un error? <br><br>  A continuaci√≥n, probamos el recibo de cotizaciones y la adici√≥n de papel.  Estas pruebas se duplican parcialmente entre s√≠, pero esto no es cr√≠tico (en la prueba para agregar papel, se llama al m√©todo para obtener cotizaciones para la verificaci√≥n).  En general, a veces escribo una prueba para todas las operaciones CRUD para una entidad en particular.  Es decir, en la prueba creo una entidad, la leo, la cambio, la leo de nuevo, la borro, la leo de nuevo.  No es muy elegante, pero los defectos obvios no son visibles. <br><br>  Prueba de cotizaci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestSecurities(t *testing.T) { //     var s *Storage //    ss, err := s.Securities() if err != nil { t.Error(err) } //     t.Logf("\n%+v\n\n", ss) } }</span></span></code> </pre> <br>  Todo es bastante obvio aqu√≠. <br><br>  Ahora prueba para agregar papel.  En esta prueba, con fines educativos (sin necesidad real), utilizaremos una t√©cnica de prueba de mesa muy conveniente.  Su esencia es la siguiente: creamos una matriz de estructuras sin nombre, cada una de las cuales contiene los datos de entrada para la prueba y el resultado esperado.  En nuestro caso, presentamos una garant√≠a para agregar, el resultado es el n√∫mero de valores en la b√≥veda (longitud de la matriz).  A continuaci√≥n, realizamos una prueba para cada elemento de la matriz de estructuras (llame al m√©todo de prueba con los datos de entrada del elemento) y comparemos el resultado con el campo de resultados del elemento actual.  Resulta algo como esto. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestAdd(t *testing.T) { //     var s *Storage var security = storage.Security{ ID: "MSFT", } //   var tt = []struct { s storage.Security //   length int //   () }{ { s: security, length: 1, }, { s: security, length: 2, }, } var ss []storage.Security // tc - test case, tt - table tests for _, tc := range tt { //    err := s.Add(security) if err != nil { t.Error(err) } ss, err = s.Securities() if err != nil { t.Error(err) } if len(ss) != tc.length { t.Errorf("  :  %d,   %d", len(ss), tc.length) } } //     t.Logf("\n%+v\n\n", ss) }</span></span></code> </pre> <br>  Bueno, una prueba para la funci√≥n de inicializaci√≥n de datos. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestInitData(t *testing.T) { //     var s *Storage //    err := s.InitData() if err != nil { t.Error(err) } ss, err := s.Securities() if err != nil { t.Error(err) } if len(ss) &lt; 1 { t.Errorf(" :  %d,   '&gt; 1'", len(ss)) } //     t.Logf("\n%+v\n\n", ss[0]) }</span></span></code> </pre> <br>  Como resultado de la ejecuci√≥n exitosa de la prueba, obtenemos: <b>17.595s de cobertura: 86.0% de las declaraciones.</b> <br><br>  Puede decir que ser√≠a bueno que una biblioteca separada obtuviera una cobertura del 100%, pero espec√≠ficamente aqu√≠ las rutas de ejecuci√≥n fallidas (errores en las funciones) son imposibles en absoluto, debido a las caracter√≠sticas de implementaci√≥n: todo est√° en la memoria, no estamos conectados en ning√∫n lugar, no dependemos de nada.  Existe un manejo formal de errores, ya que un contrato de interfaz hace que se devuelva el error y la interfaz lo requiere. <br><br>  Pasemos a probar el paquete ejecutable: el servidor web.  Hay que decir que, dado que el servidor web es una construcci√≥n s√∫per est√°ndar en los programas Go, el paquete "net / http / httptest" se desarroll√≥ especialmente para probar controladores de solicitudes http.  Le permite simular un servidor web, ejecutar un controlador de solicitudes y registrar la respuesta del servidor web en una estructura especial.  Lo usaremos, es muy simple, seguro que te gustar√°. <br><br>  Al mismo tiempo, existe la opini√≥n (y no solo la m√≠a) de que dicha prueba puede no ser muy relevante para un sistema de trabajo real.  En principio, puede iniciar un servidor real y llamar a controladores de conexi√≥n reales en las pruebas. <br><br>  Es cierto que existe otra opini√≥n (y no solo la m√≠a) de que aislar la l√≥gica empresarial de los sistemas para manipular datos reales es bueno. <br><br>  En este sentido, podemos decir que estamos escribiendo pruebas unitarias, no pruebas de integraci√≥n que involucran otros paquetes y servicios.  Aunque aqu√≠ tambi√©n soy de la opini√≥n de que cierta flexibilidad de Go le permite no centrarse en los t√©rminos y escribir las pruebas que sean m√°s adecuadas para sus tareas.  Perm√≠tanme darles un ejemplo: para las pruebas de los manejadores de solicitudes API, hice una copia simplificada de la base de datos en un servidor real en la red, inicialic√© con un peque√±o conjunto de datos y realic√© pruebas en datos reales.  Pero este enfoque es muy situacional. <br><br>  De vuelta a las pruebas de nuestro servidor web.  Para poder escribir pruebas que sean independientes del almacenamiento real, necesitamos desarrollar un almacenamiento auxiliar.  Esto no es dif√≠cil en absoluto, ya que trabajamos con el repositorio a trav√©s de la interfaz (consulte la primera parte).  Todo lo que tenemos que hacer es declarar algunos tipos de datos propios e implementar los m√©todos del contrato de la interfaz de almacenamiento, incluso con datos vac√≠os.  Algo como esto: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    -    type stub int //      var securities []storage.Security //    // ******************************* //     // InitData      func (s *stub) InitData() (err error) { //   -   var security = storage.Security{ ID: "MSFT", Name: "Microsoft", IssueDate: 1514764800, // 01/01/2018 } var quote = storage.Quote{ SecurityID: "MSFT", Num: 0, TimeStamp: 1514764800, Price: 100, } security.Quotes = append(security.Quotes, quote) securities = append(securities, security) return err } // Securities      func (s *stub) Securities() (data []storage.Security, err error) { return securities, err } //   // *****************</span></span></code> </pre> <br>  Ahora podemos inicializar nuestro almacenamiento con un trozo.  Como hacerlo  Con el fin de inicializar el entorno de prueba en Go de alguna versi√≥n no muy antigua, se agreg√≥ una funci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *testing.M)</span></span></span></span></code> </pre> <br>  Esta funci√≥n le permite inicializar y ejecutar todas las pruebas.  Se parece a esto: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    -   func TestMain(m *testing.M) { //     -    db = new(stub) //   () db.InitData() //     os.Exit(m.Run()) }</span></span></code> </pre> <br>  Ahora podemos escribir pruebas para manejadores de solicitudes API.  Tenemos dos puntos finales de API, dos controladores y, por lo tanto, dos pruebas.  Son muy similares, as√≠ que aqu√≠ est√° el primero de ellos. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    func TestSecuritiesHandler(t *testing.T) { //     req, err := http.NewRequest(http.MethodGet, "/api/v1/securities", nil) if err != nil { t.Fatal(err) } // ResponseRecorder    rr := httptest.NewRecorder() handler := http.HandlerFunc(securitiesHandler) //       handler.ServeHTTP(rr, req) //  HTTP-  if rr.Code != http.StatusOK { t.Errorf(" :  %v,   %v", rr.Code, http.StatusOK) } //  ()     json    var ss []storage.Security err = json.NewDecoder(rr.Body).Decode(&amp;ss) if err != nil { t.Fatal(err) } //       t.Logf("\n%+v\n\n", ss) }</span></span></code> </pre> <br>  La esencia de la prueba es la siguiente: cree una solicitud http, defina una estructura para registrar la respuesta del servidor, inicie el controlador de solicitudes, decodifique el cuerpo de la respuesta (json en la estructura).  Bueno, para mayor claridad, imprimimos la respuesta. <br><br>  Resulta algo as√≠ como: <br><blockquote>  === EJECUTAR TestSecuritiesHandler <br>  0xc00005e3e0 <br>  - PASS: TestSecuritiesHandler (0.00s) <br>  c: \ Users \ dtsp \ YandexDisk \ go \ src \ moex_etf \ server \ server_test.go: 96: <br>  [{ID: Nombre de MSFT: Fecha de emisi√≥n de Microsoft: 1514764800 Cotizaciones: [{SecurityID: MSFT Num: 0 TimeStamp: 1514764800 Price: 100}]}] <br><br>  Pase <br>  ok moex_etf / server 0.307s <br>  √âxito: se aprobaron las pruebas. </blockquote>  C√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Github</a> <br><br>  En la siguiente parte final del art√≠culo, desarrollaremos una aplicaci√≥n web para mostrar gr√°ficos de rendimientos de acciones reales en ETF de Moscow Exchange. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440568/">https://habr.com/ru/post/440568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440558/index.html">Tecnolog√≠a que acercar√° las redes cu√°nticas.</a></li>
<li><a href="../440560/index.html">Alexander Belokrylov y Dmitry Chuyko sobre Liberica JDK en jug.msk.ru</a></li>
<li><a href="../440562/index.html">Windows Phone - TODO, es una o otra vez</a></li>
<li><a href="../440564/index.html">Red neuronal GPT-2 de OpenAI. Inicio r√°pido</a></li>
<li><a href="../440566/index.html">Acelerar sin obst√°culos o conocer SIMD</a></li>
<li><a href="../440570/index.html">Mapas de sombras reflectantes: Parte 2 - Implementaci√≥n</a></li>
<li><a href="../440574/index.html">Russian AI Cup 2018, historia 9 lugares</a></li>
<li><a href="../440576/index.html">Cambios importantes en CTE en PostgreSQL 12</a></li>
<li><a href="../440582/index.html">¬øSe arrastran los autos el√©ctricos al fondo de la corporaci√≥n automotriz?</a></li>
<li><a href="../440584/index.html">¬øQu√© le pasa a la Raspberry Pi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>