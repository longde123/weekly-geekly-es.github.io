<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ü ü§¥üèø üë©üèª‚Äçü§ù‚Äçüë®üèº Unit-Tests in DBMS - wie wir es in Sportmaster machen, Teil zwei ü§úüèº üß¶ üëÉüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Teil ist hier . 

  

 Stellen Sie sich die Situation vor. Sie stehen vor der Aufgabe, neue Funktionen zu entwickeln. Sie haben Entwicklunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit-Tests in DBMS - wie wir es in Sportmaster machen, Teil zwei</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/465047/">  <i>Der erste Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/7s/_h/p0/7s_hp03wefqzcfhl0n867asfuge.png"></a> <br><br>  Stellen Sie sich die Situation vor.  Sie stehen vor der Aufgabe, neue Funktionen zu entwickeln.  Sie haben Entwicklungen von Ihren Vorg√§ngern.  Was w√ºrden Sie tun, wenn Sie keine moralischen Verpflichtungen haben? <br><br>  Meistens werden alle alten Errungenschaften vergessen und alles beginnt von vorne.  Niemand mag es, in den Code eines anderen zu graben, und wenn Sie Zeit haben, warum nicht mit der Erstellung Ihres eigenen Systems beginnen?  Dies ist ein typischer Ansatz, der weitgehend korrekt ist.  Aber in unserem Projekt haben wir falsch gemacht.  Wir haben den Grundstein f√ºr das zuk√ºnftige automatisierte Testsystem gelegt, das auf Unit-Tests auf utPLSQL unserer Vorg√§nger basiert, und sind dann in mehrere parallele Richtungen gegangen. <br><a name="habracut"></a><br><ol><li>  <b>Stellen Sie alte Komponententests wieder her.</b>  Wiederherstellung bezieht sich auf die Anpassung von Tests an den vorhandenen Status des Loyalit√§tssystems und die Anpassung von Tests an utPLSQL-Standards. </li><li>  <b>Die L√∂sung des Problems mit dem Verst√§ndnis und was genau, welche Methoden und Prozesse werden wir durch Autotests abgedeckt.</b>  Sie m√ºssen diese Informationen entweder ber√ºcksichtigen oder anhand des Autotest-Codes selbst Schlussfolgerungen ziehen.  Aus diesem Grund haben wir uns entschlossen, einen Katalog zu erstellen.  Wir haben jedem Autotest einen eindeutigen Mnemonikcode zugewiesen, eine Beschreibung erstellt und die Einstellungen festgelegt (z. B. unter welchen Bedingungen er gestartet werden soll oder was passieren soll, wenn der Test fehlschl√§gt).  Im Wesentlichen haben wir die Metadaten zu Autotests ausgef√ºllt und diese Metadaten in die Standard-utPLSQL-Schematabellen eingef√ºgt. </li><li>  <b>Definieren einer Expansionsstrategie, d.h.</b>  <b>Auswahl der Funktionen, die durch Autotests √ºberpr√ºft werden sollen.</b>  Wir haben uns entschlossen, drei Dinge zu beachten: neue Systemverbesserungen, Produktionsvorf√§lle und wichtige Systemprozesse.  Daher entwickeln wir parallel zur Ver√∂ffentlichung eine h√∂here Qualit√§t, erweitern gleichzeitig das Regressionsvolumen und stellen die Zuverl√§ssigkeit des Systems an kritischen Stellen sicher.  Der erste derartige Engpass war die Verteilung von Rabatten und Boni auf einen Scheck. </li><li>  <b>Nat√ºrlich haben wir begonnen, neue Autotests zu entwickeln.</b>  Eine der ersten Release-Aufgaben bestand darin, die Leistung vordefinierter Stichproben des Loyalit√§tssystems zu bewerten.  In unserem Projekt gibt es einen Block fest festgelegter SQL-Abfragen, die Clients gem√§√ü den Bedingungen ausw√§hlen.  Sie k√∂nnen beispielsweise eine Liste aller Kunden abrufen, deren letzter Kauf in einer bestimmten Stadt get√§tigt wurde, oder eine Liste der Kunden, deren durchschnittlicher Kaufbetrag √ºber einem bestimmten Wert liegt.  Nachdem wir Autotests geschrieben hatten, √ºberpr√ºften wir die vordefinierten Beispiele, legten die Referenzleistungsparameter fest und f√ºhrten zus√§tzlich Lasttests durch. </li><li> <b>Die Arbeit mit Autotests sollte bequem sein</b> .  Am h√§ufigsten werden zwei Aktionen ausgef√ºhrt: Ausf√ºhren von Autotests und Erstellen von Testdaten.  In unserem System erschienen also zwei Hilfsmodule: das Startmodul und das Datengenerierungsmodul. <br><br>  Der Launcher wird als einzelne universelle Prozedur mit einem Eingabetextparameter dargestellt.  Als Parameter k√∂nnen Sie den Mnemonikcode f√ºr den Autotest, den Paketnamen, den Testnamen, die Autotesteinstellung oder ein reserviertes Schl√ºsselwort √ºbergeben.  Die Prozedur w√§hlt alle Autotests aus und f√ºhrt sie aus, die die Bedingungen erf√ºllen. <br><br>  Das Datengenerierungsmodul wird in Form eines Pakets dargestellt, in dem f√ºr jedes Objekt des zu testenden Systems (Tabelle in der Datenbank) eine spezielle Prozedur erstellt wird, die dort Daten einf√ºgt.  Bei diesem Verfahren werden die Standardwerte so weit wie m√∂glich gef√ºllt, wodurch die Erstellung von Objekten per Fingerklick sichergestellt wird.  Zur Vereinfachung der Verwendung wurden Vorlagen f√ºr die generierten Daten erstellt.  Erstellen Sie beispielsweise einen Kunden eines bestimmten Alters mit einem Testtelefon und einem perfekten Kauf. </li><li>  <b>Autotests sollten zu einem f√ºr Ihr System akzeptablen Zeitpunkt ausgef√ºhrt werden.</b>  Aus diesem Grund wurde ein t√§glicher n√§chtlicher Start organisiert, dessen Ergebnisse einen Bericht √ºber die Ergebnisse erstellen und per Unternehmenspost an das gesamte Entwicklungsteam senden.  Nach dem Wiederherstellen alter und dem Erstellen neuer Autotests betrug die Gesamtbetriebszeit 30 Minuten.  Eine solche Leistung war f√ºr alle geeignet, da der Start nach Stunden erfolgte. <br><br>  Aber ich musste daran arbeiten, die Arbeitsgeschwindigkeit zu optimieren.  Die Aktualisierung des Loyalit√§tssystems f√ºr die Produktion erfolgt nachts.  Im Rahmen einer der Ver√∂ffentlichungen musste ich nachts dringend √Ñnderungen vornehmen.  Das halbst√ºndige Warten auf die Ergebnisse der Autotests um drei Uhr morgens machte die f√ºr die Ver√∂ffentlichung verantwortliche Person nicht gl√ºcklich (feurige Gr√º√üe an Alexei Vasyukov!), Und am n√§chsten Morgen wurden viele freundliche Worte zu unserem System gesagt.  Basierend auf den Ergebnissen wurde jedoch ein 5-Minuten-Arbeitsstandard festgelegt. <br><br>  Um die Leistung zu beschleunigen, haben wir zwei Methoden verwendet: Autotests wurden in drei parallelen Threads ausgef√ºhrt, was aufgrund der Architektur unseres Loyalit√§tssystems sehr praktisch ist.  Und wir haben den Ansatz aufgegeben, wenn der Autotest keine Testdaten f√ºr sich selbst erstellt, sondern versucht, etwas Passendes im System zu finden.  Nach den √Ñnderungen wurde die Gesamtbetriebszeit auf 3-4 Minuten reduziert. </li><li>  <b>Das Projekt mit automatischen Tests sollte an verschiedenen St√§nden eingesetzt werden k√∂nnen.</b>  Zu Beginn der Reise gab es Versuche, eigene Batch-Dateien zu schreiben, aber es wurde klar, dass eine selbstgeschriebene automatisierte Installation ein v√∂lliger Horror war, und wir wandten uns industriellen L√∂sungen zu.  Aufgrund der Tatsache, dass das Projekt viel direkten Code enth√§lt (zun√§chst speichern wir den Code f√ºr Autotests) und sehr wenig Daten (die Hauptdaten sind Metadaten zu Autotests), stellte sich heraus, dass es sehr einfach ist, Liquibase in das Projekt einzuf√ºhren. <br><br>  Es ist eine datenbankunabh√§ngige Open Source-Bibliothek zum Verfolgen, Verwalten und Anwenden von Datenbankschema√§nderungen.  Verwaltet √ºber Befehlszeile oder Frameworks wie Apache Maven.  Das Funktionsprinzip von Liquibase ist recht einfach.  Wir haben ein auf bestimmte Weise organisiertes Projekt, das aus √Ñnderungen oder Skripten besteht, die auf den Zielserver √ºbertragen werden m√ºssen, und Steuerdateien, die bestimmen, in welcher Reihenfolge und mit welchen Parametern diese √Ñnderungen installiert werden sollen. <br><br>  Auf DBMS-Ebene wird eine spezielle Tabelle erstellt, in der Liquibase das Ausf√ºhrungsprotokoll speichert.  Jede √Ñnderung hat einen berechneten Hash, der jedes Mal zwischen dem Projekt und dem Status in der Datenbank verglichen wird.  Dank Liquibase k√∂nnen wir unsere System√§nderungen problemlos auf jeden Schaltkreis √ºbertragen.  Autotests werden jetzt in Test- und Release-Schleifen sowie in Containern (pers√∂nlichen Schleifen von Entwicklern) ausgef√ºhrt. </li></ol><br><br><img src="https://habrastorage.org/webt/n4/sl/nu/n4slnu-z9xje4obstq1glb8gfqi.png"><br><br>  Lassen Sie uns also √ºber die Ergebnisse der Anwendung unseres Unit-Test-Systems sprechen. <br><br><ol><li>  Zun√§chst sind wir nat√ºrlich davon √ºberzeugt, dass wir begonnen haben, bessere Software zu entwickeln.  Autotests werden t√§glich ausgef√ºhrt und finden jedes Jahr Dutzende von Fehlern.  Dar√ºber hinaus h√§ngen einige dieser Fehler nur indirekt mit der Funktionalit√§t zusammen, die wir wirklich √§ndern wollten.  Es gibt gro√üe Zweifel, dass diese Fehler durch manuelle Tests gefunden wurden. </li><li>  Das Team hat das Vertrauen gewonnen, dass die spezifische Funktionalit√§t korrekt funktioniert ... Zun√§chst geht es um unsere kritischen Prozesse.  Zum Beispiel hatten wir in den letzten sechs Monaten trotz der √Ñnderungen in den Ver√∂ffentlichungen keine Probleme mit der Verteilung von Rabatten und Boni auf den Scheck, obwohl in den vorherigen Perioden in einigen Intervallen Fehler aufgetreten sind </li><li>  Wir konnten die Anzahl der Testiterationen reduzieren.  Aufgrund der Tatsache, dass Autotests f√ºr neue Funktionen geschrieben wurden, erhalten Analytics- und Teilzeit-Tester Code mit h√∂herer Qualit√§t, weil  Es wurde bereits verifiziert. </li><li>  Ein Teil der Entwicklungen des automatisierten Testens wird von Entwicklern verwendet.  Beispielsweise werden Testdaten f√ºr Container mithilfe des Objekterzeugungsmoduls erstellt. </li><li>  Es ist wichtig, dass wir die ‚ÄûEinf√ºhrung‚Äú eines Systems automatisierter Tests durch Entwickler entwickelt haben.  Es besteht Verst√§ndnis daf√ºr, dass dies wichtig und n√ºtzlich ist.  Und aus eigener Erfahrung kann ich sagen, dass dies weit davon entfernt ist.  Autotests m√ºssen geschrieben, gepflegt und weiterentwickelt werden, die Ergebnisse m√ºssen analysiert werden, und oft sind diese Zeitkosten einfach nicht wert.  Es ist viel einfacher, in die Produktion zu gehen und dort Probleme zu l√∂sen.  Bei uns stellen sich Entwickler an und bitten darum, ihre Funktionalit√§t durch automatische Tests abzudecken. </li></ol><br><br><h2>  Was weiter </h2><br><img src="https://habrastorage.org/webt/_u/mq/d4/_umqd4jtmujx7ugli9bwhgrhdj4.png"><br><br>  Lassen Sie uns √ºber die Entwicklungspl√§ne f√ºr das automatisierte Testprojekt sprechen. <br><br>  W√§hrend das Loyalit√§tssystem von Sportmaster noch am Leben ist und sich weiterentwickelt, ist es nat√ºrlich auch m√∂glich, Selbsttests fast endlos zu entwickeln.  Daher ist die Hauptentwicklungsrichtung die Erweiterung des Versorgungsgebiets. <br><br>  Mit zunehmender Anzahl von Autotests wird die Gesamtzeit ihrer Arbeit stetig zunehmen, und wir m√ºssen erneut auf das Thema Produktivit√§t zur√ºckkommen.  Die L√∂sung besteht h√∂chstwahrscheinlich darin, die Anzahl der parallelen Threads zu erh√∂hen. <br><br>  Dies sind jedoch offensichtliche Entwicklungspfade.  Wenn wir √ºber etwas nicht Triviales sprechen, heben wir Folgendes hervor: <br><br><ol><li>  Derzeit werden Autotests auf DBMS-Ebene verwaltet, d. H.  Sie ben√∂tigen PL / SQL-Kenntnisse, um erfolgreich zu arbeiten.  Wenn n√∂tig, steuern Sie das System (z. B. Starten oder Erstellen von Metadaten). Mit Jenkins oder √§hnlichem k√∂nnen Sie eine Art Admin-Panel erstellen. </li><li>  Jeder liebt quantitative und qualitative Indikatoren.  F√ºr automatisierte Tests ist eine solche universelle Metrik Code Coverage oder Code Coverage Metrics.  Mit diesem Indikator k√∂nnen wir bestimmen, wie viel Prozent des Codes unseres Testsystems von Autotests abgedeckt werden.  Ab Version 12.2 bietet Oracle die M√∂glichkeit, diese Metrik zu berechnen, und schl√§gt die Verwendung des Standardpakets DBMS_PLSQL_CODE_COVERAGE vor. <br><br>  Unser Autotest-System ist etwas mehr als ein Jahr alt, und vielleicht ist es jetzt an der Zeit, die Abdeckung zu bewerten.  In meinem letzten Projekt (ein Projekt, das nicht von Sportmaster stammt) ist es passiert.  Ein Jahr nach der Arbeit an Autotests hat sich das Management zum Ziel gesetzt, zu bewerten, wie viel Prozent des Codes wir abdecken.  Mit einer Abdeckung von mehr als 1% w√ºrde sich das Management freuen.  Wir, die Entwickler, haben ein Ergebnis von ca. 10% erwartet.  Die gemessene Codeabdeckung f√ºr Schrauben ergab 20%.  Um zu feiern, haben wir uns einen Preis geholt, aber wie wir uns daf√ºr entschieden haben und wohin wir sp√§ter gingen, ist eine ganz andere Geschichte. </li><li>  Automatische Tests k√∂nnen die exponierten Webdienste √ºberpr√ºfen.  Mit Oracle k√∂nnen Sie dies tun, und wir werden nicht mehr auf eine Reihe von Problemen sto√üen. </li><li>  Und nat√ºrlich kann unser automatisiertes Testsystem auf ein anderes Projekt angewendet werden.  Unsere L√∂sung ist universell und erfordert nur die Verwendung von Oracle.  Ich habe geh√∂rt, dass bei anderen Projekten von Sportmaster ein Interesse an automatischen Tests besteht und wir vielleicht zu ihnen gehen werden. </li></ol><br><h2>  Schlussfolgerungen </h2><br>  Fassen wir zusammen.  F√ºr das Projekt, das Loyalit√§tssystem in Sportmaster, ist es uns gelungen, ein automatisiertes Testsystem zu implementieren.  Grundlage ist die utPLSQL-L√∂sung von Stephen Feuerstein.  Um utPLSQL herum gibt es den Autotest-Code und zus√§tzliche selbstgeschriebene Module: Startmodul, Datengenerierungsmodul und andere.  Autotests werden t√§glich ausgef√ºhrt und funktionieren vor allem und bringen Vorteile.  Wir sind √ºberzeugt, dass wir begonnen haben, qualitativ hochwertigere Software herauszubringen.  Gleichzeitig ist die resultierende L√∂sung universell und kann frei auf jedes Projekt angewendet werden, bei dem automatisierte Tests unter Oracle DBMS organisiert werden m√ºssen. <br><br>  <i>PS Dieser Artikel ist nicht sehr spezifisch: Es gibt viel Text und fast keine technischen Beispiele.</i>  <i>Wenn das Thema global interessant ist, k√∂nnen wir es fortsetzen und mit einer Fortsetzung zur√ºckkehren, in der wir Ihnen mitteilen, was sich in den letzten sechs Monaten ge√§ndert hat, und Codebeispiele geben.</i> <i><br><br></i>  <i>Schreiben Sie Kommentare, wenn es Punkte gibt, auf die es sich lohnt, sich in Zukunft zu konzentrieren, oder wenn Fragen offengelegt werden m√ºssen.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465047/">https://habr.com/ru/post/de465047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465031/index.html">Innenansicht: RFID in der modernen Welt. Teil 2: Chinesisches RFID</a></li>
<li><a href="../de465033/index.html">Lassen Sie sich die Powercheck-Technologie einfallen</a></li>
<li><a href="../de465039/index.html">Sicherheitswoche 35: Statistiken √ºber durchgesickerte Passw√∂rter und Angriffe √ºber Google Drive</a></li>
<li><a href="../de465041/index.html">So f√ºhren Sie eine BTC-Transaktion durch, ohne kleine M√ºnzen einzuzahlen</a></li>
<li><a href="../de465045/index.html">Kali Linux NetHunter f√ºr Android: Warum und wie installieren?</a></li>
<li><a href="../de465049/index.html">10 B√ºcher √ºber agiles Projektmanagement, die es wert sind, 2020 mitgenommen zu werden</a></li>
<li><a href="../de465055/index.html">Sechs F√§higkeiten, um Ihre Data Science-Karriere auf die n√§chste Stufe zu bringen.</a></li>
<li><a href="../de465057/index.html">Container und Windows. Von Hello World zu Kubernetes. Erster Teil, Einf√ºhrung</a></li>
<li><a href="../de465059/index.html">PoE in einer Entfernung von mehr als 200 Metern. √úberwachung und automatischer Neustart von PoE-Clients</a></li>
<li><a href="../de465061/index.html">Warum ist es besser, anstelle einer viert√§gigen Arbeitswoche an einen sechsst√ºndigen Arbeitstag zu denken?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>