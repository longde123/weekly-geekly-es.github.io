<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻‍🤝‍🧑🏻 🏳️ 👩🏿‍🤝‍👩🏾 关于RTOS的全部真相。 第25条。 数据通道：简介和基本服务 👩‍👧‍👦 🧑🏽‍🤝‍🧑🏻 🔢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="短暂休息后，我们将继续发布Colin Walls的《关于RTOS的全部真相》的译文。 这次，我们将讨论数据传输通道（以下称为通道），在先前的一篇文章（即＃5 ）中已经提到过。 与邮箱（ ＃21和＃22 ）或队列（ ＃23和＃24 ）相比，通道提供了更灵活的方式来在任务之间传输简单消息。 

 该系列...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第25条。 数据通道：简介和基本服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433046/"><img src="https://habrastorage.org/webt/kk/zy/_j/kkzy_j5jujof9pkubwwgfiapg3o.jpeg"><br><br> 短暂休息后，我们将继续发布Colin Walls的《关于RTOS的全部真相》的译文。 这次，我们将讨论数据传输通道（以下称为通道），在先前的一篇文章（即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃5</a> ）中已经提到过。 与邮箱（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃21</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃22</a> ）或队列（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃23</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃24</a> ）相比，通道提供了更灵活的方式来在任务之间传输简单消息。 <br><a name="habracut"></a><br> 该系列中的先前文章： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第23条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号量：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十九条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号灯：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十八条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：助手服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十七条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <br><br><h2> 使用渠道 </h2><br> 在Nucleus SE中，通道是在组装阶段识别的。 每个应用程序最多可具有16个通道。 如果在应用程序中未配置任何通道，则与该通道相关的数据结构或服务调用代码均不会包含在该应用程序中。 <br><br> 数据传输通道-一组存储，每个存储的大小允许您放置一个用户指定长度的数据元素（以字节为单位）。 以几种任务可以安全使用它的方式来控制对数据的访问。 任务可以将数据写入通道，直到所有区域都已满为止。 任务可以从通道读取数据，并且根据FIFO原理接收数据。 根据所选的API调用设置和Nucleus SE配置，尝试向拥挤的通道写入数据或从空通道读取数据可能会导致错误或任务挂起。 <br><br><h2> 通道和队列 </h2><br>  Nucleus SE还支持在先前文章（＃23和＃24）中已详细讨论的队列。 通道和队列之间的主要区别在于消息的大小。 队列包含由单个ADDR类型的变量（通常是指针）组成的消息。 该通道包含任意大小的消息，这些消息对于应用程序中的每个通道都是独立的，并在参数设置期间分配。 <br><br><h2> 频道设定 </h2><br><h3> 通道数 </h3><br> 与大多数Nucleus SE对象一样，通道自定义由<b>nuse_config.h中</b>的<b>#define</b>指令<b>控制</b> 。 主要参数是<b>NUSE_PIPE_NUMBER</b> ，它确定在应用程序中配置的通道数。 默认情况下，该值为零（即应用程序中没有通道），并且最多可以使用16个值。不正确的值将导致编译错误，该错误将通过检入<b>nuse_config_check.h</b>文件（此文件包含在<b>nuse_config.c中</b>并生成）来生成。 ），这将触发<b>#error</b>指令。 <br><br> 选择一个非零值将用作通道的主要激活器。 此参数用于确定数据结构，其大小取决于其值（在下一篇文章中将对此进行更多说明）。 此外，非零值会激活API设置。 <br><br><h3> 激活API调用 </h3><br>  Nucleus SE中的每个API函数（实用程序调用）在<b>nuse_config.h中</b>都有<b>#define</b> enable指令。 对于通道，这些符号是： <br><br>  <b>NUSE_PIPE_SEND</b> <br>  <b>NUSE_PIPE_RECEIVE</b> <br>  <b>NUSE_PIPE_JAM</b> <br>  <b>NUSE_PIPE_RESET</b> <br>  <b>NUSE_PIPE_INFORMATION</b> <br>  <b>NUSE_PIPE_COUNT</b> <br><br> 默认情况下，它们设置为<b>FALSE</b> ，因此所有服务调用都被禁用，从而阻止了包含实现它们的代码。 要在应用程序中配置通道，您需要选择必要的API服务调用并将其设置为<b>TRUE</b> 。 <br><br> 以下是默认<b>nuse_config.h</b>文件中的代码片段。 <br><br><pre><code class="plaintext hljs">#define NUSE_PIPE_NUMBER 0 /* Number of pipes in the system - 0-16 */ /* Service call enablers */ #define NUSE_PIPE_SEND FALSE #define NUSE_PIPE_RECEIVE FALSE #define NUSE_PIPE_JAM FALSE #define NUSE_PIPE_RESET FALSE #define NUSE_PIPE_INFORMATION FALSE #define NUSE_PIPE_COUNT FALSE</code> </pre> <br> 如果已激活API函数，但应用程序中没有任何通道（始终启用<b>NUSE_Pipe_Count（）</b>除外<b>）</b> ，则会发生编译错误。 如果您的代码使用尚未激活的API调用，则会发生布局错误，因为实现代码未包含在应用程序中。 <br><br><h2> 开销频道通话 </h2><br>  Nucleus RTOS支持十个通道开销，这些开销提供以下功能： <br><br><ul><li> 向频道发送消息。  Nucleus SE在<b>NUSE_Pipe_Send（）</b>函数中实现。 </li><li> 接收来自频道的消息。  Nucleus SE在<b>NUSE_Pipe_Receive（）</b>函数中实现。 </li><li> 将消息发送到频道顶部。  Nucleus SE在<b>NUSE_Pipe_Jam（）中实现</b> 。 </li><li> 通过释放所有挂起的任务（重置）将通道恢复到未使用状态。 在Nucleus SE中，在<b>NUSE_Pipe_Reset（）中实现</b> 。 </li><li> 获取有关特定频道的信息。  Nucleus SE是使用<b>NUSE_Pipe_Information（）实现的</b> 。 </li><li> 返回应用程序中当前配置的通道的计数器。  Nucleus SE是使用<b>NUSE_Pipe_Count（）实现的</b> 。 </li><li> 向应用程序添加一个新通道（创建）。 在Nucleus SE中未实现。 </li><li> 从应用程序中删除频道。 在Nucleus SE中未实现。 </li><li> 返回指向应用程序中所有通道的指针。 在Nucleus SE中未实现。 </li><li> 向通道中暂停的所有任务发送消息（广播）。 在Nucleus SE中未实现。 </li></ul><br> 请更详细地考虑每个服务调用的实现。 <br><br><h2> 服务呼叫以写入和读取频道 </h2><br> 在通道上执行的基本操作是记录（也称为发送）和读取（也称为接收消息）。 另外，可以在通道的开始处记录数据（卡塞）。  Nucleus RTOS和Nucleus SE为这些操作提供了三个主要的API调用，下面将对其进行讨论。 <br><br><h3> 频道录制 </h3><br>  Nucleus RTOS API实用程序调用通道的写操作非常灵活，如果无法立即完成操作（例如，尝试写拥挤的通道），则可以隐式或超时地暂停任务。  Nucleus SE面临类似的挑战，但是任务暂停是可选的，并且未实现超时。 <br><br>  Nucleus RTOS还提供频道广播服务，但Nucleus SE不支持该服务。 下一篇文章的“未实现的API调用”部分将对此进行描述。 <br><br>  <b><i>调用以将消息发送到Nucleus RTOS中的频道</i></b> <br><br> 服务电话原型： <br><br>  <b>状态NU_Send_To_Pipe（NU_PIPE *管道，VOID *消息，未签名的大小，未签名的挂起）;</b> <br><br> 参数： <br><br>  <b>pipe-</b>指向用户提供的通道控制块的指针； <br>  <b>message-</b>指向要发送的消息的指针； <br>  size-消息中的字节数。 如果通道支持可变长度消息，则此参数必须等于或小于通道支持的消息长度。 如果通道支持固定长度的消息，则此参数必须等于通道支持的消息的大小； <br>  <b>暂停</b> -任务<b>暂停</b>的规范，可以采用值<b>NU_NO_SUSPEND</b> ， <b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NU_INVALID_PIPE-</b>指向通道的无效指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SIZE-</b>消息大小与通道支持的消息大小不兼容； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程挂起； <br>  <b>NU_PIPE_FULL-</b>通道已满，未指定任务挂起的类型； <br>  <b>NU_TIMEOUT-</b>通道已满，即使在任务暂停了指定的时间后也是如此； <br>  <b>NU_PIPE_DELETED-</b>任务挂起时删除了通道； <br>  <b>NU_PIPE_RESET</b> —任务挂起时重置了通道。 <br><br>  <b><i>呼叫以将消息发送到Nucleus SE中的频道</i></b> <br><br> 该API服务调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Pipe_Send（NUSE_PIPE管道，U8 *消息，U8挂起）;</b> <br><br> 参数： <br><br>  <b>pipe-</b>使用通道的索引（ID）； <br>  <b>message-</b>指向要发送的消息的指针（给定通道允许的长度字节序列）； <br>  <b>pause-</b>任务挂起规范，可以使用值<b>NUSE_NO_SUSPEND</b>和<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_PIPE-</b>无效的频道索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关的线程中挂起，或者在禁用任务锁定时挂起； <br>  <b>NUSE_PIPE_FULL-</b>通道已满，未指定任务挂起的类型； <br>  <b>NUSE_PIPE_WAS_RESET-</b>任务挂起时重置了通道。 <br><br>  <b><i>在Nucleus SE中实施频道发布</i></b> <br><br> 根据是否激活对API调用的支持以阻止（暂停）任务，使用条件编译选择API功能代码<b>NUSE_Pipe_Send（）的版本</b> （检查参数之后）。 下面我们考虑这两种选择。 <br><br> 如果禁用了锁定，则此API调用的代码非常简单： <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br> 该函数检查通道中是否有可用空间，并使用<b>NUSE_Pipe_Head []</b>索引将消息放置在通道数据区域中。 <br><br> 如果激活了任务锁定，则代码将变得更加复杂： <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_FULL; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br> 一些澄清可能会有所帮助。 <br><br> 该代码包含在<b>do ... while循环中</b> ，该<b>循环</b>在任务暂停参数为<b>NUSE_SUSPEND时运行</b> 。 <br><br> 如果通道已满，并且suspend参数为<b>NUSE_NO_SUSPEND</b> ，则API调用以值<b>NUSE_PIPE_FULL</b>结束。 如果<b>suspend</b>参数为<b>NUSE_SUSPEND</b> ，任务将暂停。 完成后（即，任务恢复时），如果返回值为<b>NUSE_SUCCESS</b> ，即由于读取消息（而不是因为通道已重置）而恢复了任务，则代码将返回到循环的开头。 <br><br> 如果通道未满，则使用<b>NUSE_Pipe_Head []</b>索引将提供的消息保存在通道数据区域中。 它检查通道是否已暂停任务（待处理消息）。 如果存在此类任务，则将恢复第一个任务。  <b>暂</b> <b>挂</b>变量设置为<b>NUSE_NO_SUSPEND</b> ，并且API调用以值<b>NUSE_SUCCESS</b>完成。 <br><br><h3> 从频道阅读 </h3><br> 从通道读取的Nucleus RTOS API调用非常灵活，如果无法立即完成操作（例如，当您尝试读取空通道时），则可以隐式或超时地暂停任务。  Nucleus SE具有类似的实用程序调用，但是任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>Nucleus RTOS中的频道读取挑战</i></b> <br><br> 服务电话原型： <br><br>  <b>状态NU_Receive_From_Pipe（NU_PIPE *管道，VOID *消息，未签名的大小，未签名的* actual_size，未签名的挂起）;</b> <br><br> 参数： <br><br>  <b>pipe-</b>指向用户提供的通道控制块的指针； <br>  <b>message-</b>指向接收到的消息的存储的指针； <br>  size-消息中的字节数。 必须与创建频道时指定的消息大小匹配； <br>  <b>挂起</b> -任务挂起规范，可以采用<b>NU_NO_SUSPEND</b> ， <b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_PIPE-</b>指向通道的无效指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程中暂停任务； <br>  <b>NU_PIPE_EMPTY-</b>通道为空，并且未指定任务挂起的类型； <br>  <b>NU_TIMEOUT-</b>即使在任务暂停指定的超时值后，通道也为空； <br>  <b>NU_PIPE_DELETED-</b>任务挂起时删除了通道； <br>  <b>NU_PIPE_RESET-</b>任务挂起时删除了通道。 <br><br>  <b><i>Nucleus SE中的频道阅读挑战</i></b> <br><br> 该API服务调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Pipe_Receive（NUSE_PIPE管道，U8 *消息，U8挂起）;</b> <br><br> 参数： <br><br>  <b>pipe-</b>使用通道的索引（ID）； <br>  <b>message-</b>指向接收到的消息的存储器的指针（字节序列，其长度与通道消息的大小一致）； <br>  <b>suspend-</b>任务挂起规范，可以采用<b>NUSE_NO_SUSPEND</b>和<b>NU_SUSPEND</b>值。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_PIPE-</b>无效的频道索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关的线程中挂起任务，或者禁用了对任务挂起的支持； <br>  <b>NUSE_PIPE_EMPTY-</b>通道为空，并且未指定任务挂起的类型； <br>  <b>NUSE_PIPE_WAS_RESET-</b>任务挂起时重置了通道。 <br><br>  <b><i>在Nucleus SE中实现Feed阅读器</i></b> <br><br> 通过条件编译选择API函数代码<b>NUSE_Pipe_Receive（）的版本</b> （检查参数之后），具体取决于是否激活了对块（暂停任务）的API调用的支持。 我们将在下面考虑这两个选项。 <br><br> 如果禁用了锁定，则此API调用的代码非常简单： <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { return_value = NUSE_PIPE_EMPTY; } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; *actual_size = msgsize; return_value = NUSE_SUCCESS; }</code> </pre><br> 该函数检查通道中是否存在消息，并使用<b>NUSE_Pipe_Tail []</b>索引从通道数据区域中获取消息，然后通过消息指针返回数据。 <br><br> 如果激活了任务锁定，则代码将变得更加复杂： <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_EMPTY; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked */ /* on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } *actual_size = msgsize; return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br> 一些澄清可能会有所帮助。 <br><br> 该代码包含在<b>do ... while循环中</b> ，该<b>循环</b>在任务暂停参数为<b>NUSE_SUSPEND时运行</b> 。 <br><br> 如果通道为空，并且suspend参数为<b>NUSE_NO_SUSPEND</b> ，则API调用以值<b>NUSE_PIPE_EMPTY</b>结束。 如果suspend参数为<b>NUSE_SUSPEND</b> ，任务将暂停。 完成后（即，任务恢复时），如果返回值为<b>NUSE_SUCCESS</b> ，即由于已发送消息（而不是因为通道已重置）而恢复了任务，则代码将返回循环的开头。 <br><br> 如果通道包含消息，则使用<b>NUSE_Pipe_Tail []</b>索引返回存储的消息。 检查此通道上是否有任何暂停（等待发送）的任务。 如果存在此类任务，则将恢复第一个任务。 将suspend变量设置为<b>NUSE_NO_SUSPEND</b> ，并且该API调用以<b>NUSE_SUCCESS</b>代码终止。 <br><br><h3> 记录到频道的开头 </h3><br>  Nucleus RTOS API实用程序调用非常灵活，可以写入通道的开头，如果无法立即完成操作（例如，尝试写入完整通道），则可以隐式或超时地暂停任务。  Nucleus SE具有类似的实用程序调用，但是任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>调用以写入Nucleus RTOS中通道的开头</i></b> <br><br> 服务电话原型： <br><br>  <b>状态NU_Send_To_Front_Of_Pipe（NU_PIPE *管道，VOID *消息，UNSIGNED大小，UNSIGINED挂起）;</b> <br><br> 参数： <br><br>  <b>pipe-</b>指向用户提供的通道控制块的指针； <br>  <b>message-</b>指向要发送的消息的指针； <br>  size-消息中的字节数。 如果通道支持可变长度消息，则此参数必须等于或小于通道支持的消息的大小。 如果通道支持定长消息，则此参数必须与通道支持的消息大小匹配。 <br>  <b>挂起</b> -任务挂起规范，可以采用<b>NU_NO_SUSPEND</b> ， <b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_PIPE-</b>指向通道的无效指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SIZE-</b>消息大小与通道支持的消息大小不兼容； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程挂起； <br>  <b>NU_PIPE_FULL-</b>通道已满，未指定任务挂起的类型； <br>  <b>NU_TIMEOUT-</b>通道已满，即使在任务暂停了指定的时间后也是如此； <br>  <b>NU_PIPE_DELETED-</b>任务挂起时删除了通道； <br>  <b>NU_PIPE_RESET</b> —任务挂起时重置了通道。 <br><br>  <b><i>调用以写入Nucleus SE中通道的开头</i></b> <br><br> 该实用程序调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Pipe_Jam（NUSE_PIPE管道，ADDR *消息，U8挂起）；</b> <br><br> 参数： <br><br>  <b>pipe-</b>使用通道的索引（ID）； <br>  <b>message-</b>指向要发送的消息的指针，该字节的序列等于通道中已配置的消息大小； <br>  <b>pause-</b>任务挂起规范，可以为<b>NUSE_NO_SUSPEND</b>或<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_PIPE-</b>无效的频道索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关的线程中挂起任务，或者在禁用任务锁时尝试将其挂起； <br>  <b>NUSE_PIPE_FULL-</b>通道已满，未指定任务挂起的类型； <br>  <b>NUSE_PIPE_WAS_RESET-</b>任务挂起时重置了通道。 <br><br>  <b><i>在Nucleus SE中实现频道条目记录</i></b> <br><br>  <b>NUSE_Pipe_Jam（）</b>函数的变体代码与<b>NUSE_Pipe_Send（）</b>非常相似，除了使用索引<b>NUSE_Pipe_Tail []</b>在其中存储数据外，因此： <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { if (NUSE_Pipe_Tail[pipe] == 0) { NUSE_Pipe_Tail[pipe] = (NUSE_Pipe_Size[pipe] - 1) * msgsize; } else { NUSE_Pipe_Tail[pipe] -= msgsize; } data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br> 在下一篇文章中，我们将考虑与通道相关的其他服务调用以及相应的数据结构。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colin的</a>专业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，电子邮件：colin_walls@mentor.com。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433046/">https://habr.com/ru/post/zh-CN433046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433034/index.html">注射</a></li>
<li><a href="../zh-CN433036/index.html">在小型企业中组织IT的技巧</a></li>
<li><a href="../zh-CN433038/index.html">营销人员为什么要学习编程</a></li>
<li><a href="../zh-CN433042/index.html">英特尔将于2019年发布具有三维架构Foveros的处理器</a></li>
<li><a href="../zh-CN433044/index.html">OpenJDK源代码包含太多脏话</a></li>
<li><a href="../zh-CN433048/index.html">2019年将如何改变俄罗斯商店</a></li>
<li><a href="../zh-CN433050/index.html">一年内从飞机设计师到程序员，还是如何成为绝地武士</a></li>
<li><a href="../zh-CN433052/index.html">抢购和扁平包装-社区的悲剧</a></li>
<li><a href="../zh-CN433054/index.html">会话堆栈中的指针，或正则表达式字节码</a></li>
<li><a href="../zh-CN433056/index.html">通讯部收紧有关外来元素的软件规定</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>