<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â¸ï¸ ğŸ—ï¸ ğŸ‘©ğŸ¼â€âš•ï¸ Memilih struktur data yang tepat di Swift ğŸŒ§ï¸ ğŸ”’ ğŸ™ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo lagi. Sebelum berangkat untuk akhir pekan kami ingin berbagi dengan Anda terjemahan materi yang disiapkan khusus untuk kursus dasar "iOS-develope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memilih struktur data yang tepat di Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/468239/">  <i>Halo lagi.</i>  <i>Sebelum berangkat untuk akhir pekan kami ingin berbagi dengan Anda terjemahan materi yang disiapkan khusus untuk kursus dasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"iOS-developer</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"</a></i> <br><br><img src="https://habrastorage.org/webt/hu/wa/i0/huwai0itmfwakcyvain6xjf2jlm.png"><br><hr><br>  Memutuskan struktur data mana yang digunakan untuk mewakili sekumpulan nilai yang diberikan seringkali jauh lebih sulit daripada yang terlihat.  Karena setiap jenis struktur data dioptimalkan untuk sejumlah kasus penggunaan tertentu, memilih pas yang tepat untuk setiap kumpulan data sering kali dapat berdampak besar pada kinerja kode kita. <a name="habracut"></a><br><br>  Pustaka Swift standar dilengkapi dengan tiga struktur data utama - <code>Array</code> , <code>Dictionary</code> , dan <code>Set</code> , yang masing-masing memiliki serangkaian optimisasi, plus dan minus.  Mari kita lihat beberapa karakteristik mereka, serta kasus-kasus di mana kita mungkin perlu melampaui perpustakaan standar untuk menemukan struktur data yang tepat untuk tujuan kita. <br><br><h3>  Linieritas array </h3><br>  <code>Array</code> mungkin adalah salah satu struktur data yang paling umum digunakan di Swift, dan ada alasan bagus untuk ini.  Ini menyimpan elemen-elemennya secara berurutan, mereka mudah disortir dengan cara yang dapat diprediksi, dan nilai apa pun dapat disimpan di dalamnya: dari struktur ke instance kelas dan koleksi lainnya. <br><br>  Sebagai contoh, di sini kita menggunakan larik untuk menyimpan koleksi bentuk-bentuk yang ditempatkan pada <code>Canvas</code> dalam aplikasi menggambar.  Kemudian, ketika kita perlu merender kanvas menjadi gambar, kita hanya pergi melalui array untuk menggambar setiap elemen menggunakan <code>DrawingContext</code> - sebagai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: [<span class="hljs-type"><span class="hljs-type">Shape</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } }</code> </pre> <br>  Ketika datang ke rendering berurutan dari semua bentuk kita, seperti yang kita lakukan di atas, array cocok.  Array tidak hanya menyimpan elemen-elemen mereka dengan cara yang sangat efisien, mereka juga memiliki urutan pengurutan yang dijamin, yang menyediakan urutan rendering yang dapat diprediksi tanpa harus melakukan pekerjaan tambahan. <br><br>  Namun, seperti semua struktur data lainnya, array memiliki kekurangannya.  Dalam kasus kami, kami akan menemukan salah satu kelemahannya ketika kami ingin menghapus bentuk dari kanvas.  Karena elemen array disimpan oleh indeks, kita harus terlebih dahulu menemukan indeks yang dikaitkan dengan angka sebelum kita dapat menghapusnya: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.firstIndex(of: shape) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) } }</code> </pre> <br>  Pada awalnya, kode di atas mungkin tidak tampak bermasalah, tetapi dapat menjadi hambatan kinerja untuk setiap kanvas yang mengandung sejumlah besar bentuk, karena <code>firstIndex</code> linier (O (N)) dalam hal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompleksitas waktu</a> . <br><br>  Meskipun kita dapat mengatasi keterbatasan ini di mana kita menggunakan jenis kanvas kita.  Misalnya, selalu mengacu pada angka berdasarkan indeks, dan bukan berdasarkan nilai atau ID - ini akan membuat kode kita lebih kompleks dan lebih rapuh, karena kita harus selalu memastikan bahwa indeks kita tidak kedaluwarsa ketika kanvas yang kita gunakan bekerja dengan akan berubah. <br><br><h3>  Set kecepatan </h3><br>  Sebagai gantinya, mari kita lihat apakah kita dapat mengoptimalkan <code>Canvas</code> itu sendiri dengan mengubah struktur data yang mendasarinya.  Mempertimbangkan masalah di atas, salah satu ide awal kami mungkin menggunakan <code>Set</code> (set) alih-alih <code>Array</code> .  Seperti yang telah kita bahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kekuatan set di Swift</a> , salah satu keuntungan signifikan set array adalah bahwa kedua insert dan delete selalu dapat dilakukan dalam waktu yang konstan (O (1)), karena item disimpan oleh nilai hash, bukan oleh indeks. <br><br>  Dengan memperbarui <code>Canvas</code> untuk menggunakan set, kita mendapatkan yang berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes: <span class="hljs-type"><span class="hljs-type">Set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { shapes.remove(shape) } }</code> </pre> <br>  Sekali lagi, kode di atas mungkin terlihat benar, dan bahkan dikompilasi tanpa masalah.  Namun, meskipun kami memecahkan masalah penghapusan, kami juga kehilangan urutan render stabil kami - karena, tidak seperti array, set tidak memberi kami urutan penyortiran yang dijamin - yang merupakan batu sandungan dalam situasi ini, karena sepertinya kami akan menggambar bentuk kustom di secara acak. <br><br><h3>  Indeks Pengindeksan </h3><br>  Ayo terus bereksperimen.  Sekarang mari kita lihat apakah kita dapat mengoptimalkan <code>Canvas</code> dengan memperkenalkan <code>Dictionary</code> , yang memungkinkan kita untuk mencari indeks bentuk apa pun berdasarkan ID-nya.  Kami akan mulai dengan mengubah tingkat akses untuk array <code>shapes</code> kami menjadi <code>private</code> sehingga kami dapat mengontrol penyisipan elemen menggunakan metode <code>add</code> baru.  Dan setiap kali angka baru ditambahkan, kami juga menambahkan indeksnya ke kamus kami: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = shapes.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> indexes[shape.id] = index shapes.append(shape) } }</code> </pre> <br>  Karena sekarang kita selalu tahu pada indeks berapa angka yang diberikan disimpan, kita dapat dengan cepat melakukan penghapusan dalam waktu yang konstan, seperti ketika menggunakan set: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = indexes[shape.id] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(at: index) indexes[shape.id] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Namun, ada bug yang cukup serius dalam implementasi <code>Canvas</code> kami yang baru.  Setiap kali kami menghapus suatu bentuk, sebenarnya kami membatalkan semua indeks yang lebih tinggi dari yang baru saja kami hapus - karena masing-masing elemen ini akan bergerak satu langkah ke awal array.  Kami dapat memecahkan masalah ini dengan menyesuaikan indeks ini setelah setiap penghapusan, tetapi ini akan membawa kami kembali ke wilayah O (N), yang kami coba hindari sejak awal. <br><br>  Implementasi terbaru kami memiliki kelebihan.  Secara umum, menggunakan kombinasi dari dua struktur data dapat menjadi ide bagus dalam situasi seperti itu, karena kita sering dapat menggunakan kekuatan dari satu struktur data untuk mengkompensasi kekurangan yang lain, dan sebaliknya. <br><br>  Jadi, mari kita coba lagi dengan kombinasi yang berbeda, tetapi kali ini mari kita mulai dengan mempertimbangkan <i>persyaratan nyata</i> kita: <br><br><ul><li>  Kami membutuhkan sisipan dan penghapusan agar memiliki kompleksitas waktu yang konstan, dan harus mungkin untuk menghapus angka tanpa mengetahui indeks dasarnya. </li><li>  Kami membutuhkan pesanan penyortiran yang dijamin untuk dapat mempertahankan pesanan rendering yang stabil. </li></ul><br>  Melihat persyaratan di atas, ternyata meskipun kita membutuhkan urutan penyortiran yang stabil, kita sebenarnya tidak membutuhkan indeks.  Ini akan membuat daftar tertaut menjadi sempurna untuk kasus penggunaan kami. <br><br>  Daftar tertaut terdiri dari node, di mana setiap node berisi tautan (atau tautan) ke simpul berikutnya dalam daftar, yang berarti bahwa simpul tersebut dapat diurutkan dengan cara yang dapat diprediksi - tanpa perlu pembaruan indeks apa pun saat item dihapus.  Namun, pustaka standar Swift (sejauh ini) tidak mengandung tipe daftar tertaut, jadi jika kita ingin menggunakannya, kita harus membuatnya terlebih dahulu. <br><br><h3>  Buat daftar tertaut </h3><br>  Mari kita mulai dengan mendeklarasikan struktur <code>List</code> yang akan melacak node pertama dan terakhir dalam daftar kami.  Kami akan membuat kedua properti ini hanya baca di luar tipe kami untuk memastikan konsistensi data: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> }</code> </pre> <br>  Selanjutnya, mari kita buat tipe <code>Node</code> kita (node), yang akan kita buat kelas, karena kita ingin dapat merujuk ke node <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan referensi, dan bukan oleh nilai</a> .  Daftar kami akan terhubung dua kali lipat, yang berarti bahwa setiap node akan berisi tautan ke tetangga berikutnya dan yang sebelumnya.  Setiap node juga akan menyimpan nilai - seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fileprivate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> next: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(value: <span class="hljs-type"><span class="hljs-type">Value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value = value } } }</code> </pre> <br><blockquote>  Alasan kami membuat properti sebelumnya lemah adalah untuk menghindari loop penahan yang akan muncul jika kami menjaga tautan kuat di kedua arah.  Untuk mempelajari lebih lanjut tentang menghindari siklus penyimpanan, lihat artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Manajemen Memori"</a> . </blockquote>  Ini sebenarnya semua kode yang kita butuhkan sehingga nilai-nilai dapat disimpan dalam daftar tertaut kami.  Tetapi ini hanya bagian pertama dari teka-teki itu, seperti pada koleksi lainnya, kami juga ingin dapat mengulanginya dan mengubah isinya.  Mari kita mulai dengan iterasi, yang, berkat desain Swift yang sangat berorientasi pada protokol, dapat dengan mudah diimplementasikan dengan memastikan kepatuhan dengan protokol <code>Sequence</code> dan menerapkan metode <code>makeIterator</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Value</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    ,    : let value = node?.value node = node?.next return value } } }</span></span></code> </pre> <br><blockquote>  Karena iterasi di atas sangat sederhana, kami menggunakan <code>AnyIterator</code> standar <code>AnyIterator</code> untuk menghindari perlunya menerapkan tipe iterator khusus.  Untuk skenario yang lebih kompleks, ini dapat diimplementasikan dengan menambahkan kecocokan ke <code>IteratorProtocol</code> . </blockquote>  Selanjutnya, mari kita tambahkan API untuk mengubah daftar tertaut kami, dimulai dengan sisipan.  Kami akan memperluas <code>List</code> dengan metode <code>append</code> , yang menambahkan simpul baru untuk nilai yang dimasukkan dan kemudian mengembalikan simpul ini - seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value: Value)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(value: value) node.previous = lastNode lastNode?.next = node lastNode = node <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { firstNode = node } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } }</code> </pre> <br><blockquote>  Di atas, kita menggunakan atribut <code>@discardableResult</code> , yang memberi tahu kompiler untuk tidak menghasilkan peringatan apa pun jika hasil memanggil metode kita tidak digunakan, karena kita tidak selalu tertarik pada simpul yang telah dibuat. </blockquote>  Karena daftar tertaut tidak didasarkan pada indeks, tetapi pada pemeliharaan rantai nilai melalui tautan, penerapan penghapusan hanya masalah memperbarui tetangga berikut dan tetangga sebelumnya dari simpul jarak jauh sehingga mereka saling menunjuk satu sama lain sebagai gantinya: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node)</span></span></span></span> { node.previous?.next = node.next node.next?.previous = node.previous <span class="hljs-comment"><span class="hljs-comment">//  Â« Â»,        ,    : if firstNode === node { firstNode = node.next } if lastNode === node { lastNode = node.previous } } }</span></span></code> </pre> <br>  Berdasarkan hal tersebut di atas, versi awal Daftar kami selesai, dan kami siap untuk memverifikasi dalam tindakan.  Mari perbarui Kanvas untuk menggunakan daftar baru kami, serta kamus yang memungkinkan kami untuk dengan cepat menemukan simpul mana yang cocok dengan ID bentuk yang diberikan: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Canvas</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shapes = <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = [<span class="hljs-type"><span class="hljs-type">Shape</span></span>.<span class="hljs-type"><span class="hljs-type">ID</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Shape</span></span>&gt;.<span class="hljs-type"><span class="hljs-type">Node</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Image</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">DrawingContext</span></span>() shapes.forEach(context.draw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.makeImage() } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { nodes[shape.id] = shapes.append(shape) } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> shape: Shape)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = nodes.removeValue(forKey: shape.id) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } shapes.remove(node) } }</code> </pre> <br>  Sekarang kami memiliki kedua penyisipan dan penghapusan cepat, dan urutan penyortiran yang dapat diprediksi, tanpa perlu menambahkan kompleksitas tambahan untuk proses panggilan - ini sangat keren!  Dan, karena Daftar baru kami adalah tipe yang sepenuhnya universal, sekarang kami dapat menggunakannya kapan pun kami perlu lagi menyimpan nilai tanpa indeks secara linear. <br><br><h3>  Kesimpulan </h3><br>  Terlepas dari kenyataan bahwa struktur data sangat mendasar sehingga dapat ditemukan dalam semua jenis bahasa pemrograman, keputusan tentang yang mana yang akan digunakan dalam setiap situasi tertentu mungkin masih memerlukan pemikiran, pengujian, dan eksperimen yang signifikan, terutama jika kita ingin sehingga kode kita tetap efektif saat set data bertambah. <br><br>  Sangat mungkin juga bahwa struktur data yang sesuai untuk setiap situasi tertentu dapat berubah seiring waktu seiring perubahan persyaratan kami, dan kadang-kadang menggunakan kombinasi beberapa struktur data, dan bukan hanya satu, dapat menjadi cara untuk mencapai karakteristik kinerja yang diperlukan. <br><br>  Kami akan terus mengeksplorasi dunia struktur data dalam artikel berikut ini, dengan fokus pada hal-hal yang belum diimplementasikan di perpustakaan standar.  Seperti banyak hal lain, kadang-kadang kita perlu memperluas pemikiran kita di luar Swift untuk memilih struktur data yang tepat untuk setiap situasi. <br><br>  Anda dapat menemukan saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Twitter</a> atau mengirim email kepada saya jika Anda memiliki pertanyaan, komentar, atau umpan balik. <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468239/">https://habr.com/ru/post/id468239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468229/index.html">Catatan kosong pada JavaScript dan TypeScript</a></li>
<li><a href="../id468231/index.html">Apakah keamanan dalam AEM platform atau masalah implementasi?</a></li>
<li><a href="../id468233/index.html">Cara mengetik memeriksa 4 juta baris kode Python. Bagian 1</a></li>
<li><a href="../id468235/index.html">Cara mengetik memeriksa 4 juta baris kode Python. Bagian 2</a></li>
<li><a href="../id468237/index.html">Cara mengetik memeriksa 4 juta baris kode Python. Bagian 3</a></li>
<li><a href="../id468245/index.html">Kami tidak perlu koreksi terjemahan: penerjemah kami lebih tahu bagaimana ini harus diterjemahkan</a></li>
<li><a href="../id468251/index.html">Tidak ada masa depan</a></li>
<li><a href="../id468253/index.html">Slider gambar sederhana dalam CSS dan Javascript</a></li>
<li><a href="../id468259/index.html">Lima highlights dari KTT Helm 2019 di Amsterdam</a></li>
<li><a href="../id468261/index.html">Gim baru dengan suasana lama di Three.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>