<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏽 👩🏻‍⚕️ 🌩️ System.IO.Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi 👨🏾‍🚒 🧓🏾 🙅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca. Sudah cukup banyak waktu berlalu sejak rilis .NET Core 2.1. Dan inovasi keren seperti Span dan Memori telah dipertimbangkan secara luas,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines - alat yang sedikit dikenal bagi pecinta kinerja tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Halo pembaca.  Sudah cukup banyak waktu berlalu sejak rilis .NET Core 2.1.  Dan inovasi keren seperti Span dan Memori telah dipertimbangkan secara luas, Anda dapat membaca, melihat, dan mendengar banyak tentangnya.  Namun, sayangnya, perpustakaan bernama System.IO.Pipelines tidak menerima perhatian yang sama.  Hampir semua yang ada di topik ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satunya posting</a> yang banyak diterjemahkan dan diposting di rumah.  Pasti harus ada lebih banyak informasi sehingga mereka yang tertarik dapat melihat teknologi dari sudut yang berbeda. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Jadi, perpustakaan ini bertujuan untuk mempercepat pekerjaan dengan pemrosesan data streaming.  Awalnya dibuat dan digunakan oleh tim pengembangan Kestrel (server web lintas platform untuk ASP.NET Core), tetapi saat ini dikirim melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket nuget</a> terpisah. <br>  Sebelum kita mempelajari topik ini, kita dapat membayangkan mekanisme perpustakaan sebagai analog MemoryStream yang ditingkatkan.  Masalah dengan MemoryStream asli adalah jumlah salinan yang berlebihan, yang jelas jika Anda ingat bahwa array byte pribadi digunakan di dalam sebagai buffer.  Misalnya, dalam metode <a href="">Baca</a> dan <a href="">Tulis</a> , penyalinan terlihat jelas.  Jadi, untuk objek yang ingin kita tulis ke aliran, salinan akan dibuat di buffer internal, dan selama membaca, salinan salinan internal akan dikirimkan ke konsumen.  Sepertinya ini bukan penggunaan ruang yang paling rasional. <br>  System.IO.Pipelines tidak bertujuan untuk mengganti semua stream, ini adalah alat tambahan dalam gudang pengembang yang menulis kode kinerja tinggi.  Saya menyarankan agar Anda membiasakan diri dengan metode dan kelas dasar, melihat bagaimana mereka diatur di dalam, dan menganalisis contoh-contoh dasar. <br><br>  Mari kita mulai dengan perangkat internal, pada saat yang sama memeriksa fragmen kode sederhana.  Setelah itu, akan menjadi jelas apa dan bagaimana cara kerjanya, dan bagaimana itu harus digunakan.  Ketika bekerja dengan System.IO.Pipelines, perlu diingat bahwa konsep dasarnya adalah bahwa semua operasi baca-tulis harus dilakukan tanpa alokasi tambahan.  Tetapi beberapa metode yang menarik pada pandangan pertama bertentangan dengan aturan ini.  Karenanya, kode yang Anda coba susah-susah mempercepat mulai mengalokasikan memori untuk data baru dan baru, memuat pengumpul sampah. <br><br>  Perpustakaan internal perpustakaan menggunakan kemungkinan terluas dari versi terbaru bahasa dan rentang waktu, Rentang, Memori, kumpulan objek, ValueTask, dll.  Layak untuk dilihat, setidaknya untuk contoh hebat menggunakan fitur-fitur ini dalam produksi. <br>  Pada suatu waktu, beberapa tidak senang dengan implementasi stream di C #, karena satu kelas digunakan untuk membaca dan menulis.  Tetapi, seperti yang mereka katakan, Anda tidak bisa membuang metode dari kelas.  Bahkan jika aliran tidak mendukung membaca / menulis / memindahkan pointer, properti CanRead, CanWrite dan CanSeek mulai berlaku, yang tampak seperti penopang kecil.  Di sini segalanya berbeda. <br>  Untuk bekerja dengan pipa, 2 kelas digunakan: <a href="">PipeWriter</a> dan <a href="">PipeReader</a> .  Kelas-kelas ini masing-masing berisi sekitar 50 baris dan pseudo-fasad (bukan inkarnasinya yang paling klasik, karena ada kelas tunggal yang tersembunyi di belakangnya, dan tidak banyak) untuk kelas <a href="">Pipa</a> , yang berisi semua logika dasar untuk bekerja dengan data.  Anggota publik - 2 konstruktor, 2 properti get-only - Reader dan Writer, metode Reset (), yang me-reset bidang internal ke keadaan awal mereka sehingga kelas dapat digunakan kembali.  Metode lain untuk pekerjaan disebut menggunakan pseudo-fasad. <br><br><h2>  Untuk memulai kelas Pipa </h2><br>  Instance class menempati 320 byte, yang cukup banyak (hampir sepertiga dari satu kilobyte, 2 objek seperti itu tidak bisa muat dalam memori Manchester Mark I).  Jadi mengalokasikannya dalam jumlah besar adalah ide yang buruk.  Selain itu, makna objek dimaksudkan untuk penggunaan jangka panjang.  Menggunakan kumpulan juga membuat argumen untuk pernyataan ini.  Bagaimanapun, objek yang digunakan di kolam akan hidup selamanya (dalam hal apapun, dalam standar). <br>  Perhatikan bahwa kelas ditandai sebagai tersegel dan aman bagi thread - banyak bagian kode merupakan bagian penting dan dibungkus dengan kunci. <br>  Untuk memulai, buat turunan dari kelas Pipa dan dapatkan objek PipeReader dan PipeWriter menggunakan properti yang disebutkan. <br><br><div class="spoiler">  <b class="spoiler_title">Inisialisasi mudah</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Pertimbangkan metode untuk bekerja dengan pipa: <br>  Untuk merekam melalui PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Lengkap, CancelPendingFlush, OnReaderCompleted. <br>  Untuk membaca melalui PipeReader - AdvanceTo, ReadAsync, TryRead, Lengkap, CancelPendingRead, OnWriterCompleted. <br><br>  Seperti yang dinyatakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> , kelas menggunakan daftar buffer yang terhubung secara tunggal.  Tapi, jelas, mereka tidak lewat antara PipeReader dan PipeWriter - semua logika ada dalam satu kelas.  Daftar ini digunakan untuk membaca dan menulis.  Selain itu, data yang dikembalikan disimpan dalam daftar ini. <br>  Ada juga objek yang menunjukkan awal data untuk dibaca (ReadHead dan indeks), akhir data untuk membaca (ReadTail dan indeks) dan awal tempat untuk menulis (WriteHead dan jumlah byte buffered yang ditulis).  Di sini, ReadHead, ReadTail, dan WriteHead adalah segmen tertentu dari daftar, dan indeks menunjukkan posisi tertentu di dalam segmen tersebut.  Dengan demikian, perekaman dapat dimulai dari tengah segmen, menangkap seluruh segmen berikutnya dan berakhir di tengah ketiga.  Pointer ini bergerak dalam berbagai metode. <br><br><h2>  Memulai dengan Metode PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (Sumber ReadOnlyMemory &lt;byte&gt;, pembatalanToken cancellationToken)</a> </h3><br>  Hanya metode menggoda itu.  Memiliki tanda tangan yang sangat cocok dan trendi - menerima ReadOnlyMemory, asinkron.  Dan banyak yang mungkin tergoda, terutama mengingat bahwa Rentang dan Memori begitu cepat dan keren.  Tapi jangan menyanjung diri sendiri.  Semua yang dilakukan metode ini adalah menyalin ReadOnlyMemory yang diteruskan ke daftar internal.  Dan "salin" berarti panggilan ke metode CopyTo, dan tidak menyalin objek itu sendiri.  Artinya, semua data yang ingin kita rekam akan disalin, sehingga memuat memori.  Metode ini harus dipelajari hanya untuk memastikan bahwa lebih baik tidak menggunakannya.  Ya, dan mungkin untuk beberapa situasi yang jarang, perilaku ini sesuai. <br>  Tubuh metode adalah bagian penting, akses ke sana disinkronkan melalui monitor. <br><br>  Maka timbul pertanyaan, bagaimana menulis sesuatu, jika tidak melalui metode yang paling jelas dan hanya cocok. <br><br><h3>  # 2 <a href="">Memori &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  Metode ini mengambil satu parameter dari tipe integer.  Di dalamnya kita harus menunjukkan berapa banyak byte yang ingin kita tulis (atau lebih, tetapi tidak kurang).  Metode ini memeriksa apakah ada cukup ruang untuk menulis dalam fragmen memori saat ini yang disimpan dalam _writingHeadMemory.  Jika cukup, _writingHeadMemory dikembalikan sebagai Memori.  Jika tidak, maka untuk data yang ditulis ke buffer, tetapi metode FlushAsync tidak dipanggil, dipanggil dan BufferSegment lain dipilih, yang terhubung ke yang sebelumnya (di sini adalah daftar).  Dengan tidak adanya _writingHeadMemory, ini diinisialisasi dengan BufferSegment baru.  Dan alokasi buffer berikutnya adalah bagian penting dan dilakukan di bawah kunci. <br>  Saya sarankan lihat contoh seperti itu.  Pada pandangan pertama, sepertinya kompiler (atau runtime) telah memperdaya iblis. <br><br><div class="spoiler">  <b class="spoiler_title">Iblis</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Tetapi segala sesuatu dalam contoh ini dapat dimengerti dan sederhana. <br>  Saat membuat turunan Pipa, kita bisa melewatkan objek <a href="">PipeOptions</a> dengan opsi untuk membuatnya ke konstruktor. <br><br>  PipeOptions memiliki bidang ukuran segmen minimum default.  Belum lama berselang 2048, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit ini</a> mengubah segalanya, sekarang 4096. Pada saat penulisan, versi dengan 4096 adalah paket pra-rilis, dalam versi rilis terbaru adalah 2048. Ini menjelaskan perilaku contoh pertama.  Jika Anda kritis dalam menggunakan ukuran yang lebih kecil untuk buffer standar, Anda dapat menentukannya dalam contoh tipe PipeOptions. <br><br>  Tetapi dalam contoh kedua, di mana ukuran minimum ditunjukkan, panjangnya tidak cocok.  Dan ini sudah terjadi karena penciptaan BufferSegment baru terjadi menggunakan kumpulan.  Salah satu opsi di PipeOptions adalah kumpulan memori.  Setelah itu, kumpulan yang ditentukan akan digunakan untuk membuat segmen baru.  Jika Anda tidak menentukan kumpulan memori Anda, ArrayPool standar akan digunakan, yang, seperti yang Anda ketahui, memiliki beberapa ember untuk berbagai ukuran array (masing-masing berikutnya 2 kali lebih besar dari sebelumnya) dan, ketika ditanya untuk ukuran tertentu, itu mencari ember dengan array ukuran yang sesuai (kemudian ada yang terdekat lebih besar atau sama).  Dengan demikian, buffer baru hampir pasti akan lebih besar dari yang Anda minta.  Ukuran minimum array di ArrayPool standar (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) adalah 16. Tapi jangan khawatir, ini adalah kumpulan array.  Oleh karena itu, dalam sebagian besar kasus, array tidak memberikan tekanan pada pemulung dan akan digunakan kembali. <br><br><h3>  # 2.5 <a href="">Rentang &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Ini bekerja sama, memberikan Rentang dari Memori. <br><br>  Jadi GetMemory () atau GetSpan () adalah metode utama untuk menulis.  Mereka memberi kita objek yang bisa kita tulis.  Untuk melakukan ini, kita tidak perlu mengalokasikan memori untuk array nilai baru, kita dapat menulis langsung ke struktur internal.  Yang mana yang akan digunakan terutama tergantung pada API yang Anda gunakan dan metode asinkron.  Namun, mengingat hal di atas, muncul pertanyaan.  Bagaimana pembaca tahu berapa banyak yang kami tulis?  Jika kami selalu menggunakan implementasi spesifik pool, yang memberikan array dengan ukuran yang persis sama seperti yang diminta, maka pembaca dapat membaca seluruh buffer sekaligus.  Namun, seperti yang telah kami katakan, kami dialokasikan buffer dengan probabilitas tinggi dari ukuran yang lebih besar.  Ini mengarah ke metode berikut yang diperlukan untuk operasi. <br><br><h3>  # 3 <a href="">void Advance (int byte)</a> </h3><br>  Metode sederhana yang mengerikan.  Dibutuhkan jumlah byte yang ditulis sebagai argumen.  Mereka menambah penghitung internal - _unflushedBytes dan _writingHeadBytesBuffered, yang namanya berbicara sendiri.  Ini juga memotong _writingHeadMemory persis ke jumlah byte yang ditulis (menggunakan metode Slice).  Oleh karena itu, setelah memanggil metode ini, Anda perlu meminta blok memori baru dalam bentuk Memori atau Rentang, Anda tidak dapat menulis ke yang sebelumnya.  Dan seluruh tubuh metode adalah bagian penting dan berjalan di bawah kunci. <br><br>  Tampaknya setelah ini pembaca dapat menerima data.  Tapi satu langkah lagi diperlukan. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (Pembatalan Pembatalan dibatalkan)</a> </h3><br>  Metode ini dipanggil setelah kami menulis data yang diperlukan ke Memori yang diterima dan menunjukkan berapa banyak kami menulis di sana.  Metode mengembalikan ValueTask, namun tidak asinkron (tidak seperti StreamPipeWriter turunannya).  ValueTask adalah tipe khusus (readonly struct) yang digunakan dalam kasus ketika sebagian besar panggilan tidak akan menggunakan asinkron, yaitu, semua data yang diperlukan akan tersedia pada saat panggilannya dan metode ini akan berakhir secara sinkron.  Di dalam, itu berisi data atau Tugas (kalau-kalau itu tidak berhasil secara serempak).  Itu tergantung pada keadaan properti _writerAwaitable.IsCompleted.  Jika kita mencari apa yang mengubah keadaan objek tunggu ini, kita akan melihat bahwa ini terjadi dengan syarat bahwa jumlah data yang belum diproses (tidak dikonsumsi) (ini tidak persis sama dengan yang belum dibaca (tidak diperiksa), akan dijelaskan kemudian) melebihi ambang tertentu (_pauseWriterThreshold).  Standarnya adalah 16 ukuran segmen.  Jika diinginkan, nilainya dapat diubah di PipeOptions.  Selain itu, metode ini memulai kelanjutan dari metode ReadAsync, jika ada yang diblokir. <br><br>  Mengembalikan FlushResult yang mengandung 2 properti - IsCanceled dan IsCompleted.  IsCanceled menunjukkan apakah Flush telah dibatalkan (panggilan CancelPendingFlush).  IsCompleted menunjukkan apakah PipeReader selesai (dengan memanggil metode Complete () atau CompleteAsync ()). <br>  Bagian utama dari metode ini dilakukan di bawah Locke Skywalker. <br><br>  Metode lain PipeWriter tidak menarik dari sudut pandang implementasi dan digunakan lebih jarang, oleh karena itu hanya deskripsi singkat yang akan diberikan. <br><br><h3>  # 5 batal Selesai (Pengecualian pengecualian = null) atau ValueTask CompleteAsync (Pengecualian pengecualian = null) </h3><br>  Pipa tanda ditutup untuk penulisan.  Setelah selesai, pengecualian akan dilemparkan ketika mencoba menggunakan metode untuk menulis.  Jika PipeReader telah selesai, seluruh instance Pipe juga selesai.  Sebagian besar pekerjaan dilakukan di bawah kunci. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Seperti namanya, ini melengkapi operasi FlushAsync () saat ini.  Ada lok. <br><br><h3>  # 7 void OnReaderCompleted (Tindakan &lt;Pengecualian, objek&gt; panggilan balik, status objek) </h3><br>  Menjalankan delegasi yang didelegasikan ketika pembaca selesai.  Ada juga kunci. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi</a> saat ini mengatakan bahwa metode ini mungkin tidak dipanggil pada beberapa keturunan PipeWriter dan akan dihapus di masa depan.  Karena itu, Anda tidak boleh mengikat logika dengan metode ini. <br><br><h2>  Pergi ke PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token PembatalanToken)</a> </h3><br>  Di sini, seperti FlushAsync, ValueTask dikembalikan, yang mengisyaratkan bahwa metode ini kebanyakan sinkron, tetapi tidak selalu.  Tergantung pada kondisi _readerAwaitable.  Seperti halnya FlushAsync, Anda perlu mengetahui kapan _readerAwaitable disetel menjadi tidak lengkap.  Ini terjadi ketika PipeReader membaca semuanya dari daftar (atau berisi data yang ditandai sebagai diperiksa dan membutuhkan lebih banyak data untuk melanjutkan).  Padahal, itu logis.  Dengan demikian, kita dapat menyimpulkan bahwa diinginkan untuk menyempurnakan Pipa untuk pekerjaan Anda, untuk mengatur semua pilihannya secara bijaksana, berdasarkan statistik yang diidentifikasi secara empiris.  Konfigurasi yang tepat akan mengurangi kemungkinan cabang eksekusi asinkron dan akan memungkinkan pemrosesan data yang lebih efisien.  Hampir seluruh metode dikelilingi oleh kunci. <br><br>  Mengembalikan <a href="">ReadResult yang</a> misterius.  Faktanya, ini hanya buffer + flag yang menunjukkan status operasi (IsCanceled - apakah ReadAsync dibatalkan dan IsCompleted menunjukkan apakah PipeWriter ditutup).  Dalam kasus ini, IsCompleted adalah nilai yang menunjukkan apakah metode PipeWriter Complete () atau CompleteAsync () dipanggil.  Jika metode ini dipanggil dengan pengecualian, maka itu akan dibuang ketika mencoba membaca. <br><br>  Buffer lagi memiliki tipe misterius - <a href="">ReadOnlySequence</a> .  Ini, pada gilirannya, adalah objek untuk mengandung <a href="">segmen (ReadOnlySequenceSegment) dari</a> awal dan akhir + awal dan akhir indeks di dalam segmen yang sesuai.  Yang sebenarnya menyerupai struktur kelas Pipe itu sendiri.  Omong-omong, BufferSegment adalah penerus dari ReadOnlySequenceSegment, yang menunjukkan bahwa itu digunakan di sana.  Berkat ini, Anda bisa menyingkirkan alokasi memori yang tidak perlu untuk transfer data dari penulis ke pembaca. <br>  ReadOnlySpan dapat diperoleh dari buffer untuk diproses lebih lanjut.  Untuk melengkapi gambar, Anda dapat memeriksa apakah buffer berisi satu ReadOnlySpan.  Jika mengandung, kita tidak perlu mengulangi koleksi dari satu elemen dan kita bisa mendapatkannya menggunakan properti First.  Jika tidak, Anda perlu memeriksa semua segmen di buffer dan memproses masing-masing ReadOnlySpan. <br><br>  Topik diskusi - di kelas ReadOnlySequence, tipe referensi nullable secara aktif digunakan dan ada goto (bukan untuk keluar dari bersarang dan tidak dalam kode yang dihasilkan) - khususnya, <a href="">di sini</a> <br><br>  Setelah diproses, Anda harus menjelaskan kepada instance Pipe bahwa kami telah membaca data. <br><br><h3>  # 2 <a href="">bool TryRead (hasil ReadResult)</a> </h3><br>  Versi sinkron.  Memungkinkan Anda mendapatkan hasilnya jika ya.  Jika belum ada, tidak seperti ReadAsync, ia tidak memblokir, tetapi mengembalikan false.  Juga di kunci. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition dikonsumsi, SequencePosition diperiksa)</a> </h3><br>  Dalam metode ini, Anda dapat menentukan berapa banyak byte yang kami baca dan berapa banyak yang diproses.  Data yang telah dibaca tetapi tidak diproses akan dikembalikan saat berikutnya dibaca.  Fitur ini mungkin tampak aneh pada pandangan pertama, tetapi ketika memproses aliran byte jarang diperlukan untuk memproses setiap byte secara individual.  Biasanya, data dipertukarkan menggunakan pesan.  Suatu situasi dapat muncul bahwa pembaca, ketika membaca, menerima satu pesan utuh dan bagian dari pesan kedua.  Seluruhnya harus diproses, dan bagian yang kedua harus dibiarkan lain kali sehingga ia datang bersama dengan bagian yang tersisa.  Metode AdvanceTo menerima SequencePosition, yang sebenarnya merupakan indeks segmen + di dalamnya.  Saat memproses semua yang telah dibaca ReadAsync, Anda dapat menentukan buffer.End.  Jika tidak, Anda harus secara eksplisit membuat posisi, menunjukkan segmen dan indeks tempat pemrosesan dihentikan.  Di bawah kap lok. <br>  Juga, jika jumlah informasi mentah kurang dari cacat yang diinstal (_resumeWriterThreshold), itu memulai kelanjutan PipeWriter jika diblokir.  Secara default, ambang ini adalah 8 volume segmen (setengah dari ambang batas pemblokiran). <br><br><h3>  Kekosongan # 4 Lengkap (Pengecualian pengecualian = nol) </h3><br>  Menyelesaikan PipeReader.  Jika PipeWriter selesai pada titik ini, maka seluruh instance Pipe berakhir.  Kunci di dalam. <br><br><h3>  # 5 batal CancelPendingRead () </h3><br>  Memungkinkan Anda membatalkan pembacaan yang saat ini diharapkan.  Locke. <br><br><h3>  # 6 void OnWriterCompleted (Tindakan &lt;Pengecualian, objek&gt; panggilan balik, status objek) </h3><br>  Memungkinkan Anda menentukan delegasi yang akan dieksekusi setelah menyelesaikan PipeWriter. <br>  Seperti metode serupa untuk PipeWriter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi memiliki</a> catatan yang sama yang akan dihapus.  Kunci di bawah tenda. <br><br><h2>  Contoh </h2><br><br>  Daftar di bawah ini menunjukkan contoh bekerja dengan pipa. <br>  Sejak diperkenalkannya .NET Core Span dan Memory, banyak kelas untuk bekerja dengan data telah ditambah dengan kelebihan menggunakan jenis ini.  Jadi skema interaksi umum akan kurang lebih sama.  Dalam contoh saya, saya menggunakan pipa untuk bekerja dengan pipa (saya suka kata-kata root), yaitu  saluran - objek OS untuk komunikasi antarproses.  API saluran baru saja diperluas untuk membaca data dalam Rentang dan Memori.  Versi asinkron menggunakan Memori, karena metode asinkron akan dikonversikan ke metode templat menggunakan mesin keadaan terhingga yang dihasilkan secara otomatis, di mana semua variabel lokal dan parameter metode disimpan, dan karena Span adalah ref readonly struct, masing-masing tidak dapat berada di heap, masing-masing, menggunakan Span dalam metode asinkron tidak dimungkinkan.  Tetapi ada juga versi sinkron dari metode yang memungkinkan Anda untuk menggunakan Span.  Dalam contoh saya, saya mencoba keduanya dan ternyata versi sinkron dalam situasi ini menunjukkan dirinya lebih baik.  Saat menggunakannya, pengumpulan sampah lebih sedikit, dan pemrosesan data lebih cepat.  Tapi ini hanya karena ada banyak data.  Jika terjadi situasi di mana tidak akan ada data pada saat mengajukan aplikasi untuk batch berikutnya, Anda harus menggunakan versi asinkron agar tidak membebani prosesor idle. <br>  Contohnya memiliki komentar yang menjelaskan beberapa poin.  Saya menarik perhatian Anda pada fakta bahwa terlepas dari kenyataan bahwa fragmen program yang bertanggung jawab untuk membaca dari pipa dan pemrosesan dipisahkan, ketika menulis ke file, data tersebut dibaca persis dari tempat di mana mereka ditulis ketika membaca dari pipa. <br><br><div class="spoiler">  <b class="spoiler_title">Evolusi bertahun-tahun demi fitur yang kuat - asinkron maine</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Penulis pipepata</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Dataprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Prosesor byte</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464921/">https://habr.com/ru/post/id464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464909/index.html">“Mereka mengawasi kita”: apa yang bisa terjadi pada minivan yang tidak mencolok tepat di bawah jendela Anda</a></li>
<li><a href="../id464913/index.html">"Know kaizen": filosofi apa ini untuk meningkatkan proses produksi</a></li>
<li><a href="../id464915/index.html">Optimisasi rekursi ekor JavaScript</a></li>
<li><a href="../id464917/index.html">Setelah cyberpunk: apa yang perlu Anda ketahui tentang genre fiksi ilmiah modern saat ini</a></li>
<li><a href="../id464919/index.html">Kontrol sumber daya bawaan RAM yang digunakan dalam aplikasi</a></li>
<li><a href="../id464925/index.html">Panduan Suara UX: situasi, pola, alat (dan sedikit dukungan moral)</a></li>
<li><a href="../id464927/index.html">Penambang ASIC bekas: risiko, verifikasi, dan hashrate yang ditambahkan</a></li>
<li><a href="../id464929/index.html">Pemuatan gambar browser yang malas (memuat atribut)</a></li>
<li><a href="../id464931/index.html">Sisipan assembler ... dalam C #?</a></li>
<li><a href="../id464933/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 4. Game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>