<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ¤ ğŸ§•ğŸ» ğŸš Pourquoi le portage sur un dÃ©bordement d'entier n'est pas une bonne idÃ©e ğŸ¥‘ â™¥ï¸ ğŸ“‹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentre sur le comportement non dÃ©fini et les optimisations du compilateur, en particulier dans le contexte d'un dÃ©bordement d'entier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi le portage sur un dÃ©bordement d'entier n'est pas une bonne idÃ©e</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/427683/">  <b>Cet article se concentre sur le comportement non dÃ©fini et les optimisations du compilateur, en particulier dans le contexte d'un dÃ©bordement d'entier signÃ©.</b> <br><br>  <b>Note du traducteur:</b> en russe, il n'y a pas de correspondance claire dans le contexte utilisÃ© du mot Â«wrapÂ» / Â«wrappingÂ».  Il existe un terme mathÃ©matique " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transfert</a> ", qui est proche du phÃ©nomÃ¨ne dÃ©crit, et le terme "indicateur de portage" est un mÃ©canisme permettant de dÃ©finir un indicateur dans les processeurs lors d'un dÃ©bordement d'entier.  Une autre option de traduction peut Ãªtre l'expression Â«rotation / retournement / rÃ©volution autour de zÃ©roÂ».  Il reflÃ¨te mieux le sens de Â«envelopperÂ» par rapport Ã  Â«transporterÂ», car  montre la transition des nombres en cas de dÃ©bordement de la plage positive Ã  la plage nÃ©gative.  Cependant, il s'est avÃ©rÃ© que ces mots semblent inhabituels dans le texte pour les lecteurs de test.  Pour simplifier, nous prendrons Ã  l'avenir le mot Â«transfertÂ» comme traduction du terme Â«envelopperÂ». <br><br>  Les compilateurs du langage C (et C ++) dans leur travail sont de plus en plus guidÃ©s par le concept de <i>comportement indÃ©fini</i> - la notion que le comportement d'un programme pour certaines opÃ©rations n'est pas rÃ©glementÃ© par la norme et que, lors de la gÃ©nÃ©ration de code objet, le compilateur a le droit de partir de l'hypothÃ¨se que le programme n'effectue pas de telles opÃ©rations.  De nombreux programmeurs se sont opposÃ©s Ã  cette approche, car le code gÃ©nÃ©rÃ© dans ce cas peut ne pas se comporter comme l'auteur du programme prÃ©vu.  Ce problÃ¨me devient de plus en plus aigu, car les compilateurs utilisent des mÃ©thodes d'optimisation plus sophistiquÃ©es, qui seront probablement basÃ©es sur le concept de comportement indÃ©fini. <br><a name="habracut"></a><br>  Dans ce contexte, un exemple avec un dÃ©passement d'entier signÃ© est indicatif.  La plupart des dÃ©veloppeurs C Ã©crivent du code pour les machines qui utilisent du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code supplÃ©mentaire</a> pour reprÃ©senter des entiers, et l'addition et la soustraction dans cette reprÃ©sentation sont implÃ©mentÃ©es exactement de la mÃªme maniÃ¨re, en arithmÃ©tique non signÃ©e.  Si la somme de deux entiers positifs avec un signe dÃ©borde - c'est-Ã -dire qu'elle devient plus grande que le type ne le permet - le processeur retournera une valeur qui, interprÃ©tÃ©e comme un complÃ©ment binaire du nombre signÃ©, sera considÃ©rÃ©e comme nÃ©gative.  Ce phÃ©nomÃ¨ne est appelÃ© Â«transfertÂ», car le rÃ©sultat, ayant atteint la limite supÃ©rieure de la plage de valeurs, est Â«transfÃ©rÃ©Â» et part de la limite infÃ©rieure. <br><br>  Pour cette raison, vous pouvez parfois voir ce code en C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a + <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; a) { <span class="hljs-comment"><span class="hljs-comment">//  puts("input too large!"); return; }</span></span></code> </pre> <br>  La tÃ¢che de l' <i>instruction if</i> est de dÃ©tecter une condition de dÃ©bordement (dans ce cas, elle se produit aprÃ¨s avoir ajoutÃ© 1000 Ã  la valeur de la variable <i>a</i> ) et de signaler une erreur.  Le problÃ¨me est qu'en C, le dÃ©bordement d'entier signÃ© est l'un des cas de comportement non dÃ©fini.  Pendant un certain temps, les compilateurs ont toujours considÃ©rÃ© ces conditions comme fausses: si vous ajoutez 1000 (ou tout autre nombre positif) Ã  un autre nombre, le rÃ©sultat ne peut pas Ãªtre infÃ©rieur Ã  la valeur initiale.  Si un dÃ©bordement se produit, alors il y a un comportement indÃ©fini, et ne pas autoriser cela est dÃ©jÃ  (apparemment) la prÃ©occupation du programmeur.  Par consÃ©quent, le compilateur peut dÃ©cider que l'opÃ©rateur conditionnel peut Ãªtre complÃ¨tement supprimÃ© Ã  des fins d'optimisation (aprÃ¨s tout, la condition est toujours fausse, elle n'affecte rien, vous pouvez donc vous en passer). <br><br>  Le problÃ¨me est qu'avec cette optimisation, le compilateur a supprimÃ© la vÃ©rification que le programmeur a ajoutÃ©e spÃ©cifiquement pour dÃ©tecter un comportement non dÃ©fini et le traiter.  Ici, vous pouvez voir comment cela se produit dans la pratique.  (Remarque: godbolt.org, le site oÃ¹ se trouve l'exemple, est trÃ¨s cool! Vous pouvez Ã©diter le code et voir immÃ©diatement comment les diffÃ©rents compilateurs le traitent, et il y en a beaucoup. ExpÃ©rimentez!).  Veuillez noter que le compilateur ne supprime pas la vÃ©rification du dÃ©bordement si vous changez le type en non signÃ©, car le comportement du dÃ©bordement non signÃ© en C est dÃ©fini (plus prÃ©cisÃ©ment, le rÃ©sultat est transfÃ©rÃ© avec une arithmÃ©tique non signÃ©e, donc le dÃ©bordement ne se produit pas rÃ©ellement). <br><br>  Est-ce donc faux?  Quelqu'un dit oui, bien qu'il soit Ã©vident que de nombreux dÃ©veloppeurs de compilateurs considÃ¨rent cette dÃ©cision comme lÃ©gale.  Si je comprends bien, les principaux arguments des partisans (edit: dÃ©pendante de l'implÃ©mentation) du transfert lors du dÃ©bordement sont les suivants: <br><br><ul><li>  Le dÃ©bordement est un comportement utile. </li><li>  La migration est le comportement attendu par les programmeurs. </li><li>  La sÃ©mantique du comportement de dÃ©bordement indÃ©fini ne fournit pas un avantage notable. </li><li>  Le standard du langage C pour un comportement non dÃ©fini permet Ã  l'implÃ©mentation Â«d'ignorer complÃ¨tement la situation et le rÃ©sultat sera imprÃ©visibleÂ», mais cela ne donne pas au compilateur le droit d'optimiser le code en supposant que la situation avec un comportement non dÃ©fini ne se produit pas du tout. </li></ul><br>  Analysons tour Ã  tour chaque Ã©lÃ©ment: <br><br>  <b>Migration de dÃ©bordement - Comportement utile?</b> <br><br>  La migration est utile principalement lorsque vous devez suivre un dÃ©bordement qui s'est dÃ©jÃ  produit.  (S'il y a d'autres problÃ¨mes qui peuvent Ãªtre rÃ©solus par transfert et ne peuvent pas Ãªtre rÃ©solus en utilisant des variables entiÃ¨res non signÃ©es, je ne peux pas rappeler immÃ©diatement de tels exemples, et je soupÃ§onne qu'il y en a peu).  Bien que le transfert simplifie vraiment le problÃ¨me de l'utilisation de variables incorrectement dÃ©bordÃ©es, ce n'est certainement pas une panacÃ©e (rappelez-vous la multiplication ou l'ajout de deux quantitÃ©s inconnues avec un signe inconnu). <br><br>  Dans des cas triviaux, lorsque le transfert vous permet simplement de suivre le dÃ©bordement qui s'est produit, il n'est pas difficile non plus de savoir Ã  l'avance s'il se produira.  Notre exemple peut Ãªtre rÃ©Ã©crit comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; INT_MAX - <span class="hljs-number"><span class="hljs-number">1000</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    puts("input too large!"); return; } int b = a + 1000;</span></span></code> </pre> <br>  Autrement dit, au lieu de calculer la somme, puis de dÃ©terminer si un dÃ©passement s'est produit ou non, en vÃ©rifiant la cohÃ©rence mathÃ©matique du rÃ©sultat, vous pouvez vÃ©rifier si la somme dÃ©passe le nombre maximal que le type convient.  (Si le signe des deux opÃ©randes est inconnu, la vÃ©rification devra Ãªtre trÃ¨s compliquÃ©e, mais il en va de mÃªme pour la vÃ©rification lors du transfert). <br><br>  Compte tenu de tout cela, je trouve l'argument peu convaincant que le transfert est utile dans la plupart des cas. <br><br>  <b>La migration est-elle attendue par les programmeurs?</b> <br><br>  Il est plus difficile de contester cet argument, car il est Ã©vident que le code d'au moins <i>certains</i> programmeurs C suppose une sÃ©mantique de transfert avec un dÃ©bordement d'entier signÃ©.  Mais ce fait Ã  lui seul ne suffit pas pour considÃ©rer une telle sÃ©mantique prÃ©fÃ©rable (notez que certains compilateurs vous permettent de l'activer si nÃ©cessaire). <br><br>  Une solution Ã©vidente au problÃ¨me (les programmeurs s'attendent Ã  ce comportement) consiste Ã  obliger le compilateur Ã  donner un avertissement lorsqu'il optimise le code, en supposant qu'il n'y a pas de comportement non dÃ©fini.  Malheureusement, comme nous l'avons vu dans l'exemple sur godbolt.org en utilisant le lien ci-dessus, les compilateurs ne le font pas toujours (Gcc version 7.3 - oui, mais version 8.1 - non, donc il y a un pas en arriÃ¨re). <br><br>  <b>La sÃ©mantique du comportement de dÃ©bordement indÃ©fini ne donne-t-elle aucun avantage notable?</b> <br><br>  Si cette remarque est vraie dans tous les cas, elle servirait d'argument fort en faveur du fait que les compilateurs devraient adhÃ©rer Ã  la sÃ©mantique de transfert par dÃ©faut, car il serait probablement prÃ©fÃ©rable d'autoriser les vÃ©rifications de dÃ©bordement, mÃªme si ce mÃ©canisme est incorrect d'un point de vue technique - bien que serait parce qu'il peut Ãªtre utilisÃ© dans du code potentiellement cassÃ©. <br><br>  Je suppose que cette optimisation (suppression des vÃ©rifications de conditions mathÃ©matiquement contradictoires) dans les programmes C ordinaires peut souvent Ãªtre nÃ©gligÃ©e, car leurs auteurs s'efforcent d'obtenir les meilleures performances et optimisent toujours le code manuellement: c'est-Ã -dire, s'il est Ã©vident que cette <i>instruction if</i> contient une condition , ce qui ne sera jamais vrai, le programmeur est susceptible de le supprimer lui-mÃªme.  En fait, j'ai dÃ©couvert que dans plusieurs Ã©tudes l'efficacitÃ© d'une telle optimisation Ã©tait remise en question, testÃ©e et jugÃ©e pratiquement insignifiante dans le cadre des tests de contrÃ´le.  Cependant, bien que cette optimisation ne donne presque jamais un avantage dans le langage C, les gÃ©nÃ©rateurs de code et les optimisations de compilateur sont pour la plupart universels et peuvent Ãªtre utilisÃ©s dans d'autres langages - et pour eux, cette conclusion peut Ãªtre incorrecte.  Prenons le langage C ++ avec sa tradition, disons, de s'appuyer sur l'optimiseur pour supprimer les constructions redondantes dans le code du modÃ¨le, plutÃ´t que de le faire manuellement.  Mais il y a des langages qui sont convertis par le transporteur en C, et le code redondant qu'ils contiennent est Ã©galement optimisÃ© par les compilateurs C. <br><br>  De plus, mÃªme si vous continuez Ã  vÃ©rifier les dÃ©bordements, ce n'est pas du tout un fait que le coÃ»t <i>direct</i> du transfert de variables entiÃ¨res sera minime mÃªme sur les machines utilisant du code supplÃ©mentaire.  L'architecture Mips, par exemple, ne peut effectuer des opÃ©rations arithmÃ©tiques que dans des registres de taille fixe (32 bits).  Le type <i>short int</i> , en rÃ¨gle gÃ©nÃ©rale, a une taille de 16 bits et <i>char</i> - 8 bits;  lorsqu'une variable d'un de ces types est stockÃ©e dans le registre, sa taille augmente et pour la transfÃ©rer correctement, il sera nÃ©cessaire d'effectuer au moins une opÃ©ration supplÃ©mentaire et, Ã©ventuellement, d'utiliser un registre supplÃ©mentaire (pour accueillir le masque de bits correspondant).  Je dois admettre que je n'ai pas traitÃ© le code pour Mips depuis longtemps, donc je ne suis pas sÃ»r du coÃ»t exact de ces opÃ©rations, mais je suis sÃ»r qu'il n'est pas nul et que les mÃªmes problÃ¨mes peuvent se produire sur d'autres architectures RISC. <br><br>  <b>Une norme de langage interdit-elle dâ€™Ã©viter lâ€™encapsulage des variables sâ€™il est prÃ©vu par lâ€™architecture?</b> <br><br>  Si vous regardez, cet argument est particuliÃ¨rement faible.  Son essence est que la norme ne permet Ã  l'implÃ©mentation (compilateur) d'interprÃ©ter le Â«comportement indÃ©finiÂ» que dans une mesure limitÃ©e.  Dans le texte de la norme elle-mÃªme - dans ce fragment auquel les dÃ©fenseurs du transfert font appel - ce qui suit est dit (cela fait partie de la dÃ©finition du terme Â«comportement indÃ©finiÂ»): <br><br>  REMARQUE: Un <i>comportement indÃ©fini peut prendre la forme d'ignorer complÃ¨tement la situation, tandis que le rÃ©sultat sera imprÃ©visible, ...</i> <br><br>  L'idÃ©e est que les mots Â«ignorant complÃ¨tement la situationÂ» ne suggÃ¨rent pas qu'un Ã©vÃ©nement conduisant Ã  un comportement indÃ©fini - par exemple, un dÃ©bordement lors de l'ajout - ne peut pas se produire, mais plutÃ´t que si c'est le cas, le compilateur devrait continuer Ã  fonctionner comme s'il Ã©tait dans que jamais, mais tenez Ã©galement compte du rÃ©sultat qui se produira s'il envoie au processeur une demande pour effectuer une telle opÃ©ration (en d'autres termes, comme si le code source Ã©tait traduit dans le code machine de maniÃ¨re simple et naÃ¯ve). <br><br>  Tout d'abord, il convient de noter que ce texte est donnÃ© en tant que Â«noteÂ», et n'est donc pas normatif (c'est-Ã -dire qu'il ne peut pas prescrire quelque chose), selon la directive ISO mentionnÃ©e dans l'introduction de la norme: <br><br>  <i>ConformÃ©ment Ã  la partie 3 des directives ISO / CEI, cette prÃ©face, introduction au texte, notes, notes de bas de page et exemples est Ã©galement Ã  titre informatif uniquement.</i> <br><br>  Puisque ce passage Â«comportement indÃ©finiÂ» est une note, il ne prescrit rien.  Veuillez noter que la dÃ©finition actuelle de Â«comportement indÃ©finiÂ» est: <br><br>  <i>comportement rÃ©sultant de l'utilisation d'une conception logicielle intolÃ©rable ou incorrecte ou de donnÃ©es incorrectes, Ã  laquelle la</i> <b><i>prÃ©sente Norme internationale n'impose aucune exigence</i></b> <i>.</i> <br><br>  J'ai soulignÃ© l'idÃ©e principale: aucune exigence n'est imposÃ©e pour un comportement indÃ©fini;  la liste des Â«types possibles de comportement indÃ©finiÂ» dans la note ne contient que des exemples et ne peut pas Ãªtre la prescription finale.  L'expression Â«ne fait aucune demandeÂ» ne peut Ãªtre interprÃ©tÃ©e autrement. <br><br>  Certains, dÃ©veloppant cet argument, soutiennent que, quel que soit le texte, le comitÃ© de langue, lorsqu'il a formulÃ© ces mots, <i>signifiait</i> que le comportement dans son ensemble devrait correspondre Ã  l'architecture du matÃ©riel sur lequel le programme s'exÃ©cute, autant que possible, impliquant une traduction naÃ¯ve en code machine.  Cela peut Ãªtre vrai, mÃªme si je n'ai vu aucune preuve (par exemple, des documents historiques) Ã  l'appui de cet argument.  Cependant, mÃªme s'il en Ã©tait ainsi, ce n'est pas un fait que cette dÃ©claration s'applique Ã  la version actuelle du texte. <br><br>  <b>DerniÃ¨res pensÃ©es</b> <br><br>  Les arguments en faveur du transfert sont largement intenables.  Peut-Ãªtre l'argument le plus fort est-il obtenu si nous les combinons: les programmeurs moins expÃ©rimentÃ©s (qui ne connaissent pas les subtilitÃ©s du langage C et le comportement indÃ©fini qu'il contient) s'attendent parfois Ã  un transfert, et cela ne rÃ©duit pas les performances - bien que ce dernier ne soit pas vrai dans tous les cas, et la premiÃ¨re partie n'est pas concluante si vous le considÃ©rez sÃ©parÃ©ment. <br><br>  Personnellement, je prÃ©fÃ©rerais que les dÃ©bordements soient bloquÃ©s (piÃ©geage) plutÃ´t que d'envelopper.  Autrement dit, de sorte que le programme se bloque et ne continue pas Ã  fonctionner - avec un comportement incertain ou des rÃ©sultats potentiellement incorrects, car dans les deux cas, une vulnÃ©rabilitÃ© apparaÃ®t.  Une telle solution, bien sÃ»r, rÃ©duira lÃ©gÃ¨rement les performances sur la plupart des (?) Architectures, en particulier sur x86, mais, d'autre part, les erreurs de dÃ©bordement seront immÃ©diatement identifiÃ©es et elles ne pourront pas tirer parti ou obtenir des rÃ©sultats incorrects en les utilisant en cours de route. programmes.  De plus, en thÃ©orie, les compilateurs avec cette approche pourraient supprimer en toute sÃ©curitÃ© les contrÃ´les de dÃ©bordement redondants, car cela <i>ne</i> se produira <i>certainement</i> pas, bien que, comme je le vois, ni Clang ni GCC ne saisissent cette occasion. <br><br>  Heureusement, Ã  la fois l'interruption et le portage sont implÃ©mentÃ©s dans le compilateur que j'utilise le plus souvent est GCC.  Pour basculer entre les modes, les arguments de ligne de commande <i>-ftrapv</i> et <i>-fwrapv</i> sont respectivement utilisÃ©s. <br><br>  Bien sÃ»r, il existe de nombreuses actions conduisant Ã  un comportement indÃ©fini - le dÃ©bordement d'entier n'est que l'une d'entre elles.  Je ne pense pas du tout qu'il soit utile d'interprÃ©ter tous ces cas comme un comportement indÃ©fini, et je suis sÃ»r qu'il existe de nombreuses situations spÃ©cifiques oÃ¹ la sÃ©mantique doit Ãªtre dÃ©terminÃ©e par le langage ou, du moins, Ãªtre laissÃ©e Ã  la discrÃ©tion des implÃ©mentations.  Et j'ai peur des interprÃ©tations trop libres de ce concept par les fabricants de compilateurs: si le comportement du compilateur ne rÃ©pond pas aux idÃ©es intuitives des dÃ©veloppeurs, en particulier de ceux qui lisent personnellement le texte de la norme, cela peut conduire Ã  de vraies erreurs;  si le gain de performance dans ce cas est nÃ©gligeable, il vaut mieux abandonner de telles interprÃ©tations.  Dans l'un des articles suivants, j'examinerai probablement certains de ces problÃ¨mes. <br><br>  SupplÃ©ment (datÃ© du 24 aoÃ»t 2018) <br><br>  J'ai rÃ©alisÃ© qu'une grande partie de ce qui prÃ©cÃ¨de pourrait Ãªtre mieux Ã©crite.  Ci-dessous, je rÃ©sume et explique briÃ¨vement mes paroles et j'ajoute quelques remarques mineures: <br><br><ul><li>  Je n'ai pas soutenu qu'un comportement indÃ©fini est prÃ©fÃ©rable Ã  un dÃ©bordement - plutÃ´t que, <i>dans la pratique, le</i> transfert n'est <i>pas beaucoup mieux qu'un</i> comportement indÃ©fini.  En particulier, des problÃ¨mes de sÃ©curitÃ© peuvent Ãªtre obtenus dans le premier cas, et dans le second - et je parie que de nombreuses vulnÃ©rabilitÃ©s causÃ©es par des dÃ©bordements qui n'ont pas Ã©tÃ© dÃ©tectÃ©es Ã  temps (Ã  l'exception de celles pour lesquelles le compilateur est responsable de la suppression des vÃ©rifications erronÃ©es) provenaient en fait de - en raison du transfert du rÃ©sultat, mais pas en raison d'un comportement indÃ©fini associÃ© au dÃ©bordement. </li><li>  Le seul vÃ©ritable avantage du transfert est que les contrÃ´les de dÃ©passement de capacitÃ© ne sont pas supprimÃ©s.  Bien que de cette faÃ§on, vous puissiez protÃ©ger le code de certains scÃ©narios d'attaque, il est probable que certains dÃ©bordements ne seront pas vÃ©rifiÃ©s du tout (c'est-Ã -dire que le programmeur oubliera d'ajouter une telle vÃ©rification) et passera inaperÃ§u. </li><li>  Si le problÃ¨me de sÃ©curitÃ© n'est pas si important et que la vitesse Ã©levÃ©e du programme apparaÃ®t, alors un comportement indÃ©fini donnera une optimisation plus rentable et une augmentation plus importante de la productivitÃ©, au moins dans certains cas.  D'un autre cÃ´tÃ©, si la sÃ©curitÃ© passe avant tout, le portage est lourd de vulnÃ©rabilitÃ©s. </li><li>  Cela signifie que si vous choisissez entre interruption, transfert et comportement indÃ©fini, il y a trÃ¨s peu de tÃ¢ches dans lesquelles le transfert peut Ãªtre utile. </li><li>  En ce qui concerne les vÃ©rifications du dÃ©bordement qui s'est produit, je pense que les laisser est nocif, car cela crÃ©e la fausse impression qu'elles fonctionnent et fonctionneront toujours.  L'interruption des dÃ©bordements Ã©vite ce problÃ¨me;  avertissements adÃ©quats - attÃ©nuez-le. </li><li>  Je pense que tout dÃ©veloppeur qui Ã©crit du code critique pour la sÃ©curitÃ© devrait idÃ©alement avoir une bonne maÃ®trise de la sÃ©mantique du langage dans lequel il Ã©crit, et Ãªtre conscient de ses piÃ¨ges.  Pour C, cela signifie que vous devez connaÃ®tre la sÃ©mantique du dÃ©bordement et les subtilitÃ©s d'un comportement indÃ©fini.  Il est triste que certains programmeurs n'aient pas atteint ce niveau. </li><li>  J'ai dÃ©couvert que Â«la plupart des programmeurs C s'attendent Ã  ce que la migration soit le comportement par dÃ©fautÂ», mais je n'en connais pas les preuves.  (Dans l'article, j'ai Ã©crit Â«quelques programmeursÂ», parce que je connais plusieurs exemples de la vie rÃ©elle, et en gÃ©nÃ©ral je doute que quiconque conteste cela). </li><li>  Il y a deux problÃ¨mes diffÃ©rents: ce que la norme de langage C requiert et ce que les compilateurs doivent implÃ©menter.  J'aime (gÃ©nÃ©ralement) la faÃ§on dont la norme dÃ©finit le comportement de dÃ©bordement non dÃ©fini.  Dans cet article, je parle de ce que les compilateurs devraient faire. </li><li>  Lorsque le dÃ©bordement est interrompu, il n'est pas nÃ©cessaire de vÃ©rifier chaque opÃ©ration pour cela.  IdÃ©alement, le programme avec cette approche se comporte de maniÃ¨re cohÃ©rente en termes de rÃ¨gles mathÃ©matiques ou cesse de fonctionner.  Dans ce cas, l'existence d'un Â«dÃ©bordement temporaireÂ» devient possible, ce qui n'entraÃ®ne pas l'apparition d'un rÃ©sultat incorrect.  Ensuite, l'expression <i>a + b - b</i> et l'expression <i>(a * b) / b</i> peuvent Ãªtre optimisÃ©es en <i>a</i> (la premiÃ¨re est Ã©galement possible pendant le transfert, mais la seconde n'est plus prÃ©sente). </li></ul><br>  <b>Remarque</b>  Une traduction de l'article est publiÃ©e sur le blog avec la permission de l'auteur.  Texte original: Davin McCall " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Envelopper le dÃ©bordement d'entier n'est pas une bonne idÃ©e</a> ". <br><br>  Liens connexes supplÃ©mentaires de l'Ã©quipe PVS-Studio: <br><br><ol><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un comportement indÃ©fini est plus proche que vous ne le pensez</a> . </li><li>  Will Dietz, Peng Li, John Regehr et Vikram Adve.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre le dÃ©passement d'entier en C / C ++</a> . </li><li>  V1026.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La variable est incrÃ©mentÃ©e dans la boucle.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un comportement non dÃ©fini se produira en cas de dÃ©passement d'entier signÃ©</a> . </li><li>  Stackoverflow  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le dÃ©passement d'entier signÃ© est-il toujours un comportement non dÃ©fini en C ++?</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427683/">https://habr.com/ru/post/fr427683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427671/index.html">Sberbank et Yandex ont officiellement lancÃ© la plateforme de trading Beru, la version russe d'Amazon</a></li>
<li><a href="../fr427673/index.html">Apprentissage automatique @ booking.com</a></li>
<li><a href="../fr427675/index.html">Papiers, s'il vous plaÃ®t. Comment un rÃ©seau de neurones nous aide Ã  vÃ©rifier les clients et Ã  attraper les escrocs</a></li>
<li><a href="../fr427679/index.html">La rÃ©duction Ã  zÃ©ro de la limite des achats hors taxes prendra un an et demi, si une dÃ©cision est prise</a></li>
<li><a href="../fr427681/index.html">Faites glisser et faites glisser dans RecyclerView. Partie 1: ItemTouchHelper</a></li>
<li><a href="../fr427685/index.html">FSB contre Internet par satellite d'opÃ©rateurs Ã©trangers</a></li>
<li><a href="../fr427687/index.html">Renvoi pour des applications commerciales | Architecture de DentalTap</a></li>
<li><a href="../fr427689/index.html">BiÃ¨re directement du cloud</a></li>
<li><a href="../fr427691/index.html">CrÃ©ation d'un bot de chat simple dans VK sur Python 3</a></li>
<li><a href="../fr427693/index.html">Le livre Â«Gravity. La derniÃ¨re tentation d'Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>