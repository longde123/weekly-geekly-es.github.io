<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ 🌈 🏳️ 移动OAuth 2.0的安全性 🌔 🧙🏼 👶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="移动应用程序的受欢迎程度持续增长。 移动应用程序上的OAuth 2.0协议也是如此。 仅仅实现标准以使OAuth 2.0协议在那里安全是不够的。 需要考虑移动应用程序的细节并应用一些其他安全机制。 

 在本文中，我想分享用于防止此类问题的移动OAuth 2.0攻击和安全机制的概念。 所描述的概念不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>移动OAuth 2.0的安全性</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/456702/"><img src="https://habrastorage.org/getpro/habr/post_images/def/8b1/158/def8b1158655952902bf05be9fb7f308.jpg" alt="图片"><br><br> 移动应用程序的受欢迎程度持续增长。 移动应用程序上的OAuth 2.0协议也是如此。 仅仅实现标准以使OAuth 2.0协议在那里安全是不够的。 需要考虑移动应用程序的细节并应用一些其他安全机制。 <br><br> 在本文中，我想分享用于防止此类问题的移动OAuth 2.0攻击和安全机制的概念。 所描述的概念不是新概念，但是缺少有关此主题的结构化信息。 本文的主要目的是填补这一空白。 <br><a name="habracut"></a><br><h1>  OAuth 2.0的性质和目的 </h1><br>  OAuth 2.0是一种<i>授权</i>协议，描述了客户端服务获得对服务提供商上用户资源的安全访问的方法。 借助OAuth 2.0，用户无需在服务提供商外部输入密码：整个过程简化为单击“我同意提供对...的访问权限”按钮。 <br><br> 提供者是拥有用户数据的服务，并在用户许可下，为第三方服务（客户端）提供对此数据的安全访问。 客户端是想要获取提供者存储的用户数据的应用程序。 <br><br>  OAuth 2.0协议发布后不久，它就进行了<i>身份验证</i> ，尽管它并不是为了实现此目的。 使用OAuth 2.0进行身份验证会将攻击向量从服务提供商处存储的数据转移到客户端服务用户帐户。 <br><br> 但是身份验证只是一个开始。 在移动应用和赞美转化的时代，仅需一个按钮即可访问应用。 开发人员将OAuth 2.0修改为可移动使用。 当然，很少有人担心移动应用程序的安全性和特性：zap进入他们的生产！ 再说一次，OAuth 2.0在Web应用程序之外无法正常运行：移动和桌面应用程序中都存在相同的问题。 <br><br> 因此，让我们找出如何使移动OAuth 2.0安全。 <br><br><h1> 如何运作？ </h1><br> 存在两个主要的移动OAuth 2.0安全问题： <br><br><ol><li> 不受信任的客户。 某些移动应用程序没有OAuth 2.0的后端，因此协议流的客户端部分位于移动设备上。 <br></li><li> 从浏览器重定向到移动应用程序的行为会有所不同，具体取决于系统设置，应用程序的安装顺序和其他功能。 <br></li></ol><br> 让我们深入研究这些问题。 <br><br><h4> 移动应用程序是公共客户端 </h4><br> 为了了解第一个问题的根源和后果，让我们看看在服务器到服务器交互的情况下OAuth 2.0是如何工作的，然后在客户机到服务器交互的情况下将其与OAuth 2.0进行比较。 <br><br> 在这两种情况下，都以客户端服务在提供者服务上的注册开始，并接收<code>client_id</code>和<code>,</code>在某些情况下为<code>, client_secret. client_id</code>  <code>, client_secret. client_id</code>是一个公共值，它是客户端服务标识所必需的，而<code>client_secret</code>值是私有的。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 7591中</a>阅读有关注册过程的更多信息。 <br><br> 以下方案显示了在服务器到服务器交互的情况下OAuth 2.0的运行方式。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a6/689/61f/9a668961fd270118492bec6134a1aca9.png"><br>  <i>图片来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  OAuth 2.0协议可分为三个主要步骤： <br><br><ol><li>  [步骤AC]接收<code>authorization_code</code> （以下称为<code>code</code> ）。 <br></li><li>  [步骤DE]将<code>code</code>交换到<code>access_token</code> 。 <br></li><li> 通过<code>access_token</code>获取资源。 </li></ol><br><br> 让我们详细说明获得<code>code</code>值的过程： <br><br><ol><li>  [步骤A]客户端将用户重定向到服务提供商。 <br></li><li>  [步骤B]服务提供商向用户请求许可以向客户端提供数据（箭头B向上）。 用户提供数据访问权限（右侧的箭头B）。 <br></li><li>  [步骤C]服务提供商将<code>code</code>返回到用户浏览器，后者将<code>code</code>重定向到客户端。 <br></li></ol><br> 让我们更多地讨论获取<code>access_token</code>的过程： <br><br><ol><li>  [步骤D]客户端服务器发送一个<code>access_token</code>请求。  <code>Code</code> ， <code>client_secret</code>和<code>redirect_uri</code>包含在请求中。 <br></li><li>  [步骤E]在有效<code>code</code> <code>client_secret</code>和<code>redirect_uri</code>情况下，提供<code>access_token</code> 。 <br></li></ol><br> 对<code>access_token</code>请求是根据服务器到服务器的方案完成的：因此，通常，攻击者必须破解客户端服务服务器或服务提供者服务器才能窃取<code>access_token</code> 。 <br><br> 现在，让我们看一下没有后端（客户端到服务器的交互）的移动OAuth 2.0方案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>图片来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br> 主要方案分为相同的主要步骤： <br><br><ol><li>  [图片中的步骤1-4]获取<code>code</code> 。 </li><li>  [图片中的步骤5-6]交换<code>code</code>到<code>access_token</code> </li><li> 通过<code>access_token</code>获得资源访问 </li></ol><br> 但是，在这种情况下，移动应用程序还具有服务器功能。 因此， <code>client_secret</code>将被嵌入到应用程序中。 结果， <code>client_secret</code>无法在移动设备上对攻击者隐藏。 嵌入式<code>client_secret</code>可以通过两种方式提取：通过分析应用程序到服务器的流量或通过反向工程。 两者都可以轻松实现，这就是为什么<code>client_secret</code>在移动设备上无用的原因。 <br><br> 您可能会问：“为什么我们不立即获得<code>access_token</code> ？” 您可能认为这多余的步骤是不必要的。 此外，还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予</a>方案，该方案允许客户端立即接收<code>access_token</code> 。 即使可以在某些情况下使用它， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予</a>也不适用于安全的移动OAuth 2.0。 <br><br><h4> 在移动设备上重定向 </h4><br> 通常， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自定义URI方案</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AppLink</a>机制用于浏览器到应用程序的重定向。 这两种机制都无法像浏览器自行重定向一样安全。 <br><br>  <i>自定义URI方案</i> （或深层链接）以以下方式使用：开发人员在部署之前确定应用程序方案。 该方案可以是任何方案，并且一个设备可以具有相同方案的多个应用程序。 <br><br> 当设备上的每个方案都与一个应用程序相对应时，这使事情变得容易。 但是，如果两个应用程序在一个设备上注册相同的方案怎么办？ 通过自定义URI方案联系时，操作系统如何决定打开哪个应用程序？  Android将显示一个窗口，其中包含一个应用程序的选择以及一个链接。  iOS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有为此提供程序</a> ，因此，可以打开任何一个应用程序。 无论如何，攻击者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就有机会拦截代码或access_token</a> 。 <br><br> 与自定义URI方案不同， <i>AppLink</i>保证打开正确的应用程序，但是此机制有几个缺陷： <br><br><ol><li> 每个服务客户都必须经过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">验证程序</a> 。 <br></li><li>  Android用户可以在设置中关闭特定应用程序的AppLink。 <br></li><li> 早于6.0的Android版本和早于9.0的iOS版本不支持AppLink。 <br></li></ol><br> 所有这些AppLink缺陷都会增加潜在服务客户端的学习难度，并且在某些情况下可能导致用户OAuth 2.0失败。 这就是为什么许多开发人员不选择AppLink机制来替代OAuth 2.0协议中的浏览器重定向的原因。 <br><br><h1> 好，那里有什么要攻击的？ </h1><br> 移动OAuth 2.0问题导致了一些特定的攻击。 让我们看看它们是什么以及它们如何工作。 <br><br><a name="1"></a><h4> 授权码拦截攻击 </h4><br> 让我们考虑用户设备具有合法应用程序（OAuth 2.0客户端）和恶意应用程序注册了与合法应用程序相同的方案的情况。 下图显示了攻击方案。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d79/b98/46e/d79b9846e18e85a546b32a5927cdd627.png"><br>  <i>图片来源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br> 这就是问题所在：第四步，浏览器通过“自定义URI方案”返回应用程序中的<code>code</code> ，因此，恶意应用程序可能会截获该<code>code</code> （因为它注册的程序与合法应用程序相同）。 然后，恶意应用将<code>code</code>更改为<code>access_token</code>并接收对用户数据的访问。 <br><br> 有什么保护？ 在某些情况下，您可以使用进程间通信。 我们稍后再讨论。 通常，您需要一个称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码交换证明密钥</a>的方案。 在下面的方案中进行了描述。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac2/289/967/ac2289967122b9d5f458e35ab2a0d902.png"><br>  <i>图片来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br> 客户请求有几个额外的参数： <code>code_verifier</code> ， <code>code_challenge</code> （在方案<code>t(code_verifier)</code> ）和<code>code_challenge_method</code> （在方案<code>t_m</code> ）。 <br><br>  <code>Code_verifier</code>是一个随机数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，最小长度为256位</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">只能使用一次</a> 。 因此，客户端必须为每个<code>code</code>请求生成一个新的<code>code_verifier</code> 。 <br><br>  <code>Code_challenge_method</code>这是转换函数的名称，主要是SHA-256。 <br><br>  <code>Code_challenge</code>是对<code>code_challenge_method</code>转换并在URL Safe Base64中进行编码的<code>code_challenge_method</code> 。 <br><br> 请求<code>code</code>时，必须根据<code>code_verifier</code>拦截（例如，来自设备系统日志），将<code>code_challenge</code>转换为<code>code_verifier</code>以拒绝攻击向量。 <br><br> 如果用户设备<b>不支持</b> SHA-256， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>client is allowed to use plain conversion of code_verifier</code></a> 。 在所有其他情况下，必须使用SHA-256。 <br><br> 此方案的工作方式如下： <br><br><ol><li> 客户端生成<code>code_verifier</code>并将其存储。 <br></li><li> 客户选择<code>code_challenge_method</code>并从<code>code_verifier</code>接收<code>code_verifier</code> 。 <br></li><li>  [步骤A]客户请求<code>code</code> ，其中<code>code_challenge</code>和<code>code_challenge_method</code>添加到请求中。 <br></li><li>  [步骤B]提供程序将<code>code_challenge</code>和<code>code_challenge_method</code>存储在服务器上，并将<code>code</code>返回给客户端。 <br></li><li>  [步骤C]客户端请求<code>access_token</code> ，并添加了<code>code_verifier</code> 。 <br></li><li> 提供者从传入的<code>code_verifier</code>接收到<code>code_verifier</code> ，然后将其与保存的<code>code_challenge</code>进行比较。 <br></li><li>  [步骤D]如果值匹配，则提供程序将给客户端<code>access_token</code> 。 <br></li></ol><br> 为了理解为什么<code>code_challenge</code>代码拦截，让我们从攻击者的角度来看协议流的外观。 <br><br><ol><li> 首先，合法的应用程序请求<code>code</code> （ <code>code_challenge</code>和<code>code_challenge_method</code>与<b>请求</b>一起<b>发送</b> ）。 <br></li><li> 恶意应用会拦截<code>code</code> （但不会拦截<code>code_challenge</code> ，因为代码<code>_challenge</code>不在响应中）。 <br></li><li> 恶意应用程序请求<code>access_token</code> （具有有效<code>code</code> ，但<b>没有</b>有效<code>code_verifier</code> ）。 <br></li><li> 服务器注意到<code>code_challenge</code>不匹配，并引发错误消息。 <br></li></ol><br> 请注意，攻击者无法猜测<code>code_verifier</code> （随机256位值！）或在日志中的某个位置找到它（因为第一个请求实际上发送了<code>code_challenge</code> ）。 <br><br> 因此， <code>code_challenge</code>回答了服务提供者的问题：“ <code>access_token</code>是由请求<code>code</code>的同一应用程序客户端请求的，还是由不同的应用程序客户端请求的？”。 <br><br><h4>  OAuth 2.0 CSRF </h4><br> 使用OAuth 2.0进行授权时，OAuth 2.0 CSRF相对无害。 使用OAuth 2.0进行身份验证时，情况完全不同。 在这种情况下，OAuth 2.0 CSRF通常会导致帐户接管。 <br><br> 让我们通过的士应用程序客户端和provider.com提供程序示例，进一步讨论符合OAuth 2.0的CSRF攻击。 首先，攻击者使用自己的设备登录到<code>attacker@provider.com</code>帐户，并接收出租车<code>code</code> 。 然后，他中断OAuth 2.0进程并生成一个链接： <br><br><pre> <code class="plaintext hljs">com.taxi.app://oauth? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4</code> </pre> <br> 然后，攻击者将该链接发送给受害者，例如以出租车物品的邮件或文本消息的形式。 受害者单击链接，出租车应用程序打开并接收<code>access_token</code> 。 结果，他们发现自己进入了<b>攻击者的</b>出租车帐户。 受害人不知道这一点，而是使用该帐户：出差，输入个人数据等。 <br><br> 现在，攻击者可以随时登录到受害者的出租车帐户，因为它已链接到<a href=""><code>attacker@provider.com</code></a> 。  CSRF登录攻击使违反者可以窃取帐户。 <br><br> 通常使用CSRF令牌（也称为<code>state</code> ）来拒绝CSRF攻击，OAuth 2.0也不例外。 如何使用CSRF令牌： <br><br><ol><li> 客户端应用程序生成CSRF令牌并将其保存在客户端的移动设备上。 <br></li><li> 客户端应用程序将CSRF令牌包含在<code>code</code>访问请求中。 <br></li><li> 服务器在响应中返回带有<code>code</code>的相同CSRF令牌。 <br></li><li> 客户端应用程序比较传入和保存的CSRF令牌。 如果它们的值匹配，则过程继续。 <br></li></ol><br>  CSRF令牌要求： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随机数</a>必须至少为256位，并且必须从良好的伪随机序列源中接收。 <br><br> 简而言之，CSRF令牌允许应用程序客户端回答以下问题：“是发起<code>access_token</code>请求的我还是有人试图欺骗我？”。 <br><br><h4> 硬编码的客户机密 </h4><br> 没有后端的移动应用程序有时会存储硬编码的<code>client_id</code>和<code>client_secret</code>值。 当然，可以通过逆向工程应用程序轻松提取它们。 <br><br> 公开<code>client_id</code>和<code>client_secret</code>很大程度上取决于信任服务提供者对特定的<code>client_id</code>和<code>client_secret</code>对的信任程度。 一个使用它们只是为了将一个客户端与另一个客户端区分开，而其他客户端则打开隐藏的API端点或对某些客户端设置较慢的速率限制。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么移动应用中的OAuth API密钥和机密不安全一文</a>详细介绍了该主题。 <br><br><h4> 恶意应用程式充当合法客户 </h4><br> 某些恶意应用程序可以模仿合法应用程序，并代表它们显示同意屏幕（同意屏幕是用户看到的屏幕：“我同意提供对...的访问权限”）。 用户可以单击“允许”，然后向恶意应用程序提供其数据。 <br><br>  Android和iOS提供了应用程序交叉检查的机制。 应用程序提供商可以确保客户端应用程序是合法的，反之亦然。 <br><br> 不幸的是，如果OAuth 2.0机制通过浏览器使用线程，则无法防御这种攻击。 <br><br><h4> 其他攻击 </h4><br> 我们仔细研究了移动OAuth 2.0专有的攻击。 但是，我们不要忘记原始的OAuth 2.0： <code>redirect_uri</code>替换，通过不安全连接进行的流量拦截等。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>了解更多信息。 <br><br><h1> 如何安全地做？ </h1><br> 我们已经了解了OAuth 2.0协议的工作原理以及它在移动设备上的漏洞。 现在，让我们将各个部分放在一起，以形成一个安全的移动OAuth 2.0方案。 <br><br><h4>  OAuth 2.0的好坏 </h4><br> 让我们从正确的方式使用同意屏幕开始。 移动设备有两种在移动应用程序中打开网页的方式。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/d1e/75a/740d1e75aedec07de286cf9d7fc49292.png"><br><br> 第一种方法是通过“浏览器自定义”选项卡（在图片的左侧）。  <b>注意</b> ：适用于Android的浏览器自定义标签称为Chrome自定义标签，适用于iOS的名称为SafariViewController。 它只是应用程序中显示的浏览器选项卡：在应用程序之间没有视觉切换。 <br><br> 第二种方法是通过WebView（在图片的右侧），对于移动OAuth 2.0而言，我认为它很糟糕。 <br><br>  WebView是用于移动应用程序的嵌入式浏览器。 <br><br>  “ <i>嵌入式浏览器</i> ”表示WebView禁止访问Cookie，存储，缓存，历史记录以及其他Safari和Chrome数据。 反之亦然：Safari和Chrome无法访问WebView数据。 <br><br>  “ <i>移动应用程序浏览器</i> ”表示运行WebView的移动应用程序具有对Cookie，存储，缓存，历史记录和其他WebView数据的<b>完全</b>访问权限。 <br><br> 现在，想象一下：用户单击“输入...”，恶意应用程序的WebView向服务提供商请求其登录名和密码。 <br><br> 史诗失败： <br><br><ol><li> 用户在应用程序中输入其服务提供商帐户的登录名和密码，可以轻松窃取此数据。 <br></li><li>  OAuth 2.0最初是为了<i>不输入服务提供商的登录名和密码而开发的。</i> <i><br></i> <br> 用户习惯于在任何地方输入他的登录名和密码，从而增加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">钓鱼的</a>可能性。 <br></li></ol><br> 考虑到WebView的所有缺点，可以得出一个明显的结论：将“浏览器自定义选项卡”用于同意屏幕。 <br><br> 如果有人赞成使用WebView而不是“浏览器自定义选项卡”，那么如果您在注释中写到它，将不胜感激。 <br><br><h4> 安全的移动OAuth 2.0方案 </h4><br> 我们将使用授权代码授予方案，因为它允许我们添加<code>code_challenge</code>以及<code>state</code>和防御代码拦截攻击和OAuth 2.0 CSRF。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/ec8/faa/0aeec8faa00c4d5736e7cf7ad36977ed.png"><br>  <i>图片来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br> 代码访问请求（步骤1-2）如下所示： <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> 3D％3D＆ <code class="plaintext hljs">https://o2.mail.ru/code? redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; code_challenge_method=S256&amp; scope=email%2Cid&amp; response_type=code&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br> 在第3步中，浏览器将获得带有重定向的响应： <br><br><pre> <code class="plaintext hljs">com.mail.cloud.app://outh? code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; state=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> </pre> <br> 在步骤4，浏览器打开“自定义URI方案”，并将CSRF令牌传递给客户端应用。 <br>  <code>access_token</code>请求（步骤5）： <br><br><pre> <code class="plaintext hljs">https://o2.mail.ru/token? code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; client_id=984a644ec3b56d32b0404777e1eb73390c</code> </pre> <br> 最后一步带来了带有<code>access_token</code>的响应。 <br><br> 这种方案通常是安全的，但是在某些特殊情况下OAuth 2.0可以更简单，更安全。 <br><br><h4>  Android IPC </h4><br>  Android具有进程之间的双向数据通信机制：IPC（进程间通信）。  IPC优于自定义URI方案有两个原因： <br><br><ol><li> 打开IPC频道的应用程序可以通过其证书确认其打开的应用程序的真实性。 反之亦然：打开的应用程序可以确认打开它的应用程序的真实性。 <br></li><li> 如果发送方通过IPC通道发送请求，则可以通过同一通道接收答复。 与交叉检查（项目1）一起，这意味着没有外部进程可以拦截<code>access_token</code> 。 <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/d7c/1a9/dacd7c1a98a6d1c7227b7e8e5e24757f.png"><br><br> 因此，我们可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式授予</a>来简化移动OAuth 2.0方案。 没有<code>code_challenge</code>和<code>state</code>也意味着更少的攻击面。 我们还可以降低恶意应用像合法客户端试图窃取用户帐户的风险。 <br><br><h4> 客户专用SDK </h4><br> 除了实施此安全的移动OAuth 2.0方案外，提供商还应为其客户开发SDK。 它将简化客户端的OAuth 2.0实施，同时减少错误和漏洞的数量。 <br><br><h1> 结论 </h1><br> 让我为您总结一下。 这是OAuth 2.0提供程序的<i>安全OAuth 2.0</i>的（基本） <i>清单</i> ： <br><br><ol><li> 坚实的基础至关重要。 在移动OAuth 2.0的情况下，基础是为实现选择的方案或协议。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实施自己的OAuth 2.0方案</a>时很容易出错。 其他人已经敲门并吸取了教训。 从他们的错误中学习并一劳永逸地进行安全实施并没有错。  <i>如何安全地进行操作中</i>介绍了最安全的移动OAuth 2.0方案。 <br></li><li>  <code>Access_token</code>和其他敏感数据必须存储在iOS的钥匙串中和Android的内部存储中。 这些存储是专门为此而开发的。  Content Provider可以在Android中使用，但必须进行安全配置。 <br></li><li>  <code>Client_secret</code>是<b>无用的</b> ，除非它存储在后端。 不要将其赠送给公共客户。 <br></li><li> 不要将WebView用于同意屏幕； 使用浏览器自定义标签。 <br></li><li> 要防御代码拦截攻击，请使用<code>code_challenge</code> 。 <br></li><li> 要防御OAuth 2.0 CSRF，请使用<code>state</code> 。 <br></li><li>  <b>随处</b>使用HTTPS，禁止降级为HTTP。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3分钟的演示，</a>说明原因（并附有漏洞赏金示例）。 <br></li><li> 遵循加密<b>标准</b> （算法选择，令牌长度等）。 您可以复制数据并弄清楚为什么要这样做，但不要自行加密。 <br></li><li>  <code>Code</code>只能使用一次，并且使用寿命很短。 <br></li><li> 在应用客户端，检查您为OAuth 2.0打开的内容； 然后从应用提供商的角度，检查谁为您打开了OAuth 2.0。 <br></li><li> 请记住<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常见的OAuth 2.0漏洞</a> 。 移动OAuth 2.0会放大并完善原始OAuth 2.0，因此， <code>redirect_uri</code>检查是否完全匹配，并且其他针对原始OAuth 2.0的建议仍然有效。 <br></li><li> 您应该为客户提供SDK。 他们的错误和漏洞更少，并且他们可以更轻松地实现您的OAuth 2.0。 <br></li></ol><br><h1> 进一步阅读 </h1><br><ol><li>  “移动OAuth 2.0的漏洞” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.youtube.com/watch?v=vjCF_O6aZIg</a> <br></li><li>  OAuth 2.0竞争状况研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://hackerone.com/reports/55140</a> <br></li><li> 关于OAuth 2.0的几乎所有内容都集中在一个地方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://oauth.net/2/</a> <br></li><li> 为什么OAuth API密钥和秘密在移动应用程序中不安全<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps</a> <br></li><li>  [RFC]适用于本机应用程序的OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc8252</a> <br></li><li>  [RFC] OAuth公共客户端用于代码交换的证明密钥<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7636</a> <br></li><li>  [RFC] OAuth 2.0威胁模型和安全注意事项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc6819</a> <br></li><li>  [RFC] OAuth 2.0动态客户端注册协议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7591</a> <br></li><li> 适用于移动和桌面应用程序的Google OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> <br></li></ol><br><h1> 学分 </h1><br> 感谢所有帮助我写这篇文章的人。 特别是谢尔盖·贝洛夫（Sergei Belov），安德烈·苏敏（Andrei Sumin），安德烈·拉布涅（Andrey Labunets）提供了有关技术细节的反馈，帕维尔·克鲁格洛夫（Pavel Kruglov）提供了英文翻译，达里亚·雅科夫列娃（Daria Yakovleva）提供了本文俄语版的帮助。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456702/">https://habr.com/ru/post/zh-CN456702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456684/index.html">修复calc.exe中的一个小错误</a></li>
<li><a href="../zh-CN456686/index.html">聘请udalenka时面试的错综复杂</a></li>
<li><a href="../zh-CN456690/index.html">Case Guru的日常耳机-CGPods Sport</a></li>
<li><a href="../zh-CN456692/index.html">Visual Basic的兴衰</a></li>
<li><a href="../zh-CN456700/index.html">极客大学在产品管理学院招募人才</a></li>
<li><a href="../zh-CN456704/index.html">测试人员可以受益的六种方式（功能测试之外）</a></li>
<li><a href="../zh-CN456710/index.html">什么是低代码/无代码平台以及CRM，CRM +，ERP</a></li>
<li><a href="../zh-CN456712/index.html">SOAP服务的选择性流量记录</a></li>
<li><a href="../zh-CN456714/index.html">了解浮点数（第0部分）</a></li>
<li><a href="../zh-CN456716/index.html">数据不是很大</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>